/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	__webpack_require__(1);
	
	__webpack_require__(5);

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	__webpack_require__(2);

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	var require;var require;/* WEBPACK VAR INJECTION */(function(global, setImmediate) {(function(f){if(true){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.AFRAME = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return require(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
	'use strict';
	// For more information about browser field, check out the browser field at https://github.com/substack/browserify-handbook#browser-field.
	
	module.exports = {
	    // Create a <link> tag with optional data attributes
	    createLink: function(href, attributes) {
	        var head = document.head || document.getElementsByTagName('head')[0];
	        var link = document.createElement('link');
	
	        link.href = href;
	        link.rel = 'stylesheet';
	
	        for (var key in attributes) {
	            if ( ! attributes.hasOwnProperty(key)) {
	                continue;
	            }
	            var value = attributes[key];
	            link.setAttribute('data-' + key, value);
	        }
	
	        head.appendChild(link);
	    },
	    // Create a <style> tag with optional data attributes
	    createStyle: function(cssText, attributes) {
	        var head = document.head || document.getElementsByTagName('head')[0],
	            style = document.createElement('style');
	
	        style.type = 'text/css';
	
	        for (var key in attributes) {
	            if ( ! attributes.hasOwnProperty(key)) {
	                continue;
	            }
	            var value = attributes[key];
	            style.setAttribute('data-' + key, value);
	        }
	        
	        if (style.sheet) { // for jsdom and IE9+
	            style.innerHTML = cssText;
	            style.sheet.cssText = cssText;
	            head.appendChild(style);
	        } else if (style.styleSheet) { // for IE8 and below
	            head.appendChild(style);
	            style.styleSheet.cssText = cssText;
	        } else { // for Chrome, Firefox, and Safari
	            style.appendChild(document.createTextNode(cssText));
	            head.appendChild(style);
	        }
	    }
	};
	
	},{}],2:[function(_dereq_,module,exports){
	// shim for using process in browser
	
	var process = module.exports = {};
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = setTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    clearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        setTimeout(drainQueue, 0);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };
	
	},{}],3:[function(_dereq_,module,exports){
	
	/**
	 * This is the web browser implementation of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */
	
	exports = module.exports = _dereq_('./debug');
	exports.log = log;
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;
	exports.storage = 'undefined' != typeof chrome
	               && 'undefined' != typeof chrome.storage
	                  ? chrome.storage.local
	                  : localstorage();
	
	/**
	 * Colors.
	 */
	
	exports.colors = [
	  'lightseagreen',
	  'forestgreen',
	  'goldenrod',
	  'dodgerblue',
	  'darkorchid',
	  'crimson'
	];
	
	/**
	 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
	 * and the Firebug extension (any Firefox version) are known
	 * to support "%c" CSS customizations.
	 *
	 * TODO: add a `localStorage` variable to explicitly enable/disable colors
	 */
	
	function useColors() {
	  // is webkit? http://stackoverflow.com/a/16459606/376773
	  return ('WebkitAppearance' in document.documentElement.style) ||
	    // is firebug? http://stackoverflow.com/a/398120/376773
	    (window.console && (console.firebug || (console.exception && console.table))) ||
	    // is firefox >= v31?
	    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
	    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
	}
	
	/**
	 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
	 */
	
	exports.formatters.j = function(v) {
	  return JSON.stringify(v);
	};
	
	
	/**
	 * Colorize log arguments if enabled.
	 *
	 * @api public
	 */
	
	function formatArgs() {
	  var args = arguments;
	  var useColors = this.useColors;
	
	  args[0] = (useColors ? '%c' : '')
	    + this.namespace
	    + (useColors ? ' %c' : ' ')
	    + args[0]
	    + (useColors ? '%c ' : ' ')
	    + '+' + exports.humanize(this.diff);
	
	  if (!useColors) return args;
	
	  var c = 'color: ' + this.color;
	  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));
	
	  // the final "%c" is somewhat tricky, because there could be other
	  // arguments passed either before or after the %c, so we need to
	  // figure out the correct index to insert the CSS into
	  var index = 0;
	  var lastC = 0;
	  args[0].replace(/%[a-z%]/g, function(match) {
	    if ('%%' === match) return;
	    index++;
	    if ('%c' === match) {
	      // we only are interested in the *last* %c
	      // (the user may have provided their own)
	      lastC = index;
	    }
	  });
	
	  args.splice(lastC, 0, c);
	  return args;
	}
	
	/**
	 * Invokes `console.log()` when available.
	 * No-op when `console.log` is not a "function".
	 *
	 * @api public
	 */
	
	function log() {
	  // this hackery is required for IE8/9, where
	  // the `console.log` function doesn't have 'apply'
	  return 'object' === typeof console
	    && console.log
	    && Function.prototype.apply.call(console.log, console, arguments);
	}
	
	/**
	 * Save `namespaces`.
	 *
	 * @param {String} namespaces
	 * @api private
	 */
	
	function save(namespaces) {
	  try {
	    if (null == namespaces) {
	      exports.storage.removeItem('debug');
	    } else {
	      exports.storage.debug = namespaces;
	    }
	  } catch(e) {}
	}
	
	/**
	 * Load `namespaces`.
	 *
	 * @return {String} returns the previously persisted debug modes
	 * @api private
	 */
	
	function load() {
	  var r;
	  try {
	    r = exports.storage.debug;
	  } catch(e) {}
	  return r;
	}
	
	/**
	 * Enable namespaces listed in `localStorage.debug` initially.
	 */
	
	exports.enable(load());
	
	/**
	 * Localstorage attempts to return the localstorage.
	 *
	 * This is necessary because safari throws
	 * when a user disables cookies/localstorage
	 * and you attempt to access it.
	 *
	 * @return {LocalStorage}
	 * @api private
	 */
	
	function localstorage(){
	  try {
	    return window.localStorage;
	  } catch (e) {}
	}
	
	},{"./debug":4}],4:[function(_dereq_,module,exports){
	
	/**
	 * This is the common logic for both the Node.js and web browser
	 * implementations of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */
	
	exports = module.exports = debug;
	exports.coerce = coerce;
	exports.disable = disable;
	exports.enable = enable;
	exports.enabled = enabled;
	exports.humanize = _dereq_('ms');
	
	/**
	 * The currently active debug mode names, and names to skip.
	 */
	
	exports.names = [];
	exports.skips = [];
	
	/**
	 * Map of special "%n" handling functions, for the debug "format" argument.
	 *
	 * Valid key names are a single, lowercased letter, i.e. "n".
	 */
	
	exports.formatters = {};
	
	/**
	 * Previously assigned color.
	 */
	
	var prevColor = 0;
	
	/**
	 * Previous log timestamp.
	 */
	
	var prevTime;
	
	/**
	 * Select a color.
	 *
	 * @return {Number}
	 * @api private
	 */
	
	function selectColor() {
	  return exports.colors[prevColor++ % exports.colors.length];
	}
	
	/**
	 * Create a debugger with the given `namespace`.
	 *
	 * @param {String} namespace
	 * @return {Function}
	 * @api public
	 */
	
	function debug(namespace) {
	
	  // define the `disabled` version
	  function disabled() {
	  }
	  disabled.enabled = false;
	
	  // define the `enabled` version
	  function enabled() {
	
	    var self = enabled;
	
	    // set `diff` timestamp
	    var curr = +new Date();
	    var ms = curr - (prevTime || curr);
	    self.diff = ms;
	    self.prev = prevTime;
	    self.curr = curr;
	    prevTime = curr;
	
	    // add the `color` if not set
	    if (null == self.useColors) self.useColors = exports.useColors();
	    if (null == self.color && self.useColors) self.color = selectColor();
	
	    var args = Array.prototype.slice.call(arguments);
	
	    args[0] = exports.coerce(args[0]);
	
	    if ('string' !== typeof args[0]) {
	      // anything else let's inspect with %o
	      args = ['%o'].concat(args);
	    }
	
	    // apply any `formatters` transformations
	    var index = 0;
	    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
	      // if we encounter an escaped % then don't increase the array index
	      if (match === '%%') return match;
	      index++;
	      var formatter = exports.formatters[format];
	      if ('function' === typeof formatter) {
	        var val = args[index];
	        match = formatter.call(self, val);
	
	        // now we need to remove `args[index]` since it's inlined in the `format`
	        args.splice(index, 1);
	        index--;
	      }
	      return match;
	    });
	
	    if ('function' === typeof exports.formatArgs) {
	      args = exports.formatArgs.apply(self, args);
	    }
	    var logFn = enabled.log || exports.log || console.log.bind(console);
	    logFn.apply(self, args);
	  }
	  enabled.enabled = true;
	
	  var fn = exports.enabled(namespace) ? enabled : disabled;
	
	  fn.namespace = namespace;
	
	  return fn;
	}
	
	/**
	 * Enables a debug mode by namespaces. This can include modes
	 * separated by a colon and wildcards.
	 *
	 * @param {String} namespaces
	 * @api public
	 */
	
	function enable(namespaces) {
	  exports.save(namespaces);
	
	  var split = (namespaces || '').split(/[\s,]+/);
	  var len = split.length;
	
	  for (var i = 0; i < len; i++) {
	    if (!split[i]) continue; // ignore empty strings
	    namespaces = split[i].replace(/\*/g, '.*?');
	    if (namespaces[0] === '-') {
	      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
	    } else {
	      exports.names.push(new RegExp('^' + namespaces + '$'));
	    }
	  }
	}
	
	/**
	 * Disable debug output.
	 *
	 * @api public
	 */
	
	function disable() {
	  exports.enable('');
	}
	
	/**
	 * Returns true if the given mode name is enabled, false otherwise.
	 *
	 * @param {String} name
	 * @return {Boolean}
	 * @api public
	 */
	
	function enabled(name) {
	  var i, len;
	  for (i = 0, len = exports.skips.length; i < len; i++) {
	    if (exports.skips[i].test(name)) {
	      return false;
	    }
	  }
	  for (i = 0, len = exports.names.length; i < len; i++) {
	    if (exports.names[i].test(name)) {
	      return true;
	    }
	  }
	  return false;
	}
	
	/**
	 * Coerce `val`.
	 *
	 * @param {Mixed} val
	 * @return {Mixed}
	 * @api private
	 */
	
	function coerce(val) {
	  if (val instanceof Error) return val.stack || val.message;
	  return val;
	}
	
	},{"ms":5}],5:[function(_dereq_,module,exports){
	/**
	 * Helpers.
	 */
	
	var s = 1000;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var y = d * 365.25;
	
	/**
	 * Parse or format the given `val`.
	 *
	 * Options:
	 *
	 *  - `long` verbose formatting [false]
	 *
	 * @param {String|Number} val
	 * @param {Object} options
	 * @return {String|Number}
	 * @api public
	 */
	
	module.exports = function(val, options){
	  options = options || {};
	  if ('string' == typeof val) return parse(val);
	  return options.long
	    ? long(val)
	    : short(val);
	};
	
	/**
	 * Parse the given `str` and return milliseconds.
	 *
	 * @param {String} str
	 * @return {Number}
	 * @api private
	 */
	
	function parse(str) {
	  str = '' + str;
	  if (str.length > 10000) return;
	  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
	  if (!match) return;
	  var n = parseFloat(match[1]);
	  var type = (match[2] || 'ms').toLowerCase();
	  switch (type) {
	    case 'years':
	    case 'year':
	    case 'yrs':
	    case 'yr':
	    case 'y':
	      return n * y;
	    case 'days':
	    case 'day':
	    case 'd':
	      return n * d;
	    case 'hours':
	    case 'hour':
	    case 'hrs':
	    case 'hr':
	    case 'h':
	      return n * h;
	    case 'minutes':
	    case 'minute':
	    case 'mins':
	    case 'min':
	    case 'm':
	      return n * m;
	    case 'seconds':
	    case 'second':
	    case 'secs':
	    case 'sec':
	    case 's':
	      return n * s;
	    case 'milliseconds':
	    case 'millisecond':
	    case 'msecs':
	    case 'msec':
	    case 'ms':
	      return n;
	  }
	}
	
	/**
	 * Short format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */
	
	function short(ms) {
	  if (ms >= d) return Math.round(ms / d) + 'd';
	  if (ms >= h) return Math.round(ms / h) + 'h';
	  if (ms >= m) return Math.round(ms / m) + 'm';
	  if (ms >= s) return Math.round(ms / s) + 's';
	  return ms + 'ms';
	}
	
	/**
	 * Long format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */
	
	function long(ms) {
	  return plural(ms, d, 'day')
	    || plural(ms, h, 'hour')
	    || plural(ms, m, 'minute')
	    || plural(ms, s, 'second')
	    || ms + ' ms';
	}
	
	/**
	 * Pluralization helper.
	 */
	
	function plural(ms, n, name) {
	  if (ms < n) return;
	  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
	  return Math.ceil(ms / n) + ' ' + name + 's';
	}
	
	},{}],6:[function(_dereq_,module,exports){
	'use strict';
	var isObj = _dereq_('is-obj');
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;
	
	function toObject(val) {
		if (val === null || val === undefined) {
			throw new TypeError('Sources cannot be null or undefined');
		}
	
		return Object(val);
	}
	
	function assignKey(to, from, key) {
		var val = from[key];
	
		if (val === undefined || val === null) {
			return;
		}
	
		if (hasOwnProperty.call(to, key)) {
			if (to[key] === undefined || to[key] === null) {
				throw new TypeError('Cannot convert undefined or null to object (' + key + ')');
			}
		}
	
		if (!hasOwnProperty.call(to, key) || !isObj(val)) {
			to[key] = val;
		} else {
			to[key] = assign(Object(to[key]), from[key]);
		}
	}
	
	function assign(to, from) {
		if (to === from) {
			return to;
		}
	
		from = Object(from);
	
		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				assignKey(to, from, key);
			}
		}
	
		if (Object.getOwnPropertySymbols) {
			var symbols = Object.getOwnPropertySymbols(from);
	
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					assignKey(to, from, symbols[i]);
				}
			}
		}
	
		return to;
	}
	
	module.exports = function deepAssign(target) {
		target = toObject(target);
	
		for (var s = 1; s < arguments.length; s++) {
			assign(target, arguments[s]);
		}
	
		return target;
	};
	
	},{"is-obj":7}],7:[function(_dereq_,module,exports){
	'use strict';
	module.exports = function (x) {
		var type = typeof x;
		return x !== null && (type === 'object' || type === 'function');
	};
	
	},{}],8:[function(_dereq_,module,exports){
	/*! (C) WebReflection Mit Style License */
	(function(t,n,r,i){"use strict";function st(e,t){for(var n=0,r=e.length;n<r;n++)gt(e[n],t)}function ot(e){for(var t=0,n=e.length,r;t<n;t++)r=e[t],it(r,w[at(r)])}function ut(e){return function(t){F(t)&&(gt(t,e),st(t.querySelectorAll(E),e))}}function at(e){var t=R.call(e,"is"),n=e.nodeName.toUpperCase(),r=x.call(b,t?m+t.toUpperCase():v+n);return t&&-1<r&&!ft(n,t)?-1:r}function ft(e,t){return-1<E.indexOf(e+'[is="'+t+'"]')}function lt(e){var t=e.currentTarget,n=e.attrChange,r=e.attrName,i=e.target;Y&&(!i||i===t)&&t.attributeChangedCallback&&r!=="style"&&e.prevValue!==e.newValue&&t.attributeChangedCallback(r,n===e[f]?null:e.prevValue,n===e[c]?null:e.newValue)}function ct(e){var t=ut(e);return function(e){$.push(t,e.target)}}function ht(e){G&&(G=!1,e.currentTarget.removeEventListener(p,ht)),st((e.target||n).querySelectorAll(E),e.detail===u?u:o),j&&vt()}function pt(e,t){var n=this;U.call(n,e,t),Z.call(n,{target:n})}function dt(e,t){P(e,t),nt?nt.observe(e,X):(Q&&(e.setAttribute=pt,e[s]=tt(e),e.addEventListener(d,Z)),e.addEventListener(h,lt)),e.createdCallback&&Y&&(e.created=!0,e.createdCallback(),e.created=!1)}function vt(){for(var e,t=0,n=I.length;t<n;t++)e=I[t],S.contains(e)||(n--,I.splice(t--,1),gt(e,u))}function mt(e){throw new Error("A "+e+" type is already registered")}function gt(e,t){var n,r=at(e);-1<r&&(rt(e,w[r]),r=0,t===o&&!e[o]?(e[u]=!1,e[o]=!0,r=1,j&&x.call(I,e)<0&&I.push(e)):t===u&&!e[u]&&(e[o]=!1,e[u]=!0,r=1),r&&(n=e[t+"Callback"])&&n.call(e))}if(i in n)return;var s="__"+i+(Math.random()*1e5>>0),o="attached",u="detached",a="extends",f="ADDITION",l="MODIFICATION",c="REMOVAL",h="DOMAttrModified",p="DOMContentLoaded",d="DOMSubtreeModified",v="<",m="=",g=/^[A-Z][A-Z0-9]*(?:-[A-Z0-9]+)+$/,y=["ANNOTATION-XML","COLOR-PROFILE","FONT-FACE","FONT-FACE-SRC","FONT-FACE-URI","FONT-FACE-FORMAT","FONT-FACE-NAME","MISSING-GLYPH"],b=[],w=[],E="",S=n.documentElement,x=b.indexOf||function(e){for(var t=this.length;t--&&this[t]!==e;);return t},T=r.prototype,N=T.hasOwnProperty,C=T.isPrototypeOf,k=r.defineProperty,L=r.getOwnPropertyDescriptor,A=r.getOwnPropertyNames,O=r.getPrototypeOf,M=r.setPrototypeOf,_=!!r.__proto__,D=r.create||function yt(e){return e?(yt.prototype=e,new yt):this},P=M||(_?function(e,t){return e.__proto__=t,e}:A&&L?function(){function e(e,t){for(var n,r=A(t),i=0,s=r.length;i<s;i++)n=r[i],N.call(e,n)||k(e,n,L(t,n))}return function(t,n){do e(t,n);while((n=O(n))&&!C.call(n,t));return t}}():function(e,t){for(var n in t)e[n]=t[n];return e}),H=t.MutationObserver||t.WebKitMutationObserver,B=(t.HTMLElement||t.Element||t.Node).prototype,j=!C.call(B,S),F=j?function(e){return e.nodeType===1}:function(e){return C.call(B,e)},I=j&&[],q=B.cloneNode,R=B.getAttribute,U=B.setAttribute,z=B.removeAttribute,W=n.createElement,X=H&&{attributes:!0,characterData:!0,attributeOldValue:!0},V=H||function(e){Q=!1,S.removeEventListener(h,V)},$,J=t.requestAnimationFrame||t.webkitRequestAnimationFrame||t.mozRequestAnimationFrame||t.msRequestAnimationFrame||function(e){setTimeout(e,10)},K=!1,Q=!0,G=!0,Y=!0,Z,et,tt,nt,rt,it;M||_?(rt=function(e,t){C.call(t,e)||dt(e,t)},it=dt):(rt=function(e,t){e[s]||(e[s]=r(!0),dt(e,t))},it=rt),j?(Q=!1,function(){var t=L(B,"addEventListener"),n=t.value,r=function(e){var t=new CustomEvent(h,{bubbles:!0});t.attrName=e,t.prevValue=R.call(this,e),t.newValue=null,t[c]=t.attrChange=2,z.call(this,e),this.dispatchEvent(t)},i=function(t,n){var r=this.hasAttribute(t),i=r&&R.call(this,t);e=new CustomEvent(h,{bubbles:!0}),U.call(this,t,n),e.attrName=t,e.prevValue=r?i:null,e.newValue=n,r?e[l]=e.attrChange=1:e[f]=e.attrChange=0,this.dispatchEvent(e)},o=function(e){var t=e.currentTarget,n=t[s],r=e.propertyName,i;n.hasOwnProperty(r)&&(n=n[r],i=new CustomEvent(h,{bubbles:!0}),i.attrName=n.name,i.prevValue=n.value||null,i.newValue=n.value=t[r]||null,i.prevValue==null?i[f]=i.attrChange=0:i[l]=i.attrChange=1,t.dispatchEvent(i))};t.value=function(e,t,u){e===h&&this.attributeChangedCallback&&this.setAttribute!==i&&(this[s]={className:{name:"class",value:this.className}},this.setAttribute=i,this.removeAttribute=r,n.call(this,"propertychange",o)),n.call(this,e,t,u)},k(B,"addEventListener",t)}()):H||(S.addEventListener(h,V),S.setAttribute(s,1),S.removeAttribute(s),Q&&(Z=function(e){var t=this,n,r,i;if(t===e.target){n=t[s],t[s]=r=tt(t);for(i in r){if(!(i in n))return et(0,t,i,n[i],r[i],f);if(r[i]!==n[i])return et(1,t,i,n[i],r[i],l)}for(i in n)if(!(i in r))return et(2,t,i,n[i],r[i],c)}},et=function(e,t,n,r,i,s){var o={attrChange:e,currentTarget:t,attrName:n,prevValue:r,newValue:i};o[s]=e,lt(o)},tt=function(e){for(var t,n,r={},i=e.attributes,s=0,o=i.length;s<o;s++)t=i[s],n=t.name,n!=="setAttribute"&&(r[n]=t.value);return r})),n[i]=function(t,r){c=t.toUpperCase(),K||(K=!0,H?(nt=function(e,t){function n(e,t){for(var n=0,r=e.length;n<r;t(e[n++]));}return new H(function(r){for(var i,s,o,u=0,a=r.length;u<a;u++)i=r[u],i.type==="childList"?(n(i.addedNodes,e),n(i.removedNodes,t)):(s=i.target,Y&&s.attributeChangedCallback&&i.attributeName!=="style"&&(o=R.call(s,i.attributeName),o!==i.oldValue&&s.attributeChangedCallback(i.attributeName,i.oldValue,o)))})}(ut(o),ut(u)),nt.observe(n,{childList:!0,subtree:!0})):($=[],J(function d(){while($.length)$.shift().call(null,$.shift());J(d)}),n.addEventListener("DOMNodeInserted",ct(o)),n.addEventListener("DOMNodeRemoved",ct(u))),n.addEventListener(p,ht),n.addEventListener("readystatechange",ht),n.createElement=function(e,t){var r=W.apply(n,arguments),i=""+e,s=x.call(b,(t?m:v)+(t||i).toUpperCase()),o=-1<s;return t&&(r.setAttribute("is",t=t.toLowerCase()),o&&(o=ft(i.toUpperCase(),t))),Y=!n.createElement.innerHTMLHelper,o&&it(r,w[s]),r},B.cloneNode=function(e){var t=q.call(this,!!e),n=at(t);return-1<n&&it(t,w[n]),e&&ot(t.querySelectorAll(E)),t}),-2<x.call(b,m+c)+x.call(b,v+c)&&mt(t);if(!g.test(c)||-1<x.call(y,c))throw new Error("The type "+t+" is invalid");var i=function(){return f?n.createElement(l,c):n.createElement(l)},s=r||T,f=N.call(s,a),l=f?r[a].toUpperCase():c,c,h;return f&&-1<x.call(b,v+l)&&mt(l),h=b.push((f?m:v)+c)-1,E=E.concat(E.length?",":"",f?l+'[is="'+t.toLowerCase()+'"]':l),i.prototype=w[h]=N.call(s,"prototype")?s.prototype:D(B),st(n.querySelectorAll(E),o),i}})(window,document,Object,"registerElement");
	},{}],9:[function(_dereq_,module,exports){
	/* eslint-disable no-unused-vars */
	'use strict';
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;
	
	function toObject(val) {
		if (val === null || val === undefined) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}
	
		return Object(val);
	}
	
	module.exports = Object.assign || function (target, source) {
		var from;
		var to = toObject(target);
		var symbols;
	
		for (var s = 1; s < arguments.length; s++) {
			from = Object(arguments[s]);
	
			for (var key in from) {
				if (hasOwnProperty.call(from, key)) {
					to[key] = from[key];
				}
			}
	
			if (Object.getOwnPropertySymbols) {
				symbols = Object.getOwnPropertySymbols(from);
				for (var i = 0; i < symbols.length; i++) {
					if (propIsEnumerable.call(from, symbols[i])) {
						to[symbols[i]] = from[symbols[i]];
					}
				}
			}
		}
	
		return to;
	};
	
	},{}],10:[function(_dereq_,module,exports){
	(function (global){
	var performance = global.performance || {};
	
	var present = (function () {
	  var names = ['now', 'webkitNow', 'msNow', 'mozNow', 'oNow'];
	  while (names.length) {
	    var name = names.shift();
	    if (name in performance) {
	      return performance[name].bind(performance);
	    }
	  }
	
	  var dateNow = Date.now || function () { return new Date().getTime(); };
	  var navigationStart = (performance.timing || {}).navigationStart || dateNow();
	  return function () {
	    return dateNow() - navigationStart;
	  };
	}());
	
	present.performanceNow = performance.now;
	present.noConflict = function () {
	  performance.now = present.performanceNow;
	};
	present.conflict = function () {
	  performance.now = present;
	};
	present.conflict();
	
	module.exports = present;
	
	}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
	
	},{}],11:[function(_dereq_,module,exports){
	(function(root) {
	
		// Store setTimeout reference so promise-polyfill will be unaffected by
		// other code modifying setTimeout (like sinon.useFakeTimers())
		var setTimeoutFunc = setTimeout;
	
		// Use polyfill for setImmediate for performance gains
		var asap = (typeof setImmediate === 'function' && setImmediate) ||
			function(fn) { setTimeoutFunc(fn, 1); };
	
		// Polyfill for Function.prototype.bind
		function bind(fn, thisArg) {
			return function() {
				fn.apply(thisArg, arguments);
			}
		}
	
		var isArray = Array.isArray || function(value) { return Object.prototype.toString.call(value) === "[object Array]" };
	
		function Promise(fn) {
			if (typeof this !== 'object') throw new TypeError('Promises must be constructed via new');
			if (typeof fn !== 'function') throw new TypeError('not a function');
			this._state = null;
			this._value = null;
			this._deferreds = []
	
			doResolve(fn, bind(resolve, this), bind(reject, this))
		}
	
		function handle(deferred) {
			var me = this;
			if (this._state === null) {
				this._deferreds.push(deferred);
				return
			}
			asap(function() {
				var cb = me._state ? deferred.onFulfilled : deferred.onRejected
				if (cb === null) {
					(me._state ? deferred.resolve : deferred.reject)(me._value);
					return;
				}
				var ret;
				try {
					ret = cb(me._value);
				}
				catch (e) {
					deferred.reject(e);
					return;
				}
				deferred.resolve(ret);
			})
		}
	
		function resolve(newValue) {
			try { //Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
				if (newValue === this) throw new TypeError('A promise cannot be resolved with itself.');
				if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {
					var then = newValue.then;
					if (typeof then === 'function') {
						doResolve(bind(then, newValue), bind(resolve, this), bind(reject, this));
						return;
					}
				}
				this._state = true;
				this._value = newValue;
				finale.call(this);
			} catch (e) { reject.call(this, e); }
		}
	
		function reject(newValue) {
			this._state = false;
			this._value = newValue;
			finale.call(this);
		}
	
		function finale() {
			for (var i = 0, len = this._deferreds.length; i < len; i++) {
				handle.call(this, this._deferreds[i]);
			}
			this._deferreds = null;
		}
	
		function Handler(onFulfilled, onRejected, resolve, reject){
			this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
			this.onRejected = typeof onRejected === 'function' ? onRejected : null;
			this.resolve = resolve;
			this.reject = reject;
		}
	
		/**
		 * Take a potentially misbehaving resolver function and make sure
		 * onFulfilled and onRejected are only called once.
		 *
		 * Makes no guarantees about asynchrony.
		 */
		function doResolve(fn, onFulfilled, onRejected) {
			var done = false;
			try {
				fn(function (value) {
					if (done) return;
					done = true;
					onFulfilled(value);
				}, function (reason) {
					if (done) return;
					done = true;
					onRejected(reason);
				})
			} catch (ex) {
				if (done) return;
				done = true;
				onRejected(ex);
			}
		}
	
		Promise.prototype['catch'] = function (onRejected) {
			return this.then(null, onRejected);
		};
	
		Promise.prototype.then = function(onFulfilled, onRejected) {
			var me = this;
			return new Promise(function(resolve, reject) {
				handle.call(me, new Handler(onFulfilled, onRejected, resolve, reject));
			})
		};
	
		Promise.all = function () {
			var args = Array.prototype.slice.call(arguments.length === 1 && isArray(arguments[0]) ? arguments[0] : arguments);
	
			return new Promise(function (resolve, reject) {
				if (args.length === 0) return resolve([]);
				var remaining = args.length;
				function res(i, val) {
					try {
						if (val && (typeof val === 'object' || typeof val === 'function')) {
							var then = val.then;
							if (typeof then === 'function') {
								then.call(val, function (val) { res(i, val) }, reject);
								return;
							}
						}
						args[i] = val;
						if (--remaining === 0) {
							resolve(args);
						}
					} catch (ex) {
						reject(ex);
					}
				}
				for (var i = 0; i < args.length; i++) {
					res(i, args[i]);
				}
			});
		};
	
		Promise.resolve = function (value) {
			if (value && typeof value === 'object' && value.constructor === Promise) {
				return value;
			}
	
			return new Promise(function (resolve) {
				resolve(value);
			});
		};
	
		Promise.reject = function (value) {
			return new Promise(function (resolve, reject) {
				reject(value);
			});
		};
	
		Promise.race = function (values) {
			return new Promise(function (resolve, reject) {
				for(var i = 0, len = values.length; i < len; i++) {
					values[i].then(resolve, reject);
				}
			});
		};
	
		/**
		 * Set the immediate function to execute callbacks
		 * @param fn {function} Function to execute
		 * @private
		 */
		Promise._setImmediateFn = function _setImmediateFn(fn) {
			asap = fn;
		};
	
		if (typeof module !== 'undefined' && module.exports) {
			module.exports = Promise;
		} else if (!root.Promise) {
			root.Promise = Promise;
		}
	
	})(this);
	
	},{}],12:[function(_dereq_,module,exports){
	'use strict';
	
	var raf = _dereq_('raf');
	var now = _dereq_('time-now');
	
	exports = module.exports = interval;
	function interval(delay, fn, ctx) {
	  var start = now();
	  var data = Object.create(null);
	  data.id = raf(loop);
	
	  return data;
	
	  function loop() {
	    data.id = raf(loop);
	
	    if ((now() - start) >= delay) {
	      fn.call(ctx);
	      start = now();
	    }
	  }
	}
	
	
	exports.clear = clearInterval;
	function clearInterval(data) {
	  raf.cancel(data.id);
	}
	
	},{"raf":13,"time-now":14}],13:[function(_dereq_,module,exports){
	/**
	 * Expose `requestAnimationFrame()`.
	 */
	
	exports = module.exports = window.requestAnimationFrame
	  || window.webkitRequestAnimationFrame
	  || window.mozRequestAnimationFrame
	  || fallback;
	
	/**
	 * Fallback implementation.
	 */
	
	var prev = new Date().getTime();
	function fallback(fn) {
	  var curr = new Date().getTime();
	  var ms = Math.max(0, 16 - (curr - prev));
	  var req = setTimeout(fn, ms);
	  prev = curr;
	  return req;
	}
	
	/**
	 * Cancel.
	 */
	
	var cancel = window.cancelAnimationFrame
	  || window.webkitCancelAnimationFrame
	  || window.mozCancelAnimationFrame
	  || window.clearTimeout;
	
	exports.cancel = function(id){
	  cancel.call(window, id);
	};
	
	},{}],14:[function(_dereq_,module,exports){
	'use strict';
	
	module.exports = (function() {
	  var perf = window && window.performance;
	  if (perf && perf.now) {
	    return perf.now.bind(perf);
	  } else {
	    return function() {
	      return new Date().getTime();
	    };
	  }
	}());
	
	},{}],15:[function(_dereq_,module,exports){
	/*
	
	style-attr
	====
	
	Very simple parsing and stringifying of style attributes.
	
	`parse`
	----
	
	Convert a style attribute string to an object.
	
	- input: string (eg. anything you might see in a style attribute)
	- return: object
	
	*/
	function parse (raw) {
	  var trim = function (s) { return s.trim(); };
	  var obj = {};
	
	  getKeyValueChunks(raw)
	    .map(trim)
	    .filter(Boolean)
	    .forEach(function (item) {
	      // split with `.indexOf` rather than `.split` because the value may also contain colons.
	      var pos = item.indexOf(':');
	      var key = item.substr(0, pos).trim();
	      var val = item.substr(pos + 1).trim();
	
	      obj[key] = val;
	    });
	
	  return obj;
	}
	
	/*
	
	`getKeyValueChunks`
	----
	
	Split a string into chunks matching `<key>: <value>`
	
	- input: string
	- return: Array<string>
	
	*/
	function getKeyValueChunks (raw) {
	  var chunks = [];
	  var offset = 0;
	  var sep = ';';
	  var hasUnclosedUrl = /url\([^\)]+$/;
	  var chunk = '';
	  var nextSplit;
	  while (offset < raw.length) {
	    nextSplit = raw.indexOf(sep, offset);
	    if (nextSplit === -1) { nextSplit = raw.length; }
	
	    chunk += raw.substring(offset, nextSplit);
	
	    // data URIs can contain semicolons, so make sure we get the whole thing
	    if (hasUnclosedUrl.test(chunk)) {
	      chunk += ';';
	      offset = nextSplit + 1;
	      continue;
	    }
	
	    chunks.push(chunk);
	    chunk = '';
	    offset = nextSplit + 1;
	  }
	
	  return chunks;
	}
	
	/*
	
	`stringify`
	----
	
	Convert an object into an attribute string
	
	- input: object
	- return: string
	
	*/
	function stringify (obj) {
	  return Object.keys(obj)
	    .map(function (key) {
	      return key + ':' + obj[key];
	    })
	    .join(';');
	}
	
	/*
	
	`normalize`
	----
	
	Normalize an attribute string (eg. collapse duplicates)
	
	- input: string
	- return: string
	
	*/
	function normalize (str) {
	  return stringify(parse(str));
	}
	
	module.exports.parse = parse;
	module.exports.stringify = stringify;
	module.exports.normalize = normalize;
	
	},{}],16:[function(_dereq_,module,exports){
	/**
	 * @author dmarcos / https://github.com/dmarcos
	 * @author mrdoob / http://mrdoob.com
	 */
	
	THREE.VRControls = function ( object, onError ) {
	
		var scope = this;
	
		var vrInputs = [];
	
		function gotVRDevices( devices ) {
	
			for ( var i = 0; i < devices.length; i ++ ) {
	
				if ( devices[ i ] instanceof PositionSensorVRDevice ) {
	
					vrInputs.push( devices[ i ] );
	
				}
	
			}
	
			if ( vrInputs.length === 0 ) {
	
				if ( onError ) onError( 'PositionSensorVRDevice not available' );
	
			}
	
		}
	
		if ( navigator.getVRDevices ) {
	
			navigator.getVRDevices().then( gotVRDevices );
	
		}
	
		// the Rift SDK returns the position in meters
		// this scale factor allows the user to define how meters
		// are converted to scene units.
	
		this.scale = 1;
	
		this.update = function () {
	
			for ( var i = 0; i < vrInputs.length; i ++ ) {
	
				var vrInput = vrInputs[ i ];
	
				var state = vrInput.getState();
	
				if ( state.orientation !== null ) {
	
					object.quaternion.copy( state.orientation );
	
				}
	
				if ( state.position !== null ) {
	
					object.position.copy( state.position ).multiplyScalar( scope.scale );
	
				}
	
			}
	
		};
	
		this.resetSensor = function () {
	
			for ( var i = 0; i < vrInputs.length; i ++ ) {
	
				var vrInput = vrInputs[ i ];
	
				if ( vrInput.resetSensor !== undefined ) {
	
					vrInput.resetSensor();
	
				} else if ( vrInput.zeroSensor !== undefined ) {
	
					vrInput.zeroSensor();
	
				}
	
			}
	
		};
	
		this.zeroSensor = function () {
	
			console.warn( 'THREE.VRControls: .zeroSensor() is now .resetSensor().' );
			this.resetSensor();
	
		};
	
		this.dispose = function () {
	
			vrInputs = [];
	
		};
	
	};
	
	},{}],17:[function(_dereq_,module,exports){
	/**
	 * @author dmarcos / https://github.com/dmarcos
	 * @author mrdoob / http://mrdoob.com
	 *
	 * WebVR Spec: http://mozvr.github.io/webvr-spec/webvr.html
	 *
	 * Firefox: http://mozvr.com/downloads/
	 * Chromium: https://drive.google.com/folderview?id=0BzudLt22BqGRbW9WTHMtOWMzNjQ&usp=sharing#list
	 *
	 */
	
	THREE.VREffect = function ( renderer, onError ) {
	
		var vrHMD;
		var eyeTranslationL, eyeFOVL;
		var eyeTranslationR, eyeFOVR;
	
		function gotVRDevices( devices ) {
	
			for ( var i = 0; i < devices.length; i ++ ) {
	
				if ( devices[ i ] instanceof HMDVRDevice ) {
	
					vrHMD = devices[ i ];
	
					break; // We keep the first we encounter
	
				}
	
			}
	
			if ( vrHMD === undefined ) {
	
				if ( onError ) onError( 'HMD not available' );
	
			}
	
		}
	
		if ( navigator.getVRDevices ) {
	
			navigator.getVRDevices().then( gotVRDevices );
	
		}
	
		//
	
		this.scale = 1;
	
		this.setSize = function ( width, height ) {
	
			renderer.setSize( width, height );
	
		};
	
		// fullscreen
	
		var isFullscreen = false;
	
		var canvas = renderer.domElement;
		var fullscreenchange = canvas.mozRequestFullScreen ? 'mozfullscreenchange' : 'webkitfullscreenchange';
	
		document.addEventListener( fullscreenchange, function ( event ) {
	
			isFullscreen = document.mozFullScreenElement || document.webkitFullscreenElement;
	
		}, false );
	
		this.setFullScreen = function ( boolean ) {
	
			if ( vrHMD === undefined ) return;
			if ( isFullscreen === boolean ) return;
	
			if ( canvas.mozRequestFullScreen ) {
	
				canvas.mozRequestFullScreen( { vrDisplay: vrHMD } );
	
			} else if ( canvas.webkitRequestFullscreen ) {
	
				canvas.webkitRequestFullscreen( { vrDisplay: vrHMD } );
	
			}
	
		};
	
		// render
	
		var cameraL = new THREE.PerspectiveCamera();
		cameraL.layers.enable( 1 );
	
		var cameraR = new THREE.PerspectiveCamera();
		cameraR.layers.enable( 2 );
	
		this.render = function ( scene, camera ) {
	
			if ( vrHMD ) {
	
				var eyeParamsL = vrHMD.getEyeParameters( 'left' );
				var eyeParamsR = vrHMD.getEyeParameters( 'right' );
	
				eyeTranslationL = eyeParamsL.eyeTranslation;
				eyeTranslationR = eyeParamsR.eyeTranslation;
				eyeFOVL = eyeParamsL.recommendedFieldOfView;
				eyeFOVR = eyeParamsR.recommendedFieldOfView;
	
				if ( Array.isArray( scene ) ) {
	
					console.warn( 'THREE.VREffect.render() no longer supports arrays. Use object.layers instead.' );
					scene = scene[ 0 ];
	
				}
	
				var size = renderer.getSize();
	
				renderer.setScissorTest( true );
				renderer.clear();
	
				if ( camera.parent === null ) camera.updateMatrixWorld();
	
				cameraL.projectionMatrix = fovToProjection( eyeFOVL, true, camera.near, camera.far );
				cameraR.projectionMatrix = fovToProjection( eyeFOVR, true, camera.near, camera.far );
	
				camera.matrixWorld.decompose( cameraL.position, cameraL.quaternion, cameraL.scale );
				camera.matrixWorld.decompose( cameraR.position, cameraR.quaternion, cameraR.scale );
	
				cameraL.translateX( eyeTranslationL.x * this.scale );
				cameraR.translateX( eyeTranslationR.x * this.scale );
	
				// render left eye
				renderer.setViewport( 0, 0, size.width / 2, size.height );
				renderer.setScissor( 0, 0, size.width / 2, size.height );
				renderer.render( scene, cameraL );
	
				// render right eye
				renderer.setViewport( size.width / 2, 0, size.width / 2, size.height );
				renderer.setScissor( size.width / 2, 0, size.width / 2, size.height );
				renderer.render( scene, cameraR );
	
				renderer.setScissorTest( false );
	
				return;
	
			}
	
			// Regular render mode if not HMD
	
			renderer.render( scene, camera );
	
		};
	
		//
	
		function fovToNDCScaleOffset( fov ) {
	
			var pxscale = 2.0 / ( fov.leftTan + fov.rightTan );
			var pxoffset = ( fov.leftTan - fov.rightTan ) * pxscale * 0.5;
			var pyscale = 2.0 / ( fov.upTan + fov.downTan );
			var pyoffset = ( fov.upTan - fov.downTan ) * pyscale * 0.5;
			return { scale: [ pxscale, pyscale ], offset: [ pxoffset, pyoffset ] };
	
		}
	
		function fovPortToProjection( fov, rightHanded, zNear, zFar ) {
	
			rightHanded = rightHanded === undefined ? true : rightHanded;
			zNear = zNear === undefined ? 0.01 : zNear;
			zFar = zFar === undefined ? 10000.0 : zFar;
	
			var handednessScale = rightHanded ? - 1.0 : 1.0;
	
			// start with an identity matrix
			var mobj = new THREE.Matrix4();
			var m = mobj.elements;
	
			// and with scale/offset info for normalized device coords
			var scaleAndOffset = fovToNDCScaleOffset( fov );
	
			// X result, map clip edges to [-w,+w]
			m[ 0 * 4 + 0 ] = scaleAndOffset.scale[ 0 ];
			m[ 0 * 4 + 1 ] = 0.0;
			m[ 0 * 4 + 2 ] = scaleAndOffset.offset[ 0 ] * handednessScale;
			m[ 0 * 4 + 3 ] = 0.0;
	
			// Y result, map clip edges to [-w,+w]
			// Y offset is negated because this proj matrix transforms from world coords with Y=up,
			// but the NDC scaling has Y=down (thanks D3D?)
			m[ 1 * 4 + 0 ] = 0.0;
			m[ 1 * 4 + 1 ] = scaleAndOffset.scale[ 1 ];
			m[ 1 * 4 + 2 ] = - scaleAndOffset.offset[ 1 ] * handednessScale;
			m[ 1 * 4 + 3 ] = 0.0;
	
			// Z result (up to the app)
			m[ 2 * 4 + 0 ] = 0.0;
			m[ 2 * 4 + 1 ] = 0.0;
			m[ 2 * 4 + 2 ] = zFar / ( zNear - zFar ) * - handednessScale;
			m[ 2 * 4 + 3 ] = ( zFar * zNear ) / ( zNear - zFar );
	
			// W result (= Z in)
			m[ 3 * 4 + 0 ] = 0.0;
			m[ 3 * 4 + 1 ] = 0.0;
			m[ 3 * 4 + 2 ] = handednessScale;
			m[ 3 * 4 + 3 ] = 0.0;
	
			mobj.transpose();
	
			return mobj;
	
		}
	
		function fovToProjection( fov, rightHanded, zNear, zFar ) {
	
			var DEG2RAD = Math.PI / 180.0;
	
			var fovPort = {
				upTan: Math.tan( fov.upDegrees * DEG2RAD ),
				downTan: Math.tan( fov.downDegrees * DEG2RAD ),
				leftTan: Math.tan( fov.leftDegrees * DEG2RAD ),
				rightTan: Math.tan( fov.rightDegrees * DEG2RAD )
			};
	
			return fovPortToProjection( fovPort, rightHanded, zNear, zFar );
	
		}
	
	};
	
	},{}],18:[function(_dereq_,module,exports){
	/**
	* @author Tim Knip / http://www.floorplanner.com/ / tim at floorplanner.com
	* @author Tony Parisi / http://www.tonyparisi.com/
	*/
	
	THREE.ColladaLoader = function () {
	
		var COLLADA = null;
		var scene = null;
		var visualScene;
		var kinematicsModel;
	
		var readyCallbackFunc = null;
	
		var sources = {};
		var images = {};
		var animations = {};
		var controllers = {};
		var geometries = {};
		var materials = {};
		var effects = {};
		var cameras = {};
		var lights = {};
	
		var animData;
		var kinematics;
		var visualScenes;
		var kinematicsModels;
		var baseUrl;
		var morphs;
		var skins;
	
		var flip_uv = true;
		var preferredShading = THREE.SmoothShading;
	
		var options = {
			// Force Geometry to always be centered at the local origin of the
			// containing Mesh.
			centerGeometry: false,
	
			// Axis conversion is done for geometries, animations, and controllers.
			// If we ever pull cameras or lights out of the COLLADA file, they'll
			// need extra work.
			convertUpAxis: false,
	
			subdivideFaces: true,
	
			upAxis: 'Y',
	
			// For reflective or refractive materials we'll use this cubemap
			defaultEnvMap: null
	
		};
	
		var colladaUnit = 1.0;
		var colladaUp = 'Y';
		var upConversion = null;
	
		function load ( url, readyCallback, progressCallback, failCallback ) {
	
			var length = 0;
	
			if ( document.implementation && document.implementation.createDocument ) {
	
				var request = new XMLHttpRequest();
	
				request.onreadystatechange = function() {
	
					if ( request.readyState === 4 ) {
	
						if ( request.status === 0 || request.status === 200 ) {
	
							if ( request.response ) {
	
								readyCallbackFunc = readyCallback;
								parse( request.response, undefined, url );
	
							} else {
	
								if ( failCallback ) {
	
									failCallback();
	
								} else {
	
									console.error( "ColladaLoader: Empty or non-existing file (" + url + ")" );
	
								}
	
							}
	
						}
	
					} else if ( request.readyState === 3 ) {
	
						if ( progressCallback ) {
	
							if ( length === 0 ) {
	
								length = request.getResponseHeader( "Content-Length" );
	
							}
	
							progressCallback( { total: length, loaded: request.responseText.length } );
	
						}
	
					}
	
				};
	
				request.open( "GET", url, true );
				request.send( null );
	
			} else {
	
				alert( "Don't know how to parse XML!" );
	
			}
	
		}
	
		function parse( text, callBack, url ) {
	
			COLLADA = new DOMParser().parseFromString( text, 'text/xml' );
			callBack = callBack || readyCallbackFunc;
	
			if ( url !== undefined ) {
	
				var parts = url.split( '/' );
				parts.pop();
				baseUrl = ( parts.length < 1 ? '.' : parts.join( '/' ) ) + '/';
	
			}
	
			parseAsset();
			setUpConversion();
			images = parseLib( "library_images image", _Image, "image" );
			materials = parseLib( "library_materials material", Material, "material" );
			effects = parseLib( "library_effects effect", Effect, "effect" );
			geometries = parseLib( "library_geometries geometry", Geometry, "geometry" );
			cameras = parseLib( "library_cameras camera", Camera, "camera" );
			lights = parseLib( "library_lights light", Light, "light" );
			controllers = parseLib( "library_controllers controller", Controller, "controller" );
			animations = parseLib( "library_animations animation", Animation, "animation" );
			visualScenes = parseLib( "library_visual_scenes visual_scene", VisualScene, "visual_scene" );
			kinematicsModels = parseLib( "library_kinematics_models kinematics_model", KinematicsModel, "kinematics_model" );
	
			morphs = [];
			skins = [];
	
			visualScene = parseScene();
			scene = new THREE.Group();
	
			for ( var i = 0; i < visualScene.nodes.length; i ++ ) {
	
				scene.add( createSceneGraph( visualScene.nodes[ i ] ) );
	
			}
	
			// unit conversion
			scene.scale.multiplyScalar( colladaUnit );
	
			createAnimations();
	
			kinematicsModel = parseKinematicsModel();
			createKinematics();
	
			var result = {
	
				scene: scene,
				morphs: morphs,
				skins: skins,
				animations: animData,
				kinematics: kinematics,
				dae: {
					images: images,
					materials: materials,
					cameras: cameras,
					lights: lights,
					effects: effects,
					geometries: geometries,
					controllers: controllers,
					animations: animations,
					visualScenes: visualScenes,
					visualScene: visualScene,
					scene: visualScene,
					kinematicsModels: kinematicsModels,
					kinematicsModel: kinematicsModel
				}
	
			};
	
			if ( callBack ) {
	
				callBack( result );
	
			}
	
			return result;
	
		}
	
		function setPreferredShading ( shading ) {
	
			preferredShading = shading;
	
		}
	
		function parseAsset () {
	
			var elements = COLLADA.querySelectorAll('asset');
	
			var element = elements[0];
	
			if ( element && element.childNodes ) {
	
				for ( var i = 0; i < element.childNodes.length; i ++ ) {
	
					var child = element.childNodes[ i ];
	
					switch ( child.nodeName ) {
	
						case 'unit':
	
							var meter = child.getAttribute( 'meter' );
	
							if ( meter ) {
	
								colladaUnit = parseFloat( meter );
	
							}
	
							break;
	
						case 'up_axis':
	
							colladaUp = child.textContent.charAt(0);
							break;
	
					}
	
				}
	
			}
	
		}
	
		function parseLib ( q, classSpec, prefix ) {
	
			var elements = COLLADA.querySelectorAll(q);
	
			var lib = {};
	
			var i = 0;
	
			var elementsLength = elements.length;
	
			for ( var j = 0; j < elementsLength; j ++ ) {
	
				var element = elements[j];
				var daeElement = ( new classSpec() ).parse( element );
	
				if ( !daeElement.id || daeElement.id.length === 0 ) daeElement.id = prefix + ( i ++ );
				lib[ daeElement.id ] = daeElement;
	
			}
	
			return lib;
	
		}
	
		function parseScene() {
	
			var sceneElement = COLLADA.querySelectorAll('scene instance_visual_scene')[0];
	
			if ( sceneElement ) {
	
				var url = sceneElement.getAttribute( 'url' ).replace( /^#/, '' );
				return visualScenes[ url.length > 0 ? url : 'visual_scene0' ];
	
			} else {
	
				return null;
	
			}
	
		}
	
		function parseKinematicsModel() {
	
			var kinematicsModelElement = COLLADA.querySelectorAll('instance_kinematics_model')[0];
	
			if ( kinematicsModelElement ) {
	
				var url = kinematicsModelElement.getAttribute( 'url' ).replace(/^#/, '');
				return kinematicsModels[ url.length > 0 ? url : 'kinematics_model0' ];
	
			} else {
	
				return null;
	
			}
	
		}
	
		function createAnimations() {
	
			animData = [];
	
			// fill in the keys
			recurseHierarchy( scene );
	
		}
	
		function recurseHierarchy( node ) {
	
			var n = visualScene.getChildById( node.colladaId, true ),
				newData = null;
	
			if ( n && n.keys ) {
	
				newData = {
					fps: 60,
					hierarchy: [ {
						node: n,
						keys: n.keys,
						sids: n.sids
					} ],
					node: node,
					name: 'animation_' + node.name,
					length: 0
				};
	
				animData.push(newData);
	
				for ( var i = 0, il = n.keys.length; i < il; i ++ ) {
	
					newData.length = Math.max( newData.length, n.keys[i].time );
	
				}
	
			} else {
	
				newData = {
					hierarchy: [ {
						keys: [],
						sids: []
					} ]
				}
	
			}
	
			for ( var i = 0, il = node.children.length; i < il; i ++ ) {
	
				var d = recurseHierarchy( node.children[i] );
	
				for ( var j = 0, jl = d.hierarchy.length; j < jl; j ++ ) {
	
					newData.hierarchy.push( {
						keys: [],
						sids: []
					} );
	
				}
	
			}
	
			return newData;
	
		}
	
		function calcAnimationBounds () {
	
			var start = 1000000;
			var end = -start;
			var frames = 0;
			var ID;
			for ( var id in animations ) {
	
				var animation = animations[ id ];
				ID = ID || animation.id;
				for ( var i = 0; i < animation.sampler.length; i ++ ) {
	
					var sampler = animation.sampler[ i ];
	
					sampler.create();
	
					start = Math.min( start, sampler.startTime );
					end = Math.max( end, sampler.endTime );
					frames = Math.max( frames, sampler.input.length );
	
				}
	
			}
	
			return { start:start, end:end, frames:frames,ID:ID };
	
		}
	
		function createMorph ( geometry, ctrl ) {
	
			var morphCtrl = ctrl instanceof InstanceController ? controllers[ ctrl.url ] : ctrl;
	
			if ( !morphCtrl || !morphCtrl.morph ) {
	
				console.log("could not find morph controller!");
				return;
	
			}
	
			var morph = morphCtrl.morph;
	
			for ( var i = 0; i < morph.targets.length; i ++ ) {
	
				var target_id = morph.targets[ i ];
				var daeGeometry = geometries[ target_id ];
	
				if ( !daeGeometry.mesh ||
					 !daeGeometry.mesh.primitives ||
					 !daeGeometry.mesh.primitives.length ) {
					 continue;
				}
	
				var target = daeGeometry.mesh.primitives[ 0 ].geometry;
	
				if ( target.vertices.length === geometry.vertices.length ) {
	
					geometry.morphTargets.push( { name: "target_1", vertices: target.vertices } );
	
				}
	
			}
	
			geometry.morphTargets.push( { name: "target_Z", vertices: geometry.vertices } );
	
		}
	
		function createSkin ( geometry, ctrl, applyBindShape ) {
	
			var skinCtrl = controllers[ ctrl.url ];
	
			if ( !skinCtrl || !skinCtrl.skin ) {
	
				console.log( "could not find skin controller!" );
				return;
	
			}
	
			if ( !ctrl.skeleton || !ctrl.skeleton.length ) {
	
				console.log( "could not find the skeleton for the skin!" );
				return;
	
			}
	
			var skin = skinCtrl.skin;
			var skeleton = visualScene.getChildById( ctrl.skeleton[ 0 ] );
			var hierarchy = [];
	
			applyBindShape = applyBindShape !== undefined ? applyBindShape : true;
	
			var bones = [];
			geometry.skinWeights = [];
			geometry.skinIndices = [];
	
			//createBones( geometry.bones, skin, hierarchy, skeleton, null, -1 );
			//createWeights( skin, geometry.bones, geometry.skinIndices, geometry.skinWeights );
	
			/*
			geometry.animation = {
				name: 'take_001',
				fps: 30,
				length: 2,
				JIT: true,
				hierarchy: hierarchy
			};
			*/
	
			if ( applyBindShape ) {
	
				for ( var i = 0; i < geometry.vertices.length; i ++ ) {
	
					geometry.vertices[ i ].applyMatrix4( skin.bindShapeMatrix );
	
				}
	
			}
	
		}
	
		function setupSkeleton ( node, bones, frame, parent ) {
	
			node.world = node.world || new THREE.Matrix4();
			node.localworld = node.localworld || new THREE.Matrix4();
			node.world.copy( node.matrix );
			node.localworld.copy( node.matrix );
	
			if ( node.channels && node.channels.length ) {
	
				var channel = node.channels[ 0 ];
				var m = channel.sampler.output[ frame ];
	
				if ( m instanceof THREE.Matrix4 ) {
	
					node.world.copy( m );
					node.localworld.copy(m);
					if (frame === 0)
						node.matrix.copy(m);
				}
	
			}
	
			if ( parent ) {
	
				node.world.multiplyMatrices( parent, node.world );
	
			}
	
			bones.push( node );
	
			for ( var i = 0; i < node.nodes.length; i ++ ) {
	
				setupSkeleton( node.nodes[ i ], bones, frame, node.world );
	
			}
	
		}
	
		function setupSkinningMatrices ( bones, skin ) {
	
			// FIXME: this is dumb...
	
			for ( var i = 0; i < bones.length; i ++ ) {
	
				var bone = bones[ i ];
				var found = -1;
	
				if ( bone.type != 'JOINT' ) continue;
	
				for ( var j = 0; j < skin.joints.length; j ++ ) {
	
					if ( bone.sid === skin.joints[ j ] ) {
	
						found = j;
						break;
	
					}
	
				}
	
				if ( found >= 0 ) {
	
					var inv = skin.invBindMatrices[ found ];
	
					bone.invBindMatrix = inv;
					bone.skinningMatrix = new THREE.Matrix4();
					bone.skinningMatrix.multiplyMatrices(bone.world, inv); // (IBMi * JMi)
					bone.animatrix = new THREE.Matrix4();
	
					bone.animatrix.copy(bone.localworld);
					bone.weights = [];
	
					for ( var j = 0; j < skin.weights.length; j ++ ) {
	
						for (var k = 0; k < skin.weights[ j ].length; k ++ ) {
	
							var w = skin.weights[ j ][ k ];
	
							if ( w.joint === found ) {
	
								bone.weights.push( w );
	
							}
	
						}
	
					}
	
				} else {
	
					console.warn( "ColladaLoader: Could not find joint '" + bone.sid + "'." );
	
					bone.skinningMatrix = new THREE.Matrix4();
					bone.weights = [];
	
				}
			}
	
		}
	
		//Walk the Collada tree and flatten the bones into a list, extract the position, quat and scale from the matrix
		function flattenSkeleton(skeleton) {
	
			var list = [];
			var walk = function(parentid, node, list) {
	
				var bone = {};
				bone.name = node.sid;
				bone.parent = parentid;
				bone.matrix = node.matrix;
				var data = [ new THREE.Vector3(),new THREE.Quaternion(),new THREE.Vector3() ];
				bone.matrix.decompose(data[0], data[1], data[2]);
	
				bone.pos = [ data[0].x,data[0].y,data[0].z ];
	
				bone.scl = [ data[2].x,data[2].y,data[2].z ];
				bone.rotq = [ data[1].x,data[1].y,data[1].z,data[1].w ];
				list.push(bone);
	
				for (var i in node.nodes) {
	
					walk(node.sid, node.nodes[i], list);
	
				}
	
			};
	
			walk(-1, skeleton, list);
			return list;
	
		}
	
		//Move the vertices into the pose that is proper for the start of the animation
		function skinToBindPose(geometry,skeleton,skinController) {
	
			var bones = [];
			setupSkeleton( skeleton, bones, -1 );
			setupSkinningMatrices( bones, skinController.skin );
			var v = new THREE.Vector3();
			var skinned = [];
	
			for (var i = 0; i < geometry.vertices.length; i ++) {
	
				skinned.push(new THREE.Vector3());
	
			}
	
			for ( i = 0; i < bones.length; i ++ ) {
	
				if ( bones[ i ].type != 'JOINT' ) continue;
	
				for ( var j = 0; j < bones[ i ].weights.length; j ++ ) {
	
					var w = bones[ i ].weights[ j ];
					var vidx = w.index;
					var weight = w.weight;
	
					var o = geometry.vertices[vidx];
					var s = skinned[vidx];
	
					v.x = o.x;
					v.y = o.y;
					v.z = o.z;
	
					v.applyMatrix4( bones[i].skinningMatrix );
	
					s.x += (v.x * weight);
					s.y += (v.y * weight);
					s.z += (v.z * weight);
				}
	
			}
	
			for (var i = 0; i < geometry.vertices.length; i ++) {
	
				geometry.vertices[i] = skinned[i];
	
			}
	
		}
	
		function applySkin ( geometry, instanceCtrl, frame ) {
	
			var skinController = controllers[ instanceCtrl.url ];
	
			frame = frame !== undefined ? frame : 40;
	
			if ( !skinController || !skinController.skin ) {
	
				console.log( 'ColladaLoader: Could not find skin controller.' );
				return;
	
			}
	
			if ( !instanceCtrl.skeleton || !instanceCtrl.skeleton.length ) {
	
				console.log( 'ColladaLoader: Could not find the skeleton for the skin. ' );
				return;
	
			}
	
			var animationBounds = calcAnimationBounds();
			var skeleton = visualScene.getChildById( instanceCtrl.skeleton[0], true ) || visualScene.getChildBySid( instanceCtrl.skeleton[0], true );
	
			//flatten the skeleton into a list of bones
			var bonelist = flattenSkeleton(skeleton);
			var joints = skinController.skin.joints;
	
			//sort that list so that the order reflects the order in the joint list
			var sortedbones = [];
			for (var i = 0; i < joints.length; i ++) {
	
				for (var j = 0; j < bonelist.length; j ++) {
	
					if (bonelist[j].name === joints[i]) {
	
						sortedbones[i] = bonelist[j];
	
					}
	
				}
	
			}
	
			//hook up the parents by index instead of name
			for (var i = 0; i < sortedbones.length; i ++) {
	
				for (var j = 0; j < sortedbones.length; j ++) {
	
					if (sortedbones[i].parent === sortedbones[j].name) {
	
						sortedbones[i].parent = j;
	
					}
	
				}
	
			}
	
	
			var i, j, w, vidx, weight;
			var v = new THREE.Vector3(), o, s;
	
			// move vertices to bind shape
			for ( i = 0; i < geometry.vertices.length; i ++ ) {
				geometry.vertices[i].applyMatrix4( skinController.skin.bindShapeMatrix );
			}
	
			var skinIndices = [];
			var skinWeights = [];
			var weights = skinController.skin.weights;
	
			// hook up the skin weights
			// TODO - this might be a good place to choose greatest 4 weights
			for ( var i =0; i < weights.length; i ++ ) {
	
				var indicies = new THREE.Vector4(weights[i][0] ? weights[i][0].joint : 0,weights[i][1] ? weights[i][1].joint : 0,weights[i][2] ? weights[i][2].joint : 0,weights[i][3] ? weights[i][3].joint : 0);
				var weight = new THREE.Vector4(weights[i][0] ? weights[i][0].weight : 0,weights[i][1] ? weights[i][1].weight : 0,weights[i][2] ? weights[i][2].weight : 0,weights[i][3] ? weights[i][3].weight : 0);
	
				skinIndices.push(indicies);
				skinWeights.push(weight);
	
			}
	
			geometry.skinIndices = skinIndices;
			geometry.skinWeights = skinWeights;
			geometry.bones = sortedbones;
			// process animation, or simply pose the rig if no animation
	
			//create an animation for the animated bones
			//NOTE: this has no effect when using morphtargets
			var animationdata = { "name":animationBounds.ID,"fps":30,"length":animationBounds.frames / 30,"hierarchy":[] };
	
			for (var j = 0; j < sortedbones.length; j ++) {
	
				animationdata.hierarchy.push({ parent:sortedbones[j].parent, name:sortedbones[j].name, keys:[] });
	
			}
	
			console.log( 'ColladaLoader:', animationBounds.ID + ' has ' + sortedbones.length + ' bones.' );
	
	
	
			skinToBindPose(geometry, skeleton, skinController);
	
	
			for ( frame = 0; frame < animationBounds.frames; frame ++ ) {
	
				var bones = [];
				var skinned = [];
				// process the frame and setup the rig with a fresh
				// transform, possibly from the bone's animation channel(s)
	
				setupSkeleton( skeleton, bones, frame );
				setupSkinningMatrices( bones, skinController.skin );
	
				for (var i = 0; i < bones.length; i ++) {
	
					for (var j = 0; j < animationdata.hierarchy.length; j ++) {
	
						if (animationdata.hierarchy[j].name === bones[i].sid) {
	
							var key = {};
							key.time = (frame / 30);
							key.matrix = bones[i].animatrix;
	
							if (frame === 0)
								bones[i].matrix = key.matrix;
	
							var data = [ new THREE.Vector3(),new THREE.Quaternion(),new THREE.Vector3() ];
							key.matrix.decompose(data[0], data[1], data[2]);
	
							key.pos = [ data[0].x,data[0].y,data[0].z ];
	
							key.scl = [ data[2].x,data[2].y,data[2].z ];
							key.rot = data[1];
	
							animationdata.hierarchy[j].keys.push(key);
	
						}
	
					}
	
				}
	
				geometry.animation = animationdata;
	
			}
	
		}
	
		function createKinematics() {
	
			if ( kinematicsModel && kinematicsModel.joints.length === 0 ) {
				kinematics = undefined;
				return;
			}
	
			var jointMap = {};
	
			var _addToMap = function( jointIndex, parentVisualElement ) {
	
				var parentVisualElementId = parentVisualElement.getAttribute( 'id' );
				var colladaNode = visualScene.getChildById( parentVisualElementId, true );
				var joint = kinematicsModel.joints[ jointIndex ];
	
				scene.traverse(function( node ) {
	
					if ( node.colladaId == parentVisualElementId ) {
	
						jointMap[ jointIndex ] = {
							node: node,
							transforms: colladaNode.transforms,
							joint: joint,
							position: joint.zeroPosition
						};
	
					}
	
				});
	
			};
	
			kinematics = {
	
				joints: kinematicsModel && kinematicsModel.joints,
	
				getJointValue: function( jointIndex ) {
	
					var jointData = jointMap[ jointIndex ];
	
					if ( jointData ) {
	
						return jointData.position;
	
					} else {
	
						console.log( 'getJointValue: joint ' + jointIndex + ' doesn\'t exist' );
	
					}
	
				},
	
				setJointValue: function( jointIndex, value ) {
	
					var jointData = jointMap[ jointIndex ];
	
					if ( jointData ) {
	
						var joint = jointData.joint;
	
						if ( value > joint.limits.max || value < joint.limits.min ) {
	
							console.log( 'setJointValue: joint ' + jointIndex + ' value ' + value + ' outside of limits (min: ' + joint.limits.min + ', max: ' + joint.limits.max + ')' );
	
						} else if ( joint.static ) {
	
							console.log( 'setJointValue: joint ' + jointIndex + ' is static' );
	
						} else {
	
							var threejsNode = jointData.node;
							var axis = joint.axis;
							var transforms = jointData.transforms;
	
							var matrix = new THREE.Matrix4();
	
							for (i = 0; i < transforms.length; i ++ ) {
	
								var transform = transforms[ i ];
	
								// kinda ghetto joint detection
								if ( transform.sid && transform.sid.indexOf( 'joint' + jointIndex ) !== -1 ) {
	
									// apply actual joint value here
									switch ( joint.type ) {
	
										case 'revolute':
	
											matrix.multiply( m1.makeRotationAxis( axis, THREE.Math.degToRad(value) ) );
											break;
	
										case 'prismatic':
	
											matrix.multiply( m1.makeTranslation(axis.x * value, axis.y * value, axis.z * value ) );
											break;
	
										default:
	
											console.warn( 'setJointValue: unknown joint type: ' + joint.type );
											break;
	
									}
	
								} else {
	
									var m1 = new THREE.Matrix4();
	
									switch ( transform.type ) {
	
										case 'matrix':
	
											matrix.multiply( transform.obj );
	
											break;
	
										case 'translate':
	
											matrix.multiply( m1.makeTranslation( transform.obj.x, transform.obj.y, transform.obj.z ) );
	
											break;
	
										case 'rotate':
	
											matrix.multiply( m1.makeRotationAxis( transform.obj, transform.angle ) );
	
											break;
	
									}
								}
							}
	
							// apply the matrix to the threejs node
							var elementsFloat32Arr = matrix.elements;
							var elements = Array.prototype.slice.call( elementsFloat32Arr );
	
							var elementsRowMajor = [
								elements[ 0 ],
								elements[ 4 ],
								elements[ 8 ],
								elements[ 12 ],
								elements[ 1 ],
								elements[ 5 ],
								elements[ 9 ],
								elements[ 13 ],
								elements[ 2 ],
								elements[ 6 ],
								elements[ 10 ],
								elements[ 14 ],
								elements[ 3 ],
								elements[ 7 ],
								elements[ 11 ],
								elements[ 15 ]
							];
	
							threejsNode.matrix.set.apply( threejsNode.matrix, elementsRowMajor );
							threejsNode.matrix.decompose( threejsNode.position, threejsNode.quaternion, threejsNode.scale );
						}
	
					} else {
	
						console.log( 'setJointValue: joint ' + jointIndex + ' doesn\'t exist' );
	
					}
	
				}
	
			};
	
			var element = COLLADA.querySelector('scene instance_kinematics_scene');
	
			if ( element ) {
	
				for ( var i = 0; i < element.childNodes.length; i ++ ) {
	
					var child = element.childNodes[ i ];
	
					if ( child.nodeType != 1 ) continue;
	
					switch ( child.nodeName ) {
	
						case 'bind_joint_axis':
	
							var visualTarget = child.getAttribute( 'target' ).split( '/' ).pop();
							var axis = child.querySelector('axis param').textContent;
							var jointIndex = parseInt( axis.split( 'joint' ).pop().split( '.' )[0] );
							var visualTargetElement = COLLADA.querySelector( '[sid="' + visualTarget + '"]' );
	
							if ( visualTargetElement ) {
								var parentVisualElement = visualTargetElement.parentElement;
								_addToMap(jointIndex, parentVisualElement);
							}
	
							break;
	
						default:
	
							break;
	
					}
	
				}
			}
	
		}
	
		function createSceneGraph ( node, parent ) {
	
			var obj = new THREE.Object3D();
			var skinned = false;
			var skinController;
			var morphController;
			var i, j;
	
			// FIXME: controllers
	
			for ( i = 0; i < node.controllers.length; i ++ ) {
	
				var controller = controllers[ node.controllers[ i ].url ];
	
				switch ( controller.type ) {
	
					case 'skin':
	
						if ( geometries[ controller.skin.source ] ) {
	
							var inst_geom = new InstanceGeometry();
	
							inst_geom.url = controller.skin.source;
							inst_geom.instance_material = node.controllers[ i ].instance_material;
	
							node.geometries.push( inst_geom );
							skinned = true;
							skinController = node.controllers[ i ];
	
						} else if ( controllers[ controller.skin.source ] ) {
	
							// urgh: controller can be chained
							// handle the most basic case...
	
							var second = controllers[ controller.skin.source ];
							morphController = second;
						//	skinController = node.controllers[i];
	
							if ( second.morph && geometries[ second.morph.source ] ) {
	
								var inst_geom = new InstanceGeometry();
	
								inst_geom.url = second.morph.source;
								inst_geom.instance_material = node.controllers[ i ].instance_material;
	
								node.geometries.push( inst_geom );
	
							}
	
						}
	
						break;
	
					case 'morph':
	
						if ( geometries[ controller.morph.source ] ) {
	
							var inst_geom = new InstanceGeometry();
	
							inst_geom.url = controller.morph.source;
							inst_geom.instance_material = node.controllers[ i ].instance_material;
	
							node.geometries.push( inst_geom );
							morphController = node.controllers[ i ];
	
						}
	
						console.log( 'ColladaLoader: Morph-controller partially supported.' );
	
					default:
						break;
	
				}
	
			}
	
			// geometries
	
			var double_sided_materials = {};
	
			for ( i = 0; i < node.geometries.length; i ++ ) {
	
				var instance_geometry = node.geometries[i];
				var instance_materials = instance_geometry.instance_material;
				var geometry = geometries[ instance_geometry.url ];
				var used_materials = {};
				var used_materials_array = [];
				var num_materials = 0;
				var first_material;
	
				if ( geometry ) {
	
					if ( !geometry.mesh || !geometry.mesh.primitives )
						continue;
	
					if ( obj.name.length === 0 ) {
	
						obj.name = geometry.id;
	
					}
	
					// collect used fx for this geometry-instance
	
					if ( instance_materials ) {
	
						for ( j = 0; j < instance_materials.length; j ++ ) {
	
							var instance_material = instance_materials[ j ];
							var mat = materials[ instance_material.target ];
							var effect_id = mat.instance_effect.url;
							var shader = effects[ effect_id ].shader;
							var material3js = shader.material;
	
							if ( geometry.doubleSided ) {
	
								if ( !( instance_material.symbol in double_sided_materials ) ) {
	
									var _copied_material = material3js.clone();
									_copied_material.side = THREE.DoubleSide;
									double_sided_materials[ instance_material.symbol ] = _copied_material;
	
								}
	
								material3js = double_sided_materials[ instance_material.symbol ];
	
							}
	
							material3js.opacity = !material3js.opacity ? 1 : material3js.opacity;
							used_materials[ instance_material.symbol ] = num_materials;
							used_materials_array.push( material3js );
							first_material = material3js;
							first_material.name = mat.name === null || mat.name === '' ? mat.id : mat.name;
							num_materials ++;
	
						}
	
					}
	
					var mesh;
					var material = first_material || new THREE.MeshLambertMaterial( { color: 0xdddddd, side: geometry.doubleSided ? THREE.DoubleSide : THREE.FrontSide } );
					var geom = geometry.mesh.geometry3js;
	
					if ( num_materials > 1 ) {
	
						material = new THREE.MultiMaterial( used_materials_array );
	
					}
	
					if ( skinController !== undefined ) {
	
	
						applySkin( geom, skinController );
	
						if ( geom.morphTargets.length > 0 ) {
	
							material.morphTargets = true;
							material.skinning = false;
	
						} else {
	
							material.morphTargets = false;
							material.skinning = true;
	
						}
	
	
						mesh = new THREE.SkinnedMesh( geom, material, false );
	
	
						//mesh.skeleton = skinController.skeleton;
						//mesh.skinController = controllers[ skinController.url ];
						//mesh.skinInstanceController = skinController;
						mesh.name = 'skin_' + skins.length;
	
	
	
						//mesh.animationHandle.setKey(0);
						skins.push( mesh );
	
					} else if ( morphController !== undefined ) {
	
						createMorph( geom, morphController );
	
						material.morphTargets = true;
	
						mesh = new THREE.Mesh( geom, material );
						mesh.name = 'morph_' + morphs.length;
	
						morphs.push( mesh );
	
					} else {
	
						if ( geom.isLineStrip === true ) {
	
							mesh = new THREE.Line( geom );
	
						} else {
	
							mesh = new THREE.Mesh( geom, material );
	
						}
	
					}
	
					obj.add(mesh);
	
				}
	
			}
	
			for ( i = 0; i < node.cameras.length; i ++ ) {
	
				var instance_camera = node.cameras[i];
				var cparams = cameras[instance_camera.url];
	
				var cam = new THREE.PerspectiveCamera(cparams.yfov, parseFloat(cparams.aspect_ratio),
						parseFloat(cparams.znear), parseFloat(cparams.zfar));
	
				obj.add(cam);
			}
	
			for ( i = 0; i < node.lights.length; i ++ ) {
	
				var light = null;
				var instance_light = node.lights[i];
				var lparams = lights[instance_light.url];
	
				if ( lparams && lparams.technique ) {
	
					var color = lparams.color.getHex();
					var intensity = lparams.intensity;
					var distance = lparams.distance;
					var angle = lparams.falloff_angle;
					var exponent; // Intentionally undefined, don't know what this is yet
	
					switch ( lparams.technique ) {
	
						case 'directional':
	
							light = new THREE.DirectionalLight( color, intensity, distance );
							light.position.set(0, 0, 1);
							break;
	
						case 'point':
	
							light = new THREE.PointLight( color, intensity, distance );
							break;
	
						case 'spot':
	
							light = new THREE.SpotLight( color, intensity, distance, angle, exponent );
							light.position.set(0, 0, 1);
							break;
	
						case 'ambient':
	
							light = new THREE.AmbientLight( color );
							break;
	
					}
	
				}
	
				if (light) {
					obj.add(light);
				}
			}
	
			obj.name = node.name || node.id || "";
			obj.colladaId = node.id || "";
			obj.layer = node.layer || "";
			obj.matrix = node.matrix;
			obj.matrix.decompose( obj.position, obj.quaternion, obj.scale );
	
			if ( options.centerGeometry && obj.geometry ) {
	
				var delta = obj.geometry.center();
				delta.multiply( obj.scale );
				delta.applyQuaternion( obj.quaternion );
	
				obj.position.sub( delta );
	
			}
	
			for ( i = 0; i < node.nodes.length; i ++ ) {
	
				obj.add( createSceneGraph( node.nodes[i], node ) );
	
			}
	
			return obj;
	
		}
	
		function getJointId( skin, id ) {
	
			for ( var i = 0; i < skin.joints.length; i ++ ) {
	
				if ( skin.joints[ i ] === id ) {
	
					return i;
	
				}
	
			}
	
		}
	
		function getLibraryNode( id ) {
	
			var nodes = COLLADA.querySelectorAll('library_nodes node');
	
			for ( var i = 0; i < nodes.length; i++ ) {
	
				var attObj = nodes[i].attributes.getNamedItem('id');
	
				if ( attObj && attObj.value === id ) {
	
					return nodes[i];
	
				}
	
			}
	
			return undefined;
	
		}
	
		function getChannelsForNode ( node ) {
	
			var channels = [];
			var startTime = 1000000;
			var endTime = -1000000;
	
			for ( var id in animations ) {
	
				var animation = animations[id];
	
				for ( var i = 0; i < animation.channel.length; i ++ ) {
	
					var channel = animation.channel[i];
					var sampler = animation.sampler[i];
					var id = channel.target.split('/')[0];
	
					if ( id == node.id ) {
	
						sampler.create();
						channel.sampler = sampler;
						startTime = Math.min(startTime, sampler.startTime);
						endTime = Math.max(endTime, sampler.endTime);
						channels.push(channel);
	
					}
	
				}
	
			}
	
			if ( channels.length ) {
	
				node.startTime = startTime;
				node.endTime = endTime;
	
			}
	
			return channels;
	
		}
	
		function calcFrameDuration( node ) {
	
			var minT = 10000000;
	
			for ( var i = 0; i < node.channels.length; i ++ ) {
	
				var sampler = node.channels[i].sampler;
	
				for ( var j = 0; j < sampler.input.length - 1; j ++ ) {
	
					var t0 = sampler.input[ j ];
					var t1 = sampler.input[ j + 1 ];
					minT = Math.min( minT, t1 - t0 );
	
				}
			}
	
			return minT;
	
		}
	
		function calcMatrixAt( node, t ) {
	
			var animated = {};
	
			var i, j;
	
			for ( i = 0; i < node.channels.length; i ++ ) {
	
				var channel = node.channels[ i ];
				animated[ channel.sid ] = channel;
	
			}
	
			var matrix = new THREE.Matrix4();
	
			for ( i = 0; i < node.transforms.length; i ++ ) {
	
				var transform = node.transforms[ i ];
				var channel = animated[ transform.sid ];
	
				if ( channel !== undefined ) {
	
					var sampler = channel.sampler;
					var value;
	
					for ( j = 0; j < sampler.input.length - 1; j ++ ) {
	
						if ( sampler.input[ j + 1 ] > t ) {
	
							value = sampler.output[ j ];
							//console.log(value.flatten)
							break;
	
						}
	
					}
	
					if ( value !== undefined ) {
	
						if ( value instanceof THREE.Matrix4 ) {
	
							matrix.multiplyMatrices( matrix, value );
	
						} else {
	
							// FIXME: handle other types
	
							matrix.multiplyMatrices( matrix, transform.matrix );
	
						}
	
					} else {
	
						matrix.multiplyMatrices( matrix, transform.matrix );
	
					}
	
				} else {
	
					matrix.multiplyMatrices( matrix, transform.matrix );
	
				}
	
			}
	
			return matrix;
	
		}
	
		function bakeAnimations ( node ) {
	
			if ( node.channels && node.channels.length ) {
	
				var keys = [],
					sids = [];
	
				for ( var i = 0, il = node.channels.length; i < il; i ++ ) {
	
					var channel = node.channels[i],
						fullSid = channel.fullSid,
						sampler = channel.sampler,
						input = sampler.input,
						transform = node.getTransformBySid( channel.sid ),
						member;
	
					if ( channel.arrIndices ) {
	
						member = [];
	
						for ( var j = 0, jl = channel.arrIndices.length; j < jl; j ++ ) {
	
							member[ j ] = getConvertedIndex( channel.arrIndices[ j ] );
	
						}
	
					} else {
	
						member = getConvertedMember( channel.member );
	
					}
	
					if ( transform ) {
	
						if ( sids.indexOf( fullSid ) === -1 ) {
	
							sids.push( fullSid );
	
						}
	
						for ( var j = 0, jl = input.length; j < jl; j ++ ) {
	
							var time = input[j],
								data = sampler.getData( transform.type, j, member ),
								key = findKey( keys, time );
	
							if ( !key ) {
	
								key = new Key( time );
								var timeNdx = findTimeNdx( keys, time );
								keys.splice( timeNdx === -1 ? keys.length : timeNdx, 0, key );
	
							}
	
							key.addTarget( fullSid, transform, member, data );
	
						}
	
					} else {
	
						console.log( 'Could not find transform "' + channel.sid + '" in node ' + node.id );
	
					}
	
				}
	
				// post process
				for ( var i = 0; i < sids.length; i ++ ) {
	
					var sid = sids[ i ];
	
					for ( var j = 0; j < keys.length; j ++ ) {
	
						var key = keys[ j ];
	
						if ( !key.hasTarget( sid ) ) {
	
							interpolateKeys( keys, key, j, sid );
	
						}
	
					}
	
				}
	
				node.keys = keys;
				node.sids = sids;
	
			}
	
		}
	
		function findKey ( keys, time) {
	
			var retVal = null;
	
			for ( var i = 0, il = keys.length; i < il && retVal === null; i ++ ) {
	
				var key = keys[i];
	
				if ( key.time === time ) {
	
					retVal = key;
	
				} else if ( key.time > time ) {
	
					break;
	
				}
	
			}
	
			return retVal;
	
		}
	
		function findTimeNdx ( keys, time) {
	
			var ndx = -1;
	
			for ( var i = 0, il = keys.length; i < il && ndx === -1; i ++ ) {
	
				var key = keys[i];
	
				if ( key.time >= time ) {
	
					ndx = i;
	
				}
	
			}
	
			return ndx;
	
		}
	
		function interpolateKeys ( keys, key, ndx, fullSid ) {
	
			var prevKey = getPrevKeyWith( keys, fullSid, ndx ? ndx - 1 : 0 ),
				nextKey = getNextKeyWith( keys, fullSid, ndx + 1 );
	
			if ( prevKey && nextKey ) {
	
				var scale = (key.time - prevKey.time) / (nextKey.time - prevKey.time),
					prevTarget = prevKey.getTarget( fullSid ),
					nextData = nextKey.getTarget( fullSid ).data,
					prevData = prevTarget.data,
					data;
	
				if ( prevTarget.type === 'matrix' ) {
	
					data = prevData;
	
				} else if ( prevData.length ) {
	
					data = [];
	
					for ( var i = 0; i < prevData.length; ++ i ) {
	
						data[ i ] = prevData[ i ] + ( nextData[ i ] - prevData[ i ] ) * scale;
	
					}
	
				} else {
	
					data = prevData + ( nextData - prevData ) * scale;
	
				}
	
				key.addTarget( fullSid, prevTarget.transform, prevTarget.member, data );
	
			}
	
		}
	
		// Get next key with given sid
	
		function getNextKeyWith( keys, fullSid, ndx ) {
	
			for ( ; ndx < keys.length; ndx ++ ) {
	
				var key = keys[ ndx ];
	
				if ( key.hasTarget( fullSid ) ) {
	
					return key;
	
				}
	
			}
	
			return null;
	
		}
	
		// Get previous key with given sid
	
		function getPrevKeyWith( keys, fullSid, ndx ) {
	
			ndx = ndx >= 0 ? ndx : ndx + keys.length;
	
			for ( ; ndx >= 0; ndx -- ) {
	
				var key = keys[ ndx ];
	
				if ( key.hasTarget( fullSid ) ) {
	
					return key;
	
				}
	
			}
	
			return null;
	
		}
	
		function _Image() {
	
			this.id = "";
			this.init_from = "";
	
		}
	
		_Image.prototype.parse = function(element) {
	
			this.id = element.getAttribute('id');
	
			for ( var i = 0; i < element.childNodes.length; i ++ ) {
	
				var child = element.childNodes[ i ];
	
				if ( child.nodeName === 'init_from' ) {
	
					this.init_from = child.textContent;
	
				}
	
			}
	
			return this;
	
		};
	
		function Controller() {
	
			this.id = "";
			this.name = "";
			this.type = "";
			this.skin = null;
			this.morph = null;
	
		}
	
		Controller.prototype.parse = function( element ) {
	
			this.id = element.getAttribute('id');
			this.name = element.getAttribute('name');
			this.type = "none";
	
			for ( var i = 0; i < element.childNodes.length; i ++ ) {
	
				var child = element.childNodes[ i ];
	
				switch ( child.nodeName ) {
	
					case 'skin':
	
						this.skin = (new Skin()).parse(child);
						this.type = child.nodeName;
						break;
	
					case 'morph':
	
						this.morph = (new Morph()).parse(child);
						this.type = child.nodeName;
						break;
	
					default:
						break;
	
				}
			}
	
			return this;
	
		};
	
		function Morph() {
	
			this.method = null;
			this.source = null;
			this.targets = null;
			this.weights = null;
	
		}
	
		Morph.prototype.parse = function( element ) {
	
			var sources = {};
			var inputs = [];
			var i;
	
			this.method = element.getAttribute( 'method' );
			this.source = element.getAttribute( 'source' ).replace( /^#/, '' );
	
			for ( i = 0; i < element.childNodes.length; i ++ ) {
	
				var child = element.childNodes[ i ];
				if ( child.nodeType != 1 ) continue;
	
				switch ( child.nodeName ) {
	
					case 'source':
	
						var source = ( new Source() ).parse( child );
						sources[ source.id ] = source;
						break;
	
					case 'targets':
	
						inputs = this.parseInputs( child );
						break;
	
					default:
	
						console.log( child.nodeName );
						break;
	
				}
	
			}
	
			for ( i = 0; i < inputs.length; i ++ ) {
	
				var input = inputs[ i ];
				var source = sources[ input.source ];
	
				switch ( input.semantic ) {
	
					case 'MORPH_TARGET':
	
						this.targets = source.read();
						break;
	
					case 'MORPH_WEIGHT':
	
						this.weights = source.read();
						break;
	
					default:
						break;
	
				}
			}
	
			return this;
	
		};
	
		Morph.prototype.parseInputs = function(element) {
	
			var inputs = [];
	
			for ( var i = 0; i < element.childNodes.length; i ++ ) {
	
				var child = element.childNodes[i];
				if ( child.nodeType != 1) continue;
	
				switch ( child.nodeName ) {
	
					case 'input':
	
						inputs.push( (new Input()).parse(child) );
						break;
	
					default:
						break;
				}
			}
	
			return inputs;
	
		};
	
		function Skin() {
	
			this.source = "";
			this.bindShapeMatrix = null;
			this.invBindMatrices = [];
			this.joints = [];
			this.weights = [];
	
		}
	
		Skin.prototype.parse = function( element ) {
	
			var sources = {};
			var joints, weights;
	
			this.source = element.getAttribute( 'source' ).replace( /^#/, '' );
			this.invBindMatrices = [];
			this.joints = [];
			this.weights = [];
	
			for ( var i = 0; i < element.childNodes.length; i ++ ) {
	
				var child = element.childNodes[i];
				if ( child.nodeType != 1 ) continue;
	
				switch ( child.nodeName ) {
	
					case 'bind_shape_matrix':
	
						var f = _floats(child.textContent);
						this.bindShapeMatrix = getConvertedMat4( f );
						break;
	
					case 'source':
	
						var src = new Source().parse(child);
						sources[ src.id ] = src;
						break;
	
					case 'joints':
	
						joints = child;
						break;
	
					case 'vertex_weights':
	
						weights = child;
						break;
	
					default:
	
						console.log( child.nodeName );
						break;
	
				}
			}
	
			this.parseJoints( joints, sources );
			this.parseWeights( weights, sources );
	
			return this;
	
		};
	
		Skin.prototype.parseJoints = function ( element, sources ) {
	
			for ( var i = 0; i < element.childNodes.length; i ++ ) {
	
				var child = element.childNodes[ i ];
				if ( child.nodeType != 1 ) continue;
	
				switch ( child.nodeName ) {
	
					case 'input':
	
						var input = ( new Input() ).parse( child );
						var source = sources[ input.source ];
	
						if ( input.semantic === 'JOINT' ) {
	
							this.joints = source.read();
	
						} else if ( input.semantic === 'INV_BIND_MATRIX' ) {
	
							this.invBindMatrices = source.read();
	
						}
	
						break;
	
					default:
						break;
				}
	
			}
	
		};
	
		Skin.prototype.parseWeights = function ( element, sources ) {
	
			var v, vcount, inputs = [];
	
			for ( var i = 0; i < element.childNodes.length; i ++ ) {
	
				var child = element.childNodes[ i ];
				if ( child.nodeType != 1 ) continue;
	
				switch ( child.nodeName ) {
	
					case 'input':
	
						inputs.push( ( new Input() ).parse( child ) );
						break;
	
					case 'v':
	
						v = _ints( child.textContent );
						break;
	
					case 'vcount':
	
						vcount = _ints( child.textContent );
						break;
	
					default:
						break;
	
				}
	
			}
	
			var index = 0;
	
			for ( var i = 0; i < vcount.length; i ++ ) {
	
				var numBones = vcount[i];
				var vertex_weights = [];
	
				for ( var j = 0; j < numBones; j ++ ) {
	
					var influence = {};
	
					for ( var k = 0; k < inputs.length; k ++ ) {
	
						var input = inputs[ k ];
						var value = v[ index + input.offset ];
	
						switch ( input.semantic ) {
	
							case 'JOINT':
	
								influence.joint = value;//this.joints[value];
								break;
	
							case 'WEIGHT':
	
								influence.weight = sources[ input.source ].data[ value ];
								break;
	
							default:
								break;
	
						}
	
					}
	
					vertex_weights.push( influence );
					index += inputs.length;
				}
	
				for ( var j = 0; j < vertex_weights.length; j ++ ) {
	
					vertex_weights[ j ].index = i;
	
				}
	
				this.weights.push( vertex_weights );
	
			}
	
		};
	
		function VisualScene () {
	
			this.id = "";
			this.name = "";
			this.nodes = [];
			this.scene = new THREE.Group();
	
		}
	
		VisualScene.prototype.getChildById = function( id, recursive ) {
	
			for ( var i = 0; i < this.nodes.length; i ++ ) {
	
				var node = this.nodes[ i ].getChildById( id, recursive );
	
				if ( node ) {
	
					return node;
	
				}
	
			}
	
			return null;
	
		};
	
		VisualScene.prototype.getChildBySid = function( sid, recursive ) {
	
			for ( var i = 0; i < this.nodes.length; i ++ ) {
	
				var node = this.nodes[ i ].getChildBySid( sid, recursive );
	
				if ( node ) {
	
					return node;
	
				}
	
			}
	
			return null;
	
		};
	
		VisualScene.prototype.parse = function( element ) {
	
			this.id = element.getAttribute( 'id' );
			this.name = element.getAttribute( 'name' );
			this.nodes = [];
	
			for ( var i = 0; i < element.childNodes.length; i ++ ) {
	
				var child = element.childNodes[ i ];
				if ( child.nodeType != 1 ) continue;
	
				switch ( child.nodeName ) {
	
					case 'node':
	
						this.nodes.push( ( new Node() ).parse( child ) );
						break;
	
					default:
						break;
	
				}
	
			}
	
			return this;
	
		};
	
		function Node() {
	
			this.id = "";
			this.name = "";
			this.sid = "";
			this.nodes = [];
			this.controllers = [];
			this.transforms = [];
			this.geometries = [];
			this.channels = [];
			this.matrix = new THREE.Matrix4();
	
		}
	
		Node.prototype.getChannelForTransform = function( transformSid ) {
	
			for ( var i = 0; i < this.channels.length; i ++ ) {
	
				var channel = this.channels[i];
				var parts = channel.target.split('/');
				var id = parts.shift();
				var sid = parts.shift();
				var dotSyntax = (sid.indexOf(".") >= 0);
				var arrSyntax = (sid.indexOf("(") >= 0);
				var arrIndices;
				var member;
	
				if ( dotSyntax ) {
	
					parts = sid.split(".");
					sid = parts.shift();
					member = parts.shift();
	
				} else if ( arrSyntax ) {
	
					arrIndices = sid.split("(");
					sid = arrIndices.shift();
	
					for ( var j = 0; j < arrIndices.length; j ++ ) {
	
						arrIndices[ j ] = parseInt( arrIndices[ j ].replace( /\)/, '' ) );
	
					}
	
				}
	
				if ( sid === transformSid ) {
	
					channel.info = { sid: sid, dotSyntax: dotSyntax, arrSyntax: arrSyntax, arrIndices: arrIndices };
					return channel;
	
				}
	
			}
	
			return null;
	
		};
	
		Node.prototype.getChildById = function ( id, recursive ) {
	
			if ( this.id === id ) {
	
				return this;
	
			}
	
			if ( recursive ) {
	
				for ( var i = 0; i < this.nodes.length; i ++ ) {
	
					var n = this.nodes[ i ].getChildById( id, recursive );
	
					if ( n ) {
	
						return n;
	
					}
	
				}
	
			}
	
			return null;
	
		};
	
		Node.prototype.getChildBySid = function ( sid, recursive ) {
	
			if ( this.sid === sid ) {
	
				return this;
	
			}
	
			if ( recursive ) {
	
				for ( var i = 0; i < this.nodes.length; i ++ ) {
	
					var n = this.nodes[ i ].getChildBySid( sid, recursive );
	
					if ( n ) {
	
						return n;
	
					}
	
				}
			}
	
			return null;
	
		};
	
		Node.prototype.getTransformBySid = function ( sid ) {
	
			for ( var i = 0; i < this.transforms.length; i ++ ) {
	
				if ( this.transforms[ i ].sid === sid ) return this.transforms[ i ];
	
			}
	
			return null;
	
		};
	
		Node.prototype.parse = function( element ) {
	
			var url;
	
			this.id = element.getAttribute('id');
			this.sid = element.getAttribute('sid');
			this.name = element.getAttribute('name');
			this.type = element.getAttribute('type');
			this.layer = element.getAttribute('layer');
	
			this.type = this.type === 'JOINT' ? this.type : 'NODE';
	
			this.nodes = [];
			this.transforms = [];
			this.geometries = [];
			this.cameras = [];
			this.lights = [];
			this.controllers = [];
			this.matrix = new THREE.Matrix4();
	
			for ( var i = 0; i < element.childNodes.length; i ++ ) {
	
				var child = element.childNodes[ i ];
				if ( child.nodeType != 1 ) continue;
	
				switch ( child.nodeName ) {
	
					case 'node':
	
						this.nodes.push( ( new Node() ).parse( child ) );
						break;
	
					case 'instance_camera':
	
						this.cameras.push( ( new InstanceCamera() ).parse( child ) );
						break;
	
					case 'instance_controller':
	
						this.controllers.push( ( new InstanceController() ).parse( child ) );
						break;
	
					case 'instance_geometry':
	
						this.geometries.push( ( new InstanceGeometry() ).parse( child ) );
						break;
	
					case 'instance_light':
	
						this.lights.push( ( new InstanceLight() ).parse( child ) );
						break;
	
					case 'instance_node':
	
						url = child.getAttribute( 'url' ).replace( /^#/, '' );
						var iNode = getLibraryNode( url );
	
						if ( iNode ) {
	
							this.nodes.push( ( new Node() ).parse( iNode )) ;
	
						}
	
						break;
	
					case 'rotate':
					case 'translate':
					case 'scale':
					case 'matrix':
					case 'lookat':
					case 'skew':
	
						this.transforms.push( ( new Transform() ).parse( child ) );
						break;
	
					case 'extra':
						break;
	
					default:
	
						console.log( child.nodeName );
						break;
	
				}
	
			}
	
			this.channels = getChannelsForNode( this );
			bakeAnimations( this );
	
			this.updateMatrix();
	
			return this;
	
		};
	
		Node.prototype.updateMatrix = function () {
	
			this.matrix.identity();
	
			for ( var i = 0; i < this.transforms.length; i ++ ) {
	
				this.transforms[ i ].apply( this.matrix );
	
			}
	
		};
	
		function Transform () {
	
			this.sid = "";
			this.type = "";
			this.data = [];
			this.obj = null;
	
		}
	
		Transform.prototype.parse = function ( element ) {
	
			this.sid = element.getAttribute( 'sid' );
			this.type = element.nodeName;
			this.data = _floats( element.textContent );
			this.convert();
	
			return this;
	
		};
	
		Transform.prototype.convert = function () {
	
			switch ( this.type ) {
	
				case 'matrix':
	
					this.obj = getConvertedMat4( this.data );
					break;
	
				case 'rotate':
	
					this.angle = THREE.Math.degToRad( this.data[3] );
	
				case 'translate':
	
					fixCoords( this.data, -1 );
					this.obj = new THREE.Vector3( this.data[ 0 ], this.data[ 1 ], this.data[ 2 ] );
					break;
	
				case 'scale':
	
					fixCoords( this.data, 1 );
					this.obj = new THREE.Vector3( this.data[ 0 ], this.data[ 1 ], this.data[ 2 ] );
					break;
	
				default:
					console.log( 'Can not convert Transform of type ' + this.type );
					break;
	
			}
	
		};
	
		Transform.prototype.apply = function () {
	
			var m1 = new THREE.Matrix4();
	
			return function ( matrix ) {
	
				switch ( this.type ) {
	
					case 'matrix':
	
						matrix.multiply( this.obj );
	
						break;
	
					case 'translate':
	
						matrix.multiply( m1.makeTranslation( this.obj.x, this.obj.y, this.obj.z ) );
	
						break;
	
					case 'rotate':
	
						matrix.multiply( m1.makeRotationAxis( this.obj, this.angle ) );
	
						break;
	
					case 'scale':
	
						matrix.scale( this.obj );
	
						break;
	
				}
	
			};
	
		}();
	
		Transform.prototype.update = function ( data, member ) {
	
			var members = [ 'X', 'Y', 'Z', 'ANGLE' ];
	
			switch ( this.type ) {
	
				case 'matrix':
	
					if ( ! member ) {
	
						this.obj.copy( data );
	
					} else if ( member.length === 1 ) {
	
						switch ( member[ 0 ] ) {
	
							case 0:
	
								this.obj.n11 = data[ 0 ];
								this.obj.n21 = data[ 1 ];
								this.obj.n31 = data[ 2 ];
								this.obj.n41 = data[ 3 ];
	
								break;
	
							case 1:
	
								this.obj.n12 = data[ 0 ];
								this.obj.n22 = data[ 1 ];
								this.obj.n32 = data[ 2 ];
								this.obj.n42 = data[ 3 ];
	
								break;
	
							case 2:
	
								this.obj.n13 = data[ 0 ];
								this.obj.n23 = data[ 1 ];
								this.obj.n33 = data[ 2 ];
								this.obj.n43 = data[ 3 ];
	
								break;
	
							case 3:
	
								this.obj.n14 = data[ 0 ];
								this.obj.n24 = data[ 1 ];
								this.obj.n34 = data[ 2 ];
								this.obj.n44 = data[ 3 ];
	
								break;
	
						}
	
					} else if ( member.length === 2 ) {
	
						var propName = 'n' + ( member[ 0 ] + 1 ) + ( member[ 1 ] + 1 );
						this.obj[ propName ] = data;
	
					} else {
	
						console.log('Incorrect addressing of matrix in transform.');
	
					}
	
					break;
	
				case 'translate':
				case 'scale':
	
					if ( Object.prototype.toString.call( member ) === '[object Array]' ) {
	
						member = members[ member[ 0 ] ];
	
					}
	
					switch ( member ) {
	
						case 'X':
	
							this.obj.x = data;
							break;
	
						case 'Y':
	
							this.obj.y = data;
							break;
	
						case 'Z':
	
							this.obj.z = data;
							break;
	
						default:
	
							this.obj.x = data[ 0 ];
							this.obj.y = data[ 1 ];
							this.obj.z = data[ 2 ];
							break;
	
					}
	
					break;
	
				case 'rotate':
	
					if ( Object.prototype.toString.call( member ) === '[object Array]' ) {
	
						member = members[ member[ 0 ] ];
	
					}
	
					switch ( member ) {
	
						case 'X':
	
							this.obj.x = data;
							break;
	
						case 'Y':
	
							this.obj.y = data;
							break;
	
						case 'Z':
	
							this.obj.z = data;
							break;
	
						case 'ANGLE':
	
							this.angle = THREE.Math.degToRad( data );
							break;
	
						default:
	
							this.obj.x = data[ 0 ];
							this.obj.y = data[ 1 ];
							this.obj.z = data[ 2 ];
							this.angle = THREE.Math.degToRad( data[ 3 ] );
							break;
	
					}
					break;
	
			}
	
		};
	
		function InstanceController() {
	
			this.url = "";
			this.skeleton = [];
			this.instance_material = [];
	
		}
	
		InstanceController.prototype.parse = function ( element ) {
	
			this.url = element.getAttribute('url').replace(/^#/, '');
			this.skeleton = [];
			this.instance_material = [];
	
			for ( var i = 0; i < element.childNodes.length; i ++ ) {
	
				var child = element.childNodes[ i ];
				if ( child.nodeType !== 1 ) continue;
	
				switch ( child.nodeName ) {
	
					case 'skeleton':
	
						this.skeleton.push( child.textContent.replace(/^#/, '') );
						break;
	
					case 'bind_material':
	
						var instances = child.querySelectorAll('instance_material');
	
						for ( var j = 0; j < instances.length; j ++ ) {
	
							var instance = instances[j];
							this.instance_material.push( (new InstanceMaterial()).parse(instance) );
	
						}
	
	
						break;
	
					case 'extra':
						break;
	
					default:
						break;
	
				}
			}
	
			return this;
	
		};
	
		function InstanceMaterial () {
	
			this.symbol = "";
			this.target = "";
	
		}
	
		InstanceMaterial.prototype.parse = function ( element ) {
	
			this.symbol = element.getAttribute('symbol');
			this.target = element.getAttribute('target').replace(/^#/, '');
			return this;
	
		};
	
		function InstanceGeometry() {
	
			this.url = "";
			this.instance_material = [];
	
		}
	
		InstanceGeometry.prototype.parse = function ( element ) {
	
			this.url = element.getAttribute('url').replace(/^#/, '');
			this.instance_material = [];
	
			for ( var i = 0; i < element.childNodes.length; i ++ ) {
	
				var child = element.childNodes[i];
				if ( child.nodeType != 1 ) continue;
	
				if ( child.nodeName === 'bind_material' ) {
	
					var instances = child.querySelectorAll('instance_material');
	
					for ( var j = 0; j < instances.length; j ++ ) {
	
						var instance = instances[j];
						this.instance_material.push( (new InstanceMaterial()).parse(instance) );
	
					}
	
					break;
	
				}
	
			}
	
			return this;
	
		};
	
		function Geometry() {
	
			this.id = "";
			this.mesh = null;
	
		}
	
		Geometry.prototype.parse = function ( element ) {
	
			this.id = element.getAttribute('id');
	
			extractDoubleSided( this, element );
	
			for ( var i = 0; i < element.childNodes.length; i ++ ) {
	
				var child = element.childNodes[i];
	
				switch ( child.nodeName ) {
	
					case 'mesh':
	
						this.mesh = (new Mesh(this)).parse(child);
						break;
	
					case 'extra':
	
						// console.log( child );
						break;
	
					default:
						break;
				}
			}
	
			return this;
	
		};
	
		function Mesh( geometry ) {
	
			this.geometry = geometry.id;
			this.primitives = [];
			this.vertices = null;
			this.geometry3js = null;
	
		}
	
		Mesh.prototype.parse = function ( element ) {
	
			this.primitives = [];
	
			for ( var i = 0; i < element.childNodes.length; i ++ ) {
	
				var child = element.childNodes[ i ];
	
				switch ( child.nodeName ) {
	
					case 'source':
	
						_source( child );
						break;
	
					case 'vertices':
	
						this.vertices = ( new Vertices() ).parse( child );
						break;
	
					case 'linestrips':
	
						this.primitives.push( ( new LineStrips().parse( child ) ) );
						break;
	
					case 'triangles':
	
						this.primitives.push( ( new Triangles().parse( child ) ) );
						break;
	
					case 'polygons':
	
						this.primitives.push( ( new Polygons().parse( child ) ) );
						break;
	
					case 'polylist':
	
						this.primitives.push( ( new Polylist().parse( child ) ) );
						break;
	
					default:
						break;
	
				}
	
			}
	
			this.geometry3js = new THREE.Geometry();
	
			if ( this.vertices === null ) {
	
				// TODO (mrdoob): Study case when this is null (carrier.dae)
	
				return this;
	
			}
	
			var vertexData = sources[ this.vertices.input['POSITION'].source ].data;
	
			for ( var i = 0; i < vertexData.length; i += 3 ) {
	
				this.geometry3js.vertices.push( getConvertedVec3( vertexData, i ).clone() );
	
			}
	
			for ( var i = 0; i < this.primitives.length; i ++ ) {
	
				var primitive = this.primitives[ i ];
				primitive.setVertices( this.vertices );
				this.handlePrimitive( primitive, this.geometry3js );
	
			}
	
			if ( this.geometry3js.calcNormals ) {
	
				this.geometry3js.computeVertexNormals();
				delete this.geometry3js.calcNormals;
	
			}
	
			return this;
	
		};
	
		Mesh.prototype.handlePrimitive = function ( primitive, geom ) {
	
			if ( primitive instanceof LineStrips ) {
	
				// TODO: Handle indices. Maybe easier with BufferGeometry?
	
				geom.isLineStrip = true;
				return;
	
			}
	
			var j, k, pList = primitive.p, inputs = primitive.inputs;
			var input, index, idx32;
			var source, numParams;
			var vcIndex = 0, vcount = 3, maxOffset = 0;
			var texture_sets = [];
	
			for ( j = 0; j < inputs.length; j ++ ) {
	
				input = inputs[ j ];
	
				var offset = input.offset + 1;
				maxOffset = (maxOffset < offset) ? offset : maxOffset;
	
				switch ( input.semantic ) {
	
					case 'TEXCOORD':
						texture_sets.push( input.set );
						break;
	
				}
	
			}
	
			for ( var pCount = 0; pCount < pList.length; ++ pCount ) {
	
				var p = pList[ pCount ], i = 0;
	
				while ( i < p.length ) {
	
					var vs = [];
					var ns = [];
					var ts = null;
					var cs = [];
	
					if ( primitive.vcount ) {
	
						vcount = primitive.vcount.length ? primitive.vcount[ vcIndex ++ ] : primitive.vcount;
	
					} else {
	
						vcount = p.length / maxOffset;
	
					}
	
	
					for ( j = 0; j < vcount; j ++ ) {
	
						for ( k = 0; k < inputs.length; k ++ ) {
	
							input = inputs[ k ];
							source = sources[ input.source ];
	
							index = p[ i + ( j * maxOffset ) + input.offset ];
							numParams = source.accessor.params.length;
							idx32 = index * numParams;
	
							switch ( input.semantic ) {
	
								case 'VERTEX':
	
									vs.push( index );
	
									break;
	
								case 'NORMAL':
	
									ns.push( getConvertedVec3( source.data, idx32 ) );
	
									break;
	
								case 'TEXCOORD':
	
									ts = ts || { };
									if ( ts[ input.set ] === undefined ) ts[ input.set ] = [];
									// invert the V
									ts[ input.set ].push( new THREE.Vector2( source.data[ idx32 ], source.data[ idx32 + 1 ] ) );
	
									break;
	
								case 'COLOR':
	
									cs.push( new THREE.Color().setRGB( source.data[ idx32 ], source.data[ idx32 + 1 ], source.data[ idx32 + 2 ] ) );
	
									break;
	
								default:
	
									break;
	
							}
	
						}
	
					}
	
					if ( ns.length === 0 ) {
	
						// check the vertices inputs
						input = this.vertices.input.NORMAL;
	
						if ( input ) {
	
							source = sources[ input.source ];
							numParams = source.accessor.params.length;
	
							for ( var ndx = 0, len = vs.length; ndx < len; ndx ++ ) {
	
								ns.push( getConvertedVec3( source.data, vs[ ndx ] * numParams ) );
	
							}
	
						} else {
	
							geom.calcNormals = true;
	
						}
	
					}
	
					if ( !ts ) {
	
						ts = { };
						// check the vertices inputs
						input = this.vertices.input.TEXCOORD;
	
						if ( input ) {
	
							texture_sets.push( input.set );
							source = sources[ input.source ];
							numParams = source.accessor.params.length;
	
							for ( var ndx = 0, len = vs.length; ndx < len; ndx ++ ) {
	
								idx32 = vs[ ndx ] * numParams;
								if ( ts[ input.set ] === undefined ) ts[ input.set ] = [ ];
								// invert the V
								ts[ input.set ].push( new THREE.Vector2( source.data[ idx32 ], 1.0 - source.data[ idx32 + 1 ] ) );
	
							}
	
						}
	
					}
	
					if ( cs.length === 0 ) {
	
						// check the vertices inputs
						input = this.vertices.input.COLOR;
	
						if ( input ) {
	
							source = sources[ input.source ];
							numParams = source.accessor.params.length;
	
							for ( var ndx = 0, len = vs.length; ndx < len; ndx ++ ) {
	
								idx32 = vs[ ndx ] * numParams;
								cs.push( new THREE.Color().setRGB( source.data[ idx32 ], source.data[ idx32 + 1 ], source.data[ idx32 + 2 ] ) );
	
							}
	
						}
	
					}
	
					var face = null, faces = [], uv, uvArr;
	
					if ( vcount === 3 ) {
	
						faces.push( new THREE.Face3( vs[0], vs[1], vs[2], ns, cs.length ? cs : new THREE.Color() ) );
	
					} else if ( vcount === 4 ) {
	
						faces.push( new THREE.Face3( vs[0], vs[1], vs[3], ns.length ? [ ns[0].clone(), ns[1].clone(), ns[3].clone() ] : [], cs.length ? [ cs[0], cs[1], cs[3] ] : new THREE.Color() ) );
	
						faces.push( new THREE.Face3( vs[1], vs[2], vs[3], ns.length ? [ ns[1].clone(), ns[2].clone(), ns[3].clone() ] : [], cs.length ? [ cs[1], cs[2], cs[3] ] : new THREE.Color() ) );
	
					} else if ( vcount > 4 && options.subdivideFaces ) {
	
						var clr = cs.length ? cs : new THREE.Color(),
							vec1, vec2, vec3, v1, v2, norm;
	
						// subdivide into multiple Face3s
	
						for ( k = 1; k < vcount - 1; ) {
	
							faces.push( new THREE.Face3( vs[0], vs[k], vs[k + 1], ns.length ? [ ns[0].clone(), ns[k ++].clone(), ns[k].clone() ] : [], clr ) );
	
						}
	
					}
	
					if ( faces.length ) {
	
						for ( var ndx = 0, len = faces.length; ndx < len; ndx ++ ) {
	
							face = faces[ndx];
							face.daeMaterial = primitive.material;
							geom.faces.push( face );
	
							for ( k = 0; k < texture_sets.length; k ++ ) {
	
								uv = ts[ texture_sets[k] ];
	
								if ( vcount > 4 ) {
	
									// Grab the right UVs for the vertices in this face
									uvArr = [ uv[0], uv[ndx + 1], uv[ndx + 2] ];
	
								} else if ( vcount === 4 ) {
	
									if ( ndx === 0 ) {
	
										uvArr = [ uv[0], uv[1], uv[3] ];
	
									} else {
	
										uvArr = [ uv[1].clone(), uv[2], uv[3].clone() ];
	
									}
	
								} else {
	
									uvArr = [ uv[0], uv[1], uv[2] ];
	
								}
	
								if ( geom.faceVertexUvs[k] === undefined ) {
	
									geom.faceVertexUvs[k] = [];
	
								}
	
								geom.faceVertexUvs[k].push( uvArr );
	
							}
	
						}
	
					} else {
	
						console.log( 'dropped face with vcount ' + vcount + ' for geometry with id: ' + geom.id );
	
					}
	
					i += maxOffset * vcount;
	
				}
	
			}
	
		};
	
		function Polygons () {
	
			this.material = "";
			this.count = 0;
			this.inputs = [];
			this.vcount = null;
			this.p = [];
			this.geometry = new THREE.Geometry();
	
		}
	
		Polygons.prototype.setVertices = function ( vertices ) {
	
			for ( var i = 0; i < this.inputs.length; i ++ ) {
	
				if ( this.inputs[ i ].source === vertices.id ) {
	
					this.inputs[ i ].source = vertices.input[ 'POSITION' ].source;
	
				}
	
			}
	
		};
	
		Polygons.prototype.parse = function ( element ) {
	
			this.material = element.getAttribute( 'material' );
			this.count = _attr_as_int( element, 'count', 0 );
	
			for ( var i = 0; i < element.childNodes.length; i ++ ) {
	
				var child = element.childNodes[ i ];
	
				switch ( child.nodeName ) {
	
					case 'input':
	
						this.inputs.push( ( new Input() ).parse( element.childNodes[ i ] ) );
						break;
	
					case 'vcount':
	
						this.vcount = _ints( child.textContent );
						break;
	
					case 'p':
	
						this.p.push( _ints( child.textContent ) );
						break;
	
					case 'ph':
	
						console.warn( 'polygon holes not yet supported!' );
						break;
	
					default:
						break;
	
				}
	
			}
	
			return this;
	
		};
	
		function Polylist () {
	
			Polygons.call( this );
	
			this.vcount = [];
	
		}
	
		Polylist.prototype = Object.create( Polygons.prototype );
		Polylist.prototype.constructor = Polylist;
	
		function LineStrips() {
	
			Polygons.call( this );
	
			this.vcount = 1;
	
		}
	
		LineStrips.prototype = Object.create( Polygons.prototype );
		LineStrips.prototype.constructor = LineStrips;
	
		function Triangles () {
	
			Polygons.call( this );
	
			this.vcount = 3;
	
		}
	
		Triangles.prototype = Object.create( Polygons.prototype );
		Triangles.prototype.constructor = Triangles;
	
		function Accessor() {
	
			this.source = "";
			this.count = 0;
			this.stride = 0;
			this.params = [];
	
		}
	
		Accessor.prototype.parse = function ( element ) {
	
			this.params = [];
			this.source = element.getAttribute( 'source' );
			this.count = _attr_as_int( element, 'count', 0 );
			this.stride = _attr_as_int( element, 'stride', 0 );
	
			for ( var i = 0; i < element.childNodes.length; i ++ ) {
	
				var child = element.childNodes[ i ];
	
				if ( child.nodeName === 'param' ) {
	
					var param = {};
					param[ 'name' ] = child.getAttribute( 'name' );
					param[ 'type' ] = child.getAttribute( 'type' );
					this.params.push( param );
	
				}
	
			}
	
			return this;
	
		};
	
		function Vertices() {
	
			this.input = {};
	
		}
	
		Vertices.prototype.parse = function ( element ) {
	
			this.id = element.getAttribute('id');
	
			for ( var i = 0; i < element.childNodes.length; i ++ ) {
	
				if ( element.childNodes[i].nodeName === 'input' ) {
	
					var input = ( new Input() ).parse( element.childNodes[ i ] );
					this.input[ input.semantic ] = input;
	
				}
	
			}
	
			return this;
	
		};
	
		function Input () {
	
			this.semantic = "";
			this.offset = 0;
			this.source = "";
			this.set = 0;
	
		}
	
		Input.prototype.parse = function ( element ) {
	
			this.semantic = element.getAttribute('semantic');
			this.source = element.getAttribute('source').replace(/^#/, '');
			this.set = _attr_as_int(element, 'set', -1);
			this.offset = _attr_as_int(element, 'offset', 0);
	
			if ( this.semantic === 'TEXCOORD' && this.set < 0 ) {
	
				this.set = 0;
	
			}
	
			return this;
	
		};
	
		function Source ( id ) {
	
			this.id = id;
			this.type = null;
	
		}
	
		Source.prototype.parse = function ( element ) {
	
			this.id = element.getAttribute( 'id' );
	
			for ( var i = 0; i < element.childNodes.length; i ++ ) {
	
				var child = element.childNodes[i];
	
				switch ( child.nodeName ) {
	
					case 'bool_array':
	
						this.data = _bools( child.textContent );
						this.type = child.nodeName;
						break;
	
					case 'float_array':
	
						this.data = _floats( child.textContent );
						this.type = child.nodeName;
						break;
	
					case 'int_array':
	
						this.data = _ints( child.textContent );
						this.type = child.nodeName;
						break;
	
					case 'IDREF_array':
					case 'Name_array':
	
						this.data = _strings( child.textContent );
						this.type = child.nodeName;
						break;
	
					case 'technique_common':
	
						for ( var j = 0; j < child.childNodes.length; j ++ ) {
	
							if ( child.childNodes[ j ].nodeName === 'accessor' ) {
	
								this.accessor = ( new Accessor() ).parse( child.childNodes[ j ] );
								break;
	
							}
						}
						break;
	
					default:
						// console.log(child.nodeName);
						break;
	
				}
	
			}
	
			return this;
	
		};
	
		Source.prototype.read = function () {
	
			var result = [];
	
			//for (var i = 0; i < this.accessor.params.length; i++) {
	
			var param = this.accessor.params[ 0 ];
	
				//console.log(param.name + " " + param.type);
	
			switch ( param.type ) {
	
				case 'IDREF':
				case 'Name': case 'name':
				case 'float':
	
					return this.data;
	
				case 'float4x4':
	
					for ( var j = 0; j < this.data.length; j += 16 ) {
	
						var s = this.data.slice( j, j + 16 );
						var m = getConvertedMat4( s );
						result.push( m );
					}
	
					break;
	
				default:
	
					console.log( 'ColladaLoader: Source: Read dont know how to read ' + param.type + '.' );
					break;
	
			}
	
			//}
	
			return result;
	
		};
	
		function Material () {
	
			this.id = "";
			this.name = "";
			this.instance_effect = null;
	
		}
	
		Material.prototype.parse = function ( element ) {
	
			this.id = element.getAttribute( 'id' );
			this.name = element.getAttribute( 'name' );
	
			for ( var i = 0; i < element.childNodes.length; i ++ ) {
	
				if ( element.childNodes[ i ].nodeName === 'instance_effect' ) {
	
					this.instance_effect = ( new InstanceEffect() ).parse( element.childNodes[ i ] );
					break;
	
				}
	
			}
	
			return this;
	
		};
	
		function ColorOrTexture () {
	
			this.color = new THREE.Color();
			this.color.setRGB( Math.random(), Math.random(), Math.random() );
			this.color.a = 1.0;
	
			this.texture = null;
			this.texcoord = null;
			this.texOpts = null;
	
		}
	
		ColorOrTexture.prototype.isColor = function () {
	
			return ( this.texture === null );
	
		};
	
		ColorOrTexture.prototype.isTexture = function () {
	
			return ( this.texture != null );
	
		};
	
		ColorOrTexture.prototype.parse = function ( element ) {
	
			if (element.nodeName === 'transparent') {
	
				this.opaque = element.getAttribute('opaque');
	
			}
	
			for ( var i = 0; i < element.childNodes.length; i ++ ) {
	
				var child = element.childNodes[ i ];
				if ( child.nodeType != 1 ) continue;
	
				switch ( child.nodeName ) {
	
					case 'color':
	
						var rgba = _floats( child.textContent );
						this.color = new THREE.Color();
						this.color.setRGB( rgba[0], rgba[1], rgba[2] );
						this.color.a = rgba[3];
						break;
	
					case 'texture':
	
						this.texture = child.getAttribute('texture');
						this.texcoord = child.getAttribute('texcoord');
						// Defaults from:
						// https://collada.org/mediawiki/index.php/Maya_texture_placement_MAYA_extension
						this.texOpts = {
							offsetU: 0,
							offsetV: 0,
							repeatU: 1,
							repeatV: 1,
							wrapU: 1,
							wrapV: 1
						};
						this.parseTexture( child );
						break;
	
					default:
						break;
	
				}
	
			}
	
			return this;
	
		};
	
		ColorOrTexture.prototype.parseTexture = function ( element ) {
	
			if ( ! element.childNodes ) return this;
	
			// This should be supported by Maya, 3dsMax, and MotionBuilder
	
			if ( element.childNodes[1] && element.childNodes[1].nodeName === 'extra' ) {
	
				element = element.childNodes[1];
	
				if ( element.childNodes[1] && element.childNodes[1].nodeName === 'technique' ) {
	
					element = element.childNodes[1];
	
				}
	
			}
	
			for ( var i = 0; i < element.childNodes.length; i ++ ) {
	
				var child = element.childNodes[ i ];
	
				switch ( child.nodeName ) {
	
					case 'offsetU':
					case 'offsetV':
					case 'repeatU':
					case 'repeatV':
	
						this.texOpts[ child.nodeName ] = parseFloat( child.textContent );
	
						break;
	
					case 'wrapU':
					case 'wrapV':
	
						// some dae have a value of true which becomes NaN via parseInt
	
						if ( child.textContent.toUpperCase() === 'TRUE' ) {
	
							this.texOpts[ child.nodeName ] = 1;
	
						} else {
	
							this.texOpts[ child.nodeName ] = parseInt( child.textContent );
	
						}
						break;
	
					default:
	
						this.texOpts[ child.nodeName ] = child.textContent;
	
						break;
	
				}
	
			}
	
			return this;
	
		};
	
		function Shader ( type, effect ) {
	
			this.type = type;
			this.effect = effect;
			this.material = null;
	
		}
	
		Shader.prototype.parse = function ( element ) {
	
			for ( var i = 0; i < element.childNodes.length; i ++ ) {
	
				var child = element.childNodes[ i ];
				if ( child.nodeType != 1 ) continue;
	
				switch ( child.nodeName ) {
	
					case 'emission':
					case 'diffuse':
					case 'specular':
					case 'transparent':
	
						this[ child.nodeName ] = ( new ColorOrTexture() ).parse( child );
						break;
	
					case 'bump':
	
						// If 'bumptype' is 'heightfield', create a 'bump' property
						// Else if 'bumptype' is 'normalmap', create a 'normal' property
						// (Default to 'bump')
						var bumpType = child.getAttribute( 'bumptype' );
						if ( bumpType ) {
							if ( bumpType.toLowerCase() === "heightfield" ) {
								this[ 'bump' ] = ( new ColorOrTexture() ).parse( child );
							} else if ( bumpType.toLowerCase() === "normalmap" ) {
								this[ 'normal' ] = ( new ColorOrTexture() ).parse( child );
							} else {
								console.error( "Shader.prototype.parse: Invalid value for attribute 'bumptype' (" + bumpType + ") - valid bumptypes are 'HEIGHTFIELD' and 'NORMALMAP' - defaulting to 'HEIGHTFIELD'" );
								this[ 'bump' ] = ( new ColorOrTexture() ).parse( child );
							}
						} else {
							console.warn( "Shader.prototype.parse: Attribute 'bumptype' missing from bump node - defaulting to 'HEIGHTFIELD'" );
							this[ 'bump' ] = ( new ColorOrTexture() ).parse( child );
						}
	
						break;
	
					case 'shininess':
					case 'reflectivity':
					case 'index_of_refraction':
					case 'transparency':
	
						var f = child.querySelectorAll('float');
	
						if ( f.length > 0 )
							this[ child.nodeName ] = parseFloat( f[ 0 ].textContent );
	
						break;
	
					default:
						break;
	
				}
	
			}
	
			this.create();
			return this;
	
		};
	
		Shader.prototype.create = function() {
	
			var props = {};
	
			var transparent = false;
	
			if (this['transparency'] !== undefined && this['transparent'] !== undefined) {
				// convert transparent color RBG to average value
				var transparentColor = this['transparent'];
				var transparencyLevel = (this.transparent.color.r + this.transparent.color.g + this.transparent.color.b) / 3 * this.transparency;
	
				if (transparencyLevel > 0) {
					transparent = true;
					props[ 'transparent' ] = true;
					props[ 'opacity' ] = 1 - transparencyLevel;
	
				}
	
			}
	
			var keys = {
				'diffuse':'map',
				'ambient':'lightMap',
				'specular':'specularMap',
				'emission':'emissionMap',
				'bump':'bumpMap',
				'normal':'normalMap'
				};
	
			for ( var prop in this ) {
	
				switch ( prop ) {
	
					case 'ambient':
					case 'emission':
					case 'diffuse':
					case 'specular':
					case 'bump':
					case 'normal':
	
						var cot = this[ prop ];
	
						if ( cot instanceof ColorOrTexture ) {
	
							if ( cot.isTexture() ) {
	
								var samplerId = cot.texture;
								var surfaceId = this.effect.sampler[samplerId];
	
								if ( surfaceId !== undefined && surfaceId.source !== undefined ) {
	
									var surface = this.effect.surface[surfaceId.source];
	
									if ( surface !== undefined ) {
	
										var image = images[ surface.init_from ];
	
										if ( image ) {
	
											var url = baseUrl + image.init_from;
	
											var texture;
											var loader = THREE.Loader.Handlers.get( url );
	
											if ( loader !== null ) {
	
												texture = loader.load( url );
	
											} else {
	
												texture = new THREE.Texture();
	
												loadTextureImage( texture, url );
	
											}
	
											texture.wrapS = cot.texOpts.wrapU ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;
											texture.wrapT = cot.texOpts.wrapV ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;
											texture.offset.x = cot.texOpts.offsetU;
											texture.offset.y = cot.texOpts.offsetV;
											texture.repeat.x = cot.texOpts.repeatU;
											texture.repeat.y = cot.texOpts.repeatV;
											props[keys[prop]] = texture;
	
											// Texture with baked lighting?
											if (prop === 'emission') props['emissive'] = 0xffffff;
	
										}
	
									}
	
								}
	
							} else if ( prop === 'diffuse' || !transparent ) {
	
								if ( prop === 'emission' ) {
	
									props[ 'emissive' ] = cot.color.getHex();
	
								} else {
	
									props[ prop ] = cot.color.getHex();
	
								}
	
							}
	
						}
	
						break;
	
					case 'shininess':
	
						props[ prop ] = this[ prop ];
						break;
	
					case 'reflectivity':
	
						props[ prop ] = this[ prop ];
						if ( props[ prop ] > 0.0 ) props['envMap'] = options.defaultEnvMap;
						props['combine'] = THREE.MixOperation;	//mix regular shading with reflective component
						break;
	
					case 'index_of_refraction':
	
						props[ 'refractionRatio' ] = this[ prop ]; //TODO: "index_of_refraction" becomes "refractionRatio" in shader, but I'm not sure if the two are actually comparable
						if ( this[ prop ] !== 1.0 ) props['envMap'] = options.defaultEnvMap;
						break;
	
					case 'transparency':
						// gets figured out up top
						break;
	
					default:
						break;
	
				}
	
			}
	
			props[ 'shading' ] = preferredShading;
			props[ 'side' ] = this.effect.doubleSided ? THREE.DoubleSide : THREE.FrontSide;
	
			if ( props.diffuse !== undefined ) {
	
				props.color = props.diffuse;
				delete props.diffuse;
	
			}
	
			switch ( this.type ) {
	
				case 'constant':
	
					if (props.emissive != undefined) props.color = props.emissive;
					this.material = new THREE.MeshBasicMaterial( props );
					break;
	
				case 'phong':
				case 'blinn':
	
					this.material = new THREE.MeshPhongMaterial( props );
					break;
	
				case 'lambert':
				default:
	
					this.material = new THREE.MeshLambertMaterial( props );
					break;
	
			}
	
			return this.material;
	
		};
	
		function Surface ( effect ) {
	
			this.effect = effect;
			this.init_from = null;
			this.format = null;
	
		}
	
		Surface.prototype.parse = function ( element ) {
	
			for ( var i = 0; i < element.childNodes.length; i ++ ) {
	
				var child = element.childNodes[ i ];
				if ( child.nodeType != 1 ) continue;
	
				switch ( child.nodeName ) {
	
					case 'init_from':
	
						this.init_from = child.textContent;
						break;
	
					case 'format':
	
						this.format = child.textContent;
						break;
	
					default:
	
						console.log( "unhandled Surface prop: " + child.nodeName );
						break;
	
				}
	
			}
	
			return this;
	
		};
	
		function Sampler2D ( effect ) {
	
			this.effect = effect;
			this.source = null;
			this.wrap_s = null;
			this.wrap_t = null;
			this.minfilter = null;
			this.magfilter = null;
			this.mipfilter = null;
	
		}
	
		Sampler2D.prototype.parse = function ( element ) {
	
			for ( var i = 0; i < element.childNodes.length; i ++ ) {
	
				var child = element.childNodes[ i ];
				if ( child.nodeType != 1 ) continue;
	
				switch ( child.nodeName ) {
	
					case 'source':
	
						this.source = child.textContent;
						break;
	
					case 'minfilter':
	
						this.minfilter = child.textContent;
						break;
	
					case 'magfilter':
	
						this.magfilter = child.textContent;
						break;
	
					case 'mipfilter':
	
						this.mipfilter = child.textContent;
						break;
	
					case 'wrap_s':
	
						this.wrap_s = child.textContent;
						break;
	
					case 'wrap_t':
	
						this.wrap_t = child.textContent;
						break;
	
					default:
	
						console.log( "unhandled Sampler2D prop: " + child.nodeName );
						break;
	
				}
	
			}
	
			return this;
	
		};
	
		function Effect () {
	
			this.id = "";
			this.name = "";
			this.shader = null;
			this.surface = {};
			this.sampler = {};
	
		}
	
		Effect.prototype.create = function () {
	
			if ( this.shader === null ) {
	
				return null;
	
			}
	
		};
	
		Effect.prototype.parse = function ( element ) {
	
			this.id = element.getAttribute( 'id' );
			this.name = element.getAttribute( 'name' );
	
			extractDoubleSided( this, element );
	
			this.shader = null;
	
			for ( var i = 0; i < element.childNodes.length; i ++ ) {
	
				var child = element.childNodes[ i ];
				if ( child.nodeType != 1 ) continue;
	
				switch ( child.nodeName ) {
	
					case 'profile_COMMON':
	
						this.parseTechnique( this.parseProfileCOMMON( child ) );
						break;
	
					default:
						break;
	
				}
	
			}
	
			return this;
	
		};
	
		Effect.prototype.parseNewparam = function ( element ) {
	
			var sid = element.getAttribute( 'sid' );
	
			for ( var i = 0; i < element.childNodes.length; i ++ ) {
	
				var child = element.childNodes[ i ];
				if ( child.nodeType != 1 ) continue;
	
				switch ( child.nodeName ) {
	
					case 'surface':
	
						this.surface[sid] = ( new Surface( this ) ).parse( child );
						break;
	
					case 'sampler2D':
	
						this.sampler[sid] = ( new Sampler2D( this ) ).parse( child );
						break;
	
					case 'extra':
	
						break;
	
					default:
	
						console.log( child.nodeName );
						break;
	
				}
	
			}
	
		};
	
		Effect.prototype.parseProfileCOMMON = function ( element ) {
	
			var technique;
	
			for ( var i = 0; i < element.childNodes.length; i ++ ) {
	
				var child = element.childNodes[ i ];
	
				if ( child.nodeType != 1 ) continue;
	
				switch ( child.nodeName ) {
	
					case 'profile_COMMON':
	
						this.parseProfileCOMMON( child );
						break;
	
					case 'technique':
	
						technique = child;
						break;
	
					case 'newparam':
	
						this.parseNewparam( child );
						break;
	
					case 'image':
	
						var _image = ( new _Image() ).parse( child );
						images[ _image.id ] = _image;
						break;
	
					case 'extra':
						break;
	
					default:
	
						console.log( child.nodeName );
						break;
	
				}
	
			}
	
			return technique;
	
		};
	
		Effect.prototype.parseTechnique = function ( element ) {
	
			for ( var i = 0; i < element.childNodes.length; i ++ ) {
	
				var child = element.childNodes[i];
				if ( child.nodeType != 1 ) continue;
	
				switch ( child.nodeName ) {
	
					case 'constant':
					case 'lambert':
					case 'blinn':
					case 'phong':
	
						this.shader = ( new Shader( child.nodeName, this ) ).parse( child );
						break;
					case 'extra':
						this.parseExtra(child);
						break;
					default:
						break;
	
				}
	
			}
	
		};
	
		Effect.prototype.parseExtra = function ( element ) {
	
			for ( var i = 0; i < element.childNodes.length; i ++ ) {
	
				var child = element.childNodes[i];
				if ( child.nodeType != 1 ) continue;
	
				switch ( child.nodeName ) {
	
					case 'technique':
						this.parseExtraTechnique( child );
						break;
					default:
						break;
	
				}
	
			}
	
		};
	
		Effect.prototype.parseExtraTechnique = function ( element ) {
	
			for ( var i = 0; i < element.childNodes.length; i ++ ) {
	
				var child = element.childNodes[i];
				if ( child.nodeType != 1 ) continue;
	
				switch ( child.nodeName ) {
	
					case 'bump':
						this.shader.parse( element );
						break;
					default:
						break;
	
				}
	
			}
	
		};
	
		function InstanceEffect () {
	
			this.url = "";
	
		}
	
		InstanceEffect.prototype.parse = function ( element ) {
	
			this.url = element.getAttribute( 'url' ).replace( /^#/, '' );
			return this;
	
		};
	
		function Animation() {
	
			this.id = "";
			this.name = "";
			this.source = {};
			this.sampler = [];
			this.channel = [];
	
		}
	
		Animation.prototype.parse = function ( element ) {
	
			this.id = element.getAttribute( 'id' );
			this.name = element.getAttribute( 'name' );
			this.source = {};
	
			for ( var i = 0; i < element.childNodes.length; i ++ ) {
	
				var child = element.childNodes[ i ];
	
				if ( child.nodeType != 1 ) continue;
	
				switch ( child.nodeName ) {
	
					case 'animation':
	
						var anim = ( new Animation() ).parse( child );
	
						for ( var src in anim.source ) {
	
							this.source[ src ] = anim.source[ src ];
	
						}
	
						for ( var j = 0; j < anim.channel.length; j ++ ) {
	
							this.channel.push( anim.channel[ j ] );
							this.sampler.push( anim.sampler[ j ] );
	
						}
	
						break;
	
					case 'source':
	
						var src = ( new Source() ).parse( child );
						this.source[ src.id ] = src;
						break;
	
					case 'sampler':
	
						this.sampler.push( ( new Sampler( this ) ).parse( child ) );
						break;
	
					case 'channel':
	
						this.channel.push( ( new Channel( this ) ).parse( child ) );
						break;
	
					default:
						break;
	
				}
	
			}
	
			return this;
	
		};
	
		function Channel( animation ) {
	
			this.animation = animation;
			this.source = "";
			this.target = "";
			this.fullSid = null;
			this.sid = null;
			this.dotSyntax = null;
			this.arrSyntax = null;
			this.arrIndices = null;
			this.member = null;
	
		}
	
		Channel.prototype.parse = function ( element ) {
	
			this.source = element.getAttribute( 'source' ).replace( /^#/, '' );
			this.target = element.getAttribute( 'target' );
	
			var parts = this.target.split( '/' );
	
			var id = parts.shift();
			var sid = parts.shift();
	
			var dotSyntax = ( sid.indexOf(".") >= 0 );
			var arrSyntax = ( sid.indexOf("(") >= 0 );
	
			if ( dotSyntax ) {
	
				parts = sid.split(".");
				this.sid = parts.shift();
				this.member = parts.shift();
	
			} else if ( arrSyntax ) {
	
				var arrIndices = sid.split("(");
				this.sid = arrIndices.shift();
	
				for (var j = 0; j < arrIndices.length; j ++ ) {
	
					arrIndices[j] = parseInt( arrIndices[j].replace(/\)/, '') );
	
				}
	
				this.arrIndices = arrIndices;
	
			} else {
	
				this.sid = sid;
	
			}
	
			this.fullSid = sid;
			this.dotSyntax = dotSyntax;
			this.arrSyntax = arrSyntax;
	
			return this;
	
		};
	
		function Sampler ( animation ) {
	
			this.id = "";
			this.animation = animation;
			this.inputs = [];
			this.input = null;
			this.output = null;
			this.strideOut = null;
			this.interpolation = null;
			this.startTime = null;
			this.endTime = null;
			this.duration = 0;
	
		}
	
		Sampler.prototype.parse = function ( element ) {
	
			this.id = element.getAttribute( 'id' );
			this.inputs = [];
	
			for ( var i = 0; i < element.childNodes.length; i ++ ) {
	
				var child = element.childNodes[ i ];
				if ( child.nodeType != 1 ) continue;
	
				switch ( child.nodeName ) {
	
					case 'input':
	
						this.inputs.push( (new Input()).parse( child ) );
						break;
	
					default:
						break;
	
				}
	
			}
	
			return this;
	
		};
	
		Sampler.prototype.create = function () {
	
			for ( var i = 0; i < this.inputs.length; i ++ ) {
	
				var input = this.inputs[ i ];
				var source = this.animation.source[ input.source ];
	
				switch ( input.semantic ) {
	
					case 'INPUT':
	
						this.input = source.read();
						break;
	
					case 'OUTPUT':
	
						this.output = source.read();
						this.strideOut = source.accessor.stride;
						break;
	
					case 'INTERPOLATION':
	
						this.interpolation = source.read();
						break;
	
					case 'IN_TANGENT':
	
						break;
	
					case 'OUT_TANGENT':
	
						break;
	
					default:
	
						console.log(input.semantic);
						break;
	
				}
	
			}
	
			this.startTime = 0;
			this.endTime = 0;
			this.duration = 0;
	
			if ( this.input.length ) {
	
				this.startTime = 100000000;
				this.endTime = -100000000;
	
				for ( var i = 0; i < this.input.length; i ++ ) {
	
					this.startTime = Math.min( this.startTime, this.input[ i ] );
					this.endTime = Math.max( this.endTime, this.input[ i ] );
	
				}
	
				this.duration = this.endTime - this.startTime;
	
			}
	
		};
	
		Sampler.prototype.getData = function ( type, ndx, member ) {
	
			var data;
	
			if ( type === 'matrix' && this.strideOut === 16 ) {
	
				data = this.output[ ndx ];
	
			} else if ( this.strideOut > 1 ) {
	
				data = [];
				ndx *= this.strideOut;
	
				for ( var i = 0; i < this.strideOut; ++ i ) {
	
					data[ i ] = this.output[ ndx + i ];
	
				}
	
				if ( this.strideOut === 3 ) {
	
					switch ( type ) {
	
						case 'rotate':
						case 'translate':
	
							fixCoords( data, -1 );
							break;
	
						case 'scale':
	
							fixCoords( data, 1 );
							break;
	
					}
	
				} else if ( this.strideOut === 4 && type === 'matrix' ) {
	
					fixCoords( data, -1 );
	
				}
	
			} else {
	
				data = this.output[ ndx ];
	
				if ( member && type === 'translate' ) {
					data = getConvertedTranslation( member, data );
				}
	
			}
	
			return data;
	
		};
	
		function Key ( time ) {
	
			this.targets = [];
			this.time = time;
	
		}
	
		Key.prototype.addTarget = function ( fullSid, transform, member, data ) {
	
			this.targets.push( {
				sid: fullSid,
				member: member,
				transform: transform,
				data: data
			} );
	
		};
	
		Key.prototype.apply = function ( opt_sid ) {
	
			for ( var i = 0; i < this.targets.length; ++ i ) {
	
				var target = this.targets[ i ];
	
				if ( !opt_sid || target.sid === opt_sid ) {
	
					target.transform.update( target.data, target.member );
	
				}
	
			}
	
		};
	
		Key.prototype.getTarget = function ( fullSid ) {
	
			for ( var i = 0; i < this.targets.length; ++ i ) {
	
				if ( this.targets[ i ].sid === fullSid ) {
	
					return this.targets[ i ];
	
				}
	
			}
	
			return null;
	
		};
	
		Key.prototype.hasTarget = function ( fullSid ) {
	
			for ( var i = 0; i < this.targets.length; ++ i ) {
	
				if ( this.targets[ i ].sid === fullSid ) {
	
					return true;
	
				}
	
			}
	
			return false;
	
		};
	
		// TODO: Currently only doing linear interpolation. Should support full COLLADA spec.
		Key.prototype.interpolate = function ( nextKey, time ) {
	
			for ( var i = 0, l = this.targets.length; i < l; i ++ ) {
	
				var target = this.targets[ i ],
					nextTarget = nextKey.getTarget( target.sid ),
					data;
	
				if ( target.transform.type !== 'matrix' && nextTarget ) {
	
					var scale = ( time - this.time ) / ( nextKey.time - this.time ),
						nextData = nextTarget.data,
						prevData = target.data;
	
					if ( scale < 0 ) scale = 0;
					if ( scale > 1 ) scale = 1;
	
					if ( prevData.length ) {
	
						data = [];
	
						for ( var j = 0; j < prevData.length; ++ j ) {
	
							data[ j ] = prevData[ j ] + ( nextData[ j ] - prevData[ j ] ) * scale;
	
						}
	
					} else {
	
						data = prevData + ( nextData - prevData ) * scale;
	
					}
	
				} else {
	
					data = target.data;
	
				}
	
				target.transform.update( data, target.member );
	
			}
	
		};
	
		// Camera
		function Camera() {
	
			this.id = "";
			this.name = "";
			this.technique = "";
	
		}
	
		Camera.prototype.parse = function ( element ) {
	
			this.id = element.getAttribute( 'id' );
			this.name = element.getAttribute( 'name' );
	
			for ( var i = 0; i < element.childNodes.length; i ++ ) {
	
				var child = element.childNodes[ i ];
				if ( child.nodeType != 1 ) continue;
	
				switch ( child.nodeName ) {
	
					case 'optics':
	
						this.parseOptics( child );
						break;
	
					default:
						break;
	
				}
	
			}
	
			return this;
	
		};
	
		Camera.prototype.parseOptics = function ( element ) {
	
			for ( var i = 0; i < element.childNodes.length; i ++ ) {
	
				if ( element.childNodes[ i ].nodeName === 'technique_common' ) {
	
					var technique = element.childNodes[ i ];
	
					for ( var j = 0; j < technique.childNodes.length; j ++ ) {
	
						this.technique = technique.childNodes[ j ].nodeName;
	
						if ( this.technique === 'perspective' ) {
	
							var perspective = technique.childNodes[ j ];
	
							for ( var k = 0; k < perspective.childNodes.length; k ++ ) {
	
								var param = perspective.childNodes[ k ];
	
								switch ( param.nodeName ) {
	
									case 'yfov':
										this.yfov = param.textContent;
										break;
									case 'xfov':
										this.xfov = param.textContent;
										break;
									case 'znear':
										this.znear = param.textContent;
										break;
									case 'zfar':
										this.zfar = param.textContent;
										break;
									case 'aspect_ratio':
										this.aspect_ratio = param.textContent;
										break;
	
								}
	
							}
	
						} else if ( this.technique === 'orthographic' ) {
	
							var orthographic = technique.childNodes[ j ];
	
							for ( var k = 0; k < orthographic.childNodes.length; k ++ ) {
	
								var param = orthographic.childNodes[ k ];
	
								switch ( param.nodeName ) {
	
									case 'xmag':
										this.xmag = param.textContent;
										break;
									case 'ymag':
										this.ymag = param.textContent;
										break;
									case 'znear':
										this.znear = param.textContent;
										break;
									case 'zfar':
										this.zfar = param.textContent;
										break;
									case 'aspect_ratio':
										this.aspect_ratio = param.textContent;
										break;
	
								}
	
							}
	
						}
	
					}
	
				}
	
			}
	
			return this;
	
		};
	
		function InstanceCamera() {
	
			this.url = "";
	
		}
	
		InstanceCamera.prototype.parse = function ( element ) {
	
			this.url = element.getAttribute('url').replace(/^#/, '');
	
			return this;
	
		};
	
		// Light
	
		function Light() {
	
			this.id = "";
			this.name = "";
			this.technique = "";
	
		}
	
		Light.prototype.parse = function ( element ) {
	
			this.id = element.getAttribute( 'id' );
			this.name = element.getAttribute( 'name' );
	
			for ( var i = 0; i < element.childNodes.length; i ++ ) {
	
				var child = element.childNodes[ i ];
				if ( child.nodeType != 1 ) continue;
	
				switch ( child.nodeName ) {
	
					case 'technique_common':
	
						this.parseCommon( child );
						break;
	
					case 'technique':
	
						this.parseTechnique( child );
						break;
	
					default:
						break;
	
				}
	
			}
	
			return this;
	
		};
	
		Light.prototype.parseCommon = function ( element ) {
	
			for ( var i = 0; i < element.childNodes.length; i ++ ) {
	
				switch ( element.childNodes[ i ].nodeName ) {
	
					case 'directional':
					case 'point':
					case 'spot':
					case 'ambient':
	
						this.technique = element.childNodes[ i ].nodeName;
	
						var light = element.childNodes[ i ];
	
						for ( var j = 0; j < light.childNodes.length; j ++ ) {
	
							var child = light.childNodes[j];
	
							switch ( child.nodeName ) {
	
								case 'color':
	
									var rgba = _floats( child.textContent );
									this.color = new THREE.Color(0);
									this.color.setRGB( rgba[0], rgba[1], rgba[2] );
									this.color.a = rgba[3];
									break;
	
								case 'falloff_angle':
	
									this.falloff_angle = parseFloat( child.textContent );
									break;
	
								case 'quadratic_attenuation':
									var f = parseFloat( child.textContent );
									this.distance = f ? Math.sqrt( 1 / f ) : 0;
							}
	
						}
	
				}
	
			}
	
			return this;
	
		};
	
		Light.prototype.parseTechnique = function ( element ) {
	
			this.profile = element.getAttribute( 'profile' );
	
			for ( var i = 0; i < element.childNodes.length; i ++ ) {
	
				var child = element.childNodes[ i ];
	
				switch ( child.nodeName ) {
	
					case 'intensity':
	
						this.intensity = parseFloat(child.textContent);
						break;
	
				}
	
			}
	
			return this;
	
		};
	
		function InstanceLight() {
	
			this.url = "";
	
		}
	
		InstanceLight.prototype.parse = function ( element ) {
	
			this.url = element.getAttribute('url').replace(/^#/, '');
	
			return this;
	
		};
	
		function KinematicsModel( ) {
	
			this.id = '';
			this.name = '';
			this.joints = [];
			this.links = [];
	
		}
	
		KinematicsModel.prototype.parse = function( element ) {
	
			this.id = element.getAttribute('id');
			this.name = element.getAttribute('name');
			this.joints = [];
			this.links = [];
	
			for (var i = 0; i < element.childNodes.length; i ++ ) {
	
				var child = element.childNodes[ i ];
				if ( child.nodeType != 1 ) continue;
	
				switch ( child.nodeName ) {
	
					case 'technique_common':
	
						this.parseCommon(child);
						break;
	
					default:
						break;
	
				}
	
			}
	
			return this;
	
		};
	
		KinematicsModel.prototype.parseCommon = function( element ) {
	
			for (var i = 0; i < element.childNodes.length; i ++ ) {
	
				var child = element.childNodes[ i ];
				if ( child.nodeType != 1 ) continue;
	
				switch ( element.childNodes[ i ].nodeName ) {
	
					case 'joint':
						this.joints.push( (new Joint()).parse(child) );
						break;
	
					case 'link':
						this.links.push( (new Link()).parse(child) );
						break;
	
					default:
						break;
	
				}
	
			}
	
			return this;
	
		};
	
		function Joint( ) {
	
			this.sid = '';
			this.name = '';
			this.axis = new THREE.Vector3();
			this.limits = {
				min: 0,
				max: 0
			};
			this.type = '';
			this.static = false;
			this.zeroPosition = 0.0;
			this.middlePosition = 0.0;
	
		}
	
		Joint.prototype.parse = function( element ) {
	
			this.sid = element.getAttribute('sid');
			this.name = element.getAttribute('name');
			this.axis = new THREE.Vector3();
			this.limits = {
				min: 0,
				max: 0
			};
			this.type = '';
			this.static = false;
			this.zeroPosition = 0.0;
			this.middlePosition = 0.0;
	
			var axisElement = element.querySelector('axis');
			var _axis = _floats(axisElement.textContent);
			this.axis = getConvertedVec3(_axis, 0);
	
			var min = element.querySelector('limits min') ? parseFloat(element.querySelector('limits min').textContent) : -360;
			var max = element.querySelector('limits max') ? parseFloat(element.querySelector('limits max').textContent) : 360;
	
			this.limits = {
				min: min,
				max: max
			};
	
			var jointTypes = [ 'prismatic', 'revolute' ];
			for (var i = 0; i < jointTypes.length; i ++ ) {
	
				var type = jointTypes[ i ];
	
				var jointElement = element.querySelector(type);
	
				if ( jointElement ) {
	
					this.type = type;
	
				}
	
			}
	
			// if the min is equal to or somehow greater than the max, consider the joint static
			if ( this.limits.min >= this.limits.max ) {
	
				this.static = true;
	
			}
	
			this.middlePosition = (this.limits.min + this.limits.max) / 2.0;
			return this;
	
		};
	
		function Link( ) {
	
			this.sid = '';
			this.name = '';
			this.transforms = [];
			this.attachments = [];
	
		}
	
		Link.prototype.parse = function( element ) {
	
			this.sid = element.getAttribute('sid');
			this.name = element.getAttribute('name');
			this.transforms = [];
			this.attachments = [];
	
			for (var i = 0; i < element.childNodes.length; i ++ ) {
	
				var child = element.childNodes[ i ];
				if ( child.nodeType != 1 ) continue;
	
				switch ( child.nodeName ) {
	
					case 'attachment_full':
						this.attachments.push( (new Attachment()).parse(child) );
						break;
	
					case 'rotate':
					case 'translate':
					case 'matrix':
	
						this.transforms.push( (new Transform()).parse(child) );
						break;
	
					default:
	
						break;
	
				}
	
			}
	
			return this;
	
		};
	
		function Attachment( ) {
	
			this.joint = '';
			this.transforms = [];
			this.links = [];
	
		}
	
		Attachment.prototype.parse = function( element ) {
	
			this.joint = element.getAttribute('joint').split('/').pop();
			this.links = [];
	
			for (var i = 0; i < element.childNodes.length; i ++ ) {
	
				var child = element.childNodes[ i ];
				if ( child.nodeType != 1 ) continue;
	
				switch ( child.nodeName ) {
	
					case 'link':
						this.links.push( (new Link()).parse(child) );
						break;
	
					case 'rotate':
					case 'translate':
					case 'matrix':
	
						this.transforms.push( (new Transform()).parse(child) );
						break;
	
					default:
	
						break;
	
				}
	
			}
	
			return this;
	
		};
	
		function _source( element ) {
	
			var id = element.getAttribute( 'id' );
	
			if ( sources[ id ] != undefined ) {
	
				return sources[ id ];
	
			}
	
			sources[ id ] = ( new Source(id )).parse( element );
			return sources[ id ];
	
		}
	
		function _nsResolver( nsPrefix ) {
	
			if ( nsPrefix === "dae" ) {
	
				return "http://www.collada.org/2005/11/COLLADASchema";
	
			}
	
			return null;
	
		}
	
		function _bools( str ) {
	
			var raw = _strings( str );
			var data = [];
	
			for ( var i = 0, l = raw.length; i < l; i ++ ) {
	
				data.push( (raw[i] === 'true' || raw[i] === '1') ? true : false );
	
			}
	
			return data;
	
		}
	
		function _floats( str ) {
	
			var raw = _strings(str);
			var data = [];
	
			for ( var i = 0, l = raw.length; i < l; i ++ ) {
	
				data.push( parseFloat( raw[ i ] ) );
	
			}
	
			return data;
	
		}
	
		function _ints( str ) {
	
			var raw = _strings( str );
			var data = [];
	
			for ( var i = 0, l = raw.length; i < l; i ++ ) {
	
				data.push( parseInt( raw[ i ], 10 ) );
	
			}
	
			return data;
	
		}
	
		function _strings( str ) {
	
			return ( str.length > 0 ) ? _trimString( str ).split( /\s+/ ) : [];
	
		}
	
		function _trimString( str ) {
	
			return str.replace( /^\s+/, "" ).replace( /\s+$/, "" );
	
		}
	
		function _attr_as_float( element, name, defaultValue ) {
	
			if ( element.hasAttribute( name ) ) {
	
				return parseFloat( element.getAttribute( name ) );
	
			} else {
	
				return defaultValue;
	
			}
	
		}
	
		function _attr_as_int( element, name, defaultValue ) {
	
			if ( element.hasAttribute( name ) ) {
	
				return parseInt( element.getAttribute( name ), 10) ;
	
			} else {
	
				return defaultValue;
	
			}
	
		}
	
		function _attr_as_string( element, name, defaultValue ) {
	
			if ( element.hasAttribute( name ) ) {
	
				return element.getAttribute( name );
	
			} else {
	
				return defaultValue;
	
			}
	
		}
	
		function _format_float( f, num ) {
	
			if ( f === undefined ) {
	
				var s = '0.';
	
				while ( s.length < num + 2 ) {
	
					s += '0';
	
				}
	
				return s;
	
			}
	
			num = num || 2;
	
			var parts = f.toString().split( '.' );
			parts[ 1 ] = parts.length > 1 ? parts[ 1 ].substr( 0, num ) : "0";
	
			while ( parts[ 1 ].length < num ) {
	
				parts[ 1 ] += '0';
	
			}
	
			return parts.join( '.' );
	
		}
	
		function loadTextureImage ( texture, url ) {
	
			var loader = new THREE.ImageLoader();
	
			loader.load( url, function ( image ) {
	
				texture.image = image;
				texture.needsUpdate = true;
	
			} );
	
		}
	
		function extractDoubleSided( obj, element ) {
	
			obj.doubleSided = false;
	
			var node = element.querySelectorAll('extra double_sided')[0];
	
			if ( node ) {
	
				if ( node && parseInt( node.textContent, 10 ) === 1 ) {
	
					obj.doubleSided = true;
	
				}
	
			}
	
		}
	
		// Up axis conversion
	
		function setUpConversion() {
	
			if ( options.convertUpAxis !== true || colladaUp === options.upAxis ) {
	
				upConversion = null;
	
			} else {
	
				switch ( colladaUp ) {
	
					case 'X':
	
						upConversion = options.upAxis === 'Y' ? 'XtoY' : 'XtoZ';
						break;
	
					case 'Y':
	
						upConversion = options.upAxis === 'X' ? 'YtoX' : 'YtoZ';
						break;
	
					case 'Z':
	
						upConversion = options.upAxis === 'X' ? 'ZtoX' : 'ZtoY';
						break;
	
				}
	
			}
	
		}
	
		function fixCoords( data, sign ) {
	
			if ( options.convertUpAxis !== true || colladaUp === options.upAxis ) {
	
				return;
	
			}
	
			switch ( upConversion ) {
	
				case 'XtoY':
	
					var tmp = data[ 0 ];
					data[ 0 ] = sign * data[ 1 ];
					data[ 1 ] = tmp;
					break;
	
				case 'XtoZ':
	
					var tmp = data[ 2 ];
					data[ 2 ] = data[ 1 ];
					data[ 1 ] = data[ 0 ];
					data[ 0 ] = tmp;
					break;
	
				case 'YtoX':
	
					var tmp = data[ 0 ];
					data[ 0 ] = data[ 1 ];
					data[ 1 ] = sign * tmp;
					break;
	
				case 'YtoZ':
	
					var tmp = data[ 1 ];
					data[ 1 ] = sign * data[ 2 ];
					data[ 2 ] = tmp;
					break;
	
				case 'ZtoX':
	
					var tmp = data[ 0 ];
					data[ 0 ] = data[ 1 ];
					data[ 1 ] = data[ 2 ];
					data[ 2 ] = tmp;
					break;
	
				case 'ZtoY':
	
					var tmp = data[ 1 ];
					data[ 1 ] = data[ 2 ];
					data[ 2 ] = sign * tmp;
					break;
	
			}
	
		}
	
		function getConvertedTranslation( axis, data ) {
	
			if ( options.convertUpAxis !== true || colladaUp === options.upAxis ) {
	
				return data;
	
			}
	
			switch ( axis ) {
				case 'X':
					data = upConversion === 'XtoY' ? data * -1 : data;
					break;
				case 'Y':
					data = upConversion === 'YtoZ' || upConversion === 'YtoX' ? data * -1 : data;
					break;
				case 'Z':
					data = upConversion === 'ZtoY' ? data * -1 : data ;
					break;
				default:
					break;
			}
	
			return data;
		}
	
		function getConvertedVec3( data, offset ) {
	
			var arr = [ data[ offset ], data[ offset + 1 ], data[ offset + 2 ] ];
			fixCoords( arr, -1 );
			return new THREE.Vector3( arr[ 0 ], arr[ 1 ], arr[ 2 ] );
	
		}
	
		function getConvertedMat4( data ) {
	
			if ( options.convertUpAxis ) {
	
				// First fix rotation and scale
	
				// Columns first
				var arr = [ data[ 0 ], data[ 4 ], data[ 8 ] ];
				fixCoords( arr, -1 );
				data[ 0 ] = arr[ 0 ];
				data[ 4 ] = arr[ 1 ];
				data[ 8 ] = arr[ 2 ];
				arr = [ data[ 1 ], data[ 5 ], data[ 9 ] ];
				fixCoords( arr, -1 );
				data[ 1 ] = arr[ 0 ];
				data[ 5 ] = arr[ 1 ];
				data[ 9 ] = arr[ 2 ];
				arr = [ data[ 2 ], data[ 6 ], data[ 10 ] ];
				fixCoords( arr, -1 );
				data[ 2 ] = arr[ 0 ];
				data[ 6 ] = arr[ 1 ];
				data[ 10 ] = arr[ 2 ];
				// Rows second
				arr = [ data[ 0 ], data[ 1 ], data[ 2 ] ];
				fixCoords( arr, -1 );
				data[ 0 ] = arr[ 0 ];
				data[ 1 ] = arr[ 1 ];
				data[ 2 ] = arr[ 2 ];
				arr = [ data[ 4 ], data[ 5 ], data[ 6 ] ];
				fixCoords( arr, -1 );
				data[ 4 ] = arr[ 0 ];
				data[ 5 ] = arr[ 1 ];
				data[ 6 ] = arr[ 2 ];
				arr = [ data[ 8 ], data[ 9 ], data[ 10 ] ];
				fixCoords( arr, -1 );
				data[ 8 ] = arr[ 0 ];
				data[ 9 ] = arr[ 1 ];
				data[ 10 ] = arr[ 2 ];
	
				// Now fix translation
				arr = [ data[ 3 ], data[ 7 ], data[ 11 ] ];
				fixCoords( arr, -1 );
				data[ 3 ] = arr[ 0 ];
				data[ 7 ] = arr[ 1 ];
				data[ 11 ] = arr[ 2 ];
	
			}
	
			return new THREE.Matrix4().set(
				data[0], data[1], data[2], data[3],
				data[4], data[5], data[6], data[7],
				data[8], data[9], data[10], data[11],
				data[12], data[13], data[14], data[15]
				);
	
		}
	
		function getConvertedIndex( index ) {
	
			if ( index > -1 && index < 3 ) {
	
				var members = [ 'X', 'Y', 'Z' ],
					indices = { X: 0, Y: 1, Z: 2 };
	
				index = getConvertedMember( members[ index ] );
				index = indices[ index ];
	
			}
	
			return index;
	
		}
	
		function getConvertedMember( member ) {
	
			if ( options.convertUpAxis ) {
	
				switch ( member ) {
	
					case 'X':
	
						switch ( upConversion ) {
	
							case 'XtoY':
							case 'XtoZ':
							case 'YtoX':
	
								member = 'Y';
								break;
	
							case 'ZtoX':
	
								member = 'Z';
								break;
	
						}
	
						break;
	
					case 'Y':
	
						switch ( upConversion ) {
	
							case 'XtoY':
							case 'YtoX':
							case 'ZtoX':
	
								member = 'X';
								break;
	
							case 'XtoZ':
							case 'YtoZ':
							case 'ZtoY':
	
								member = 'Z';
								break;
	
						}
	
						break;
	
					case 'Z':
	
						switch ( upConversion ) {
	
							case 'XtoZ':
	
								member = 'X';
								break;
	
							case 'YtoZ':
							case 'ZtoX':
							case 'ZtoY':
	
								member = 'Y';
								break;
	
						}
	
						break;
	
				}
	
			}
	
			return member;
	
		}
	
		return {
	
			load: load,
			parse: parse,
			setPreferredShading: setPreferredShading,
			applySkin: applySkin,
			geometries : geometries,
			options: options
	
		};
	
	};
	
	},{}],19:[function(_dereq_,module,exports){
	/**
	 * Loads a Wavefront .mtl file specifying materials
	 *
	 * @author angelxuanchang
	 */
	
	THREE.MTLLoader = function( manager ) {
	
		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
	
	};
	
	THREE.MTLLoader.prototype = {
	
		constructor: THREE.MTLLoader,
	
		load: function ( url, onLoad, onProgress, onError ) {
	
			var scope = this;
	
			var loader = new THREE.XHRLoader( this.manager );
			loader.setPath( this.path );
			loader.load( url, function ( text ) {
	
				onLoad( scope.parse( text ) );
	
			}, onProgress, onError );
	
		},
	
		setPath: function ( value ) {
	
			this.path = value;
	
		},
	
		setBaseUrl: function( value ) {
	
			// TODO: Merge with setPath()? Or rename to setTexturePath?
	
			this.baseUrl = value;
	
		},
	
		setCrossOrigin: function ( value ) {
	
			this.crossOrigin = value;
	
		},
	
		setMaterialOptions: function ( value ) {
	
			this.materialOptions = value;
	
		},
	
		/**
		 * Parses loaded MTL file
		 * @param text - Content of MTL file
		 * @return {THREE.MTLLoader.MaterialCreator}
		 */
		parse: function ( text ) {
	
			var lines = text.split( "\n" );
			var info = {};
			var delimiter_pattern = /\s+/;
			var materialsInfo = {};
	
			for ( var i = 0; i < lines.length; i ++ ) {
	
				var line = lines[ i ];
				line = line.trim();
	
				if ( line.length === 0 || line.charAt( 0 ) === '#' ) {
	
					// Blank line or comment ignore
					continue;
	
				}
	
				var pos = line.indexOf( ' ' );
	
				var key = ( pos >= 0 ) ? line.substring( 0, pos ) : line;
				key = key.toLowerCase();
	
				var value = ( pos >= 0 ) ? line.substring( pos + 1 ) : "";
				value = value.trim();
	
				if ( key === "newmtl" ) {
	
					// New material
	
					info = { name: value };
					materialsInfo[ value ] = info;
	
				} else if ( info ) {
	
					if ( key === "ka" || key === "kd" || key === "ks" ) {
	
						var ss = value.split( delimiter_pattern, 3 );
						info[ key ] = [ parseFloat( ss[ 0 ] ), parseFloat( ss[ 1 ] ), parseFloat( ss[ 2 ] ) ];
	
					} else {
	
						info[ key ] = value;
	
					}
	
				}
	
			}
	
			var materialCreator = new THREE.MTLLoader.MaterialCreator( this.baseUrl, this.materialOptions );
			materialCreator.setCrossOrigin( this.crossOrigin );
			materialCreator.setManager( this.manager );
			materialCreator.setMaterials( materialsInfo );
			return materialCreator;
	
		}
	
	};
	
	/**
	 * Create a new THREE-MTLLoader.MaterialCreator
	 * @param baseUrl - Url relative to which textures are loaded
	 * @param options - Set of options on how to construct the materials
	 *                  side: Which side to apply the material
	 *                        THREE.FrontSide (default), THREE.BackSide, THREE.DoubleSide
	 *                  wrap: What type of wrapping to apply for textures
	 *                        THREE.RepeatWrapping (default), THREE.ClampToEdgeWrapping, THREE.MirroredRepeatWrapping
	 *                  normalizeRGB: RGBs need to be normalized to 0-1 from 0-255
	 *                                Default: false, assumed to be already normalized
	 *                  ignoreZeroRGBs: Ignore values of RGBs (Ka,Kd,Ks) that are all 0's
	 *                                  Default: false
	 * @constructor
	 */
	
	THREE.MTLLoader.MaterialCreator = function( baseUrl, options ) {
	
		this.baseUrl = baseUrl;
		this.options = options;
		this.materialsInfo = {};
		this.materials = {};
		this.materialsArray = [];
		this.nameLookup = {};
	
		this.side = ( this.options && this.options.side ) ? this.options.side : THREE.FrontSide;
		this.wrap = ( this.options && this.options.wrap ) ? this.options.wrap : THREE.RepeatWrapping;
	
	};
	
	THREE.MTLLoader.MaterialCreator.prototype = {
	
		constructor: THREE.MTLLoader.MaterialCreator,
	
		setCrossOrigin: function ( value ) {
	
			this.crossOrigin = value;
	
		},
	
		setManager: function ( value ) {
	
			this.manager = value;
	
		},
	
		setMaterials: function( materialsInfo ) {
	
			this.materialsInfo = this.convert( materialsInfo );
			this.materials = {};
			this.materialsArray = [];
			this.nameLookup = {};
	
		},
	
		convert: function( materialsInfo ) {
	
			if ( ! this.options ) return materialsInfo;
	
			var converted = {};
	
			for ( var mn in materialsInfo ) {
	
				// Convert materials info into normalized form based on options
	
				var mat = materialsInfo[ mn ];
	
				var covmat = {};
	
				converted[ mn ] = covmat;
	
				for ( var prop in mat ) {
	
					var save = true;
					var value = mat[ prop ];
					var lprop = prop.toLowerCase();
	
					switch ( lprop ) {
	
						case 'kd':
						case 'ka':
						case 'ks':
	
							// Diffuse color (color under white light) using RGB values
	
							if ( this.options && this.options.normalizeRGB ) {
	
								value = [ value[ 0 ] / 255, value[ 1 ] / 255, value[ 2 ] / 255 ];
	
							}
	
							if ( this.options && this.options.ignoreZeroRGBs ) {
	
								if ( value[ 0 ] === 0 && value[ 1 ] === 0 && value[ 1 ] === 0 ) {
	
									// ignore
	
									save = false;
	
								}
	
							}
	
							break;
	
						default:
	
							break;
					}
	
					if ( save ) {
	
						covmat[ lprop ] = value;
	
					}
	
				}
	
			}
	
			return converted;
	
		},
	
		preload: function () {
	
			for ( var mn in this.materialsInfo ) {
	
				this.create( mn );
	
			}
	
		},
	
		getIndex: function( materialName ) {
	
			return this.nameLookup[ materialName ];
	
		},
	
		getAsArray: function() {
	
			var index = 0;
	
			for ( var mn in this.materialsInfo ) {
	
				this.materialsArray[ index ] = this.create( mn );
				this.nameLookup[ mn ] = index;
				index ++;
	
			}
	
			return this.materialsArray;
	
		},
	
		create: function ( materialName ) {
	
			if ( this.materials[ materialName ] === undefined ) {
	
				this.createMaterial_( materialName );
	
			}
	
			return this.materials[ materialName ];
	
		},
	
		createMaterial_: function ( materialName ) {
	
			// Create material
	
			var mat = this.materialsInfo[ materialName ];
			var params = {
	
				name: materialName,
				side: this.side
	
			};
	
			for ( var prop in mat ) {
	
				var value = mat[ prop ];
	
				if ( value === '' ) {
					continue;
				}
	
				switch ( prop.toLowerCase() ) {
	
					// Ns is material specular exponent
	
					case 'kd':
	
						// Diffuse color (color under white light) using RGB values
	
						params[ 'color' ] = new THREE.Color().fromArray( value );
	
						break;
	
					case 'ks':
	
						// Specular color (color when light is reflected from shiny surface) using RGB values
						params[ 'specular' ] = new THREE.Color().fromArray( value );
	
						break;
	
					case 'map_kd':
	
						// Diffuse texture map
	
						params[ 'map' ] = this.loadTexture( this.baseUrl + value );
						params[ 'map' ].wrapS = this.wrap;
						params[ 'map' ].wrapT = this.wrap;
	
						break;
	
					case 'ns':
	
						// The specular exponent (defines the focus of the specular highlight)
						// A high exponent results in a tight, concentrated highlight. Ns values normally range from 0 to 1000.
	
						params[ 'shininess' ] = parseFloat( value );
	
						break;
	
					case 'd':
	
						if ( value < 1 ) {
	
							params[ 'opacity' ] = value;
							params[ 'transparent' ] = true;
	
						}
	
						break;
	
					case 'Tr':
	
						if ( value > 0 ) {
	
							params[ 'opacity' ] = 1 - value;
							params[ 'transparent' ] = true;
	
						}
	
						break;
	
					case 'map_bump':
					case 'bump':
	
						// Bump texture map
	
						if ( params[ 'bumpMap' ] ) break; // Avoid loading twice.
	
						params[ 'bumpMap' ] = this.loadTexture( this.baseUrl + value );
						params[ 'bumpMap' ].wrapS = this.wrap;
						params[ 'bumpMap' ].wrapT = this.wrap;
	
						break;
	
					default:
						break;
	
				}
	
			}
	
			this.materials[ materialName ] = new THREE.MeshPhongMaterial( params );
			return this.materials[ materialName ];
	
		},
	
	
		loadTexture: function ( url, mapping, onLoad, onProgress, onError ) {
	
			var texture;
			var loader = THREE.Loader.Handlers.get( url );
			var manager = ( this.manager !== undefined ) ? this.manager : THREE.DefaultLoadingManager;
	
			if ( loader === null ) {
	
				loader = new THREE.TextureLoader( manager );
	
			}
	
			if ( loader.setCrossOrigin ) loader.setCrossOrigin( this.crossOrigin );
			texture = loader.load( url, onLoad, onProgress, onError );
	
			if ( mapping !== undefined ) texture.mapping = mapping;
	
			return texture;
	
		}
	
	};
	
	THREE.EventDispatcher.prototype.apply( THREE.MTLLoader.prototype );
	
	},{}],20:[function(_dereq_,module,exports){
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.OBJLoader = function ( manager ) {
	
		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
	
		this.materials = null;
	
	};
	
	THREE.OBJLoader.prototype = {
	
		constructor: THREE.OBJLoader,
	
		load: function ( url, onLoad, onProgress, onError ) {
	
			var scope = this;
	
			var loader = new THREE.XHRLoader( scope.manager );
			loader.setPath( this.path );
			loader.load( url, function ( text ) {
	
				onLoad( scope.parse( text ) );
	
			}, onProgress, onError );
	
		},
	
		setPath: function ( value ) {
	
			this.path = value;
	
		},
	
		setMaterials: function ( materials ) {
	
			this.materials = materials;
	
		},
	
		parse: function ( text ) {
	
			console.time( 'OBJLoader' );
	
			var objects = [];
			var object;
			var foundObjects = false;
			var vertices = [];
			var normals = [];
			var uvs = [];
	
			function addObject( name ) {
	
				var geometry = {
					vertices: [],
					normals: [],
					uvs: []
				};
	
				var material = {
					name: '',
					smooth: true
				};
	
				object = {
					name: name,
					geometry: geometry,
					material: material
				};
	
				objects.push( object );
	
			}
	
			function parseVertexIndex( value ) {
	
				var index = parseInt( value );
	
				return ( index >= 0 ? index - 1 : index + vertices.length / 3 ) * 3;
	
			}
	
			function parseNormalIndex( value ) {
	
				var index = parseInt( value );
	
				return ( index >= 0 ? index - 1 : index + normals.length / 3 ) * 3;
	
			}
	
			function parseUVIndex( value ) {
	
				var index = parseInt( value );
	
				return ( index >= 0 ? index - 1 : index + uvs.length / 2 ) * 2;
	
			}
	
			function addVertex( a, b, c ) {
	
				object.geometry.vertices.push(
					vertices[ a ], vertices[ a + 1 ], vertices[ a + 2 ],
					vertices[ b ], vertices[ b + 1 ], vertices[ b + 2 ],
					vertices[ c ], vertices[ c + 1 ], vertices[ c + 2 ]
				);
	
			}
	
			function addNormal( a, b, c ) {
	
				object.geometry.normals.push(
					normals[ a ], normals[ a + 1 ], normals[ a + 2 ],
					normals[ b ], normals[ b + 1 ], normals[ b + 2 ],
					normals[ c ], normals[ c + 1 ], normals[ c + 2 ]
				);
	
			}
	
			function addUV( a, b, c ) {
	
				object.geometry.uvs.push(
					uvs[ a ], uvs[ a + 1 ],
					uvs[ b ], uvs[ b + 1 ],
					uvs[ c ], uvs[ c + 1 ]
				);
	
			}
	
			function addFace( a, b, c, d,  ua, ub, uc, ud, na, nb, nc, nd ) {
	
				var ia = parseVertexIndex( a );
				var ib = parseVertexIndex( b );
				var ic = parseVertexIndex( c );
				var id;
	
				if ( d === undefined ) {
	
					addVertex( ia, ib, ic );
	
				} else {
	
					id = parseVertexIndex( d );
	
					addVertex( ia, ib, id );
					addVertex( ib, ic, id );
	
				}
	
				if ( ua !== undefined ) {
	
					ia = parseUVIndex( ua );
					ib = parseUVIndex( ub );
					ic = parseUVIndex( uc );
	
					if ( d === undefined ) {
	
						addUV( ia, ib, ic );
	
					} else {
	
						id = parseUVIndex( ud );
	
						addUV( ia, ib, id );
						addUV( ib, ic, id );
	
					}
	
				}
	
				if ( na !== undefined ) {
	
					ia = parseNormalIndex( na );
					ib = parseNormalIndex( nb );
					ic = parseNormalIndex( nc );
	
					if ( d === undefined ) {
	
						addNormal( ia, ib, ic );
	
					} else {
	
						id = parseNormalIndex( nd );
	
						addNormal( ia, ib, id );
						addNormal( ib, ic, id );
	
					}
	
				}
	
			}
	
			addObject( '' );
	
			// v float float float
			var vertex_pattern = /^v\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/;
	
			// vn float float float
			var normal_pattern = /^vn\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/;
	
			// vt float float
			var uv_pattern = /^vt\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/;
	
			// f vertex vertex vertex ...
			var face_pattern1 = /^f\s+(-?\d+)\s+(-?\d+)\s+(-?\d+)(?:\s+(-?\d+))?/;
	
			// f vertex/uv vertex/uv vertex/uv ...
			var face_pattern2 = /^f\s+((-?\d+)\/(-?\d+))\s+((-?\d+)\/(-?\d+))\s+((-?\d+)\/(-?\d+))(?:\s+((-?\d+)\/(-?\d+)))?/;
	
			// f vertex/uv/normal vertex/uv/normal vertex/uv/normal ...
			var face_pattern3 = /^f\s+((-?\d+)\/(-?\d+)\/(-?\d+))\s+((-?\d+)\/(-?\d+)\/(-?\d+))\s+((-?\d+)\/(-?\d+)\/(-?\d+))(?:\s+((-?\d+)\/(-?\d+)\/(-?\d+)))?/;
	
			// f vertex//normal vertex//normal vertex//normal ...
			var face_pattern4 = /^f\s+((-?\d+)\/\/(-?\d+))\s+((-?\d+)\/\/(-?\d+))\s+((-?\d+)\/\/(-?\d+))(?:\s+((-?\d+)\/\/(-?\d+)))?/;
	
			var object_pattern = /^[og]\s+(.+)/;
	
			var smoothing_pattern = /^s\s+([01]|on|off)/;
	
			//
	
			var lines = text.split( '\n' );
	
			for ( var i = 0; i < lines.length; i ++ ) {
	
				var line = lines[ i ];
				line = line.trim();
	
				var result;
	
				if ( line.length === 0 || line.charAt( 0 ) === '#' ) {
	
					continue;
	
				} else if ( ( result = vertex_pattern.exec( line ) ) !== null ) {
	
					// ["v 1.0 2.0 3.0", "1.0", "2.0", "3.0"]
	
					vertices.push(
						parseFloat( result[ 1 ] ),
						parseFloat( result[ 2 ] ),
						parseFloat( result[ 3 ] )
					);
	
				} else if ( ( result = normal_pattern.exec( line ) ) !== null ) {
	
					// ["vn 1.0 2.0 3.0", "1.0", "2.0", "3.0"]
	
					normals.push(
						parseFloat( result[ 1 ] ),
						parseFloat( result[ 2 ] ),
						parseFloat( result[ 3 ] )
					);
	
				} else if ( ( result = uv_pattern.exec( line ) ) !== null ) {
	
					// ["vt 0.1 0.2", "0.1", "0.2"]
	
					uvs.push(
						parseFloat( result[ 1 ] ),
						parseFloat( result[ 2 ] )
					);
	
				} else if ( ( result = face_pattern1.exec( line ) ) !== null ) {
	
					// ["f 1 2 3", "1", "2", "3", undefined]
	
					addFace(
						result[ 1 ], result[ 2 ], result[ 3 ], result[ 4 ]
					);
	
				} else if ( ( result = face_pattern2.exec( line ) ) !== null ) {
	
					// ["f 1/1 2/2 3/3", " 1/1", "1", "1", " 2/2", "2", "2", " 3/3", "3", "3", undefined, undefined, undefined]
	
					addFace(
						result[ 2 ], result[ 5 ], result[ 8 ], result[ 11 ],
						result[ 3 ], result[ 6 ], result[ 9 ], result[ 12 ]
					);
	
				} else if ( ( result = face_pattern3.exec( line ) ) !== null ) {
	
					// ["f 1/1/1 2/2/2 3/3/3", " 1/1/1", "1", "1", "1", " 2/2/2", "2", "2", "2", " 3/3/3", "3", "3", "3", undefined, undefined, undefined, undefined]
	
					addFace(
						result[ 2 ], result[ 6 ], result[ 10 ], result[ 14 ],
						result[ 3 ], result[ 7 ], result[ 11 ], result[ 15 ],
						result[ 4 ], result[ 8 ], result[ 12 ], result[ 16 ]
					);
	
				} else if ( ( result = face_pattern4.exec( line ) ) !== null ) {
	
					// ["f 1//1 2//2 3//3", " 1//1", "1", "1", " 2//2", "2", "2", " 3//3", "3", "3", undefined, undefined, undefined]
	
					addFace(
						result[ 2 ], result[ 5 ], result[ 8 ], result[ 11 ],
						undefined, undefined, undefined, undefined,
						result[ 3 ], result[ 6 ], result[ 9 ], result[ 12 ]
					);
	
				} else if ( ( result = object_pattern.exec( line ) ) !== null ) {
	
					// o object_name
					// or
					// g group_name
	
					var name = result[ 1 ].trim();
	
					if ( foundObjects === false ) {
	
						foundObjects = true;
						object.name = name;
	
					} else {
	
						addObject( name );
	
					}
	
				} else if ( /^usemtl /.test( line ) ) {
	
					// material
	
					object.material.name = line.substring( 7 ).trim();
	
				} else if ( /^mtllib /.test( line ) ) {
	
					// mtl file
	
				} else if ( ( result = smoothing_pattern.exec( line ) ) !== null ) {
	
					// smooth shading
	
					object.material.smooth = result[ 1 ] === "1" || result[ 1 ] === "on";
	
				} else {
	
					throw new Error( "Unexpected line: " + line );
	
				}
	
			}
	
			var container = new THREE.Group();
	
			for ( var i = 0, l = objects.length; i < l; i ++ ) {
	
				object = objects[ i ];
				var geometry = object.geometry;
	
				var buffergeometry = new THREE.BufferGeometry();
	
				buffergeometry.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( geometry.vertices ), 3 ) );
	
				if ( geometry.normals.length > 0 ) {
	
					buffergeometry.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( geometry.normals ), 3 ) );
	
				} else {
	
					buffergeometry.computeVertexNormals();
	
				}
	
				if ( geometry.uvs.length > 0 ) {
	
					buffergeometry.addAttribute( 'uv', new THREE.BufferAttribute( new Float32Array( geometry.uvs ), 2 ) );
	
				}
	
				var material;
	
				if ( this.materials !== null ) {
	
					material = this.materials.create( object.material.name );
	
				}
	
				if ( !material ) {
	
					material = new THREE.MeshPhongMaterial();
					material.name = object.material.name;
	
				}
	
				material.shading = object.material.smooth ? THREE.SmoothShading : THREE.FlatShading;
	
				var mesh = new THREE.Mesh( buffergeometry, material );
				mesh.name = object.name;
	
				container.add( mesh );
	
			}
	
			console.timeEnd( 'OBJLoader' );
	
			return container;
	
		}
	
	};
	
	},{}],21:[function(_dereq_,module,exports){
	var self = self || {};// File:src/Three.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	var THREE = { REVISION: '74' };
	
	//
	
	if ( typeof define === 'function' && define.amd ) {
	
		define( 'three', THREE );
	
	} else if ( 'undefined' !== typeof exports && 'undefined' !== typeof module ) {
	
		module.exports = THREE;
	
	}
	
	//
	
	if ( Number.EPSILON === undefined ) {
	
		Number.EPSILON = Math.pow( 2, - 52 );
	
	}
	
	//
	
	if ( Math.sign === undefined ) {
	
		// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign
	
		Math.sign = function ( x ) {
	
			return ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;
	
		};
	
	}
	
	if ( Function.prototype.name === undefined && Object.defineProperty !== undefined ) {
	
		// Missing in IE9-11.
		// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name
	
		Object.defineProperty( Function.prototype, 'name', {
	
			get: function () {
	
				return this.toString().match( /^\s*function\s*(\S*)\s*\(/ )[ 1 ];
	
			}
	
		} );
	
	}
	
	if ( Object.assign === undefined ) {
	
		// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
	
		Object.defineProperty( Object, 'assign', {
	
			writable: true,
			configurable: true,
	
			value: function ( target ) {
	
				'use strict';
	
				if ( target === undefined || target === null ) {
	
					throw new TypeError( "Cannot convert first argument to object" );
	
				}
	
				var to = Object( target );
	
				for ( var i = 1, n = arguments.length; i !== n; ++ i ) {
	
					var nextSource = arguments[ i ];
	
					if ( nextSource === undefined || nextSource === null ) continue;
	
					nextSource = Object( nextSource );
	
					var keysArray = Object.keys( nextSource );
	
					for ( var nextIndex = 0, len = keysArray.length; nextIndex !== len; ++ nextIndex ) {
	
						var nextKey = keysArray[ nextIndex ];
						var desc = Object.getOwnPropertyDescriptor( nextSource, nextKey );
	
						if ( desc !== undefined && desc.enumerable ) {
	
							to[ nextKey ] = nextSource[ nextKey ];
	
						}
	
					}
	
				}
	
				return to;
	
			}
	
		} );
	
	}
	
	// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent.button
	
	THREE.MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };
	
	// GL STATE CONSTANTS
	
	THREE.CullFaceNone = 0;
	THREE.CullFaceBack = 1;
	THREE.CullFaceFront = 2;
	THREE.CullFaceFrontBack = 3;
	
	THREE.FrontFaceDirectionCW = 0;
	THREE.FrontFaceDirectionCCW = 1;
	
	// SHADOWING TYPES
	
	THREE.BasicShadowMap = 0;
	THREE.PCFShadowMap = 1;
	THREE.PCFSoftShadowMap = 2;
	
	// MATERIAL CONSTANTS
	
	// side
	
	THREE.FrontSide = 0;
	THREE.BackSide = 1;
	THREE.DoubleSide = 2;
	
	// shading
	
	THREE.FlatShading = 1;
	THREE.SmoothShading = 2;
	
	// colors
	
	THREE.NoColors = 0;
	THREE.FaceColors = 1;
	THREE.VertexColors = 2;
	
	// blending modes
	
	THREE.NoBlending = 0;
	THREE.NormalBlending = 1;
	THREE.AdditiveBlending = 2;
	THREE.SubtractiveBlending = 3;
	THREE.MultiplyBlending = 4;
	THREE.CustomBlending = 5;
	
	// custom blending equations
	// (numbers start from 100 not to clash with other
	// mappings to OpenGL constants defined in Texture.js)
	
	THREE.AddEquation = 100;
	THREE.SubtractEquation = 101;
	THREE.ReverseSubtractEquation = 102;
	THREE.MinEquation = 103;
	THREE.MaxEquation = 104;
	
	// custom blending destination factors
	
	THREE.ZeroFactor = 200;
	THREE.OneFactor = 201;
	THREE.SrcColorFactor = 202;
	THREE.OneMinusSrcColorFactor = 203;
	THREE.SrcAlphaFactor = 204;
	THREE.OneMinusSrcAlphaFactor = 205;
	THREE.DstAlphaFactor = 206;
	THREE.OneMinusDstAlphaFactor = 207;
	
	// custom blending source factors
	
	//THREE.ZeroFactor = 200;
	//THREE.OneFactor = 201;
	//THREE.SrcAlphaFactor = 204;
	//THREE.OneMinusSrcAlphaFactor = 205;
	//THREE.DstAlphaFactor = 206;
	//THREE.OneMinusDstAlphaFactor = 207;
	THREE.DstColorFactor = 208;
	THREE.OneMinusDstColorFactor = 209;
	THREE.SrcAlphaSaturateFactor = 210;
	
	// depth modes
	
	THREE.NeverDepth = 0;
	THREE.AlwaysDepth = 1;
	THREE.LessDepth = 2;
	THREE.LessEqualDepth = 3;
	THREE.EqualDepth = 4;
	THREE.GreaterEqualDepth = 5;
	THREE.GreaterDepth = 6;
	THREE.NotEqualDepth = 7;
	
	
	// TEXTURE CONSTANTS
	
	THREE.MultiplyOperation = 0;
	THREE.MixOperation = 1;
	THREE.AddOperation = 2;
	
	// Mapping modes
	
	THREE.UVMapping = 300;
	
	THREE.CubeReflectionMapping = 301;
	THREE.CubeRefractionMapping = 302;
	
	THREE.EquirectangularReflectionMapping = 303;
	THREE.EquirectangularRefractionMapping = 304;
	
	THREE.SphericalReflectionMapping = 305;
	
	// Wrapping modes
	
	THREE.RepeatWrapping = 1000;
	THREE.ClampToEdgeWrapping = 1001;
	THREE.MirroredRepeatWrapping = 1002;
	
	// Filters
	
	THREE.NearestFilter = 1003;
	THREE.NearestMipMapNearestFilter = 1004;
	THREE.NearestMipMapLinearFilter = 1005;
	THREE.LinearFilter = 1006;
	THREE.LinearMipMapNearestFilter = 1007;
	THREE.LinearMipMapLinearFilter = 1008;
	
	// Data types
	
	THREE.UnsignedByteType = 1009;
	THREE.ByteType = 1010;
	THREE.ShortType = 1011;
	THREE.UnsignedShortType = 1012;
	THREE.IntType = 1013;
	THREE.UnsignedIntType = 1014;
	THREE.FloatType = 1015;
	THREE.HalfFloatType = 1025;
	
	// Pixel types
	
	//THREE.UnsignedByteType = 1009;
	THREE.UnsignedShort4444Type = 1016;
	THREE.UnsignedShort5551Type = 1017;
	THREE.UnsignedShort565Type = 1018;
	
	// Pixel formats
	
	THREE.AlphaFormat = 1019;
	THREE.RGBFormat = 1020;
	THREE.RGBAFormat = 1021;
	THREE.LuminanceFormat = 1022;
	THREE.LuminanceAlphaFormat = 1023;
	// THREE.RGBEFormat handled as THREE.RGBAFormat in shaders
	THREE.RGBEFormat = THREE.RGBAFormat; //1024;
	
	// DDS / ST3C Compressed texture formats
	
	THREE.RGB_S3TC_DXT1_Format = 2001;
	THREE.RGBA_S3TC_DXT1_Format = 2002;
	THREE.RGBA_S3TC_DXT3_Format = 2003;
	THREE.RGBA_S3TC_DXT5_Format = 2004;
	
	
	// PVRTC compressed texture formats
	
	THREE.RGB_PVRTC_4BPPV1_Format = 2100;
	THREE.RGB_PVRTC_2BPPV1_Format = 2101;
	THREE.RGBA_PVRTC_4BPPV1_Format = 2102;
	THREE.RGBA_PVRTC_2BPPV1_Format = 2103;
	
	// ETC compressed texture formats
	
	THREE.RGB_ETC1_Format = 2151;
	
	// Loop styles for AnimationAction
	
	THREE.LoopOnce = 2200;
	THREE.LoopRepeat = 2201;
	THREE.LoopPingPong = 2202;
	
	// Interpolation
	
	THREE.InterpolateDiscrete = 2300;
	THREE.InterpolateLinear = 2301;
	THREE.InterpolateSmooth = 2302;
	
	// Interpolant ending modes
	
	THREE.ZeroCurvatureEnding = 2400;
	THREE.ZeroSlopeEnding = 2401;
	THREE.WrapAroundEnding = 2402;
	
	// Triangle Draw modes
	
	THREE.TrianglesDrawMode = 0;
	THREE.TriangleStripDrawMode = 1;
	THREE.TriangleFanDrawMode = 2;
	
	// File:src/math/Color.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.Color = function ( color ) {
	
		if ( arguments.length === 3 ) {
	
			return this.fromArray( arguments );
	
		}
	
		return this.set( color );
	
	};
	
	THREE.Color.prototype = {
	
		constructor: THREE.Color,
	
		r: 1, g: 1, b: 1,
	
		set: function ( value ) {
	
			if ( value instanceof THREE.Color ) {
	
				this.copy( value );
	
			} else if ( typeof value === 'number' ) {
	
				this.setHex( value );
	
			} else if ( typeof value === 'string' ) {
	
				this.setStyle( value );
	
			}
	
			return this;
	
		},
	
		setScalar: function ( scalar ) {
	
			this.r = scalar;
			this.g = scalar;
			this.b = scalar;
	
		},
	
		setHex: function ( hex ) {
	
			hex = Math.floor( hex );
	
			this.r = ( hex >> 16 & 255 ) / 255;
			this.g = ( hex >> 8 & 255 ) / 255;
			this.b = ( hex & 255 ) / 255;
	
			return this;
	
		},
	
		setRGB: function ( r, g, b ) {
	
			this.r = r;
			this.g = g;
			this.b = b;
	
			return this;
	
		},
	
		setHSL: function () {
	
			function hue2rgb( p, q, t ) {
	
				if ( t < 0 ) t += 1;
				if ( t > 1 ) t -= 1;
				if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
				if ( t < 1 / 2 ) return q;
				if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
				return p;
	
			}
	
			return function ( h, s, l ) {
	
				// h,s,l ranges are in 0.0 - 1.0
				h = THREE.Math.euclideanModulo( h, 1 );
				s = THREE.Math.clamp( s, 0, 1 );
				l = THREE.Math.clamp( l, 0, 1 );
	
				if ( s === 0 ) {
	
					this.r = this.g = this.b = l;
	
				} else {
	
					var p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
					var q = ( 2 * l ) - p;
	
					this.r = hue2rgb( q, p, h + 1 / 3 );
					this.g = hue2rgb( q, p, h );
					this.b = hue2rgb( q, p, h - 1 / 3 );
	
				}
	
				return this;
	
			};
	
		}(),
	
		setStyle: function ( style ) {
	
			function handleAlpha( string ) {
	
				if ( string === undefined ) return;
	
				if ( parseFloat( string ) < 1 ) {
	
					console.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );
	
				}
	
			}
	
	
			var m;
	
			if ( m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec( style ) ) {
	
				// rgb / hsl
	
				var color;
				var name = m[ 1 ];
				var components = m[ 2 ];
	
				switch ( name ) {
	
					case 'rgb':
					case 'rgba':
	
						if ( color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {
	
							// rgb(255,0,0) rgba(255,0,0,0.5)
							this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
							this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
							this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;
	
							handleAlpha( color[ 5 ] );
	
							return this;
	
						}
	
						if ( color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {
	
							// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
							this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
							this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
							this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;
	
							handleAlpha( color[ 5 ] );
	
							return this;
	
						}
	
						break;
	
					case 'hsl':
					case 'hsla':
	
						if ( color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {
	
							// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
							var h = parseFloat( color[ 1 ] ) / 360;
							var s = parseInt( color[ 2 ], 10 ) / 100;
							var l = parseInt( color[ 3 ], 10 ) / 100;
	
							handleAlpha( color[ 5 ] );
	
							return this.setHSL( h, s, l );
	
						}
	
						break;
	
				}
	
			} else if ( m = /^\#([A-Fa-f0-9]+)$/.exec( style ) ) {
	
				// hex color
	
				var hex = m[ 1 ];
				var size = hex.length;
	
				if ( size === 3 ) {
	
					// #ff0
					this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;
					this.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;
					this.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;
	
					return this;
	
				} else if ( size === 6 ) {
	
					// #ff0000
					this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;
					this.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;
					this.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;
	
					return this;
	
				}
	
			}
	
			if ( style && style.length > 0 ) {
	
				// color keywords
				var hex = THREE.ColorKeywords[ style ];
	
				if ( hex !== undefined ) {
	
					// red
					this.setHex( hex );
	
				} else {
	
					// unknown color
					console.warn( 'THREE.Color: Unknown color ' + style );
	
				}
	
			}
	
			return this;
	
		},
	
		clone: function () {
	
			return new this.constructor( this.r, this.g, this.b );
	
		},
	
		copy: function ( color ) {
	
			this.r = color.r;
			this.g = color.g;
			this.b = color.b;
	
			return this;
	
		},
	
		copyGammaToLinear: function ( color, gammaFactor ) {
	
			if ( gammaFactor === undefined ) gammaFactor = 2.0;
	
			this.r = Math.pow( color.r, gammaFactor );
			this.g = Math.pow( color.g, gammaFactor );
			this.b = Math.pow( color.b, gammaFactor );
	
			return this;
	
		},
	
		copyLinearToGamma: function ( color, gammaFactor ) {
	
			if ( gammaFactor === undefined ) gammaFactor = 2.0;
	
			var safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;
	
			this.r = Math.pow( color.r, safeInverse );
			this.g = Math.pow( color.g, safeInverse );
			this.b = Math.pow( color.b, safeInverse );
	
			return this;
	
		},
	
		convertGammaToLinear: function () {
	
			var r = this.r, g = this.g, b = this.b;
	
			this.r = r * r;
			this.g = g * g;
			this.b = b * b;
	
			return this;
	
		},
	
		convertLinearToGamma: function () {
	
			this.r = Math.sqrt( this.r );
			this.g = Math.sqrt( this.g );
			this.b = Math.sqrt( this.b );
	
			return this;
	
		},
	
		getHex: function () {
	
			return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;
	
		},
	
		getHexString: function () {
	
			return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );
	
		},
	
		getHSL: function ( optionalTarget ) {
	
			// h,s,l ranges are in 0.0 - 1.0
	
			var hsl = optionalTarget || { h: 0, s: 0, l: 0 };
	
			var r = this.r, g = this.g, b = this.b;
	
			var max = Math.max( r, g, b );
			var min = Math.min( r, g, b );
	
			var hue, saturation;
			var lightness = ( min + max ) / 2.0;
	
			if ( min === max ) {
	
				hue = 0;
				saturation = 0;
	
			} else {
	
				var delta = max - min;
	
				saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );
	
				switch ( max ) {
	
					case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
					case g: hue = ( b - r ) / delta + 2; break;
					case b: hue = ( r - g ) / delta + 4; break;
	
				}
	
				hue /= 6;
	
			}
	
			hsl.h = hue;
			hsl.s = saturation;
			hsl.l = lightness;
	
			return hsl;
	
		},
	
		getStyle: function () {
	
			return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';
	
		},
	
		offsetHSL: function ( h, s, l ) {
	
			var hsl = this.getHSL();
	
			hsl.h += h; hsl.s += s; hsl.l += l;
	
			this.setHSL( hsl.h, hsl.s, hsl.l );
	
			return this;
	
		},
	
		add: function ( color ) {
	
			this.r += color.r;
			this.g += color.g;
			this.b += color.b;
	
			return this;
	
		},
	
		addColors: function ( color1, color2 ) {
	
			this.r = color1.r + color2.r;
			this.g = color1.g + color2.g;
			this.b = color1.b + color2.b;
	
			return this;
	
		},
	
		addScalar: function ( s ) {
	
			this.r += s;
			this.g += s;
			this.b += s;
	
			return this;
	
		},
	
		multiply: function ( color ) {
	
			this.r *= color.r;
			this.g *= color.g;
			this.b *= color.b;
	
			return this;
	
		},
	
		multiplyScalar: function ( s ) {
	
			this.r *= s;
			this.g *= s;
			this.b *= s;
	
			return this;
	
		},
	
		lerp: function ( color, alpha ) {
	
			this.r += ( color.r - this.r ) * alpha;
			this.g += ( color.g - this.g ) * alpha;
			this.b += ( color.b - this.b ) * alpha;
	
			return this;
	
		},
	
		equals: function ( c ) {
	
			return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );
	
		},
	
		fromArray: function ( array, offset ) {
	
			if ( offset === undefined ) offset = 0;
	
			this.r = array[ offset ];
			this.g = array[ offset + 1 ];
			this.b = array[ offset + 2 ];
	
			return this;
	
		},
	
		toArray: function ( array, offset ) {
	
			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;
	
			array[ offset ] = this.r;
			array[ offset + 1 ] = this.g;
			array[ offset + 2 ] = this.b;
	
			return array;
	
		}
	
	};
	
	THREE.ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
	'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
	'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
	'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
	'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
	'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
	'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
	'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
	'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
	'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
	'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
	'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
	'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
	'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
	'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
	'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
	'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
	'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
	'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
	'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
	'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
	'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
	'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
	'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };
	
	// File:src/math/Quaternion.js
	
	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://clara.io
	 */
	
	THREE.Quaternion = function ( x, y, z, w ) {
	
		this._x = x || 0;
		this._y = y || 0;
		this._z = z || 0;
		this._w = ( w !== undefined ) ? w : 1;
	
	};
	
	THREE.Quaternion.prototype = {
	
		constructor: THREE.Quaternion,
	
		get x () {
	
			return this._x;
	
		},
	
		set x ( value ) {
	
			this._x = value;
			this.onChangeCallback();
	
		},
	
		get y () {
	
			return this._y;
	
		},
	
		set y ( value ) {
	
			this._y = value;
			this.onChangeCallback();
	
		},
	
		get z () {
	
			return this._z;
	
		},
	
		set z ( value ) {
	
			this._z = value;
			this.onChangeCallback();
	
		},
	
		get w () {
	
			return this._w;
	
		},
	
		set w ( value ) {
	
			this._w = value;
			this.onChangeCallback();
	
		},
	
		set: function ( x, y, z, w ) {
	
			this._x = x;
			this._y = y;
			this._z = z;
			this._w = w;
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		clone: function () {
	
			return new this.constructor( this._x, this._y, this._z, this._w );
	
		},
	
		copy: function ( quaternion ) {
	
			this._x = quaternion.x;
			this._y = quaternion.y;
			this._z = quaternion.z;
			this._w = quaternion.w;
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		setFromEuler: function ( euler, update ) {
	
			if ( euler instanceof THREE.Euler === false ) {
	
				throw new Error( 'THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );
	
			}
	
			// http://www.mathworks.com/matlabcentral/fileexchange/
			// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
			//	content/SpinCalc.m
	
			var c1 = Math.cos( euler._x / 2 );
			var c2 = Math.cos( euler._y / 2 );
			var c3 = Math.cos( euler._z / 2 );
			var s1 = Math.sin( euler._x / 2 );
			var s2 = Math.sin( euler._y / 2 );
			var s3 = Math.sin( euler._z / 2 );
	
			var order = euler.order;
	
			if ( order === 'XYZ' ) {
	
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
	
			} else if ( order === 'YXZ' ) {
	
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
	
			} else if ( order === 'ZXY' ) {
	
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
	
			} else if ( order === 'ZYX' ) {
	
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
	
			} else if ( order === 'YZX' ) {
	
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
	
			} else if ( order === 'XZY' ) {
	
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
	
			}
	
			if ( update !== false ) this.onChangeCallback();
	
			return this;
	
		},
	
		setFromAxisAngle: function ( axis, angle ) {
	
			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
	
			// assumes axis is normalized
	
			var halfAngle = angle / 2, s = Math.sin( halfAngle );
	
			this._x = axis.x * s;
			this._y = axis.y * s;
			this._z = axis.z * s;
			this._w = Math.cos( halfAngle );
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		setFromRotationMatrix: function ( m ) {
	
			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
	
			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
	
			var te = m.elements,
	
				m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
				m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
				m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],
	
				trace = m11 + m22 + m33,
				s;
	
			if ( trace > 0 ) {
	
				s = 0.5 / Math.sqrt( trace + 1.0 );
	
				this._w = 0.25 / s;
				this._x = ( m32 - m23 ) * s;
				this._y = ( m13 - m31 ) * s;
				this._z = ( m21 - m12 ) * s;
	
			} else if ( m11 > m22 && m11 > m33 ) {
	
				s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );
	
				this._w = ( m32 - m23 ) / s;
				this._x = 0.25 * s;
				this._y = ( m12 + m21 ) / s;
				this._z = ( m13 + m31 ) / s;
	
			} else if ( m22 > m33 ) {
	
				s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );
	
				this._w = ( m13 - m31 ) / s;
				this._x = ( m12 + m21 ) / s;
				this._y = 0.25 * s;
				this._z = ( m23 + m32 ) / s;
	
			} else {
	
				s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );
	
				this._w = ( m21 - m12 ) / s;
				this._x = ( m13 + m31 ) / s;
				this._y = ( m23 + m32 ) / s;
				this._z = 0.25 * s;
	
			}
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		setFromUnitVectors: function () {
	
			// http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final
	
			// assumes direction vectors vFrom and vTo are normalized
	
			var v1, r;
	
			var EPS = 0.000001;
	
			return function ( vFrom, vTo ) {
	
				if ( v1 === undefined ) v1 = new THREE.Vector3();
	
				r = vFrom.dot( vTo ) + 1;
	
				if ( r < EPS ) {
	
					r = 0;
	
					if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {
	
						v1.set( - vFrom.y, vFrom.x, 0 );
	
					} else {
	
						v1.set( 0, - vFrom.z, vFrom.y );
	
					}
	
				} else {
	
					v1.crossVectors( vFrom, vTo );
	
				}
	
				this._x = v1.x;
				this._y = v1.y;
				this._z = v1.z;
				this._w = r;
	
				this.normalize();
	
				return this;
	
			};
	
		}(),
	
		inverse: function () {
	
			this.conjugate().normalize();
	
			return this;
	
		},
	
		conjugate: function () {
	
			this._x *= - 1;
			this._y *= - 1;
			this._z *= - 1;
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		dot: function ( v ) {
	
			return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
	
		},
	
		lengthSq: function () {
	
			return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
	
		},
	
		length: function () {
	
			return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );
	
		},
	
		normalize: function () {
	
			var l = this.length();
	
			if ( l === 0 ) {
	
				this._x = 0;
				this._y = 0;
				this._z = 0;
				this._w = 1;
	
			} else {
	
				l = 1 / l;
	
				this._x = this._x * l;
				this._y = this._y * l;
				this._z = this._z * l;
				this._w = this._w * l;
	
			}
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		multiply: function ( q, p ) {
	
			if ( p !== undefined ) {
	
				console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
				return this.multiplyQuaternions( q, p );
	
			}
	
			return this.multiplyQuaternions( this, q );
	
		},
	
		multiplyQuaternions: function ( a, b ) {
	
			// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
	
			var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
			var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
	
			this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
			this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
			this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
			this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		slerp: function ( qb, t ) {
	
			if ( t === 0 ) return this;
			if ( t === 1 ) return this.copy( qb );
	
			var x = this._x, y = this._y, z = this._z, w = this._w;
	
			// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/
	
			var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
	
			if ( cosHalfTheta < 0 ) {
	
				this._w = - qb._w;
				this._x = - qb._x;
				this._y = - qb._y;
				this._z = - qb._z;
	
				cosHalfTheta = - cosHalfTheta;
	
			} else {
	
				this.copy( qb );
	
			}
	
			if ( cosHalfTheta >= 1.0 ) {
	
				this._w = w;
				this._x = x;
				this._y = y;
				this._z = z;
	
				return this;
	
			}
	
			var sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );
	
			if ( Math.abs( sinHalfTheta ) < 0.001 ) {
	
				this._w = 0.5 * ( w + this._w );
				this._x = 0.5 * ( x + this._x );
				this._y = 0.5 * ( y + this._y );
				this._z = 0.5 * ( z + this._z );
	
				return this;
	
			}
	
			var halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
			var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
			ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;
	
			this._w = ( w * ratioA + this._w * ratioB );
			this._x = ( x * ratioA + this._x * ratioB );
			this._y = ( y * ratioA + this._y * ratioB );
			this._z = ( z * ratioA + this._z * ratioB );
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		equals: function ( quaternion ) {
	
			return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );
	
		},
	
		fromArray: function ( array, offset ) {
	
			if ( offset === undefined ) offset = 0;
	
			this._x = array[ offset ];
			this._y = array[ offset + 1 ];
			this._z = array[ offset + 2 ];
			this._w = array[ offset + 3 ];
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		toArray: function ( array, offset ) {
	
			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;
	
			array[ offset ] = this._x;
			array[ offset + 1 ] = this._y;
			array[ offset + 2 ] = this._z;
			array[ offset + 3 ] = this._w;
	
			return array;
	
		},
	
		onChange: function ( callback ) {
	
			this.onChangeCallback = callback;
	
			return this;
	
		},
	
		onChangeCallback: function () {}
	
	};
	
	Object.assign( THREE.Quaternion, {
	
		slerp: function( qa, qb, qm, t ) {
	
			return qm.copy( qa ).slerp( qb, t );
	
		},
	
		slerpFlat: function(
				dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {
	
			// fuzz-free, array-based Quaternion SLERP operation
	
			var x0 = src0[ srcOffset0 + 0 ],
				y0 = src0[ srcOffset0 + 1 ],
				z0 = src0[ srcOffset0 + 2 ],
				w0 = src0[ srcOffset0 + 3 ],
	
				x1 = src1[ srcOffset1 + 0 ],
				y1 = src1[ srcOffset1 + 1 ],
				z1 = src1[ srcOffset1 + 2 ],
				w1 = src1[ srcOffset1 + 3 ];
	
			if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {
	
				var s = 1 - t,
	
					cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
	
					dir = ( cos >= 0 ? 1 : - 1 ),
					sqrSin = 1 - cos * cos;
	
				// Skip the Slerp for tiny steps to avoid numeric problems:
				if ( sqrSin > Number.EPSILON ) {
	
					var sin = Math.sqrt( sqrSin ),
						len = Math.atan2( sin, cos * dir );
	
					s = Math.sin( s * len ) / sin;
					t = Math.sin( t * len ) / sin;
	
				}
	
				var tDir = t * dir;
	
				x0 = x0 * s + x1 * tDir;
				y0 = y0 * s + y1 * tDir;
				z0 = z0 * s + z1 * tDir;
				w0 = w0 * s + w1 * tDir;
	
				// Normalize in case we just did a lerp:
				if ( s === 1 - t ) {
	
					var f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );
	
					x0 *= f;
					y0 *= f;
					z0 *= f;
					w0 *= f;
	
				}
	
			}
	
			dst[ dstOffset ] = x0;
			dst[ dstOffset + 1 ] = y0;
			dst[ dstOffset + 2 ] = z0;
			dst[ dstOffset + 3 ] = w0;
	
		}
	
	} );
	
	// File:src/math/Vector2.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author philogb / http://blog.thejit.org/
	 * @author egraether / http://egraether.com/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 */
	
	THREE.Vector2 = function ( x, y ) {
	
		this.x = x || 0;
		this.y = y || 0;
	
	};
	
	THREE.Vector2.prototype = {
	
		constructor: THREE.Vector2,
	
		get width() {
	
			return this.x;
	
		},
	
		set width( value ) {
	
			this.x = value;
	
		},
	
		get height() {
	
			return this.y;
	
		},
	
		set height( value ) {
	
			this.y = value;
	
		},
	
		//
	
		set: function ( x, y ) {
	
			this.x = x;
			this.y = y;
	
			return this;
	
		},
	
		setScalar: function ( scalar ) {
	
			this.x = scalar;
			this.y = scalar;
	
			return this;
	
		},
	
		setX: function ( x ) {
	
			this.x = x;
	
			return this;
	
		},
	
		setY: function ( y ) {
	
			this.y = y;
	
			return this;
	
		},
	
		setComponent: function ( index, value ) {
	
			switch ( index ) {
	
				case 0: this.x = value; break;
				case 1: this.y = value; break;
				default: throw new Error( 'index is out of range: ' + index );
	
			}
	
		},
	
		getComponent: function ( index ) {
	
			switch ( index ) {
	
				case 0: return this.x;
				case 1: return this.y;
				default: throw new Error( 'index is out of range: ' + index );
	
			}
	
		},
	
		clone: function () {
	
			return new this.constructor( this.x, this.y );
	
		},
	
		copy: function ( v ) {
	
			this.x = v.x;
			this.y = v.y;
	
			return this;
	
		},
	
		add: function ( v, w ) {
	
			if ( w !== undefined ) {
	
				console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );
	
			}
	
			this.x += v.x;
			this.y += v.y;
	
			return this;
	
		},
	
		addScalar: function ( s ) {
	
			this.x += s;
			this.y += s;
	
			return this;
	
		},
	
		addVectors: function ( a, b ) {
	
			this.x = a.x + b.x;
			this.y = a.y + b.y;
	
			return this;
	
		},
	
		addScaledVector: function ( v, s ) {
	
			this.x += v.x * s;
			this.y += v.y * s;
	
			return this;
	
		},
	
		sub: function ( v, w ) {
	
			if ( w !== undefined ) {
	
				console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );
	
			}
	
			this.x -= v.x;
			this.y -= v.y;
	
			return this;
	
		},
	
		subScalar: function ( s ) {
	
			this.x -= s;
			this.y -= s;
	
			return this;
	
		},
	
		subVectors: function ( a, b ) {
	
			this.x = a.x - b.x;
			this.y = a.y - b.y;
	
			return this;
	
		},
	
		multiply: function ( v ) {
	
			this.x *= v.x;
			this.y *= v.y;
	
			return this;
	
		},
	
		multiplyScalar: function ( scalar ) {
	
			if ( isFinite( scalar ) ) {
	
				this.x *= scalar;
				this.y *= scalar;
	
			} else {
	
				this.x = 0;
				this.y = 0;
	
			}
	
			return this;
	
		},
	
		divide: function ( v ) {
	
			this.x /= v.x;
			this.y /= v.y;
	
			return this;
	
		},
	
		divideScalar: function ( scalar ) {
	
			return this.multiplyScalar( 1 / scalar );
	
		},
	
		min: function ( v ) {
	
			this.x = Math.min( this.x, v.x );
			this.y = Math.min( this.y, v.y );
	
			return this;
	
		},
	
		max: function ( v ) {
	
			this.x = Math.max( this.x, v.x );
			this.y = Math.max( this.y, v.y );
	
			return this;
	
		},
	
		clamp: function ( min, max ) {
	
			// This function assumes min < max, if this assumption isn't true it will not operate correctly
	
			this.x = Math.max( min.x, Math.min( max.x, this.x ) );
			this.y = Math.max( min.y, Math.min( max.y, this.y ) );
	
			return this;
	
		},
	
		clampScalar: function () {
	
			var min, max;
	
			return function clampScalar( minVal, maxVal ) {
	
				if ( min === undefined ) {
	
					min = new THREE.Vector2();
					max = new THREE.Vector2();
	
				}
	
				min.set( minVal, minVal );
				max.set( maxVal, maxVal );
	
				return this.clamp( min, max );
	
			};
	
		}(),
	
		clampLength: function ( min, max ) {
	
			var length = this.length();
	
			this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );
	
			return this;
	
		},
	
		floor: function () {
	
			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );
	
			return this;
	
		},
	
		ceil: function () {
	
			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );
	
			return this;
	
		},
	
		round: function () {
	
			this.x = Math.round( this.x );
			this.y = Math.round( this.y );
	
			return this;
	
		},
	
		roundToZero: function () {
	
			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
	
			return this;
	
		},
	
		negate: function () {
	
			this.x = - this.x;
			this.y = - this.y;
	
			return this;
	
		},
	
		dot: function ( v ) {
	
			return this.x * v.x + this.y * v.y;
	
		},
	
		lengthSq: function () {
	
			return this.x * this.x + this.y * this.y;
	
		},
	
		length: function () {
	
			return Math.sqrt( this.x * this.x + this.y * this.y );
	
		},
	
		lengthManhattan: function() {
	
			return Math.abs( this.x ) + Math.abs( this.y );
	
		},
	
		normalize: function () {
	
			return this.divideScalar( this.length() );
	
		},
	
		angle: function () {
	
			// computes the angle in radians with respect to the positive x-axis
	
			var angle = Math.atan2( this.y, this.x );
	
			if ( angle < 0 ) angle += 2 * Math.PI;
	
			return angle;
	
		},
	
		distanceTo: function ( v ) {
	
			return Math.sqrt( this.distanceToSquared( v ) );
	
		},
	
		distanceToSquared: function ( v ) {
	
			var dx = this.x - v.x, dy = this.y - v.y;
			return dx * dx + dy * dy;
	
		},
	
		setLength: function ( length ) {
	
			return this.multiplyScalar( length / this.length() );
	
		},
	
		lerp: function ( v, alpha ) {
	
			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;
	
			return this;
	
		},
	
		lerpVectors: function ( v1, v2, alpha ) {
	
			this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );
	
			return this;
	
		},
	
		equals: function ( v ) {
	
			return ( ( v.x === this.x ) && ( v.y === this.y ) );
	
		},
	
		fromArray: function ( array, offset ) {
	
			if ( offset === undefined ) offset = 0;
	
			this.x = array[ offset ];
			this.y = array[ offset + 1 ];
	
			return this;
	
		},
	
		toArray: function ( array, offset ) {
	
			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;
	
			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;
	
			return array;
	
		},
	
		fromAttribute: function ( attribute, index, offset ) {
	
			if ( offset === undefined ) offset = 0;
	
			index = index * attribute.itemSize + offset;
	
			this.x = attribute.array[ index ];
			this.y = attribute.array[ index + 1 ];
	
			return this;
	
		},
	
		rotateAround: function ( center, angle ) {
	
			var c = Math.cos( angle ), s = Math.sin( angle );
	
			var x = this.x - center.x;
			var y = this.y - center.y;
	
			this.x = x * c - y * s + center.x;
			this.y = x * s + y * c + center.y;
	
			return this;
	
		}
	
	};
	
	// File:src/math/Vector3.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author *kile / http://kile.stravaganza.org/
	 * @author philogb / http://blog.thejit.org/
	 * @author mikael emtinger / http://gomo.se/
	 * @author egraether / http://egraether.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */
	
	THREE.Vector3 = function ( x, y, z ) {
	
		this.x = x || 0;
		this.y = y || 0;
		this.z = z || 0;
	
	};
	
	THREE.Vector3.prototype = {
	
		constructor: THREE.Vector3,
	
		set: function ( x, y, z ) {
	
			this.x = x;
			this.y = y;
			this.z = z;
	
			return this;
	
		},
	
		setScalar: function ( scalar ) {
	
			this.x = scalar;
			this.y = scalar;
			this.z = scalar;
	
			return this;
	
		},
	
		setX: function ( x ) {
	
			this.x = x;
	
			return this;
	
		},
	
		setY: function ( y ) {
	
			this.y = y;
	
			return this;
	
		},
	
		setZ: function ( z ) {
	
			this.z = z;
	
			return this;
	
		},
	
		setComponent: function ( index, value ) {
	
			switch ( index ) {
	
				case 0: this.x = value; break;
				case 1: this.y = value; break;
				case 2: this.z = value; break;
				default: throw new Error( 'index is out of range: ' + index );
	
			}
	
		},
	
		getComponent: function ( index ) {
	
			switch ( index ) {
	
				case 0: return this.x;
				case 1: return this.y;
				case 2: return this.z;
				default: throw new Error( 'index is out of range: ' + index );
	
			}
	
		},
	
		clone: function () {
	
			return new this.constructor( this.x, this.y, this.z );
	
		},
	
		copy: function ( v ) {
	
			this.x = v.x;
			this.y = v.y;
			this.z = v.z;
	
			return this;
	
		},
	
		add: function ( v, w ) {
	
			if ( w !== undefined ) {
	
				console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );
	
			}
	
			this.x += v.x;
			this.y += v.y;
			this.z += v.z;
	
			return this;
	
		},
	
		addScalar: function ( s ) {
	
			this.x += s;
			this.y += s;
			this.z += s;
	
			return this;
	
		},
	
		addVectors: function ( a, b ) {
	
			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;
	
			return this;
	
		},
	
		addScaledVector: function ( v, s ) {
	
			this.x += v.x * s;
			this.y += v.y * s;
			this.z += v.z * s;
	
			return this;
	
		},
	
		sub: function ( v, w ) {
	
			if ( w !== undefined ) {
	
				console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );
	
			}
	
			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;
	
			return this;
	
		},
	
		subScalar: function ( s ) {
	
			this.x -= s;
			this.y -= s;
			this.z -= s;
	
			return this;
	
		},
	
		subVectors: function ( a, b ) {
	
			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;
	
			return this;
	
		},
	
		multiply: function ( v, w ) {
	
			if ( w !== undefined ) {
	
				console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
				return this.multiplyVectors( v, w );
	
			}
	
			this.x *= v.x;
			this.y *= v.y;
			this.z *= v.z;
	
			return this;
	
		},
	
		multiplyScalar: function ( scalar ) {
	
			if ( isFinite( scalar ) ) {
	
				this.x *= scalar;
				this.y *= scalar;
				this.z *= scalar;
	
			} else {
	
				this.x = 0;
				this.y = 0;
				this.z = 0;
	
			}
	
			return this;
	
		},
	
		multiplyVectors: function ( a, b ) {
	
			this.x = a.x * b.x;
			this.y = a.y * b.y;
			this.z = a.z * b.z;
	
			return this;
	
		},
	
		applyEuler: function () {
	
			var quaternion;
	
			return function applyEuler( euler ) {
	
				if ( euler instanceof THREE.Euler === false ) {
	
					console.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );
	
				}
	
				if ( quaternion === undefined ) quaternion = new THREE.Quaternion();
	
				this.applyQuaternion( quaternion.setFromEuler( euler ) );
	
				return this;
	
			};
	
		}(),
	
		applyAxisAngle: function () {
	
			var quaternion;
	
			return function applyAxisAngle( axis, angle ) {
	
				if ( quaternion === undefined ) quaternion = new THREE.Quaternion();
	
				this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );
	
				return this;
	
			};
	
		}(),
	
		applyMatrix3: function ( m ) {
	
			var x = this.x;
			var y = this.y;
			var z = this.z;
	
			var e = m.elements;
	
			this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
			this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
			this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;
	
			return this;
	
		},
	
		applyMatrix4: function ( m ) {
	
			// input: THREE.Matrix4 affine matrix
	
			var x = this.x, y = this.y, z = this.z;
	
			var e = m.elements;
	
			this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ];
			this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ];
			this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ];
	
			return this;
	
		},
	
		applyProjection: function ( m ) {
	
			// input: THREE.Matrix4 projection matrix
	
			var x = this.x, y = this.y, z = this.z;
	
			var e = m.elements;
			var d = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] ); // perspective divide
	
			this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ] ) * d;
			this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ] ) * d;
			this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * d;
	
			return this;
	
		},
	
		applyQuaternion: function ( q ) {
	
			var x = this.x;
			var y = this.y;
			var z = this.z;
	
			var qx = q.x;
			var qy = q.y;
			var qz = q.z;
			var qw = q.w;
	
			// calculate quat * vector
	
			var ix =  qw * x + qy * z - qz * y;
			var iy =  qw * y + qz * x - qx * z;
			var iz =  qw * z + qx * y - qy * x;
			var iw = - qx * x - qy * y - qz * z;
	
			// calculate result * inverse quat
	
			this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
			this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
			this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;
	
			return this;
	
		},
	
		project: function () {
	
			var matrix;
	
			return function project( camera ) {
	
				if ( matrix === undefined ) matrix = new THREE.Matrix4();
	
				matrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );
				return this.applyProjection( matrix );
	
			};
	
		}(),
	
		unproject: function () {
	
			var matrix;
	
			return function unproject( camera ) {
	
				if ( matrix === undefined ) matrix = new THREE.Matrix4();
	
				matrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );
				return this.applyProjection( matrix );
	
			};
	
		}(),
	
		transformDirection: function ( m ) {
	
			// input: THREE.Matrix4 affine matrix
			// vector interpreted as a direction
	
			var x = this.x, y = this.y, z = this.z;
	
			var e = m.elements;
	
			this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z;
			this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z;
			this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;
	
			this.normalize();
	
			return this;
	
		},
	
		divide: function ( v ) {
	
			this.x /= v.x;
			this.y /= v.y;
			this.z /= v.z;
	
			return this;
	
		},
	
		divideScalar: function ( scalar ) {
	
			return this.multiplyScalar( 1 / scalar );
	
		},
	
		min: function ( v ) {
	
			this.x = Math.min( this.x, v.x );
			this.y = Math.min( this.y, v.y );
			this.z = Math.min( this.z, v.z );
	
			return this;
	
		},
	
		max: function ( v ) {
	
			this.x = Math.max( this.x, v.x );
			this.y = Math.max( this.y, v.y );
			this.z = Math.max( this.z, v.z );
	
			return this;
	
		},
	
		clamp: function ( min, max ) {
	
			// This function assumes min < max, if this assumption isn't true it will not operate correctly
	
			this.x = Math.max( min.x, Math.min( max.x, this.x ) );
			this.y = Math.max( min.y, Math.min( max.y, this.y ) );
			this.z = Math.max( min.z, Math.min( max.z, this.z ) );
	
			return this;
	
		},
	
		clampScalar: function () {
	
			var min, max;
	
			return function clampScalar( minVal, maxVal ) {
	
				if ( min === undefined ) {
	
					min = new THREE.Vector3();
					max = new THREE.Vector3();
	
				}
	
				min.set( minVal, minVal, minVal );
				max.set( maxVal, maxVal, maxVal );
	
				return this.clamp( min, max );
	
			};
	
		}(),
	
		clampLength: function ( min, max ) {
	
			var length = this.length();
	
			this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );
	
			return this;
	
		},
	
		floor: function () {
	
			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );
			this.z = Math.floor( this.z );
	
			return this;
	
		},
	
		ceil: function () {
	
			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );
			this.z = Math.ceil( this.z );
	
			return this;
	
		},
	
		round: function () {
	
			this.x = Math.round( this.x );
			this.y = Math.round( this.y );
			this.z = Math.round( this.z );
	
			return this;
	
		},
	
		roundToZero: function () {
	
			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
			this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
	
			return this;
	
		},
	
		negate: function () {
	
			this.x = - this.x;
			this.y = - this.y;
			this.z = - this.z;
	
			return this;
	
		},
	
		dot: function ( v ) {
	
			return this.x * v.x + this.y * v.y + this.z * v.z;
	
		},
	
		lengthSq: function () {
	
			return this.x * this.x + this.y * this.y + this.z * this.z;
	
		},
	
		length: function () {
	
			return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );
	
		},
	
		lengthManhattan: function () {
	
			return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );
	
		},
	
		normalize: function () {
	
			return this.divideScalar( this.length() );
	
		},
	
		setLength: function ( length ) {
	
			return this.multiplyScalar( length / this.length() );
	
		},
	
		lerp: function ( v, alpha ) {
	
			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;
			this.z += ( v.z - this.z ) * alpha;
	
			return this;
	
		},
	
		lerpVectors: function ( v1, v2, alpha ) {
	
			this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );
	
			return this;
	
		},
	
		cross: function ( v, w ) {
	
			if ( w !== undefined ) {
	
				console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
				return this.crossVectors( v, w );
	
			}
	
			var x = this.x, y = this.y, z = this.z;
	
			this.x = y * v.z - z * v.y;
			this.y = z * v.x - x * v.z;
			this.z = x * v.y - y * v.x;
	
			return this;
	
		},
	
		crossVectors: function ( a, b ) {
	
			var ax = a.x, ay = a.y, az = a.z;
			var bx = b.x, by = b.y, bz = b.z;
	
			this.x = ay * bz - az * by;
			this.y = az * bx - ax * bz;
			this.z = ax * by - ay * bx;
	
			return this;
	
		},
	
		projectOnVector: function () {
	
			var v1, dot;
	
			return function projectOnVector( vector ) {
	
				if ( v1 === undefined ) v1 = new THREE.Vector3();
	
				v1.copy( vector ).normalize();
	
				dot = this.dot( v1 );
	
				return this.copy( v1 ).multiplyScalar( dot );
	
			};
	
		}(),
	
		projectOnPlane: function () {
	
			var v1;
	
			return function projectOnPlane( planeNormal ) {
	
				if ( v1 === undefined ) v1 = new THREE.Vector3();
	
				v1.copy( this ).projectOnVector( planeNormal );
	
				return this.sub( v1 );
	
			}
	
		}(),
	
		reflect: function () {
	
			// reflect incident vector off plane orthogonal to normal
			// normal is assumed to have unit length
	
			var v1;
	
			return function reflect( normal ) {
	
				if ( v1 === undefined ) v1 = new THREE.Vector3();
	
				return this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );
	
			}
	
		}(),
	
		angleTo: function ( v ) {
	
			var theta = this.dot( v ) / ( Math.sqrt( this.lengthSq() * v.lengthSq() ) );
	
			// clamp, to handle numerical problems
	
			return Math.acos( THREE.Math.clamp( theta, - 1, 1 ) );
	
		},
	
		distanceTo: function ( v ) {
	
			return Math.sqrt( this.distanceToSquared( v ) );
	
		},
	
		distanceToSquared: function ( v ) {
	
			var dx = this.x - v.x;
			var dy = this.y - v.y;
			var dz = this.z - v.z;
	
			return dx * dx + dy * dy + dz * dz;
	
		},
	
		setFromMatrixPosition: function ( m ) {
	
			this.x = m.elements[ 12 ];
			this.y = m.elements[ 13 ];
			this.z = m.elements[ 14 ];
	
			return this;
	
		},
	
		setFromMatrixScale: function ( m ) {
	
			var sx = this.set( m.elements[ 0 ], m.elements[ 1 ], m.elements[ 2 ] ).length();
			var sy = this.set( m.elements[ 4 ], m.elements[ 5 ], m.elements[ 6 ] ).length();
			var sz = this.set( m.elements[ 8 ], m.elements[ 9 ], m.elements[ 10 ] ).length();
	
			this.x = sx;
			this.y = sy;
			this.z = sz;
	
			return this;
	
		},
	
		setFromMatrixColumn: function ( index, matrix ) {
	
			var offset = index * 4;
	
			var me = matrix.elements;
	
			this.x = me[ offset ];
			this.y = me[ offset + 1 ];
			this.z = me[ offset + 2 ];
	
			return this;
	
		},
	
		equals: function ( v ) {
	
			return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );
	
		},
	
		fromArray: function ( array, offset ) {
	
			if ( offset === undefined ) offset = 0;
	
			this.x = array[ offset ];
			this.y = array[ offset + 1 ];
			this.z = array[ offset + 2 ];
	
			return this;
	
		},
	
		toArray: function ( array, offset ) {
	
			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;
	
			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;
			array[ offset + 2 ] = this.z;
	
			return array;
	
		},
	
		fromAttribute: function ( attribute, index, offset ) {
	
			if ( offset === undefined ) offset = 0;
	
			index = index * attribute.itemSize + offset;
	
			this.x = attribute.array[ index ];
			this.y = attribute.array[ index + 1 ];
			this.z = attribute.array[ index + 2 ];
	
			return this;
	
		}
	
	};
	
	// File:src/math/Vector4.js
	
	/**
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author philogb / http://blog.thejit.org/
	 * @author mikael emtinger / http://gomo.se/
	 * @author egraether / http://egraether.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */
	
	THREE.Vector4 = function ( x, y, z, w ) {
	
		this.x = x || 0;
		this.y = y || 0;
		this.z = z || 0;
		this.w = ( w !== undefined ) ? w : 1;
	
	};
	
	THREE.Vector4.prototype = {
	
		constructor: THREE.Vector4,
	
		set: function ( x, y, z, w ) {
	
			this.x = x;
			this.y = y;
			this.z = z;
			this.w = w;
	
			return this;
	
		},
	
		setScalar: function ( scalar ) {
	
			this.x = scalar;
			this.y = scalar;
			this.z = scalar;
			this.w = scalar;
	
			return this;
	
		},
	
		setX: function ( x ) {
	
			this.x = x;
	
			return this;
	
		},
	
		setY: function ( y ) {
	
			this.y = y;
	
			return this;
	
		},
	
		setZ: function ( z ) {
	
			this.z = z;
	
			return this;
	
		},
	
		setW: function ( w ) {
	
			this.w = w;
	
			return this;
	
		},
	
		setComponent: function ( index, value ) {
	
			switch ( index ) {
	
				case 0: this.x = value; break;
				case 1: this.y = value; break;
				case 2: this.z = value; break;
				case 3: this.w = value; break;
				default: throw new Error( 'index is out of range: ' + index );
	
			}
	
		},
	
		getComponent: function ( index ) {
	
			switch ( index ) {
	
				case 0: return this.x;
				case 1: return this.y;
				case 2: return this.z;
				case 3: return this.w;
				default: throw new Error( 'index is out of range: ' + index );
	
			}
	
		},
	
		clone: function () {
	
			return new this.constructor( this.x, this.y, this.z, this.w );
	
		},
	
		copy: function ( v ) {
	
			this.x = v.x;
			this.y = v.y;
			this.z = v.z;
			this.w = ( v.w !== undefined ) ? v.w : 1;
	
			return this;
	
		},
	
		add: function ( v, w ) {
	
			if ( w !== undefined ) {
	
				console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );
	
			}
	
			this.x += v.x;
			this.y += v.y;
			this.z += v.z;
			this.w += v.w;
	
			return this;
	
		},
	
		addScalar: function ( s ) {
	
			this.x += s;
			this.y += s;
			this.z += s;
			this.w += s;
	
			return this;
	
		},
	
		addVectors: function ( a, b ) {
	
			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;
			this.w = a.w + b.w;
	
			return this;
	
		},
	
		addScaledVector: function ( v, s ) {
	
			this.x += v.x * s;
			this.y += v.y * s;
			this.z += v.z * s;
			this.w += v.w * s;
	
			return this;
	
		},
	
		sub: function ( v, w ) {
	
			if ( w !== undefined ) {
	
				console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );
	
			}
	
			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;
			this.w -= v.w;
	
			return this;
	
		},
	
		subScalar: function ( s ) {
	
			this.x -= s;
			this.y -= s;
			this.z -= s;
			this.w -= s;
	
			return this;
	
		},
	
		subVectors: function ( a, b ) {
	
			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;
			this.w = a.w - b.w;
	
			return this;
	
		},
	
		multiplyScalar: function ( scalar ) {
	
			if ( isFinite( scalar ) ) {
	
				this.x *= scalar;
				this.y *= scalar;
				this.z *= scalar;
				this.w *= scalar;
	
			} else {
	
				this.x = 0;
				this.y = 0;
				this.z = 0;
				this.w = 0;
	
			}
	
			return this;
	
		},
	
		applyMatrix4: function ( m ) {
	
			var x = this.x;
			var y = this.y;
			var z = this.z;
			var w = this.w;
	
			var e = m.elements;
	
			this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
			this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
			this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
			this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;
	
			return this;
	
		},
	
		divideScalar: function ( scalar ) {
	
			return this.multiplyScalar( 1 / scalar );
	
		},
	
		setAxisAngleFromQuaternion: function ( q ) {
	
			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm
	
			// q is assumed to be normalized
	
			this.w = 2 * Math.acos( q.w );
	
			var s = Math.sqrt( 1 - q.w * q.w );
	
			if ( s < 0.0001 ) {
	
				 this.x = 1;
				 this.y = 0;
				 this.z = 0;
	
			} else {
	
				 this.x = q.x / s;
				 this.y = q.y / s;
				 this.z = q.z / s;
	
			}
	
			return this;
	
		},
	
		setAxisAngleFromRotationMatrix: function ( m ) {
	
			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm
	
			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
	
			var angle, x, y, z,		// variables for result
				epsilon = 0.01,		// margin to allow for rounding errors
				epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees
	
				te = m.elements,
	
				m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
				m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
				m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];
	
			if ( ( Math.abs( m12 - m21 ) < epsilon )
			   && ( Math.abs( m13 - m31 ) < epsilon )
			   && ( Math.abs( m23 - m32 ) < epsilon ) ) {
	
				// singularity found
				// first check for identity matrix which must have +1 for all terms
				// in leading diagonal and zero in other terms
	
				if ( ( Math.abs( m12 + m21 ) < epsilon2 )
				   && ( Math.abs( m13 + m31 ) < epsilon2 )
				   && ( Math.abs( m23 + m32 ) < epsilon2 )
				   && ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {
	
					// this singularity is identity matrix so angle = 0
	
					this.set( 1, 0, 0, 0 );
	
					return this; // zero angle, arbitrary axis
	
				}
	
				// otherwise this singularity is angle = 180
	
				angle = Math.PI;
	
				var xx = ( m11 + 1 ) / 2;
				var yy = ( m22 + 1 ) / 2;
				var zz = ( m33 + 1 ) / 2;
				var xy = ( m12 + m21 ) / 4;
				var xz = ( m13 + m31 ) / 4;
				var yz = ( m23 + m32 ) / 4;
	
				if ( ( xx > yy ) && ( xx > zz ) ) {
	
					// m11 is the largest diagonal term
	
					if ( xx < epsilon ) {
	
						x = 0;
						y = 0.707106781;
						z = 0.707106781;
	
					} else {
	
						x = Math.sqrt( xx );
						y = xy / x;
						z = xz / x;
	
					}
	
				} else if ( yy > zz ) {
	
					// m22 is the largest diagonal term
	
					if ( yy < epsilon ) {
	
						x = 0.707106781;
						y = 0;
						z = 0.707106781;
	
					} else {
	
						y = Math.sqrt( yy );
						x = xy / y;
						z = yz / y;
	
					}
	
				} else {
	
					// m33 is the largest diagonal term so base result on this
	
					if ( zz < epsilon ) {
	
						x = 0.707106781;
						y = 0.707106781;
						z = 0;
	
					} else {
	
						z = Math.sqrt( zz );
						x = xz / z;
						y = yz / z;
	
					}
	
				}
	
				this.set( x, y, z, angle );
	
				return this; // return 180 deg rotation
	
			}
	
			// as we have reached here there are no singularities so we can handle normally
	
			var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 )
							  + ( m13 - m31 ) * ( m13 - m31 )
							  + ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize
	
			if ( Math.abs( s ) < 0.001 ) s = 1;
	
			// prevent divide by zero, should not happen if matrix is orthogonal and should be
			// caught by singularity test above, but I've left it in just in case
	
			this.x = ( m32 - m23 ) / s;
			this.y = ( m13 - m31 ) / s;
			this.z = ( m21 - m12 ) / s;
			this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );
	
			return this;
	
		},
	
		min: function ( v ) {
	
			this.x = Math.min( this.x, v.x );
			this.y = Math.min( this.y, v.y );
			this.z = Math.min( this.z, v.z );
			this.w = Math.min( this.w, v.w );
	
			return this;
	
		},
	
		max: function ( v ) {
	
			this.x = Math.max( this.x, v.x );
			this.y = Math.max( this.y, v.y );
			this.z = Math.max( this.z, v.z );
			this.w = Math.max( this.w, v.w );
	
			return this;
	
		},
	
		clamp: function ( min, max ) {
	
			// This function assumes min < max, if this assumption isn't true it will not operate correctly
	
			this.x = Math.max( min.x, Math.min( max.x, this.x ) );
			this.y = Math.max( min.y, Math.min( max.y, this.y ) );
			this.z = Math.max( min.z, Math.min( max.z, this.z ) );
			this.w = Math.max( min.w, Math.min( max.w, this.w ) );
	
			return this;
	
		},
	
		clampScalar: function () {
	
			var min, max;
	
			return function clampScalar( minVal, maxVal ) {
	
				if ( min === undefined ) {
	
					min = new THREE.Vector4();
					max = new THREE.Vector4();
	
				}
	
				min.set( minVal, minVal, minVal, minVal );
				max.set( maxVal, maxVal, maxVal, maxVal );
	
				return this.clamp( min, max );
	
			};
	
		}(),
	
		floor: function () {
	
			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );
			this.z = Math.floor( this.z );
			this.w = Math.floor( this.w );
	
			return this;
	
		},
	
		ceil: function () {
	
			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );
			this.z = Math.ceil( this.z );
			this.w = Math.ceil( this.w );
	
			return this;
	
		},
	
		round: function () {
	
			this.x = Math.round( this.x );
			this.y = Math.round( this.y );
			this.z = Math.round( this.z );
			this.w = Math.round( this.w );
	
			return this;
	
		},
	
		roundToZero: function () {
	
			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
			this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
			this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );
	
			return this;
	
		},
	
		negate: function () {
	
			this.x = - this.x;
			this.y = - this.y;
			this.z = - this.z;
			this.w = - this.w;
	
			return this;
	
		},
	
		dot: function ( v ) {
	
			return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
	
		},
	
		lengthSq: function () {
	
			return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
	
		},
	
		length: function () {
	
			return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );
	
		},
	
		lengthManhattan: function () {
	
			return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );
	
		},
	
		normalize: function () {
	
			return this.divideScalar( this.length() );
	
		},
	
		setLength: function ( length ) {
	
			return this.multiplyScalar( length / this.length() );
	
		},
	
		lerp: function ( v, alpha ) {
	
			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;
			this.z += ( v.z - this.z ) * alpha;
			this.w += ( v.w - this.w ) * alpha;
	
			return this;
	
		},
	
		lerpVectors: function ( v1, v2, alpha ) {
	
			this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );
	
			return this;
	
		},
	
		equals: function ( v ) {
	
			return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );
	
		},
	
		fromArray: function ( array, offset ) {
	
			if ( offset === undefined ) offset = 0;
	
			this.x = array[ offset ];
			this.y = array[ offset + 1 ];
			this.z = array[ offset + 2 ];
			this.w = array[ offset + 3 ];
	
			return this;
	
		},
	
		toArray: function ( array, offset ) {
	
			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;
	
			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;
			array[ offset + 2 ] = this.z;
			array[ offset + 3 ] = this.w;
	
			return array;
	
		},
	
		fromAttribute: function ( attribute, index, offset ) {
	
			if ( offset === undefined ) offset = 0;
	
			index = index * attribute.itemSize + offset;
	
			this.x = attribute.array[ index ];
			this.y = attribute.array[ index + 1 ];
			this.z = attribute.array[ index + 2 ];
			this.w = attribute.array[ index + 3 ];
	
			return this;
	
		}
	
	};
	
	// File:src/math/Euler.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://clara.io
	 */
	
	THREE.Euler = function ( x, y, z, order ) {
	
		this._x = x || 0;
		this._y = y || 0;
		this._z = z || 0;
		this._order = order || THREE.Euler.DefaultOrder;
	
	};
	
	THREE.Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];
	
	THREE.Euler.DefaultOrder = 'XYZ';
	
	THREE.Euler.prototype = {
	
		constructor: THREE.Euler,
	
		get x () {
	
			return this._x;
	
		},
	
		set x ( value ) {
	
			this._x = value;
			this.onChangeCallback();
	
		},
	
		get y () {
	
			return this._y;
	
		},
	
		set y ( value ) {
	
			this._y = value;
			this.onChangeCallback();
	
		},
	
		get z () {
	
			return this._z;
	
		},
	
		set z ( value ) {
	
			this._z = value;
			this.onChangeCallback();
	
		},
	
		get order () {
	
			return this._order;
	
		},
	
		set order ( value ) {
	
			this._order = value;
			this.onChangeCallback();
	
		},
	
		set: function ( x, y, z, order ) {
	
			this._x = x;
			this._y = y;
			this._z = z;
			this._order = order || this._order;
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		clone: function () {
	
			return new this.constructor( this._x, this._y, this._z, this._order );
	
		},
	
		copy: function ( euler ) {
	
			this._x = euler._x;
			this._y = euler._y;
			this._z = euler._z;
			this._order = euler._order;
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		setFromRotationMatrix: function ( m, order, update ) {
	
			var clamp = THREE.Math.clamp;
	
			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
	
			var te = m.elements;
			var m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
			var m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
			var m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];
	
			order = order || this._order;
	
			if ( order === 'XYZ' ) {
	
				this._y = Math.asin( clamp( m13, - 1, 1 ) );
	
				if ( Math.abs( m13 ) < 0.99999 ) {
	
					this._x = Math.atan2( - m23, m33 );
					this._z = Math.atan2( - m12, m11 );
	
				} else {
	
					this._x = Math.atan2( m32, m22 );
					this._z = 0;
	
				}
	
			} else if ( order === 'YXZ' ) {
	
				this._x = Math.asin( - clamp( m23, - 1, 1 ) );
	
				if ( Math.abs( m23 ) < 0.99999 ) {
	
					this._y = Math.atan2( m13, m33 );
					this._z = Math.atan2( m21, m22 );
	
				} else {
	
					this._y = Math.atan2( - m31, m11 );
					this._z = 0;
	
				}
	
			} else if ( order === 'ZXY' ) {
	
				this._x = Math.asin( clamp( m32, - 1, 1 ) );
	
				if ( Math.abs( m32 ) < 0.99999 ) {
	
					this._y = Math.atan2( - m31, m33 );
					this._z = Math.atan2( - m12, m22 );
	
				} else {
	
					this._y = 0;
					this._z = Math.atan2( m21, m11 );
	
				}
	
			} else if ( order === 'ZYX' ) {
	
				this._y = Math.asin( - clamp( m31, - 1, 1 ) );
	
				if ( Math.abs( m31 ) < 0.99999 ) {
	
					this._x = Math.atan2( m32, m33 );
					this._z = Math.atan2( m21, m11 );
	
				} else {
	
					this._x = 0;
					this._z = Math.atan2( - m12, m22 );
	
				}
	
			} else if ( order === 'YZX' ) {
	
				this._z = Math.asin( clamp( m21, - 1, 1 ) );
	
				if ( Math.abs( m21 ) < 0.99999 ) {
	
					this._x = Math.atan2( - m23, m22 );
					this._y = Math.atan2( - m31, m11 );
	
				} else {
	
					this._x = 0;
					this._y = Math.atan2( m13, m33 );
	
				}
	
			} else if ( order === 'XZY' ) {
	
				this._z = Math.asin( - clamp( m12, - 1, 1 ) );
	
				if ( Math.abs( m12 ) < 0.99999 ) {
	
					this._x = Math.atan2( m32, m22 );
					this._y = Math.atan2( m13, m11 );
	
				} else {
	
					this._x = Math.atan2( - m23, m33 );
					this._y = 0;
	
				}
	
			} else {
	
				console.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order )
	
			}
	
			this._order = order;
	
			if ( update !== false ) this.onChangeCallback();
	
			return this;
	
		},
	
		setFromQuaternion: function () {
	
			var matrix;
	
			return function ( q, order, update ) {
	
				if ( matrix === undefined ) matrix = new THREE.Matrix4();
				matrix.makeRotationFromQuaternion( q );
				this.setFromRotationMatrix( matrix, order, update );
	
				return this;
	
			};
	
		}(),
	
		setFromVector3: function ( v, order ) {
	
			return this.set( v.x, v.y, v.z, order || this._order );
	
		},
	
		reorder: function () {
	
			// WARNING: this discards revolution information -bhouston
	
			var q = new THREE.Quaternion();
	
			return function ( newOrder ) {
	
				q.setFromEuler( this );
				this.setFromQuaternion( q, newOrder );
	
			};
	
		}(),
	
		equals: function ( euler ) {
	
			return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );
	
		},
	
		fromArray: function ( array ) {
	
			this._x = array[ 0 ];
			this._y = array[ 1 ];
			this._z = array[ 2 ];
			if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		toArray: function ( array, offset ) {
	
			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;
	
			array[ offset ] = this._x;
			array[ offset + 1 ] = this._y;
			array[ offset + 2 ] = this._z;
			array[ offset + 3 ] = this._order;
	
			return array;
	
		},
	
		toVector3: function ( optionalResult ) {
	
			if ( optionalResult ) {
	
				return optionalResult.set( this._x, this._y, this._z );
	
			} else {
	
				return new THREE.Vector3( this._x, this._y, this._z );
	
			}
	
		},
	
		onChange: function ( callback ) {
	
			this.onChangeCallback = callback;
	
			return this;
	
		},
	
		onChangeCallback: function () {}
	
	};
	
	// File:src/math/Line3.js
	
	/**
	 * @author bhouston / http://clara.io
	 */
	
	THREE.Line3 = function ( start, end ) {
	
		this.start = ( start !== undefined ) ? start : new THREE.Vector3();
		this.end = ( end !== undefined ) ? end : new THREE.Vector3();
	
	};
	
	THREE.Line3.prototype = {
	
		constructor: THREE.Line3,
	
		set: function ( start, end ) {
	
			this.start.copy( start );
			this.end.copy( end );
	
			return this;
	
		},
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		},
	
		copy: function ( line ) {
	
			this.start.copy( line.start );
			this.end.copy( line.end );
	
			return this;
	
		},
	
		center: function ( optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
			return result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );
	
		},
	
		delta: function ( optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
			return result.subVectors( this.end, this.start );
	
		},
	
		distanceSq: function () {
	
			return this.start.distanceToSquared( this.end );
	
		},
	
		distance: function () {
	
			return this.start.distanceTo( this.end );
	
		},
	
		at: function ( t, optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
	
			return this.delta( result ).multiplyScalar( t ).add( this.start );
	
		},
	
		closestPointToPointParameter: function () {
	
			var startP = new THREE.Vector3();
			var startEnd = new THREE.Vector3();
	
			return function ( point, clampToLine ) {
	
				startP.subVectors( point, this.start );
				startEnd.subVectors( this.end, this.start );
	
				var startEnd2 = startEnd.dot( startEnd );
				var startEnd_startP = startEnd.dot( startP );
	
				var t = startEnd_startP / startEnd2;
	
				if ( clampToLine ) {
	
					t = THREE.Math.clamp( t, 0, 1 );
	
				}
	
				return t;
	
			};
	
		}(),
	
		closestPointToPoint: function ( point, clampToLine, optionalTarget ) {
	
			var t = this.closestPointToPointParameter( point, clampToLine );
	
			var result = optionalTarget || new THREE.Vector3();
	
			return this.delta( result ).multiplyScalar( t ).add( this.start );
	
		},
	
		applyMatrix4: function ( matrix ) {
	
			this.start.applyMatrix4( matrix );
			this.end.applyMatrix4( matrix );
	
			return this;
	
		},
	
		equals: function ( line ) {
	
			return line.start.equals( this.start ) && line.end.equals( this.end );
	
		}
	
	};
	
	// File:src/math/Box2.js
	
	/**
	 * @author bhouston / http://clara.io
	 */
	
	THREE.Box2 = function ( min, max ) {
	
		this.min = ( min !== undefined ) ? min : new THREE.Vector2( + Infinity, + Infinity );
		this.max = ( max !== undefined ) ? max : new THREE.Vector2( - Infinity, - Infinity );
	
	};
	
	THREE.Box2.prototype = {
	
		constructor: THREE.Box2,
	
		set: function ( min, max ) {
	
			this.min.copy( min );
			this.max.copy( max );
	
			return this;
	
		},
	
		setFromPoints: function ( points ) {
	
			this.makeEmpty();
	
			for ( var i = 0, il = points.length; i < il; i ++ ) {
	
				this.expandByPoint( points[ i ] );
	
			}
	
			return this;
	
		},
	
		setFromCenterAndSize: function () {
	
			var v1 = new THREE.Vector2();
	
			return function ( center, size ) {
	
				var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
				this.min.copy( center ).sub( halfSize );
				this.max.copy( center ).add( halfSize );
	
				return this;
	
			};
	
		}(),
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		},
	
		copy: function ( box ) {
	
			this.min.copy( box.min );
			this.max.copy( box.max );
	
			return this;
	
		},
	
		makeEmpty: function () {
	
			this.min.x = this.min.y = + Infinity;
			this.max.x = this.max.y = - Infinity;
	
			return this;
	
		},
	
		isEmpty: function () {
	
			// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
	
			return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );
	
		},
	
		center: function ( optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector2();
			return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );
	
		},
	
		size: function ( optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector2();
			return result.subVectors( this.max, this.min );
	
		},
	
		expandByPoint: function ( point ) {
	
			this.min.min( point );
			this.max.max( point );
	
			return this;
	
		},
	
		expandByVector: function ( vector ) {
	
			this.min.sub( vector );
			this.max.add( vector );
	
			return this;
	
		},
	
		expandByScalar: function ( scalar ) {
	
			this.min.addScalar( - scalar );
			this.max.addScalar( scalar );
	
			return this;
	
		},
	
		containsPoint: function ( point ) {
	
			if ( point.x < this.min.x || point.x > this.max.x ||
			     point.y < this.min.y || point.y > this.max.y ) {
	
				return false;
	
			}
	
			return true;
	
		},
	
		containsBox: function ( box ) {
	
			if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
			     ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {
	
				return true;
	
			}
	
			return false;
	
		},
	
		getParameter: function ( point, optionalTarget ) {
	
			// This can potentially have a divide by zero if the box
			// has a size dimension of 0.
	
			var result = optionalTarget || new THREE.Vector2();
	
			return result.set(
				( point.x - this.min.x ) / ( this.max.x - this.min.x ),
				( point.y - this.min.y ) / ( this.max.y - this.min.y )
			);
	
		},
	
		intersectsBox: function ( box ) {
	
			// using 6 splitting planes to rule out intersections.
	
			if ( box.max.x < this.min.x || box.min.x > this.max.x ||
			     box.max.y < this.min.y || box.min.y > this.max.y ) {
	
				return false;
	
			}
	
			return true;
	
		},
	
		clampPoint: function ( point, optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector2();
			return result.copy( point ).clamp( this.min, this.max );
	
		},
	
		distanceToPoint: function () {
	
			var v1 = new THREE.Vector2();
	
			return function ( point ) {
	
				var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
				return clampedPoint.sub( point ).length();
	
			};
	
		}(),
	
		intersect: function ( box ) {
	
			this.min.max( box.min );
			this.max.min( box.max );
	
			return this;
	
		},
	
		union: function ( box ) {
	
			this.min.min( box.min );
			this.max.max( box.max );
	
			return this;
	
		},
	
		translate: function ( offset ) {
	
			this.min.add( offset );
			this.max.add( offset );
	
			return this;
	
		},
	
		equals: function ( box ) {
	
			return box.min.equals( this.min ) && box.max.equals( this.max );
	
		}
	
	};
	
	// File:src/math/Box3.js
	
	/**
	 * @author bhouston / http://clara.io
	 * @author WestLangley / http://github.com/WestLangley
	 */
	
	THREE.Box3 = function ( min, max ) {
	
		this.min = ( min !== undefined ) ? min : new THREE.Vector3( + Infinity, + Infinity, + Infinity );
		this.max = ( max !== undefined ) ? max : new THREE.Vector3( - Infinity, - Infinity, - Infinity );
	
	};
	
	THREE.Box3.prototype = {
	
		constructor: THREE.Box3,
	
		set: function ( min, max ) {
	
			this.min.copy( min );
			this.max.copy( max );
	
			return this;
	
		},
	
		setFromArray: function ( array ) {
	
			this.makeEmpty();
	
			var minX = + Infinity;
			var minY = + Infinity;
			var minZ = + Infinity;
	
			var maxX = - Infinity;
			var maxY = - Infinity;
			var maxZ = - Infinity;
	
			for ( var i = 0, il = array.length; i < il; i += 3 ) {
	
				var x = array[ i ];
				var y = array[ i + 1 ];
				var z = array[ i + 2 ];
	
				if ( x < minX ) minX = x;
				if ( y < minY ) minY = y;
				if ( z < minZ ) minZ = z;
	
				if ( x > maxX ) maxX = x;
				if ( y > maxY ) maxY = y;
				if ( z > maxZ ) maxZ = z;
	
			}
	
			this.min.set( minX, minY, minZ );
			this.max.set( maxX, maxY, maxZ );
	
		},
	
		setFromPoints: function ( points ) {
	
			this.makeEmpty();
	
			for ( var i = 0, il = points.length; i < il; i ++ ) {
	
				this.expandByPoint( points[ i ] );
	
			}
	
			return this;
	
		},
	
		setFromCenterAndSize: function () {
	
			var v1 = new THREE.Vector3();
	
			return function ( center, size ) {
	
				var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
	
				this.min.copy( center ).sub( halfSize );
				this.max.copy( center ).add( halfSize );
	
				return this;
	
			};
	
		}(),
	
		setFromObject: function () {
	
			// Computes the world-axis-aligned bounding box of an object (including its children),
			// accounting for both the object's, and children's, world transforms
	
			var box;
	
			return function ( object ) {
	
				if ( box === undefined ) box = new THREE.Box3();
	
				var scope = this;
	
				this.makeEmpty();
	
				object.updateMatrixWorld( true );
	
				object.traverse( function ( node ) {
	
					var geometry = node.geometry;
	
					if ( geometry !== undefined ) {
	
						if ( geometry.boundingBox === null ) {
	
							geometry.computeBoundingBox();
	
						}
	
						box.copy( geometry.boundingBox );
						box.applyMatrix4( node.matrixWorld );
						scope.union( box );
	
					}
	
				} );
	
				return this;
	
			};
	
		}(),
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		},
	
		copy: function ( box ) {
	
			this.min.copy( box.min );
			this.max.copy( box.max );
	
			return this;
	
		},
	
		makeEmpty: function () {
	
			this.min.x = this.min.y = this.min.z = + Infinity;
			this.max.x = this.max.y = this.max.z = - Infinity;
	
			return this;
	
		},
	
		isEmpty: function () {
	
			// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
	
			return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );
	
		},
	
		center: function ( optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
			return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );
	
		},
	
		size: function ( optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
			return result.subVectors( this.max, this.min );
	
		},
	
		expandByPoint: function ( point ) {
	
			this.min.min( point );
			this.max.max( point );
	
			return this;
	
		},
	
		expandByVector: function ( vector ) {
	
			this.min.sub( vector );
			this.max.add( vector );
	
			return this;
	
		},
	
		expandByScalar: function ( scalar ) {
	
			this.min.addScalar( - scalar );
			this.max.addScalar( scalar );
	
			return this;
	
		},
	
		containsPoint: function ( point ) {
	
			if ( point.x < this.min.x || point.x > this.max.x ||
					 point.y < this.min.y || point.y > this.max.y ||
					 point.z < this.min.z || point.z > this.max.z ) {
	
				return false;
	
			}
	
			return true;
	
		},
	
		containsBox: function ( box ) {
	
			if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
				 ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&
				 ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {
	
				return true;
	
			}
	
			return false;
	
		},
	
		getParameter: function ( point, optionalTarget ) {
	
			// This can potentially have a divide by zero if the box
			// has a size dimension of 0.
	
			var result = optionalTarget || new THREE.Vector3();
	
			return result.set(
				( point.x - this.min.x ) / ( this.max.x - this.min.x ),
				( point.y - this.min.y ) / ( this.max.y - this.min.y ),
				( point.z - this.min.z ) / ( this.max.z - this.min.z )
			);
	
		},
	
		intersectsBox: function ( box ) {
	
			// using 6 splitting planes to rule out intersections.
	
			if ( box.max.x < this.min.x || box.min.x > this.max.x ||
					 box.max.y < this.min.y || box.min.y > this.max.y ||
					 box.max.z < this.min.z || box.min.z > this.max.z ) {
	
				return false;
	
			}
	
			return true;
	
		},
	
		intersectsSphere: ( function () {
	
			var closestPoint;
	
			return function intersectsSphere( sphere ) {
	
				if ( closestPoint === undefined ) closestPoint = new THREE.Vector3();
	
				// Find the point on the AABB closest to the sphere center.
				this.clampPoint( sphere.center, closestPoint );
	
				// If that point is inside the sphere, the AABB and sphere intersect.
				return closestPoint.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );
	
			};
	
		} )(),
	
		intersectsPlane: function ( plane ) {
	
			// We compute the minimum and maximum dot product values. If those values
			// are on the same side (back or front) of the plane, then there is no intersection.
	
			var min, max;
	
			if ( plane.normal.x > 0 ) {
	
				min = plane.normal.x * this.min.x;
				max = plane.normal.x * this.max.x;
	
			} else {
	
				min = plane.normal.x * this.max.x;
				max = plane.normal.x * this.min.x;
	
			}
	
			if ( plane.normal.y > 0 ) {
	
				min += plane.normal.y * this.min.y;
				max += plane.normal.y * this.max.y;
	
			} else {
	
				min += plane.normal.y * this.max.y;
				max += plane.normal.y * this.min.y;
	
			}
	
			if ( plane.normal.z > 0 ) {
	
				min += plane.normal.z * this.min.z;
				max += plane.normal.z * this.max.z;
	
			} else {
	
				min += plane.normal.z * this.max.z;
				max += plane.normal.z * this.min.z;
	
			}
	
			return ( min <= plane.constant && max >= plane.constant );
	
		},
	
		clampPoint: function ( point, optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
			return result.copy( point ).clamp( this.min, this.max );
	
		},
	
		distanceToPoint: function () {
	
			var v1 = new THREE.Vector3();
	
			return function ( point ) {
	
				var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
				return clampedPoint.sub( point ).length();
	
			};
	
		}(),
	
		getBoundingSphere: function () {
	
			var v1 = new THREE.Vector3();
	
			return function ( optionalTarget ) {
	
				var result = optionalTarget || new THREE.Sphere();
	
				result.center = this.center();
				result.radius = this.size( v1 ).length() * 0.5;
	
				return result;
	
			};
	
		}(),
	
		intersect: function ( box ) {
	
			this.min.max( box.min );
			this.max.min( box.max );
	
			return this;
	
		},
	
		union: function ( box ) {
	
			this.min.min( box.min );
			this.max.max( box.max );
	
			return this;
	
		},
	
		applyMatrix4: function () {
	
			var points = [
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3()
			];
	
			return function ( matrix ) {
	
				// NOTE: I am using a binary pattern to specify all 2^3 combinations below
				points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
				points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
				points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
				points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
				points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
				points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
				points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
				points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );	// 111
	
				this.makeEmpty();
				this.setFromPoints( points );
	
				return this;
	
			};
	
		}(),
	
		translate: function ( offset ) {
	
			this.min.add( offset );
			this.max.add( offset );
	
			return this;
	
		},
	
		equals: function ( box ) {
	
			return box.min.equals( this.min ) && box.max.equals( this.max );
	
		}
	
	};
	
	// File:src/math/Matrix3.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://clara.io
	 */
	
	THREE.Matrix3 = function () {
	
		this.elements = new Float32Array( [
	
			1, 0, 0,
			0, 1, 0,
			0, 0, 1
	
		] );
	
		if ( arguments.length > 0 ) {
	
			console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );
	
		}
	
	};
	
	THREE.Matrix3.prototype = {
	
		constructor: THREE.Matrix3,
	
		set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {
	
			var te = this.elements;
	
			te[ 0 ] = n11; te[ 3 ] = n12; te[ 6 ] = n13;
			te[ 1 ] = n21; te[ 4 ] = n22; te[ 7 ] = n23;
			te[ 2 ] = n31; te[ 5 ] = n32; te[ 8 ] = n33;
	
			return this;
	
		},
	
		identity: function () {
	
			this.set(
	
				1, 0, 0,
				0, 1, 0,
				0, 0, 1
	
			);
	
			return this;
	
		},
	
		clone: function () {
	
			return new this.constructor().fromArray( this.elements );
	
		},
	
		copy: function ( m ) {
	
			var me = m.elements;
	
			this.set(
	
				me[ 0 ], me[ 3 ], me[ 6 ],
				me[ 1 ], me[ 4 ], me[ 7 ],
				me[ 2 ], me[ 5 ], me[ 8 ]
	
			);
	
			return this;
	
		},
	
		applyToVector3Array: function () {
	
			var v1;
	
			return function ( array, offset, length ) {
	
				if ( v1 === undefined ) v1 = new THREE.Vector3();
				if ( offset === undefined ) offset = 0;
				if ( length === undefined ) length = array.length;
	
				for ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {
	
					v1.fromArray( array, j );
					v1.applyMatrix3( this );
					v1.toArray( array, j );
	
				}
	
				return array;
	
			};
	
		}(),
	
		applyToBuffer: function () {
	
			var v1;
	
			return function applyToBuffer( buffer, offset, length ) {
	
				if ( v1 === undefined ) v1 = new THREE.Vector3();
				if ( offset === undefined ) offset = 0;
				if ( length === undefined ) length = buffer.length / buffer.itemSize;
	
				for ( var i = 0, j = offset; i < length; i ++, j ++ ) {
	
					v1.x = buffer.getX( j );
					v1.y = buffer.getY( j );
					v1.z = buffer.getZ( j );
	
					v1.applyMatrix3( this );
	
					buffer.setXYZ( v1.x, v1.y, v1.z );
	
				}
	
				return buffer;
	
			};
	
		}(),
	
		multiplyScalar: function ( s ) {
	
			var te = this.elements;
	
			te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
			te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
			te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;
	
			return this;
	
		},
	
		determinant: function () {
	
			var te = this.elements;
	
			var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
				d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
				g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];
	
			return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
	
		},
	
		getInverse: function ( matrix, throwOnDegenerate ) {
	
			// input: THREE.Matrix4
			// ( based on http://code.google.com/p/webgl-mjs/ )
	
			var me = matrix.elements;
			var te = this.elements;
	
			te[ 0 ] =   me[ 10 ] * me[ 5 ] - me[ 6 ] * me[ 9 ];
			te[ 1 ] = - me[ 10 ] * me[ 1 ] + me[ 2 ] * me[ 9 ];
			te[ 2 ] =   me[ 6 ] * me[ 1 ] - me[ 2 ] * me[ 5 ];
			te[ 3 ] = - me[ 10 ] * me[ 4 ] + me[ 6 ] * me[ 8 ];
			te[ 4 ] =   me[ 10 ] * me[ 0 ] - me[ 2 ] * me[ 8 ];
			te[ 5 ] = - me[ 6 ] * me[ 0 ] + me[ 2 ] * me[ 4 ];
			te[ 6 ] =   me[ 9 ] * me[ 4 ] - me[ 5 ] * me[ 8 ];
			te[ 7 ] = - me[ 9 ] * me[ 0 ] + me[ 1 ] * me[ 8 ];
			te[ 8 ] =   me[ 5 ] * me[ 0 ] - me[ 1 ] * me[ 4 ];
	
			var det = me[ 0 ] * te[ 0 ] + me[ 1 ] * te[ 3 ] + me[ 2 ] * te[ 6 ];
	
			// no inverse
	
			if ( det === 0 ) {
	
				var msg = "THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0";
	
				if ( throwOnDegenerate || false ) {
	
					throw new Error( msg );
	
				} else {
	
					console.warn( msg );
	
				}
	
				this.identity();
	
				return this;
	
			}
	
			this.multiplyScalar( 1.0 / det );
	
			return this;
	
		},
	
		transpose: function () {
	
			var tmp, m = this.elements;
	
			tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
			tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
			tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;
	
			return this;
	
		},
	
		flattenToArrayOffset: function ( array, offset ) {
	
			var te = this.elements;
	
			array[ offset ] = te[ 0 ];
			array[ offset + 1 ] = te[ 1 ];
			array[ offset + 2 ] = te[ 2 ];
	
			array[ offset + 3 ] = te[ 3 ];
			array[ offset + 4 ] = te[ 4 ];
			array[ offset + 5 ] = te[ 5 ];
	
			array[ offset + 6 ] = te[ 6 ];
			array[ offset + 7 ] = te[ 7 ];
			array[ offset + 8 ]  = te[ 8 ];
	
			return array;
	
		},
	
		getNormalMatrix: function ( m ) {
	
			// input: THREE.Matrix4
	
			this.getInverse( m ).transpose();
	
			return this;
	
		},
	
		transposeIntoArray: function ( r ) {
	
			var m = this.elements;
	
			r[ 0 ] = m[ 0 ];
			r[ 1 ] = m[ 3 ];
			r[ 2 ] = m[ 6 ];
			r[ 3 ] = m[ 1 ];
			r[ 4 ] = m[ 4 ];
			r[ 5 ] = m[ 7 ];
			r[ 6 ] = m[ 2 ];
			r[ 7 ] = m[ 5 ];
			r[ 8 ] = m[ 8 ];
	
			return this;
	
		},
	
		fromArray: function ( array ) {
	
			this.elements.set( array );
	
			return this;
	
		},
	
		toArray: function () {
	
			var te = this.elements;
	
			return [
				te[ 0 ], te[ 1 ], te[ 2 ],
				te[ 3 ], te[ 4 ], te[ 5 ],
				te[ 6 ], te[ 7 ], te[ 8 ]
			];
	
		}
	
	};
	
	// File:src/math/Matrix4.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author philogb / http://blog.thejit.org/
	 * @author jordi_ros / http://plattsoft.com
	 * @author D1plo1d / http://github.com/D1plo1d
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author timknip / http://www.floorplanner.com/
	 * @author bhouston / http://clara.io
	 * @author WestLangley / http://github.com/WestLangley
	 */
	
	THREE.Matrix4 = function () {
	
		this.elements = new Float32Array( [
	
			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1
	
		] );
	
		if ( arguments.length > 0 ) {
	
			console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );
	
		}
	
	};
	
	THREE.Matrix4.prototype = {
	
		constructor: THREE.Matrix4,
	
		set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {
	
			var te = this.elements;
	
			te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
			te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
			te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
			te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;
	
			return this;
	
		},
	
		identity: function () {
	
			this.set(
	
				1, 0, 0, 0,
				0, 1, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1
	
			);
	
			return this;
	
		},
	
		clone: function () {
	
			return new THREE.Matrix4().fromArray( this.elements );
	
		},
	
		copy: function ( m ) {
	
			this.elements.set( m.elements );
	
			return this;
	
		},
	
		copyPosition: function ( m ) {
	
			var te = this.elements;
			var me = m.elements;
	
			te[ 12 ] = me[ 12 ];
			te[ 13 ] = me[ 13 ];
			te[ 14 ] = me[ 14 ];
	
			return this;
	
		},
	
		extractBasis: function ( xAxis, yAxis, zAxis ) {
	
			var te = this.elements;
	
			xAxis.set( te[ 0 ], te[ 1 ], te[ 2 ] );
			yAxis.set( te[ 4 ], te[ 5 ], te[ 6 ] );
			zAxis.set( te[ 8 ], te[ 9 ], te[ 10 ] );
	
			return this;
	
		},
	
		makeBasis: function ( xAxis, yAxis, zAxis ) {
	
			this.set(
				xAxis.x, yAxis.x, zAxis.x, 0,
				xAxis.y, yAxis.y, zAxis.y, 0,
				xAxis.z, yAxis.z, zAxis.z, 0,
				0,       0,       0,       1
			);
	
			return this;
	
		},
	
		extractRotation: function () {
	
			var v1;
	
			return function ( m ) {
	
				if ( v1 === undefined ) v1 = new THREE.Vector3();
	
				var te = this.elements;
				var me = m.elements;
	
				var scaleX = 1 / v1.set( me[ 0 ], me[ 1 ], me[ 2 ] ).length();
				var scaleY = 1 / v1.set( me[ 4 ], me[ 5 ], me[ 6 ] ).length();
				var scaleZ = 1 / v1.set( me[ 8 ], me[ 9 ], me[ 10 ] ).length();
	
				te[ 0 ] = me[ 0 ] * scaleX;
				te[ 1 ] = me[ 1 ] * scaleX;
				te[ 2 ] = me[ 2 ] * scaleX;
	
				te[ 4 ] = me[ 4 ] * scaleY;
				te[ 5 ] = me[ 5 ] * scaleY;
				te[ 6 ] = me[ 6 ] * scaleY;
	
				te[ 8 ] = me[ 8 ] * scaleZ;
				te[ 9 ] = me[ 9 ] * scaleZ;
				te[ 10 ] = me[ 10 ] * scaleZ;
	
				return this;
	
			};
	
		}(),
	
		makeRotationFromEuler: function ( euler ) {
	
			if ( euler instanceof THREE.Euler === false ) {
	
				console.error( 'THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );
	
			}
	
			var te = this.elements;
	
			var x = euler.x, y = euler.y, z = euler.z;
			var a = Math.cos( x ), b = Math.sin( x );
			var c = Math.cos( y ), d = Math.sin( y );
			var e = Math.cos( z ), f = Math.sin( z );
	
			if ( euler.order === 'XYZ' ) {
	
				var ae = a * e, af = a * f, be = b * e, bf = b * f;
	
				te[ 0 ] = c * e;
				te[ 4 ] = - c * f;
				te[ 8 ] = d;
	
				te[ 1 ] = af + be * d;
				te[ 5 ] = ae - bf * d;
				te[ 9 ] = - b * c;
	
				te[ 2 ] = bf - ae * d;
				te[ 6 ] = be + af * d;
				te[ 10 ] = a * c;
	
			} else if ( euler.order === 'YXZ' ) {
	
				var ce = c * e, cf = c * f, de = d * e, df = d * f;
	
				te[ 0 ] = ce + df * b;
				te[ 4 ] = de * b - cf;
				te[ 8 ] = a * d;
	
				te[ 1 ] = a * f;
				te[ 5 ] = a * e;
				te[ 9 ] = - b;
	
				te[ 2 ] = cf * b - de;
				te[ 6 ] = df + ce * b;
				te[ 10 ] = a * c;
	
			} else if ( euler.order === 'ZXY' ) {
	
				var ce = c * e, cf = c * f, de = d * e, df = d * f;
	
				te[ 0 ] = ce - df * b;
				te[ 4 ] = - a * f;
				te[ 8 ] = de + cf * b;
	
				te[ 1 ] = cf + de * b;
				te[ 5 ] = a * e;
				te[ 9 ] = df - ce * b;
	
				te[ 2 ] = - a * d;
				te[ 6 ] = b;
				te[ 10 ] = a * c;
	
			} else if ( euler.order === 'ZYX' ) {
	
				var ae = a * e, af = a * f, be = b * e, bf = b * f;
	
				te[ 0 ] = c * e;
				te[ 4 ] = be * d - af;
				te[ 8 ] = ae * d + bf;
	
				te[ 1 ] = c * f;
				te[ 5 ] = bf * d + ae;
				te[ 9 ] = af * d - be;
	
				te[ 2 ] = - d;
				te[ 6 ] = b * c;
				te[ 10 ] = a * c;
	
			} else if ( euler.order === 'YZX' ) {
	
				var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
	
				te[ 0 ] = c * e;
				te[ 4 ] = bd - ac * f;
				te[ 8 ] = bc * f + ad;
	
				te[ 1 ] = f;
				te[ 5 ] = a * e;
				te[ 9 ] = - b * e;
	
				te[ 2 ] = - d * e;
				te[ 6 ] = ad * f + bc;
				te[ 10 ] = ac - bd * f;
	
			} else if ( euler.order === 'XZY' ) {
	
				var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
	
				te[ 0 ] = c * e;
				te[ 4 ] = - f;
				te[ 8 ] = d * e;
	
				te[ 1 ] = ac * f + bd;
				te[ 5 ] = a * e;
				te[ 9 ] = ad * f - bc;
	
				te[ 2 ] = bc * f - ad;
				te[ 6 ] = b * e;
				te[ 10 ] = bd * f + ac;
	
			}
	
			// last column
			te[ 3 ] = 0;
			te[ 7 ] = 0;
			te[ 11 ] = 0;
	
			// bottom row
			te[ 12 ] = 0;
			te[ 13 ] = 0;
			te[ 14 ] = 0;
			te[ 15 ] = 1;
	
			return this;
	
		},
	
		makeRotationFromQuaternion: function ( q ) {
	
			var te = this.elements;
	
			var x = q.x, y = q.y, z = q.z, w = q.w;
			var x2 = x + x, y2 = y + y, z2 = z + z;
			var xx = x * x2, xy = x * y2, xz = x * z2;
			var yy = y * y2, yz = y * z2, zz = z * z2;
			var wx = w * x2, wy = w * y2, wz = w * z2;
	
			te[ 0 ] = 1 - ( yy + zz );
			te[ 4 ] = xy - wz;
			te[ 8 ] = xz + wy;
	
			te[ 1 ] = xy + wz;
			te[ 5 ] = 1 - ( xx + zz );
			te[ 9 ] = yz - wx;
	
			te[ 2 ] = xz - wy;
			te[ 6 ] = yz + wx;
			te[ 10 ] = 1 - ( xx + yy );
	
			// last column
			te[ 3 ] = 0;
			te[ 7 ] = 0;
			te[ 11 ] = 0;
	
			// bottom row
			te[ 12 ] = 0;
			te[ 13 ] = 0;
			te[ 14 ] = 0;
			te[ 15 ] = 1;
	
			return this;
	
		},
	
		lookAt: function () {
	
			var x, y, z;
	
			return function ( eye, target, up ) {
	
				if ( x === undefined ) x = new THREE.Vector3();
				if ( y === undefined ) y = new THREE.Vector3();
				if ( z === undefined ) z = new THREE.Vector3();
	
				var te = this.elements;
	
				z.subVectors( eye, target ).normalize();
	
				if ( z.lengthSq() === 0 ) {
	
					z.z = 1;
	
				}
	
				x.crossVectors( up, z ).normalize();
	
				if ( x.lengthSq() === 0 ) {
	
					z.x += 0.0001;
					x.crossVectors( up, z ).normalize();
	
				}
	
				y.crossVectors( z, x );
	
	
				te[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;
				te[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;
				te[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;
	
				return this;
	
			};
	
		}(),
	
		multiply: function ( m, n ) {
	
			if ( n !== undefined ) {
	
				console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
				return this.multiplyMatrices( m, n );
	
			}
	
			return this.multiplyMatrices( this, m );
	
		},
	
		multiplyMatrices: function ( a, b ) {
	
			var ae = a.elements;
			var be = b.elements;
			var te = this.elements;
	
			var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
			var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
			var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
			var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];
	
			var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
			var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
			var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
			var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];
	
			te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
			te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
			te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
			te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
	
			te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
			te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
			te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
			te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
	
			te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
			te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
			te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
			te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
	
			te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
			te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
			te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
			te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
	
			return this;
	
		},
	
		multiplyToArray: function ( a, b, r ) {
	
			var te = this.elements;
	
			this.multiplyMatrices( a, b );
	
			r[ 0 ] = te[ 0 ]; r[ 1 ] = te[ 1 ]; r[ 2 ] = te[ 2 ]; r[ 3 ] = te[ 3 ];
			r[ 4 ] = te[ 4 ]; r[ 5 ] = te[ 5 ]; r[ 6 ] = te[ 6 ]; r[ 7 ] = te[ 7 ];
			r[ 8 ]  = te[ 8 ]; r[ 9 ]  = te[ 9 ]; r[ 10 ] = te[ 10 ]; r[ 11 ] = te[ 11 ];
			r[ 12 ] = te[ 12 ]; r[ 13 ] = te[ 13 ]; r[ 14 ] = te[ 14 ]; r[ 15 ] = te[ 15 ];
	
			return this;
	
		},
	
		multiplyScalar: function ( s ) {
	
			var te = this.elements;
	
			te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
			te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
			te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
			te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;
	
			return this;
	
		},
	
		applyToVector3Array: function () {
	
			var v1;
	
			return function ( array, offset, length ) {
	
				if ( v1 === undefined ) v1 = new THREE.Vector3();
				if ( offset === undefined ) offset = 0;
				if ( length === undefined ) length = array.length;
	
				for ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {
	
					v1.fromArray( array, j );
					v1.applyMatrix4( this );
					v1.toArray( array, j );
	
				}
	
				return array;
	
			};
	
		}(),
	
		applyToBuffer: function () {
	
			var v1;
	
			return function applyToBuffer( buffer, offset, length ) {
	
				if ( v1 === undefined ) v1 = new THREE.Vector3();
				if ( offset === undefined ) offset = 0;
				if ( length === undefined ) length = buffer.length / buffer.itemSize;
	
				for ( var i = 0, j = offset; i < length; i ++, j ++ ) {
	
					v1.x = buffer.getX( j );
					v1.y = buffer.getY( j );
					v1.z = buffer.getZ( j );
	
					v1.applyMatrix4( this );
	
					buffer.setXYZ( v1.x, v1.y, v1.z );
	
				}
	
				return buffer;
	
			};
	
		}(),
	
		determinant: function () {
	
			var te = this.elements;
	
			var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
			var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
			var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
			var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];
	
			//TODO: make this more efficient
			//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )
	
			return (
				n41 * (
					+ n14 * n23 * n32
					 - n13 * n24 * n32
					 - n14 * n22 * n33
					 + n12 * n24 * n33
					 + n13 * n22 * n34
					 - n12 * n23 * n34
				) +
				n42 * (
					+ n11 * n23 * n34
					 - n11 * n24 * n33
					 + n14 * n21 * n33
					 - n13 * n21 * n34
					 + n13 * n24 * n31
					 - n14 * n23 * n31
				) +
				n43 * (
					+ n11 * n24 * n32
					 - n11 * n22 * n34
					 - n14 * n21 * n32
					 + n12 * n21 * n34
					 + n14 * n22 * n31
					 - n12 * n24 * n31
				) +
				n44 * (
					- n13 * n22 * n31
					 - n11 * n23 * n32
					 + n11 * n22 * n33
					 + n13 * n21 * n32
					 - n12 * n21 * n33
					 + n12 * n23 * n31
				)
	
			);
	
		},
	
		transpose: function () {
	
			var te = this.elements;
			var tmp;
	
			tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
			tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
			tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;
	
			tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
			tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
			tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;
	
			return this;
	
		},
	
		flattenToArrayOffset: function ( array, offset ) {
	
			var te = this.elements;
	
			array[ offset ] = te[ 0 ];
			array[ offset + 1 ] = te[ 1 ];
			array[ offset + 2 ] = te[ 2 ];
			array[ offset + 3 ] = te[ 3 ];
	
			array[ offset + 4 ] = te[ 4 ];
			array[ offset + 5 ] = te[ 5 ];
			array[ offset + 6 ] = te[ 6 ];
			array[ offset + 7 ] = te[ 7 ];
	
			array[ offset + 8 ]  = te[ 8 ];
			array[ offset + 9 ]  = te[ 9 ];
			array[ offset + 10 ] = te[ 10 ];
			array[ offset + 11 ] = te[ 11 ];
	
			array[ offset + 12 ] = te[ 12 ];
			array[ offset + 13 ] = te[ 13 ];
			array[ offset + 14 ] = te[ 14 ];
			array[ offset + 15 ] = te[ 15 ];
	
			return array;
	
		},
	
		getPosition: function () {
	
			var v1;
	
			return function () {
	
				if ( v1 === undefined ) v1 = new THREE.Vector3();
				console.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );
	
				var te = this.elements;
				return v1.set( te[ 12 ], te[ 13 ], te[ 14 ] );
	
			};
	
		}(),
	
		setPosition: function ( v ) {
	
			var te = this.elements;
	
			te[ 12 ] = v.x;
			te[ 13 ] = v.y;
			te[ 14 ] = v.z;
	
			return this;
	
		},
	
		getInverse: function ( m, throwOnInvertible ) {
	
			// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
			var te = this.elements;
			var me = m.elements;
	
			var n11 = me[ 0 ], n12 = me[ 4 ], n13 = me[ 8 ], n14 = me[ 12 ];
			var n21 = me[ 1 ], n22 = me[ 5 ], n23 = me[ 9 ], n24 = me[ 13 ];
			var n31 = me[ 2 ], n32 = me[ 6 ], n33 = me[ 10 ], n34 = me[ 14 ];
			var n41 = me[ 3 ], n42 = me[ 7 ], n43 = me[ 11 ], n44 = me[ 15 ];
	
			te[ 0 ] = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44;
			te[ 4 ] = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44;
			te[ 8 ] = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44;
			te[ 12 ] = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
			te[ 1 ] = n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44;
			te[ 5 ] = n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44;
			te[ 9 ] = n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44;
			te[ 13 ] = n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34;
			te[ 2 ] = n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44;
			te[ 6 ] = n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44;
			te[ 10 ] = n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44;
			te[ 14 ] = n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34;
			te[ 3 ] = n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43;
			te[ 7 ] = n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43;
			te[ 11 ] = n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43;
			te[ 15 ] = n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33;
	
			var det = n11 * te[ 0 ] + n21 * te[ 4 ] + n31 * te[ 8 ] + n41 * te[ 12 ];
	
			if ( det === 0 ) {
	
				var msg = "THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0";
	
				if ( throwOnInvertible || false ) {
	
					throw new Error( msg );
	
				} else {
	
					console.warn( msg );
	
				}
	
				this.identity();
	
				return this;
	
			}
	
			this.multiplyScalar( 1 / det );
	
			return this;
	
		},
	
		scale: function ( v ) {
	
			var te = this.elements;
			var x = v.x, y = v.y, z = v.z;
	
			te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
			te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
			te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
			te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;
	
			return this;
	
		},
	
		getMaxScaleOnAxis: function () {
	
			var te = this.elements;
	
			var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
			var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
			var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];
	
			return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );
	
		},
	
		makeTranslation: function ( x, y, z ) {
	
			this.set(
	
				1, 0, 0, x,
				0, 1, 0, y,
				0, 0, 1, z,
				0, 0, 0, 1
	
			);
	
			return this;
	
		},
	
		makeRotationX: function ( theta ) {
	
			var c = Math.cos( theta ), s = Math.sin( theta );
	
			this.set(
	
				1, 0,  0, 0,
				0, c, - s, 0,
				0, s,  c, 0,
				0, 0,  0, 1
	
			);
	
			return this;
	
		},
	
		makeRotationY: function ( theta ) {
	
			var c = Math.cos( theta ), s = Math.sin( theta );
	
			this.set(
	
				 c, 0, s, 0,
				 0, 1, 0, 0,
				- s, 0, c, 0,
				 0, 0, 0, 1
	
			);
	
			return this;
	
		},
	
		makeRotationZ: function ( theta ) {
	
			var c = Math.cos( theta ), s = Math.sin( theta );
	
			this.set(
	
				c, - s, 0, 0,
				s,  c, 0, 0,
				0,  0, 1, 0,
				0,  0, 0, 1
	
			);
	
			return this;
	
		},
	
		makeRotationAxis: function ( axis, angle ) {
	
			// Based on http://www.gamedev.net/reference/articles/article1199.asp
	
			var c = Math.cos( angle );
			var s = Math.sin( angle );
			var t = 1 - c;
			var x = axis.x, y = axis.y, z = axis.z;
			var tx = t * x, ty = t * y;
	
			this.set(
	
				tx * x + c, tx * y - s * z, tx * z + s * y, 0,
				tx * y + s * z, ty * y + c, ty * z - s * x, 0,
				tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
				0, 0, 0, 1
	
			);
	
			 return this;
	
		},
	
		makeScale: function ( x, y, z ) {
	
			this.set(
	
				x, 0, 0, 0,
				0, y, 0, 0,
				0, 0, z, 0,
				0, 0, 0, 1
	
			);
	
			return this;
	
		},
	
		compose: function ( position, quaternion, scale ) {
	
			this.makeRotationFromQuaternion( quaternion );
			this.scale( scale );
			this.setPosition( position );
	
			return this;
	
		},
	
		decompose: function () {
	
			var vector, matrix;
	
			return function ( position, quaternion, scale ) {
	
				if ( vector === undefined ) vector = new THREE.Vector3();
				if ( matrix === undefined ) matrix = new THREE.Matrix4();
	
				var te = this.elements;
	
				var sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
				var sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
				var sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();
	
				// if determine is negative, we need to invert one scale
				var det = this.determinant();
				if ( det < 0 ) {
	
					sx = - sx;
	
				}
	
				position.x = te[ 12 ];
				position.y = te[ 13 ];
				position.z = te[ 14 ];
	
				// scale the rotation part
	
				matrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()
	
				var invSX = 1 / sx;
				var invSY = 1 / sy;
				var invSZ = 1 / sz;
	
				matrix.elements[ 0 ] *= invSX;
				matrix.elements[ 1 ] *= invSX;
				matrix.elements[ 2 ] *= invSX;
	
				matrix.elements[ 4 ] *= invSY;
				matrix.elements[ 5 ] *= invSY;
				matrix.elements[ 6 ] *= invSY;
	
				matrix.elements[ 8 ] *= invSZ;
				matrix.elements[ 9 ] *= invSZ;
				matrix.elements[ 10 ] *= invSZ;
	
				quaternion.setFromRotationMatrix( matrix );
	
				scale.x = sx;
				scale.y = sy;
				scale.z = sz;
	
				return this;
	
			};
	
		}(),
	
		makeFrustum: function ( left, right, bottom, top, near, far ) {
	
			var te = this.elements;
			var x = 2 * near / ( right - left );
			var y = 2 * near / ( top - bottom );
	
			var a = ( right + left ) / ( right - left );
			var b = ( top + bottom ) / ( top - bottom );
			var c = - ( far + near ) / ( far - near );
			var d = - 2 * far * near / ( far - near );
	
			te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
			te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
			te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
			te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;
	
			return this;
	
		},
	
		makePerspective: function ( fov, aspect, near, far ) {
	
			var ymax = near * Math.tan( THREE.Math.degToRad( fov * 0.5 ) );
			var ymin = - ymax;
			var xmin = ymin * aspect;
			var xmax = ymax * aspect;
	
			return this.makeFrustum( xmin, xmax, ymin, ymax, near, far );
	
		},
	
		makeOrthographic: function ( left, right, top, bottom, near, far ) {
	
			var te = this.elements;
			var w = right - left;
			var h = top - bottom;
			var p = far - near;
	
			var x = ( right + left ) / w;
			var y = ( top + bottom ) / h;
			var z = ( far + near ) / p;
	
			te[ 0 ] = 2 / w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
			te[ 1 ] = 0;	te[ 5 ] = 2 / h;	te[ 9 ] = 0;	te[ 13 ] = - y;
			te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 / p;	te[ 14 ] = - z;
			te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;
	
			return this;
	
		},
	
		equals: function ( matrix ) {
	
			var te = this.elements;
			var me = matrix.elements;
	
			for ( var i = 0; i < 16; i ++ ) {
	
				if ( te[ i ] !== me[ i ] ) return false;
	
			}
	
			return true;
	
		},
	
		fromArray: function ( array ) {
	
			this.elements.set( array );
	
			return this;
	
		},
	
		toArray: function () {
	
			var te = this.elements;
	
			return [
				te[ 0 ], te[ 1 ], te[ 2 ], te[ 3 ],
				te[ 4 ], te[ 5 ], te[ 6 ], te[ 7 ],
				te[ 8 ], te[ 9 ], te[ 10 ], te[ 11 ],
				te[ 12 ], te[ 13 ], te[ 14 ], te[ 15 ]
			];
	
		}
	
	};
	
	// File:src/math/Ray.js
	
	/**
	 * @author bhouston / http://clara.io
	 */
	
	THREE.Ray = function ( origin, direction ) {
	
		this.origin = ( origin !== undefined ) ? origin : new THREE.Vector3();
		this.direction = ( direction !== undefined ) ? direction : new THREE.Vector3();
	
	};
	
	THREE.Ray.prototype = {
	
		constructor: THREE.Ray,
	
		set: function ( origin, direction ) {
	
			this.origin.copy( origin );
			this.direction.copy( direction );
	
			return this;
	
		},
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		},
	
		copy: function ( ray ) {
	
			this.origin.copy( ray.origin );
			this.direction.copy( ray.direction );
	
			return this;
	
		},
	
		at: function ( t, optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
	
			return result.copy( this.direction ).multiplyScalar( t ).add( this.origin );
	
		},
	
		lookAt: function ( v ) {
	
			this.direction.copy( v ).sub( this.origin ).normalize();
	
		},
	
		recast: function () {
	
			var v1 = new THREE.Vector3();
	
			return function ( t ) {
	
				this.origin.copy( this.at( t, v1 ) );
	
				return this;
	
			};
	
		}(),
	
		closestPointToPoint: function ( point, optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
			result.subVectors( point, this.origin );
			var directionDistance = result.dot( this.direction );
	
			if ( directionDistance < 0 ) {
	
				return result.copy( this.origin );
	
			}
	
			return result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );
	
		},
	
		distanceToPoint: function ( point ) {
	
			return Math.sqrt( this.distanceSqToPoint( point ) );
	
		},
	
		distanceSqToPoint: function () {
	
			var v1 = new THREE.Vector3();
	
			return function ( point ) {
	
				var directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );
	
				// point behind the ray
	
				if ( directionDistance < 0 ) {
	
					return this.origin.distanceToSquared( point );
	
				}
	
				v1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );
	
				return v1.distanceToSquared( point );
	
			};
	
		}(),
	
		distanceSqToSegment: function () {
	
			var segCenter = new THREE.Vector3();
			var segDir = new THREE.Vector3();
			var diff = new THREE.Vector3();
	
			return function ( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {
	
				// from http://www.geometrictools.com/LibMathematics/Distance/Wm5DistRay3Segment3.cpp
				// It returns the min distance between the ray and the segment
				// defined by v0 and v1
				// It can also set two optional targets :
				// - The closest point on the ray
				// - The closest point on the segment
	
				segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
				segDir.copy( v1 ).sub( v0 ).normalize();
				diff.copy( this.origin ).sub( segCenter );
	
				var segExtent = v0.distanceTo( v1 ) * 0.5;
				var a01 = - this.direction.dot( segDir );
				var b0 = diff.dot( this.direction );
				var b1 = - diff.dot( segDir );
				var c = diff.lengthSq();
				var det = Math.abs( 1 - a01 * a01 );
				var s0, s1, sqrDist, extDet;
	
				if ( det > 0 ) {
	
					// The ray and segment are not parallel.
	
					s0 = a01 * b1 - b0;
					s1 = a01 * b0 - b1;
					extDet = segExtent * det;
	
					if ( s0 >= 0 ) {
	
						if ( s1 >= - extDet ) {
	
							if ( s1 <= extDet ) {
	
								// region 0
								// Minimum at interior points of ray and segment.
	
								var invDet = 1 / det;
								s0 *= invDet;
								s1 *= invDet;
								sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;
	
							} else {
	
								// region 1
	
								s1 = segExtent;
								s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
								sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;
	
							}
	
						} else {
	
							// region 5
	
							s1 = - segExtent;
							s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;
	
						}
	
					} else {
	
						if ( s1 <= - extDet ) {
	
							// region 4
	
							s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
							s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;
	
						} else if ( s1 <= extDet ) {
	
							// region 3
	
							s0 = 0;
							s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
							sqrDist = s1 * ( s1 + 2 * b1 ) + c;
	
						} else {
	
							// region 2
	
							s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
							s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;
	
						}
	
					}
	
				} else {
	
					// Ray and segment are parallel.
	
					s1 = ( a01 > 0 ) ? - segExtent : segExtent;
					s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;
	
				}
	
				if ( optionalPointOnRay ) {
	
					optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );
	
				}
	
				if ( optionalPointOnSegment ) {
	
					optionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );
	
				}
	
				return sqrDist;
	
			};
	
		}(),
	
		intersectSphere: function () {
	
			var v1 = new THREE.Vector3();
	
			return function ( sphere, optionalTarget ) {
	
				v1.subVectors( sphere.center, this.origin );
				var tca = v1.dot( this.direction );
				var d2 = v1.dot( v1 ) - tca * tca;
				var radius2 = sphere.radius * sphere.radius;
	
				if ( d2 > radius2 ) return null;
	
				var thc = Math.sqrt( radius2 - d2 );
	
				// t0 = first intersect point - entrance on front of sphere
				var t0 = tca - thc;
	
				// t1 = second intersect point - exit point on back of sphere
				var t1 = tca + thc;
	
				// test to see if both t0 and t1 are behind the ray - if so, return null
				if ( t0 < 0 && t1 < 0 ) return null;
	
				// test to see if t0 is behind the ray:
				// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
				// in order to always return an intersect point that is in front of the ray.
				if ( t0 < 0 ) return this.at( t1, optionalTarget );
	
				// else t0 is in front of the ray, so return the first collision point scaled by t0
				return this.at( t0, optionalTarget );
	
			}
	
		}(),
	
		intersectsSphere: function ( sphere ) {
	
			return this.distanceToPoint( sphere.center ) <= sphere.radius;
	
		},
	
		distanceToPlane: function ( plane ) {
	
			var denominator = plane.normal.dot( this.direction );
	
			if ( denominator === 0 ) {
	
				// line is coplanar, return origin
				if ( plane.distanceToPoint( this.origin ) === 0 ) {
	
					return 0;
	
				}
	
				// Null is preferable to undefined since undefined means.... it is undefined
	
				return null;
	
			}
	
			var t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;
	
			// Return if the ray never intersects the plane
	
			return t >= 0 ? t :  null;
	
		},
	
		intersectPlane: function ( plane, optionalTarget ) {
	
			var t = this.distanceToPlane( plane );
	
			if ( t === null ) {
	
				return null;
	
			}
	
			return this.at( t, optionalTarget );
	
		},
	
	
	
		intersectsPlane: function ( plane ) {
	
			// check if the ray lies on the plane first
	
			var distToPoint = plane.distanceToPoint( this.origin );
	
			if ( distToPoint === 0 ) {
	
				return true;
	
			}
	
			var denominator = plane.normal.dot( this.direction );
	
			if ( denominator * distToPoint < 0 ) {
	
				return true;
	
			}
	
			// ray origin is behind the plane (and is pointing behind it)
	
			return false;
	
		},
	
		intersectBox: function ( box, optionalTarget ) {
	
			var tmin, tmax, tymin, tymax, tzmin, tzmax;
	
			var invdirx = 1 / this.direction.x,
				invdiry = 1 / this.direction.y,
				invdirz = 1 / this.direction.z;
	
			var origin = this.origin;
	
			if ( invdirx >= 0 ) {
	
				tmin = ( box.min.x - origin.x ) * invdirx;
				tmax = ( box.max.x - origin.x ) * invdirx;
	
			} else {
	
				tmin = ( box.max.x - origin.x ) * invdirx;
				tmax = ( box.min.x - origin.x ) * invdirx;
	
			}
	
			if ( invdiry >= 0 ) {
	
				tymin = ( box.min.y - origin.y ) * invdiry;
				tymax = ( box.max.y - origin.y ) * invdiry;
	
			} else {
	
				tymin = ( box.max.y - origin.y ) * invdiry;
				tymax = ( box.min.y - origin.y ) * invdiry;
	
			}
	
			if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;
	
			// These lines also handle the case where tmin or tmax is NaN
			// (result of 0 * Infinity). x !== x returns true if x is NaN
	
			if ( tymin > tmin || tmin !== tmin ) tmin = tymin;
	
			if ( tymax < tmax || tmax !== tmax ) tmax = tymax;
	
			if ( invdirz >= 0 ) {
	
				tzmin = ( box.min.z - origin.z ) * invdirz;
				tzmax = ( box.max.z - origin.z ) * invdirz;
	
			} else {
	
				tzmin = ( box.max.z - origin.z ) * invdirz;
				tzmax = ( box.min.z - origin.z ) * invdirz;
	
			}
	
			if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;
	
			if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;
	
			if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;
	
			//return point closest to the ray (positive side)
	
			if ( tmax < 0 ) return null;
	
			return this.at( tmin >= 0 ? tmin : tmax, optionalTarget );
	
		},
	
		intersectsBox: ( function () {
	
			var v = new THREE.Vector3();
	
			return function ( box ) {
	
				return this.intersectBox( box, v ) !== null;
	
			};
	
		} )(),
	
		intersectTriangle: function () {
	
			// Compute the offset origin, edges, and normal.
			var diff = new THREE.Vector3();
			var edge1 = new THREE.Vector3();
			var edge2 = new THREE.Vector3();
			var normal = new THREE.Vector3();
	
			return function ( a, b, c, backfaceCulling, optionalTarget ) {
	
				// from http://www.geometrictools.com/LibMathematics/Intersection/Wm5IntrRay3Triangle3.cpp
	
				edge1.subVectors( b, a );
				edge2.subVectors( c, a );
				normal.crossVectors( edge1, edge2 );
	
				// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
				// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
				//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
				//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
				//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
				var DdN = this.direction.dot( normal );
				var sign;
	
				if ( DdN > 0 ) {
	
					if ( backfaceCulling ) return null;
					sign = 1;
	
				} else if ( DdN < 0 ) {
	
					sign = - 1;
					DdN = - DdN;
	
				} else {
	
					return null;
	
				}
	
				diff.subVectors( this.origin, a );
				var DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );
	
				// b1 < 0, no intersection
				if ( DdQxE2 < 0 ) {
	
					return null;
	
				}
	
				var DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );
	
				// b2 < 0, no intersection
				if ( DdE1xQ < 0 ) {
	
					return null;
	
				}
	
				// b1+b2 > 1, no intersection
				if ( DdQxE2 + DdE1xQ > DdN ) {
	
					return null;
	
				}
	
				// Line intersects triangle, check if ray does.
				var QdN = - sign * diff.dot( normal );
	
				// t < 0, no intersection
				if ( QdN < 0 ) {
	
					return null;
	
				}
	
				// Ray intersects triangle.
				return this.at( QdN / DdN, optionalTarget );
	
			};
	
		}(),
	
		applyMatrix4: function ( matrix4 ) {
	
			this.direction.add( this.origin ).applyMatrix4( matrix4 );
			this.origin.applyMatrix4( matrix4 );
			this.direction.sub( this.origin );
			this.direction.normalize();
	
			return this;
	
		},
	
		equals: function ( ray ) {
	
			return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );
	
		}
	
	};
	
	// File:src/math/Sphere.js
	
	/**
	 * @author bhouston / http://clara.io
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.Sphere = function ( center, radius ) {
	
		this.center = ( center !== undefined ) ? center : new THREE.Vector3();
		this.radius = ( radius !== undefined ) ? radius : 0;
	
	};
	
	THREE.Sphere.prototype = {
	
		constructor: THREE.Sphere,
	
		set: function ( center, radius ) {
	
			this.center.copy( center );
			this.radius = radius;
	
			return this;
	
		},
	
		setFromPoints: function () {
	
			var box = new THREE.Box3();
	
			return function ( points, optionalCenter ) {
	
				var center = this.center;
	
				if ( optionalCenter !== undefined ) {
	
					center.copy( optionalCenter );
	
				} else {
	
					box.setFromPoints( points ).center( center );
	
				}
	
				var maxRadiusSq = 0;
	
				for ( var i = 0, il = points.length; i < il; i ++ ) {
	
					maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );
	
				}
	
				this.radius = Math.sqrt( maxRadiusSq );
	
				return this;
	
			};
	
		}(),
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		},
	
		copy: function ( sphere ) {
	
			this.center.copy( sphere.center );
			this.radius = sphere.radius;
	
			return this;
	
		},
	
		empty: function () {
	
			return ( this.radius <= 0 );
	
		},
	
		containsPoint: function ( point ) {
	
			return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );
	
		},
	
		distanceToPoint: function ( point ) {
	
			return ( point.distanceTo( this.center ) - this.radius );
	
		},
	
		intersectsSphere: function ( sphere ) {
	
			var radiusSum = this.radius + sphere.radius;
	
			return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );
	
		},
	
		intersectsBox: function ( box ) {
	
			return box.intersectsSphere( this );
	
		},
	
		intersectsPlane: function ( plane ) {
	
			// We use the following equation to compute the signed distance from
			// the center of the sphere to the plane.
			//
			// distance = q * n - d
			//
			// If this distance is greater than the radius of the sphere,
			// then there is no intersection.
	
			return Math.abs( this.center.dot( plane.normal ) - plane.constant ) <= this.radius;
	
		},
	
		clampPoint: function ( point, optionalTarget ) {
	
			var deltaLengthSq = this.center.distanceToSquared( point );
	
			var result = optionalTarget || new THREE.Vector3();
	
			result.copy( point );
	
			if ( deltaLengthSq > ( this.radius * this.radius ) ) {
	
				result.sub( this.center ).normalize();
				result.multiplyScalar( this.radius ).add( this.center );
	
			}
	
			return result;
	
		},
	
		getBoundingBox: function ( optionalTarget ) {
	
			var box = optionalTarget || new THREE.Box3();
	
			box.set( this.center, this.center );
			box.expandByScalar( this.radius );
	
			return box;
	
		},
	
		applyMatrix4: function ( matrix ) {
	
			this.center.applyMatrix4( matrix );
			this.radius = this.radius * matrix.getMaxScaleOnAxis();
	
			return this;
	
		},
	
		translate: function ( offset ) {
	
			this.center.add( offset );
	
			return this;
	
		},
	
		equals: function ( sphere ) {
	
			return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );
	
		}
	
	};
	
	// File:src/math/Frustum.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author bhouston / http://clara.io
	 */
	
	THREE.Frustum = function ( p0, p1, p2, p3, p4, p5 ) {
	
		this.planes = [
	
			( p0 !== undefined ) ? p0 : new THREE.Plane(),
			( p1 !== undefined ) ? p1 : new THREE.Plane(),
			( p2 !== undefined ) ? p2 : new THREE.Plane(),
			( p3 !== undefined ) ? p3 : new THREE.Plane(),
			( p4 !== undefined ) ? p4 : new THREE.Plane(),
			( p5 !== undefined ) ? p5 : new THREE.Plane()
	
		];
	
	};
	
	THREE.Frustum.prototype = {
	
		constructor: THREE.Frustum,
	
		set: function ( p0, p1, p2, p3, p4, p5 ) {
	
			var planes = this.planes;
	
			planes[ 0 ].copy( p0 );
			planes[ 1 ].copy( p1 );
			planes[ 2 ].copy( p2 );
			planes[ 3 ].copy( p3 );
			planes[ 4 ].copy( p4 );
			planes[ 5 ].copy( p5 );
	
			return this;
	
		},
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		},
	
		copy: function ( frustum ) {
	
			var planes = this.planes;
	
			for ( var i = 0; i < 6; i ++ ) {
	
				planes[ i ].copy( frustum.planes[ i ] );
	
			}
	
			return this;
	
		},
	
		setFromMatrix: function ( m ) {
	
			var planes = this.planes;
			var me = m.elements;
			var me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
			var me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
			var me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
			var me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];
	
			planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
			planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
			planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
			planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
			planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
			planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();
	
			return this;
	
		},
	
		intersectsObject: function () {
	
			var sphere = new THREE.Sphere();
	
			return function ( object ) {
	
				var geometry = object.geometry;
	
				if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();
	
				sphere.copy( geometry.boundingSphere );
				sphere.applyMatrix4( object.matrixWorld );
	
				return this.intersectsSphere( sphere );
	
			};
	
		}(),
	
		intersectsSphere: function ( sphere ) {
	
			var planes = this.planes;
			var center = sphere.center;
			var negRadius = - sphere.radius;
	
			for ( var i = 0; i < 6; i ++ ) {
	
				var distance = planes[ i ].distanceToPoint( center );
	
				if ( distance < negRadius ) {
	
					return false;
	
				}
	
			}
	
			return true;
	
		},
	
		intersectsBox: function () {
	
			var p1 = new THREE.Vector3(),
				p2 = new THREE.Vector3();
	
			return function ( box ) {
	
				var planes = this.planes;
	
				for ( var i = 0; i < 6 ; i ++ ) {
	
					var plane = planes[ i ];
	
					p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
					p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
					p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
					p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
					p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
					p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;
	
					var d1 = plane.distanceToPoint( p1 );
					var d2 = plane.distanceToPoint( p2 );
	
					// if both outside plane, no intersection
	
					if ( d1 < 0 && d2 < 0 ) {
	
						return false;
	
					}
	
				}
	
				return true;
	
			};
	
		}(),
	
	
		containsPoint: function ( point ) {
	
			var planes = this.planes;
	
			for ( var i = 0; i < 6; i ++ ) {
	
				if ( planes[ i ].distanceToPoint( point ) < 0 ) {
	
					return false;
	
				}
	
			}
	
			return true;
	
		}
	
	};
	
	// File:src/math/Plane.js
	
	/**
	 * @author bhouston / http://clara.io
	 */
	
	THREE.Plane = function ( normal, constant ) {
	
		this.normal = ( normal !== undefined ) ? normal : new THREE.Vector3( 1, 0, 0 );
		this.constant = ( constant !== undefined ) ? constant : 0;
	
	};
	
	THREE.Plane.prototype = {
	
		constructor: THREE.Plane,
	
		set: function ( normal, constant ) {
	
			this.normal.copy( normal );
			this.constant = constant;
	
			return this;
	
		},
	
		setComponents: function ( x, y, z, w ) {
	
			this.normal.set( x, y, z );
			this.constant = w;
	
			return this;
	
		},
	
		setFromNormalAndCoplanarPoint: function ( normal, point ) {
	
			this.normal.copy( normal );
			this.constant = - point.dot( this.normal );	// must be this.normal, not normal, as this.normal is normalized
	
			return this;
	
		},
	
		setFromCoplanarPoints: function () {
	
			var v1 = new THREE.Vector3();
			var v2 = new THREE.Vector3();
	
			return function ( a, b, c ) {
	
				var normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();
	
				// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?
	
				this.setFromNormalAndCoplanarPoint( normal, a );
	
				return this;
	
			};
	
		}(),
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		},
	
		copy: function ( plane ) {
	
			this.normal.copy( plane.normal );
			this.constant = plane.constant;
	
			return this;
	
		},
	
		normalize: function () {
	
			// Note: will lead to a divide by zero if the plane is invalid.
	
			var inverseNormalLength = 1.0 / this.normal.length();
			this.normal.multiplyScalar( inverseNormalLength );
			this.constant *= inverseNormalLength;
	
			return this;
	
		},
	
		negate: function () {
	
			this.constant *= - 1;
			this.normal.negate();
	
			return this;
	
		},
	
		distanceToPoint: function ( point ) {
	
			return this.normal.dot( point ) + this.constant;
	
		},
	
		distanceToSphere: function ( sphere ) {
	
			return this.distanceToPoint( sphere.center ) - sphere.radius;
	
		},
	
		projectPoint: function ( point, optionalTarget ) {
	
			return this.orthoPoint( point, optionalTarget ).sub( point ).negate();
	
		},
	
		orthoPoint: function ( point, optionalTarget ) {
	
			var perpendicularMagnitude = this.distanceToPoint( point );
	
			var result = optionalTarget || new THREE.Vector3();
			return result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );
	
		},
	
		intersectLine: function () {
	
			var v1 = new THREE.Vector3();
	
			return function ( line, optionalTarget ) {
	
				var result = optionalTarget || new THREE.Vector3();
	
				var direction = line.delta( v1 );
	
				var denominator = this.normal.dot( direction );
	
				if ( denominator === 0 ) {
	
					// line is coplanar, return origin
					if ( this.distanceToPoint( line.start ) === 0 ) {
	
						return result.copy( line.start );
	
					}
	
					// Unsure if this is the correct method to handle this case.
					return undefined;
	
				}
	
				var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;
	
				if ( t < 0 || t > 1 ) {
	
					return undefined;
	
				}
	
				return result.copy( direction ).multiplyScalar( t ).add( line.start );
	
			};
	
		}(),
	
		intersectsLine: function ( line ) {
	
			// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.
	
			var startSign = this.distanceToPoint( line.start );
			var endSign = this.distanceToPoint( line.end );
	
			return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );
	
		},
	
		intersectsBox: function ( box ) {
	
			return box.intersectsPlane( this );
	
		},
	
		intersectsSphere: function ( sphere ) {
	
			return sphere.intersectsPlane( this );
	
		},
	
		coplanarPoint: function ( optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
			return result.copy( this.normal ).multiplyScalar( - this.constant );
	
		},
	
		applyMatrix4: function () {
	
			var v1 = new THREE.Vector3();
			var v2 = new THREE.Vector3();
			var m1 = new THREE.Matrix3();
	
			return function ( matrix, optionalNormalMatrix ) {
	
				// compute new normal based on theory here:
				// http://www.songho.ca/opengl/gl_normaltransform.html
				var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );
				var newNormal = v1.copy( this.normal ).applyMatrix3( normalMatrix );
	
				var newCoplanarPoint = this.coplanarPoint( v2 );
				newCoplanarPoint.applyMatrix4( matrix );
	
				this.setFromNormalAndCoplanarPoint( newNormal, newCoplanarPoint );
	
				return this;
	
			};
	
		}(),
	
		translate: function ( offset ) {
	
			this.constant = this.constant - offset.dot( this.normal );
	
			return this;
	
		},
	
		equals: function ( plane ) {
	
			return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );
	
		}
	
	};
	
	// File:src/math/Math.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.Math = {
	
		generateUUID: function () {
	
			// http://www.broofa.com/Tools/Math.uuid.htm
	
			var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );
			var uuid = new Array( 36 );
			var rnd = 0, r;
	
			return function () {
	
				for ( var i = 0; i < 36; i ++ ) {
	
					if ( i === 8 || i === 13 || i === 18 || i === 23 ) {
	
						uuid[ i ] = '-';
	
					} else if ( i === 14 ) {
	
						uuid[ i ] = '4';
	
					} else {
	
						if ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;
						r = rnd & 0xf;
						rnd = rnd >> 4;
						uuid[ i ] = chars[ ( i === 19 ) ? ( r & 0x3 ) | 0x8 : r ];
	
					}
	
				}
	
				return uuid.join( '' );
	
			};
	
		}(),
	
		clamp: function ( value, min, max ) {
	
			return Math.max( min, Math.min( max, value ) );
	
		},
	
		// compute euclidian modulo of m % n
		// https://en.wikipedia.org/wiki/Modulo_operation
	
		euclideanModulo: function ( n, m ) {
	
			return ( ( n % m ) + m ) % m;
	
		},
	
		// Linear mapping from range <a1, a2> to range <b1, b2>
	
		mapLinear: function ( x, a1, a2, b1, b2 ) {
	
			return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );
	
		},
	
		// http://en.wikipedia.org/wiki/Smoothstep
	
		smoothstep: function ( x, min, max ) {
	
			if ( x <= min ) return 0;
			if ( x >= max ) return 1;
	
			x = ( x - min ) / ( max - min );
	
			return x * x * ( 3 - 2 * x );
	
		},
	
		smootherstep: function ( x, min, max ) {
	
			if ( x <= min ) return 0;
			if ( x >= max ) return 1;
	
			x = ( x - min ) / ( max - min );
	
			return x * x * x * ( x * ( x * 6 - 15 ) + 10 );
	
		},
	
		random16: function () {
	
			console.warn( 'THREE.Math.random16() has been deprecated. Use Math.random() instead.' );
			return Math.random();
	
		},
	
		// Random integer from <low, high> interval
	
		randInt: function ( low, high ) {
	
			return low + Math.floor( Math.random() * ( high - low + 1 ) );
	
		},
	
		// Random float from <low, high> interval
	
		randFloat: function ( low, high ) {
	
			return low + Math.random() * ( high - low );
	
		},
	
		// Random float from <-range/2, range/2> interval
	
		randFloatSpread: function ( range ) {
	
			return range * ( 0.5 - Math.random() );
	
		},
	
		degToRad: function () {
	
			var degreeToRadiansFactor = Math.PI / 180;
	
			return function ( degrees ) {
	
				return degrees * degreeToRadiansFactor;
	
			};
	
		}(),
	
		radToDeg: function () {
	
			var radianToDegreesFactor = 180 / Math.PI;
	
			return function ( radians ) {
	
				return radians * radianToDegreesFactor;
	
			};
	
		}(),
	
		isPowerOfTwo: function ( value ) {
	
			return ( value & ( value - 1 ) ) === 0 && value !== 0;
	
		},
	
		nearestPowerOfTwo: function ( value ) {
	
			return Math.pow( 2, Math.round( Math.log( value ) / Math.LN2 ) );
	
		},
	
		nextPowerOfTwo: function ( value ) {
	
			value --;
			value |= value >> 1;
			value |= value >> 2;
			value |= value >> 4;
			value |= value >> 8;
			value |= value >> 16;
			value ++;
	
			return value;
	
		}
	
	};
	
	// File:src/math/Spline.js
	
	/**
	 * Spline from Tween.js, slightly optimized (and trashed)
	 * http://sole.github.com/tween.js/examples/05_spline.html
	 *
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.Spline = function ( points ) {
	
		this.points = points;
	
		var c = [], v3 = { x: 0, y: 0, z: 0 },
		point, intPoint, weight, w2, w3,
		pa, pb, pc, pd;
	
		this.initFromArray = function ( a ) {
	
			this.points = [];
	
			for ( var i = 0; i < a.length; i ++ ) {
	
				this.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };
	
			}
	
		};
	
		this.getPoint = function ( k ) {
	
			point = ( this.points.length - 1 ) * k;
			intPoint = Math.floor( point );
			weight = point - intPoint;
	
			c[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;
			c[ 1 ] = intPoint;
			c[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;
			c[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;
	
			pa = this.points[ c[ 0 ] ];
			pb = this.points[ c[ 1 ] ];
			pc = this.points[ c[ 2 ] ];
			pd = this.points[ c[ 3 ] ];
	
			w2 = weight * weight;
			w3 = weight * w2;
	
			v3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );
			v3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );
			v3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );
	
			return v3;
	
		};
	
		this.getControlPointsArray = function () {
	
			var i, p, l = this.points.length,
				coords = [];
	
			for ( i = 0; i < l; i ++ ) {
	
				p = this.points[ i ];
				coords[ i ] = [ p.x, p.y, p.z ];
	
			}
	
			return coords;
	
		};
	
		// approximate length by summing linear segments
	
		this.getLength = function ( nSubDivisions ) {
	
			var i, index, nSamples, position,
				point = 0, intPoint = 0, oldIntPoint = 0,
				oldPosition = new THREE.Vector3(),
				tmpVec = new THREE.Vector3(),
				chunkLengths = [],
				totalLength = 0;
	
			// first point has 0 length
	
			chunkLengths[ 0 ] = 0;
	
			if ( ! nSubDivisions ) nSubDivisions = 100;
	
			nSamples = this.points.length * nSubDivisions;
	
			oldPosition.copy( this.points[ 0 ] );
	
			for ( i = 1; i < nSamples; i ++ ) {
	
				index = i / nSamples;
	
				position = this.getPoint( index );
				tmpVec.copy( position );
	
				totalLength += tmpVec.distanceTo( oldPosition );
	
				oldPosition.copy( position );
	
				point = ( this.points.length - 1 ) * index;
				intPoint = Math.floor( point );
	
				if ( intPoint !== oldIntPoint ) {
	
					chunkLengths[ intPoint ] = totalLength;
					oldIntPoint = intPoint;
	
				}
	
			}
	
			// last point ends with total length
	
			chunkLengths[ chunkLengths.length ] = totalLength;
	
			return { chunks: chunkLengths, total: totalLength };
	
		};
	
		this.reparametrizeByArcLength = function ( samplingCoef ) {
	
			var i, j,
				index, indexCurrent, indexNext,
				realDistance,
				sampling, position,
				newpoints = [],
				tmpVec = new THREE.Vector3(),
				sl = this.getLength();
	
			newpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );
	
			for ( i = 1; i < this.points.length; i ++ ) {
	
				//tmpVec.copy( this.points[ i - 1 ] );
				//linearDistance = tmpVec.distanceTo( this.points[ i ] );
	
				realDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];
	
				sampling = Math.ceil( samplingCoef * realDistance / sl.total );
	
				indexCurrent = ( i - 1 ) / ( this.points.length - 1 );
				indexNext = i / ( this.points.length - 1 );
	
				for ( j = 1; j < sampling - 1; j ++ ) {
	
					index = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );
	
					position = this.getPoint( index );
					newpoints.push( tmpVec.copy( position ).clone() );
	
				}
	
				newpoints.push( tmpVec.copy( this.points[ i ] ).clone() );
	
			}
	
			this.points = newpoints;
	
		};
	
		// Catmull-Rom
	
		function interpolate( p0, p1, p2, p3, t, t2, t3 ) {
	
			var v0 = ( p2 - p0 ) * 0.5,
				v1 = ( p3 - p1 ) * 0.5;
	
			return ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;
	
		}
	
	};
	
	// File:src/math/Triangle.js
	
	/**
	 * @author bhouston / http://clara.io
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.Triangle = function ( a, b, c ) {
	
		this.a = ( a !== undefined ) ? a : new THREE.Vector3();
		this.b = ( b !== undefined ) ? b : new THREE.Vector3();
		this.c = ( c !== undefined ) ? c : new THREE.Vector3();
	
	};
	
	THREE.Triangle.normal = function () {
	
		var v0 = new THREE.Vector3();
	
		return function ( a, b, c, optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
	
			result.subVectors( c, b );
			v0.subVectors( a, b );
			result.cross( v0 );
	
			var resultLengthSq = result.lengthSq();
			if ( resultLengthSq > 0 ) {
	
				return result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );
	
			}
	
			return result.set( 0, 0, 0 );
	
		};
	
	}();
	
	// static/instance method to calculate barycentric coordinates
	// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
	THREE.Triangle.barycoordFromPoint = function () {
	
		var v0 = new THREE.Vector3();
		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();
	
		return function ( point, a, b, c, optionalTarget ) {
	
			v0.subVectors( c, a );
			v1.subVectors( b, a );
			v2.subVectors( point, a );
	
			var dot00 = v0.dot( v0 );
			var dot01 = v0.dot( v1 );
			var dot02 = v0.dot( v2 );
			var dot11 = v1.dot( v1 );
			var dot12 = v1.dot( v2 );
	
			var denom = ( dot00 * dot11 - dot01 * dot01 );
	
			var result = optionalTarget || new THREE.Vector3();
	
			// collinear or singular triangle
			if ( denom === 0 ) {
	
				// arbitrary location outside of triangle?
				// not sure if this is the best idea, maybe should be returning undefined
				return result.set( - 2, - 1, - 1 );
	
			}
	
			var invDenom = 1 / denom;
			var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
			var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;
	
			// barycentric coordinates must always sum to 1
			return result.set( 1 - u - v, v, u );
	
		};
	
	}();
	
	THREE.Triangle.containsPoint = function () {
	
		var v1 = new THREE.Vector3();
	
		return function ( point, a, b, c ) {
	
			var result = THREE.Triangle.barycoordFromPoint( point, a, b, c, v1 );
	
			return ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );
	
		};
	
	}();
	
	THREE.Triangle.prototype = {
	
		constructor: THREE.Triangle,
	
		set: function ( a, b, c ) {
	
			this.a.copy( a );
			this.b.copy( b );
			this.c.copy( c );
	
			return this;
	
		},
	
		setFromPointsAndIndices: function ( points, i0, i1, i2 ) {
	
			this.a.copy( points[ i0 ] );
			this.b.copy( points[ i1 ] );
			this.c.copy( points[ i2 ] );
	
			return this;
	
		},
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		},
	
		copy: function ( triangle ) {
	
			this.a.copy( triangle.a );
			this.b.copy( triangle.b );
			this.c.copy( triangle.c );
	
			return this;
	
		},
	
		area: function () {
	
			var v0 = new THREE.Vector3();
			var v1 = new THREE.Vector3();
	
			return function () {
	
				v0.subVectors( this.c, this.b );
				v1.subVectors( this.a, this.b );
	
				return v0.cross( v1 ).length() * 0.5;
	
			};
	
		}(),
	
		midpoint: function ( optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
			return result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );
	
		},
	
		normal: function ( optionalTarget ) {
	
			return THREE.Triangle.normal( this.a, this.b, this.c, optionalTarget );
	
		},
	
		plane: function ( optionalTarget ) {
	
			var result = optionalTarget || new THREE.Plane();
	
			return result.setFromCoplanarPoints( this.a, this.b, this.c );
	
		},
	
		barycoordFromPoint: function ( point, optionalTarget ) {
	
			return THREE.Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );
	
		},
	
		containsPoint: function ( point ) {
	
			return THREE.Triangle.containsPoint( point, this.a, this.b, this.c );
	
		},
	
		equals: function ( triangle ) {
	
			return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );
	
		}
	
	};
	
	// File:src/math/Interpolant.js
	
	/**
	 * Abstract base class of interpolants over parametric samples.
	 *
	 * The parameter domain is one dimensional, typically the time or a path
	 * along a curve defined by the data.
	 *
	 * The sample values can have any dimensionality and derived classes may
	 * apply special interpretations to the data.
	 *
	 * This class provides the interval seek in a Template Method, deferring
	 * the actual interpolation to derived classes.
	 *
	 * Time complexity is O(1) for linear access crossing at most two points
	 * and O(log N) for random access, where N is the number of positions.
	 *
	 * References:
	 *
	 * 		http://www.oodesign.com/template-method-pattern.html
	 *
	 * @author tschw
	 */
	
	THREE.Interpolant = function(
			parameterPositions, sampleValues, sampleSize, resultBuffer ) {
	
		this.parameterPositions = parameterPositions;
		this._cachedIndex = 0;
	
		this.resultBuffer = resultBuffer !== undefined ?
				resultBuffer : new sampleValues.constructor( sampleSize );
		this.sampleValues = sampleValues;
		this.valueSize = sampleSize;
	
	};
	
	THREE.Interpolant.prototype = {
	
		constructor: THREE.Interpolant,
	
		evaluate: function( t ) {
	
			var pp = this.parameterPositions,
				i1 = this._cachedIndex,
	
				t1 = pp[   i1   ],
				t0 = pp[ i1 - 1 ];
	
			validate_interval: {
	
				seek: {
	
					var right;
	
					linear_scan: {
	//- See http://jsperf.com/comparison-to-undefined/3
	//- slower code:
	//-
	//- 				if ( t >= t1 || t1 === undefined ) {
						forward_scan: if ( ! ( t < t1 ) ) {
	
							for ( var giveUpAt = i1 + 2; ;) {
	
								if ( t1 === undefined ) {
	
									if ( t < t0 ) break forward_scan;
	
									// after end
	
									i1 = pp.length;
									this._cachedIndex = i1;
									return this.afterEnd_( i1 - 1, t, t0 );
	
								}
	
								if ( i1 === giveUpAt ) break; // this loop
	
								t0 = t1;
								t1 = pp[ ++ i1 ];
	
								if ( t < t1 ) {
	
									// we have arrived at the sought interval
									break seek;
	
								}
	
							}
	
							// prepare binary search on the right side of the index
							right = pp.length;
							break linear_scan;
	
						}
	
	//- slower code:
	//-					if ( t < t0 || t0 === undefined ) {
						if ( ! ( t >= t0 ) ) {
	
							// looping?
	
							var t1global = pp[ 1 ];
	
							if ( t < t1global ) {
	
								i1 = 2; // + 1, using the scan for the details
								t0 = t1global;
	
							}
	
							// linear reverse scan
	
							for ( var giveUpAt = i1 - 2; ;) {
	
								if ( t0 === undefined ) {
	
									// before start
	
									this._cachedIndex = 0;
									return this.beforeStart_( 0, t, t1 );
	
								}
	
								if ( i1 === giveUpAt ) break; // this loop
	
								t1 = t0;
								t0 = pp[ -- i1 - 1 ];
	
								if ( t >= t0 ) {
	
									// we have arrived at the sought interval
									break seek;
	
								}
	
							}
	
							// prepare binary search on the left side of the index
							right = i1;
							i1 = 0;
							break linear_scan;
	
						}
	
						// the interval is valid
	
						break validate_interval;
	
					} // linear scan
	
					// binary search
	
					while ( i1 < right ) {
	
						var mid = ( i1 + right ) >>> 1;
	
						if ( t < pp[ mid ] ) {
	
							right = mid;
	
						} else {
	
							i1 = mid + 1;
	
						}
	
					}
	
					t1 = pp[   i1   ];
					t0 = pp[ i1 - 1 ];
	
					// check boundary cases, again
	
					if ( t0 === undefined ) {
	
						this._cachedIndex = 0;
						return this.beforeStart_( 0, t, t1 );
	
					}
	
					if ( t1 === undefined ) {
	
						i1 = pp.length;
						this._cachedIndex = i1;
						return this.afterEnd_( i1 - 1, t0, t );
	
					}
	
				} // seek
	
				this._cachedIndex = i1;
	
				this.intervalChanged_( i1, t0, t1 );
	
			} // validate_interval
	
			return this.interpolate_( i1, t0, t, t1 );
	
		},
	
		settings: null, // optional, subclass-specific settings structure
		// Note: The indirection allows central control of many interpolants.
	
		// --- Protected interface
	
		DefaultSettings_: {},
	
		getSettings_: function() {
	
			return this.settings || this.DefaultSettings_;
	
		},
	
		copySampleValue_: function( index ) {
	
			// copies a sample value to the result buffer
	
			var result = this.resultBuffer,
				values = this.sampleValues,
				stride = this.valueSize,
				offset = index * stride;
	
			for ( var i = 0; i !== stride; ++ i ) {
	
				result[ i ] = values[ offset + i ];
	
			}
	
			return result;
	
		},
	
		// Template methods for derived classes:
	
		interpolate_: function( i1, t0, t, t1 ) {
	
			throw new Error( "call to abstract method" );
			// implementations shall return this.resultBuffer
	
		},
	
		intervalChanged_: function( i1, t0, t1 ) {
	
			// empty
	
		}
	
	};
	
	Object.assign( THREE.Interpolant.prototype, {
	
		beforeStart_: //( 0, t, t0 ), returns this.resultBuffer
			THREE.Interpolant.prototype.copySampleValue_,
	
		afterEnd_: //( N-1, tN-1, t ), returns this.resultBuffer
			THREE.Interpolant.prototype.copySampleValue_
	
	} );
	
	// File:src/math/interpolants/CubicInterpolant.js
	
	/**
	 * Fast and simple cubic spline interpolant.
	 *
	 * It was derived from a Hermitian construction setting the first derivative
	 * at each sample position to the linear slope between neighboring positions
	 * over their parameter interval.
	 *
	 * @author tschw
	 */
	
	THREE.CubicInterpolant = function(
			parameterPositions, sampleValues, sampleSize, resultBuffer ) {
	
		THREE.Interpolant.call(
				this, parameterPositions, sampleValues, sampleSize, resultBuffer );
	
		this._weightPrev = -0;
		this._offsetPrev = -0;
		this._weightNext = -0;
		this._offsetNext = -0;
	
	};
	
	THREE.CubicInterpolant.prototype =
			Object.assign( Object.create( THREE.Interpolant.prototype ), {
	
		constructor: THREE.CubicInterpolant,
	
		DefaultSettings_: {
	
			endingStart: 	THREE.ZeroCurvatureEnding,
			endingEnd:		THREE.ZeroCurvatureEnding
	
		},
	
		intervalChanged_: function( i1, t0, t1 ) {
	
			var pp = this.parameterPositions,
				iPrev = i1 - 2,
				iNext = i1 + 1,
	
				tPrev = pp[ iPrev ],
				tNext = pp[ iNext ];
	
			if ( tPrev === undefined ) {
	
				switch ( this.getSettings_().endingStart ) {
	
					case THREE.ZeroSlopeEnding:
	
						// f'(t0) = 0
						iPrev = i1;
						tPrev = 2 * t0 - t1;
	
						break;
	
					case THREE.WrapAroundEnding:
	
						// use the other end of the curve
						iPrev = pp.length - 2;
						tPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];
	
						break;
	
					default: // ZeroCurvatureEnding
	
						// f''(t0) = 0 a.k.a. Natural Spline
						iPrev = i1;
						tPrev = t1;
	
				}
	
			}
	
			if ( tNext === undefined ) {
	
				switch ( this.getSettings_().endingEnd ) {
	
					case THREE.ZeroSlopeEnding:
	
						// f'(tN) = 0
						iNext = i1;
						tNext = 2 * t1 - t0;
	
						break;
	
					case THREE.WrapAroundEnding:
	
						// use the other end of the curve
						iNext = 1;
						tNext = t1 + pp[ 1 ] - pp[ 0 ];
	
						break;
	
					default: // ZeroCurvatureEnding
	
						// f''(tN) = 0, a.k.a. Natural Spline
						iNext = i1 - 1;
						tNext = t0;
	
				}
	
			}
	
			var halfDt = ( t1 - t0 ) * 0.5,
				stride = this.valueSize;
	
			this._weightPrev = halfDt / ( t0 - tPrev );
			this._weightNext = halfDt / ( tNext - t1 );
			this._offsetPrev = iPrev * stride;
			this._offsetNext = iNext * stride;
	
		},
	
		interpolate_: function( i1, t0, t, t1 ) {
	
			var result = this.resultBuffer,
				values = this.sampleValues,
				stride = this.valueSize,
	
				o1 = i1 * stride,		o0 = o1 - stride,
				oP = this._offsetPrev, 	oN = this._offsetNext,
				wP = this._weightPrev,	wN = this._weightNext,
	
				p = ( t - t0 ) / ( t1 - t0 ),
				pp = p * p,
				ppp = pp * p;
	
			// evaluate polynomials
	
			var sP =     - wP   * ppp   +         2 * wP    * pp    -          wP   * p;
			var s0 = ( 1 + wP ) * ppp   + (-1.5 - 2 * wP )  * pp    + ( -0.5 + wP ) * p     + 1;
			var s1 = (-1 - wN ) * ppp   + ( 1.5 +   wN   )  * pp    +    0.5        * p;
			var sN =       wN   * ppp   -           wN      * pp;
	
			// combine data linearly
	
			for ( var i = 0; i !== stride; ++ i ) {
	
				result[ i ] =
						sP * values[ oP + i ] +
						s0 * values[ o0 + i ] +
						s1 * values[ o1 + i ] +
						sN * values[ oN + i ];
	
			}
	
			return result;
	
		}
	
	} );
	
	// File:src/math/interpolants/DiscreteInterpolant.js
	
	/**
	 *
	 * Interpolant that evaluates to the sample value at the position preceeding
	 * the parameter.
	 *
	 * @author tschw
	 */
	
	THREE.DiscreteInterpolant = function(
			parameterPositions, sampleValues, sampleSize, resultBuffer ) {
	
		THREE.Interpolant.call(
				this, parameterPositions, sampleValues, sampleSize, resultBuffer );
	
	};
	
	THREE.DiscreteInterpolant.prototype =
			Object.assign( Object.create( THREE.Interpolant.prototype ), {
	
		constructor: THREE.DiscreteInterpolant,
	
		interpolate_: function( i1, t0, t, t1 ) {
	
			return this.copySampleValue_( i1 - 1 );
	
		}
	
	} );
	
	// File:src/math/interpolants/LinearInterpolant.js
	
	/**
	 * @author tschw
	 */
	
	THREE.LinearInterpolant = function(
			parameterPositions, sampleValues, sampleSize, resultBuffer ) {
	
		THREE.Interpolant.call(
				this, parameterPositions, sampleValues, sampleSize, resultBuffer );
	
	};
	
	THREE.LinearInterpolant.prototype =
			Object.assign( Object.create( THREE.Interpolant.prototype ), {
	
		constructor: THREE.LinearInterpolant,
	
		interpolate_: function( i1, t0, t, t1 ) {
	
			var result = this.resultBuffer,
				values = this.sampleValues,
				stride = this.valueSize,
	
				offset1 = i1 * stride,
				offset0 = offset1 - stride,
	
				weight1 = ( t - t0 ) / ( t1 - t0 ),
				weight0 = 1 - weight1;
	
			for ( var i = 0; i !== stride; ++ i ) {
	
				result[ i ] =
						values[ offset0 + i ] * weight0 +
						values[ offset1 + i ] * weight1;
	
			}
	
			return result;
	
		}
	
	} );
	
	// File:src/math/interpolants/QuaternionLinearInterpolant.js
	
	/**
	 * Spherical linear unit quaternion interpolant.
	 *
	 * @author tschw
	 */
	
	THREE.QuaternionLinearInterpolant = function(
			parameterPositions, sampleValues, sampleSize, resultBuffer ) {
	
		THREE.Interpolant.call(
				this, parameterPositions, sampleValues, sampleSize, resultBuffer );
	
	};
	
	THREE.QuaternionLinearInterpolant.prototype =
			Object.assign( Object.create( THREE.Interpolant.prototype ), {
	
		constructor: THREE.QuaternionLinearInterpolant,
	
		interpolate_: function( i1, t0, t, t1 ) {
	
			var result = this.resultBuffer,
				values = this.sampleValues,
				stride = this.valueSize,
	
				offset = i1 * stride,
	
				alpha = ( t - t0 ) / ( t1 - t0 );
	
			for ( var end = offset + stride; offset !== end; offset += 4 ) {
	
				THREE.Quaternion.slerpFlat( result, 0,
						values, offset - stride, values, offset, alpha );
	
			}
	
			return result;
	
		}
	
	} );
	
	// File:src/core/Clock.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.Clock = function ( autoStart ) {
	
		this.autoStart = ( autoStart !== undefined ) ? autoStart : true;
	
		this.startTime = 0;
		this.oldTime = 0;
		this.elapsedTime = 0;
	
		this.running = false;
	
	};
	
	THREE.Clock.prototype = {
	
		constructor: THREE.Clock,
	
		start: function () {
	
			this.startTime = performance.now();
	
			this.oldTime = this.startTime;
			this.running = true;
	
		},
	
		stop: function () {
	
			this.getElapsedTime();
			this.running = false;
	
		},
	
		getElapsedTime: function () {
	
			this.getDelta();
			return this.elapsedTime;
	
		},
	
		getDelta: function () {
	
			var diff = 0;
	
			if ( this.autoStart && ! this.running ) {
	
				this.start();
	
			}
	
			if ( this.running ) {
	
				var newTime = performance.now();
	
				diff = 0.001 * ( newTime - this.oldTime );
				this.oldTime = newTime;
	
				this.elapsedTime += diff;
	
			}
	
			return diff;
	
		}
	
	};
	
	// File:src/core/EventDispatcher.js
	
	/**
	 * https://github.com/mrdoob/eventdispatcher.js/
	 */
	
	THREE.EventDispatcher = function () {};
	
	THREE.EventDispatcher.prototype = {
	
		constructor: THREE.EventDispatcher,
	
		apply: function ( object ) {
	
			object.addEventListener = THREE.EventDispatcher.prototype.addEventListener;
			object.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener;
			object.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener;
			object.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent;
	
		},
	
		addEventListener: function ( type, listener ) {
	
			if ( this._listeners === undefined ) this._listeners = {};
	
			var listeners = this._listeners;
	
			if ( listeners[ type ] === undefined ) {
	
				listeners[ type ] = [];
	
			}
	
			if ( listeners[ type ].indexOf( listener ) === - 1 ) {
	
				listeners[ type ].push( listener );
	
			}
	
		},
	
		hasEventListener: function ( type, listener ) {
	
			if ( this._listeners === undefined ) return false;
	
			var listeners = this._listeners;
	
			if ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {
	
				return true;
	
			}
	
			return false;
	
		},
	
		removeEventListener: function ( type, listener ) {
	
			if ( this._listeners === undefined ) return;
	
			var listeners = this._listeners;
			var listenerArray = listeners[ type ];
	
			if ( listenerArray !== undefined ) {
	
				var index = listenerArray.indexOf( listener );
	
				if ( index !== - 1 ) {
	
					listenerArray.splice( index, 1 );
	
				}
	
			}
	
		},
	
		dispatchEvent: function ( event ) {
	
			if ( this._listeners === undefined ) return;
	
			var listeners = this._listeners;
			var listenerArray = listeners[ event.type ];
	
			if ( listenerArray !== undefined ) {
	
				event.target = this;
	
				var array = [];
				var length = listenerArray.length;
	
				for ( var i = 0; i < length; i ++ ) {
	
					array[ i ] = listenerArray[ i ];
	
				}
	
				for ( var i = 0; i < length; i ++ ) {
	
					array[ i ].call( this, event );
	
				}
	
			}
	
		}
	
	};
	
	// File:src/core/Layers.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.Layers = function () {
	
		this.mask = 1;
	
	};
	
	THREE.Layers.prototype = {
	
		constructor: THREE.Layers,
	
		set: function ( channel ) {
	
			this.mask = 1 << channel;
	
		},
	
		enable: function ( channel ) {
	
			this.mask |= 1 << channel;
	
		},
	
		toggle: function ( channel ) {
	
			this.mask ^= 1 << channel;
	
		},
	
		disable: function ( channel ) {
	
			this.mask &= ~ ( 1 << channel );
	
		},
	
		test: function ( layers ) {
	
			return ( this.mask & layers.mask ) !== 0;
	
		}
	
	};
	
	// File:src/core/Raycaster.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author bhouston / http://clara.io/
	 * @author stephomi / http://stephaneginier.com/
	 */
	
	( function ( THREE ) {
	
		THREE.Raycaster = function ( origin, direction, near, far ) {
	
			this.ray = new THREE.Ray( origin, direction );
			// direction is assumed to be normalized (for accurate distance calculations)
	
			this.near = near || 0;
			this.far = far || Infinity;
	
			this.params = {
				Mesh: {},
				Line: {},
				LOD: {},
				Points: { threshold: 1 },
				Sprite: {}
			};
	
			Object.defineProperties( this.params, {
				PointCloud: {
					get: function () {
						console.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );
						return this.Points;
					}
				}
			} );
	
		};
	
		function ascSort( a, b ) {
	
			return a.distance - b.distance;
	
		}
	
		function intersectObject( object, raycaster, intersects, recursive ) {
	
			if ( object.visible === false ) return;
	
			object.raycast( raycaster, intersects );
	
			if ( recursive === true ) {
	
				var children = object.children;
	
				for ( var i = 0, l = children.length; i < l; i ++ ) {
	
					intersectObject( children[ i ], raycaster, intersects, true );
	
				}
	
			}
	
		}
	
		//
	
		THREE.Raycaster.prototype = {
	
			constructor: THREE.Raycaster,
	
			linePrecision: 1,
	
			set: function ( origin, direction ) {
	
				// direction is assumed to be normalized (for accurate distance calculations)
	
				this.ray.set( origin, direction );
	
			},
	
			setFromCamera: function ( coords, camera ) {
	
				if ( camera instanceof THREE.PerspectiveCamera ) {
	
					this.ray.origin.setFromMatrixPosition( camera.matrixWorld );
					this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();
	
				} else if ( camera instanceof THREE.OrthographicCamera ) {
	
					this.ray.origin.set( coords.x, coords.y, - 1 ).unproject( camera );
					this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );
	
				} else {
	
					console.error( 'THREE.Raycaster: Unsupported camera type.' );
	
				}
	
			},
	
			intersectObject: function ( object, recursive ) {
	
				var intersects = [];
	
				intersectObject( object, this, intersects, recursive );
	
				intersects.sort( ascSort );
	
				return intersects;
	
			},
	
			intersectObjects: function ( objects, recursive ) {
	
				var intersects = [];
	
				if ( Array.isArray( objects ) === false ) {
	
					console.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );
					return intersects;
	
				}
	
				for ( var i = 0, l = objects.length; i < l; i ++ ) {
	
					intersectObject( objects[ i ], this, intersects, recursive );
	
				}
	
				intersects.sort( ascSort );
	
				return intersects;
	
			}
	
		};
	
	}( THREE ) );
	
	// File:src/core/Object3D.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author elephantatwork / www.elephantatwork.ch
	 */
	
	THREE.Object3D = function () {
	
		Object.defineProperty( this, 'id', { value: THREE.Object3DIdCount ++ } );
	
		this.uuid = THREE.Math.generateUUID();
	
		this.name = '';
		this.type = 'Object3D';
	
		this.parent = null;
		this.children = [];
	
		this.up = THREE.Object3D.DefaultUp.clone();
	
		var position = new THREE.Vector3();
		var rotation = new THREE.Euler();
		var quaternion = new THREE.Quaternion();
		var scale = new THREE.Vector3( 1, 1, 1 );
	
		function onRotationChange() {
	
			quaternion.setFromEuler( rotation, false );
	
		}
	
		function onQuaternionChange() {
	
			rotation.setFromQuaternion( quaternion, undefined, false );
	
		}
	
		rotation.onChange( onRotationChange );
		quaternion.onChange( onQuaternionChange );
	
		Object.defineProperties( this, {
			position: {
				enumerable: true,
				value: position
			},
			rotation: {
				enumerable: true,
				value: rotation
			},
			quaternion: {
				enumerable: true,
				value: quaternion
			},
			scale: {
				enumerable: true,
				value: scale
			},
			modelViewMatrix: {
				value: new THREE.Matrix4()
			},
			normalMatrix: {
				value: new THREE.Matrix3()
			}
		} );
	
		this.rotationAutoUpdate = true;
	
		this.matrix = new THREE.Matrix4();
		this.matrixWorld = new THREE.Matrix4();
	
		this.matrixAutoUpdate = THREE.Object3D.DefaultMatrixAutoUpdate;
		this.matrixWorldNeedsUpdate = false;
	
		this.layers = new THREE.Layers();
		this.visible = true;
	
		this.castShadow = false;
		this.receiveShadow = false;
	
		this.frustumCulled = true;
		this.renderOrder = 0;
	
		this.userData = {};
	
	};
	
	THREE.Object3D.DefaultUp = new THREE.Vector3( 0, 1, 0 );
	THREE.Object3D.DefaultMatrixAutoUpdate = true;
	
	THREE.Object3D.prototype = {
	
		constructor: THREE.Object3D,
	
		applyMatrix: function ( matrix ) {
	
			this.matrix.multiplyMatrices( matrix, this.matrix );
	
			this.matrix.decompose( this.position, this.quaternion, this.scale );
	
		},
	
		setRotationFromAxisAngle: function ( axis, angle ) {
	
			// assumes axis is normalized
	
			this.quaternion.setFromAxisAngle( axis, angle );
	
		},
	
		setRotationFromEuler: function ( euler ) {
	
			this.quaternion.setFromEuler( euler, true );
	
		},
	
		setRotationFromMatrix: function ( m ) {
	
			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
	
			this.quaternion.setFromRotationMatrix( m );
	
		},
	
		setRotationFromQuaternion: function ( q ) {
	
			// assumes q is normalized
	
			this.quaternion.copy( q );
	
		},
	
		rotateOnAxis: function () {
	
			// rotate object on axis in object space
			// axis is assumed to be normalized
	
			var q1 = new THREE.Quaternion();
	
			return function ( axis, angle ) {
	
				q1.setFromAxisAngle( axis, angle );
	
				this.quaternion.multiply( q1 );
	
				return this;
	
			};
	
		}(),
	
		rotateX: function () {
	
			var v1 = new THREE.Vector3( 1, 0, 0 );
	
			return function ( angle ) {
	
				return this.rotateOnAxis( v1, angle );
	
			};
	
		}(),
	
		rotateY: function () {
	
			var v1 = new THREE.Vector3( 0, 1, 0 );
	
			return function ( angle ) {
	
				return this.rotateOnAxis( v1, angle );
	
			};
	
		}(),
	
		rotateZ: function () {
	
			var v1 = new THREE.Vector3( 0, 0, 1 );
	
			return function ( angle ) {
	
				return this.rotateOnAxis( v1, angle );
	
			};
	
		}(),
	
		translateOnAxis: function () {
	
			// translate object by distance along axis in object space
			// axis is assumed to be normalized
	
			var v1 = new THREE.Vector3();
	
			return function ( axis, distance ) {
	
				v1.copy( axis ).applyQuaternion( this.quaternion );
	
				this.position.add( v1.multiplyScalar( distance ) );
	
				return this;
	
			};
	
		}(),
	
		translateX: function () {
	
			var v1 = new THREE.Vector3( 1, 0, 0 );
	
			return function ( distance ) {
	
				return this.translateOnAxis( v1, distance );
	
			};
	
		}(),
	
		translateY: function () {
	
			var v1 = new THREE.Vector3( 0, 1, 0 );
	
			return function ( distance ) {
	
				return this.translateOnAxis( v1, distance );
	
			};
	
		}(),
	
		translateZ: function () {
	
			var v1 = new THREE.Vector3( 0, 0, 1 );
	
			return function ( distance ) {
	
				return this.translateOnAxis( v1, distance );
	
			};
	
		}(),
	
		localToWorld: function ( vector ) {
	
			return vector.applyMatrix4( this.matrixWorld );
	
		},
	
		worldToLocal: function () {
	
			var m1 = new THREE.Matrix4();
	
			return function ( vector ) {
	
				return vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );
	
			};
	
		}(),
	
		lookAt: function () {
	
			// This routine does not support objects with rotated and/or translated parent(s)
	
			var m1 = new THREE.Matrix4();
	
			return function ( vector ) {
	
				m1.lookAt( vector, this.position, this.up );
	
				this.quaternion.setFromRotationMatrix( m1 );
	
			};
	
		}(),
	
		add: function ( object ) {
	
			if ( arguments.length > 1 ) {
	
				for ( var i = 0; i < arguments.length; i ++ ) {
	
					this.add( arguments[ i ] );
	
				}
	
				return this;
	
			}
	
			if ( object === this ) {
	
				console.error( "THREE.Object3D.add: object can't be added as a child of itself.", object );
				return this;
	
			}
	
			if ( object instanceof THREE.Object3D ) {
	
				if ( object.parent !== null ) {
	
					object.parent.remove( object );
	
				}
	
				object.parent = this;
				object.dispatchEvent( { type: 'added' } );
	
				this.children.push( object );
	
			} else {
	
				console.error( "THREE.Object3D.add: object not an instance of THREE.Object3D.", object );
	
			}
	
			return this;
	
		},
	
		remove: function ( object ) {
	
			if ( arguments.length > 1 ) {
	
				for ( var i = 0; i < arguments.length; i ++ ) {
	
					this.remove( arguments[ i ] );
	
				}
	
			}
	
			var index = this.children.indexOf( object );
	
			if ( index !== - 1 ) {
	
				object.parent = null;
	
				object.dispatchEvent( { type: 'removed' } );
	
				this.children.splice( index, 1 );
	
			}
	
		},
	
		getObjectById: function ( id ) {
	
			return this.getObjectByProperty( 'id', id );
	
		},
	
		getObjectByName: function ( name ) {
	
			return this.getObjectByProperty( 'name', name );
	
		},
	
		getObjectByProperty: function ( name, value ) {
	
			if ( this[ name ] === value ) return this;
	
			for ( var i = 0, l = this.children.length; i < l; i ++ ) {
	
				var child = this.children[ i ];
				var object = child.getObjectByProperty( name, value );
	
				if ( object !== undefined ) {
	
					return object;
	
				}
	
			}
	
			return undefined;
	
		},
	
		getWorldPosition: function ( optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
	
			this.updateMatrixWorld( true );
	
			return result.setFromMatrixPosition( this.matrixWorld );
	
		},
	
		getWorldQuaternion: function () {
	
			var position = new THREE.Vector3();
			var scale = new THREE.Vector3();
	
			return function ( optionalTarget ) {
	
				var result = optionalTarget || new THREE.Quaternion();
	
				this.updateMatrixWorld( true );
	
				this.matrixWorld.decompose( position, result, scale );
	
				return result;
	
			};
	
		}(),
	
		getWorldRotation: function () {
	
			var quaternion = new THREE.Quaternion();
	
			return function ( optionalTarget ) {
	
				var result = optionalTarget || new THREE.Euler();
	
				this.getWorldQuaternion( quaternion );
	
				return result.setFromQuaternion( quaternion, this.rotation.order, false );
	
			};
	
		}(),
	
		getWorldScale: function () {
	
			var position = new THREE.Vector3();
			var quaternion = new THREE.Quaternion();
	
			return function ( optionalTarget ) {
	
				var result = optionalTarget || new THREE.Vector3();
	
				this.updateMatrixWorld( true );
	
				this.matrixWorld.decompose( position, quaternion, result );
	
				return result;
	
			};
	
		}(),
	
		getWorldDirection: function () {
	
			var quaternion = new THREE.Quaternion();
	
			return function ( optionalTarget ) {
	
				var result = optionalTarget || new THREE.Vector3();
	
				this.getWorldQuaternion( quaternion );
	
				return result.set( 0, 0, 1 ).applyQuaternion( quaternion );
	
			};
	
		}(),
	
		raycast: function () {},
	
		traverse: function ( callback ) {
	
			callback( this );
	
			var children = this.children;
	
			for ( var i = 0, l = children.length; i < l; i ++ ) {
	
				children[ i ].traverse( callback );
	
			}
	
		},
	
		traverseVisible: function ( callback ) {
	
			if ( this.visible === false ) return;
	
			callback( this );
	
			var children = this.children;
	
			for ( var i = 0, l = children.length; i < l; i ++ ) {
	
				children[ i ].traverseVisible( callback );
	
			}
	
		},
	
		traverseAncestors: function ( callback ) {
	
			var parent = this.parent;
	
			if ( parent !== null ) {
	
				callback( parent );
	
				parent.traverseAncestors( callback );
	
			}
	
		},
	
		updateMatrix: function () {
	
			this.matrix.compose( this.position, this.quaternion, this.scale );
	
			this.matrixWorldNeedsUpdate = true;
	
		},
	
		updateMatrixWorld: function ( force ) {
	
			if ( this.matrixAutoUpdate === true ) this.updateMatrix();
	
			if ( this.matrixWorldNeedsUpdate === true || force === true ) {
	
				if ( this.parent === null ) {
	
					this.matrixWorld.copy( this.matrix );
	
				} else {
	
					this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );
	
				}
	
				this.matrixWorldNeedsUpdate = false;
	
				force = true;
	
			}
	
			// update children
	
			for ( var i = 0, l = this.children.length; i < l; i ++ ) {
	
				this.children[ i ].updateMatrixWorld( force );
	
			}
	
		},
	
		toJSON: function ( meta ) {
	
			var isRootObject = ( meta === undefined );
	
			var output = {};
	
			// meta is a hash used to collect geometries, materials.
			// not providing it implies that this is the root object
			// being serialized.
			if ( isRootObject ) {
	
				// initialize meta obj
				meta = {
					geometries: {},
					materials: {},
					textures: {},
					images: {}
				};
	
				output.metadata = {
					version: 4.4,
					type: 'Object',
					generator: 'Object3D.toJSON'
				};
	
			}
	
			// standard Object3D serialization
	
			var object = {};
	
			object.uuid = this.uuid;
			object.type = this.type;
	
			if ( this.name !== '' ) object.name = this.name;
			if ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;
			if ( this.castShadow === true ) object.castShadow = true;
			if ( this.receiveShadow === true ) object.receiveShadow = true;
			if ( this.visible === false ) object.visible = false;
	
			object.matrix = this.matrix.toArray();
	
			//
	
			if ( this.geometry !== undefined ) {
	
				if ( meta.geometries[ this.geometry.uuid ] === undefined ) {
	
					meta.geometries[ this.geometry.uuid ] = this.geometry.toJSON( meta );
	
				}
	
				object.geometry = this.geometry.uuid;
	
			}
	
			if ( this.material !== undefined ) {
	
				if ( meta.materials[ this.material.uuid ] === undefined ) {
	
					meta.materials[ this.material.uuid ] = this.material.toJSON( meta );
	
				}
	
				object.material = this.material.uuid;
	
			}
	
			//
	
			if ( this.children.length > 0 ) {
	
				object.children = [];
	
				for ( var i = 0; i < this.children.length; i ++ ) {
	
					object.children.push( this.children[ i ].toJSON( meta ).object );
	
				}
	
			}
	
			if ( isRootObject ) {
	
				var geometries = extractFromCache( meta.geometries );
				var materials = extractFromCache( meta.materials );
				var textures = extractFromCache( meta.textures );
				var images = extractFromCache( meta.images );
	
				if ( geometries.length > 0 ) output.geometries = geometries;
				if ( materials.length > 0 ) output.materials = materials;
				if ( textures.length > 0 ) output.textures = textures;
				if ( images.length > 0 ) output.images = images;
	
			}
	
			output.object = object;
	
			return output;
	
			// extract data from the cache hash
			// remove metadata on each item
			// and return as array
			function extractFromCache ( cache ) {
	
				var values = [];
				for ( var key in cache ) {
	
					var data = cache[ key ];
					delete data.metadata;
					values.push( data );
	
				}
				return values;
	
			}
	
		},
	
		clone: function ( recursive ) {
	
			return new this.constructor().copy( this, recursive );
	
		},
	
		copy: function ( source, recursive ) {
	
			if ( recursive === undefined ) recursive = true;
	
			this.name = source.name;
	
			this.up.copy( source.up );
	
			this.position.copy( source.position );
			this.quaternion.copy( source.quaternion );
			this.scale.copy( source.scale );
	
			this.rotationAutoUpdate = source.rotationAutoUpdate;
	
			this.matrix.copy( source.matrix );
			this.matrixWorld.copy( source.matrixWorld );
	
			this.matrixAutoUpdate = source.matrixAutoUpdate;
			this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
	
			this.visible = source.visible;
	
			this.castShadow = source.castShadow;
			this.receiveShadow = source.receiveShadow;
	
			this.frustumCulled = source.frustumCulled;
			this.renderOrder = source.renderOrder;
	
			this.userData = JSON.parse( JSON.stringify( source.userData ) );
	
			if ( recursive === true ) {
	
				for ( var i = 0; i < source.children.length; i ++ ) {
	
					var child = source.children[ i ];
					this.add( child.clone() );
	
				}
	
			}
	
			return this;
	
		}
	
	};
	
	THREE.EventDispatcher.prototype.apply( THREE.Object3D.prototype );
	
	THREE.Object3DIdCount = 0;
	
	// File:src/core/Face3.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.Face3 = function ( a, b, c, normal, color, materialIndex ) {
	
		this.a = a;
		this.b = b;
		this.c = c;
	
		this.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();
		this.vertexNormals = Array.isArray( normal ) ? normal : [];
	
		this.color = color instanceof THREE.Color ? color : new THREE.Color();
		this.vertexColors = Array.isArray( color ) ? color : [];
	
		this.materialIndex = materialIndex !== undefined ? materialIndex : 0;
	
	};
	
	THREE.Face3.prototype = {
	
		constructor: THREE.Face3,
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		},
	
		copy: function ( source ) {
	
			this.a = source.a;
			this.b = source.b;
			this.c = source.c;
	
			this.normal.copy( source.normal );
			this.color.copy( source.color );
	
			this.materialIndex = source.materialIndex;
	
			for ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {
	
				this.vertexNormals[ i ] = source.vertexNormals[ i ].clone();
	
			}
	
			for ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {
	
				this.vertexColors[ i ] = source.vertexColors[ i ].clone();
	
			}
	
			return this;
	
		}
	
	};
	
	// File:src/core/BufferAttribute.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.BufferAttribute = function ( array, itemSize ) {
	
		this.uuid = THREE.Math.generateUUID();
	
		this.array = array;
		this.itemSize = itemSize;
	
		this.dynamic = false;
		this.updateRange = { offset: 0, count: - 1 };
	
		this.version = 0;
	
	};
	
	THREE.BufferAttribute.prototype = {
	
		constructor: THREE.BufferAttribute,
	
		get count() {
	
			return this.array.length / this.itemSize;
	
		},
	
		set needsUpdate( value ) {
	
			if ( value === true ) this.version ++;
	
		},
	
		setDynamic: function ( value ) {
	
			this.dynamic = value;
	
			return this;
	
		},
	
		copy: function ( source ) {
	
			this.array = new source.array.constructor( source.array );
			this.itemSize = source.itemSize;
	
			this.dynamic = source.dynamic;
	
			return this;
	
		},
	
		copyAt: function ( index1, attribute, index2 ) {
	
			index1 *= this.itemSize;
			index2 *= attribute.itemSize;
	
			for ( var i = 0, l = this.itemSize; i < l; i ++ ) {
	
				this.array[ index1 + i ] = attribute.array[ index2 + i ];
	
			}
	
			return this;
	
		},
	
		copyArray: function ( array ) {
	
			this.array.set( array );
	
			return this;
	
		},
	
		copyColorsArray: function ( colors ) {
	
			var array = this.array, offset = 0;
	
			for ( var i = 0, l = colors.length; i < l; i ++ ) {
	
				var color = colors[ i ];
	
				if ( color === undefined ) {
	
					console.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );
					color = new THREE.Color();
	
				}
	
				array[ offset ++ ] = color.r;
				array[ offset ++ ] = color.g;
				array[ offset ++ ] = color.b;
	
			}
	
			return this;
	
		},
	
		copyIndicesArray: function ( indices ) {
	
			var array = this.array, offset = 0;
	
			for ( var i = 0, l = indices.length; i < l; i ++ ) {
	
				var index = indices[ i ];
	
				array[ offset ++ ] = index.a;
				array[ offset ++ ] = index.b;
				array[ offset ++ ] = index.c;
	
			}
	
			return this;
	
		},
	
		copyVector2sArray: function ( vectors ) {
	
			var array = this.array, offset = 0;
	
			for ( var i = 0, l = vectors.length; i < l; i ++ ) {
	
				var vector = vectors[ i ];
	
				if ( vector === undefined ) {
	
					console.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );
					vector = new THREE.Vector2();
	
				}
	
				array[ offset ++ ] = vector.x;
				array[ offset ++ ] = vector.y;
	
			}
	
			return this;
	
		},
	
		copyVector3sArray: function ( vectors ) {
	
			var array = this.array, offset = 0;
	
			for ( var i = 0, l = vectors.length; i < l; i ++ ) {
	
				var vector = vectors[ i ];
	
				if ( vector === undefined ) {
	
					console.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );
					vector = new THREE.Vector3();
	
				}
	
				array[ offset ++ ] = vector.x;
				array[ offset ++ ] = vector.y;
				array[ offset ++ ] = vector.z;
	
			}
	
			return this;
	
		},
	
		copyVector4sArray: function ( vectors ) {
	
			var array = this.array, offset = 0;
	
			for ( var i = 0, l = vectors.length; i < l; i ++ ) {
	
				var vector = vectors[ i ];
	
				if ( vector === undefined ) {
	
					console.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );
					vector = new THREE.Vector4();
	
				}
	
				array[ offset ++ ] = vector.x;
				array[ offset ++ ] = vector.y;
				array[ offset ++ ] = vector.z;
				array[ offset ++ ] = vector.w;
	
			}
	
			return this;
	
		},
	
		set: function ( value, offset ) {
	
			if ( offset === undefined ) offset = 0;
	
			this.array.set( value, offset );
	
			return this;
	
		},
	
		getX: function ( index ) {
	
			return this.array[ index * this.itemSize ];
	
		},
	
		setX: function ( index, x ) {
	
			this.array[ index * this.itemSize ] = x;
	
			return this;
	
		},
	
		getY: function ( index ) {
	
			return this.array[ index * this.itemSize + 1 ];
	
		},
	
		setY: function ( index, y ) {
	
			this.array[ index * this.itemSize + 1 ] = y;
	
			return this;
	
		},
	
		getZ: function ( index ) {
	
			return this.array[ index * this.itemSize + 2 ];
	
		},
	
		setZ: function ( index, z ) {
	
			this.array[ index * this.itemSize + 2 ] = z;
	
			return this;
	
		},
	
		getW: function ( index ) {
	
			return this.array[ index * this.itemSize + 3 ];
	
		},
	
		setW: function ( index, w ) {
	
			this.array[ index * this.itemSize + 3 ] = w;
	
			return this;
	
		},
	
		setXY: function ( index, x, y ) {
	
			index *= this.itemSize;
	
			this.array[ index + 0 ] = x;
			this.array[ index + 1 ] = y;
	
			return this;
	
		},
	
		setXYZ: function ( index, x, y, z ) {
	
			index *= this.itemSize;
	
			this.array[ index + 0 ] = x;
			this.array[ index + 1 ] = y;
			this.array[ index + 2 ] = z;
	
			return this;
	
		},
	
		setXYZW: function ( index, x, y, z, w ) {
	
			index *= this.itemSize;
	
			this.array[ index + 0 ] = x;
			this.array[ index + 1 ] = y;
			this.array[ index + 2 ] = z;
			this.array[ index + 3 ] = w;
	
			return this;
	
		},
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		}
	
	};
	
	//
	
	THREE.Int8Attribute = function ( array, itemSize ) {
	
		return new THREE.BufferAttribute( new Int8Array( array ), itemSize );
	
	};
	
	THREE.Uint8Attribute = function ( array, itemSize ) {
	
		return new THREE.BufferAttribute( new Uint8Array( array ), itemSize );
	
	};
	
	THREE.Uint8ClampedAttribute = function ( array, itemSize ) {
	
		return new THREE.BufferAttribute( new Uint8ClampedArray( array ), itemSize );
	
	};
	
	THREE.Int16Attribute = function ( array, itemSize ) {
	
		return new THREE.BufferAttribute( new Int16Array( array ), itemSize );
	
	};
	
	THREE.Uint16Attribute = function ( array, itemSize ) {
	
		return new THREE.BufferAttribute( new Uint16Array( array ), itemSize );
	
	};
	
	THREE.Int32Attribute = function ( array, itemSize ) {
	
		return new THREE.BufferAttribute( new Int32Array( array ), itemSize );
	
	};
	
	THREE.Uint32Attribute = function ( array, itemSize ) {
	
		return new THREE.BufferAttribute( new Uint32Array( array ), itemSize );
	
	};
	
	THREE.Float32Attribute = function ( array, itemSize ) {
	
		return new THREE.BufferAttribute( new Float32Array( array ), itemSize );
	
	};
	
	THREE.Float64Attribute = function ( array, itemSize ) {
	
		return new THREE.BufferAttribute( new Float64Array( array ), itemSize );
	
	};
	
	
	// Deprecated
	
	THREE.DynamicBufferAttribute = function ( array, itemSize ) {
	
		console.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.' );
		return new THREE.BufferAttribute( array, itemSize ).setDynamic( true );
	
	};
	
	// File:src/core/InstancedBufferAttribute.js
	
	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */
	
	THREE.InstancedBufferAttribute = function ( array, itemSize, meshPerAttribute ) {
	
		THREE.BufferAttribute.call( this, array, itemSize );
	
		this.meshPerAttribute = meshPerAttribute || 1;
	
	};
	
	THREE.InstancedBufferAttribute.prototype = Object.create( THREE.BufferAttribute.prototype );
	THREE.InstancedBufferAttribute.prototype.constructor = THREE.InstancedBufferAttribute;
	
	THREE.InstancedBufferAttribute.prototype.copy = function ( source ) {
	
		THREE.BufferAttribute.prototype.copy.call( this, source );
	
		this.meshPerAttribute = source.meshPerAttribute;
	
		return this;
	
	};
	
	// File:src/core/InterleavedBuffer.js
	
	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */
	
	THREE.InterleavedBuffer = function ( array, stride ) {
	
		this.uuid = THREE.Math.generateUUID();
	
		this.array = array;
		this.stride = stride;
	
		this.dynamic = false;
		this.updateRange = { offset: 0, count: - 1 };
	
		this.version = 0;
	
	};
	
	THREE.InterleavedBuffer.prototype = {
	
		constructor: THREE.InterleavedBuffer,
	
		get length () {
	
			return this.array.length;
	
		},
	
		get count () {
	
			return this.array.length / this.stride;
	
		},
	
		set needsUpdate( value ) {
	
			if ( value === true ) this.version ++;
	
		},
	
		setDynamic: function ( value ) {
	
			this.dynamic = value;
	
			return this;
	
		},
	
		copy: function ( source ) {
	
			this.array = new source.array.constructor( source.array );
			this.stride = source.stride;
			this.dynamic = source.dynamic;
	
			return this;
	
		},
	
		copyAt: function ( index1, attribute, index2 ) {
	
			index1 *= this.stride;
			index2 *= attribute.stride;
	
			for ( var i = 0, l = this.stride; i < l; i ++ ) {
	
				this.array[ index1 + i ] = attribute.array[ index2 + i ];
	
			}
	
			return this;
	
		},
	
		set: function ( value, offset ) {
	
			if ( offset === undefined ) offset = 0;
	
			this.array.set( value, offset );
	
			return this;
	
		},
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		}
	
	};
	
	// File:src/core/InstancedInterleavedBuffer.js
	
	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */
	
	THREE.InstancedInterleavedBuffer = function ( array, stride, meshPerAttribute ) {
	
		THREE.InterleavedBuffer.call( this, array, stride );
	
		this.meshPerAttribute = meshPerAttribute || 1;
	
	};
	
	THREE.InstancedInterleavedBuffer.prototype = Object.create( THREE.InterleavedBuffer.prototype );
	THREE.InstancedInterleavedBuffer.prototype.constructor = THREE.InstancedInterleavedBuffer;
	
	THREE.InstancedInterleavedBuffer.prototype.copy = function ( source ) {
	
		THREE.InterleavedBuffer.prototype.copy.call( this, source );
	
		this.meshPerAttribute = source.meshPerAttribute;
	
		return this;
	
	};
	
	// File:src/core/InterleavedBufferAttribute.js
	
	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */
	
	THREE.InterleavedBufferAttribute = function ( interleavedBuffer, itemSize, offset ) {
	
		this.uuid = THREE.Math.generateUUID();
	
		this.data = interleavedBuffer;
		this.itemSize = itemSize;
		this.offset = offset;
	
	};
	
	
	THREE.InterleavedBufferAttribute.prototype = {
	
		constructor: THREE.InterleavedBufferAttribute,
	
		get length() {
	
			console.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );
			return this.array.length;
	
		},
	
		get count() {
	
			return this.data.count;
	
		},
	
		setX: function ( index, x ) {
	
			this.data.array[ index * this.data.stride + this.offset ] = x;
	
			return this;
	
		},
	
		setY: function ( index, y ) {
	
			this.data.array[ index * this.data.stride + this.offset + 1 ] = y;
	
			return this;
	
		},
	
		setZ: function ( index, z ) {
	
			this.data.array[ index * this.data.stride + this.offset + 2 ] = z;
	
			return this;
	
		},
	
		setW: function ( index, w ) {
	
			this.data.array[ index * this.data.stride + this.offset + 3 ] = w;
	
			return this;
	
		},
	
		getX: function ( index ) {
	
			return this.data.array[ index * this.data.stride + this.offset ];
	
		},
	
		getY: function ( index ) {
	
			return this.data.array[ index * this.data.stride + this.offset + 1 ];
	
		},
	
		getZ: function ( index ) {
	
			return this.data.array[ index * this.data.stride + this.offset + 2 ];
	
		},
	
		getW: function ( index ) {
	
			return this.data.array[ index * this.data.stride + this.offset + 3 ];
	
		},
	
		setXY: function ( index, x, y ) {
	
			index = index * this.data.stride + this.offset;
	
			this.data.array[ index + 0 ] = x;
			this.data.array[ index + 1 ] = y;
	
			return this;
	
		},
	
		setXYZ: function ( index, x, y, z ) {
	
			index = index * this.data.stride + this.offset;
	
			this.data.array[ index + 0 ] = x;
			this.data.array[ index + 1 ] = y;
			this.data.array[ index + 2 ] = z;
	
			return this;
	
		},
	
		setXYZW: function ( index, x, y, z, w ) {
	
			index = index * this.data.stride + this.offset;
	
			this.data.array[ index + 0 ] = x;
			this.data.array[ index + 1 ] = y;
			this.data.array[ index + 2 ] = z;
			this.data.array[ index + 3 ] = w;
	
			return this;
	
		}
	
	};
	
	// File:src/core/Geometry.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author kile / http://kile.stravaganza.org/
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author bhouston / http://clara.io
	 */
	
	THREE.Geometry = function () {
	
		Object.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );
	
		this.uuid = THREE.Math.generateUUID();
	
		this.name = '';
		this.type = 'Geometry';
	
		this.vertices = [];
		this.colors = [];
		this.faces = [];
		this.faceVertexUvs = [ [] ];
	
		this.morphTargets = [];
		this.morphNormals = [];
	
		this.skinWeights = [];
		this.skinIndices = [];
	
		this.lineDistances = [];
	
		this.boundingBox = null;
		this.boundingSphere = null;
	
		// update flags
	
		this.verticesNeedUpdate = false;
		this.elementsNeedUpdate = false;
		this.uvsNeedUpdate = false;
		this.normalsNeedUpdate = false;
		this.colorsNeedUpdate = false;
		this.lineDistancesNeedUpdate = false;
		this.groupsNeedUpdate = false;
	
	};
	
	THREE.Geometry.prototype = {
	
		constructor: THREE.Geometry,
	
		applyMatrix: function ( matrix ) {
	
			var normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );
	
			for ( var i = 0, il = this.vertices.length; i < il; i ++ ) {
	
				var vertex = this.vertices[ i ];
				vertex.applyMatrix4( matrix );
	
			}
	
			for ( var i = 0, il = this.faces.length; i < il; i ++ ) {
	
				var face = this.faces[ i ];
				face.normal.applyMatrix3( normalMatrix ).normalize();
	
				for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {
	
					face.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();
	
				}
	
			}
	
			if ( this.boundingBox !== null ) {
	
				this.computeBoundingBox();
	
			}
	
			if ( this.boundingSphere !== null ) {
	
				this.computeBoundingSphere();
	
			}
	
			this.verticesNeedUpdate = true;
			this.normalsNeedUpdate = true;
	
		},
	
		rotateX: function () {
	
			// rotate geometry around world x-axis
	
			var m1;
	
			return function rotateX( angle ) {
	
				if ( m1 === undefined ) m1 = new THREE.Matrix4();
	
				m1.makeRotationX( angle );
	
				this.applyMatrix( m1 );
	
				return this;
	
			};
	
		}(),
	
		rotateY: function () {
	
			// rotate geometry around world y-axis
	
			var m1;
	
			return function rotateY( angle ) {
	
				if ( m1 === undefined ) m1 = new THREE.Matrix4();
	
				m1.makeRotationY( angle );
	
				this.applyMatrix( m1 );
	
				return this;
	
			};
	
		}(),
	
		rotateZ: function () {
	
			// rotate geometry around world z-axis
	
			var m1;
	
			return function rotateZ( angle ) {
	
				if ( m1 === undefined ) m1 = new THREE.Matrix4();
	
				m1.makeRotationZ( angle );
	
				this.applyMatrix( m1 );
	
				return this;
	
			};
	
		}(),
	
		translate: function () {
	
			// translate geometry
	
			var m1;
	
			return function translate( x, y, z ) {
	
				if ( m1 === undefined ) m1 = new THREE.Matrix4();
	
				m1.makeTranslation( x, y, z );
	
				this.applyMatrix( m1 );
	
				return this;
	
			};
	
		}(),
	
		scale: function () {
	
			// scale geometry
	
			var m1;
	
			return function scale( x, y, z ) {
	
				if ( m1 === undefined ) m1 = new THREE.Matrix4();
	
				m1.makeScale( x, y, z );
	
				this.applyMatrix( m1 );
	
				return this;
	
			};
	
		}(),
	
		lookAt: function () {
	
			var obj;
	
			return function lookAt( vector ) {
	
				if ( obj === undefined ) obj = new THREE.Object3D();
	
				obj.lookAt( vector );
	
				obj.updateMatrix();
	
				this.applyMatrix( obj.matrix );
	
			};
	
		}(),
	
		fromBufferGeometry: function ( geometry ) {
	
			var scope = this;
	
			var indices = geometry.index !== null ? geometry.index.array : undefined;
			var attributes = geometry.attributes;
	
			var positions = attributes.position.array;
			var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
			var colors = attributes.color !== undefined ? attributes.color.array : undefined;
			var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
			var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;
	
			if ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];
	
			var tempNormals = [];
			var tempUVs = [];
			var tempUVs2 = [];
	
			for ( var i = 0, j = 0; i < positions.length; i += 3, j += 2 ) {
	
				scope.vertices.push( new THREE.Vector3( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] ) );
	
				if ( normals !== undefined ) {
	
					tempNormals.push( new THREE.Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );
	
				}
	
				if ( colors !== undefined ) {
	
					scope.colors.push( new THREE.Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );
	
				}
	
				if ( uvs !== undefined ) {
	
					tempUVs.push( new THREE.Vector2( uvs[ j ], uvs[ j + 1 ] ) );
	
				}
	
				if ( uvs2 !== undefined ) {
	
					tempUVs2.push( new THREE.Vector2( uvs2[ j ], uvs2[ j + 1 ] ) );
	
				}
	
			}
	
			function addFace( a, b, c ) {
	
				var vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];
				var vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];
	
				var face = new THREE.Face3( a, b, c, vertexNormals, vertexColors );
	
				scope.faces.push( face );
	
				if ( uvs !== undefined ) {
	
					scope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );
	
				}
	
				if ( uvs2 !== undefined ) {
	
					scope.faceVertexUvs[ 1 ].push( [ tempUVs2[ a ].clone(), tempUVs2[ b ].clone(), tempUVs2[ c ].clone() ] );
	
				}
	
			}
	
			if ( indices !== undefined ) {
	
				var groups = geometry.groups;
	
				if ( groups.length > 0 ) {
	
					for ( var i = 0; i < groups.length; i ++ ) {
	
						var group = groups[ i ];
	
						var start = group.start;
						var count = group.count;
	
						for ( var j = start, jl = start + count; j < jl; j += 3 ) {
	
							addFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ] );
	
						}
	
					}
	
				} else {
	
					for ( var i = 0; i < indices.length; i += 3 ) {
	
						addFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );
	
					}
	
				}
	
			} else {
	
				for ( var i = 0; i < positions.length / 3; i += 3 ) {
	
					addFace( i, i + 1, i + 2 );
	
				}
	
			}
	
			this.computeFaceNormals();
	
			if ( geometry.boundingBox !== null ) {
	
				this.boundingBox = geometry.boundingBox.clone();
	
			}
	
			if ( geometry.boundingSphere !== null ) {
	
				this.boundingSphere = geometry.boundingSphere.clone();
	
			}
	
			return this;
	
		},
	
		center: function () {
	
			this.computeBoundingBox();
	
			var offset = this.boundingBox.center().negate();
	
			this.translate( offset.x, offset.y, offset.z );
	
			return offset;
	
		},
	
		normalize: function () {
	
			this.computeBoundingSphere();
	
			var center = this.boundingSphere.center;
			var radius = this.boundingSphere.radius;
	
			var s = radius === 0 ? 1 : 1.0 / radius;
	
			var matrix = new THREE.Matrix4();
			matrix.set(
				s, 0, 0, - s * center.x,
				0, s, 0, - s * center.y,
				0, 0, s, - s * center.z,
				0, 0, 0, 1
			);
	
			this.applyMatrix( matrix );
	
			return this;
	
		},
	
		computeFaceNormals: function () {
	
			var cb = new THREE.Vector3(), ab = new THREE.Vector3();
	
			for ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
				var face = this.faces[ f ];
	
				var vA = this.vertices[ face.a ];
				var vB = this.vertices[ face.b ];
				var vC = this.vertices[ face.c ];
	
				cb.subVectors( vC, vB );
				ab.subVectors( vA, vB );
				cb.cross( ab );
	
				cb.normalize();
	
				face.normal.copy( cb );
	
			}
	
		},
	
		computeVertexNormals: function ( areaWeighted ) {
	
			if ( areaWeighted === undefined ) areaWeighted = true;
	
			var v, vl, f, fl, face, vertices;
	
			vertices = new Array( this.vertices.length );
	
			for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {
	
				vertices[ v ] = new THREE.Vector3();
	
			}
	
			if ( areaWeighted ) {
	
				// vertex normals weighted by triangle areas
				// http://www.iquilezles.org/www/articles/normals/normals.htm
	
				var vA, vB, vC;
				var cb = new THREE.Vector3(), ab = new THREE.Vector3();
	
				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
					face = this.faces[ f ];
	
					vA = this.vertices[ face.a ];
					vB = this.vertices[ face.b ];
					vC = this.vertices[ face.c ];
	
					cb.subVectors( vC, vB );
					ab.subVectors( vA, vB );
					cb.cross( ab );
	
					vertices[ face.a ].add( cb );
					vertices[ face.b ].add( cb );
					vertices[ face.c ].add( cb );
	
				}
	
			} else {
	
				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
					face = this.faces[ f ];
	
					vertices[ face.a ].add( face.normal );
					vertices[ face.b ].add( face.normal );
					vertices[ face.c ].add( face.normal );
	
				}
	
			}
	
			for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {
	
				vertices[ v ].normalize();
	
			}
	
			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
				face = this.faces[ f ];
	
				var vertexNormals = face.vertexNormals;
	
				if ( vertexNormals.length === 3 ) {
	
					vertexNormals[ 0 ].copy( vertices[ face.a ] );
					vertexNormals[ 1 ].copy( vertices[ face.b ] );
					vertexNormals[ 2 ].copy( vertices[ face.c ] );
	
				} else {
	
					vertexNormals[ 0 ] = vertices[ face.a ].clone();
					vertexNormals[ 1 ] = vertices[ face.b ].clone();
					vertexNormals[ 2 ] = vertices[ face.c ].clone();
	
				}
	
			}
	
			if ( this.faces.length > 0 ) {
	
				this.normalsNeedUpdate = true;
	
			}
	
		},
	
		computeMorphNormals: function () {
	
			var i, il, f, fl, face;
	
			// save original normals
			// - create temp variables on first access
			//   otherwise just copy (for faster repeated calls)
	
			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
				face = this.faces[ f ];
	
				if ( ! face.__originalFaceNormal ) {
	
					face.__originalFaceNormal = face.normal.clone();
	
				} else {
	
					face.__originalFaceNormal.copy( face.normal );
	
				}
	
				if ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];
	
				for ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {
	
					if ( ! face.__originalVertexNormals[ i ] ) {
	
						face.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();
	
					} else {
	
						face.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );
	
					}
	
				}
	
			}
	
			// use temp geometry to compute face and vertex normals for each morph
	
			var tmpGeo = new THREE.Geometry();
			tmpGeo.faces = this.faces;
	
			for ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {
	
				// create on first access
	
				if ( ! this.morphNormals[ i ] ) {
	
					this.morphNormals[ i ] = {};
					this.morphNormals[ i ].faceNormals = [];
					this.morphNormals[ i ].vertexNormals = [];
	
					var dstNormalsFace = this.morphNormals[ i ].faceNormals;
					var dstNormalsVertex = this.morphNormals[ i ].vertexNormals;
	
					var faceNormal, vertexNormals;
	
					for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
						faceNormal = new THREE.Vector3();
						vertexNormals = { a: new THREE.Vector3(), b: new THREE.Vector3(), c: new THREE.Vector3() };
	
						dstNormalsFace.push( faceNormal );
						dstNormalsVertex.push( vertexNormals );
	
					}
	
				}
	
				var morphNormals = this.morphNormals[ i ];
	
				// set vertices to morph target
	
				tmpGeo.vertices = this.morphTargets[ i ].vertices;
	
				// compute morph normals
	
				tmpGeo.computeFaceNormals();
				tmpGeo.computeVertexNormals();
	
				// store morph normals
	
				var faceNormal, vertexNormals;
	
				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
					face = this.faces[ f ];
	
					faceNormal = morphNormals.faceNormals[ f ];
					vertexNormals = morphNormals.vertexNormals[ f ];
	
					faceNormal.copy( face.normal );
	
					vertexNormals.a.copy( face.vertexNormals[ 0 ] );
					vertexNormals.b.copy( face.vertexNormals[ 1 ] );
					vertexNormals.c.copy( face.vertexNormals[ 2 ] );
	
				}
	
			}
	
			// restore original normals
	
			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
				face = this.faces[ f ];
	
				face.normal = face.__originalFaceNormal;
				face.vertexNormals = face.__originalVertexNormals;
	
			}
	
		},
	
		computeTangents: function () {
	
			console.warn( 'THREE.Geometry: .computeTangents() has been removed.' );
	
		},
	
		computeLineDistances: function () {
	
			var d = 0;
			var vertices = this.vertices;
	
			for ( var i = 0, il = vertices.length; i < il; i ++ ) {
	
				if ( i > 0 ) {
	
					d += vertices[ i ].distanceTo( vertices[ i - 1 ] );
	
				}
	
				this.lineDistances[ i ] = d;
	
			}
	
		},
	
		computeBoundingBox: function () {
	
			if ( this.boundingBox === null ) {
	
				this.boundingBox = new THREE.Box3();
	
			}
	
			this.boundingBox.setFromPoints( this.vertices );
	
		},
	
		computeBoundingSphere: function () {
	
			if ( this.boundingSphere === null ) {
	
				this.boundingSphere = new THREE.Sphere();
	
			}
	
			this.boundingSphere.setFromPoints( this.vertices );
	
		},
	
		merge: function ( geometry, matrix, materialIndexOffset ) {
	
			if ( geometry instanceof THREE.Geometry === false ) {
	
				console.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );
				return;
	
			}
	
			var normalMatrix,
			vertexOffset = this.vertices.length,
			vertices1 = this.vertices,
			vertices2 = geometry.vertices,
			faces1 = this.faces,
			faces2 = geometry.faces,
			uvs1 = this.faceVertexUvs[ 0 ],
			uvs2 = geometry.faceVertexUvs[ 0 ];
	
			if ( materialIndexOffset === undefined ) materialIndexOffset = 0;
	
			if ( matrix !== undefined ) {
	
				normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );
	
			}
	
			// vertices
	
			for ( var i = 0, il = vertices2.length; i < il; i ++ ) {
	
				var vertex = vertices2[ i ];
	
				var vertexCopy = vertex.clone();
	
				if ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );
	
				vertices1.push( vertexCopy );
	
			}
	
			// faces
	
			for ( i = 0, il = faces2.length; i < il; i ++ ) {
	
				var face = faces2[ i ], faceCopy, normal, color,
				faceVertexNormals = face.vertexNormals,
				faceVertexColors = face.vertexColors;
	
				faceCopy = new THREE.Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );
				faceCopy.normal.copy( face.normal );
	
				if ( normalMatrix !== undefined ) {
	
					faceCopy.normal.applyMatrix3( normalMatrix ).normalize();
	
				}
	
				for ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {
	
					normal = faceVertexNormals[ j ].clone();
	
					if ( normalMatrix !== undefined ) {
	
						normal.applyMatrix3( normalMatrix ).normalize();
	
					}
	
					faceCopy.vertexNormals.push( normal );
	
				}
	
				faceCopy.color.copy( face.color );
	
				for ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {
	
					color = faceVertexColors[ j ];
					faceCopy.vertexColors.push( color.clone() );
	
				}
	
				faceCopy.materialIndex = face.materialIndex + materialIndexOffset;
	
				faces1.push( faceCopy );
	
			}
	
			// uvs
	
			for ( i = 0, il = uvs2.length; i < il; i ++ ) {
	
				var uv = uvs2[ i ], uvCopy = [];
	
				if ( uv === undefined ) {
	
					continue;
	
				}
	
				for ( var j = 0, jl = uv.length; j < jl; j ++ ) {
	
					uvCopy.push( uv[ j ].clone() );
	
				}
	
				uvs1.push( uvCopy );
	
			}
	
		},
	
		mergeMesh: function ( mesh ) {
	
			if ( mesh instanceof THREE.Mesh === false ) {
	
				console.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );
				return;
	
			}
	
			mesh.matrixAutoUpdate && mesh.updateMatrix();
	
			this.merge( mesh.geometry, mesh.matrix );
	
		},
	
		/*
		 * Checks for duplicate vertices with hashmap.
		 * Duplicated vertices are removed
		 * and faces' vertices are updated.
		 */
	
		mergeVertices: function () {
	
			var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)
			var unique = [], changes = [];
	
			var v, key;
			var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001
			var precision = Math.pow( 10, precisionPoints );
			var i, il, face;
			var indices, j, jl;
	
			for ( i = 0, il = this.vertices.length; i < il; i ++ ) {
	
				v = this.vertices[ i ];
				key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );
	
				if ( verticesMap[ key ] === undefined ) {
	
					verticesMap[ key ] = i;
					unique.push( this.vertices[ i ] );
					changes[ i ] = unique.length - 1;
	
				} else {
	
					//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
					changes[ i ] = changes[ verticesMap[ key ] ];
	
				}
	
			}
	
	
			// if faces are completely degenerate after merging vertices, we
			// have to remove them from the geometry.
			var faceIndicesToRemove = [];
	
			for ( i = 0, il = this.faces.length; i < il; i ++ ) {
	
				face = this.faces[ i ];
	
				face.a = changes[ face.a ];
				face.b = changes[ face.b ];
				face.c = changes[ face.c ];
	
				indices = [ face.a, face.b, face.c ];
	
				var dupIndex = - 1;
	
				// if any duplicate vertices are found in a Face3
				// we have to remove the face as nothing can be saved
				for ( var n = 0; n < 3; n ++ ) {
	
					if ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {
	
						dupIndex = n;
						faceIndicesToRemove.push( i );
						break;
	
					}
	
				}
	
			}
	
			for ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {
	
				var idx = faceIndicesToRemove[ i ];
	
				this.faces.splice( idx, 1 );
	
				for ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {
	
					this.faceVertexUvs[ j ].splice( idx, 1 );
	
				}
	
			}
	
			// Use unique set of vertices
	
			var diff = this.vertices.length - unique.length;
			this.vertices = unique;
			return diff;
	
		},
	
		sortFacesByMaterialIndex: function () {
	
			var faces = this.faces;
			var length = faces.length;
	
			// tag faces
	
			for ( var i = 0; i < length; i ++ ) {
	
				faces[ i ]._id = i;
	
			}
	
			// sort faces
	
			function materialIndexSort( a, b ) {
	
				return a.materialIndex - b.materialIndex;
	
			}
	
			faces.sort( materialIndexSort );
	
			// sort uvs
	
			var uvs1 = this.faceVertexUvs[ 0 ];
			var uvs2 = this.faceVertexUvs[ 1 ];
	
			var newUvs1, newUvs2;
	
			if ( uvs1 && uvs1.length === length ) newUvs1 = [];
			if ( uvs2 && uvs2.length === length ) newUvs2 = [];
	
			for ( var i = 0; i < length; i ++ ) {
	
				var id = faces[ i ]._id;
	
				if ( newUvs1 ) newUvs1.push( uvs1[ id ] );
				if ( newUvs2 ) newUvs2.push( uvs2[ id ] );
	
			}
	
			if ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;
			if ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;
	
		},
	
		toJSON: function () {
	
			var data = {
				metadata: {
					version: 4.4,
					type: 'Geometry',
					generator: 'Geometry.toJSON'
				}
			};
	
			// standard Geometry serialization
	
			data.uuid = this.uuid;
			data.type = this.type;
			if ( this.name !== '' ) data.name = this.name;
	
			if ( this.parameters !== undefined ) {
	
				var parameters = this.parameters;
	
				for ( var key in parameters ) {
	
					if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];
	
				}
	
				return data;
	
			}
	
			var vertices = [];
	
			for ( var i = 0; i < this.vertices.length; i ++ ) {
	
				var vertex = this.vertices[ i ];
				vertices.push( vertex.x, vertex.y, vertex.z );
	
			}
	
			var faces = [];
			var normals = [];
			var normalsHash = {};
			var colors = [];
			var colorsHash = {};
			var uvs = [];
			var uvsHash = {};
	
			for ( var i = 0; i < this.faces.length; i ++ ) {
	
				var face = this.faces[ i ];
	
				var hasMaterial = true;
				var hasFaceUv = false; // deprecated
				var hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;
				var hasFaceNormal = face.normal.length() > 0;
				var hasFaceVertexNormal = face.vertexNormals.length > 0;
				var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
				var hasFaceVertexColor = face.vertexColors.length > 0;
	
				var faceType = 0;
	
				faceType = setBit( faceType, 0, 0 ); // isQuad
				faceType = setBit( faceType, 1, hasMaterial );
				faceType = setBit( faceType, 2, hasFaceUv );
				faceType = setBit( faceType, 3, hasFaceVertexUv );
				faceType = setBit( faceType, 4, hasFaceNormal );
				faceType = setBit( faceType, 5, hasFaceVertexNormal );
				faceType = setBit( faceType, 6, hasFaceColor );
				faceType = setBit( faceType, 7, hasFaceVertexColor );
	
				faces.push( faceType );
				faces.push( face.a, face.b, face.c );
				faces.push( face.materialIndex );
	
				if ( hasFaceVertexUv ) {
	
					var faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];
	
					faces.push(
						getUvIndex( faceVertexUvs[ 0 ] ),
						getUvIndex( faceVertexUvs[ 1 ] ),
						getUvIndex( faceVertexUvs[ 2 ] )
					);
	
				}
	
				if ( hasFaceNormal ) {
	
					faces.push( getNormalIndex( face.normal ) );
	
				}
	
				if ( hasFaceVertexNormal ) {
	
					var vertexNormals = face.vertexNormals;
	
					faces.push(
						getNormalIndex( vertexNormals[ 0 ] ),
						getNormalIndex( vertexNormals[ 1 ] ),
						getNormalIndex( vertexNormals[ 2 ] )
					);
	
				}
	
				if ( hasFaceColor ) {
	
					faces.push( getColorIndex( face.color ) );
	
				}
	
				if ( hasFaceVertexColor ) {
	
					var vertexColors = face.vertexColors;
	
					faces.push(
						getColorIndex( vertexColors[ 0 ] ),
						getColorIndex( vertexColors[ 1 ] ),
						getColorIndex( vertexColors[ 2 ] )
					);
	
				}
	
			}
	
			function setBit( value, position, enabled ) {
	
				return enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );
	
			}
	
			function getNormalIndex( normal ) {
	
				var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();
	
				if ( normalsHash[ hash ] !== undefined ) {
	
					return normalsHash[ hash ];
	
				}
	
				normalsHash[ hash ] = normals.length / 3;
				normals.push( normal.x, normal.y, normal.z );
	
				return normalsHash[ hash ];
	
			}
	
			function getColorIndex( color ) {
	
				var hash = color.r.toString() + color.g.toString() + color.b.toString();
	
				if ( colorsHash[ hash ] !== undefined ) {
	
					return colorsHash[ hash ];
	
				}
	
				colorsHash[ hash ] = colors.length;
				colors.push( color.getHex() );
	
				return colorsHash[ hash ];
	
			}
	
			function getUvIndex( uv ) {
	
				var hash = uv.x.toString() + uv.y.toString();
	
				if ( uvsHash[ hash ] !== undefined ) {
	
					return uvsHash[ hash ];
	
				}
	
				uvsHash[ hash ] = uvs.length / 2;
				uvs.push( uv.x, uv.y );
	
				return uvsHash[ hash ];
	
			}
	
			data.data = {};
	
			data.data.vertices = vertices;
			data.data.normals = normals;
			if ( colors.length > 0 ) data.data.colors = colors;
			if ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility
			data.data.faces = faces;
	
			return data;
	
		},
	
		clone: function () {
	
			/*
			// Handle primitives
	
			var parameters = this.parameters;
	
			if ( parameters !== undefined ) {
	
				var values = [];
	
				for ( var key in parameters ) {
	
					values.push( parameters[ key ] );
	
				}
	
				var geometry = Object.create( this.constructor.prototype );
				this.constructor.apply( geometry, values );
				return geometry;
	
			}
	
			return new this.constructor().copy( this );
			*/
	
			return new THREE.Geometry().copy( this );
	
		},
	
		copy: function ( source ) {
	
			this.vertices = [];
			this.faces = [];
			this.faceVertexUvs = [ [] ];
	
			var vertices = source.vertices;
	
			for ( var i = 0, il = vertices.length; i < il; i ++ ) {
	
				this.vertices.push( vertices[ i ].clone() );
	
			}
	
			var faces = source.faces;
	
			for ( var i = 0, il = faces.length; i < il; i ++ ) {
	
				this.faces.push( faces[ i ].clone() );
	
			}
	
			for ( var i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {
	
				var faceVertexUvs = source.faceVertexUvs[ i ];
	
				if ( this.faceVertexUvs[ i ] === undefined ) {
	
					this.faceVertexUvs[ i ] = [];
	
				}
	
				for ( var j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {
	
					var uvs = faceVertexUvs[ j ], uvsCopy = [];
	
					for ( var k = 0, kl = uvs.length; k < kl; k ++ ) {
	
						var uv = uvs[ k ];
	
						uvsCopy.push( uv.clone() );
	
					}
	
					this.faceVertexUvs[ i ].push( uvsCopy );
	
				}
	
			}
	
			return this;
	
		},
	
		dispose: function () {
	
			this.dispatchEvent( { type: 'dispose' } );
	
		}
	
	};
	
	THREE.EventDispatcher.prototype.apply( THREE.Geometry.prototype );
	
	THREE.GeometryIdCount = 0;
	
	// File:src/core/DirectGeometry.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.DirectGeometry = function () {
	
		Object.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );
	
		this.uuid = THREE.Math.generateUUID();
	
		this.name = '';
		this.type = 'DirectGeometry';
	
		this.indices = [];
		this.vertices = [];
		this.normals = [];
		this.colors = [];
		this.uvs = [];
		this.uvs2 = [];
	
		this.groups = [];
	
		this.morphTargets = {};
	
		this.skinWeights = [];
		this.skinIndices = [];
	
		// this.lineDistances = [];
	
		this.boundingBox = null;
		this.boundingSphere = null;
	
		// update flags
	
		this.verticesNeedUpdate = false;
		this.normalsNeedUpdate = false;
		this.colorsNeedUpdate = false;
		this.uvsNeedUpdate = false;
		this.groupsNeedUpdate = false;
	
	};
	
	THREE.DirectGeometry.prototype = {
	
		constructor: THREE.DirectGeometry,
	
		computeBoundingBox: THREE.Geometry.prototype.computeBoundingBox,
		computeBoundingSphere: THREE.Geometry.prototype.computeBoundingSphere,
	
		computeFaceNormals: function () {
	
			console.warn( 'THREE.DirectGeometry: computeFaceNormals() is not a method of this type of geometry.' );
	
		},
	
		computeVertexNormals: function () {
	
			console.warn( 'THREE.DirectGeometry: computeVertexNormals() is not a method of this type of geometry.' );
	
		},
	
		computeGroups: function ( geometry ) {
	
			var group;
			var groups = [];
			var materialIndex;
	
			var faces = geometry.faces;
	
			for ( var i = 0; i < faces.length; i ++ ) {
	
				var face = faces[ i ];
	
				// materials
	
				if ( face.materialIndex !== materialIndex ) {
	
					materialIndex = face.materialIndex;
	
					if ( group !== undefined ) {
	
						group.count = ( i * 3 ) - group.start;
						groups.push( group );
	
					}
	
					group = {
						start: i * 3,
						materialIndex: materialIndex
					};
	
				}
	
			}
	
			if ( group !== undefined ) {
	
				group.count = ( i * 3 ) - group.start;
				groups.push( group );
	
			}
	
			this.groups = groups;
	
		},
	
		fromGeometry: function ( geometry ) {
	
			var faces = geometry.faces;
			var vertices = geometry.vertices;
			var faceVertexUvs = geometry.faceVertexUvs;
	
			var hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;
			var hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;
	
			// morphs
	
			var morphTargets = geometry.morphTargets;
			var morphTargetsLength = morphTargets.length;
	
			var morphTargetsPosition;
	
			if ( morphTargetsLength > 0 ) {
	
				morphTargetsPosition = [];
	
				for ( var i = 0; i < morphTargetsLength; i ++ ) {
	
					morphTargetsPosition[ i ] = [];
	
				}
	
				this.morphTargets.position = morphTargetsPosition;
	
			}
	
			var morphNormals = geometry.morphNormals;
			var morphNormalsLength = morphNormals.length;
	
			var morphTargetsNormal;
	
			if ( morphNormalsLength > 0 ) {
	
				morphTargetsNormal = [];
	
				for ( var i = 0; i < morphNormalsLength; i ++ ) {
	
					morphTargetsNormal[ i ] = [];
	
				}
	
				this.morphTargets.normal = morphTargetsNormal;
	
			}
	
			// skins
	
			var skinIndices = geometry.skinIndices;
			var skinWeights = geometry.skinWeights;
	
			var hasSkinIndices = skinIndices.length === vertices.length;
			var hasSkinWeights = skinWeights.length === vertices.length;
	
			//
	
			for ( var i = 0; i < faces.length; i ++ ) {
	
				var face = faces[ i ];
	
				this.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );
	
				var vertexNormals = face.vertexNormals;
	
				if ( vertexNormals.length === 3 ) {
	
					this.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );
	
				} else {
	
					var normal = face.normal;
	
					this.normals.push( normal, normal, normal );
	
				}
	
				var vertexColors = face.vertexColors;
	
				if ( vertexColors.length === 3 ) {
	
					this.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );
	
				} else {
	
					var color = face.color;
	
					this.colors.push( color, color, color );
	
				}
	
				if ( hasFaceVertexUv === true ) {
	
					var vertexUvs = faceVertexUvs[ 0 ][ i ];
	
					if ( vertexUvs !== undefined ) {
	
						this.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );
	
					} else {
	
						console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );
	
						this.uvs.push( new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() );
	
					}
	
				}
	
				if ( hasFaceVertexUv2 === true ) {
	
					var vertexUvs = faceVertexUvs[ 1 ][ i ];
	
					if ( vertexUvs !== undefined ) {
	
						this.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );
	
					} else {
	
						console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );
	
						this.uvs2.push( new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() );
	
					}
	
				}
	
				// morphs
	
				for ( var j = 0; j < morphTargetsLength; j ++ ) {
	
					var morphTarget = morphTargets[ j ].vertices;
	
					morphTargetsPosition[ j ].push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );
	
				}
	
				for ( var j = 0; j < morphNormalsLength; j ++ ) {
	
					var morphNormal = morphNormals[ j ].vertexNormals[ i ];
	
					morphTargetsNormal[ j ].push( morphNormal.a, morphNormal.b, morphNormal.c );
	
				}
	
				// skins
	
				if ( hasSkinIndices ) {
	
					this.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );
	
				}
	
				if ( hasSkinWeights ) {
	
					this.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );
	
				}
	
			}
	
			this.computeGroups( geometry );
	
			this.verticesNeedUpdate = geometry.verticesNeedUpdate;
			this.normalsNeedUpdate = geometry.normalsNeedUpdate;
			this.colorsNeedUpdate = geometry.colorsNeedUpdate;
			this.uvsNeedUpdate = geometry.uvsNeedUpdate;
			this.groupsNeedUpdate = geometry.groupsNeedUpdate;
	
			return this;
	
		},
	
		dispose: function () {
	
			this.dispatchEvent( { type: 'dispose' } );
	
		}
	
	};
	
	THREE.EventDispatcher.prototype.apply( THREE.DirectGeometry.prototype );
	
	// File:src/core/BufferGeometry.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.BufferGeometry = function () {
	
		Object.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );
	
		this.uuid = THREE.Math.generateUUID();
	
		this.name = '';
		this.type = 'BufferGeometry';
	
		this.index = null;
		this.attributes = {};
	
		this.morphAttributes = {};
	
		this.groups = [];
	
		this.boundingBox = null;
		this.boundingSphere = null;
	
		this.drawRange = { start: 0, count: Infinity };
	
	};
	
	THREE.BufferGeometry.prototype = {
	
		constructor: THREE.BufferGeometry,
	
		getIndex: function () {
	
			return this.index;
	
		},
	
		setIndex: function ( index ) {
	
			this.index = index;
	
		},
	
		addAttribute: function ( name, attribute ) {
	
			if ( attribute instanceof THREE.BufferAttribute === false && attribute instanceof THREE.InterleavedBufferAttribute === false ) {
	
				console.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );
	
				this.addAttribute( name, new THREE.BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );
	
				return;
	
			}
	
			if ( name === 'index' ) {
	
				console.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );
				this.setIndex( attribute );
	
				return;
	
			}
	
			this.attributes[ name ] = attribute;
	
			return this;
	
		},
	
		getAttribute: function ( name ) {
	
			return this.attributes[ name ];
	
		},
	
		removeAttribute: function ( name ) {
	
			delete this.attributes[ name ];
	
			return this;
	
		},
	
		addGroup: function ( start, count, materialIndex ) {
	
			this.groups.push( {
	
				start: start,
				count: count,
				materialIndex: materialIndex !== undefined ? materialIndex : 0
	
			} );
	
		},
	
		clearGroups: function () {
	
			this.groups = [];
	
		},
	
		setDrawRange: function ( start, count ) {
	
			this.drawRange.start = start;
			this.drawRange.count = count;
	
		},
	
		applyMatrix: function ( matrix ) {
	
			var position = this.attributes.position;
	
			if ( position !== undefined ) {
	
				matrix.applyToVector3Array( position.array );
				position.needsUpdate = true;
	
			}
	
			var normal = this.attributes.normal;
	
			if ( normal !== undefined ) {
	
				var normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );
	
				normalMatrix.applyToVector3Array( normal.array );
				normal.needsUpdate = true;
	
			}
	
			if ( this.boundingBox !== null ) {
	
				this.computeBoundingBox();
	
			}
	
			if ( this.boundingSphere !== null ) {
	
				this.computeBoundingSphere();
	
			}
	
		},
	
		rotateX: function () {
	
			// rotate geometry around world x-axis
	
			var m1;
	
			return function rotateX( angle ) {
	
				if ( m1 === undefined ) m1 = new THREE.Matrix4();
	
				m1.makeRotationX( angle );
	
				this.applyMatrix( m1 );
	
				return this;
	
			};
	
		}(),
	
		rotateY: function () {
	
			// rotate geometry around world y-axis
	
			var m1;
	
			return function rotateY( angle ) {
	
				if ( m1 === undefined ) m1 = new THREE.Matrix4();
	
				m1.makeRotationY( angle );
	
				this.applyMatrix( m1 );
	
				return this;
	
			};
	
		}(),
	
		rotateZ: function () {
	
			// rotate geometry around world z-axis
	
			var m1;
	
			return function rotateZ( angle ) {
	
				if ( m1 === undefined ) m1 = new THREE.Matrix4();
	
				m1.makeRotationZ( angle );
	
				this.applyMatrix( m1 );
	
				return this;
	
			};
	
		}(),
	
		translate: function () {
	
			// translate geometry
	
			var m1;
	
			return function translate( x, y, z ) {
	
				if ( m1 === undefined ) m1 = new THREE.Matrix4();
	
				m1.makeTranslation( x, y, z );
	
				this.applyMatrix( m1 );
	
				return this;
	
			};
	
		}(),
	
		scale: function () {
	
			// scale geometry
	
			var m1;
	
			return function scale( x, y, z ) {
	
				if ( m1 === undefined ) m1 = new THREE.Matrix4();
	
				m1.makeScale( x, y, z );
	
				this.applyMatrix( m1 );
	
				return this;
	
			};
	
		}(),
	
		lookAt: function () {
	
			var obj;
	
			return function lookAt( vector ) {
	
				if ( obj === undefined ) obj = new THREE.Object3D();
	
				obj.lookAt( vector );
	
				obj.updateMatrix();
	
				this.applyMatrix( obj.matrix );
	
			};
	
		}(),
	
		center: function () {
	
			this.computeBoundingBox();
	
			var offset = this.boundingBox.center().negate();
	
			this.translate( offset.x, offset.y, offset.z );
	
			return offset;
	
		},
	
		setFromObject: function ( object ) {
	
			// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );
	
			var geometry = object.geometry;
	
			if ( object instanceof THREE.Points || object instanceof THREE.Line ) {
	
				var positions = new THREE.Float32Attribute( geometry.vertices.length * 3, 3 );
				var colors = new THREE.Float32Attribute( geometry.colors.length * 3, 3 );
	
				this.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );
				this.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );
	
				if ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {
	
					var lineDistances = new THREE.Float32Attribute( geometry.lineDistances.length, 1 );
	
					this.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );
	
				}
	
				if ( geometry.boundingSphere !== null ) {
	
					this.boundingSphere = geometry.boundingSphere.clone();
	
				}
	
				if ( geometry.boundingBox !== null ) {
	
					this.boundingBox = geometry.boundingBox.clone();
	
				}
	
			} else if ( object instanceof THREE.Mesh ) {
	
				if ( geometry instanceof THREE.Geometry ) {
	
					this.fromGeometry( geometry );
	
				}
	
			}
	
			return this;
	
		},
	
		updateFromObject: function ( object ) {
	
			var geometry = object.geometry;
	
			if ( object instanceof THREE.Mesh ) {
	
				var direct = geometry.__directGeometry;
	
				if ( direct === undefined ) {
	
					return this.fromGeometry( geometry );
	
				}
	
				direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
				direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
				direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
				direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
				direct.groupsNeedUpdate = geometry.groupsNeedUpdate;
	
				geometry.verticesNeedUpdate = false;
				geometry.normalsNeedUpdate = false;
				geometry.colorsNeedUpdate = false;
				geometry.uvsNeedUpdate = false;
				geometry.groupsNeedUpdate = false;
	
				geometry = direct;
	
			}
	
			if ( geometry.verticesNeedUpdate === true ) {
	
				var attribute = this.attributes.position;
	
				if ( attribute !== undefined ) {
	
					attribute.copyVector3sArray( geometry.vertices );
					attribute.needsUpdate = true;
	
				}
	
				geometry.verticesNeedUpdate = false;
	
			}
	
			if ( geometry.normalsNeedUpdate === true ) {
	
				var attribute = this.attributes.normal;
	
				if ( attribute !== undefined ) {
	
					attribute.copyVector3sArray( geometry.normals );
					attribute.needsUpdate = true;
	
				}
	
				geometry.normalsNeedUpdate = false;
	
			}
	
			if ( geometry.colorsNeedUpdate === true ) {
	
				var attribute = this.attributes.color;
	
				if ( attribute !== undefined ) {
	
					attribute.copyColorsArray( geometry.colors );
					attribute.needsUpdate = true;
	
				}
	
				geometry.colorsNeedUpdate = false;
	
			}
	
			if ( geometry.uvsNeedUpdate ) {
	
				var attribute = this.attributes.uv;
	
				if ( attribute !== undefined ) {
	
					attribute.copyVector2sArray( geometry.uvs );
					attribute.needsUpdate = true;
	
				}
	
				geometry.uvsNeedUpdate = false;
	
			}
	
			if ( geometry.lineDistancesNeedUpdate ) {
	
				var attribute = this.attributes.lineDistance;
	
				if ( attribute !== undefined ) {
	
					attribute.copyArray( geometry.lineDistances );
					attribute.needsUpdate = true;
	
				}
	
				geometry.lineDistancesNeedUpdate = false;
	
			}
	
			if ( geometry.groupsNeedUpdate ) {
	
				geometry.computeGroups( object.geometry );
				this.groups = geometry.groups;
	
				geometry.groupsNeedUpdate = false;
	
			}
	
			return this;
	
		},
	
		fromGeometry: function ( geometry ) {
	
			geometry.__directGeometry = new THREE.DirectGeometry().fromGeometry( geometry );
	
			return this.fromDirectGeometry( geometry.__directGeometry );
	
		},
	
		fromDirectGeometry: function ( geometry ) {
	
			var positions = new Float32Array( geometry.vertices.length * 3 );
			this.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );
	
			if ( geometry.normals.length > 0 ) {
	
				var normals = new Float32Array( geometry.normals.length * 3 );
				this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );
	
			}
	
			if ( geometry.colors.length > 0 ) {
	
				var colors = new Float32Array( geometry.colors.length * 3 );
				this.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );
	
			}
	
			if ( geometry.uvs.length > 0 ) {
	
				var uvs = new Float32Array( geometry.uvs.length * 2 );
				this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );
	
			}
	
			if ( geometry.uvs2.length > 0 ) {
	
				var uvs2 = new Float32Array( geometry.uvs2.length * 2 );
				this.addAttribute( 'uv2', new THREE.BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );
	
			}
	
			if ( geometry.indices.length > 0 ) {
	
				var TypeArray = geometry.vertices.length > 65535 ? Uint32Array : Uint16Array;
				var indices = new TypeArray( geometry.indices.length * 3 );
				this.setIndex( new THREE.BufferAttribute( indices, 1 ).copyIndicesArray( geometry.indices ) );
	
			}
	
			// groups
	
			this.groups = geometry.groups;
	
			// morphs
	
			for ( var name in geometry.morphTargets ) {
	
				var array = [];
				var morphTargets = geometry.morphTargets[ name ];
	
				for ( var i = 0, l = morphTargets.length; i < l; i ++ ) {
	
					var morphTarget = morphTargets[ i ];
	
					var attribute = new THREE.Float32Attribute( morphTarget.length * 3, 3 );
	
					array.push( attribute.copyVector3sArray( morphTarget ) );
	
				}
	
				this.morphAttributes[ name ] = array;
	
			}
	
			// skinning
	
			if ( geometry.skinIndices.length > 0 ) {
	
				var skinIndices = new THREE.Float32Attribute( geometry.skinIndices.length * 4, 4 );
				this.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );
	
			}
	
			if ( geometry.skinWeights.length > 0 ) {
	
				var skinWeights = new THREE.Float32Attribute( geometry.skinWeights.length * 4, 4 );
				this.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );
	
			}
	
			//
	
			if ( geometry.boundingSphere !== null ) {
	
				this.boundingSphere = geometry.boundingSphere.clone();
	
			}
	
			if ( geometry.boundingBox !== null ) {
	
				this.boundingBox = geometry.boundingBox.clone();
	
			}
	
			return this;
	
		},
	
		computeBoundingBox: function () {
	
			var vector = new THREE.Vector3();
	
			return function () {
	
				if ( this.boundingBox === null ) {
	
					this.boundingBox = new THREE.Box3();
	
				}
	
				var positions = this.attributes.position.array;
	
				if ( positions ) {
	
					this.boundingBox.setFromArray( positions );
	
				}
	
				if ( positions === undefined || positions.length === 0 ) {
	
					this.boundingBox.min.set( 0, 0, 0 );
					this.boundingBox.max.set( 0, 0, 0 );
	
				}
	
				if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {
	
					console.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );
	
				}
	
			};
	
		}(),
	
		computeBoundingSphere: function () {
	
			var box = new THREE.Box3();
			var vector = new THREE.Vector3();
	
			return function () {
	
				if ( this.boundingSphere === null ) {
	
					this.boundingSphere = new THREE.Sphere();
	
				}
	
				var positions = this.attributes.position.array;
	
				if ( positions ) {
	
					var center = this.boundingSphere.center;
	
					box.setFromArray( positions );
					box.center( center );
	
					// hoping to find a boundingSphere with a radius smaller than the
					// boundingSphere of the boundingBox: sqrt(3) smaller in the best case
	
					var maxRadiusSq = 0;
	
					for ( var i = 0, il = positions.length; i < il; i += 3 ) {
	
						vector.fromArray( positions, i );
						maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );
	
					}
	
					this.boundingSphere.radius = Math.sqrt( maxRadiusSq );
	
					if ( isNaN( this.boundingSphere.radius ) ) {
	
						console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );
	
					}
	
				}
	
			};
	
		}(),
	
		computeFaceNormals: function () {
	
			// backwards compatibility
	
		},
	
		computeVertexNormals: function () {
	
			var index = this.index;
			var attributes = this.attributes;
			var groups = this.groups;
	
			if ( attributes.position ) {
	
				var positions = attributes.position.array;
	
				if ( attributes.normal === undefined ) {
	
					this.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( positions.length ), 3 ) );
	
				} else {
	
					// reset existing normals to zero
	
					var array = attributes.normal.array;
	
					for ( var i = 0, il = array.length; i < il; i ++ ) {
	
						array[ i ] = 0;
	
					}
	
				}
	
				var normals = attributes.normal.array;
	
				var vA, vB, vC,
	
				pA = new THREE.Vector3(),
				pB = new THREE.Vector3(),
				pC = new THREE.Vector3(),
	
				cb = new THREE.Vector3(),
				ab = new THREE.Vector3();
	
				// indexed elements
	
				if ( index ) {
	
					var indices = index.array;
	
					if ( groups.length === 0 ) {
	
						this.addGroup( 0, indices.length );
	
					}
	
					for ( var j = 0, jl = groups.length; j < jl; ++ j ) {
	
						var group = groups[ j ];
	
						var start = group.start;
						var count = group.count;
	
						for ( var i = start, il = start + count; i < il; i += 3 ) {
	
							vA = indices[ i + 0 ] * 3;
							vB = indices[ i + 1 ] * 3;
							vC = indices[ i + 2 ] * 3;
	
							pA.fromArray( positions, vA );
							pB.fromArray( positions, vB );
							pC.fromArray( positions, vC );
	
							cb.subVectors( pC, pB );
							ab.subVectors( pA, pB );
							cb.cross( ab );
	
							normals[ vA ] += cb.x;
							normals[ vA + 1 ] += cb.y;
							normals[ vA + 2 ] += cb.z;
	
							normals[ vB ] += cb.x;
							normals[ vB + 1 ] += cb.y;
							normals[ vB + 2 ] += cb.z;
	
							normals[ vC ] += cb.x;
							normals[ vC + 1 ] += cb.y;
							normals[ vC + 2 ] += cb.z;
	
						}
	
					}
	
				} else {
	
					// non-indexed elements (unconnected triangle soup)
	
					for ( var i = 0, il = positions.length; i < il; i += 9 ) {
	
						pA.fromArray( positions, i );
						pB.fromArray( positions, i + 3 );
						pC.fromArray( positions, i + 6 );
	
						cb.subVectors( pC, pB );
						ab.subVectors( pA, pB );
						cb.cross( ab );
	
						normals[ i ] = cb.x;
						normals[ i + 1 ] = cb.y;
						normals[ i + 2 ] = cb.z;
	
						normals[ i + 3 ] = cb.x;
						normals[ i + 4 ] = cb.y;
						normals[ i + 5 ] = cb.z;
	
						normals[ i + 6 ] = cb.x;
						normals[ i + 7 ] = cb.y;
						normals[ i + 8 ] = cb.z;
	
					}
	
				}
	
				this.normalizeNormals();
	
				attributes.normal.needsUpdate = true;
	
			}
	
		},
	
		merge: function ( geometry, offset ) {
	
			if ( geometry instanceof THREE.BufferGeometry === false ) {
	
				console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );
				return;
	
			}
	
			if ( offset === undefined ) offset = 0;
	
			var attributes = this.attributes;
	
			for ( var key in attributes ) {
	
				if ( geometry.attributes[ key ] === undefined ) continue;
	
				var attribute1 = attributes[ key ];
				var attributeArray1 = attribute1.array;
	
				var attribute2 = geometry.attributes[ key ];
				var attributeArray2 = attribute2.array;
	
				var attributeSize = attribute2.itemSize;
	
				for ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {
	
					attributeArray1[ j ] = attributeArray2[ i ];
	
				}
	
			}
	
			return this;
	
		},
	
		normalizeNormals: function () {
	
			var normals = this.attributes.normal.array;
	
			var x, y, z, n;
	
			for ( var i = 0, il = normals.length; i < il; i += 3 ) {
	
				x = normals[ i ];
				y = normals[ i + 1 ];
				z = normals[ i + 2 ];
	
				n = 1.0 / Math.sqrt( x * x + y * y + z * z );
	
				normals[ i ] *= n;
				normals[ i + 1 ] *= n;
				normals[ i + 2 ] *= n;
	
			}
	
		},
	
		toNonIndexed: function () {
	
			if ( this.index === null ) {
	
				console.warn( 'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );
				return this;
	
			}
	
			var geometry2 = new THREE.BufferGeometry();
	
			var indices = this.index.array;
			var attributes = this.attributes;
	
			for ( var name in attributes ) {
	
				var attribute = attributes[ name ];
	
				var array = attribute.array;
				var itemSize = attribute.itemSize;
	
				var array2 = new array.constructor( indices.length * itemSize );
	
				var index = 0, index2 = 0;
	
				for ( var i = 0, l = indices.length; i < l; i ++ ) {
	
					index = indices[ i ] * itemSize;
	
					for ( var j = 0; j < itemSize; j ++ ) {
	
						array2[ index2 ++ ] = array[ index ++ ];
	
					}
	
				}
	
				geometry2.addAttribute( name, new THREE.BufferAttribute( array2, itemSize ) );
	
			}
	
			return geometry2;
	
		},
	
		toJSON: function () {
	
			var data = {
				metadata: {
					version: 4.4,
					type: 'BufferGeometry',
					generator: 'BufferGeometry.toJSON'
				}
			};
	
			// standard BufferGeometry serialization
	
			data.uuid = this.uuid;
			data.type = this.type;
			if ( this.name !== '' ) data.name = this.name;
	
			if ( this.parameters !== undefined ) {
	
				var parameters = this.parameters;
	
				for ( var key in parameters ) {
	
					if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];
	
				}
	
				return data;
	
			}
	
			data.data = { attributes: {} };
	
			var index = this.index;
	
			if ( index !== null ) {
	
				var array = Array.prototype.slice.call( index.array );
	
				data.data.index = {
					type: index.array.constructor.name,
					array: array
				};
	
			}
	
			var attributes = this.attributes;
	
			for ( var key in attributes ) {
	
				var attribute = attributes[ key ];
	
				var array = Array.prototype.slice.call( attribute.array );
	
				data.data.attributes[ key ] = {
					itemSize: attribute.itemSize,
					type: attribute.array.constructor.name,
					array: array
				};
	
			}
	
			var groups = this.groups;
	
			if ( groups.length > 0 ) {
	
				data.data.groups = JSON.parse( JSON.stringify( groups ) );
	
			}
	
			var boundingSphere = this.boundingSphere;
	
			if ( boundingSphere !== null ) {
	
				data.data.boundingSphere = {
					center: boundingSphere.center.toArray(),
					radius: boundingSphere.radius
				};
	
			}
	
			return data;
	
		},
	
		clone: function () {
	
			/*
			// Handle primitives
	
			var parameters = this.parameters;
	
			if ( parameters !== undefined ) {
	
				var values = [];
	
				for ( var key in parameters ) {
	
					values.push( parameters[ key ] );
	
				}
	
				var geometry = Object.create( this.constructor.prototype );
				this.constructor.apply( geometry, values );
				return geometry;
	
			}
	
			return new this.constructor().copy( this );
			*/
	
			return new THREE.BufferGeometry().copy( this );
	
		},
	
		copy: function ( source ) {
	
			var index = source.index;
	
			if ( index !== null ) {
	
				this.setIndex( index.clone() );
	
			}
	
			var attributes = source.attributes;
	
			for ( var name in attributes ) {
	
				var attribute = attributes[ name ];
				this.addAttribute( name, attribute.clone() );
	
			}
	
			var groups = source.groups;
	
			for ( var i = 0, l = groups.length; i < l; i ++ ) {
	
				var group = groups[ i ];
				this.addGroup( group.start, group.count );
	
			}
	
			return this;
	
		},
	
		dispose: function () {
	
			this.dispatchEvent( { type: 'dispose' } );
	
		}
	
	};
	
	THREE.EventDispatcher.prototype.apply( THREE.BufferGeometry.prototype );
	
	THREE.BufferGeometry.MaxIndex = 65535;
	
	// File:src/core/InstancedBufferGeometry.js
	
	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */
	
	THREE.InstancedBufferGeometry = function () {
	
		THREE.BufferGeometry.call( this );
	
		this.type = 'InstancedBufferGeometry';
		this.maxInstancedCount = undefined;
	
	};
	
	THREE.InstancedBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
	THREE.InstancedBufferGeometry.prototype.constructor = THREE.InstancedBufferGeometry;
	
	THREE.InstancedBufferGeometry.prototype.addGroup = function ( start, count, instances ) {
	
		this.groups.push( {
	
			start: start,
			count: count,
			instances: instances
	
		} );
	
	};
	
	THREE.InstancedBufferGeometry.prototype.copy = function ( source ) {
	
		var index = source.index;
	
		if ( index !== null ) {
	
			this.setIndex( index.clone() );
	
		}
	
		var attributes = source.attributes;
	
		for ( var name in attributes ) {
	
			var attribute = attributes[ name ];
			this.addAttribute( name, attribute.clone() );
	
		}
	
		var groups = source.groups;
	
		for ( var i = 0, l = groups.length; i < l; i ++ ) {
	
			var group = groups[ i ];
			this.addGroup( group.start, group.count, group.instances );
	
		}
	
		return this;
	
	};
	
	THREE.EventDispatcher.prototype.apply( THREE.InstancedBufferGeometry.prototype );
	
	// File:src/core/Uniform.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.Uniform = function ( type, value ) {
	
		this.type = type;
		this.value = value;
	
		this.dynamic = false;
	
	};
	
	THREE.Uniform.prototype = {
	
		constructor: THREE.Uniform,
	
		onUpdate: function ( callback ) {
	
			this.dynamic = true;
			this.onUpdateCallback = callback;
	
			return this;
	
		}
	
	};
	
	// File:src/animation/AnimationClip.js
	
	/**
	 *
	 * Reusable set of Tracks that represent an animation.
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 */
	
	THREE.AnimationClip = function ( name, duration, tracks ) {
	
		this.name = name || THREE.Math.generateUUID();
		this.tracks = tracks;
		this.duration = ( duration !== undefined ) ? duration : -1;
	
		// this means it should figure out its duration by scanning the tracks
		if ( this.duration < 0 ) {
	
			this.resetDuration();
	
		}
	
		// maybe only do these on demand, as doing them here could potentially slow down loading
		// but leaving these here during development as this ensures a lot of testing of these functions
		this.trim();
		this.optimize();
	
	};
	
	THREE.AnimationClip.prototype = {
	
		constructor: THREE.AnimationClip,
	
		resetDuration: function() {
	
			var tracks = this.tracks,
				duration = 0;
	
			for ( var i = 0, n = tracks.length; i !== n; ++ i ) {
	
				var track = this.tracks[ i ];
	
				duration = Math.max(
						duration, track.times[ track.times.length - 1 ] );
	
			}
	
			this.duration = duration;
	
		},
	
		trim: function() {
	
			for ( var i = 0; i < this.tracks.length; i ++ ) {
	
				this.tracks[ i ].trim( 0, this.duration );
	
			}
	
			return this;
	
		},
	
		optimize: function() {
	
			for ( var i = 0; i < this.tracks.length; i ++ ) {
	
				this.tracks[ i ].optimize();
	
			}
	
			return this;
	
		}
	
	};
	
	// Static methods:
	
	Object.assign( THREE.AnimationClip, {
	
		parse: function( json ) {
	
			var tracks = [],
				jsonTracks = json.tracks,
				frameTime = 1.0 / ( json.fps || 1.0 );
	
			for ( var i = 0, n = jsonTracks.length; i !== n; ++ i ) {
	
				tracks.push( THREE.KeyframeTrack.parse( jsonTracks[ i ] ).scale( frameTime ) );
	
			}
	
			return new THREE.AnimationClip( json.name, json.duration, tracks );
	
		},
	
	
		toJSON: function( clip ) {
	
			var tracks = [],
				clipTracks = clip.tracks;
	
			var json = {
	
				'name': clip.name,
				'duration': clip.duration,
				'tracks': tracks
	
			};
	
			for ( var i = 0, n = clipTracks.length; i !== n; ++ i ) {
	
				tracks.push( THREE.KeyframeTrack.toJSON( clipTracks[ i ] ) );
	
			}
	
			return json;
	
		},
	
	
		CreateFromMorphTargetSequence: function( name, morphTargetSequence, fps ) {
	
			var numMorphTargets = morphTargetSequence.length;
			var tracks = [];
	
			for ( var i = 0; i < numMorphTargets; i ++ ) {
	
				var times = [];
				var values = [];
	
				times.push(
						( i + numMorphTargets - 1 ) % numMorphTargets,
						i,
						( i + 1 ) % numMorphTargets );
	
				values.push( 0, 1, 0 );
	
				var order = THREE.AnimationUtils.getKeyframeOrder( times );
				times = THREE.AnimationUtils.sortedArray( times, 1, order );
				values = THREE.AnimationUtils.sortedArray( values, 1, order );
	
				// if there is a key at the first frame, duplicate it as the
				// last frame as well for perfect loop.
				if ( times[ 0 ] === 0 ) {
	
					times.push( numMorphTargets );
					values.push( values[ 0 ] );
	
				}
	
				tracks.push(
						new THREE.NumberKeyframeTrack(
							'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',
							times, values
						).scale( 1.0 / fps ) );
			}
	
			return new THREE.AnimationClip( name, -1, tracks );
	
		},
	
		findByName: function( clipArray, name ) {
	
			for ( var i = 0; i < clipArray.length; i ++ ) {
	
				if ( clipArray[ i ].name === name ) {
	
					return clipArray[ i ];
	
				}
			}
	
			return null;
	
		},
	
		CreateClipsFromMorphTargetSequences: function( morphTargets, fps ) {
	
			var animationToMorphTargets = {};
	
			// tested with https://regex101.com/ on trick sequences
			// such flamingo_flyA_003, flamingo_run1_003, crdeath0059
			var pattern = /^([\w-]*?)([\d]+)$/;
	
			// sort morph target names into animation groups based
			// patterns like Walk_001, Walk_002, Run_001, Run_002
			for ( var i = 0, il = morphTargets.length; i < il; i ++ ) {
	
				var morphTarget = morphTargets[ i ];
				var parts = morphTarget.name.match( pattern );
	
				if ( parts && parts.length > 1 ) {
	
					var name = parts[ 1 ];
	
					var animationMorphTargets = animationToMorphTargets[ name ];
					if ( ! animationMorphTargets ) {
	
						animationToMorphTargets[ name ] = animationMorphTargets = [];
	
					}
	
					animationMorphTargets.push( morphTarget );
	
				}
	
			}
	
			var clips = [];
	
			for ( var name in animationToMorphTargets ) {
	
				clips.push( THREE.AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps ) );
	
			}
	
			return clips;
	
		},
	
		// parse the animation.hierarchy format
		parseAnimation: function( animation, bones, nodeName ) {
	
			if ( ! animation ) {
	
				console.error( "  no animation in JSONLoader data" );
				return null;
	
			}
	
			var addNonemptyTrack = function(
					trackType, trackName, animationKeys, propertyName, destTracks ) {
	
				// only return track if there are actually keys.
				if ( animationKeys.length !== 0 ) {
	
					var times = [];
					var values = [];
	
					THREE.AnimationUtils.flattenJSON(
							animationKeys, times, values, propertyName );
	
					// empty keys are filtered out, so check again
					if ( times.length !== 0 ) {
	
						destTracks.push( new trackType( trackName, times, values ) );
	
					}
	
				}
	
			};
	
			var tracks = [];
	
			var clipName = animation.name || 'default';
			// automatic length determination in AnimationClip.
			var duration = animation.length || -1;
			var fps = animation.fps || 30;
	
			var hierarchyTracks = animation.hierarchy || [];
	
			for ( var h = 0; h < hierarchyTracks.length; h ++ ) {
	
				var animationKeys = hierarchyTracks[ h ].keys;
	
				// skip empty tracks
				if ( ! animationKeys || animationKeys.length == 0 ) continue;
	
				// process morph targets in a way exactly compatible
				// with AnimationHandler.init( animation )
				if ( animationKeys[0].morphTargets ) {
	
					// figure out all morph targets used in this track
					var morphTargetNames = {};
					for ( var k = 0; k < animationKeys.length; k ++ ) {
	
						if ( animationKeys[k].morphTargets ) {
	
							for ( var m = 0; m < animationKeys[k].morphTargets.length; m ++ ) {
	
								morphTargetNames[ animationKeys[k].morphTargets[m] ] = -1;
							}
	
						}
	
					}
	
					// create a track for each morph target with all zero
					// morphTargetInfluences except for the keys in which
					// the morphTarget is named.
					for ( var morphTargetName in morphTargetNames ) {
	
						var times = [];
						var values = [];
	
						for ( var m = 0;
								m !== animationKeys[k].morphTargets.length; ++ m ) {
	
							var animationKey = animationKeys[k];
	
							times.push( animationKey.time );
							values.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 )
	
						}
	
						tracks.push( new THREE.NumberKeyframeTrack(
								'.morphTargetInfluence[' + morphTargetName + ']', times, values ) );
	
					}
	
					duration = morphTargetNames.length * ( fps || 1.0 );
	
				} else {
					// ...assume skeletal animation
	
					var boneName = '.bones[' + bones[ h ].name + ']';
	
					addNonemptyTrack(
							THREE.VectorKeyframeTrack, boneName + '.position',
							animationKeys, 'pos', tracks );
	
					addNonemptyTrack(
							THREE.QuaternionKeyframeTrack, boneName + '.quaternion',
							animationKeys, 'rot', tracks );
	
					addNonemptyTrack(
							THREE.VectorKeyframeTrack, boneName + '.scale',
							animationKeys, 'scl', tracks );
	
				}
	
			}
	
			if ( tracks.length === 0 ) {
	
				return null;
	
			}
	
			var clip = new THREE.AnimationClip( clipName, duration, tracks );
	
			return clip;
	
		}
	
	} );
	
	
	// File:src/animation/AnimationMixer.js
	
	/**
	 *
	 * Player for AnimationClips.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */
	
	THREE.AnimationMixer = function( root ) {
	
		this._root = root;
		this._initMemoryManager();
		this._accuIndex = 0;
	
		this.time = 0;
	
		this.timeScale = 1.0;
	
	};
	
	THREE.AnimationMixer.prototype = {
	
		constructor: THREE.AnimationMixer,
	
		// return an action for a clip optionally using a custom root target
		// object (this method allocates a lot of dynamic memory in case a
		// previously unknown clip/root combination is specified)
		clipAction: function( clip, optionalRoot ) {
	
			var root = optionalRoot || this._root,
				rootUuid = root.uuid,
				clipName = ( typeof clip === 'string' ) ? clip : clip.name,
				clipObject = ( clip !== clipName ) ? clip : null,
	
				actionsForClip = this._actionsByClip[ clipName ],
				prototypeAction;
	
			if ( actionsForClip !== undefined ) {
	
				var existingAction =
						actionsForClip.actionByRoot[ rootUuid ];
	
				if ( existingAction !== undefined ) {
	
					return existingAction;
	
				}
	
				// we know the clip, so we don't have to parse all
				// the bindings again but can just copy
				prototypeAction = actionsForClip.knownActions[ 0 ];
	
				// also, take the clip from the prototype action
				clipObject = prototypeAction._clip;
	
				if ( clip !== clipName && clip !== clipObject ) {
	
					throw new Error(
							"Different clips with the same name detected!" );
	
				}
	
			}
	
			// clip must be known when specified via string
			if ( clipObject === null ) return null;
	
			// allocate all resources required to run it
			var newAction = new THREE.
					AnimationMixer._Action( this, clipObject, optionalRoot );
	
			this._bindAction( newAction, prototypeAction );
	
			// and make the action known to the memory manager
			this._addInactiveAction( newAction, clipName, rootUuid );
	
			return newAction;
	
		},
	
		// get an existing action
		existingAction: function( clip, optionalRoot ) {
	
			var root = optionalRoot || this._root,
				rootUuid = root.uuid,
				clipName = ( typeof clip === 'string' ) ? clip : clip.name,
				actionsForClip = this._actionsByClip[ clipName ];
	
			if ( actionsForClip !== undefined ) {
	
				return actionsForClip.actionByRoot[ rootUuid ] || null;
	
			}
	
			return null;
	
		},
	
		// deactivates all previously scheduled actions
		stopAllAction: function() {
	
			var actions = this._actions,
				nActions = this._nActiveActions,
				bindings = this._bindings,
				nBindings = this._nActiveBindings;
	
			this._nActiveActions = 0;
			this._nActiveBindings = 0;
	
			for ( var i = 0; i !== nActions; ++ i ) {
	
				actions[ i ].reset();
	
			}
	
			for ( var i = 0; i !== nBindings; ++ i ) {
	
				bindings[ i ].useCount = 0;
	
			}
	
			return this;
	
		},
	
		// advance the time and update apply the animation
		update: function( deltaTime ) {
	
			deltaTime *= this.timeScale;
	
			var actions = this._actions,
				nActions = this._nActiveActions,
	
				time = this.time += deltaTime,
				timeDirection = Math.sign( deltaTime ),
	
				accuIndex = this._accuIndex ^= 1;
	
			// run active actions
	
			for ( var i = 0; i !== nActions; ++ i ) {
	
				var action = actions[ i ];
	
				if ( action.enabled ) {
	
					action._update( time, deltaTime, timeDirection, accuIndex );
	
				}
	
			}
	
			// update scene graph
	
			var bindings = this._bindings,
				nBindings = this._nActiveBindings;
	
			for ( var i = 0; i !== nBindings; ++ i ) {
	
				bindings[ i ].apply( accuIndex );
	
			}
	
			return this;
	
		},
	
		// return this mixer's root target object
		getRoot: function() {
	
			return this._root;
	
		},
	
		// free all resources specific to a particular clip
		uncacheClip: function( clip ) {
	
			var actions = this._actions,
				clipName = clip.name,
				actionsByClip = this._actionsByClip,
				actionsForClip = actionsByClip[ clipName ];
	
			if ( actionsForClip !== undefined ) {
	
				// note: just calling _removeInactiveAction would mess up the
				// iteration state and also require updating the state we can
				// just throw away
	
				var actionsToRemove = actionsForClip.knownActions;
	
				for ( var i = 0, n = actionsToRemove.length; i !== n; ++ i ) {
	
					var action = actionsToRemove[ i ];
	
					this._deactivateAction( action );
	
					var cacheIndex = action._cacheIndex,
						lastInactiveAction = actions[ actions.length - 1 ];
	
					action._cacheIndex = null;
					action._byClipCacheIndex = null;
	
					lastInactiveAction._cacheIndex = cacheIndex;
					actions[ cacheIndex ] = lastInactiveAction;
					actions.pop();
	
					this._removeInactiveBindingsForAction( action );
	
				}
	
				delete actionsByClip[ clipName ];
	
			}
	
		},
	
		// free all resources specific to a particular root target object
		uncacheRoot: function( root ) {
	
			var rootUuid = root.uuid,
				actionsByClip = this._actionsByClip;
	
			for ( var clipName in actionsByClip ) {
	
				var actionByRoot = actionsByClip[ clipName ].actionByRoot,
					action = actionByRoot[ rootUuid ];
	
				if ( action !== undefined ) {
	
					this._deactivateAction( action );
					this._removeInactiveAction( action );
	
				}
	
			}
	
			var bindingsByRoot = this._bindingsByRootAndName,
				bindingByName = bindingsByRoot[ rootUuid ];
	
			if ( bindingByName !== undefined ) {
	
				for ( var trackName in bindingByName ) {
	
					var binding = bindingByName[ trackName ];
					binding.restoreOriginalState();
					this._removeInactiveBinding( binding );
	
				}
	
			}
	
		},
	
		// remove a targeted clip from the cache
		uncacheAction: function( clip, optionalRoot ) {
	
			var action = this.existingAction( clip, optionalRoot );
	
			if ( action !== null ) {
	
				this._deactivateAction( action );
				this._removeInactiveAction( action );
	
			}
	
		}
	
	};
	
	THREE.EventDispatcher.prototype.apply( THREE.AnimationMixer.prototype );
	
	THREE.AnimationMixer._Action =
			function( mixer, clip, localRoot ) {
	
		this._mixer = mixer;
		this._clip = clip;
		this._localRoot = localRoot || null;
	
		var tracks = clip.tracks,
			nTracks = tracks.length,
			interpolants = new Array( nTracks );
	
		var interpolantSettings = {
				endingStart: 	THREE.ZeroCurvatureEnding,
				endingEnd:		THREE.ZeroCurvatureEnding
		};
	
		for ( var i = 0; i !== nTracks; ++ i ) {
	
			var interpolant = tracks[ i ].createInterpolant( null );
			interpolants[ i ] = interpolant;
			interpolant.settings = interpolantSettings
	
		}
	
		this._interpolantSettings = interpolantSettings;
	
		this._interpolants = interpolants;	// bound by the mixer
	
		// inside: PropertyMixer (managed by the mixer)
		this._propertyBindings = new Array( nTracks );
	
		this._cacheIndex = null;			// for the memory manager
		this._byClipCacheIndex = null;		// for the memory manager
	
		this._timeScaleInterpolant = null;
		this._weightInterpolant = null;
	
		this.loop = THREE.LoopRepeat;
		this._loopCount = -1;
	
		// global mixer time when the action is to be started
		// it's set back to 'null' upon start of the action
		this._startTime = null;
	
		// scaled local time of the action
		// gets clamped or wrapped to 0..clip.duration according to loop
		this.time = 0;
	
		this.timeScale = 1;
		this._effectiveTimeScale = 1;
	
		this.weight = 1;
		this._effectiveWeight = 1;
	
		this.repetitions = Infinity; 		// no. of repetitions when looping
	
		this.paused = false;				// false -> zero effective time scale
		this.enabled = true;				// true -> zero effective weight
	
		this.clampWhenFinished 	= false;	// keep feeding the last frame?
	
		this.zeroSlopeAtStart 	= true;		// for smooth interpolation w/o separate
		this.zeroSlopeAtEnd		= true;		// clips for start, loop and end
	
	};
	
	THREE.AnimationMixer._Action.prototype = {
	
		constructor: THREE.AnimationMixer._Action,
	
		// State & Scheduling
	
		play: function() {
	
			this._mixer._activateAction( this );
	
			return this;
	
		},
	
		stop: function() {
	
			this._mixer._deactivateAction( this );
	
			return this.reset();
	
		},
	
		reset: function() {
	
			this.paused = false;
			this.enabled = true;
	
			this.time = 0;			// restart clip
			this._loopCount = -1;	// forget previous loops
			this._startTime = null;	// forget scheduling
	
			return this.stopFading().stopWarping();
	
		},
	
		isRunning: function() {
	
			var start = this._startTime;
	
			return this.enabled && ! this.paused && this.timeScale !== 0 &&
					this._startTime === null && this._mixer._isActiveAction( this )
	
		},
	
		// return true when play has been called
		isScheduled: function() {
	
			return this._mixer._isActiveAction( this );
	
		},
	
		startAt: function( time ) {
	
			this._startTime = time;
	
			return this;
	
		},
	
		setLoop: function( mode, repetitions ) {
	
			this.loop = mode;
			this.repetitions = repetitions;
	
			return this;
	
		},
	
		// Weight
	
		// set the weight stopping any scheduled fading
		// although .enabled = false yields an effective weight of zero, this
		// method does *not* change .enabled, because it would be confusing
		setEffectiveWeight: function( weight ) {
	
			this.weight = weight;
	
			// note: same logic as when updated at runtime
			this._effectiveWeight = this.enabled ? weight : 0;
	
			return this.stopFading();
	
		},
	
		// return the weight considering fading and .enabled
		getEffectiveWeight: function() {
	
			return this._effectiveWeight;
	
		},
	
		fadeIn: function( duration ) {
	
			return this._scheduleFading( duration, 0, 1 );
	
		},
	
		fadeOut: function( duration ) {
	
			return this._scheduleFading( duration, 1, 0 );
	
		},
	
		crossFadeFrom: function( fadeOutAction, duration, warp ) {
	
			var mixer = this._mixer;
	
			fadeOutAction.fadeOut( duration );
			this.fadeIn( duration );
	
			if( warp ) {
	
				var fadeInDuration = this._clip.duration,
					fadeOutDuration = fadeOutAction._clip.duration,
	
					startEndRatio = fadeOutDuration / fadeInDuration,
					endStartRatio = fadeInDuration / fadeOutDuration;
	
				fadeOutAction.warp( 1.0, startEndRatio, duration );
				this.warp( endStartRatio, 1.0, duration );
	
			}
	
			return this;
	
		},
	
		crossFadeTo: function( fadeInAction, duration, warp ) {
	
			return fadeInAction.crossFadeFrom( this, duration, warp );
	
		},
	
		stopFading: function() {
	
			var weightInterpolant = this._weightInterpolant;
	
			if ( weightInterpolant !== null ) {
	
				this._weightInterpolant = null;
				this._mixer._takeBackControlInterpolant( weightInterpolant );
	
			}
	
			return this;
	
		},
	
		// Time Scale Control
	
		// set the weight stopping any scheduled warping
		// although .paused = true yields an effective time scale of zero, this
		// method does *not* change .paused, because it would be confusing
		setEffectiveTimeScale: function( timeScale ) {
	
			this.timeScale = timeScale;
			this._effectiveTimeScale = this.paused ? 0 :timeScale;
	
			return this.stopWarping();
	
		},
	
		// return the time scale considering warping and .paused
		getEffectiveTimeScale: function() {
	
			return this._effectiveTimeScale;
	
		},
	
		setDuration: function( duration ) {
	
			this.timeScale = this._clip.duration / duration;
	
			return this.stopWarping();
	
		},
	
		syncWith: function( action ) {
	
			this.time = action.time;
			this.timeScale = action.timeScale;
	
			return this.stopWarping();
	
		},
	
		halt: function( duration ) {
	
			return this.warp( this._currentTimeScale, 0, duration );
	
		},
	
		warp: function( startTimeScale, endTimeScale, duration ) {
	
			var mixer = this._mixer, now = mixer.time,
				interpolant = this._timeScaleInterpolant,
	
				timeScale = this.timeScale;
	
			if ( interpolant === null ) {
	
				interpolant = mixer._lendControlInterpolant(),
				this._timeScaleInterpolant = interpolant;
	
			}
	
			var times = interpolant.parameterPositions,
				values = interpolant.sampleValues;
	
			times[ 0 ] = now;
			times[ 1 ] = now + duration;
	
			values[ 0 ] = startTimeScale / timeScale;
			values[ 1 ] = endTimeScale / timeScale;
	
			return this;
	
		},
	
		stopWarping: function() {
	
			var timeScaleInterpolant = this._timeScaleInterpolant;
	
			if ( timeScaleInterpolant !== null ) {
	
				this._timeScaleInterpolant = null;
				this._mixer._takeBackControlInterpolant( timeScaleInterpolant );
	
			}
	
			return this;
	
		},
	
		// Object Accessors
	
		getMixer: function() {
	
			return this._mixer;
	
		},
	
		getClip: function() {
	
			return this._clip;
	
		},
	
		getRoot: function() {
	
			return this._localRoot || this._mixer._root;
	
		},
	
		// Interna
	
		_update: function( time, deltaTime, timeDirection, accuIndex ) {
			// called by the mixer
	
			var startTime = this._startTime;
	
			if ( startTime !== null ) {
	
				// check for scheduled start of action
	
				var timeRunning = ( time - startTime ) * timeDirection;
				if ( timeRunning < 0 || timeDirection === 0 ) {
	
					return; // yet to come / don't decide when delta = 0
	
				}
	
				// start
	
				this._startTime = null; // unschedule
				deltaTime = timeDirection * timeRunning;
	
			}
	
			// apply time scale and advance time
	
			deltaTime *= this._updateTimeScale( time );
			var clipTime = this._updateTime( deltaTime );
	
			// note: _updateTime may disable the action resulting in
			// an effective weight of 0
	
			var weight = this._updateWeight( time );
	
			if ( weight > 0 ) {
	
				var interpolants = this._interpolants;
				var propertyMixers = this._propertyBindings;
	
				for ( var j = 0, m = interpolants.length; j !== m; ++ j ) {
	
					interpolants[ j ].evaluate( clipTime );
					propertyMixers[ j ].accumulate( accuIndex, weight );
	
				}
	
			}
	
		},
	
		_updateWeight: function( time ) {
	
			var weight = 0;
	
			if ( this.enabled ) {
	
				weight = this.weight;
				var interpolant = this._weightInterpolant;
	
				if ( interpolant !== null ) {
	
					var interpolantValue = interpolant.evaluate( time )[ 0 ];
	
					weight *= interpolantValue;
	
					if ( time > interpolant.parameterPositions[ 1 ] ) {
	
						this.stopFading();
	
						if ( interpolantValue === 0 ) {
	
							// faded out, disable
							this.enabled = false;
	
						}
	
					}
	
				}
	
			}
	
			this._effectiveWeight = weight;
			return weight;
	
		},
	
		_updateTimeScale: function( time ) {
	
			var timeScale = 0;
	
			if ( ! this.paused ) {
	
				timeScale = this.timeScale;
	
				var interpolant = this._timeScaleInterpolant;
	
				if ( interpolant !== null ) {
	
					var interpolantValue = interpolant.evaluate( time )[ 0 ];
	
					timeScale *= interpolantValue;
	
					if ( time > interpolant.parameterPositions[ 1 ] ) {
	
						this.stopWarping();
	
						if ( timeScale === 0 ) {
	
							// motion has halted, pause
							this.pause = true;
	
						} else {
	
							// warp done - apply final time scale
							this.timeScale = timeScale;
	
						}
	
					}
	
				}
	
			}
	
			this._effectiveTimeScale = timeScale;
			return timeScale;
	
		},
	
		_updateTime: function( deltaTime ) {
	
			var time = this.time + deltaTime;
	
			if ( deltaTime === 0 ) return time;
	
			var duration = this._clip.duration,
	
				loop = this.loop,
				loopCount = this._loopCount,
	
				pingPong = false;
	
			switch ( loop ) {
	
				case THREE.LoopOnce:
	
					if ( loopCount === -1 ) {
	
						// just started
	
						this.loopCount = 0;
						this._setEndings( true, true, false );
	
					}
	
					if ( time >= duration ) {
	
						time = duration;
	
					} else if ( time < 0 ) {
	
						time = 0;
	
					} else break;
	
					// reached the end
	
					if ( this.clampWhenFinished ) this.pause = true;
					else this.enabled = false;
	
					this._mixer.dispatchEvent( {
						type: 'finished', action: this,
						direction: deltaTime < 0 ? -1 : 1
					} );
	
					break;
	
				case THREE.LoopPingPong:
	
					pingPong = true;
	
				case THREE.LoopRepeat:
	
					if ( loopCount === -1 ) {
	
						// just started
	
						if ( deltaTime > 0 ) {
	
							loopCount = 0;
	
							this._setEndings(
									true, this.repetitions === 0, pingPong );
	
						} else {
	
							// when looping in reverse direction, the initial
							// transition through zero counts as a repetition,
							// so leave loopCount at -1
	
							this._setEndings(
									this.repetitions === 0, true, pingPong );
	
						}
	
					}
	
					if ( time >= duration || time < 0 ) {
	
						// wrap around
	
						var loopDelta = Math.floor( time / duration ); // signed
						time -= duration * loopDelta;
	
						loopCount += Math.abs( loopDelta );
	
						var pending = this.repetitions - loopCount;
	
						if ( pending < 0 ) {
	
							// stop (switch state, clamp time, fire event)
	
							if ( this.clampWhenFinished ) this.paused = true;
							else this.enabled = false;
	
							time = deltaTime > 0 ? duration : 0;
	
							this._mixer.dispatchEvent( {
								type: 'finished', action: this,
								direction: deltaTime > 0 ? 1 : -1
							} );
	
							break;
	
						} else if ( pending === 0 ) {
	
							// transition to last round
	
							var atStart = deltaTime < 0;
							this._setEndings( atStart, ! atStart, pingPong );
	
						} else {
	
							this._setEndings( false, false, pingPong );
	
						}
	
						this._loopCount = loopCount;
	
						this._mixer.dispatchEvent( {
							type: 'loop', action: this, loopDelta: loopDelta
						} );
	
					}
	
					if ( loop === THREE.LoopPingPong && ( loopCount & 1 ) === 1 ) {
	
						// invert time for the "pong round"
	
						this.time = time;
	
						return duration - time;
	
					}
	
					break;
	
			}
	
			this.time = time;
	
			return time;
	
		},
	
		_setEndings: function( atStart, atEnd, pingPong ) {
	
			var settings = this._interpolantSettings;
	
			if ( pingPong ) {
	
				settings.endingStart 	= THREE.ZeroSlopeEnding;
				settings.endingEnd		= THREE.ZeroSlopeEnding;
	
			} else {
	
				// assuming for LoopOnce atStart == atEnd == true
	
				if ( atStart ) {
	
					settings.endingStart = this.zeroSlopeAtStart ?
							THREE.ZeroSlopeEnding : THREE.ZeroCurvatureEnding;
	
				} else {
	
					settings.endingStart = THREE.WrapAroundEnding;
	
				}
	
				if ( atEnd ) {
	
					settings.endingEnd = this.zeroSlopeAtEnd ?
							THREE.ZeroSlopeEnding : THREE.ZeroCurvatureEnding;
	
				} else {
	
					settings.endingEnd 	 = THREE.WrapAroundEnding;
	
				}
	
			}
	
		},
	
		_scheduleFading: function( duration, weightNow, weightThen ) {
	
			var mixer = this._mixer, now = mixer.time,
				interpolant = this._weightInterpolant;
	
			if ( interpolant === null ) {
	
				interpolant = mixer._lendControlInterpolant(),
				this._weightInterpolant = interpolant;
	
			}
	
			var times = interpolant.parameterPositions,
				values = interpolant.sampleValues;
	
			times[ 0 ] = now; 				values[ 0 ] = weightNow;
			times[ 1 ] = now + duration;	values[ 1 ] = weightThen;
	
			return this;
	
		}
	
	};
	
	// Implementation details:
	
	Object.assign( THREE.AnimationMixer.prototype, {
	
		_bindAction: function( action, prototypeAction ) {
	
			var root = action._localRoot || this._root,
				tracks = action._clip.tracks,
				nTracks = tracks.length,
				bindings = action._propertyBindings,
				interpolants = action._interpolants,
				rootUuid = root.uuid,
				bindingsByRoot = this._bindingsByRootAndName,
				bindingsByName = bindingsByRoot[ rootUuid ];
	
			if ( bindingsByName === undefined ) {
	
				bindingsByName = {};
				bindingsByRoot[ rootUuid ] = bindingsByName;
	
			}
	
			for ( var i = 0; i !== nTracks; ++ i ) {
	
				var track = tracks[ i ],
					trackName = track.name,
					binding = bindingsByName[ trackName ];
	
				if ( binding !== undefined ) {
	
					bindings[ i ] = binding;
	
				} else {
	
					binding = bindings[ i ];
	
					if ( binding !== undefined ) {
	
						// existing binding, make sure the cache knows
	
						if ( binding._cacheIndex === null ) {
	
							++ binding.referenceCount;
							this._addInactiveBinding( binding, rootUuid, trackName );
	
						}
	
						continue;
	
					}
	
					var path = prototypeAction && prototypeAction.
							_propertyBindings[ i ].binding.parsedPath;
	
					binding = new THREE.PropertyMixer(
							THREE.PropertyBinding.create( root, trackName, path ),
							track.ValueTypeName, track.getValueSize() );
	
					++ binding.referenceCount;
					this._addInactiveBinding( binding, rootUuid, trackName );
	
					bindings[ i ] = binding;
	
				}
	
				interpolants[ i ].resultBuffer = binding.buffer;
	
			}
	
		},
	
		_activateAction: function( action ) {
	
			if ( ! this._isActiveAction( action ) ) {
	
				if ( action._cacheIndex === null ) {
	
					// this action has been forgotten by the cache, but the user
					// appears to be still using it -> rebind
	
					var rootUuid = ( action._localRoot || this._root ).uuid,
						clipName = action._clip.name,
						actionsForClip = this._actionsByClip[ clipName ];
	
					this._bindAction( action,
							actionsForClip && actionsForClip.knownActions[ 0 ] );
	
					this._addInactiveAction( action, clipName, rootUuid );
	
				}
	
				var bindings = action._propertyBindings;
	
				// increment reference counts / sort out state
				for ( var i = 0, n = bindings.length; i !== n; ++ i ) {
	
					var binding = bindings[ i ];
	
					if ( binding.useCount ++ === 0 ) {
	
						this._lendBinding( binding );
						binding.saveOriginalState();
	
					}
	
				}
	
				this._lendAction( action );
	
			}
	
		},
	
		_deactivateAction: function( action ) {
	
			if ( this._isActiveAction( action ) ) {
	
				var bindings = action._propertyBindings;
	
				// decrement reference counts / sort out state
				for ( var i = 0, n = bindings.length; i !== n; ++ i ) {
	
					var binding = bindings[ i ];
	
					if ( -- binding.useCount === 0 ) {
	
						binding.restoreOriginalState();
						this._takeBackBinding( binding );
	
					}
	
				}
	
				this._takeBackAction( action );
	
			}
	
		},
	
		// Memory manager
	
		_initMemoryManager: function() {
	
			this._actions = []; // 'nActiveActions' followed by inactive ones
			this._nActiveActions = 0;
	
			this._actionsByClip = {};
			// inside:
			// {
			// 		knownActions: Array< _Action >	- used as prototypes
			// 		actionByRoot: _Action			- lookup
			// }
	
	
			this._bindings = []; // 'nActiveBindings' followed by inactive ones
			this._nActiveBindings = 0;
	
			this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >
	
	
			this._controlInterpolants = []; // same game as above
			this._nActiveControlInterpolants = 0;
	
			var scope = this;
	
			this.stats = {
	
				actions: {
					get total() { return scope._actions.length; },
					get inUse() { return scope._nActiveActions; }
				},
				bindings: {
					get total() { return scope._bindings.length; },
					get inUse() { return scope._nActiveBindings; }
				},
				controlInterpolants: {
					get total() { return scope._controlInterpolants.length; },
					get inUse() { return scope._nActiveControlInterpolants; }
				}
	
			};
	
		},
	
		// Memory management for _Action objects
	
		_isActiveAction: function( action ) {
	
			var index = action._cacheIndex;
			return index !== null && index < this._nActiveActions;
	
		},
	
		_addInactiveAction: function( action, clipName, rootUuid ) {
	
			var actions = this._actions,
				actionsByClip = this._actionsByClip,
				actionsForClip = actionsByClip[ clipName ];
	
			if ( actionsForClip === undefined ) {
	
				actionsForClip = {
	
					knownActions: [ action ],
					actionByRoot: {}
	
				};
	
				action._byClipCacheIndex = 0;
	
				actionsByClip[ clipName ] = actionsForClip;
	
			} else {
	
				var knownActions = actionsForClip.knownActions;
	
				action._byClipCacheIndex = knownActions.length;
				knownActions.push( action );
	
			}
	
			action._cacheIndex = actions.length;
			actions.push( action );
	
			actionsForClip.actionByRoot[ rootUuid ] = action;
	
		},
	
		_removeInactiveAction: function( action ) {
	
			var actions = this._actions,
				lastInactiveAction = actions[ actions.length - 1 ],
				cacheIndex = action._cacheIndex;
	
			lastInactiveAction._cacheIndex = cacheIndex;
			actions[ cacheIndex ] = lastInactiveAction;
			actions.pop();
	
			action._cacheIndex = null;
	
	
			var clipName = action._clip.name,
				actionsByClip = this._actionsByClip,
				actionsForClip = actionsByClip[ clipName ],
				knownActionsForClip = actionsForClip.knownActions,
	
				lastKnownAction =
					knownActionsForClip[ knownActionsForClip.length - 1 ],
	
				byClipCacheIndex = action._byClipCacheIndex;
	
			lastKnownAction._byClipCacheIndex = byClipCacheIndex;
			knownActionsForClip[ byClipCacheIndex ] = lastKnownAction;
			knownActionsForClip.pop();
	
			action._byClipCacheIndex = null;
	
	
			var actionByRoot = actionsForClip.actionByRoot,
				rootUuid = ( actions._localRoot || this._root ).uuid;
	
			delete actionByRoot[ rootUuid ];
	
			if ( knownActionsForClip.length === 0 ) {
	
				delete actionsByClip[ clipName ];
	
			}
	
			this._removeInactiveBindingsForAction( action );
	
		},
	
		_removeInactiveBindingsForAction: function( action ) {
	
			var bindings = action._propertyBindings;
			for ( var i = 0, n = bindings.length; i !== n; ++ i ) {
	
				var binding = bindings[ i ];
	
				if ( -- binding.referenceCount === 0 ) {
	
					this._removeInactiveBinding( binding );
	
				}
	
			}
	
		},
	
		_lendAction: function( action ) {
	
			// [ active actions |  inactive actions  ]
			// [  active actions >| inactive actions ]
			//                 s        a
			//                  <-swap->
			//                 a        s
	
			var actions = this._actions,
				prevIndex = action._cacheIndex,
	
				lastActiveIndex = this._nActiveActions ++,
	
				firstInactiveAction = actions[ lastActiveIndex ];
	
			action._cacheIndex = lastActiveIndex;
			actions[ lastActiveIndex ] = action;
	
			firstInactiveAction._cacheIndex = prevIndex;
			actions[ prevIndex ] = firstInactiveAction;
	
		},
	
		_takeBackAction: function( action ) {
	
			// [  active actions  | inactive actions ]
			// [ active actions |< inactive actions  ]
			//        a        s
			//         <-swap->
			//        s        a
	
			var actions = this._actions,
				prevIndex = action._cacheIndex,
	
				firstInactiveIndex = -- this._nActiveActions,
	
				lastActiveAction = actions[ firstInactiveIndex ];
	
			action._cacheIndex = firstInactiveIndex;
			actions[ firstInactiveIndex ] = action;
	
			lastActiveAction._cacheIndex = prevIndex;
			actions[ prevIndex ] = lastActiveAction;
	
		},
	
		// Memory management for PropertyMixer objects
	
		_addInactiveBinding: function( binding, rootUuid, trackName ) {
	
			var bindingsByRoot = this._bindingsByRootAndName,
				bindingByName = bindingsByRoot[ rootUuid ],
	
				bindings = this._bindings;
	
			if ( bindingByName === undefined ) {
	
				bindingByName = {};
				bindingsByRoot[ rootUuid ] = bindingByName;
	
			}
	
			bindingByName[ trackName ] = binding;
	
			binding._cacheIndex = bindings.length;
			bindings.push( binding );
	
		},
	
		_removeInactiveBinding: function( binding ) {
	
			var bindings = this._bindings,
				propBinding = binding.binding,
				rootUuid = propBinding.rootNode.uuid,
				trackName = propBinding.path,
				bindingsByRoot = this._bindingsByRootAndName,
				bindingByName = bindingsByRoot[ rootUuid ],
	
				lastInactiveBinding = bindings[ bindings.length - 1 ],
				cacheIndex = binding._cacheIndex;
	
			lastInactiveBinding._cacheIndex = cacheIndex;
			bindings[ cacheIndex ] = lastInactiveBinding;
			bindings.pop();
	
			delete bindingByName[ trackName ];
	
			remove_empty_map: {
	
				for ( var _ in bindingByName ) break remove_empty_map;
	
				delete bindingsByRoot[ rootUuid ];
	
			}
	
		},
	
		_lendBinding: function( binding ) {
	
			var bindings = this._bindings,
				prevIndex = binding._cacheIndex,
	
				lastActiveIndex = this._nActiveBindings ++,
	
				firstInactiveBinding = bindings[ lastActiveIndex ];
	
			binding._cacheIndex = lastActiveIndex;
			bindings[ lastActiveIndex ] = binding;
	
			firstInactiveBinding._cacheIndex = prevIndex;
			bindings[ prevIndex ] = firstInactiveBinding;
	
		},
	
		_takeBackBinding: function( binding ) {
	
			var bindings = this._bindings,
				prevIndex = binding._cacheIndex,
	
				firstInactiveIndex = -- this._nActiveBindings,
	
				lastActiveBinding = bindings[ firstInactiveIndex ];
	
			binding._cacheIndex = firstInactiveIndex;
			bindings[ firstInactiveIndex ] = binding;
	
			lastActiveBinding._cacheIndex = prevIndex;
			bindings[ prevIndex ] = lastActiveBinding;
	
		},
	
	
		// Memory management of Interpolants for weight and time scale
	
		_lendControlInterpolant: function() {
	
			var interpolants = this._controlInterpolants,
				lastActiveIndex = this._nActiveControlInterpolants ++,
				interpolant = interpolants[ lastActiveIndex ];
	
			if ( interpolant === undefined ) {
	
				interpolant = new THREE.LinearInterpolant(
						new Float32Array( 2 ), new Float32Array( 2 ),
							1, this._controlInterpolantsResultBuffer );
	
				interpolant.__cacheIndex = lastActiveIndex;
				interpolants[ lastActiveIndex ] = interpolant;
	
			}
	
			return interpolant;
	
		},
	
		_takeBackControlInterpolant: function( interpolant ) {
	
			var interpolants = this._controlInterpolants,
				prevIndex = interpolant.__cacheIndex,
	
				firstInactiveIndex = -- this._nActiveControlInterpolants,
	
				lastActiveInterpolant = interpolants[ firstInactiveIndex ];
	
			interpolant.__cacheIndex = firstInactiveIndex;
			interpolants[ firstInactiveIndex ] = interpolant;
	
			lastActiveInterpolant.__cacheIndex = prevIndex;
			interpolants[ prevIndex ] = lastActiveInterpolant;
	
		},
	
		_controlInterpolantsResultBuffer: new Float32Array( 1 )
	
	} );
	
	
	// File:src/animation/AnimationObjectGroup.js
	
	/**
	 *
	 * A group of objects that receives a shared animation state.
	 *
	 * Usage:
	 *
	 * 	-	Add objects you would otherwise pass as 'root' to the
	 * 		constructor or the .clipAction method of AnimationMixer.
	 *
	 * 	-	Instead pass this object as 'root'.
	 *
	 * 	-	You can also add and remove objects later when the mixer
	 * 		is running.
	 *
	 * Note:
	 *
	 *  	Objects of this class appear as one object to the mixer,
	 *  	so cache control of the individual objects must be done
	 *  	on the group.
	 *
	 * Limitation:
	 *
	 * 	- 	The animated properties must be compatible among the
	 * 		all objects in the group.
	 *
	 *  -	A single property can either be controlled through a
	 *  	target group or directly, but not both.
	 *
	 * @author tschw
	 */
	
	THREE.AnimationObjectGroup = function( var_args ) {
	
		this.uuid = THREE.Math.generateUUID();
	
		// cached objects followed by the active ones
		this._objects = Array.prototype.slice.call( arguments );
	
		this.nCachedObjects_ = 0;			// threshold
		// note: read by PropertyBinding.Composite
	
		var indices = {};
		this._indicesByUUID = indices;		// for bookkeeping
	
		for ( var i = 0, n = arguments.length; i !== n; ++ i ) {
	
			indices[ arguments[ i ].uuid ] = i;
	
		}
	
		this._paths = [];					// inside: string
		this._parsedPaths = [];				// inside: { we don't care, here }
		this._bindings = []; 				// inside: Array< PropertyBinding >
		this._bindingsIndicesByPath = {}; 	// inside: indices in these arrays
	
		var scope = this;
	
		this.stats = {
	
			objects: {
				get total() { return scope._objects.length; },
				get inUse() { return this.total - scope.nCachedObjects_;  }
			},
	
			get bindingsPerObject() { return scope._bindings.length; }
	
		};
	
	};
	
	THREE.AnimationObjectGroup.prototype = {
	
		constructor: THREE.AnimationObjectGroup,
	
		add: function( var_args ) {
	
			var objects = this._objects,
				nObjects = objects.length,
				nCachedObjects = this.nCachedObjects_,
				indicesByUUID = this._indicesByUUID,
				paths = this._paths,
				parsedPaths = this._parsedPaths,
				bindings = this._bindings,
				nBindings = bindings.length;
	
			for ( var i = 0, n = arguments.length; i !== n; ++ i ) {
	
				var object = arguments[ i ],
					uuid = object.uuid,
					index = indicesByUUID[ uuid ];
	
				if ( index === undefined ) {
	
					// unknown object -> add it to the ACTIVE region
	
					index = nObjects ++;
					indicesByUUID[ uuid ] = index;
					objects.push( object );
	
					// accounting is done, now do the same for all bindings
	
					for ( var j = 0, m = nBindings; j !== m; ++ j ) {
	
						bindings[ j ].push(
								new THREE.PropertyBinding(
									object, paths[ j ], parsedPaths[ j ] ) );
	
					}
	
				} else if ( index < nCachedObjects ) {
	
					var knownObject = objects[ index ];
	
					// move existing object to the ACTIVE region
	
					var firstActiveIndex = -- nCachedObjects,
						lastCachedObject = objects[ firstActiveIndex ];
	
					indicesByUUID[ lastCachedObject.uuid ] = index;
					objects[ index ] = lastCachedObject;
	
					indicesByUUID[ uuid ] = firstActiveIndex;
					objects[ firstActiveIndex ] = object;
	
					// accounting is done, now do the same for all bindings
	
					for ( var j = 0, m = nBindings; j !== m; ++ j ) {
	
						var bindingsForPath = bindings[ j ],
							lastCached = bindingsForPath[ firstActiveIndex ],
							binding = bindingsForPath[ index ];
	
						bindingsForPath[ index ] = lastCached;
	
						if ( binding === undefined ) {
	
							// since we do not bother to create new bindings
							// for objects that are cached, the binding may
							// or may not exist
	
							binding = new THREE.PropertyBinding(
									object, paths[ j ], parsedPaths[ j ] );
	
						}
	
						bindingsForPath[ firstActiveIndex ] = binding;
	
					}
	
				} else if ( objects[ index ] !== knownObject) {
	
					console.error( "Different objects with the same UUID " +
							"detected. Clean the caches or recreate your " +
							"infrastructure when reloading scenes..." );
	
				} // else the object is already where we want it to be
	
			} // for arguments
	
			this.nCachedObjects_ = nCachedObjects;
	
		},
	
		remove: function( var_args ) {
	
			var objects = this._objects,
				nObjects = objects.length,
				nCachedObjects = this.nCachedObjects_,
				indicesByUUID = this._indicesByUUID,
				bindings = this._bindings,
				nBindings = bindings.length;
	
			for ( var i = 0, n = arguments.length; i !== n; ++ i ) {
	
				var object = arguments[ i ],
					uuid = object.uuid,
					index = indicesByUUID[ uuid ];
	
				if ( index !== undefined && index >= nCachedObjects ) {
	
					// move existing object into the CACHED region
	
					var lastCachedIndex = nCachedObjects ++,
						firstActiveObject = objects[ lastCachedIndex ];
	
					indicesByUUID[ firstActiveObject.uuid ] = index;
					objects[ index ] = firstActiveObject;
	
					indicesByUUID[ uuid ] = lastCachedIndex;
					objects[ lastCachedIndex ] = object;
	
					// accounting is done, now do the same for all bindings
	
					for ( var j = 0, m = nBindings; j !== m; ++ j ) {
	
						var bindingsForPath = bindings[ j ],
							firstActive = bindingsForPath[ lastCachedIndex ],
							binding = bindingsForPath[ index ];
	
						bindingsForPath[ index ] = firstActive;
						bindingsForPath[ lastCachedIndex ] = binding;
	
					}
	
				}
	
			} // for arguments
	
			this.nCachedObjects_ = nCachedObjects;
	
		},
	
		// remove & forget
		uncache: function( var_args ) {
	
			var objects = this._objects,
				nObjects = objects.length,
				nCachedObjects = this.nCachedObjects_,
				indicesByUUID = this._indicesByUUID,
				bindings = this._bindings,
				nBindings = bindings.length;
	
			for ( var i = 0, n = arguments.length; i !== n; ++ i ) {
	
				var object = arguments[ i ],
					uuid = object.uuid,
					index = indicesByUUID[ uuid ];
	
				if ( index !== undefined ) {
	
					delete indicesByUUID[ uuid ];
	
					if ( index < nCachedObjects ) {
	
						// object is cached, shrink the CACHED region
	
						var firstActiveIndex = -- nCachedObjects,
							lastCachedObject = objects[ firstActiveIndex ],
							lastIndex = -- nObjects,
							lastObject = objects[ lastIndex ];
	
						// last cached object takes this object's place
						indicesByUUID[ lastCachedObject.uuid ] = index;
						objects[ index ] = lastCachedObject;
	
						// last object goes to the activated slot and pop
						indicesByUUID[ lastObject.uuid ] = firstActiveIndex;
						objects[ firstActiveIndex ] = lastObject;
						objects.pop();
	
						// accounting is done, now do the same for all bindings
	
						for ( var j = 0, m = nBindings; j !== m; ++ j ) {
	
							var bindingsForPath = bindings[ j ],
								lastCached = bindingsForPath[ firstActiveIndex ],
								last = bindingsForPath[ lastIndex ];
	
							bindingsForPath[ index ] = lastCached;
							bindingsForPath[ firstActiveIndex ] = last;
							bindingsForPath.pop();
	
						}
	
					} else {
	
						// object is active, just swap with the last and pop
	
						var lastIndex = -- nObjects,
							lastObject = objects[ lastIndex ];
	
						indicesByUUID[ lastObject.uuid ] = index;
						objects[ index ] = lastObject;
						objects.pop();
	
						// accounting is done, now do the same for all bindings
	
						for ( var j = 0, m = nBindings; j !== m; ++ j ) {
	
							var bindingsForPath = bindings[ j ];
	
							bindingsForPath[ index ] = bindingsForPath[ lastIndex ];
							bindingsForPath.pop();
	
						}
	
					} // cached or active
	
				} // if object is known
	
			} // for arguments
	
			this.nCachedObjects_ = nCachedObjects;
	
		},
	
		// Internal interface used by befriended PropertyBinding.Composite:
	
		subscribe_: function( path, parsedPath ) {
			// returns an array of bindings for the given path that is changed
			// according to the contained objects in the group
	
			var indicesByPath = this._bindingsIndicesByPath,
				index = indicesByPath[ path ],
				bindings = this._bindings;
	
			if ( index !== undefined ) return bindings[ index ];
	
			var paths = this._paths,
				parsedPaths = this._parsedPaths,
				objects = this._objects,
				nObjects = objects.length,
				nCachedObjects = this.nCachedObjects_,
				bindingsForPath = new Array( nObjects );
	
			index = bindings.length;
	
			indicesByPath[ path ] = index;
	
			paths.push( path );
			parsedPaths.push( parsedPath );
			bindings.push( bindingsForPath );
	
			for ( var i = nCachedObjects,
					n = objects.length; i !== n; ++ i ) {
	
				var object = objects[ i ];
	
				bindingsForPath[ i ] =
						new THREE.PropertyBinding( object, path, parsedPath );
	
			}
	
			return bindingsForPath;
	
		},
	
		unsubscribe_: function( path ) {
			// tells the group to forget about a property path and no longer
			// update the array previously obtained with 'subscribe_'
	
			var indicesByPath = this._bindingsIndicesByPath,
				index = indicesByPath[ path ];
	
			if ( index !== undefined ) {
	
				var paths = this._paths,
					parsedPaths = this._parsedPaths,
					bindings = this._bindings,
					lastBindingsIndex = bindings.length - 1,
					lastBindings = bindings[ lastBindingsIndex ],
					lastBindingsPath = path[ lastBindingsIndex ];
	
				indicesByPath[ lastBindingsPath ] = index;
	
				bindings[ index ] = lastBindings;
				bindings.pop();
	
				parsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];
				parsedPaths.pop();
	
				paths[ index ] = paths[ lastBindingsIndex ];
				paths.pop();
	
			}
	
		}
	
	};
	
	
	// File:src/animation/AnimationUtils.js
	
	/**
	 * @author tschw
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 */
	
	THREE.AnimationUtils = {
	
		// same as Array.prototype.slice, but also works on typed arrays
		arraySlice: function( array, from, to ) {
	
			if ( THREE.AnimationUtils.isTypedArray( array ) ) {
	
				return new array.constructor( array.subarray( from, to ) );
	
			}
	
			return array.slice( from, to );
	
		},
	
		// converts an array to a specific type
		convertArray: function( array, type, forceClone ) {
	
			if ( ! array || // let 'undefined' and 'null' pass
					! forceClone && array.constructor === type ) return array;
	
			if ( typeof type.BYTES_PER_ELEMENT === 'number' ) {
	
				return new type( array ); // create typed array
	
			}
	
			return Array.prototype.slice.call( array ); // create Array
	
		},
	
		isTypedArray: function( object ) {
	
			return ArrayBuffer.isView( object ) &&
					! ( object instanceof DataView );
	
		},
	
		// returns an array by which times and values can be sorted
		getKeyframeOrder: function( times ) {
	
			function compareTime( i, j ) {
	
				return times[ i ] - times[ j ];
	
			}
	
			var n = times.length;
			var result = new Array( n );
			for ( var i = 0; i !== n; ++ i ) result[ i ] = i;
	
			result.sort( compareTime );
	
			return result;
	
		},
	
		// uses the array previously returned by 'getKeyframeOrder' to sort data
		sortedArray: function( values, stride, order ) {
	
			var nValues = values.length;
			var result = new values.constructor( nValues );
	
			for ( var i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {
	
				var srcOffset = order[ i ] * stride;
	
				for ( var j = 0; j !== stride; ++ j ) {
	
					result[ dstOffset ++ ] = values[ srcOffset + j ];
	
				}
	
			}
	
			return result;
	
		},
	
		// function for parsing AOS keyframe formats
		flattenJSON: function( jsonKeys, times, values, valuePropertyName ) {
	
			var i = 1, key = jsonKeys[ 0 ];
	
			while ( key !== undefined && key[ valuePropertyName ] === undefined ) {
	
				key = jsonKeys[ i ++ ];
	
			}
	
			if ( key === undefined ) return; // no data
	
			var value = key[ valuePropertyName ];
			if ( value === undefined ) return; // no data
	
			if ( Array.isArray( value ) ) {
	
				do {
	
					value = key[ valuePropertyName ];
	
					if ( value !== undefined ) {
	
						times.push( key.time );
						values.push.apply( values, value ); // push all elements
	
					}
	
					key = jsonKeys[ i ++ ];
	
				} while ( key !== undefined );
	
			} else if ( value.toArray !== undefined ) {
				// ...assume THREE.Math-ish
	
				do {
	
					value = key[ valuePropertyName ];
	
					if ( value !== undefined ) {
	
						times.push( key.time );
						value.toArray( values, values.length );
	
					}
	
					key = jsonKeys[ i ++ ];
	
				} while ( key !== undefined );
	
			} else {
				// otherwise push as-is
	
				do {
	
					value = key[ valuePropertyName ];
	
					if ( value !== undefined ) {
	
						times.push( key.time );
						values.push( value );
	
					}
	
					key = jsonKeys[ i ++ ];
	
				} while ( key !== undefined );
	
			}
	
		}
	
	};
	
	// File:src/animation/KeyframeTrack.js
	
	/**
	 *
	 * A timed sequence of keyframes for a specific property.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */
	
	THREE.KeyframeTrack = function ( name, times, values, interpolation ) {
	
		if( name === undefined ) throw new Error( "track name is undefined" );
	
		if( times === undefined || times.length === 0 ) {
	
			throw new Error( "no keyframes in track named " + name );
	
		}
	
		this.name = name;
	
		this.times = THREE.AnimationUtils.convertArray( times, this.TimeBufferType );
		this.values = THREE.AnimationUtils.convertArray( values, this.ValueBufferType );
	
		this.setInterpolation( interpolation || this.DefaultInterpolation );
	
		this.validate();
		this.optimize();
	
	};
	
	THREE.KeyframeTrack.prototype = {
	
		constructor: THREE.KeyframeTrack,
	
		TimeBufferType: Float32Array,
		ValueBufferType: Float32Array,
	
		DefaultInterpolation: THREE.InterpolateLinear,
	
		InterpolantFactoryMethodDiscrete: function( result ) {
	
			return new THREE.DiscreteInterpolant(
					this.times, this.values, this.getValueSize(), result );
	
		},
	
		InterpolantFactoryMethodLinear: function( result ) {
	
			return new THREE.LinearInterpolant(
					this.times, this.values, this.getValueSize(), result );
	
		},
	
		InterpolantFactoryMethodSmooth: function( result ) {
	
			return new THREE.CubicInterpolant(
					this.times, this.values, this.getValueSize(), result );
	
		},
	
		setInterpolation: function( interpolation ) {
	
			var factoryMethod = undefined;
	
			switch ( interpolation ) {
	
				case THREE.InterpolateDiscrete:
	
					factoryMethod = this.InterpolantFactoryMethodDiscrete;
	
					break;
	
				case THREE.InterpolateLinear:
	
					factoryMethod = this.InterpolantFactoryMethodLinear;
	
					break;
	
				case THREE.InterpolateSmooth:
	
					factoryMethod = this.InterpolantFactoryMethodSmooth;
	
					break;
	
			}
	
			if ( factoryMethod === undefined ) {
	
				var message = "unsupported interpolation for " +
						this.ValueTypeName + " keyframe track named " + this.name;
	
				if ( this.createInterpolant === undefined ) {
	
					// fall back to default, unless the default itself is messed up
					if ( interpolation !== this.DefaultInterpolation ) {
	
						this.setInterpolation( this.DefaultInterpolation );
	
					} else {
	
						throw new Error( message ); // fatal, in this case
	
					}
	
				}
	
				console.warn( message );
				return;
	
			}
	
			this.createInterpolant = factoryMethod;
	
		},
	
		getInterpolation: function() {
	
			switch ( this.createInterpolant ) {
	
				case this.InterpolantFactoryMethodDiscrete:
	
					return THREE.InterpolateDiscrete;
	
				case this.InterpolantFactoryMethodLinear:
	
					return THREE.InterpolateLinear;
	
				case this.InterpolantFactoryMethodSmooth:
	
					return THREE.InterpolateSmooth;
	
			}
	
		},
	
		getValueSize: function() {
	
			return this.values.length / this.times.length;
	
		},
	
		// move all keyframes either forwards or backwards in time
		shift: function( timeOffset ) {
	
			if( timeOffset !== 0.0 ) {
	
				var times = this.times;
	
				for( var i = 0, n = times.length; i !== n; ++ i ) {
	
					times[ i ] += timeOffset;
	
				}
	
			}
	
			return this;
	
		},
	
		// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
		scale: function( timeScale ) {
	
			if( timeScale !== 1.0 ) {
	
				var times = this.times;
	
				for( var i = 0, n = times.length; i !== n; ++ i ) {
	
					times[ i ] *= timeScale;
	
				}
	
			}
	
			return this;
	
		},
	
		// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
		// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
		trim: function( startTime, endTime ) {
	
			var times = this.times,
				nKeys = times.length,
				from = 0,
				to = nKeys - 1;
	
			while ( from !== nKeys && times[ from ] < startTime ) ++ from;
			while ( to !== -1 && times[ to ] > endTime ) -- to;
	
			++ to; // inclusive -> exclusive bound
	
			if( from !== 0 || to !== nKeys ) {
	
				// empty tracks are forbidden, so keep at least one keyframe
				if ( from >= to ) to = Math.max( to , 1 ), from = to - 1;
	
				var stride = this.getValueSize();
				this.times = THREE.AnimationUtils.arraySlice( times, from, to );
				this.values = THREE.AnimationUtils.
						arraySlice( this.values, from * stride, to * stride );
	
			}
	
			return this;
	
		},
	
		// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
		validate: function() {
	
			var valid = true;
	
			var valueSize = this.getValueSize();
			if ( valueSize - Math.floor( valueSize ) !== 0 ) {
	
				console.error( "invalid value size in track", this );
				valid = false;
	
			}
	
			var times = this.times,
				values = this.values,
	
				nKeys = times.length;
	
			if( nKeys === 0 ) {
	
				console.error( "track is empty", this );
				valid = false;
	
			}
	
			var prevTime = null;
	
			for( var i = 0; i !== nKeys; i ++ ) {
	
				var currTime = times[ i ];
	
				if ( typeof currTime === 'number' && isNaN( currTime ) ) {
	
					console.error( "time is not a valid number", this, i, currTime );
					valid = false;
					break;
	
				}
	
				if( prevTime !== null && prevTime > currTime ) {
	
					console.error( "out of order keys", this, i, currTime, prevTime );
					valid = false;
					break;
	
				}
	
				prevTime = currTime;
	
			}
	
			if ( values !== undefined ) {
	
				if ( THREE.AnimationUtils.isTypedArray( values ) ) {
	
					for ( var i = 0, n = values.length; i !== n; ++ i ) {
	
						var value = values[ i ];
	
						if ( isNaN( value ) ) {
	
							console.error( "value is not a valid number", this, i, value );
							valid = false;
							break;
	
						}
	
					}
	
				}
	
			}
	
			return valid;
	
		},
	
		// removes equivalent sequential keys as common in morph target sequences
		// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
		optimize: function() {
	
			var times = this.times,
				values = this.values,
				stride = this.getValueSize(),
	
				writeIndex = 1;
	
			for( var i = 1, n = times.length - 1; i <= n; ++ i ) {
	
				var keep = false;
	
				var time = times[ i ];
				var timeNext = times[ i + 1 ];
	
				// remove adjacent keyframes scheduled at the same time
	
				if ( time !== timeNext && ( i !== 1 || time !== time[ 0 ] ) ) {
	
					// remove unnecessary keyframes same as their neighbors
					var offset = i * stride,
						offsetP = offset - stride,
						offsetN = offset + stride;
	
					for ( var j = 0; j !== stride; ++ j ) {
	
						var value = values[ offset + j ];
	
						if ( value !== values[ offsetP + j ] ||
								value !== values[ offsetN + j ] ) {
	
							keep = true;
							break;
	
						}
	
					}
	
				}
	
				// in-place compaction
	
				if ( keep ) {
	
					if ( i !== writeIndex ) {
	
						times[ writeIndex ] = times[ i ];
	
						var readOffset = i * stride,
							writeOffset = writeIndex * stride;
	
						for ( var j = 0; j !== stride; ++ j ) {
	
							values[ writeOffset + j ] = values[ readOffset + j ];
	
						}
	
	
					}
	
					++ writeIndex;
	
				}
	
			}
	
			if ( writeIndex !== times.length ) {
	
				this.times = THREE.AnimationUtils.arraySlice( times, 0, writeIndex );
				this.values = THREE.AnimationUtils.arraySlice( values, 0, writeIndex * stride );
	
			}
	
			return this;
	
		}
	
	};
	
	// Static methods:
	
	Object.assign( THREE.KeyframeTrack, {
	
		// Serialization (in static context, because of constructor invocation
		// and automatic invocation of .toJSON):
	
		parse: function( json ) {
	
			if( json.type === undefined ) {
	
				throw new Error( "track type undefined, can not parse" );
	
			}
	
			var trackType = THREE.KeyframeTrack._getTrackTypeForValueTypeName( json.type );
	
			if ( json.times === undefined ) {
	
				console.warn( "legacy JSON format detected, converting" );
	
				var times = [], values = [];
	
				THREE.AnimationUtils.flattenJSON( json.keys, times, values, 'value' );
	
				json.times = times;
				json.values = values;
	
			}
	
			// derived classes can define a static parse method
			if ( trackType.parse !== undefined ) {
	
				return trackType.parse( json );
	
			} else {
	
				// by default, we asssume a constructor compatible with the base
				return new trackType(
						json.name, json.times, json.values, json.interpolation );
	
			}
	
		},
	
		toJSON: function( track ) {
	
			var trackType = track.constructor;
	
			var json;
	
			// derived classes can define a static toJSON method
			if ( trackType.toJSON !== undefined ) {
	
				json = trackType.toJSON( track );
	
			} else {
	
				// by default, we assume the data can be serialized as-is
				json = {
	
					'name': track.name,
					'times': THREE.AnimationUtils.convertArray( track.times, Array ),
					'values': THREE.AnimationUtils.convertArray( track.values, Array )
	
				};
	
				var interpolation = track.getInterpolation();
	
				if ( interpolation !== track.DefaultInterpolation ) {
	
					json.interpolation = interpolation;
	
				}
	
			}
	
			json.type = track.ValueTypeName; // mandatory
	
			return json;
	
		},
	
		_getTrackTypeForValueTypeName: function( typeName ) {
	
			switch( typeName.toLowerCase() ) {
	
				case "scalar":
				case "double":
				case "float":
				case "number":
				case "integer":
	
					return THREE.NumberKeyframeTrack;
	
				case "vector":
				case "vector2":
				case "vector3":
				case "vector4":
	
					return THREE.VectorKeyframeTrack;
	
				case "color":
	
					return THREE.ColorKeyframeTrack;
	
				case "quaternion":
	
					return THREE.QuaternionKeyframeTrack;
	
				case "bool":
				case "boolean":
	
					return THREE.BooleanKeyframeTrack;
	
				case "string":
	
					return THREE.StringKeyframeTrack;
	
			};
	
			throw new Error( "Unsupported typeName: " + typeName );
	
		}
	
	} );
	
	// File:src/animation/PropertyBinding.js
	
	/**
	 *
	 * A reference to a real property in the scene graph.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */
	
	THREE.PropertyBinding = function ( rootNode, path, parsedPath ) {
	
		this.path = path;
		this.parsedPath = parsedPath ||
				THREE.PropertyBinding.parseTrackName( path );
	
		this.node = THREE.PropertyBinding.findNode(
				rootNode, this.parsedPath.nodeName ) || rootNode;
	
		this.rootNode = rootNode;
	
	};
	
	THREE.PropertyBinding.prototype = {
	
		constructor: THREE.PropertyBinding,
	
		getValue: function getValue_unbound( targetArray, offset ) {
	
			this.bind();
			this.getValue( targetArray, offset );
	
			// Note: This class uses a State pattern on a per-method basis:
			// 'bind' sets 'this.getValue' / 'setValue' and shadows the
			// prototype version of these methods with one that represents
			// the bound state. When the property is not found, the methods
			// become no-ops.
	
		},
	
		setValue: function getValue_unbound( sourceArray, offset ) {
	
			this.bind();
			this.setValue( sourceArray, offset );
	
		},
	
		// create getter / setter pair for a property in the scene graph
		bind: function() {
	
			var targetObject = this.node,
				parsedPath = this.parsedPath,
	
				objectName = parsedPath.objectName,
				propertyName = parsedPath.propertyName,
				propertyIndex = parsedPath.propertyIndex;
	
			if ( ! targetObject ) {
	
				targetObject = THREE.PropertyBinding.findNode(
						this.rootNode, parsedPath.nodeName ) || this.rootNode;
	
				this.node = targetObject;
	
			}
	
			// set fail state so we can just 'return' on error
			this.getValue = this._getValue_unavailable;
			this.setValue = this._setValue_unavailable;
	
	 		// ensure there is a value node
			if ( ! targetObject ) {
	
				console.error( "  trying to update node for track: " + this.path + " but it wasn't found." );
				return;
	
			}
	
			if( objectName ) {
	
				var objectIndex = parsedPath.objectIndex;
	
				// special cases were we need to reach deeper into the hierarchy to get the face materials....
				switch ( objectName ) {
	
					case 'materials':
	
						if( ! targetObject.material ) {
	
							console.error( '  can not bind to material as node does not have a material', this );
							return;
	
						}
	
						if( ! targetObject.material.materials ) {
	
							console.error( '  can not bind to material.materials as node.material does not have a materials array', this );
							return;
	
						}
	
						targetObject = targetObject.material.materials;
	
						break;
	
					case 'bones':
	
						if( ! targetObject.skeleton ) {
	
							console.error( '  can not bind to bones as node does not have a skeleton', this );
							return;
	
						}
	
						// potential future optimization: skip this if propertyIndex is already an integer
						// and convert the integer string to a true integer.
	
						targetObject = targetObject.skeleton.bones;
	
						// support resolving morphTarget names into indices.
						for ( var i = 0; i < targetObject.length; i ++ ) {
	
							if ( targetObject[i].name === objectIndex ) {
	
								objectIndex = i;
								break;
	
							}
	
						}
	
						break;
	
					default:
	
						if ( targetObject[ objectName ] === undefined ) {
	
							console.error( '  can not bind to objectName of node, undefined', this );
							return;
	
						}
	
						targetObject = targetObject[ objectName ];
	
				}
	
	
				if ( objectIndex !== undefined ) {
	
					if( targetObject[ objectIndex ] === undefined ) {
	
						console.error( "  trying to bind to objectIndex of objectName, but is undefined:", this, targetObject );
						return;
	
					}
	
					targetObject = targetObject[ objectIndex ];
	
				}
	
			}
	
			// resolve property
			var nodeProperty = targetObject[ propertyName ];
	
			if ( ! nodeProperty ) {
	
				var nodeName = parsedPath.nodeName;
	
				console.error( "  trying to update property for track: " + nodeName +
						'.' + propertyName + " but it wasn't found.", targetObject );
				return;
	
			}
	
			// determine versioning scheme
			var versioning = this.Versioning.None;
	
			if ( targetObject.needsUpdate !== undefined ) { // material
	
				versioning = this.Versioning.NeedsUpdate;
				this.targetObject = targetObject;
	
			} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform
	
				versioning = this.Versioning.MatrixWorldNeedsUpdate;
				this.targetObject = targetObject;
	
			}
	
			// determine how the property gets bound
			var bindingType = this.BindingType.Direct;
	
			if ( propertyIndex !== undefined ) {
				// access a sub element of the property array (only primitives are supported right now)
	
				if ( propertyName === "morphTargetInfluences" ) {
					// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.
	
					// support resolving morphTarget names into indices.
					if ( ! targetObject.geometry ) {
	
						console.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry', this );
						return;
	
					}
	
					if ( ! targetObject.geometry.morphTargets ) {
	
						console.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets', this );
						return;
	
					}
	
					for ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) {
	
						if ( targetObject.geometry.morphTargets[i].name === propertyIndex ) {
	
							propertyIndex = i;
							break;
	
						}
	
					}
	
				}
	
				bindingType = this.BindingType.ArrayElement;
	
				this.resolvedProperty = nodeProperty;
				this.propertyIndex = propertyIndex;
	
			} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {
				// must use copy for Object3D.Euler/Quaternion
	
				bindingType = this.BindingType.HasFromToArray;
	
				this.resolvedProperty = nodeProperty;
	
			} else if ( nodeProperty.length !== undefined ) {
	
				bindingType = this.BindingType.EntireArray;
	
				this.resolvedProperty = nodeProperty;
	
			} else {
	
				this.propertyName = propertyName;
	
			}
	
			// select getter / setter
			this.getValue = this.GetterByBindingType[ bindingType ];
			this.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];
	
		},
	
		unbind: function() {
	
			this.node = null;
	
			// back to the prototype version of getValue / setValue
			// note: avoiding to mutate the shape of 'this' via 'delete'
			this.getValue = this._getValue_unbound;
			this.setValue = this._setValue_unbound;
	
		}
	
	};
	
	Object.assign( THREE.PropertyBinding.prototype, { // prototype, continued
	
		// these are used to "bind" a nonexistent property
		_getValue_unavailable: function() {},
		_setValue_unavailable: function() {},
	
		// initial state of these methods that calls 'bind'
		_getValue_unbound: THREE.PropertyBinding.prototype.getValue,
		_setValue_unbound: THREE.PropertyBinding.prototype.setValue,
	
		BindingType: {
			Direct: 0,
			EntireArray: 1,
			ArrayElement: 2,
			HasFromToArray: 3
		},
	
		Versioning: {
			None: 0,
			NeedsUpdate: 1,
			MatrixWorldNeedsUpdate: 2
		},
	
		GetterByBindingType: [
	
			function getValue_direct( buffer, offset ) {
	
				buffer[ offset ] = this.node[ this.propertyName ];
	
			},
	
			function getValue_array( buffer, offset ) {
	
				var source = this.resolvedProperty;
	
				for ( var i = 0, n = source.length; i !== n; ++ i ) {
	
					buffer[ offset ++ ] = source[ i ];
	
				}
	
			},
	
			function getValue_arrayElement( buffer, offset ) {
	
				buffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];
	
			},
	
			function getValue_toArray( buffer, offset ) {
	
				this.resolvedProperty.toArray( buffer, offset );
	
			}
	
		],
	
		SetterByBindingTypeAndVersioning: [
	
			[
				// Direct
	
				function setValue_direct( buffer, offset ) {
	
					this.node[ this.propertyName ] = buffer[ offset ];
	
				},
	
				function setValue_direct_setNeedsUpdate( buffer, offset ) {
	
					this.node[ this.propertyName ] = buffer[ offset ];
					this.targetObject.needsUpdate = true;
	
				},
	
				function setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {
	
					this.node[ this.propertyName ] = buffer[ offset ];
					this.targetObject.matrixWorldNeedsUpdate = true;
	
				}
	
			], [
	
				// EntireArray
	
				function setValue_array( buffer, offset ) {
	
					var dest = this.resolvedProperty;
	
					for ( var i = 0, n = dest.length; i !== n; ++ i ) {
	
						dest[ i ] = buffer[ offset ++ ];
	
					}
	
				},
	
				function setValue_array_setNeedsUpdate( buffer, offset ) {
	
					var dest = this.resolvedProperty;
	
					for ( var i = 0, n = dest.length; i !== n; ++ i ) {
	
						dest[ i ] = buffer[ offset ++ ];
	
					}
	
					this.targetObject.needsUpdate = true;
	
				},
	
				function setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {
	
					var dest = this.resolvedProperty;
	
					for ( var i = 0, n = dest.length; i !== n; ++ i ) {
	
						dest[ i ] = buffer[ offset ++ ];
	
					}
	
					this.targetObject.matrixWorldNeedsUpdate = true;
	
				}
	
			], [
	
				// ArrayElement
	
				function setValue_arrayElement( buffer, offset ) {
	
					this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
	
				},
	
				function setValue_arrayElement_setNeedsUpdate( buffer, offset ) {
	
					this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
					this.targetObject.needsUpdate = true;
	
				},
	
				function setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {
	
					this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
					this.targetObject.matrixWorldNeedsUpdate = true;
	
				}
	
			], [
	
				// HasToFromArray
	
				function setValue_fromArray( buffer, offset ) {
	
					this.resolvedProperty.fromArray( buffer, offset );
	
				},
	
				function setValue_fromArray_setNeedsUpdate( buffer, offset ) {
	
					this.resolvedProperty.fromArray( buffer, offset );
					this.targetObject.needsUpdate = true;
	
				},
	
				function setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {
	
					this.resolvedProperty.fromArray( buffer, offset );
					this.targetObject.matrixWorldNeedsUpdate = true;
	
				}
	
			]
	
		]
	
	} );
	
	THREE.PropertyBinding.Composite =
			function( targetGroup, path, optionalParsedPath ) {
	
		var parsedPath = optionalParsedPath ||
				THREE.PropertyBinding.parseTrackName( path );
	
		this._targetGroup = targetGroup;
		this._bindings = targetGroup.subscribe_( path, parsedPath );
	
	};
	
	THREE.PropertyBinding.Composite.prototype = {
	
		constructor: THREE.PropertyBinding.Composite,
	
		getValue: function( array, offset ) {
	
			this.bind(); // bind all binding
	
			var firstValidIndex = this._targetGroup.nCachedObjects_,
				binding = this._bindings[ firstValidIndex ];
	
			// and only call .getValue on the first
			if ( binding !== undefined ) binding.getValue( array, offset );
	
		},
	
		setValue: function( array, offset ) {
	
			var bindings = this._bindings;
	
			for ( var i = this._targetGroup.nCachedObjects_,
					n = bindings.length; i !== n; ++ i ) {
	
				bindings[ i ].setValue( array, offset );
	
			}
	
		},
	
		bind: function() {
	
			var bindings = this._bindings;
	
			for ( var i = this._targetGroup.nCachedObjects_,
					n = bindings.length; i !== n; ++ i ) {
	
				bindings[ i ].bind();
	
			}
	
		},
	
		unbind: function() {
	
			var bindings = this._bindings;
	
			for ( var i = this._targetGroup.nCachedObjects_,
					n = bindings.length; i !== n; ++ i ) {
	
				bindings[ i ].unbind();
	
			}
	
		}
	
	};
	
	THREE.PropertyBinding.create = function( root, path, parsedPath ) {
	
		if ( ! ( root instanceof THREE.AnimationObjectGroup ) ) {
	
			return new THREE.PropertyBinding( root, path, parsedPath );
	
		} else {
	
			return new THREE.PropertyBinding.Composite( root, path, parsedPath );
	
		}
	
	};
	
	THREE.PropertyBinding.parseTrackName = function( trackName ) {
	
		// matches strings in the form of:
		//    nodeName.property
		//    nodeName.property[accessor]
		//    nodeName.material.property[accessor]
		//    uuid.property[accessor]
		//    uuid.objectName[objectIndex].propertyName[propertyIndex]
		//    parentName/nodeName.property
		//    parentName/parentName/nodeName.property[index]
		//	  .bone[Armature.DEF_cog].position
		// created and tested via https://regex101.com/#javascript
	
		var re = /^(([\w]+\/)*)([\w-\d]+)?(\.([\w]+)(\[([\w\d\[\]\_. ]+)\])?)?(\.([\w.]+)(\[([\w\d\[\]\_. ]+)\])?)$/;
		var matches = re.exec(trackName);
	
		if( ! matches ) {
			throw new Error( "cannot parse trackName at all: " + trackName );
		}
	
	    if (matches.index === re.lastIndex) {
	        re.lastIndex++;
	    }
	
		var results = {
			// directoryName: matches[1], // (tschw) currently unused
			nodeName: matches[3], 	// allowed to be null, specified root node.
			objectName: matches[5],
			objectIndex: matches[7],
			propertyName: matches[9],
			propertyIndex: matches[11]	// allowed to be null, specifies that the whole property is set.
		};
	
		if( results.propertyName === null || results.propertyName.length === 0 ) {
			throw new Error( "can not parse propertyName from trackName: " + trackName );
		}
	
		return results;
	
	};
	
	THREE.PropertyBinding.findNode = function( root, nodeName ) {
	
		if( ! nodeName || nodeName === "" || nodeName === "root" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid ) {
	
			return root;
	
		}
	
		// search into skeleton bones.
		if( root.skeleton ) {
	
			var searchSkeleton = function( skeleton ) {
	
				for( var i = 0; i < skeleton.bones.length; i ++ ) {
	
					var bone = skeleton.bones[i];
	
					if( bone.name === nodeName ) {
	
						return bone;
	
					}
				}
	
				return null;
	
			};
	
			var bone = searchSkeleton( root.skeleton );
	
			if( bone ) {
	
				return bone;
	
			}
		}
	
		// search into node subtree.
		if( root.children ) {
	
			var searchNodeSubtree = function( children ) {
	
				for( var i = 0; i < children.length; i ++ ) {
	
					var childNode = children[i];
	
					if( childNode.name === nodeName || childNode.uuid === nodeName ) {
	
						return childNode;
	
					}
	
					var result = searchNodeSubtree( childNode.children );
	
					if( result ) return result;
	
				}
	
				return null;
	
			};
	
			var subTreeNode = searchNodeSubtree( root.children );
	
			if( subTreeNode ) {
	
				return subTreeNode;
	
			}
	
		}
	
		return null;
	
	}
	
	// File:src/animation/PropertyMixer.js
	
	/**
	 *
	 * Buffered scene graph property that allows weighted accumulation.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */
	
	THREE.PropertyMixer = function ( binding, typeName, valueSize ) {
	
		this.binding = binding;
		this.valueSize = valueSize;
	
		var bufferType = Float64Array,
			mixFunction;
	
		switch ( typeName ) {
	
			case 'quaternion':			mixFunction = this._slerp;		break;
	
			case 'string':
			case 'bool':
	
				bufferType = Array,		mixFunction = this._select;		break;
	
			default:					mixFunction = this._lerp;
	
		}
	
		this.buffer = new bufferType( valueSize * 4 );
		// layout: [ incoming | accu0 | accu1 | orig ]
		//
		// interpolators can use .buffer as their .result
		// the data then goes to 'incoming'
		//
		// 'accu0' and 'accu1' are used frame-interleaved for
		// the cumulative result and are compared to detect
		// changes
		//
		// 'orig' stores the original state of the property
	
		this._mixBufferRegion = mixFunction;
	
		this.cumulativeWeight = 0;
	
		this.useCount = 0;
		this.referenceCount = 0;
	
	};
	
	THREE.PropertyMixer.prototype = {
	
		constructor: THREE.PropertyMixer,
	
		// accumulate data in the 'incoming' region into 'accu<i>'
		accumulate: function( accuIndex, weight ) {
	
			// note: happily accumulating nothing when weight = 0, the caller knows
			// the weight and shouldn't have made the call in the first place
	
			var buffer = this.buffer,
				stride = this.valueSize,
				offset = accuIndex * stride + stride,
	
				currentWeight = this.cumulativeWeight;
	
			if ( currentWeight === 0 ) {
	
				// accuN := incoming * weight
	
				for ( var i = 0; i !== stride; ++ i ) {
	
					buffer[ offset + i ] = buffer[ i ];
	
				}
	
				currentWeight = weight;
	
			} else {
	
				// accuN := accuN + incoming * weight
	
				currentWeight += weight;
				var mix = weight / currentWeight;
				this._mixBufferRegion( buffer, offset, 0, mix, stride );
	
			}
	
			this.cumulativeWeight = currentWeight;
	
		},
	
		// apply the state of 'accu<i>' to the binding when accus differ
		apply: function( accuIndex ) {
	
			var stride = this.valueSize,
				buffer = this.buffer,
				offset = accuIndex * stride + stride,
	
				weight = this.cumulativeWeight,
	
				binding = this.binding;
	
			this.cumulativeWeight = 0;
	
			if ( weight < 1 ) {
	
				// accuN := accuN + original * ( 1 - cumulativeWeight )
	
				var originalValueOffset = stride * 3;
	
				this._mixBufferRegion(
						buffer, offset, originalValueOffset, 1 - weight, stride );
	
			}
	
			for ( var i = stride, e = stride + stride; i !== e; ++ i ) {
	
				if ( buffer[ i ] !== buffer[ i + stride ] ) {
	
					// value has changed -> update scene graph
	
					binding.setValue( buffer, offset );
					break;
	
				}
	
			}
	
		},
	
		// remember the state of the bound property and copy it to both accus
		saveOriginalState: function() {
	
			var binding = this.binding;
	
			var buffer = this.buffer,
				stride = this.valueSize,
	
				originalValueOffset = stride * 3;
	
			binding.getValue( buffer, originalValueOffset );
	
			// accu[0..1] := orig -- initially detect changes against the original
			for ( var i = stride, e = originalValueOffset; i !== e; ++ i ) {
	
				buffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];
	
			}
	
			this.cumulativeWeight = 0;
	
		},
	
		// apply the state previously taken via 'saveOriginalState' to the binding
		restoreOriginalState: function() {
	
			var originalValueOffset = this.valueSize * 3;
			this.binding.setValue( this.buffer, originalValueOffset );
	
		},
	
	
		// mix functions
	
		_select: function( buffer, dstOffset, srcOffset, t, stride ) {
	
			if ( t >= 0.5 ) {
	
				for ( var i = 0; i !== stride; ++ i ) {
	
					buffer[ dstOffset + i ] = buffer[ srcOffset + i ];
	
				}
	
			}
	
		},
	
		_slerp: function( buffer, dstOffset, srcOffset, t, stride ) {
	
			THREE.Quaternion.slerpFlat( buffer, dstOffset,
					buffer, dstOffset, buffer, srcOffset, t );
	
		},
	
		_lerp: function( buffer, dstOffset, srcOffset, t, stride ) {
	
			var s = 1 - t;
	
			for ( var i = 0; i !== stride; ++ i ) {
	
				var j = dstOffset + i;
	
				buffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;
	
			}
	
		}
	
	};
	
	// File:src/animation/tracks/BooleanKeyframeTrack.js
	
	/**
	 *
	 * A Track of Boolean keyframe values.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */
	
	THREE.BooleanKeyframeTrack = function ( name, times, values ) {
	
		THREE.KeyframeTrack.call( this, name, times, values );
	
	};
	
	THREE.BooleanKeyframeTrack.prototype =
			Object.assign( Object.create( THREE.KeyframeTrack.prototype ), {
	
		constructor: THREE.BooleanKeyframeTrack,
	
		ValueTypeName: 'bool',
		ValueBufferType: Array,
	
		DefaultInterpolation: THREE.IntepolateDiscrete,
	
		InterpolantFactoryMethodLinear: undefined,
		InterpolantFactoryMethodSmooth: undefined
	
		// Note: Actually this track could have a optimized / compressed
		// representation of a single value and a custom interpolant that
		// computes "firstValue ^ isOdd( index )".
	
	} );
	
	// File:src/animation/tracks/NumberKeyframeTrack.js
	
	/**
	 *
	 * A Track of numeric keyframe values.
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */
	
	THREE.NumberKeyframeTrack = function ( name, times, values, interpolation ) {
	
		THREE.KeyframeTrack.call( this, name, times, values, interpolation );
	
	};
	
	THREE.NumberKeyframeTrack.prototype =
			Object.assign( Object.create( THREE.KeyframeTrack.prototype ), {
	
		constructor: THREE.NumberKeyframeTrack,
	
		ValueTypeName: 'number',
	
		// ValueBufferType is inherited
	
		// DefaultInterpolation is inherited
	
	} );
	
	// File:src/animation/tracks/QuaternionKeyframeTrack.js
	
	/**
	 *
	 * A Track of quaternion keyframe values.
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */
	
	THREE.QuaternionKeyframeTrack = function ( name, times, values, interpolation ) {
	
		THREE.KeyframeTrack.call( this, name, times, values, interpolation );
	
	};
	
	THREE.QuaternionKeyframeTrack.prototype =
			Object.assign( Object.create( THREE.KeyframeTrack.prototype ), {
	
		constructor: THREE.QuaternionKeyframeTrack,
	
		ValueTypeName: 'quaternion',
	
		// ValueBufferType is inherited
	
		DefaultInterpolation: THREE.InterpolateLinear,
	
		InterpolantFactoryMethodLinear: function( result ) {
	
			return new THREE.QuaternionLinearInterpolant(
					this.times, this.values, this.getValueSize(), result );
	
		},
	
		InterpolantFactoryMethodSmooth: undefined // not yet implemented
	
	} );
	
	// File:src/animation/tracks/StringKeyframeTrack.js
	
	/**
	 *
	 * A Track that interpolates Strings
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */
	
	THREE.StringKeyframeTrack = function ( name, times, values, interpolation ) {
	
		THREE.KeyframeTrack.call( this, name, times, values, interpolation );
	
	};
	
	THREE.StringKeyframeTrack.prototype =
			Object.assign( Object.create( THREE.KeyframeTrack.prototype ), {
	
		constructor: THREE.StringKeyframeTrack,
	
		ValueTypeName: 'string',
		ValueBufferType: Array,
	
		DefaultInterpolation: THREE.IntepolateDiscrete,
	
		InterpolantFactoryMethodLinear: undefined,
	
		InterpolantFactoryMethodSmooth: undefined
	
	} );
	
	// File:src/animation/tracks/VectorKeyframeTrack.js
	
	/**
	 *
	 * A Track of vectored keyframe values.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */
	
	THREE.VectorKeyframeTrack = function ( name, times, values, interpolation ) {
	
		THREE.KeyframeTrack.call( this, name, times, values, interpolation );
	
	};
	
	THREE.VectorKeyframeTrack.prototype =
			Object.assign( Object.create( THREE.KeyframeTrack.prototype ), {
	
		constructor: THREE.VectorKeyframeTrack,
	
		ValueTypeName: 'vector'
	
		// ValueBufferType is inherited
	
		// DefaultInterpolation is inherited
	
	} );
	
	// File:src/audio/Audio.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.Audio = function ( listener ) {
	
		THREE.Object3D.call( this );
	
		this.type = 'Audio';
	
		this.context = listener.context;
		this.source = this.context.createBufferSource();
		this.source.onended = this.onEnded.bind( this );
	
		this.gain = this.context.createGain();
		this.gain.connect( listener.getInput() );
	
		this.autoplay = false;
	
		this.startTime = 0;
		this.playbackRate = 1;
		this.isPlaying = false;
		this.hasPlaybackControl = true;
		this.sourceType = 'empty';
	
		this.filter = null;
	
	};
	
	THREE.Audio.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Audio.prototype.constructor = THREE.Audio;
	
	THREE.Audio.prototype.getOutput = function () {
	
		return this.gain;
	
	};
	
	THREE.Audio.prototype.load = function ( file ) {
	
		var buffer = new THREE.AudioBuffer( this.context );
		buffer.load( file );
	
		this.setBuffer( buffer );
	
		return this;
	
	};
	
	THREE.Audio.prototype.setNodeSource = function ( audioNode ) {
	
		this.hasPlaybackControl = false;
		this.sourceType = 'audioNode';
		this.source = audioNode;
		this.connect();
	
		return this;
	
	};
	
	THREE.Audio.prototype.setBuffer = function ( audioBuffer ) {
	
		var scope = this;
	
		audioBuffer.onReady( function( buffer ) {
	
			scope.source.buffer = buffer;
			scope.sourceType = 'buffer';
			if ( scope.autoplay ) scope.play();
	
		} );
	
		return this;
	
	};
	
	THREE.Audio.prototype.play = function () {
	
		if ( this.isPlaying === true ) {
	
			console.warn( 'THREE.Audio: Audio is already playing.' );
			return;
	
		}
	
		if ( this.hasPlaybackControl === false ) {
	
			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;
	
		}
	
		var source = this.context.createBufferSource();
	
		source.buffer = this.source.buffer;
		source.loop = this.source.loop;
		source.onended = this.source.onended;
		source.start( 0, this.startTime );
		source.playbackRate.value = this.playbackRate;
	
		this.isPlaying = true;
	
		this.source = source;
	
		this.connect();
	
	};
	
	THREE.Audio.prototype.pause = function () {
	
		if ( this.hasPlaybackControl === false ) {
	
			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;
	
		}
	
		this.source.stop();
		this.startTime = this.context.currentTime;
	
	};
	
	THREE.Audio.prototype.stop = function () {
	
		if ( this.hasPlaybackControl === false ) {
	
			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;
	
		}
	
		this.source.stop();
		this.startTime = 0;
	
	};
	
	THREE.Audio.prototype.connect = function () {
	
		if ( this.filter !== null ) {
	
			this.source.connect( this.filter );
			this.filter.connect( this.getOutput() );
	
		} else {
	
			this.source.connect( this.getOutput() );
	
		}
	
	};
	
	THREE.Audio.prototype.disconnect = function () {
	
		if ( this.filter !== null ) {
	
			this.source.disconnect( this.filter );
			this.filter.disconnect( this.getOutput() );
	
		} else {
	
			this.source.disconnect( this.getOutput() );
	
		}
	
	};
	
	THREE.Audio.prototype.getFilter = function () {
	
		return this.filter;
	
	};
	
	THREE.Audio.prototype.setFilter = function ( value ) {
	
		if ( value === undefined ) value = null;
	
		if ( this.isPlaying === true ) {
	
			this.disconnect();
			this.filter = value;
			this.connect();
	
		} else {
	
			this.filter = value;
	
		}
	
	};
	
	THREE.Audio.prototype.setPlaybackRate = function ( value ) {
	
		if ( this.hasPlaybackControl === false ) {
	
			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;
	
		}
	
		this.playbackRate = value;
	
		if ( this.isPlaying === true ) {
	
			this.source.playbackRate.value = this.playbackRate;
	
		}
	
	};
	
	THREE.Audio.prototype.getPlaybackRate = function () {
	
		return this.playbackRate;
	
	};
	
	THREE.Audio.prototype.onEnded = function() {
	
		this.isPlaying = false;
	
	};
	
	THREE.Audio.prototype.setLoop = function ( value ) {
	
		if ( this.hasPlaybackControl === false ) {
	
			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;
	
		}
	
		this.source.loop = value;
	
	};
	
	THREE.Audio.prototype.getLoop = function () {
	
		if ( this.hasPlaybackControl === false ) {
	
			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return false;
	
		}
	
		return this.source.loop;
	
	};
	
	
	THREE.Audio.prototype.setVolume = function ( value ) {
	
		this.gain.gain.value = value;
	
	};
	
	THREE.Audio.prototype.getVolume = function () {
	
		return this.gain.gain.value;
	
	};
	
	// File:src/audio/AudioAnalyser.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.AudioAnalyser = function ( audio, fftSize ) {
	
		this.analyser = audio.context.createAnalyser();
		this.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;
	
		this.data = new Uint8Array( this.analyser.frequencyBinCount );
	
		audio.getOutput().connect( this.analyser );
	
	};
	
	THREE.AudioAnalyser.prototype = {
	
		constructor: THREE.AudioAnalyser,
	
		getData: function () {
	
			this.analyser.getByteFrequencyData( this.data );
			return this.data;
	
		}
	
	};
	
	// File:src/audio/AudioBuffer.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.AudioBuffer = function ( context ) {
	
		this.context = context;
		this.ready = false;
		this.readyCallbacks = [];
	
	};
	
	THREE.AudioBuffer.prototype.load = function ( file ) {
	
		var scope = this;
	
		var request = new XMLHttpRequest();
		request.open( 'GET', file, true );
		request.responseType = 'arraybuffer';
		request.onload = function ( e ) {
	
			scope.context.decodeAudioData( this.response, function ( buffer ) {
	
				scope.buffer = buffer;
				scope.ready = true;
	
				for ( var i = 0; i < scope.readyCallbacks.length; i ++ ) {
	
					scope.readyCallbacks[ i ]( scope.buffer );
	
				}
	
				scope.readyCallbacks = [];
	
			} );
	
		};
		request.send();
	
		return this;
	
	};
	
	THREE.AudioBuffer.prototype.onReady = function ( callback ) {
	
		if ( this.ready ) {
	
			callback( this.buffer );
	
		} else {
	
			this.readyCallbacks.push( callback );
	
		}
	
	};
	
	// File:src/audio/PositionalAudio.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.PositionalAudio = function ( listener ) {
	
		THREE.Audio.call( this, listener );
	
		this.panner = this.context.createPanner();
		this.panner.connect( this.gain );
	
	};
	
	THREE.PositionalAudio.prototype = Object.create( THREE.Audio.prototype );
	THREE.PositionalAudio.prototype.constructor = THREE.PositionalAudio;
	
	THREE.PositionalAudio.prototype.getOutput = function () {
	
		return this.panner;
	
	};
	
	THREE.PositionalAudio.prototype.setRefDistance = function ( value ) {
	
		this.panner.refDistance = value;
	
	};
	
	THREE.PositionalAudio.prototype.getRefDistance = function () {
	
		return this.panner.refDistance;
	
	};
	
	THREE.PositionalAudio.prototype.setRolloffFactor = function ( value ) {
	
		this.panner.rolloffFactor = value;
	
	};
	
	THREE.PositionalAudio.prototype.getRolloffFactor = function () {
	
		return this.panner.rolloffFactor;
	
	};
	
	THREE.PositionalAudio.prototype.setDistanceModel = function ( value ) {
	
		this.panner.distanceModel = value;
	
	};
	
	THREE.PositionalAudio.prototype.getDistanceModel = function () {
	
		return this.panner.distanceModel;
	
	};
	
	THREE.PositionalAudio.prototype.setMaxDistance = function ( value ) {
	
		this.panner.maxDistance = value;
	
	};
	
	THREE.PositionalAudio.prototype.getMaxDistance = function () {
	
		return this.panner.maxDistance;
	
	};
	
	THREE.PositionalAudio.prototype.updateMatrixWorld = ( function () {
	
		var position = new THREE.Vector3();
	
		return function updateMatrixWorld( force ) {
	
			THREE.Object3D.prototype.updateMatrixWorld.call( this, force );
	
			position.setFromMatrixPosition( this.matrixWorld );
	
			this.panner.setPosition( position.x, position.y, position.z );
	
		};
	
	} )();
	
	// File:src/audio/AudioListener.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.AudioListener = function () {
	
		THREE.Object3D.call( this );
	
		this.type = 'AudioListener';
	
		this.context = new ( window.AudioContext || window.webkitAudioContext )();
	
		this.gain = this.context.createGain();
		this.gain.connect( this.context.destination );
	
		this.filter = null;
	
	};
	
	THREE.AudioListener.prototype = Object.create( THREE.Object3D.prototype );
	THREE.AudioListener.prototype.constructor = THREE.AudioListener;
	
	THREE.AudioListener.prototype.getInput = function () {
	
		return this.gain;
	
	};
	
	THREE.AudioListener.prototype.removeFilter = function ( ) {
	
		if ( this.filter !== null ) {
	
			this.gain.disconnect( this.filter );
			this.filter.disconnect( this.context.destination );
			this.gain.connect( this.context.destination );
			this.filter = null;
	
		}
	
	};
	
	THREE.AudioListener.prototype.setFilter = function ( value ) {
	
		if ( this.filter !== null ) {
	
			this.gain.disconnect( this.filter );
			this.filter.disconnect( this.context.destination );
	
		} else {
	
			this.gain.disconnect( this.context.destination );
	
		}
	
		this.filter = value;
		this.gain.connect( this.filter );
		this.filter.connect( this.context.destination );
	
	};
	
	THREE.AudioListener.prototype.getFilter = function () {
	
		return this.filter;
	
	};
	
	THREE.AudioListener.prototype.setMasterVolume = function ( value ) {
	
		this.gain.gain.value = value;
	
	};
	
	THREE.AudioListener.prototype.getMasterVolume = function () {
	
		return this.gain.gain.value;
	
	};
	
	
	THREE.AudioListener.prototype.updateMatrixWorld = ( function () {
	
		var position = new THREE.Vector3();
		var quaternion = new THREE.Quaternion();
		var scale = new THREE.Vector3();
	
		var orientation = new THREE.Vector3();
	
		return function updateMatrixWorld( force ) {
	
			THREE.Object3D.prototype.updateMatrixWorld.call( this, force );
	
			var listener = this.context.listener;
			var up = this.up;
	
			this.matrixWorld.decompose( position, quaternion, scale );
	
			orientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );
	
			listener.setPosition( position.x, position.y, position.z );
			listener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );
	
		};
	
	} )();
	
	// File:src/cameras/Camera.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author WestLangley / http://github.com/WestLangley
	*/
	
	THREE.Camera = function () {
	
		THREE.Object3D.call( this );
	
		this.type = 'Camera';
	
		this.matrixWorldInverse = new THREE.Matrix4();
		this.projectionMatrix = new THREE.Matrix4();
	
	};
	
	THREE.Camera.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Camera.prototype.constructor = THREE.Camera;
	
	THREE.Camera.prototype.getWorldDirection = function () {
	
		var quaternion = new THREE.Quaternion();
	
		return function ( optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
	
			this.getWorldQuaternion( quaternion );
	
			return result.set( 0, 0, - 1 ).applyQuaternion( quaternion );
	
		};
	
	}();
	
	THREE.Camera.prototype.lookAt = function () {
	
		// This routine does not support cameras with rotated and/or translated parent(s)
	
		var m1 = new THREE.Matrix4();
	
		return function ( vector ) {
	
			m1.lookAt( this.position, vector, this.up );
	
			this.quaternion.setFromRotationMatrix( m1 );
	
		};
	
	}();
	
	THREE.Camera.prototype.clone = function () {
	
		return new this.constructor().copy( this );
	
	};
	
	THREE.Camera.prototype.copy = function ( source ) {
	
		THREE.Object3D.prototype.copy.call( this, source );
	
		this.matrixWorldInverse.copy( source.matrixWorldInverse );
		this.projectionMatrix.copy( source.projectionMatrix );
	
		return this;
	
	};
	
	// File:src/cameras/CubeCamera.js
	
	/**
	 * Camera for rendering cube maps
	 *	- renders scene into axis-aligned cube
	 *
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.CubeCamera = function ( near, far, cubeResolution ) {
	
		THREE.Object3D.call( this );
	
		this.type = 'CubeCamera';
	
		var fov = 90, aspect = 1;
	
		var cameraPX = new THREE.PerspectiveCamera( fov, aspect, near, far );
		cameraPX.up.set( 0, - 1, 0 );
		cameraPX.lookAt( new THREE.Vector3( 1, 0, 0 ) );
		this.add( cameraPX );
	
		var cameraNX = new THREE.PerspectiveCamera( fov, aspect, near, far );
		cameraNX.up.set( 0, - 1, 0 );
		cameraNX.lookAt( new THREE.Vector3( - 1, 0, 0 ) );
		this.add( cameraNX );
	
		var cameraPY = new THREE.PerspectiveCamera( fov, aspect, near, far );
		cameraPY.up.set( 0, 0, 1 );
		cameraPY.lookAt( new THREE.Vector3( 0, 1, 0 ) );
		this.add( cameraPY );
	
		var cameraNY = new THREE.PerspectiveCamera( fov, aspect, near, far );
		cameraNY.up.set( 0, 0, - 1 );
		cameraNY.lookAt( new THREE.Vector3( 0, - 1, 0 ) );
		this.add( cameraNY );
	
		var cameraPZ = new THREE.PerspectiveCamera( fov, aspect, near, far );
		cameraPZ.up.set( 0, - 1, 0 );
		cameraPZ.lookAt( new THREE.Vector3( 0, 0, 1 ) );
		this.add( cameraPZ );
	
		var cameraNZ = new THREE.PerspectiveCamera( fov, aspect, near, far );
		cameraNZ.up.set( 0, - 1, 0 );
		cameraNZ.lookAt( new THREE.Vector3( 0, 0, - 1 ) );
		this.add( cameraNZ );
	
		var options = { format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter };
	
		this.renderTarget = new THREE.WebGLRenderTargetCube( cubeResolution, cubeResolution, options );
	
		this.updateCubeMap = function ( renderer, scene ) {
	
			if ( this.parent === null ) this.updateMatrixWorld();
	
			var renderTarget = this.renderTarget;
			var generateMipmaps = renderTarget.texture.generateMipmaps;
	
			renderTarget.texture.generateMipmaps = false;
	
			renderTarget.activeCubeFace = 0;
			renderer.render( scene, cameraPX, renderTarget );
	
			renderTarget.activeCubeFace = 1;
			renderer.render( scene, cameraNX, renderTarget );
	
			renderTarget.activeCubeFace = 2;
			renderer.render( scene, cameraPY, renderTarget );
	
			renderTarget.activeCubeFace = 3;
			renderer.render( scene, cameraNY, renderTarget );
	
			renderTarget.activeCubeFace = 4;
			renderer.render( scene, cameraPZ, renderTarget );
	
			renderTarget.texture.generateMipmaps = generateMipmaps;
	
			renderTarget.activeCubeFace = 5;
			renderer.render( scene, cameraNZ, renderTarget );
	
			renderer.setRenderTarget( null );
	
		};
	
	};
	
	THREE.CubeCamera.prototype = Object.create( THREE.Object3D.prototype );
	THREE.CubeCamera.prototype.constructor = THREE.CubeCamera;
	
	// File:src/cameras/OrthographicCamera.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.OrthographicCamera = function ( left, right, top, bottom, near, far ) {
	
		THREE.Camera.call( this );
	
		this.type = 'OrthographicCamera';
	
		this.zoom = 1;
	
		this.left = left;
		this.right = right;
		this.top = top;
		this.bottom = bottom;
	
		this.near = ( near !== undefined ) ? near : 0.1;
		this.far = ( far !== undefined ) ? far : 2000;
	
		this.updateProjectionMatrix();
	
	};
	
	THREE.OrthographicCamera.prototype = Object.create( THREE.Camera.prototype );
	THREE.OrthographicCamera.prototype.constructor = THREE.OrthographicCamera;
	
	THREE.OrthographicCamera.prototype.updateProjectionMatrix = function () {
	
		var dx = ( this.right - this.left ) / ( 2 * this.zoom );
		var dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
		var cx = ( this.right + this.left ) / 2;
		var cy = ( this.top + this.bottom ) / 2;
	
		this.projectionMatrix.makeOrthographic( cx - dx, cx + dx, cy + dy, cy - dy, this.near, this.far );
	
	};
	
	THREE.OrthographicCamera.prototype.copy = function ( source ) {
	
		THREE.Camera.prototype.copy.call( this, source );
	
		this.left = source.left;
		this.right = source.right;
		this.top = source.top;
		this.bottom = source.bottom;
		this.near = source.near;
		this.far = source.far;
	
		this.zoom = source.zoom;
	
		return this;
	
	};
	
	THREE.OrthographicCamera.prototype.toJSON = function ( meta ) {
	
		var data = THREE.Object3D.prototype.toJSON.call( this, meta );
	
		data.object.zoom = this.zoom;
		data.object.left = this.left;
		data.object.right = this.right;
		data.object.top = this.top;
		data.object.bottom = this.bottom;
		data.object.near = this.near;
		data.object.far = this.far;
	
		return data;
	
	};
	
	// File:src/cameras/PerspectiveCamera.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author greggman / http://games.greggman.com/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 */
	
	THREE.PerspectiveCamera = function ( fov, aspect, near, far ) {
	
		THREE.Camera.call( this );
	
		this.type = 'PerspectiveCamera';
	
		this.focalLength = 10;
		this.zoom = 1;
	
		this.fov = fov !== undefined ? fov : 50;
		this.aspect = aspect !== undefined ? aspect : 1;
		this.near = near !== undefined ? near : 0.1;
		this.far = far !== undefined ? far : 2000;
	
		this.updateProjectionMatrix();
	
	};
	
	THREE.PerspectiveCamera.prototype = Object.create( THREE.Camera.prototype );
	THREE.PerspectiveCamera.prototype.constructor = THREE.PerspectiveCamera;
	
	
	/**
	 * Uses Focal Length (in mm) to estimate and set FOV
	 * 35mm (full-frame) camera is used if frame size is not specified;
	 * Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html
	 */
	
	THREE.PerspectiveCamera.prototype.setLens = function ( focalLength, frameHeight ) {
	
		if ( frameHeight === undefined ) frameHeight = 24;
	
		this.fov = 2 * THREE.Math.radToDeg( Math.atan( frameHeight / ( focalLength * 2 ) ) );
		this.updateProjectionMatrix();
	
	};
	
	
	/**
	 * Sets an offset in a larger frustum. This is useful for multi-window or
	 * multi-monitor/multi-machine setups.
	 *
	 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
	 * the monitors are in grid like this
	 *
	 *   +---+---+---+
	 *   | A | B | C |
	 *   +---+---+---+
	 *   | D | E | F |
	 *   +---+---+---+
	 *
	 * then for each monitor you would call it like this
	 *
	 *   var w = 1920;
	 *   var h = 1080;
	 *   var fullWidth = w * 3;
	 *   var fullHeight = h * 2;
	 *
	 *   --A--
	 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
	 *   --B--
	 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
	 *   --C--
	 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
	 *   --D--
	 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
	 *   --E--
	 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
	 *   --F--
	 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
	 *
	 *   Note there is no reason monitors have to be the same size or in a grid.
	 */
	
	THREE.PerspectiveCamera.prototype.setViewOffset = function ( fullWidth, fullHeight, x, y, width, height ) {
	
		this.fullWidth = fullWidth;
		this.fullHeight = fullHeight;
		this.x = x;
		this.y = y;
		this.width = width;
		this.height = height;
	
		this.updateProjectionMatrix();
	
	};
	
	
	THREE.PerspectiveCamera.prototype.updateProjectionMatrix = function () {
	
		var fov = THREE.Math.radToDeg( 2 * Math.atan( Math.tan( THREE.Math.degToRad( this.fov ) * 0.5 ) / this.zoom ) );
	
		if ( this.fullWidth ) {
	
			var aspect = this.fullWidth / this.fullHeight;
			var top = Math.tan( THREE.Math.degToRad( fov * 0.5 ) ) * this.near;
			var bottom = - top;
			var left = aspect * bottom;
			var right = aspect * top;
			var width = Math.abs( right - left );
			var height = Math.abs( top - bottom );
	
			this.projectionMatrix.makeFrustum(
				left + this.x * width / this.fullWidth,
				left + ( this.x + this.width ) * width / this.fullWidth,
				top - ( this.y + this.height ) * height / this.fullHeight,
				top - this.y * height / this.fullHeight,
				this.near,
				this.far
			);
	
		} else {
	
			this.projectionMatrix.makePerspective( fov, this.aspect, this.near, this.far );
	
		}
	
	};
	
	THREE.PerspectiveCamera.prototype.copy = function ( source ) {
	
		THREE.Camera.prototype.copy.call( this, source );
	
		this.focalLength = source.focalLength;
		this.zoom = source.zoom;
	
		this.fov = source.fov;
		this.aspect = source.aspect;
		this.near = source.near;
		this.far = source.far;
	
		return this;
	
	};
	
	THREE.PerspectiveCamera.prototype.toJSON = function ( meta ) {
	
		var data = THREE.Object3D.prototype.toJSON.call( this, meta );
	
		data.object.focalLength = this.focalLength;
		data.object.zoom = this.zoom;
	
		data.object.fov = this.fov;
		data.object.aspect = this.aspect;
		data.object.near = this.near;
		data.object.far = this.far;
	
		return data;
	
	};
	
	// File:src/cameras/StereoCamera.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.StereoCamera = function () {
	
		this.type = 'StereoCamera';
	
		this.aspect = 1;
	
		this.cameraL = new THREE.PerspectiveCamera();
		this.cameraL.layers.enable( 1 );
		this.cameraL.matrixAutoUpdate = false;
	
		this.cameraR = new THREE.PerspectiveCamera();
		this.cameraR.layers.enable( 2 );
		this.cameraR.matrixAutoUpdate = false;
	
	};
	
	THREE.StereoCamera.prototype = {
	
		constructor: THREE.StereoCamera,
	
		update: ( function () {
	
			var focalLength, fov, aspect, near, far;
	
			var eyeRight = new THREE.Matrix4();
			var eyeLeft = new THREE.Matrix4();
	
			return function update ( camera ) {
	
				var needsUpdate = focalLength !== camera.focalLength || fov !== camera.fov ||
													aspect !== camera.aspect * this.aspect || near !== camera.near ||
													far !== camera.far;
	
				if ( needsUpdate ) {
	
					focalLength = camera.focalLength;
					fov = camera.fov;
					aspect = camera.aspect * this.aspect;
					near = camera.near;
					far = camera.far;
	
					// Off-axis stereoscopic effect based on
					// http://paulbourke.net/stereographics/stereorender/
	
					var projectionMatrix = camera.projectionMatrix.clone();
					var eyeSep = 0.064 / 2;
					var eyeSepOnProjection = eyeSep * near / focalLength;
					var ymax = near * Math.tan( THREE.Math.degToRad( fov * 0.5 ) );
					var xmin, xmax;
	
					// translate xOffset
	
					eyeLeft.elements[ 12 ] = - eyeSep;
					eyeRight.elements[ 12 ] = eyeSep;
	
					// for left eye
	
					xmin = - ymax * aspect + eyeSepOnProjection;
					xmax = ymax * aspect + eyeSepOnProjection;
	
					projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );
					projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );
	
					this.cameraL.projectionMatrix.copy( projectionMatrix );
	
					// for right eye
	
					xmin = - ymax * aspect - eyeSepOnProjection;
					xmax = ymax * aspect - eyeSepOnProjection;
	
					projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );
					projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );
	
					this.cameraR.projectionMatrix.copy( projectionMatrix );
	
				}
	
				this.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( eyeLeft );
				this.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( eyeRight );
	
			};
	
		} )()
	
	};
	
	// File:src/lights/Light.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.Light = function ( color, intensity ) {
	
		THREE.Object3D.call( this );
	
		this.type = 'Light';
	
		this.color = new THREE.Color( color );
		this.intensity = intensity !== undefined ? intensity : 1;
	
		this.receiveShadow = undefined;
	
	};
	
	THREE.Light.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Light.prototype.constructor = THREE.Light;
	
	THREE.Light.prototype.copy = function ( source ) {
	
		THREE.Object3D.prototype.copy.call( this, source );
	
		this.color.copy( source.color );
		this.intensity = source.intensity;
	
		return this;
	
	};
	
	THREE.Light.prototype.toJSON = function ( meta ) {
	
		var data = THREE.Object3D.prototype.toJSON.call( this, meta );
	
		data.object.color = this.color.getHex();
		data.object.intensity = this.intensity;
	
		if ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();
	
		if ( this.distance !== undefined ) data.object.distance = this.distance;
		if ( this.angle !== undefined ) data.object.angle = this.angle;
		if ( this.decay !== undefined ) data.object.decay = this.decay;
		if ( this.exponent !== undefined ) data.object.exponent = this.exponent;
	
		return data;
	
	};
	
	// File:src/lights/LightShadow.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.LightShadow = function ( camera ) {
	
		this.camera = camera;
	
		this.bias = 0;
		this.radius = 1;
	
		this.mapSize = new THREE.Vector2( 512, 512 );
	
		this.map = null;
		this.matrix = new THREE.Matrix4();
	
	};
	
	THREE.LightShadow.prototype = {
	
		constructor: THREE.LightShadow,
	
		copy: function ( source ) {
	
			this.camera = source.camera.clone();
	
			this.bias = source.bias;
			this.radius = source.radius;
	
			this.mapSize.copy( source.mapSize );
	
			return this;
	
		},
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		}
	
	};
	
	// File:src/lights/AmbientLight.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.AmbientLight = function ( color, intensity ) {
	
		THREE.Light.call( this, color, intensity );
	
		this.type = 'AmbientLight';
	
		this.castShadow = undefined;
	
	};
	
	THREE.AmbientLight.prototype = Object.create( THREE.Light.prototype );
	THREE.AmbientLight.prototype.constructor = THREE.AmbientLight;
	
	// File:src/lights/DirectionalLight.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.DirectionalLight = function ( color, intensity ) {
	
		THREE.Light.call( this, color, intensity );
	
		this.type = 'DirectionalLight';
	
		this.position.set( 0, 1, 0 );
		this.updateMatrix();
	
		this.target = new THREE.Object3D();
	
		this.shadow = new THREE.LightShadow( new THREE.OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );
	
	};
	
	THREE.DirectionalLight.prototype = Object.create( THREE.Light.prototype );
	THREE.DirectionalLight.prototype.constructor = THREE.DirectionalLight;
	
	THREE.DirectionalLight.prototype.copy = function ( source ) {
	
		THREE.Light.prototype.copy.call( this, source );
	
		this.target = source.target.clone();
	
		this.shadow = source.shadow.clone();
	
		return this;
	
	};
	
	// File:src/lights/HemisphereLight.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.HemisphereLight = function ( skyColor, groundColor, intensity ) {
	
		THREE.Light.call( this, skyColor, intensity );
	
		this.type = 'HemisphereLight';
	
		this.castShadow = undefined;
	
		this.position.set( 0, 1, 0 );
		this.updateMatrix();
	
		this.groundColor = new THREE.Color( groundColor );
	
	};
	
	THREE.HemisphereLight.prototype = Object.create( THREE.Light.prototype );
	THREE.HemisphereLight.prototype.constructor = THREE.HemisphereLight;
	
	THREE.HemisphereLight.prototype.copy = function ( source ) {
	
		THREE.Light.prototype.copy.call( this, source );
	
		this.groundColor.copy( source.groundColor );
	
		return this;
	
	};
	
	// File:src/lights/PointLight.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	
	THREE.PointLight = function ( color, intensity, distance, decay ) {
	
		THREE.Light.call( this, color, intensity );
	
		this.type = 'PointLight';
	
		this.distance = ( distance !== undefined ) ? distance : 0;
		this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.
	
		this.shadow = new THREE.LightShadow( new THREE.PerspectiveCamera( 90, 1, 0.5, 500 ) );
	
	};
	
	THREE.PointLight.prototype = Object.create( THREE.Light.prototype );
	THREE.PointLight.prototype.constructor = THREE.PointLight;
	
	THREE.PointLight.prototype.copy = function ( source ) {
	
		THREE.Light.prototype.copy.call( this, source );
	
		this.distance = source.distance;
		this.decay = source.decay;
	
		this.shadow = source.shadow.clone();
	
		return this;
	
	};
	
	// File:src/lights/SpotLight.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.SpotLight = function ( color, intensity, distance, angle, exponent, decay ) {
	
		THREE.Light.call( this, color, intensity );
	
		this.type = 'SpotLight';
	
		this.position.set( 0, 1, 0 );
		this.updateMatrix();
	
		this.target = new THREE.Object3D();
	
		this.distance = ( distance !== undefined ) ? distance : 0;
		this.angle = ( angle !== undefined ) ? angle : Math.PI / 3;
		this.exponent = ( exponent !== undefined ) ? exponent : 10;
		this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.
	
		this.shadow = new THREE.LightShadow( new THREE.PerspectiveCamera( 50, 1, 0.5, 500 ) );
	
	};
	
	THREE.SpotLight.prototype = Object.create( THREE.Light.prototype );
	THREE.SpotLight.prototype.constructor = THREE.SpotLight;
	
	THREE.SpotLight.prototype.copy = function ( source ) {
	
		THREE.Light.prototype.copy.call( this, source );
	
		this.distance = source.distance;
		this.angle = source.angle;
		this.exponent = source.exponent;
		this.decay = source.decay;
	
		this.target = source.target.clone();
	
		this.shadow = source.shadow.clone();
	
		return this;
	
	};
	
	// File:src/loaders/Cache.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.Cache = {
	
		enabled: false,
	
		files: {},
	
		add: function ( key, file ) {
	
			if ( this.enabled === false ) return;
	
			// console.log( 'THREE.Cache', 'Adding key:', key );
	
			this.files[ key ] = file;
	
		},
	
		get: function ( key ) {
	
			if ( this.enabled === false ) return;
	
			// console.log( 'THREE.Cache', 'Checking key:', key );
	
			return this.files[ key ];
	
		},
	
		remove: function ( key ) {
	
			delete this.files[ key ];
	
		},
	
		clear: function () {
	
			this.files = {};
	
		}
	
	};
	
	// File:src/loaders/Loader.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.Loader = function () {
	
		this.onLoadStart = function () {};
		this.onLoadProgress = function () {};
		this.onLoadComplete = function () {};
	
	};
	
	THREE.Loader.prototype = {
	
		constructor: THREE.Loader,
	
		crossOrigin: undefined,
	
		extractUrlBase: function ( url ) {
	
			var parts = url.split( '/' );
	
			if ( parts.length === 1 ) return './';
	
			parts.pop();
	
			return parts.join( '/' ) + '/';
	
		},
	
		initMaterials: function ( materials, texturePath, crossOrigin ) {
	
			var array = [];
	
			for ( var i = 0; i < materials.length; ++ i ) {
	
				array[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin );
	
			}
	
			return array;
	
		},
	
		createMaterial: ( function () {
	
			var color, textureLoader, materialLoader;
	
			return function ( m, texturePath, crossOrigin ) {
	
				if ( color === undefined ) color = new THREE.Color();
				if ( textureLoader === undefined ) textureLoader = new THREE.TextureLoader();
				if ( materialLoader === undefined ) materialLoader = new THREE.MaterialLoader();
	
				// convert from old material format
	
				var textures = {};
	
				function loadTexture( path, repeat, offset, wrap, anisotropy ) {
	
					var fullPath = texturePath + path;
					var loader = THREE.Loader.Handlers.get( fullPath );
	
					var texture;
	
					if ( loader !== null ) {
	
						texture = loader.load( fullPath );
	
					} else {
	
						textureLoader.setCrossOrigin( crossOrigin );
						texture = textureLoader.load( fullPath );
	
					}
	
					if ( repeat !== undefined ) {
	
						texture.repeat.fromArray( repeat );
	
						if ( repeat[ 0 ] !== 1 ) texture.wrapS = THREE.RepeatWrapping;
						if ( repeat[ 1 ] !== 1 ) texture.wrapT = THREE.RepeatWrapping;
	
					}
	
					if ( offset !== undefined ) {
	
						texture.offset.fromArray( offset );
	
					}
	
					if ( wrap !== undefined ) {
	
						if ( wrap[ 0 ] === 'repeat' ) texture.wrapS = THREE.RepeatWrapping;
						if ( wrap[ 0 ] === 'mirror' ) texture.wrapS = THREE.MirroredRepeatWrapping;
	
						if ( wrap[ 1 ] === 'repeat' ) texture.wrapT = THREE.RepeatWrapping;
						if ( wrap[ 1 ] === 'mirror' ) texture.wrapT = THREE.MirroredRepeatWrapping;
	
					}
	
					if ( anisotropy !== undefined ) {
	
						texture.anisotropy = anisotropy;
	
					}
	
					var uuid = THREE.Math.generateUUID();
	
					textures[ uuid ] = texture;
	
					return uuid;
	
				}
	
				//
	
				var json = {
					uuid: THREE.Math.generateUUID(),
					type: 'MeshLambertMaterial'
				};
	
				for ( var name in m ) {
	
					var value = m[ name ];
	
					switch ( name ) {
						case 'DbgColor':
						case 'DbgIndex':
						case 'opticalDensity':
						case 'illumination':
							break;
						case 'DbgName':
							json.name = value;
							break;
						case 'blending':
							json.blending = THREE[ value ];
							break;
						case 'colorAmbient':
							console.warn( 'THREE.Loader.createMaterial: colorAmbient is no longer supported' );
							break;
						case 'colorDiffuse':
							json.color = color.fromArray( value ).getHex();
							break;
						case 'colorSpecular':
							json.specular = color.fromArray( value ).getHex();
							break;
						case 'colorEmissive':
							json.emissive = color.fromArray( value ).getHex();
							break;
						case 'specularCoef':
							json.shininess = value;
							break;
						case 'shading':
							if ( value.toLowerCase() === 'basic' ) json.type = 'MeshBasicMaterial';
							if ( value.toLowerCase() === 'phong' ) json.type = 'MeshPhongMaterial';
							break;
						case 'mapDiffuse':
							json.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );
							break;
						case 'mapDiffuseRepeat':
						case 'mapDiffuseOffset':
						case 'mapDiffuseWrap':
						case 'mapDiffuseAnisotropy':
							break;
						case 'mapLight':
							json.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );
							break;
						case 'mapLightRepeat':
						case 'mapLightOffset':
						case 'mapLightWrap':
						case 'mapLightAnisotropy':
							break;
						case 'mapAO':
							json.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );
							break;
						case 'mapAORepeat':
						case 'mapAOOffset':
						case 'mapAOWrap':
						case 'mapAOAnisotropy':
							break;
						case 'mapBump':
							json.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );
							break;
						case 'mapBumpScale':
							json.bumpScale = value;
							break;
						case 'mapBumpRepeat':
						case 'mapBumpOffset':
						case 'mapBumpWrap':
						case 'mapBumpAnisotropy':
							break;
						case 'mapNormal':
							json.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );
							break;
						case 'mapNormalFactor':
							json.normalScale = [ value, value ];
							break;
						case 'mapNormalRepeat':
						case 'mapNormalOffset':
						case 'mapNormalWrap':
						case 'mapNormalAnisotropy':
							break;
						case 'mapSpecular':
							json.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );
							break;
						case 'mapSpecularRepeat':
						case 'mapSpecularOffset':
						case 'mapSpecularWrap':
						case 'mapSpecularAnisotropy':
							break;
						case 'mapAlpha':
							json.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );
							break;
						case 'mapAlphaRepeat':
						case 'mapAlphaOffset':
						case 'mapAlphaWrap':
						case 'mapAlphaAnisotropy':
							break;
						case 'flipSided':
							json.side = THREE.BackSide;
							break;
						case 'doubleSided':
							json.side = THREE.DoubleSide;
							break;
						case 'transparency':
							console.warn( 'THREE.Loader.createMaterial: transparency has been renamed to opacity' );
							json.opacity = value;
							break;
						case 'depthTest':
						case 'depthWrite':
						case 'colorWrite':
						case 'opacity':
						case 'reflectivity':
						case 'transparent':
						case 'visible':
						case 'wireframe':
							json[ name ] = value;
							break;
						case 'vertexColors':
							if ( value === true ) json.vertexColors = THREE.VertexColors;
							if ( value === 'face' ) json.vertexColors = THREE.FaceColors;
							break;
						default:
							console.error( 'THREE.Loader.createMaterial: Unsupported', name, value );
							break;
					}
	
				}
	
				if ( json.type === 'MeshBasicMaterial' ) delete json.emissive;
				if ( json.type !== 'MeshPhongMaterial' ) delete json.specular;
	
				if ( json.opacity < 1 ) json.transparent = true;
	
				materialLoader.setTextures( textures );
	
				return materialLoader.parse( json );
	
			};
	
		} )()
	
	};
	
	THREE.Loader.Handlers = {
	
		handlers: [],
	
		add: function ( regex, loader ) {
	
			this.handlers.push( regex, loader );
	
		},
	
		get: function ( file ) {
	
			var handlers = this.handlers;
	
			for ( var i = 0, l = handlers.length; i < l; i += 2 ) {
	
				var regex = handlers[ i ];
				var loader  = handlers[ i + 1 ];
	
				if ( regex.test( file ) ) {
	
					return loader;
	
				}
	
			}
	
			return null;
	
		}
	
	};
	
	// File:src/loaders/XHRLoader.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.XHRLoader = function ( manager ) {
	
		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
	
	};
	
	THREE.XHRLoader.prototype = {
	
		constructor: THREE.XHRLoader,
	
		load: function ( url, onLoad, onProgress, onError ) {
	
			if ( this.path !== undefined ) url = this.path + url;
	
			var scope = this;
	
			var cached = THREE.Cache.get( url );
	
			if ( cached !== undefined ) {
	
				if ( onLoad ) {
	
					setTimeout( function () {
	
						onLoad( cached );
	
					}, 0 );
	
				}
	
				return cached;
	
			}
	
			var request = new XMLHttpRequest();
			request.overrideMimeType( 'text/plain' );
			request.open( 'GET', url, true );
	
			request.addEventListener( 'load', function ( event ) {
	
				var response = event.target.response;
	
				THREE.Cache.add( url, response );
	
				if ( this.status === 200 ) {
	
					if ( onLoad ) onLoad( response );
	
					scope.manager.itemEnd( url );
	
				} else if ( this.status === 0 ) {
	
					// Some browsers return HTTP Status 0 when using non-http protocol
					// e.g. 'file://' or 'data://'. Handle as success.
	
					console.warn( 'THREE.XHRLoader: HTTP Status 0 received.' );
	
					if ( onLoad ) onLoad( response );
	
					scope.manager.itemEnd( url );
	
				} else {
	
					if ( onError ) onError( event );
	
					scope.manager.itemError( url );
	
				}
	
			}, false );
	
			if ( onProgress !== undefined ) {
	
				request.addEventListener( 'progress', function ( event ) {
	
					onProgress( event );
	
				}, false );
	
			}
	
			request.addEventListener( 'error', function ( event ) {
	
				if ( onError ) onError( event );
	
				scope.manager.itemError( url );
	
			}, false );
	
			if ( this.responseType !== undefined ) request.responseType = this.responseType;
			if ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;
	
			request.send( null );
	
			scope.manager.itemStart( url );
	
			return request;
	
		},
	
		setPath: function ( value ) {
	
			this.path = value;
	
		},
	
		setResponseType: function ( value ) {
	
			this.responseType = value;
	
		},
	
		setWithCredentials: function ( value ) {
	
			this.withCredentials = value;
	
		}
	
	};
	
	// File:src/loaders/FontLoader.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.FontLoader = function ( manager ) {
	
		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
	
	};
	
	THREE.FontLoader.prototype = {
	
		constructor: THREE.FontLoader,
	
		load: function ( url, onLoad, onProgress, onError ) {
	
			var loader = new THREE.XHRLoader( this.manager );
			loader.load( url, function ( text ) {
	
				onLoad( new THREE.Font( JSON.parse( text.substring( 65, text.length - 2 ) ) ) );
	
			}, onProgress, onError );
	
		}
	
	};
	
	// File:src/loaders/ImageLoader.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.ImageLoader = function ( manager ) {
	
		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
	
	};
	
	THREE.ImageLoader.prototype = {
	
		constructor: THREE.ImageLoader,
	
		load: function ( url, onLoad, onProgress, onError ) {
	
			if ( this.path !== undefined ) url = this.path + url;
	
			var scope = this;
	
			var cached = THREE.Cache.get( url );
	
			if ( cached !== undefined ) {
	
				scope.manager.itemStart( url );
	
				if ( onLoad ) {
	
					setTimeout( function () {
	
						onLoad( cached );
	
						scope.manager.itemEnd( url );
	
					}, 0 );
	
				} else {
	
					scope.manager.itemEnd( url );
	
				}
	
				return cached;
	
			}
	
			var image = document.createElement( 'img' );
	
			image.addEventListener( 'load', function ( event ) {
	
				THREE.Cache.add( url, this );
	
				if ( onLoad ) onLoad( this );
	
				scope.manager.itemEnd( url );
	
			}, false );
	
			if ( onProgress !== undefined ) {
	
				image.addEventListener( 'progress', function ( event ) {
	
					onProgress( event );
	
				}, false );
	
			}
	
			image.addEventListener( 'error', function ( event ) {
	
				if ( onError ) onError( event );
	
				scope.manager.itemError( url );
	
			}, false );
	
			if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;
	
			scope.manager.itemStart( url );
	
			image.src = url;
	
			return image;
	
		},
	
		setCrossOrigin: function ( value ) {
	
			this.crossOrigin = value;
	
		},
	
		setPath: function ( value ) {
	
			this.path = value;
	
		}
	
	};
	
	// File:src/loaders/JSONLoader.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.JSONLoader = function ( manager ) {
	
		if ( typeof manager === 'boolean' ) {
	
			console.warn( 'THREE.JSONLoader: showStatus parameter has been removed from constructor.' );
			manager = undefined;
	
		}
	
		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
	
		this.withCredentials = false;
	
	};
	
	THREE.JSONLoader.prototype = {
	
		constructor: THREE.JSONLoader,
	
		// Deprecated
	
		get statusDomElement () {
	
			if ( this._statusDomElement === undefined ) {
	
				this._statusDomElement = document.createElement( 'div' );
	
			}
	
			console.warn( 'THREE.JSONLoader: .statusDomElement has been removed.' );
			return this._statusDomElement;
	
		},
	
		load: function( url, onLoad, onProgress, onError ) {
	
			var scope = this;
	
			var texturePath = this.texturePath && ( typeof this.texturePath === "string" ) ? this.texturePath : THREE.Loader.prototype.extractUrlBase( url );
	
			var loader = new THREE.XHRLoader( this.manager );
			loader.setWithCredentials( this.withCredentials );
			loader.load( url, function ( text ) {
	
				var json = JSON.parse( text );
				var metadata = json.metadata;
	
				if ( metadata !== undefined ) {
	
					var type = metadata.type;
	
					if ( type !== undefined ) {
	
						if ( type.toLowerCase() === 'object' ) {
	
							console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );
							return;
	
						}
	
						if ( type.toLowerCase() === 'scene' ) {
	
							console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.' );
							return;
	
						}
	
					}
	
				}
	
				var object = scope.parse( json, texturePath );
				onLoad( object.geometry, object.materials );
	
			}, onProgress, onError );
	
		},
	
		setTexturePath: function ( value ) {
	
			this.texturePath = value;
	
		},
	
		parse: function ( json, texturePath ) {
	
			var geometry = new THREE.Geometry(),
			scale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;
	
			parseModel( scale );
	
			parseSkin();
			parseMorphing( scale );
			parseAnimations();
	
			geometry.computeFaceNormals();
			geometry.computeBoundingSphere();
	
			function parseModel( scale ) {
	
				function isBitSet( value, position ) {
	
					return value & ( 1 << position );
	
				}
	
				var i, j, fi,
	
				offset, zLength,
	
			colorIndex, normalIndex, uvIndex, materialIndex,
	
				type,
				isQuad,
				hasMaterial,
				hasFaceVertexUv,
				hasFaceNormal, hasFaceVertexNormal,
				hasFaceColor, hasFaceVertexColor,
	
			vertex, face, faceA, faceB, hex, normal,
	
				uvLayer, uv, u, v,
	
				faces = json.faces,
				vertices = json.vertices,
				normals = json.normals,
				colors = json.colors,
	
				nUvLayers = 0;
	
				if ( json.uvs !== undefined ) {
	
					// disregard empty arrays
	
					for ( i = 0; i < json.uvs.length; i ++ ) {
	
						if ( json.uvs[ i ].length ) nUvLayers ++;
	
					}
	
					for ( i = 0; i < nUvLayers; i ++ ) {
	
						geometry.faceVertexUvs[ i ] = [];
	
					}
	
				}
	
				offset = 0;
				zLength = vertices.length;
	
				while ( offset < zLength ) {
	
					vertex = new THREE.Vector3();
	
					vertex.x = vertices[ offset ++ ] * scale;
					vertex.y = vertices[ offset ++ ] * scale;
					vertex.z = vertices[ offset ++ ] * scale;
	
					geometry.vertices.push( vertex );
	
				}
	
				offset = 0;
				zLength = faces.length;
	
				while ( offset < zLength ) {
	
					type = faces[ offset ++ ];
	
	
					isQuad              = isBitSet( type, 0 );
					hasMaterial         = isBitSet( type, 1 );
					hasFaceVertexUv     = isBitSet( type, 3 );
					hasFaceNormal       = isBitSet( type, 4 );
					hasFaceVertexNormal = isBitSet( type, 5 );
					hasFaceColor	     = isBitSet( type, 6 );
					hasFaceVertexColor  = isBitSet( type, 7 );
	
					// console.log("type", type, "bits", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);
	
					if ( isQuad ) {
	
						faceA = new THREE.Face3();
						faceA.a = faces[ offset ];
						faceA.b = faces[ offset + 1 ];
						faceA.c = faces[ offset + 3 ];
	
						faceB = new THREE.Face3();
						faceB.a = faces[ offset + 1 ];
						faceB.b = faces[ offset + 2 ];
						faceB.c = faces[ offset + 3 ];
	
						offset += 4;
	
						if ( hasMaterial ) {
	
							materialIndex = faces[ offset ++ ];
							faceA.materialIndex = materialIndex;
							faceB.materialIndex = materialIndex;
	
						}
	
						// to get face <=> uv index correspondence
	
						fi = geometry.faces.length;
	
						if ( hasFaceVertexUv ) {
	
							for ( i = 0; i < nUvLayers; i ++ ) {
	
								uvLayer = json.uvs[ i ];
	
								geometry.faceVertexUvs[ i ][ fi ] = [];
								geometry.faceVertexUvs[ i ][ fi + 1 ] = [];
	
								for ( j = 0; j < 4; j ++ ) {
	
									uvIndex = faces[ offset ++ ];
	
									u = uvLayer[ uvIndex * 2 ];
									v = uvLayer[ uvIndex * 2 + 1 ];
	
									uv = new THREE.Vector2( u, v );
	
									if ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );
									if ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );
	
								}
	
							}
	
						}
	
						if ( hasFaceNormal ) {
	
							normalIndex = faces[ offset ++ ] * 3;
	
							faceA.normal.set(
								normals[ normalIndex ++ ],
								normals[ normalIndex ++ ],
								normals[ normalIndex ]
							);
	
							faceB.normal.copy( faceA.normal );
	
						}
	
						if ( hasFaceVertexNormal ) {
	
							for ( i = 0; i < 4; i ++ ) {
	
								normalIndex = faces[ offset ++ ] * 3;
	
								normal = new THREE.Vector3(
									normals[ normalIndex ++ ],
									normals[ normalIndex ++ ],
									normals[ normalIndex ]
								);
	
	
								if ( i !== 2 ) faceA.vertexNormals.push( normal );
								if ( i !== 0 ) faceB.vertexNormals.push( normal );
	
							}
	
						}
	
	
						if ( hasFaceColor ) {
	
							colorIndex = faces[ offset ++ ];
							hex = colors[ colorIndex ];
	
							faceA.color.setHex( hex );
							faceB.color.setHex( hex );
	
						}
	
	
						if ( hasFaceVertexColor ) {
	
							for ( i = 0; i < 4; i ++ ) {
	
								colorIndex = faces[ offset ++ ];
								hex = colors[ colorIndex ];
	
								if ( i !== 2 ) faceA.vertexColors.push( new THREE.Color( hex ) );
								if ( i !== 0 ) faceB.vertexColors.push( new THREE.Color( hex ) );
	
							}
	
						}
	
						geometry.faces.push( faceA );
						geometry.faces.push( faceB );
	
					} else {
	
						face = new THREE.Face3();
						face.a = faces[ offset ++ ];
						face.b = faces[ offset ++ ];
						face.c = faces[ offset ++ ];
	
						if ( hasMaterial ) {
	
							materialIndex = faces[ offset ++ ];
							face.materialIndex = materialIndex;
	
						}
	
						// to get face <=> uv index correspondence
	
						fi = geometry.faces.length;
	
						if ( hasFaceVertexUv ) {
	
							for ( i = 0; i < nUvLayers; i ++ ) {
	
								uvLayer = json.uvs[ i ];
	
								geometry.faceVertexUvs[ i ][ fi ] = [];
	
								for ( j = 0; j < 3; j ++ ) {
	
									uvIndex = faces[ offset ++ ];
	
									u = uvLayer[ uvIndex * 2 ];
									v = uvLayer[ uvIndex * 2 + 1 ];
	
									uv = new THREE.Vector2( u, v );
	
									geometry.faceVertexUvs[ i ][ fi ].push( uv );
	
								}
	
							}
	
						}
	
						if ( hasFaceNormal ) {
	
							normalIndex = faces[ offset ++ ] * 3;
	
							face.normal.set(
								normals[ normalIndex ++ ],
								normals[ normalIndex ++ ],
								normals[ normalIndex ]
							);
	
						}
	
						if ( hasFaceVertexNormal ) {
	
							for ( i = 0; i < 3; i ++ ) {
	
								normalIndex = faces[ offset ++ ] * 3;
	
								normal = new THREE.Vector3(
									normals[ normalIndex ++ ],
									normals[ normalIndex ++ ],
									normals[ normalIndex ]
								);
	
								face.vertexNormals.push( normal );
	
							}
	
						}
	
	
						if ( hasFaceColor ) {
	
							colorIndex = faces[ offset ++ ];
							face.color.setHex( colors[ colorIndex ] );
	
						}
	
	
						if ( hasFaceVertexColor ) {
	
							for ( i = 0; i < 3; i ++ ) {
	
								colorIndex = faces[ offset ++ ];
								face.vertexColors.push( new THREE.Color( colors[ colorIndex ] ) );
	
							}
	
						}
	
						geometry.faces.push( face );
	
					}
	
				}
	
			};
	
			function parseSkin() {
	
				var influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;
	
				if ( json.skinWeights ) {
	
					for ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {
	
						var x =                               json.skinWeights[ i ];
						var y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;
						var z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;
						var w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;
	
						geometry.skinWeights.push( new THREE.Vector4( x, y, z, w ) );
	
					}
	
				}
	
				if ( json.skinIndices ) {
	
					for ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {
	
						var a =                               json.skinIndices[ i ];
						var b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;
						var c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;
						var d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;
	
						geometry.skinIndices.push( new THREE.Vector4( a, b, c, d ) );
	
					}
	
				}
	
				geometry.bones = json.bones;
	
				if ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {
	
					console.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +
						geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );
	
				}
	
			};
	
			function parseMorphing( scale ) {
	
				if ( json.morphTargets !== undefined ) {
	
					for ( var i = 0, l = json.morphTargets.length; i < l; i ++ ) {
	
						geometry.morphTargets[ i ] = {};
						geometry.morphTargets[ i ].name = json.morphTargets[ i ].name;
						geometry.morphTargets[ i ].vertices = [];
	
						var dstVertices = geometry.morphTargets[ i ].vertices;
						var srcVertices = json.morphTargets[ i ].vertices;
	
						for ( var v = 0, vl = srcVertices.length; v < vl; v += 3 ) {
	
							var vertex = new THREE.Vector3();
							vertex.x = srcVertices[ v ] * scale;
							vertex.y = srcVertices[ v + 1 ] * scale;
							vertex.z = srcVertices[ v + 2 ] * scale;
	
							dstVertices.push( vertex );
	
						}
	
					}
	
				}
	
				if ( json.morphColors !== undefined && json.morphColors.length > 0 ) {
	
					console.warn( 'THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.' );
	
					var faces = geometry.faces;
					var morphColors = json.morphColors[ 0 ].colors;
	
					for ( var i = 0, l = faces.length; i < l; i ++ ) {
	
						faces[ i ].color.fromArray( morphColors, i * 3 );
	
					}
	
				}
	
			}
	
			function parseAnimations() {
	
				var outputAnimations = [];
	
				// parse old style Bone/Hierarchy animations
				var animations = [];
	
				if ( json.animation !== undefined ) {
	
					animations.push( json.animation );
	
				}
	
				if ( json.animations !== undefined ) {
	
					if ( json.animations.length ) {
	
						animations = animations.concat( json.animations );
	
					} else {
	
						animations.push( json.animations );
	
					}
	
				}
	
				for ( var i = 0; i < animations.length; i ++ ) {
	
					var clip = THREE.AnimationClip.parseAnimation( animations[ i ], geometry.bones );
					if ( clip ) outputAnimations.push( clip );
	
				}
	
				// parse implicit morph animations
				if ( geometry.morphTargets ) {
	
					// TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.
					var morphAnimationClips = THREE.AnimationClip.CreateClipsFromMorphTargetSequences( geometry.morphTargets, 10 );
					outputAnimations = outputAnimations.concat( morphAnimationClips );
	
				}
	
				if ( outputAnimations.length > 0 ) geometry.animations = outputAnimations;
	
			};
	
			if ( json.materials === undefined || json.materials.length === 0 ) {
	
				return { geometry: geometry };
	
			} else {
	
				var materials = THREE.Loader.prototype.initMaterials( json.materials, texturePath, this.crossOrigin );
	
				return { geometry: geometry, materials: materials };
	
			}
	
		}
	
	};
	
	// File:src/loaders/LoadingManager.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.LoadingManager = function ( onLoad, onProgress, onError ) {
	
		var scope = this;
	
		var isLoading = false, itemsLoaded = 0, itemsTotal = 0;
	
		this.onStart = undefined;
		this.onLoad = onLoad;
		this.onProgress = onProgress;
		this.onError = onError;
	
		this.itemStart = function ( url ) {
	
			itemsTotal ++;
	
			if ( isLoading === false ) {
	
				if ( scope.onStart !== undefined ) {
	
					scope.onStart( url, itemsLoaded, itemsTotal );
	
				}
	
			}
	
			isLoading = true;
	
		};
	
		this.itemEnd = function ( url ) {
	
			itemsLoaded ++;
	
			if ( scope.onProgress !== undefined ) {
	
				scope.onProgress( url, itemsLoaded, itemsTotal );
	
			}
	
			if ( itemsLoaded === itemsTotal ) {
	
				isLoading = false;
	
				if ( scope.onLoad !== undefined ) {
	
					scope.onLoad();
	
				}
	
			}
	
		};
	
		this.itemError = function ( url ) {
	
			if ( scope.onError !== undefined ) {
	
				scope.onError( url );
	
			}
	
		};
	
	};
	
	THREE.DefaultLoadingManager = new THREE.LoadingManager();
	
	// File:src/loaders/BufferGeometryLoader.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.BufferGeometryLoader = function ( manager ) {
	
		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
	
	};
	
	THREE.BufferGeometryLoader.prototype = {
	
		constructor: THREE.BufferGeometryLoader,
	
		load: function ( url, onLoad, onProgress, onError ) {
	
			var scope = this;
	
			var loader = new THREE.XHRLoader( scope.manager );
			loader.load( url, function ( text ) {
	
				onLoad( scope.parse( JSON.parse( text ) ) );
	
			}, onProgress, onError );
	
		},
	
		parse: function ( json ) {
	
			var geometry = new THREE.BufferGeometry();
	
			var index = json.data.index;
	
			var TYPED_ARRAYS = {
				'Int8Array': Int8Array,
				'Uint8Array': Uint8Array,
				'Uint8ClampedArray': Uint8ClampedArray,
				'Int16Array': Int16Array,
				'Uint16Array': Uint16Array,
				'Int32Array': Int32Array,
				'Uint32Array': Uint32Array,
				'Float32Array': Float32Array,
				'Float64Array': Float64Array
			};
	
			if ( index !== undefined ) {
	
				var typedArray = new TYPED_ARRAYS[ index.type ]( index.array );
				geometry.setIndex( new THREE.BufferAttribute( typedArray, 1 ) );
	
			}
	
			var attributes = json.data.attributes;
	
			for ( var key in attributes ) {
	
				var attribute = attributes[ key ];
				var typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );
	
				geometry.addAttribute( key, new THREE.BufferAttribute( typedArray, attribute.itemSize ) );
	
			}
	
			var groups = json.data.groups || json.data.drawcalls || json.data.offsets;
	
			if ( groups !== undefined ) {
	
				for ( var i = 0, n = groups.length; i !== n; ++ i ) {
	
					var group = groups[ i ];
	
					geometry.addGroup( group.start, group.count, group.materialIndex );
	
				}
	
			}
	
			var boundingSphere = json.data.boundingSphere;
	
			if ( boundingSphere !== undefined ) {
	
				var center = new THREE.Vector3();
	
				if ( boundingSphere.center !== undefined ) {
	
					center.fromArray( boundingSphere.center );
	
				}
	
				geometry.boundingSphere = new THREE.Sphere( center, boundingSphere.radius );
	
			}
	
			return geometry;
	
		}
	
	};
	
	// File:src/loaders/MaterialLoader.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.MaterialLoader = function ( manager ) {
	
		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
		this.textures = {};
	
	};
	
	THREE.MaterialLoader.prototype = {
	
		constructor: THREE.MaterialLoader,
	
		load: function ( url, onLoad, onProgress, onError ) {
	
			var scope = this;
	
			var loader = new THREE.XHRLoader( scope.manager );
			loader.load( url, function ( text ) {
	
				onLoad( scope.parse( JSON.parse( text ) ) );
	
			}, onProgress, onError );
	
		},
	
		setTextures: function ( value ) {
	
			this.textures = value;
	
		},
	
		getTexture: function ( name ) {
	
			var textures = this.textures;
	
			if ( textures[ name ] === undefined ) {
	
				console.warn( 'THREE.MaterialLoader: Undefined texture', name );
	
			}
	
			return textures[ name ];
	
		},
	
		parse: function ( json ) {
	
			var material = new THREE[ json.type ];
	
			if ( json.uuid !== undefined ) material.uuid = json.uuid;
			if ( json.name !== undefined ) material.name = json.name;
			if ( json.color !== undefined ) material.color.setHex( json.color );
			if ( json.roughness !== undefined ) material.roughness = json.roughness;
			if ( json.metalness !== undefined ) material.metalness = json.metalness;
			if ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );
			if ( json.specular !== undefined ) material.specular.setHex( json.specular );
			if ( json.shininess !== undefined ) material.shininess = json.shininess;
			if ( json.uniforms !== undefined ) material.uniforms = json.uniforms;
			if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;
			if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;
			if ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;
			if ( json.shading !== undefined ) material.shading = json.shading;
			if ( json.blending !== undefined ) material.blending = json.blending;
			if ( json.side !== undefined ) material.side = json.side;
			if ( json.opacity !== undefined ) material.opacity = json.opacity;
			if ( json.transparent !== undefined ) material.transparent = json.transparent;
			if ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;
			if ( json.depthTest !== undefined ) material.depthTest = json.depthTest;
			if ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;
			if ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;
			if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;
			if ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;
	
			// for PointsMaterial
			if ( json.size !== undefined ) material.size = json.size;
			if ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;
	
			// maps
	
			if ( json.map !== undefined ) material.map = this.getTexture( json.map );
	
			if ( json.alphaMap !== undefined ) {
	
				material.alphaMap = this.getTexture( json.alphaMap );
				material.transparent = true;
	
			}
	
			if ( json.bumpMap !== undefined ) material.bumpMap = this.getTexture( json.bumpMap );
			if ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;
	
			if ( json.normalMap !== undefined ) material.normalMap = this.getTexture( json.normalMap );
			if ( json.normalScale !== undefined ) {
	
				var normalScale = json.normalScale;
	
				if ( Array.isArray( normalScale ) === false ) {
	
					// Blender exporter used to export a scalar. See #7459
	
					normalScale = [ normalScale, normalScale ];
	
				}
	
				material.normalScale = new THREE.Vector2().fromArray( normalScale );
	
			}
	
			if ( json.displacementMap !== undefined ) material.displacementMap = this.getTexture( json.displacementMap );
			if ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;
			if ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;
	
			if ( json.roughnessMap !== undefined ) material.roughnessMap = this.getTexture( json.roughnessMap );
			if ( json.metalnessMap !== undefined ) material.metalnessMap = this.getTexture( json.metalnessMap );
	
			if ( json.emissiveMap !== undefined ) material.emissiveMap = this.getTexture( json.emissiveMap );
			if ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;
	
			if ( json.specularMap !== undefined ) material.specularMap = this.getTexture( json.specularMap );
	
			if ( json.envMap !== undefined ) {
	
				material.envMap = this.getTexture( json.envMap );
				material.combine = THREE.MultiplyOperation;
	
			}
	
			if ( json.reflectivity ) material.reflectivity = json.reflectivity;
	
			if ( json.lightMap !== undefined ) material.lightMap = this.getTexture( json.lightMap );
			if ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;
	
			if ( json.aoMap !== undefined ) material.aoMap = this.getTexture( json.aoMap );
			if ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;
	
			// MultiMaterial
	
			if ( json.materials !== undefined ) {
	
				for ( var i = 0, l = json.materials.length; i < l; i ++ ) {
	
					material.materials.push( this.parse( json.materials[ i ] ) );
	
				}
	
			}
	
			return material;
	
		}
	
	};
	
	// File:src/loaders/ObjectLoader.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.ObjectLoader = function ( manager ) {
	
		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
		this.texturePath = '';
	
	};
	
	THREE.ObjectLoader.prototype = {
	
		constructor: THREE.ObjectLoader,
	
		load: function ( url, onLoad, onProgress, onError ) {
	
			if ( this.texturePath === '' ) {
	
				this.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );
	
			}
	
			var scope = this;
	
			var loader = new THREE.XHRLoader( scope.manager );
			loader.load( url, function ( text ) {
	
				scope.parse( JSON.parse( text ), onLoad );
	
			}, onProgress, onError );
	
		},
	
		setTexturePath: function ( value ) {
	
			this.texturePath = value;
	
		},
	
		setCrossOrigin: function ( value ) {
	
			this.crossOrigin = value;
	
		},
	
		parse: function ( json, onLoad ) {
	
			var geometries = this.parseGeometries( json.geometries );
	
			var images = this.parseImages( json.images, function () {
	
				if ( onLoad !== undefined ) onLoad( object );
	
			} );
	
			var textures  = this.parseTextures( json.textures, images );
			var materials = this.parseMaterials( json.materials, textures );
	
			var object = this.parseObject( json.object, geometries, materials );
	
			if ( json.animations ) {
	
				object.animations = this.parseAnimations( json.animations );
	
			}
	
			if ( json.images === undefined || json.images.length === 0 ) {
	
				if ( onLoad !== undefined ) onLoad( object );
	
			}
	
			return object;
	
		},
	
		parseGeometries: function ( json ) {
	
			var geometries = {};
	
			if ( json !== undefined ) {
	
				var geometryLoader = new THREE.JSONLoader();
				var bufferGeometryLoader = new THREE.BufferGeometryLoader();
	
				for ( var i = 0, l = json.length; i < l; i ++ ) {
	
					var geometry;
					var data = json[ i ];
	
					switch ( data.type ) {
	
						case 'PlaneGeometry':
						case 'PlaneBufferGeometry':
	
							geometry = new THREE[ data.type ](
								data.width,
								data.height,
								data.widthSegments,
								data.heightSegments
							);
	
							break;
	
						case 'BoxGeometry':
						case 'CubeGeometry': // backwards compatible
	
							geometry = new THREE.BoxGeometry(
								data.width,
								data.height,
								data.depth,
								data.widthSegments,
								data.heightSegments,
								data.depthSegments
							);
	
							break;
	
						case 'CircleBufferGeometry':
	
							geometry = new THREE.CircleBufferGeometry(
								data.radius,
								data.segments,
								data.thetaStart,
								data.thetaLength
							);
	
							break;
	
						case 'CircleGeometry':
	
							geometry = new THREE.CircleGeometry(
								data.radius,
								data.segments,
								data.thetaStart,
								data.thetaLength
							);
	
							break;
	
						case 'CylinderGeometry':
	
							geometry = new THREE.CylinderGeometry(
								data.radiusTop,
								data.radiusBottom,
								data.height,
								data.radialSegments,
								data.heightSegments,
								data.openEnded,
								data.thetaStart,
								data.thetaLength
							);
	
							break;
	
						case 'SphereGeometry':
	
							geometry = new THREE.SphereGeometry(
								data.radius,
								data.widthSegments,
								data.heightSegments,
								data.phiStart,
								data.phiLength,
								data.thetaStart,
								data.thetaLength
							);
	
							break;
	
						case 'SphereBufferGeometry':
	
							geometry = new THREE.SphereBufferGeometry(
								data.radius,
								data.widthSegments,
								data.heightSegments,
								data.phiStart,
								data.phiLength,
								data.thetaStart,
								data.thetaLength
							);
	
							break;
	
						case 'DodecahedronGeometry':
	
							geometry = new THREE.DodecahedronGeometry(
								data.radius,
								data.detail
							);
	
							break;
	
						case 'IcosahedronGeometry':
	
							geometry = new THREE.IcosahedronGeometry(
								data.radius,
								data.detail
							);
	
							break;
	
						case 'OctahedronGeometry':
	
							geometry = new THREE.OctahedronGeometry(
								data.radius,
								data.detail
							);
	
							break;
	
						case 'TetrahedronGeometry':
	
							geometry = new THREE.TetrahedronGeometry(
								data.radius,
								data.detail
							);
	
							break;
	
						case 'RingGeometry':
	
							geometry = new THREE.RingGeometry(
								data.innerRadius,
								data.outerRadius,
								data.thetaSegments,
								data.phiSegments,
								data.thetaStart,
								data.thetaLength
							);
	
							break;
	
						case 'TorusGeometry':
	
							geometry = new THREE.TorusGeometry(
								data.radius,
								data.tube,
								data.radialSegments,
								data.tubularSegments,
								data.arc
							);
	
							break;
	
						case 'TorusKnotGeometry':
	
							geometry = new THREE.TorusKnotGeometry(
								data.radius,
								data.tube,
								data.radialSegments,
								data.tubularSegments,
								data.p,
								data.q,
								data.heightScale
							);
	
							break;
	
						case 'LatheGeometry':
	
							geometry = new THREE.LatheGeometry(
								data.points,
								data.segments,
								data.phiStart,
								data.phiLength
							);
	
							break;
	
						case 'BufferGeometry':
	
							geometry = bufferGeometryLoader.parse( data );
	
							break;
	
						case 'Geometry':
	
							geometry = geometryLoader.parse( data.data, this.texturePath ).geometry;
	
							break;
	
						default:
	
							console.warn( 'THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"' );
	
							continue;
	
					}
	
					geometry.uuid = data.uuid;
	
					if ( data.name !== undefined ) geometry.name = data.name;
	
					geometries[ data.uuid ] = geometry;
	
				}
	
			}
	
			return geometries;
	
		},
	
		parseMaterials: function ( json, textures ) {
	
			var materials = {};
	
			if ( json !== undefined ) {
	
				var loader = new THREE.MaterialLoader();
				loader.setTextures( textures );
	
				for ( var i = 0, l = json.length; i < l; i ++ ) {
	
					var material = loader.parse( json[ i ] );
					materials[ material.uuid ] = material;
	
				}
	
			}
	
			return materials;
	
		},
	
		parseAnimations: function ( json ) {
	
			var animations = [];
	
			for ( var i = 0; i < json.length; i ++ ) {
	
				var clip = THREE.AnimationClip.parse( json[ i ] );
	
				animations.push( clip );
	
			}
	
			return animations;
	
		},
	
		parseImages: function ( json, onLoad ) {
	
			var scope = this;
			var images = {};
	
			function loadImage( url ) {
	
				scope.manager.itemStart( url );
	
				return loader.load( url, function () {
	
					scope.manager.itemEnd( url );
	
				} );
	
			}
	
			if ( json !== undefined && json.length > 0 ) {
	
				var manager = new THREE.LoadingManager( onLoad );
	
				var loader = new THREE.ImageLoader( manager );
				loader.setCrossOrigin( this.crossOrigin );
	
				for ( var i = 0, l = json.length; i < l; i ++ ) {
	
					var image = json[ i ];
					var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;
	
					images[ image.uuid ] = loadImage( path );
	
				}
	
			}
	
			return images;
	
		},
	
		parseTextures: function ( json, images ) {
	
			function parseConstant( value ) {
	
				if ( typeof( value ) === 'number' ) return value;
	
				console.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );
	
				return THREE[ value ];
	
			}
	
			var textures = {};
	
			if ( json !== undefined ) {
	
				for ( var i = 0, l = json.length; i < l; i ++ ) {
	
					var data = json[ i ];
	
					if ( data.image === undefined ) {
	
						console.warn( 'THREE.ObjectLoader: No "image" specified for', data.uuid );
	
					}
	
					if ( images[ data.image ] === undefined ) {
	
						console.warn( 'THREE.ObjectLoader: Undefined image', data.image );
	
					}
	
					var texture = new THREE.Texture( images[ data.image ] );
					texture.needsUpdate = true;
	
					texture.uuid = data.uuid;
	
					if ( data.name !== undefined ) texture.name = data.name;
					if ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping );
					if ( data.offset !== undefined ) texture.offset = new THREE.Vector2( data.offset[ 0 ], data.offset[ 1 ] );
					if ( data.repeat !== undefined ) texture.repeat = new THREE.Vector2( data.repeat[ 0 ], data.repeat[ 1 ] );
					if ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter );
					if ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter );
					if ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;
					if ( Array.isArray( data.wrap ) ) {
	
						texture.wrapS = parseConstant( data.wrap[ 0 ] );
						texture.wrapT = parseConstant( data.wrap[ 1 ] );
	
					}
	
					textures[ data.uuid ] = texture;
	
				}
	
			}
	
			return textures;
	
		},
	
		parseObject: function () {
	
			var matrix = new THREE.Matrix4();
	
			return function ( data, geometries, materials ) {
	
				var object;
	
				function getGeometry( name ) {
	
					if ( geometries[ name ] === undefined ) {
	
						console.warn( 'THREE.ObjectLoader: Undefined geometry', name );
	
					}
	
					return geometries[ name ];
	
				}
	
				function getMaterial( name ) {
	
					if ( name === undefined ) return undefined;
	
					if ( materials[ name ] === undefined ) {
	
						console.warn( 'THREE.ObjectLoader: Undefined material', name );
	
					}
	
					return materials[ name ];
	
				}
	
				switch ( data.type ) {
	
					case 'Scene':
	
						object = new THREE.Scene();
	
						break;
	
					case 'PerspectiveCamera':
	
						object = new THREE.PerspectiveCamera( data.fov, data.aspect, data.near, data.far );
	
						break;
	
					case 'OrthographicCamera':
	
						object = new THREE.OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );
	
						break;
	
					case 'AmbientLight':
	
						object = new THREE.AmbientLight( data.color, data.intensity );
	
						break;
	
					case 'DirectionalLight':
	
						object = new THREE.DirectionalLight( data.color, data.intensity );
	
						break;
	
					case 'PointLight':
	
						object = new THREE.PointLight( data.color, data.intensity, data.distance, data.decay );
	
						break;
	
					case 'SpotLight':
	
						object = new THREE.SpotLight( data.color, data.intensity, data.distance, data.angle, data.exponent, data.decay );
	
						break;
	
					case 'HemisphereLight':
	
						object = new THREE.HemisphereLight( data.color, data.groundColor, data.intensity );
	
						break;
	
					case 'Mesh':
	
						var geometry = getGeometry( data.geometry );
						var material = getMaterial( data.material );
	
						if ( geometry.bones && geometry.bones.length > 0 ) {
	
							object = new THREE.SkinnedMesh( geometry, material );
	
						} else {
	
							object = new THREE.Mesh( geometry, material );
	
						}
	
						break;
	
					case 'LOD':
	
						object = new THREE.LOD();
	
						break;
	
					case 'Line':
	
						object = new THREE.Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );
	
						break;
	
					case 'PointCloud':
					case 'Points':
	
						object = new THREE.Points( getGeometry( data.geometry ), getMaterial( data.material ) );
	
						break;
	
					case 'Sprite':
	
						object = new THREE.Sprite( getMaterial( data.material ) );
	
						break;
	
					case 'Group':
	
						object = new THREE.Group();
	
						break;
	
					default:
	
						object = new THREE.Object3D();
	
				}
	
				object.uuid = data.uuid;
	
				if ( data.name !== undefined ) object.name = data.name;
				if ( data.matrix !== undefined ) {
	
					matrix.fromArray( data.matrix );
					matrix.decompose( object.position, object.quaternion, object.scale );
	
				} else {
	
					if ( data.position !== undefined ) object.position.fromArray( data.position );
					if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
					if ( data.scale !== undefined ) object.scale.fromArray( data.scale );
	
				}
	
				if ( data.castShadow !== undefined ) object.castShadow = data.castShadow;
				if ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;
	
				if ( data.visible !== undefined ) object.visible = data.visible;
				if ( data.userData !== undefined ) object.userData = data.userData;
	
				if ( data.children !== undefined ) {
	
					for ( var child in data.children ) {
	
						object.add( this.parseObject( data.children[ child ], geometries, materials ) );
	
					}
	
				}
	
				if ( data.type === 'LOD' ) {
	
					var levels = data.levels;
	
					for ( var l = 0; l < levels.length; l ++ ) {
	
						var level = levels[ l ];
						var child = object.getObjectByProperty( 'uuid', level.object );
	
						if ( child !== undefined ) {
	
							object.addLevel( child, level.distance );
	
						}
	
					}
	
				}
	
				return object;
	
			}
	
		}()
	
	};
	
	// File:src/loaders/TextureLoader.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.TextureLoader = function ( manager ) {
	
		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
	
	};
	
	THREE.TextureLoader.prototype = {
	
		constructor: THREE.TextureLoader,
	
		load: function ( url, onLoad, onProgress, onError ) {
	
			var texture = new THREE.Texture();
	
			var loader = new THREE.ImageLoader( this.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.setPath( this.path );
			loader.load( url, function ( image ) {
	
				texture.image = image;
				texture.needsUpdate = true;
	
				if ( onLoad !== undefined ) {
	
					onLoad( texture );
	
				}
	
			}, onProgress, onError );
	
			return texture;
	
		},
	
		setCrossOrigin: function ( value ) {
	
			this.crossOrigin = value;
	
		},
	
		setPath: function ( value ) {
	
			this.path = value;
	
		}
	
	};
	
	// File:src/loaders/CubeTextureLoader.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.CubeTextureLoader = function ( manager ) {
	
		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
	
	};
	
	THREE.CubeTextureLoader.prototype = {
	
		constructor: THREE.CubeTextureLoader,
	
		load: function ( urls, onLoad, onProgress, onError ) {
	
			var texture = new THREE.CubeTexture( [] );
	
			var loader = new THREE.ImageLoader( this.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.setPath( this.path );
	
			var loaded = 0;
	
			function loadTexture( i ) {
	
				loader.load( urls[ i ], function ( image ) {
	
					texture.images[ i ] = image;
	
					loaded ++;
	
					if ( loaded === 6 ) {
	
						texture.needsUpdate = true;
	
						if ( onLoad ) onLoad( texture );
	
					}
	
				}, undefined, onError );
	
			}
	
			for ( var i = 0; i < urls.length; ++ i ) {
	
				loadTexture( i );
	
			}
	
			return texture;
	
		},
	
		setCrossOrigin: function ( value ) {
	
			this.crossOrigin = value;
	
		},
	
		setPath: function ( value ) {
	
			this.path = value;
	
		}
	
	};
	
	// File:src/loaders/BinaryTextureLoader.js
	
	/**
	 * @author Nikos M. / https://github.com/foo123/
	 *
	 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
	 */
	
	THREE.DataTextureLoader = THREE.BinaryTextureLoader = function ( manager ) {
	
		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
	
		// override in sub classes
		this._parser = null;
	
	};
	
	THREE.BinaryTextureLoader.prototype = {
	
		constructor: THREE.BinaryTextureLoader,
	
		load: function ( url, onLoad, onProgress, onError ) {
	
			var scope = this;
	
			var texture = new THREE.DataTexture();
	
			var loader = new THREE.XHRLoader( this.manager );
			loader.setResponseType( 'arraybuffer' );
	
			loader.load( url, function ( buffer ) {
	
				var texData = scope._parser( buffer );
	
				if ( ! texData ) return;
	
				if ( undefined !== texData.image ) {
	
					texture.image = texData.image;
	
				} else if ( undefined !== texData.data ) {
	
					texture.image.width = texData.width;
					texture.image.height = texData.height;
					texture.image.data = texData.data;
	
				}
	
				texture.wrapS = undefined !== texData.wrapS ? texData.wrapS : THREE.ClampToEdgeWrapping;
				texture.wrapT = undefined !== texData.wrapT ? texData.wrapT : THREE.ClampToEdgeWrapping;
	
				texture.magFilter = undefined !== texData.magFilter ? texData.magFilter : THREE.LinearFilter;
				texture.minFilter = undefined !== texData.minFilter ? texData.minFilter : THREE.LinearMipMapLinearFilter;
	
				texture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;
	
				if ( undefined !== texData.format ) {
	
					texture.format = texData.format;
	
				}
				if ( undefined !== texData.type ) {
	
					texture.type = texData.type;
	
				}
	
				if ( undefined !== texData.mipmaps ) {
	
					texture.mipmaps = texData.mipmaps;
	
				}
	
				if ( 1 === texData.mipmapCount ) {
	
					texture.minFilter = THREE.LinearFilter;
	
				}
	
				texture.needsUpdate = true;
	
				if ( onLoad ) onLoad( texture, texData );
	
			}, onProgress, onError );
	
	
			return texture;
	
		}
	
	};
	
	// File:src/loaders/CompressedTextureLoader.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 *
	 * Abstract Base class to block based textures loader (dds, pvr, ...)
	 */
	
	THREE.CompressedTextureLoader = function ( manager ) {
	
		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
	
		// override in sub classes
		this._parser = null;
	
	};
	
	
	THREE.CompressedTextureLoader.prototype = {
	
		constructor: THREE.CompressedTextureLoader,
	
		load: function ( url, onLoad, onProgress, onError ) {
	
			var scope = this;
	
			var images = [];
	
			var texture = new THREE.CompressedTexture();
			texture.image = images;
	
			var loader = new THREE.XHRLoader( this.manager );
			loader.setPath( this.path );
			loader.setResponseType( 'arraybuffer' );
	
			function loadTexture( i ) {
	
				loader.load( url[ i ], function ( buffer ) {
	
					var texDatas = scope._parser( buffer, true );
	
					images[ i ] = {
						width: texDatas.width,
						height: texDatas.height,
						format: texDatas.format,
						mipmaps: texDatas.mipmaps
					};
	
					loaded += 1;
	
					if ( loaded === 6 ) {
	
						if ( texDatas.mipmapCount === 1 )
							texture.minFilter = THREE.LinearFilter;
	
						texture.format = texDatas.format;
						texture.needsUpdate = true;
	
						if ( onLoad ) onLoad( texture );
	
					}
	
				}, onProgress, onError );
	
			}
	
			if ( Array.isArray( url ) ) {
	
				var loaded = 0;
	
				for ( var i = 0, il = url.length; i < il; ++ i ) {
	
					loadTexture( i );
	
				}
	
			} else {
	
				// compressed cubemap texture stored in a single DDS file
	
				loader.load( url, function ( buffer ) {
	
					var texDatas = scope._parser( buffer, true );
	
					if ( texDatas.isCubemap ) {
	
						var faces = texDatas.mipmaps.length / texDatas.mipmapCount;
	
						for ( var f = 0; f < faces; f ++ ) {
	
							images[ f ] = { mipmaps : [] };
	
							for ( var i = 0; i < texDatas.mipmapCount; i ++ ) {
	
								images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );
								images[ f ].format = texDatas.format;
								images[ f ].width = texDatas.width;
								images[ f ].height = texDatas.height;
	
							}
	
						}
	
					} else {
	
						texture.image.width = texDatas.width;
						texture.image.height = texDatas.height;
						texture.mipmaps = texDatas.mipmaps;
	
					}
	
					if ( texDatas.mipmapCount === 1 ) {
	
						texture.minFilter = THREE.LinearFilter;
	
					}
	
					texture.format = texDatas.format;
					texture.needsUpdate = true;
	
					if ( onLoad ) onLoad( texture );
	
				}, onProgress, onError );
	
			}
	
			return texture;
	
		},
	
		setPath: function ( value ) {
	
			this.path = value;
	
		}
	
	};
	
	// File:src/materials/Material.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.Material = function () {
	
		Object.defineProperty( this, 'id', { value: THREE.MaterialIdCount ++ } );
	
		this.uuid = THREE.Math.generateUUID();
	
		this.name = '';
		this.type = 'Material';
	
		this.side = THREE.FrontSide;
	
		this.opacity = 1;
		this.transparent = false;
	
		this.blending = THREE.NormalBlending;
	
		this.blendSrc = THREE.SrcAlphaFactor;
		this.blendDst = THREE.OneMinusSrcAlphaFactor;
		this.blendEquation = THREE.AddEquation;
		this.blendSrcAlpha = null;
		this.blendDstAlpha = null;
		this.blendEquationAlpha = null;
	
		this.depthFunc = THREE.LessEqualDepth;
		this.depthTest = true;
		this.depthWrite = true;
	
		this.colorWrite = true;
	
		this.precision = null; // override the renderer's default precision for this material
	
		this.polygonOffset = false;
		this.polygonOffsetFactor = 0;
		this.polygonOffsetUnits = 0;
	
		this.alphaTest = 0;
	
		this.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer
	
		this.visible = true;
	
		this._needsUpdate = true;
	
	};
	
	THREE.Material.prototype = {
	
		constructor: THREE.Material,
	
		get needsUpdate () {
	
			return this._needsUpdate;
	
		},
	
		set needsUpdate ( value ) {
	
			if ( value === true ) this.update();
	
			this._needsUpdate = value;
	
		},
	
		setValues: function ( values ) {
	
			if ( values === undefined ) return;
	
			for ( var key in values ) {
	
				var newValue = values[ key ];
	
				if ( newValue === undefined ) {
	
					console.warn( "THREE.Material: '" + key + "' parameter is undefined." );
					continue;
	
				}
	
				var currentValue = this[ key ];
	
				if ( currentValue === undefined ) {
	
					console.warn( "THREE." + this.type + ": '" + key + "' is not a property of this material." );
					continue;
	
				}
	
				if ( currentValue instanceof THREE.Color ) {
	
					currentValue.set( newValue );
	
				} else if ( currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3 ) {
	
					currentValue.copy( newValue );
	
				} else if ( key === 'overdraw' ) {
	
					// ensure overdraw is backwards-compatible with legacy boolean type
					this[ key ] = Number( newValue );
	
				} else {
	
					this[ key ] = newValue;
	
				}
	
			}
	
		},
	
		toJSON: function ( meta ) {
	
			var isRoot = meta === undefined;
	
			if ( isRoot ) {
	
				meta = {
					textures: {},
					images: {}
				};
	
			}
	
			var data = {
				metadata: {
					version: 4.4,
					type: 'Material',
					generator: 'Material.toJSON'
				}
			};
	
			// standard Material serialization
			data.uuid = this.uuid;
			data.type = this.type;
			if ( this.name !== '' ) data.name = this.name;
	
			if ( this.color instanceof THREE.Color ) data.color = this.color.getHex();
	
			if ( this.roughness !== 0.5 ) data.roughness = this.roughness;
			if ( this.metalness !== 0.5 ) data.metalness = this.metalness;
	
			if ( this.emissive instanceof THREE.Color ) data.emissive = this.emissive.getHex();
			if ( this.specular instanceof THREE.Color ) data.specular = this.specular.getHex();
			if ( this.shininess !== undefined ) data.shininess = this.shininess;
	
			if ( this.map instanceof THREE.Texture ) data.map = this.map.toJSON( meta ).uuid;
			if ( this.alphaMap instanceof THREE.Texture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;
			if ( this.lightMap instanceof THREE.Texture ) data.lightMap = this.lightMap.toJSON( meta ).uuid;
			if ( this.bumpMap instanceof THREE.Texture ) {
	
				data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
				data.bumpScale = this.bumpScale;
	
			}
			if ( this.normalMap instanceof THREE.Texture ) {
	
				data.normalMap = this.normalMap.toJSON( meta ).uuid;
				data.normalScale = this.normalScale.toArray();
	
			}
			if ( this.displacementMap instanceof THREE.Texture ) {
	
				data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
				data.displacementScale = this.displacementScale;
				data.displacementBias = this.displacementBias;
	
			}
			if ( this.roughnessMap instanceof THREE.Texture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;
			if ( this.metalnessMap instanceof THREE.Texture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;
	
			if ( this.emissiveMap instanceof THREE.Texture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;
			if ( this.specularMap instanceof THREE.Texture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;
	
			if ( this.envMap instanceof THREE.Texture ) {
	
				data.envMap = this.envMap.toJSON( meta ).uuid;
				data.reflectivity = this.reflectivity; // Scale behind envMap
	
			}
	
			if ( this.size !== undefined ) data.size = this.size;
			if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;
	
			if ( this.vertexColors !== undefined && this.vertexColors !== THREE.NoColors ) data.vertexColors = this.vertexColors;
			if ( this.shading !== undefined && this.shading !== THREE.SmoothShading ) data.shading = this.shading;
			if ( this.blending !== undefined && this.blending !== THREE.NormalBlending ) data.blending = this.blending;
			if ( this.side !== undefined && this.side !== THREE.FrontSide ) data.side = this.side;
	
			if ( this.opacity < 1 ) data.opacity = this.opacity;
			if ( this.transparent === true ) data.transparent = this.transparent;
			if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
			if ( this.wireframe === true ) data.wireframe = this.wireframe;
			if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;
	
			// TODO: Copied from Object3D.toJSON
	
			function extractFromCache ( cache ) {
	
				var values = [];
	
				for ( var key in cache ) {
	
					var data = cache[ key ];
					delete data.metadata;
					values.push( data );
	
				}
	
				return values;
	
			}
	
			if ( isRoot ) {
	
				var textures = extractFromCache( meta.textures );
				var images = extractFromCache( meta.images );
	
				if ( textures.length > 0 ) data.textures = textures;
				if ( images.length > 0 ) data.images = images;
	
			}
	
			return data;
	
		},
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		},
	
		copy: function ( source ) {
	
			this.name = source.name;
	
			this.side = source.side;
	
			this.opacity = source.opacity;
			this.transparent = source.transparent;
	
			this.blending = source.blending;
	
			this.blendSrc = source.blendSrc;
			this.blendDst = source.blendDst;
			this.blendEquation = source.blendEquation;
			this.blendSrcAlpha = source.blendSrcAlpha;
			this.blendDstAlpha = source.blendDstAlpha;
			this.blendEquationAlpha = source.blendEquationAlpha;
	
			this.depthFunc = source.depthFunc;
			this.depthTest = source.depthTest;
			this.depthWrite = source.depthWrite;
	
			this.colorWrite = source.colorWrite;
	
			this.precision = source.precision;
	
			this.polygonOffset = source.polygonOffset;
			this.polygonOffsetFactor = source.polygonOffsetFactor;
			this.polygonOffsetUnits = source.polygonOffsetUnits;
	
			this.alphaTest = source.alphaTest;
	
			this.overdraw = source.overdraw;
	
			this.visible = source.visible;
	
			return this;
	
		},
	
		update: function () {
	
			this.dispatchEvent( { type: 'update' } );
	
		},
	
		dispose: function () {
	
			this.dispatchEvent( { type: 'dispose' } );
	
		}
	
	};
	
	THREE.EventDispatcher.prototype.apply( THREE.Material.prototype );
	
	THREE.MaterialIdCount = 0;
	
	// File:src/materials/LineBasicMaterial.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  linewidth: <float>,
	 *  linecap: "round",
	 *  linejoin: "round",
	 *
	 *  vertexColors: <bool>
	 *
	 *  fog: <bool>
	 * }
	 */
	
	THREE.LineBasicMaterial = function ( parameters ) {
	
		THREE.Material.call( this );
	
		this.type = 'LineBasicMaterial';
	
		this.color = new THREE.Color( 0xffffff );
	
		this.linewidth = 1;
		this.linecap = 'round';
		this.linejoin = 'round';
	
		this.vertexColors = THREE.NoColors;
	
		this.fog = true;
	
		this.setValues( parameters );
	
	};
	
	THREE.LineBasicMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.LineBasicMaterial.prototype.constructor = THREE.LineBasicMaterial;
	
	THREE.LineBasicMaterial.prototype.copy = function ( source ) {
	
		THREE.Material.prototype.copy.call( this, source );
	
		this.color.copy( source.color );
	
		this.linewidth = source.linewidth;
		this.linecap = source.linecap;
		this.linejoin = source.linejoin;
	
		this.vertexColors = source.vertexColors;
	
		this.fog = source.fog;
	
		return this;
	
	};
	
	// File:src/materials/LineDashedMaterial.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  linewidth: <float>,
	 *
	 *  scale: <float>,
	 *  dashSize: <float>,
	 *  gapSize: <float>,
	 *
	 *  vertexColors: THREE.NoColors / THREE.FaceColors / THREE.VertexColors
	 *
	 *  fog: <bool>
	 * }
	 */
	
	THREE.LineDashedMaterial = function ( parameters ) {
	
		THREE.Material.call( this );
	
		this.type = 'LineDashedMaterial';
	
		this.color = new THREE.Color( 0xffffff );
	
		this.linewidth = 1;
	
		this.scale = 1;
		this.dashSize = 3;
		this.gapSize = 1;
	
		this.vertexColors = THREE.NoColors;
	
		this.fog = true;
	
		this.setValues( parameters );
	
	};
	
	THREE.LineDashedMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.LineDashedMaterial.prototype.constructor = THREE.LineDashedMaterial;
	
	THREE.LineDashedMaterial.prototype.copy = function ( source ) {
	
		THREE.Material.prototype.copy.call( this, source );
	
		this.color.copy( source.color );
		
		this.linewidth = source.linewidth;
	
		this.scale = source.scale;
		this.dashSize = source.dashSize;
		this.gapSize = source.gapSize;
	
		this.vertexColors = source.vertexColors;
	
		this.fog = source.fog;
	
		return this;
	
	};
	
	// File:src/materials/MeshBasicMaterial.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  shading: THREE.SmoothShading,
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *
	 *  fog: <bool>
	 * }
	 */
	
	THREE.MeshBasicMaterial = function ( parameters ) {
	
		THREE.Material.call( this );
	
		this.type = 'MeshBasicMaterial';
	
		this.color = new THREE.Color( 0xffffff ); // emissive
	
		this.map = null;
	
		this.aoMap = null;
		this.aoMapIntensity = 1.0;
	
		this.specularMap = null;
	
		this.alphaMap = null;
	
		this.envMap = null;
		this.combine = THREE.MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;
	
		this.fog = true;
	
		this.shading = THREE.SmoothShading;
	
		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';
	
		this.vertexColors = THREE.NoColors;
	
		this.skinning = false;
		this.morphTargets = false;
	
		this.setValues( parameters );
	
	};
	
	THREE.MeshBasicMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.MeshBasicMaterial.prototype.constructor = THREE.MeshBasicMaterial;
	
	THREE.MeshBasicMaterial.prototype.copy = function ( source ) {
	
		THREE.Material.prototype.copy.call( this, source );
	
		this.color.copy( source.color );
	
		this.map = source.map;
	
		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;
	
		this.specularMap = source.specularMap;
	
		this.alphaMap = source.alphaMap;
	
		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;
	
		this.fog = source.fog;
	
		this.shading = source.shading;
	
		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;
	
		this.vertexColors = source.vertexColors;
	
		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
	
		return this;
	
	};
	
	// File:src/materials/MeshLambertMaterial.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *  lightMapIntensity: <float>
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  emissive: <hex>,
	 *  emissiveIntensity: <float>
	 *  emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>,
	 *
	 *	fog: <bool>
	 * }
	 */
	
	THREE.MeshLambertMaterial = function ( parameters ) {
	
		THREE.Material.call( this );
	
		this.type = 'MeshLambertMaterial';
	
		this.color = new THREE.Color( 0xffffff ); // diffuse
	
		this.map = null;
	
		this.lightMap = null;
		this.lightMapIntensity = 1.0;
	
		this.aoMap = null;
		this.aoMapIntensity = 1.0;
	
		this.emissive = new THREE.Color( 0x000000 );
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;
	
		this.specularMap = null;
	
		this.alphaMap = null;
	
		this.envMap = null;
		this.combine = THREE.MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;
	
		this.fog = true;
	
		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';
	
		this.vertexColors = THREE.NoColors;
	
		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;
	
		this.setValues( parameters );
	
	};
	
	THREE.MeshLambertMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.MeshLambertMaterial.prototype.constructor = THREE.MeshLambertMaterial;
	
	THREE.MeshLambertMaterial.prototype.copy = function ( source ) {
	
		THREE.Material.prototype.copy.call( this, source );
	
		this.color.copy( source.color );
	
		this.map = source.map;
	
		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;
	
		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;
	
		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;
	
		this.specularMap = source.specularMap;
	
		this.alphaMap = source.alphaMap;
	
		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;
	
		this.fog = source.fog;
	
		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;
	
		this.vertexColors = source.vertexColors;
	
		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;
	
		return this;
	
	};
	
	// File:src/materials/MeshPhongMaterial.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  specular: <hex>,
	 *  shininess: <float>,
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *  lightMapIntensity: <float>
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  emissive: <hex>,
	 *  emissiveIntensity: <float>
	 *  emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *  bumpMap: new THREE.Texture( <Image> ),
	 *  bumpScale: <float>,
	 *
	 *  normalMap: new THREE.Texture( <Image> ),
	 *  normalScale: <Vector2>,
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  shading: THREE.SmoothShading,
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>,
	 *
	 *	fog: <bool>
	 * }
	 */
	
	THREE.MeshPhongMaterial = function ( parameters ) {
	
		THREE.Material.call( this );
	
		this.type = 'MeshPhongMaterial';
	
		this.color = new THREE.Color( 0xffffff ); // diffuse
		this.specular = new THREE.Color( 0x111111 );
		this.shininess = 30;
	
		this.map = null;
	
		this.lightMap = null;
		this.lightMapIntensity = 1.0;
	
		this.aoMap = null;
		this.aoMapIntensity = 1.0;
	
		this.emissive = new THREE.Color( 0x000000 );
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;
	
		this.bumpMap = null;
		this.bumpScale = 1;
	
		this.normalMap = null;
		this.normalScale = new THREE.Vector2( 1, 1 );
	
		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;
	
		this.specularMap = null;
	
		this.alphaMap = null;
	
		this.envMap = null;
		this.combine = THREE.MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;
	
		this.fog = true;
	
		this.shading = THREE.SmoothShading;
	
		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';
	
		this.vertexColors = THREE.NoColors;
	
		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;
	
		this.setValues( parameters );
	
	};
	
	THREE.MeshPhongMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.MeshPhongMaterial.prototype.constructor = THREE.MeshPhongMaterial;
	
	THREE.MeshPhongMaterial.prototype.copy = function ( source ) {
	
		THREE.Material.prototype.copy.call( this, source );
	
		this.color.copy( source.color );
		this.specular.copy( source.specular );
		this.shininess = source.shininess;
	
		this.map = source.map;
	
		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;
	
		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;
	
		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;
	
		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;
	
		this.normalMap = source.normalMap;
		this.normalScale.copy( source.normalScale );
	
		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;
	
		this.specularMap = source.specularMap;
	
		this.alphaMap = source.alphaMap;
	
		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;
	
		this.fog = source.fog;
	
		this.shading = source.shading;
	
		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;
	
		this.vertexColors = source.vertexColors;
	
		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;
	
		return this;
	
	};
	
	// File:src/materials/MeshStandardMaterial.js
	
	/**
	 * @author WestLangley / http://github.com/WestLangley
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  roughness: <float>,
	 *  metalness: <float>,
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *  lightMapIntensity: <float>
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  emissive: <hex>,
	 *  emissiveIntensity: <float>
	 *  emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *  bumpMap: new THREE.Texture( <Image> ),
	 *  bumpScale: <float>,
	 *
	 *  normalMap: new THREE.Texture( <Image> ),
	 *  normalScale: <Vector2>,
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  roughnessMap: new THREE.Texture( <Image> ),
	 *
	 *  metalnessMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	 *  envMapIntensity: <float>
	 *
	 *  refractionRatio: <float>,
	 *
	 *  shading: THREE.SmoothShading,
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>,
	 *
	 *	fog: <bool>
	 * }
	 */
	
	THREE.MeshStandardMaterial = function ( parameters ) {
	
		THREE.Material.call( this );
	
		this.type = 'MeshStandardMaterial';
	
		this.color = new THREE.Color( 0xffffff ); // diffuse
		this.roughness = 0.5;
		this.metalness = 0.5;
	
		this.map = null;
	
		this.lightMap = null;
		this.lightMapIntensity = 1.0;
	
		this.aoMap = null;
		this.aoMapIntensity = 1.0;
	
		this.emissive = new THREE.Color( 0x000000 );
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;
	
		this.bumpMap = null;
		this.bumpScale = 1;
	
		this.normalMap = null;
		this.normalScale = new THREE.Vector2( 1, 1 );
	
		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;
	
		this.roughnessMap = null;
	
		this.metalnessMap = null;
	
		this.alphaMap = null;
	
		this.envMap = null;
		this.envMapIntensity = 1.0;
	
		this.refractionRatio = 0.98;
	
		this.fog = true;
	
		this.shading = THREE.SmoothShading;
	
		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';
	
		this.vertexColors = THREE.NoColors;
	
		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;
	
		this.setValues( parameters );
	
	};
	
	THREE.MeshStandardMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.MeshStandardMaterial.prototype.constructor = THREE.MeshStandardMaterial;
	
	THREE.MeshStandardMaterial.prototype.copy = function ( source ) {
	
		THREE.Material.prototype.copy.call( this, source );
	
		this.color.copy( source.color );
		this.roughness = source.roughness;
		this.metalness = source.metalness;
	
		this.map = source.map;
	
		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;
	
		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;
	
		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;
	
		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;
	
		this.normalMap = source.normalMap;
		this.normalScale.copy( source.normalScale );
	
		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;
	
		this.roughnessMap = source.roughnessMap;
	
		this.metalnessMap = source.metalnessMap;
	
		this.alphaMap = source.alphaMap;
	
		this.envMap = source.envMap;
		this.envMapIntensity = source.envMapIntensity;
	
		this.refractionRatio = source.refractionRatio;
	
		this.fog = source.fog;
	
		this.shading = source.shading;
	
		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;
	
		this.vertexColors = source.vertexColors;
	
		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;
	
		return this;
	
	};
	
	// File:src/materials/MeshDepthMaterial.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  opacity: <float>,
	 *
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>
	 * }
	 */
	
	THREE.MeshDepthMaterial = function ( parameters ) {
	
		THREE.Material.call( this );
	
		this.type = 'MeshDepthMaterial';
	
		this.morphTargets = false;
		this.wireframe = false;
		this.wireframeLinewidth = 1;
	
		this.setValues( parameters );
	
	};
	
	THREE.MeshDepthMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.MeshDepthMaterial.prototype.constructor = THREE.MeshDepthMaterial;
	
	THREE.MeshDepthMaterial.prototype.copy = function ( source ) {
	
		THREE.Material.prototype.copy.call( this, source );
	
		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
	
		return this;
	
	};
	
	// File:src/materials/MeshNormalMaterial.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 *
	 * parameters = {
	 *  opacity: <float>,
	 *
	 *  shading: THREE.FlatShading,
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>
	 * }
	 */
	
	THREE.MeshNormalMaterial = function ( parameters ) {
	
		THREE.Material.call( this, parameters );
	
		this.type = 'MeshNormalMaterial';
	
		this.wireframe = false;
		this.wireframeLinewidth = 1;
	
		this.morphTargets = false;
	
		this.setValues( parameters );
	
	};
	
	THREE.MeshNormalMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.MeshNormalMaterial.prototype.constructor = THREE.MeshNormalMaterial;
	
	THREE.MeshNormalMaterial.prototype.copy = function ( source ) {
	
		THREE.Material.prototype.copy.call( this, source );
	
		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
	
		return this;
	
	};
	
	// File:src/materials/MultiMaterial.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.MultiMaterial = function ( materials ) {
	
		this.uuid = THREE.Math.generateUUID();
	
		this.type = 'MultiMaterial';
	
		this.materials = materials instanceof Array ? materials : [];
	
		this.visible = true;
	
	};
	
	THREE.MultiMaterial.prototype = {
	
		constructor: THREE.MultiMaterial,
	
		toJSON: function ( meta ) {
	
			var output = {
				metadata: {
					version: 4.2,
					type: 'material',
					generator: 'MaterialExporter'
				},
				uuid: this.uuid,
				type: this.type,
				materials: []
			};
	
			var materials = this.materials;
	
			for ( var i = 0, l = materials.length; i < l; i ++ ) {
	
				var material = materials[ i ].toJSON( meta );
				delete material.metadata;
	
				output.materials.push( material );
	
			}
	
			output.visible = this.visible;
	
			return output;
	
		},
	
		clone: function () {
	
			var material = new this.constructor();
	
			for ( var i = 0; i < this.materials.length; i ++ ) {
	
				material.materials.push( this.materials[ i ].clone() );
	
			}
	
			material.visible = this.visible;
	
			return material;
	
		}
	
	};
	
	// File:src/materials/PointsMaterial.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  size: <float>,
	 *  sizeAttenuation: <bool>,
	 *
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  vertexColors: <bool>,
	 *
	 *  fog: <bool>
	 * }
	 */
	
	THREE.PointsMaterial = function ( parameters ) {
	
		THREE.Material.call( this );
	
		this.type = 'PointsMaterial';
	
		this.color = new THREE.Color( 0xffffff );
	
		this.map = null;
	
		this.size = 1;
		this.sizeAttenuation = true;
	
		this.vertexColors = THREE.NoColors;
	
		this.fog = true;
	
		this.setValues( parameters );
	
	};
	
	THREE.PointsMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.PointsMaterial.prototype.constructor = THREE.PointsMaterial;
	
	THREE.PointsMaterial.prototype.copy = function ( source ) {
	
		THREE.Material.prototype.copy.call( this, source );
	
		this.color.copy( source.color );
	
		this.map = source.map;
	
		this.size = source.size;
		this.sizeAttenuation = source.sizeAttenuation;
	
		this.vertexColors = source.vertexColors;
	
		this.fog = source.fog;
	
		return this;
	
	};
	
	// File:src/materials/ShaderMaterial.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  defines: { "label" : "value" },
	 *  uniforms: { "parameter1": { type: "f", value: 1.0 }, "parameter2": { type: "i" value2: 2 } },
	 *
	 *  fragmentShader: <string>,
	 *  vertexShader: <string>,
	 *
	 *  shading: THREE.SmoothShading,
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  lights: <bool>,
	 *
	 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>,
	 *
	 *	fog: <bool>
	 * }
	 */
	
	THREE.ShaderMaterial = function ( parameters ) {
	
		THREE.Material.call( this );
	
		this.type = 'ShaderMaterial';
	
		this.defines = {};
		this.uniforms = {};
	
		this.vertexShader = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';
		this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';
	
		this.shading = THREE.SmoothShading;
	
		this.linewidth = 1;
	
		this.wireframe = false;
		this.wireframeLinewidth = 1;
	
		this.fog = false; // set to use scene fog
	
		this.lights = false; // set to use scene lights
	
		this.vertexColors = THREE.NoColors; // set to use "color" attribute stream
	
		this.skinning = false; // set to use skinning attribute streams
	
		this.morphTargets = false; // set to use morph targets
		this.morphNormals = false; // set to use morph normals
	
		this.extensions = {
			derivatives: false, // set to use derivatives
			fragDepth: false, // set to use fragment depth values
			drawBuffers: false, // set to use draw buffers
			shaderTextureLOD: false // set to use shader texture LOD
		};
	
		// When rendered geometry doesn't include these attributes but the material does,
		// use these default values in WebGL. This avoids errors when buffer data is missing.
		this.defaultAttributeValues = {
			'color': [ 1, 1, 1 ],
			'uv': [ 0, 0 ],
			'uv2': [ 0, 0 ]
		};
	
		this.index0AttributeName = undefined;
	
		if ( parameters !== undefined ) {
	
			if ( parameters.attributes !== undefined ) {
	
				console.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );
	
			}
	
			this.setValues( parameters );
	
		}
	
	};
	
	THREE.ShaderMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.ShaderMaterial.prototype.constructor = THREE.ShaderMaterial;
	
	THREE.ShaderMaterial.prototype.copy = function ( source ) {
	
		THREE.Material.prototype.copy.call( this, source );
	
		this.fragmentShader = source.fragmentShader;
		this.vertexShader = source.vertexShader;
	
		this.uniforms = THREE.UniformsUtils.clone( source.uniforms );
	
		this.defines = source.defines;
	
		this.shading = source.shading;
	
		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
	
		this.fog = source.fog;
	
		this.lights = source.lights;
	
		this.vertexColors = source.vertexColors;
	
		this.skinning = source.skinning;
	
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;
	
		this.extensions = source.extensions;
	
		return this;
	
	};
	
	THREE.ShaderMaterial.prototype.toJSON = function ( meta ) {
	
		var data = THREE.Material.prototype.toJSON.call( this, meta );
	
		data.uniforms = this.uniforms;
		data.vertexShader = this.vertexShader;
		data.fragmentShader = this.fragmentShader;
	
		return data;
	
	};
	
	// File:src/materials/RawShaderMaterial.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.RawShaderMaterial = function ( parameters ) {
	
		THREE.ShaderMaterial.call( this, parameters );
	
		this.type = 'RawShaderMaterial';
	
	};
	
	THREE.RawShaderMaterial.prototype = Object.create( THREE.ShaderMaterial.prototype );
	THREE.RawShaderMaterial.prototype.constructor = THREE.RawShaderMaterial;
	
	// File:src/materials/SpriteMaterial.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *	uvOffset: new THREE.Vector2(),
	 *	uvScale: new THREE.Vector2(),
	 *
	 *  fog: <bool>
	 * }
	 */
	
	THREE.SpriteMaterial = function ( parameters ) {
	
		THREE.Material.call( this );
	
		this.type = 'SpriteMaterial';
	
		this.color = new THREE.Color( 0xffffff );
		this.map = null;
	
		this.rotation = 0;
	
		this.fog = false;
	
		// set parameters
	
		this.setValues( parameters );
	
	};
	
	THREE.SpriteMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.SpriteMaterial.prototype.constructor = THREE.SpriteMaterial;
	
	THREE.SpriteMaterial.prototype.copy = function ( source ) {
	
		THREE.Material.prototype.copy.call( this, source );
	
		this.color.copy( source.color );
		this.map = source.map;
	
		this.rotation = source.rotation;
	
		this.fog = source.fog;
	
		return this;
	
	};
	
	// File:src/textures/Texture.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author szimek / https://github.com/szimek/
	 */
	
	THREE.Texture = function ( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {
	
		Object.defineProperty( this, 'id', { value: THREE.TextureIdCount ++ } );
	
		this.uuid = THREE.Math.generateUUID();
	
		this.name = '';
		this.sourceFile = '';
	
		this.image = image !== undefined ? image : THREE.Texture.DEFAULT_IMAGE;
		this.mipmaps = [];
	
		this.mapping = mapping !== undefined ? mapping : THREE.Texture.DEFAULT_MAPPING;
	
		this.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;
		this.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;
	
		this.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;
		this.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;
	
		this.anisotropy = anisotropy !== undefined ? anisotropy : 1;
	
		this.format = format !== undefined ? format : THREE.RGBAFormat;
		this.type = type !== undefined ? type : THREE.UnsignedByteType;
	
		this.offset = new THREE.Vector2( 0, 0 );
		this.repeat = new THREE.Vector2( 1, 1 );
	
		this.generateMipmaps = true;
		this.premultiplyAlpha = false;
		this.flipY = true;
		this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)
	
		this.version = 0;
		this.onUpdate = null;
	
	};
	
	THREE.Texture.DEFAULT_IMAGE = undefined;
	THREE.Texture.DEFAULT_MAPPING = THREE.UVMapping;
	
	THREE.Texture.prototype = {
	
		constructor: THREE.Texture,
	
		set needsUpdate ( value ) {
	
			if ( value === true ) this.version ++;
	
		},
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		},
	
		copy: function ( source ) {
	
			this.image = source.image;
			this.mipmaps = source.mipmaps.slice( 0 );
	
			this.mapping = source.mapping;
	
			this.wrapS = source.wrapS;
			this.wrapT = source.wrapT;
	
			this.magFilter = source.magFilter;
			this.minFilter = source.minFilter;
	
			this.anisotropy = source.anisotropy;
	
			this.format = source.format;
			this.type = source.type;
	
			this.offset.copy( source.offset );
			this.repeat.copy( source.repeat );
	
			this.generateMipmaps = source.generateMipmaps;
			this.premultiplyAlpha = source.premultiplyAlpha;
			this.flipY = source.flipY;
			this.unpackAlignment = source.unpackAlignment;
	
			return this;
	
		},
	
		toJSON: function ( meta ) {
	
			if ( meta.textures[ this.uuid ] !== undefined ) {
	
				return meta.textures[ this.uuid ];
	
			}
	
			function getDataURL( image ) {
	
				var canvas;
	
				if ( image.toDataURL !== undefined ) {
	
					canvas = image;
	
				} else {
	
					canvas = document.createElement( 'canvas' );
					canvas.width = image.width;
					canvas.height = image.height;
	
					canvas.getContext( '2d' ).drawImage( image, 0, 0, image.width, image.height );
	
				}
	
				if ( canvas.width > 2048 || canvas.height > 2048 ) {
	
					return canvas.toDataURL( 'image/jpeg', 0.6 );
	
				} else {
	
					return canvas.toDataURL( 'image/png' );
	
				}
	
			}
	
			var output = {
				metadata: {
					version: 4.4,
					type: 'Texture',
					generator: 'Texture.toJSON'
				},
	
				uuid: this.uuid,
				name: this.name,
	
				mapping: this.mapping,
	
				repeat: [ this.repeat.x, this.repeat.y ],
				offset: [ this.offset.x, this.offset.y ],
				wrap: [ this.wrapS, this.wrapT ],
	
				minFilter: this.minFilter,
				magFilter: this.magFilter,
				anisotropy: this.anisotropy
			};
	
			if ( this.image !== undefined ) {
	
				// TODO: Move to THREE.Image
	
				var image = this.image;
	
				if ( image.uuid === undefined ) {
	
					image.uuid = THREE.Math.generateUUID(); // UGH
	
				}
	
				if ( meta.images[ image.uuid ] === undefined ) {
	
					meta.images[ image.uuid ] = {
						uuid: image.uuid,
						url: getDataURL( image )
					};
	
				}
	
				output.image = image.uuid;
	
			}
	
			meta.textures[ this.uuid ] = output;
	
			return output;
	
		},
	
		dispose: function () {
	
			this.dispatchEvent( { type: 'dispose' } );
	
		},
	
		transformUv: function ( uv ) {
	
			if ( this.mapping !== THREE.UVMapping )  return;
	
			uv.multiply( this.repeat );
			uv.add( this.offset );
	
			if ( uv.x < 0 || uv.x > 1 ) {
	
				switch ( this.wrapS ) {
	
					case THREE.RepeatWrapping:
	
						uv.x = uv.x - Math.floor( uv.x );
						break;
	
					case THREE.ClampToEdgeWrapping:
	
						uv.x = uv.x < 0 ? 0 : 1;
						break;
	
					case THREE.MirroredRepeatWrapping:
	
						if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {
	
							uv.x = Math.ceil( uv.x ) - uv.x;
	
						} else {
	
							uv.x = uv.x - Math.floor( uv.x );
	
						}
						break;
	
				}
	
			}
	
			if ( uv.y < 0 || uv.y > 1 ) {
	
				switch ( this.wrapT ) {
	
					case THREE.RepeatWrapping:
	
						uv.y = uv.y - Math.floor( uv.y );
						break;
	
					case THREE.ClampToEdgeWrapping:
	
						uv.y = uv.y < 0 ? 0 : 1;
						break;
	
					case THREE.MirroredRepeatWrapping:
	
						if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {
	
							uv.y = Math.ceil( uv.y ) - uv.y;
	
						} else {
	
							uv.y = uv.y - Math.floor( uv.y );
	
						}
						break;
	
				}
	
			}
	
			if ( this.flipY ) {
	
				uv.y = 1 - uv.y;
	
			}
	
		}
	
	};
	
	THREE.EventDispatcher.prototype.apply( THREE.Texture.prototype );
	
	THREE.TextureIdCount = 0;
	
	// File:src/textures/CanvasTexture.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.CanvasTexture = function ( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {
	
		THREE.Texture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );
	
		this.needsUpdate = true;
	
	};
	
	THREE.CanvasTexture.prototype = Object.create( THREE.Texture.prototype );
	THREE.CanvasTexture.prototype.constructor = THREE.CanvasTexture;
	
	// File:src/textures/CubeTexture.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.CubeTexture = function ( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {
	
		mapping = mapping !== undefined ? mapping : THREE.CubeReflectionMapping;
	
		THREE.Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );
	
		this.images = images;
		this.flipY = false;
	
	};
	
	THREE.CubeTexture.prototype = Object.create( THREE.Texture.prototype );
	THREE.CubeTexture.prototype.constructor = THREE.CubeTexture;
	
	THREE.CubeTexture.prototype.copy = function ( source ) {
	
		THREE.Texture.prototype.copy.call( this, source );
	
		this.images = source.images;
	
		return this;
	
	};
	
	// File:src/textures/CompressedTexture.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.CompressedTexture = function ( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {
	
		THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );
	
		this.image = { width: width, height: height };
		this.mipmaps = mipmaps;
	
		// no flipping for cube textures
		// (also flipping doesn't work for compressed textures )
	
		this.flipY = false;
	
		// can't generate mipmaps for compressed textures
		// mips must be embedded in DDS files
	
		this.generateMipmaps = false;
	
	};
	
	THREE.CompressedTexture.prototype = Object.create( THREE.Texture.prototype );
	THREE.CompressedTexture.prototype.constructor = THREE.CompressedTexture;
	
	// File:src/textures/DataTexture.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.DataTexture = function ( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {
	
		THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );
	
		this.image = { data: data, width: width, height: height };
	
		this.magFilter = magFilter !== undefined ? magFilter : THREE.NearestFilter;
		this.minFilter = minFilter !== undefined ? minFilter : THREE.NearestFilter;
		
		this.flipY = false;
		this.generateMipmaps  = false;
	
	};
	
	THREE.DataTexture.prototype = Object.create( THREE.Texture.prototype );
	THREE.DataTexture.prototype.constructor = THREE.DataTexture;
	
	// File:src/textures/VideoTexture.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.VideoTexture = function ( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {
	
		THREE.Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );
	
		this.generateMipmaps = false;
	
		var scope = this;
	
		function update() {
	
			requestAnimationFrame( update );
	
			if ( video.readyState === video.HAVE_ENOUGH_DATA ) {
	
				scope.needsUpdate = true;
	
			}
	
		}
	
		update();
	
	};
	
	THREE.VideoTexture.prototype = Object.create( THREE.Texture.prototype );
	THREE.VideoTexture.prototype.constructor = THREE.VideoTexture;
	
	// File:src/objects/Group.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.Group = function () {
	
		THREE.Object3D.call( this );
	
		this.type = 'Group';
	
	};
	
	THREE.Group.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Group.prototype.constructor = THREE.Group;
	// File:src/objects/Points.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.Points = function ( geometry, material ) {
	
		THREE.Object3D.call( this );
	
		this.type = 'Points';
	
		this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
		this.material = material !== undefined ? material : new THREE.PointsMaterial( { color: Math.random() * 0xffffff } );
	
	};
	
	THREE.Points.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Points.prototype.constructor = THREE.Points;
	
	THREE.Points.prototype.raycast = ( function () {
	
		var inverseMatrix = new THREE.Matrix4();
		var ray = new THREE.Ray();
		var sphere = new THREE.Sphere();
	
		return function raycast( raycaster, intersects ) {
	
			var object = this;
			var geometry = this.geometry;
			var matrixWorld = this.matrixWorld;
			var threshold = raycaster.params.Points.threshold;
	
			// Checking boundingSphere distance to ray
	
			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();
	
			sphere.copy( geometry.boundingSphere );
			sphere.applyMatrix4( matrixWorld );
	
			if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;
	
			//
	
			inverseMatrix.getInverse( matrixWorld );
			ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );
	
			var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
			var localThresholdSq = localThreshold * localThreshold;
			var position = new THREE.Vector3();
	
			function testPoint( point, index ) {
	
				var rayPointDistanceSq = ray.distanceSqToPoint( point );
	
				if ( rayPointDistanceSq < localThresholdSq ) {
	
					var intersectPoint = ray.closestPointToPoint( point );
					intersectPoint.applyMatrix4( matrixWorld );
	
					var distance = raycaster.ray.origin.distanceTo( intersectPoint );
	
					if ( distance < raycaster.near || distance > raycaster.far ) return;
	
					intersects.push( {
	
						distance: distance,
						distanceToRay: Math.sqrt( rayPointDistanceSq ),
						point: intersectPoint.clone(),
						index: index,
						face: null,
						object: object
	
					} );
	
				}
	
			}
	
			if ( geometry instanceof THREE.BufferGeometry ) {
	
				var index = geometry.index;
				var attributes = geometry.attributes;
				var positions = attributes.position.array;
	
				if ( index !== null ) {
	
					var indices = index.array;
	
					for ( var i = 0, il = indices.length; i < il; i ++ ) {
	
						var a = indices[ i ];
	
						position.fromArray( positions, a * 3 );
	
						testPoint( position, a );
	
					}
	
				} else {
	
					for ( var i = 0, l = positions.length / 3; i < l; i ++ ) {
	
						position.fromArray( positions, i * 3 );
	
						testPoint( position, i );
	
					}
	
				}
	
			} else {
	
				var vertices = geometry.vertices;
	
				for ( var i = 0, l = vertices.length; i < l; i ++ ) {
	
					testPoint( vertices[ i ], i );
	
				}
	
			}
	
		};
	
	}() );
	
	THREE.Points.prototype.clone = function () {
	
		return new this.constructor( this.geometry, this.material ).copy( this );
	
	};
	
	// File:src/objects/Line.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.Line = function ( geometry, material, mode ) {
	
		if ( mode === 1 ) {
	
			console.warn( 'THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.' );
			return new THREE.LineSegments( geometry, material );
	
		}
	
		THREE.Object3D.call( this );
	
		this.type = 'Line';
	
		this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
		this.material = material !== undefined ? material : new THREE.LineBasicMaterial( { color: Math.random() * 0xffffff } );
	
	};
	
	THREE.Line.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Line.prototype.constructor = THREE.Line;
	
	THREE.Line.prototype.raycast = ( function () {
	
		var inverseMatrix = new THREE.Matrix4();
		var ray = new THREE.Ray();
		var sphere = new THREE.Sphere();
	
		return function raycast( raycaster, intersects ) {
	
			var precision = raycaster.linePrecision;
			var precisionSq = precision * precision;
	
			var geometry = this.geometry;
			var matrixWorld = this.matrixWorld;
	
			// Checking boundingSphere distance to ray
	
			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();
	
			sphere.copy( geometry.boundingSphere );
			sphere.applyMatrix4( matrixWorld );
	
			if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;
	
			//
	
			inverseMatrix.getInverse( matrixWorld );
			ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );
	
			var vStart = new THREE.Vector3();
			var vEnd = new THREE.Vector3();
			var interSegment = new THREE.Vector3();
			var interRay = new THREE.Vector3();
			var step = this instanceof THREE.LineSegments ? 2 : 1;
	
			if ( geometry instanceof THREE.BufferGeometry ) {
	
				var index = geometry.index;
				var attributes = geometry.attributes;
				var positions = attributes.position.array;
	
				if ( index !== null ) {
	
					var indices = index.array;
	
					for ( var i = 0, l = indices.length - 1; i < l; i += step ) {
	
						var a = indices[ i ];
						var b = indices[ i + 1 ];
	
						vStart.fromArray( positions, a * 3 );
						vEnd.fromArray( positions, b * 3 );
	
						var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );
	
						if ( distSq > precisionSq ) continue;
	
						interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation
	
						var distance = raycaster.ray.origin.distanceTo( interRay );
	
						if ( distance < raycaster.near || distance > raycaster.far ) continue;
	
						intersects.push( {
	
							distance: distance,
							// What do we want? intersection point on the ray or on the segment??
							// point: raycaster.ray.at( distance ),
							point: interSegment.clone().applyMatrix4( this.matrixWorld ),
							index: i,
							face: null,
							faceIndex: null,
							object: this
	
						} );
	
					}
	
				} else {
	
					for ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {
	
						vStart.fromArray( positions, 3 * i );
						vEnd.fromArray( positions, 3 * i + 3 );
	
						var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );
	
						if ( distSq > precisionSq ) continue;
	
						interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation
	
						var distance = raycaster.ray.origin.distanceTo( interRay );
	
						if ( distance < raycaster.near || distance > raycaster.far ) continue;
	
						intersects.push( {
	
							distance: distance,
							// What do we want? intersection point on the ray or on the segment??
							// point: raycaster.ray.at( distance ),
							point: interSegment.clone().applyMatrix4( this.matrixWorld ),
							index: i,
							face: null,
							faceIndex: null,
							object: this
	
						} );
	
					}
	
				}
	
			} else if ( geometry instanceof THREE.Geometry ) {
	
				var vertices = geometry.vertices;
				var nbVertices = vertices.length;
	
				for ( var i = 0; i < nbVertices - 1; i += step ) {
	
					var distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );
	
					if ( distSq > precisionSq ) continue;
	
					interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation
	
					var distance = raycaster.ray.origin.distanceTo( interRay );
	
					if ( distance < raycaster.near || distance > raycaster.far ) continue;
	
					intersects.push( {
	
						distance: distance,
						// What do we want? intersection point on the ray or on the segment??
						// point: raycaster.ray.at( distance ),
						point: interSegment.clone().applyMatrix4( this.matrixWorld ),
						index: i,
						face: null,
						faceIndex: null,
						object: this
	
					} );
	
				}
	
			}
	
		};
	
	}() );
	
	THREE.Line.prototype.clone = function () {
	
		return new this.constructor( this.geometry, this.material ).copy( this );
	
	};
	
	// DEPRECATED
	
	THREE.LineStrip = 0;
	THREE.LinePieces = 1;
	
	// File:src/objects/LineSegments.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.LineSegments = function ( geometry, material ) {
	
		THREE.Line.call( this, geometry, material );
	
		this.type = 'LineSegments';
	
	};
	
	THREE.LineSegments.prototype = Object.create( THREE.Line.prototype );
	THREE.LineSegments.prototype.constructor = THREE.LineSegments;
	
	// File:src/objects/Mesh.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author jonobr1 / http://jonobr1.com/
	 */
	
	THREE.Mesh = function ( geometry, material ) {
	
		THREE.Object3D.call( this );
	
		this.type = 'Mesh';
	
		this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
		this.material = material !== undefined ? material : new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff } );
	
		this.drawMode = THREE.TrianglesDrawMode;
	
		this.updateMorphTargets();
	
	};
	
	THREE.Mesh.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Mesh.prototype.constructor = THREE.Mesh;
	
	THREE.Mesh.prototype.setDrawMode = function ( value ) {
	
		this.drawMode = value;
	
	};
	
	THREE.Mesh.prototype.updateMorphTargets = function () {
	
		if ( this.geometry.morphTargets !== undefined && this.geometry.morphTargets.length > 0 ) {
	
			this.morphTargetBase = - 1;
			this.morphTargetInfluences = [];
			this.morphTargetDictionary = {};
	
			for ( var m = 0, ml = this.geometry.morphTargets.length; m < ml; m ++ ) {
	
				this.morphTargetInfluences.push( 0 );
				this.morphTargetDictionary[ this.geometry.morphTargets[ m ].name ] = m;
	
			}
	
		}
	
	};
	
	THREE.Mesh.prototype.getMorphTargetIndexByName = function ( name ) {
	
		if ( this.morphTargetDictionary[ name ] !== undefined ) {
	
			return this.morphTargetDictionary[ name ];
	
		}
	
		console.warn( 'THREE.Mesh.getMorphTargetIndexByName: morph target ' + name + ' does not exist. Returning 0.' );
	
		return 0;
	
	};
	
	
	THREE.Mesh.prototype.raycast = ( function () {
	
		var inverseMatrix = new THREE.Matrix4();
		var ray = new THREE.Ray();
		var sphere = new THREE.Sphere();
	
		var vA = new THREE.Vector3();
		var vB = new THREE.Vector3();
		var vC = new THREE.Vector3();
	
		var tempA = new THREE.Vector3();
		var tempB = new THREE.Vector3();
		var tempC = new THREE.Vector3();
	
		var uvA = new THREE.Vector2();
		var uvB = new THREE.Vector2();
		var uvC = new THREE.Vector2();
	
		var barycoord = new THREE.Vector3();
	
		var intersectionPoint = new THREE.Vector3();
		var intersectionPointWorld = new THREE.Vector3();
	
		function uvIntersection( point, p1, p2, p3, uv1, uv2, uv3 ) {
	
			THREE.Triangle.barycoordFromPoint( point, p1, p2, p3, barycoord );
	
			uv1.multiplyScalar( barycoord.x );
			uv2.multiplyScalar( barycoord.y );
			uv3.multiplyScalar( barycoord.z );
	
			uv1.add( uv2 ).add( uv3 );
	
			return uv1.clone();
	
		}
	
		function checkIntersection( object, raycaster, ray, pA, pB, pC, point ) {
	
			var intersect;
			var material = object.material;
	
			if ( material.side === THREE.BackSide ) {
	
				intersect = ray.intersectTriangle( pC, pB, pA, true, point );
	
			} else {
	
				intersect = ray.intersectTriangle( pA, pB, pC, material.side !== THREE.DoubleSide, point );
	
			}
	
			if ( intersect === null ) return null;
	
			intersectionPointWorld.copy( point );
			intersectionPointWorld.applyMatrix4( object.matrixWorld );
	
			var distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );
	
			if ( distance < raycaster.near || distance > raycaster.far ) return null;
	
			return {
				distance: distance,
				point: intersectionPointWorld.clone(),
				object: object
			};
	
		}
	
		function checkBufferGeometryIntersection( object, raycaster, ray, positions, uvs, a, b, c ) {
	
			vA.fromArray( positions, a * 3 );
			vB.fromArray( positions, b * 3 );
			vC.fromArray( positions, c * 3 );
	
			var intersection = checkIntersection( object, raycaster, ray, vA, vB, vC, intersectionPoint );
	
			if ( intersection ) {
	
				if ( uvs ) {
	
					uvA.fromArray( uvs, a * 2 );
					uvB.fromArray( uvs, b * 2 );
					uvC.fromArray( uvs, c * 2 );
	
					intersection.uv = uvIntersection( intersectionPoint,  vA, vB, vC,  uvA, uvB, uvC );
	
				}
	
				intersection.face = new THREE.Face3( a, b, c, THREE.Triangle.normal( vA, vB, vC ) );
				intersection.faceIndex = a;
	
			}
	
			return intersection;
	
		}
	
		return function raycast( raycaster, intersects ) {
	
			var geometry = this.geometry;
			var material = this.material;
			var matrixWorld = this.matrixWorld;
	
			if ( material === undefined ) return;
	
			// Checking boundingSphere distance to ray
	
			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();
	
			sphere.copy( geometry.boundingSphere );
			sphere.applyMatrix4( matrixWorld );
	
			if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;
	
			//
	
			inverseMatrix.getInverse( matrixWorld );
			ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );
	
			// Check boundingBox before continuing
	
			if ( geometry.boundingBox !== null ) {
	
				if ( ray.intersectsBox( geometry.boundingBox ) === false ) return;
	
			}
	
			var uvs, intersection;
	
			if ( geometry instanceof THREE.BufferGeometry ) {
	
				var a, b, c;
				var index = geometry.index;
				var attributes = geometry.attributes;
				var positions = attributes.position.array;
	
				if ( attributes.uv !== undefined ) {
	
					uvs = attributes.uv.array;
	
				}
	
				if ( index !== null ) {
	
					var indices = index.array;
	
					for ( var i = 0, l = indices.length; i < l; i += 3 ) {
	
						a = indices[ i ];
						b = indices[ i + 1 ];
						c = indices[ i + 2 ];
	
						intersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );
	
						if ( intersection ) {
	
							intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indices buffer semantics
							intersects.push( intersection );
	
						}
	
					}
	
				} else {
	
	
					for ( var i = 0, l = positions.length; i < l; i += 9 ) {
	
						a = i / 3;
						b = a + 1;
						c = a + 2;
	
						intersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );
	
						if ( intersection ) {
	
							intersection.index = a; // triangle number in positions buffer semantics
							intersects.push( intersection );
	
						}
	
					}
	
				}
	
			} else if ( geometry instanceof THREE.Geometry ) {
	
				var fvA, fvB, fvC;
				var isFaceMaterial = material instanceof THREE.MultiMaterial;
				var materials = isFaceMaterial === true ? material.materials : null;
	
				var vertices = geometry.vertices;
				var faces = geometry.faces;
				var faceVertexUvs = geometry.faceVertexUvs[ 0 ];
				if ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;
	
				for ( var f = 0, fl = faces.length; f < fl; f ++ ) {
	
					var face = faces[ f ];
					var faceMaterial = isFaceMaterial === true ? materials[ face.materialIndex ] : material;
	
					if ( faceMaterial === undefined ) continue;
	
					fvA = vertices[ face.a ];
					fvB = vertices[ face.b ];
					fvC = vertices[ face.c ];
	
					if ( faceMaterial.morphTargets === true ) {
	
						var morphTargets = geometry.morphTargets;
						var morphInfluences = this.morphTargetInfluences;
	
						vA.set( 0, 0, 0 );
						vB.set( 0, 0, 0 );
						vC.set( 0, 0, 0 );
	
						for ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {
	
							var influence = morphInfluences[ t ];
	
							if ( influence === 0 ) continue;
	
							var targets = morphTargets[ t ].vertices;
	
							vA.addScaledVector( tempA.subVectors( targets[ face.a ], fvA ), influence );
							vB.addScaledVector( tempB.subVectors( targets[ face.b ], fvB ), influence );
							vC.addScaledVector( tempC.subVectors( targets[ face.c ], fvC ), influence );
	
						}
	
						vA.add( fvA );
						vB.add( fvB );
						vC.add( fvC );
	
						fvA = vA;
						fvB = vB;
						fvC = vC;
	
					}
	
					intersection = checkIntersection( this, raycaster, ray, fvA, fvB, fvC, intersectionPoint );
	
					if ( intersection ) {
	
						if ( uvs ) {
	
							var uvs_f = uvs[ f ];
							uvA.copy( uvs_f[ 0 ] );
							uvB.copy( uvs_f[ 1 ] );
							uvC.copy( uvs_f[ 2 ] );
	
							intersection.uv = uvIntersection( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC );
	
						}
	
						intersection.face = face;
						intersection.faceIndex = f;
						intersects.push( intersection );
	
					}
	
				}
	
			}
	
		};
	
	}() );
	
	THREE.Mesh.prototype.clone = function () {
	
		return new this.constructor( this.geometry, this.material ).copy( this );
	
	};
	
	// File:src/objects/Bone.js
	
	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author ikerr / http://verold.com
	 */
	
	THREE.Bone = function ( skin ) {
	
		THREE.Object3D.call( this );
	
		this.type = 'Bone';
	
		this.skin = skin;
	
	};
	
	THREE.Bone.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Bone.prototype.constructor = THREE.Bone;
	
	THREE.Bone.prototype.copy = function ( source ) {
		
		THREE.Object3D.prototype.copy.call( this, source );
		
		this.skin = source.skin;
		
		return this;
	
	};
	
	// File:src/objects/Skeleton.js
	
	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author michael guerrero / http://realitymeltdown.com
	 * @author ikerr / http://verold.com
	 */
	
	THREE.Skeleton = function ( bones, boneInverses, useVertexTexture ) {
	
		this.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;
	
		this.identityMatrix = new THREE.Matrix4();
	
		// copy the bone array
	
		bones = bones || [];
	
		this.bones = bones.slice( 0 );
	
		// create a bone texture or an array of floats
	
		if ( this.useVertexTexture ) {
	
			// layout (1 matrix = 4 pixels)
			//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
			//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
			//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
			//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
			//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)
	
			
			var size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix
			size = THREE.Math.nextPowerOfTwo( Math.ceil( size ) );
			size = Math.max( size, 4 );
	
			this.boneTextureWidth = size;
			this.boneTextureHeight = size;
	
			this.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel
			this.boneTexture = new THREE.DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType );
	
		} else {
	
			this.boneMatrices = new Float32Array( 16 * this.bones.length );
	
		}
	
		// use the supplied bone inverses or calculate the inverses
	
		if ( boneInverses === undefined ) {
	
			this.calculateInverses();
	
		} else {
	
			if ( this.bones.length === boneInverses.length ) {
	
				this.boneInverses = boneInverses.slice( 0 );
	
			} else {
	
				console.warn( 'THREE.Skeleton bonInverses is the wrong length.' );
	
				this.boneInverses = [];
	
				for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {
	
					this.boneInverses.push( new THREE.Matrix4() );
	
				}
	
			}
	
		}
	
	};
	
	THREE.Skeleton.prototype.calculateInverses = function () {
	
		this.boneInverses = [];
	
		for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {
	
			var inverse = new THREE.Matrix4();
	
			if ( this.bones[ b ] ) {
	
				inverse.getInverse( this.bones[ b ].matrixWorld );
	
			}
	
			this.boneInverses.push( inverse );
	
		}
	
	};
	
	THREE.Skeleton.prototype.pose = function () {
	
		var bone;
	
		// recover the bind-time world matrices
	
		for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {
	
			bone = this.bones[ b ];
	
			if ( bone ) {
	
				bone.matrixWorld.getInverse( this.boneInverses[ b ] );
	
			}
	
		}
	
		// compute the local matrices, positions, rotations and scales
	
		for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {
	
			bone = this.bones[ b ];
	
			if ( bone ) {
	
				if ( bone.parent ) {
	
					bone.matrix.getInverse( bone.parent.matrixWorld );
					bone.matrix.multiply( bone.matrixWorld );
	
				} else {
	
					bone.matrix.copy( bone.matrixWorld );
	
				}
	
				bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );
	
			}
	
		}
	
	};
	
	THREE.Skeleton.prototype.update = ( function () {
	
		var offsetMatrix = new THREE.Matrix4();
	
		return function update() {
	
			// flatten bone matrices to array
	
			for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {
	
				// compute the offset between the current and the original transform
	
				var matrix = this.bones[ b ] ? this.bones[ b ].matrixWorld : this.identityMatrix;
	
				offsetMatrix.multiplyMatrices( matrix, this.boneInverses[ b ] );
				offsetMatrix.flattenToArrayOffset( this.boneMatrices, b * 16 );
	
			}
	
			if ( this.useVertexTexture ) {
	
				this.boneTexture.needsUpdate = true;
	
			}
	
		};
	
	} )();
	
	THREE.Skeleton.prototype.clone = function () {
	
		return new THREE.Skeleton( this.bones, this.boneInverses, this.useVertexTexture );
	
	};
	
	// File:src/objects/SkinnedMesh.js
	
	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author ikerr / http://verold.com
	 */
	
	THREE.SkinnedMesh = function ( geometry, material, useVertexTexture ) {
	
		THREE.Mesh.call( this, geometry, material );
	
		this.type = 'SkinnedMesh';
	
		this.bindMode = "attached";
		this.bindMatrix = new THREE.Matrix4();
		this.bindMatrixInverse = new THREE.Matrix4();
	
		// init bones
	
		// TODO: remove bone creation as there is no reason (other than
		// convenience) for THREE.SkinnedMesh to do this.
	
		var bones = [];
	
		if ( this.geometry && this.geometry.bones !== undefined ) {
	
			var bone, gbone;
	
			for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {
	
				gbone = this.geometry.bones[ b ];
	
				bone = new THREE.Bone( this );
				bones.push( bone );
	
				bone.name = gbone.name;
				bone.position.fromArray( gbone.pos );
				bone.quaternion.fromArray( gbone.rotq );
				if ( gbone.scl !== undefined ) bone.scale.fromArray( gbone.scl );
	
			}
	
			for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {
	
				gbone = this.geometry.bones[ b ];
	
				if ( gbone.parent !== - 1 && gbone.parent !== null ) {
	
					bones[ gbone.parent ].add( bones[ b ] );
	
				} else {
	
					this.add( bones[ b ] );
	
				}
	
			}
	
		}
	
		this.normalizeSkinWeights();
	
		this.updateMatrixWorld( true );
		this.bind( new THREE.Skeleton( bones, undefined, useVertexTexture ), this.matrixWorld );
	
	};
	
	
	THREE.SkinnedMesh.prototype = Object.create( THREE.Mesh.prototype );
	THREE.SkinnedMesh.prototype.constructor = THREE.SkinnedMesh;
	
	THREE.SkinnedMesh.prototype.bind = function( skeleton, bindMatrix ) {
	
		this.skeleton = skeleton;
	
		if ( bindMatrix === undefined ) {
	
			this.updateMatrixWorld( true );
	
			this.skeleton.calculateInverses();
	
			bindMatrix = this.matrixWorld;
	
		}
	
		this.bindMatrix.copy( bindMatrix );
		this.bindMatrixInverse.getInverse( bindMatrix );
	
	};
	
	THREE.SkinnedMesh.prototype.pose = function () {
	
		this.skeleton.pose();
	
	};
	
	THREE.SkinnedMesh.prototype.normalizeSkinWeights = function () {
	
		if ( this.geometry instanceof THREE.Geometry ) {
	
			for ( var i = 0; i < this.geometry.skinWeights.length; i ++ ) {
	
				var sw = this.geometry.skinWeights[ i ];
	
				var scale = 1.0 / sw.lengthManhattan();
	
				if ( scale !== Infinity ) {
	
					sw.multiplyScalar( scale );
	
				} else {
	
					sw.set( 1, 0, 0, 0 ); // do something reasonable
	
				}
	
			}
	
		} else if ( this.geometry instanceof THREE.BufferGeometry ) {
	
			var vec = new THREE.Vector4();
	
			var skinWeight = this.geometry.attributes.skinWeight;
	
			for ( var i = 0; i < skinWeight.count; i ++ ) {
	
				vec.x = skinWeight.getX( i );
				vec.y = skinWeight.getY( i );
				vec.z = skinWeight.getZ( i );
				vec.w = skinWeight.getW( i );
	
				var scale = 1.0 / vec.lengthManhattan();
	
				if ( scale !== Infinity ) {
	
					vec.multiplyScalar( scale );
	
				} else {
	
					vec.set( 1, 0, 0, 0 ); // do something reasonable
	
				}
	
				skinWeight.setXYZW( i, vec.x, vec.y, vec.z, vec.w );
	
			}
	
		}
	
	};
	
	THREE.SkinnedMesh.prototype.updateMatrixWorld = function( force ) {
	
		THREE.Mesh.prototype.updateMatrixWorld.call( this, true );
	
		if ( this.bindMode === "attached" ) {
	
			this.bindMatrixInverse.getInverse( this.matrixWorld );
	
		} else if ( this.bindMode === "detached" ) {
	
			this.bindMatrixInverse.getInverse( this.bindMatrix );
	
		} else {
	
			console.warn( 'THREE.SkinnedMesh unrecognized bindMode: ' + this.bindMode );
	
		}
	
	};
	
	THREE.SkinnedMesh.prototype.clone = function() {
	
		return new this.constructor( this.geometry, this.material, this.useVertexTexture ).copy( this );
	
	};
	
	// File:src/objects/LOD.js
	
	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.LOD = function () {
	
		THREE.Object3D.call( this );
	
		this.type = 'LOD';
	
		Object.defineProperties( this, {
			levels: {
				enumerable: true,
				value: []
			},
			objects: {
				get: function () {
	
					console.warn( 'THREE.LOD: .objects has been renamed to .levels.' );
					return this.levels;
	
				}
			}
		} );
	
	};
	
	
	THREE.LOD.prototype = Object.create( THREE.Object3D.prototype );
	THREE.LOD.prototype.constructor = THREE.LOD;
	
	THREE.LOD.prototype.addLevel = function ( object, distance ) {
	
		if ( distance === undefined ) distance = 0;
	
		distance = Math.abs( distance );
	
		var levels = this.levels;
	
		for ( var l = 0; l < levels.length; l ++ ) {
	
			if ( distance < levels[ l ].distance ) {
	
				break;
	
			}
	
		}
	
		levels.splice( l, 0, { distance: distance, object: object } );
	
		this.add( object );
	
	};
	
	THREE.LOD.prototype.getObjectForDistance = function ( distance ) {
	
		var levels = this.levels;
	
		for ( var i = 1, l = levels.length; i < l; i ++ ) {
	
			if ( distance < levels[ i ].distance ) {
	
				break;
	
			}
	
		}
	
		return levels[ i - 1 ].object;
	
	};
	
	THREE.LOD.prototype.raycast = ( function () {
	
		var matrixPosition = new THREE.Vector3();
	
		return function raycast( raycaster, intersects ) {
	
			matrixPosition.setFromMatrixPosition( this.matrixWorld );
	
			var distance = raycaster.ray.origin.distanceTo( matrixPosition );
	
			this.getObjectForDistance( distance ).raycast( raycaster, intersects );
	
		};
	
	}() );
	
	THREE.LOD.prototype.update = function () {
	
		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();
	
		return function update( camera ) {
	
			var levels = this.levels;
	
			if ( levels.length > 1 ) {
	
				v1.setFromMatrixPosition( camera.matrixWorld );
				v2.setFromMatrixPosition( this.matrixWorld );
	
				var distance = v1.distanceTo( v2 );
	
				levels[ 0 ].object.visible = true;
	
				for ( var i = 1, l = levels.length; i < l; i ++ ) {
	
					if ( distance >= levels[ i ].distance ) {
	
						levels[ i - 1 ].object.visible = false;
						levels[ i ].object.visible = true;
	
					} else {
	
						break;
	
					}
	
				}
	
				for ( ; i < l; i ++ ) {
	
					levels[ i ].object.visible = false;
	
				}
	
			}
	
		};
	
	}();
	
	THREE.LOD.prototype.copy = function ( source ) {
	
		THREE.Object3D.prototype.copy.call( this, source, false );
	
		var levels = source.levels;
	
		for ( var i = 0, l = levels.length; i < l; i ++ ) {
	
			var level = levels[ i ];
	
			this.addLevel( level.object.clone(), level.distance );
	
		}
	
		return this;
	
	};
	
	THREE.LOD.prototype.toJSON = function ( meta ) {
	
		var data = THREE.Object3D.prototype.toJSON.call( this, meta );
	
		data.object.levels = [];
	
		var levels = this.levels;
	
		for ( var i = 0, l = levels.length; i < l; i ++ ) {
	
			var level = levels[ i ];
	
			data.object.levels.push( {
				object: level.object.uuid,
				distance: level.distance
			} );
	
		}
	
		return data;
	
	};
	
	// File:src/objects/Sprite.js
	
	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.Sprite = ( function () {
	
		var indices = new Uint16Array( [ 0, 1, 2,  0, 2, 3 ] );
		var vertices = new Float32Array( [ - 0.5, - 0.5, 0,   0.5, - 0.5, 0,   0.5, 0.5, 0,   - 0.5, 0.5, 0 ] );
		var uvs = new Float32Array( [ 0, 0,   1, 0,   1, 1,   0, 1 ] );
	
		var geometry = new THREE.BufferGeometry();
		geometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );
		geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
		geometry.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );
	
		return function Sprite( material ) {
	
			THREE.Object3D.call( this );
	
			this.type = 'Sprite';
	
			this.geometry = geometry;
			this.material = ( material !== undefined ) ? material : new THREE.SpriteMaterial();
	
		};
	
	} )();
	
	THREE.Sprite.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Sprite.prototype.constructor = THREE.Sprite;
	
	THREE.Sprite.prototype.raycast = ( function () {
	
		var matrixPosition = new THREE.Vector3();
	
		return function raycast( raycaster, intersects ) {
	
			matrixPosition.setFromMatrixPosition( this.matrixWorld );
	
			var distanceSq = raycaster.ray.distanceSqToPoint( matrixPosition );
			var guessSizeSq = this.scale.x * this.scale.y;
	
			if ( distanceSq > guessSizeSq ) {
	
				return;
	
			}
	
			intersects.push( {
	
				distance: Math.sqrt( distanceSq ),
				point: this.position,
				face: null,
				object: this
	
			} );
	
		};
	
	}() );
	
	THREE.Sprite.prototype.clone = function () {
	
		return new this.constructor( this.material ).copy( this );
	
	};
	
	// Backwards compatibility
	
	THREE.Particle = THREE.Sprite;
	
	// File:src/objects/LensFlare.js
	
	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.LensFlare = function ( texture, size, distance, blending, color ) {
	
		THREE.Object3D.call( this );
	
		this.lensFlares = [];
	
		this.positionScreen = new THREE.Vector3();
		this.customUpdateCallback = undefined;
	
		if ( texture !== undefined ) {
	
			this.add( texture, size, distance, blending, color );
	
		}
	
	};
	
	THREE.LensFlare.prototype = Object.create( THREE.Object3D.prototype );
	THREE.LensFlare.prototype.constructor = THREE.LensFlare;
	
	
	/*
	 * Add: adds another flare
	 */
	
	THREE.LensFlare.prototype.add = function ( texture, size, distance, blending, color, opacity ) {
	
		if ( size === undefined ) size = - 1;
		if ( distance === undefined ) distance = 0;
		if ( opacity === undefined ) opacity = 1;
		if ( color === undefined ) color = new THREE.Color( 0xffffff );
		if ( blending === undefined ) blending = THREE.NormalBlending;
	
		distance = Math.min( distance, Math.max( 0, distance ) );
	
		this.lensFlares.push( {
			texture: texture,	// THREE.Texture
			size: size, 		// size in pixels (-1 = use texture.width)
			distance: distance, 	// distance (0-1) from light source (0=at light source)
			x: 0, y: 0, z: 0,	// screen position (-1 => 1) z = 0 is in front z = 1 is back
			scale: 1, 		// scale
			rotation: 0, 		// rotation
			opacity: opacity,	// opacity
			color: color,		// color
			blending: blending	// blending
		} );
	
	};
	
	/*
	 * Update lens flares update positions on all flares based on the screen position
	 * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.
	 */
	
	THREE.LensFlare.prototype.updateLensFlares = function () {
	
		var f, fl = this.lensFlares.length;
		var flare;
		var vecX = - this.positionScreen.x * 2;
		var vecY = - this.positionScreen.y * 2;
	
		for ( f = 0; f < fl; f ++ ) {
	
			flare = this.lensFlares[ f ];
	
			flare.x = this.positionScreen.x + vecX * flare.distance;
			flare.y = this.positionScreen.y + vecY * flare.distance;
	
			flare.wantedRotation = flare.x * Math.PI * 0.25;
			flare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;
	
		}
	
	};
	
	THREE.LensFlare.prototype.copy = function ( source ) {
	
		THREE.Object3D.prototype.copy.call( this, source );
	
		this.positionScreen.copy( source.positionScreen );
		this.customUpdateCallback = source.customUpdateCallback;
	
		for ( var i = 0, l = source.lensFlares.length; i < l; i ++ ) {
	
			this.lensFlares.push( source.lensFlares[ i ] );
	
		}
	
		return this;
	
	};
	
	// File:src/scenes/Scene.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.Scene = function () {
	
		THREE.Object3D.call( this );
	
		this.type = 'Scene';
	
		this.fog = null;
		this.overrideMaterial = null;
	
		this.autoUpdate = true; // checked by the renderer
	
	};
	
	THREE.Scene.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Scene.prototype.constructor = THREE.Scene;
	
	THREE.Scene.prototype.copy = function ( source ) {
	
		THREE.Object3D.prototype.copy.call( this, source );
	
		if ( source.fog !== null ) this.fog = source.fog.clone();
		if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();
	
		this.autoUpdate = source.autoUpdate;
		this.matrixAutoUpdate = source.matrixAutoUpdate;
	
		return this;
	
	};
	
	// File:src/scenes/Fog.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.Fog = function ( color, near, far ) {
	
		this.name = '';
	
		this.color = new THREE.Color( color );
	
		this.near = ( near !== undefined ) ? near : 1;
		this.far = ( far !== undefined ) ? far : 1000;
	
	};
	
	THREE.Fog.prototype.clone = function () {
	
		return new THREE.Fog( this.color.getHex(), this.near, this.far );
	
	};
	
	// File:src/scenes/FogExp2.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.FogExp2 = function ( color, density ) {
	
		this.name = '';
	
		this.color = new THREE.Color( color );
		this.density = ( density !== undefined ) ? density : 0.00025;
	
	};
	
	THREE.FogExp2.prototype.clone = function () {
	
		return new THREE.FogExp2( this.color.getHex(), this.density );
	
	};
	
	// File:src/renderers/shaders/ShaderChunk.js
	
	THREE.ShaderChunk = {};
	
	// File:src/renderers/shaders/ShaderChunk/alphamap_fragment.glsl
	
	THREE.ShaderChunk[ 'alphamap_fragment' ] = "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/alphamap_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'alphamap_pars_fragment' ] = "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/alphatest_fragment.glsl
	
	THREE.ShaderChunk[ 'alphatest_fragment' ] = "#ifdef ALPHATEST\n	if ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/ambient_pars.glsl
	
	THREE.ShaderChunk[ 'ambient_pars' ] = "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	return PI * ambientLightColor;\n}\n";
	
	// File:src/renderers/shaders/ShaderChunk/aomap_fragment.glsl
	
	THREE.ShaderChunk[ 'aomap_fragment' ] = "#ifdef USE_AOMAP\n	reflectedLight.indirectDiffuse *= ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/aomap_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'aomap_pars_fragment' ] = "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/begin_vertex.glsl
	
	THREE.ShaderChunk[ 'begin_vertex' ] = "\nvec3 transformed = vec3( position );\n";
	
	// File:src/renderers/shaders/ShaderChunk/beginnormal_vertex.glsl
	
	THREE.ShaderChunk[ 'beginnormal_vertex' ] = "\nvec3 objectNormal = vec3( normal );\n";
	
	// File:src/renderers/shaders/ShaderChunk/bsdfs.glsl
	
	THREE.ShaderChunk[ 'bsdfs' ] = "float calcLightAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n	if ( decayExponent > 0.0 ) {\n	  return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n	}\n	return 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n	return ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = alpha * alpha;\n	float gl = dotNL + pow( a2 + ( 1.0 - a2 ) * dotNL * dotNL, 0.5 );\n	float gv = dotNV + pow( a2 + ( 1.0 - a2 ) * dotNV * dotNV, 0.5 );\n	return 1.0 / ( gl * gv );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = alpha * alpha;\n	float denom = dotNH * dotNH * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / ( denom * denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n	float alpha = roughness * roughness;\n	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n	float dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n	float dotNH = saturate( dot( geometry.normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float G = G_GGX_Smith( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( G * D );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n	return specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n	float dotNH = saturate( dot( geometry.normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n	return ( 2.0 / square( ggxRoughness + 0.0001 ) - 2.0 );\n}";
	
	// File:src/renderers/shaders/ShaderChunk/bumpmap_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'bumpmap_pars_fragment' ] = "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n		vec3 vSigmaX = dFdx( surf_pos );\n		vec3 vSigmaY = dFdy( surf_pos );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 );\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/color_fragment.glsl
	
	THREE.ShaderChunk[ 'color_fragment' ] = "#ifdef USE_COLOR\n	diffuseColor.rgb *= vColor;\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/color_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'color_pars_fragment' ] = "#ifdef USE_COLOR\n	varying vec3 vColor;\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/color_pars_vertex.glsl
	
	THREE.ShaderChunk[ 'color_pars_vertex' ] = "#ifdef USE_COLOR\n	varying vec3 vColor;\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/color_vertex.glsl
	
	THREE.ShaderChunk[ 'color_vertex' ] = "#ifdef USE_COLOR\n	vColor.xyz = color.xyz;\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/common.glsl
	
	THREE.ShaderChunk[ 'common' ] = "#define PI 3.14159\n#define PI2 6.28318\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat square( const in float x ) { return x*x; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	float distance = dot( planeNormal, point - pointOnPlane );\n	return - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nvec3 inputToLinear( in vec3 a ) {\n	#ifdef GAMMA_INPUT\n		return pow( a, vec3( float( GAMMA_FACTOR ) ) );\n	#else\n		return a;\n	#endif\n}\nvec3 linearToOutput( in vec3 a ) {\n	#ifdef GAMMA_OUTPUT\n		return pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );\n	#else\n		return a;\n	#endif\n}\n";
	
	// File:src/renderers/shaders/ShaderChunk/defaultnormal_vertex.glsl
	
	THREE.ShaderChunk[ 'defaultnormal_vertex' ] = "#ifdef FLIP_SIDED\n	objectNormal = -objectNormal;\n#endif\nvec3 transformedNormal = normalMatrix * objectNormal;\n";
	
	// File:src/renderers/shaders/ShaderChunk/displacementmap_vertex.glsl
	
	THREE.ShaderChunk[ 'displacementmap_vertex' ] = "#ifdef USE_DISPLACEMENTMAP\n	transformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/displacementmap_pars_vertex.glsl
	
	THREE.ShaderChunk[ 'displacementmap_pars_vertex' ] = "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/emissivemap_fragment.glsl
	
	THREE.ShaderChunk[ 'emissivemap_fragment' ] = "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n	emissiveColor.rgb = inputToLinear( emissiveColor.rgb );\n	totalEmissiveLight *= emissiveColor.rgb;\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/emissivemap_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'emissivemap_pars_fragment' ] = "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/envmap_fragment.glsl
	
	THREE.ShaderChunk[ 'envmap_fragment' ] = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToVertex, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef DOUBLE_SIDED\n		float flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n	#else\n		float flipNormal = 1.0;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#elif defined( ENVMAP_TYPE_EQUIREC )\n		vec2 sampleUV;\n		sampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n		sampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n		vec4 envColor = texture2D( envMap, sampleUV );\n	#elif defined( ENVMAP_TYPE_SPHERE )\n		vec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\n		vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n	#endif\n	envColor.xyz = inputToLinear( envColor.xyz );\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/envmap_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'envmap_pars_fragment' ] = "#if defined( USE_ENVMAP ) || defined( STANDARD )\n	uniform float reflectivity;\n	uniform float envMapIntenstiy;\n#endif\n#ifdef USE_ENVMAP\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	uniform float flipEnvMap;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( STANDARD )\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/envmap_pars_vertex.glsl
	
	THREE.ShaderChunk[ 'envmap_pars_vertex' ] = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG ) && ! defined( STANDARD )\n	varying vec3 vReflect;\n	uniform float refractionRatio;\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/envmap_vertex.glsl
	
	THREE.ShaderChunk[ 'envmap_vertex' ] = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG ) && ! defined( STANDARD )\n	vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n	vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n	#ifdef ENVMAP_MODE_REFLECTION\n		vReflect = reflect( cameraToVertex, worldNormal );\n	#else\n		vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n	#endif\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/fog_fragment.glsl
	
	THREE.ShaderChunk[ 'fog_fragment' ] = "#ifdef USE_FOG\n	#ifdef USE_LOGDEPTHBUF_EXT\n		float depth = gl_FragDepthEXT / gl_FragCoord.w;\n	#else\n		float depth = gl_FragCoord.z / gl_FragCoord.w;\n	#endif\n	#ifdef FOG_EXP2\n		float fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, depth );\n	#endif\n	\n	outgoingLight = mix( outgoingLight, fogColor, fogFactor );\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/fog_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'fog_pars_fragment' ] = "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/lightmap_fragment.glsl
	
	THREE.ShaderChunk[ 'lightmap_fragment' ] = "#ifdef USE_LIGHTMAP\n	reflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/lightmap_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'lightmap_pars_fragment' ] = "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/lights_lambert_vertex.glsl
	
	THREE.ShaderChunk[ 'lights_lambert_vertex' ] = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n	vLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		directLight = getPointDirectLight( pointLights[ i ], geometry );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		directLight = getSpotDirectLight( spotLights[ i ], geometry );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n#endif\n#if NUM_DIR_LIGHTS > 0\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directLight = getDirectionalDirectLight( directionalLights[ i ], geometry );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n		vLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		#ifdef DOUBLE_SIDED\n			vLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n		#endif\n	}\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/lights_pars.glsl
	
	THREE.ShaderChunk[ 'lights_pars' ] = "#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n		int shadow;\n		float shadowBias;\n		float shadowRadius;\n		vec2 shadowMapSize;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	IncidentLight getDirectionalDirectLight( const in DirectionalLight directionalLight, const in GeometricContext geometry ) {\n		IncidentLight directLight;\n		directLight.color = directionalLight.color;\n		directLight.direction = directionalLight.direction;\n		return directLight;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n		int shadow;\n		float shadowBias;\n		float shadowRadius;\n		vec2 shadowMapSize;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	IncidentLight getPointDirectLight( const in PointLight pointLight, const in GeometricContext geometry ) {\n		IncidentLight directLight;\n		vec3 lVector = pointLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		directLight.color = pointLight.color;\n		directLight.color *= calcLightAttenuation( length( lVector ), pointLight.distance, pointLight.decay );\n		return directLight;\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float angleCos;\n		float exponent;\n		int shadow;\n		float shadowBias;\n		float shadowRadius;\n		vec2 shadowMapSize;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	IncidentLight getSpotDirectLight( const in SpotLight spotLight, const in GeometricContext geometry ) {\n		IncidentLight directLight;\n		vec3 lVector = spotLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float spotEffect = dot( directLight.direction, spotLight.direction );\n		if ( spotEffect > spotLight.angleCos ) {\n			float spotEffect = dot( spotLight.direction, directLight.direction );\n			spotEffect = saturate( pow( saturate( spotEffect ), spotLight.exponent ) );\n			directLight.color = spotLight.color;\n			directLight.color *= ( spotEffect * calcLightAttenuation( length( lVector ), spotLight.distance, spotLight.decay ) );\n		} else {\n			directLight.color = vec3( 0.0 );\n		}\n		return directLight;\n	}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n		float dotNL = dot( geometry.normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		return PI * mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n	}\n#endif\n#if defined( USE_ENVMAP ) && defined( STANDARD )\n	vec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n		#ifdef DOUBLE_SIDED\n			float flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n		#else\n			float flipNormal = 1.0;\n		#endif\n		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n			#endif\n		#else\n			vec3 envMapColor = vec3( 0.0 );\n		#endif\n		envMapColor.rgb = inputToLinear( envMapColor.rgb );\n		return PI * envMapColor.rgb * envMapIntensity;\n	}\n	float getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n		float maxMIPLevelScalar = float( maxMIPLevel );\n		float desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( square( blinnShininessExponent ) + 1.0 );\n		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n	}\n	vec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n		#else\n			vec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n		#endif\n		#ifdef DOUBLE_SIDED\n			float flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n		#else\n			float flipNormal = 1.0;\n		#endif\n		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n		float specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n			#endif\n		#elif defined( ENVMAP_TYPE_EQUIREC )\n			vec2 sampleUV;\n			sampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n			sampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n			#else\n				vec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n			#endif\n		#elif defined( ENVMAP_TYPE_SPHERE )\n			vec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n			#else\n				vec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n			#endif\n		#endif\n		envMapColor.rgb = inputToLinear( envMapColor.rgb );\n		return envMapColor.rgb * envMapIntensity;\n	}\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/lights_phong_fragment.glsl
	
	THREE.ShaderChunk[ 'lights_phong_fragment' ] = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n";
	
	// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'lights_phong_pars_fragment' ] = "#ifdef USE_ENVMAP\n	varying vec3 vWorldPosition;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n	vec3	diffuseColor;\n	vec3	specularColor;\n	float	specularShininess;\n	float	specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * PI * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )	(0)\n";
	
	// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_vertex.glsl
	
	THREE.ShaderChunk[ 'lights_phong_pars_vertex' ] = "#ifdef USE_ENVMAP\n	varying vec3 vWorldPosition;\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/lights_phong_vertex.glsl
	
	THREE.ShaderChunk[ 'lights_phong_vertex' ] = "#ifdef USE_ENVMAP\n	vWorldPosition = worldPosition.xyz;\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/lights_standard_fragment.glsl
	
	THREE.ShaderChunk[ 'lights_standard_fragment' ] = "StandardMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\nmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n";
	
	// File:src/renderers/shaders/ShaderChunk/lights_standard_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'lights_standard_pars_fragment' ] = "struct StandardMaterial {\n	vec3	diffuseColor;\n	float	specularRoughness;\n	vec3	specularColor;\n};\nvoid RE_Direct_Standard( const in IncidentLight directLight, const in GeometricContext geometry, const in StandardMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * PI * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n}\nvoid RE_IndirectDiffuse_Standard( const in vec3 irradiance, const in GeometricContext geometry, const in StandardMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Standard( const in vec3 radiance, const in GeometricContext geometry, const in StandardMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectSpecular += radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n}\n#define RE_Direct				RE_Direct_Standard\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Standard\n#define RE_IndirectSpecular		RE_IndirectSpecular_Standard\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n";
	
	// File:src/renderers/shaders/ShaderChunk/lights_template.glsl
	
	THREE.ShaderChunk[ 'lights_template' ] = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		directLight = getPointDirectLight( pointLight, geometry );\n		#ifdef USE_SHADOWMAP\n		directLight.color *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		directLight = getSpotDirectLight( spotLight, geometry );\n		#ifdef USE_SHADOWMAP\n		directLight.color *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		directLight = getDirectionalDirectLight( directionalLight, geometry );\n		#ifdef USE_SHADOWMAP\n		directLight.color *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	#ifdef USE_LIGHTMAP\n		irradiance += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n	#endif\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		}\n	#endif\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	vec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n	RE_IndirectSpecular( radiance, geometry, material, reflectedLight );\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/linear_to_gamma_fragment.glsl
	
	THREE.ShaderChunk[ 'linear_to_gamma_fragment' ] = "\n	outgoingLight = linearToOutput( outgoingLight );\n";
	
	// File:src/renderers/shaders/ShaderChunk/logdepthbuf_fragment.glsl
	
	THREE.ShaderChunk[ 'logdepthbuf_fragment' ] = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n	gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'logdepthbuf_pars_fragment' ] = "#ifdef USE_LOGDEPTHBUF\n	uniform float logDepthBufFC;\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n	#endif\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_vertex.glsl
	
	THREE.ShaderChunk[ 'logdepthbuf_pars_vertex' ] = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n	#endif\n	uniform float logDepthBufFC;\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/logdepthbuf_vertex.glsl
	
	THREE.ShaderChunk[ 'logdepthbuf_vertex' ] = "#ifdef USE_LOGDEPTHBUF\n	gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n	#else\n		gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n	#endif\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/map_fragment.glsl
	
	THREE.ShaderChunk[ 'map_fragment' ] = "#ifdef USE_MAP\n	vec4 texelColor = texture2D( map, vUv );\n	texelColor.xyz = inputToLinear( texelColor.xyz );\n	diffuseColor *= texelColor;\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/map_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'map_pars_fragment' ] = "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/map_particle_fragment.glsl
	
	THREE.ShaderChunk[ 'map_particle_fragment' ] = "#ifdef USE_MAP\n	diffuseColor *= texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/map_particle_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'map_particle_pars_fragment' ] = "#ifdef USE_MAP\n	uniform vec4 offsetRepeat;\n	uniform sampler2D map;\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/metalnessmap_fragment.glsl
	
	THREE.ShaderChunk[ 'metalnessmap_fragment' ] = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vUv );\n	metalnessFactor *= texelMetalness.r;\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/metalnessmap_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'metalnessmap_pars_fragment' ] = "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/morphnormal_vertex.glsl
	
	THREE.ShaderChunk[ 'morphnormal_vertex' ] = "#ifdef USE_MORPHNORMALS\n	objectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n	objectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n	objectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n	objectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/morphtarget_pars_vertex.glsl
	
	THREE.ShaderChunk[ 'morphtarget_pars_vertex' ] = "#ifdef USE_MORPHTARGETS\n	#ifndef USE_MORPHNORMALS\n	uniform float morphTargetInfluences[ 8 ];\n	#else\n	uniform float morphTargetInfluences[ 4 ];\n	#endif\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/morphtarget_vertex.glsl
	
	THREE.ShaderChunk[ 'morphtarget_vertex' ] = "#ifdef USE_MORPHTARGETS\n	transformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n	transformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n	transformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n	transformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n	#ifndef USE_MORPHNORMALS\n	transformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n	transformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n	transformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n	transformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n	#endif\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/normal_fragment.glsl
	
	THREE.ShaderChunk[ 'normal_fragment' ] = "#ifdef FLAT_SHADED\n	vec3 fdx = dFdx( vViewPosition );\n	vec3 fdy = dFdy( vViewPosition );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n	#endif\n#endif\n#ifdef USE_NORMALMAP\n	normal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/normalmap_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'normalmap_pars_fragment' ] = "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n		vec3 q0 = dFdx( eye_pos.xyz );\n		vec3 q1 = dFdy( eye_pos.xyz );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n		vec3 S = normalize( q0 * st1.t - q1 * st0.t );\n		vec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n		vec3 N = normalize( surf_norm );\n		vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n		mapN.xy = normalScale * mapN.xy;\n		mat3 tsn = mat3( S, T, N );\n		return normalize( tsn * mapN );\n	}\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/project_vertex.glsl
	
	THREE.ShaderChunk[ 'project_vertex' ] = "#ifdef USE_SKINNING\n	vec4 mvPosition = modelViewMatrix * skinned;\n#else\n	vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n#endif\ngl_Position = projectionMatrix * mvPosition;\n";
	
	// File:src/renderers/shaders/ShaderChunk/roughnessmap_fragment.glsl
	
	THREE.ShaderChunk[ 'roughnessmap_fragment' ] = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vUv );\n	roughnessFactor *= texelRoughness.r;\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/roughnessmap_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'roughnessmap_pars_fragment' ] = "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'shadowmap_pars_fragment' ] = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHTS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n	#endif\n	#if NUM_SPOT_LIGHTS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n	#endif\n	#if NUM_POINT_LIGHTS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n	#endif\n	float unpackDepth( const in vec4 rgba_depth ) {\n		const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n		return dot( rgba_depth, bit_shift );\n	}\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackDepth( texture2D( depths, uv ) ) );\n	}\n	float texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n		const vec2 offset = vec2( 0.0, 1.0 );\n		vec2 texelSize = vec2( 1.0 ) / size;\n		vec2 centroidUV = floor( uv * size + 0.5 ) / size;\n		float lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n		float lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n		float rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n		float rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n		vec2 f = fract( uv * size + 0.5 );\n		float a = mix( lb, lt, f.y );\n		float b = mix( rb, rt, f.y );\n		float c = mix( a, b, f.x );\n		return c;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n		bool frustumTest = all( frustumTestVec );\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			return (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			return (\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return 1.0;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n		vec3 lightToPosition = shadowCoord.xyz;\n		vec3 bd3D = normalize( lightToPosition );\n		float dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec3 offset = vec3( - 1, 0, 1 ) * shadowRadius * 2.0 * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.zzz, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.zxz, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxz, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xzz, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.zzx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.zxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xzx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.zzy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.zxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xzy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.zyz, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyz, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.zyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yzz, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxz, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yzx, texelSize.y ), dp )\n			) * ( 1.0 / 21.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_vertex.glsl
	
	THREE.ShaderChunk[ 'shadowmap_pars_vertex' ] = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHTS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n	#endif\n	#if NUM_SPOT_LIGHTS > 0\n		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n	#endif\n	#if NUM_POINT_LIGHTS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n	#endif\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/shadowmap_vertex.glsl
	
	THREE.ShaderChunk[ 'shadowmap_vertex' ] = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHTS > 0\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n	}\n	#endif\n	#if NUM_SPOT_LIGHTS > 0\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n	}\n	#endif\n	#if NUM_POINT_LIGHTS > 0\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n	}\n	#endif\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/shadowmask_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'shadowmask_pars_fragment' ] = "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHTS > 0\n	DirectionalLight directionalLight;\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		shadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#endif\n	#if NUM_SPOT_LIGHTS > 0\n	SpotLight spotLight;\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		shadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n	}\n	#endif\n	#if NUM_POINT_LIGHTS > 0\n	PointLight pointLight;\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		shadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n	}\n	#endif\n	#endif\n	return shadow;\n}\n";
	
	// File:src/renderers/shaders/ShaderChunk/skinbase_vertex.glsl
	
	THREE.ShaderChunk[ 'skinbase_vertex' ] = "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/skinning_pars_vertex.glsl
	
	THREE.ShaderChunk[ 'skinning_pars_vertex' ] = "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	#ifdef BONE_TEXTURE\n		uniform sampler2D boneTexture;\n		uniform int boneTextureWidth;\n		uniform int boneTextureHeight;\n		mat4 getBoneMatrix( const in float i ) {\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureWidth ) );\n			float y = floor( j / float( boneTextureWidth ) );\n			float dx = 1.0 / float( boneTextureWidth );\n			float dy = 1.0 / float( boneTextureHeight );\n			y = dy * ( y + 0.5 );\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n			mat4 bone = mat4( v1, v2, v3, v4 );\n			return bone;\n		}\n	#else\n		uniform mat4 boneGlobalMatrices[ MAX_BONES ];\n		mat4 getBoneMatrix( const in float i ) {\n			mat4 bone = boneGlobalMatrices[ int(i) ];\n			return bone;\n		}\n	#endif\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/skinning_vertex.glsl
	
	THREE.ShaderChunk[ 'skinning_vertex' ] = "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	skinned  = bindMatrixInverse * skinned;\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/skinnormal_vertex.glsl
	
	THREE.ShaderChunk[ 'skinnormal_vertex' ] = "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/specularmap_fragment.glsl
	
	THREE.ShaderChunk[ 'specularmap_fragment' ] = "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/specularmap_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'specularmap_pars_fragment' ] = "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/uv2_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'uv2_pars_fragment' ] = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	varying vec2 vUv2;\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/uv2_pars_vertex.glsl
	
	THREE.ShaderChunk[ 'uv2_pars_vertex' ] = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/uv2_vertex.glsl
	
	THREE.ShaderChunk[ 'uv2_vertex' ] = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	vUv2 = uv2;\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/uv_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'uv_pars_fragment' ] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n	varying vec2 vUv;\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/uv_pars_vertex.glsl
	
	THREE.ShaderChunk[ 'uv_pars_vertex' ] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n	varying vec2 vUv;\n	uniform vec4 offsetRepeat;\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/uv_vertex.glsl
	
	THREE.ShaderChunk[ 'uv_vertex' ] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n	vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/worldpos_vertex.glsl
	
	THREE.ShaderChunk[ 'worldpos_vertex' ] = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( STANDARD ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n	#ifdef USE_SKINNING\n		vec4 worldPosition = modelMatrix * skinned;\n	#else\n		vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n	#endif\n#endif\n";
	
	// File:src/renderers/shaders/UniformsUtils.js
	
	/**
	 * Uniform Utilities
	 */
	
	THREE.UniformsUtils = {
	
		merge: function ( uniforms ) {
	
			var merged = {};
	
			for ( var u = 0; u < uniforms.length; u ++ ) {
	
				var tmp = this.clone( uniforms[ u ] );
	
				for ( var p in tmp ) {
	
					merged[ p ] = tmp[ p ];
	
				}
	
			}
	
			return merged;
	
		},
	
		clone: function ( uniforms_src ) {
	
			var uniforms_dst = {};
	
			for ( var u in uniforms_src ) {
	
				uniforms_dst[ u ] = {};
	
				for ( var p in uniforms_src[ u ] ) {
	
					var parameter_src = uniforms_src[ u ][ p ];
	
					if ( parameter_src instanceof THREE.Color ||
						 parameter_src instanceof THREE.Vector2 ||
						 parameter_src instanceof THREE.Vector3 ||
						 parameter_src instanceof THREE.Vector4 ||
						 parameter_src instanceof THREE.Matrix3 ||
						 parameter_src instanceof THREE.Matrix4 ||
						 parameter_src instanceof THREE.Texture ) {
	
						uniforms_dst[ u ][ p ] = parameter_src.clone();
	
					} else if ( Array.isArray( parameter_src ) ) {
	
						uniforms_dst[ u ][ p ] = parameter_src.slice();
	
					} else {
	
						uniforms_dst[ u ][ p ] = parameter_src;
	
					}
	
				}
	
			}
	
			return uniforms_dst;
	
		}
	
	};
	
	// File:src/renderers/shaders/UniformsLib.js
	
	/**
	 * Uniforms library for shared webgl shaders
	 */
	
	THREE.UniformsLib = {
	
		common: {
	
			"diffuse": { type: "c", value: new THREE.Color( 0xeeeeee ) },
			"opacity": { type: "f", value: 1.0 },
	
			"map": { type: "t", value: null },
			"offsetRepeat": { type: "v4", value: new THREE.Vector4( 0, 0, 1, 1 ) },
	
			"specularMap": { type: "t", value: null },
			"alphaMap": { type: "t", value: null },
	
			"envMap": { type: "t", value: null },
			"flipEnvMap": { type: "f", value: - 1 },
			"reflectivity": { type: "f", value: 1.0 },
			"refractionRatio": { type: "f", value: 0.98 }
	
		},
	
		aomap: {
	
			"aoMap": { type: "t", value: null },
			"aoMapIntensity": { type: "f", value: 1 }
	
		},
	
		lightmap: {
	
			"lightMap": { type: "t", value: null },
			"lightMapIntensity": { type: "f", value: 1 }
	
		},
	
		emissivemap: {
	
			"emissiveMap": { type: "t", value: null }
	
		},
	
		bumpmap: {
	
			"bumpMap": { type: "t", value: null },
			"bumpScale": { type: "f", value: 1 }
	
		},
	
		normalmap: {
	
			"normalMap": { type: "t", value: null },
			"normalScale": { type: "v2", value: new THREE.Vector2( 1, 1 ) }
	
		},
	
		displacementmap: {
	
			"displacementMap": { type: "t", value: null },
			"displacementScale": { type: "f", value: 1 },
			"displacementBias": { type: "f", value: 0 }
	
		},
	
		roughnessmap: {
	
			"roughnessMap": { type: "t", value: null }
	
		},
	
		metalnessmap: {
	
			"metalnessMap": { type: "t", value: null }
	
		},
	
		fog: {
	
			"fogDensity": { type: "f", value: 0.00025 },
			"fogNear": { type: "f", value: 1 },
			"fogFar": { type: "f", value: 2000 },
			"fogColor": { type: "c", value: new THREE.Color( 0xffffff ) }
	
		},
	
		ambient: {
	
			"ambientLightColor": { type: "fv", value: [] }
	
		},
	
		lights: {
	
			"directionalLights": { type: "sa", value: [], properties: {
				"direction": { type: "v3" },
				"color": { type: "c" },
	
				"shadow": { type: "i" },
				"shadowBias": { type: "f" },
				"shadowRadius": { type: "f" },
				"shadowMapSize": { type: "v2" }
			} },
	
			"directionalShadowMap": { type: "tv", value: [] },
			"directionalShadowMatrix": { type: "m4v", value: [] },
	
			"spotLights": { type: "sa", value: [], properties: {
				"color": { type: "c" },
				"position": { type: "v3" },
				"direction": { type: "v3" },
				"distance": { type: "f" },
				"angleCos": { type: "f" },
				"exponent": { type: "f" },
				"decay": { type: "f" },
	
				"shadow": { type: "i" },
				"shadowBias": { type: "f" },
				"shadowRadius": { type: "f" },
				"shadowMapSize": { type: "v2" }
			} },
	
			"spotShadowMap": { type: "tv", value: [] },
			"spotShadowMatrix": { type: "m4v", value: [] },
	
			"pointLights": { type: "sa", value: [], properties: {
				"color": { type: "c" },
				"position": { type: "v3" },
				"decay": { type: "f" },
				"distance": { type: "f" },
	
				"shadow": { type: "i" },
				"shadowBias": { type: "f" },
				"shadowRadius": { type: "f" },
				"shadowMapSize": { type: "v2" }
			} },
	
			"pointShadowMap": { type: "tv", value: [] },
			"pointShadowMatrix": { type: "m4v", value: [] },
	
			"hemisphereLights": { type: "sa", value: [], properties: {
				"direction": { type: "v3" },
				"skyColor": { type: "c" },
				"groundColor": { type: "c" }
			} }
	
		},
	
		points: {
	
			"diffuse": { type: "c", value: new THREE.Color( 0xeeeeee ) },
			"opacity": { type: "f", value: 1.0 },
			"size": { type: "f", value: 1.0 },
			"scale": { type: "f", value: 1.0 },
			"map": { type: "t", value: null },
			"offsetRepeat": { type: "v4", value: new THREE.Vector4( 0, 0, 1, 1 ) }
	
		}
	
	};
	
	// File:src/renderers/shaders/ShaderLib.js
	
	/**
	 * Webgl Shader Library for three.js
	 *
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 */
	
	
	THREE.ShaderLib = {
	
		'basic': {
	
			uniforms: THREE.UniformsUtils.merge( [
	
				THREE.UniformsLib[ "common" ],
				THREE.UniformsLib[ "aomap" ],
				THREE.UniformsLib[ "fog" ]
	
			] ),
	
			vertexShader: [
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "uv_pars_vertex" ],
				THREE.ShaderChunk[ "uv2_pars_vertex" ],
				THREE.ShaderChunk[ "envmap_pars_vertex" ],
				THREE.ShaderChunk[ "color_pars_vertex" ],
				THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
				THREE.ShaderChunk[ "skinning_pars_vertex" ],
				THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],
	
				"void main() {",
	
					THREE.ShaderChunk[ "uv_vertex" ],
					THREE.ShaderChunk[ "uv2_vertex" ],
					THREE.ShaderChunk[ "color_vertex" ],
					THREE.ShaderChunk[ "skinbase_vertex" ],
	
				"	#ifdef USE_ENVMAP",
	
					THREE.ShaderChunk[ "beginnormal_vertex" ],
					THREE.ShaderChunk[ "morphnormal_vertex" ],
					THREE.ShaderChunk[ "skinnormal_vertex" ],
					THREE.ShaderChunk[ "defaultnormal_vertex" ],
	
				"	#endif",
	
					THREE.ShaderChunk[ "begin_vertex" ],
					THREE.ShaderChunk[ "morphtarget_vertex" ],
					THREE.ShaderChunk[ "skinning_vertex" ],
					THREE.ShaderChunk[ "project_vertex" ],
					THREE.ShaderChunk[ "logdepthbuf_vertex" ],
	
					THREE.ShaderChunk[ "worldpos_vertex" ],
					THREE.ShaderChunk[ "envmap_vertex" ],
					THREE.ShaderChunk[ "shadowmap_vertex" ],
	
				"}"
	
			].join( "\n" ),
	
			fragmentShader: [
	
				"uniform vec3 diffuse;",
				"uniform float opacity;",
	
				"#ifndef FLAT_SHADED",
	
				"	varying vec3 vNormal;",
	
				"#endif",
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "color_pars_fragment" ],
				THREE.ShaderChunk[ "uv_pars_fragment" ],
				THREE.ShaderChunk[ "uv2_pars_fragment" ],
				THREE.ShaderChunk[ "map_pars_fragment" ],
				THREE.ShaderChunk[ "alphamap_pars_fragment" ],
				THREE.ShaderChunk[ "aomap_pars_fragment" ],
				THREE.ShaderChunk[ "envmap_pars_fragment" ],
				THREE.ShaderChunk[ "fog_pars_fragment" ],
				THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
				THREE.ShaderChunk[ "specularmap_pars_fragment" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],
	
				"void main() {",
	
				"	vec4 diffuseColor = vec4( diffuse, opacity );",
	
					THREE.ShaderChunk[ "logdepthbuf_fragment" ],
					THREE.ShaderChunk[ "map_fragment" ],
					THREE.ShaderChunk[ "color_fragment" ],
					THREE.ShaderChunk[ "alphamap_fragment" ],
					THREE.ShaderChunk[ "alphatest_fragment" ],
					THREE.ShaderChunk[ "specularmap_fragment" ],
	
				"	ReflectedLight reflectedLight;",
				"	reflectedLight.directDiffuse = vec3( 0.0 );",
				"	reflectedLight.directSpecular = vec3( 0.0 );",
				"	reflectedLight.indirectDiffuse = diffuseColor.rgb;",
				"	reflectedLight.indirectSpecular = vec3( 0.0 );",
	
					THREE.ShaderChunk[ "aomap_fragment" ],
	
				"	vec3 outgoingLight = reflectedLight.indirectDiffuse;",
	
					THREE.ShaderChunk[ "envmap_fragment" ],
					THREE.ShaderChunk[ "linear_to_gamma_fragment" ],
					THREE.ShaderChunk[ "fog_fragment" ],
	
				"	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",
	
				"}"
	
			].join( "\n" )
	
		},
	
		'lambert': {
	
			uniforms: THREE.UniformsUtils.merge( [
	
				THREE.UniformsLib[ "common" ],
				THREE.UniformsLib[ "aomap" ],
				THREE.UniformsLib[ "lightmap" ],
				THREE.UniformsLib[ "emissivemap" ],
				THREE.UniformsLib[ "fog" ],
				THREE.UniformsLib[ "ambient" ],
				THREE.UniformsLib[ "lights" ],
	
				{
					"emissive" : { type: "c", value: new THREE.Color( 0x000000 ) }
				}
	
			] ),
	
			vertexShader: [
	
				"#define LAMBERT",
	
				"varying vec3 vLightFront;",
	
				"#ifdef DOUBLE_SIDED",
	
				"	varying vec3 vLightBack;",
	
				"#endif",
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "uv_pars_vertex" ],
				THREE.ShaderChunk[ "uv2_pars_vertex" ],
				THREE.ShaderChunk[ "envmap_pars_vertex" ],
				THREE.ShaderChunk[ "bsdfs" ],
				THREE.ShaderChunk[ "lights_pars" ],
				THREE.ShaderChunk[ "color_pars_vertex" ],
				THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
				THREE.ShaderChunk[ "skinning_pars_vertex" ],
				THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],
	
				"void main() {",
	
					THREE.ShaderChunk[ "uv_vertex" ],
					THREE.ShaderChunk[ "uv2_vertex" ],
					THREE.ShaderChunk[ "color_vertex" ],
	
					THREE.ShaderChunk[ "beginnormal_vertex" ],
					THREE.ShaderChunk[ "morphnormal_vertex" ],
					THREE.ShaderChunk[ "skinbase_vertex" ],
					THREE.ShaderChunk[ "skinnormal_vertex" ],
					THREE.ShaderChunk[ "defaultnormal_vertex" ],
	
					THREE.ShaderChunk[ "begin_vertex" ],
					THREE.ShaderChunk[ "morphtarget_vertex" ],
					THREE.ShaderChunk[ "skinning_vertex" ],
					THREE.ShaderChunk[ "project_vertex" ],
					THREE.ShaderChunk[ "logdepthbuf_vertex" ],
	
					THREE.ShaderChunk[ "worldpos_vertex" ],
					THREE.ShaderChunk[ "envmap_vertex" ],
					THREE.ShaderChunk[ "lights_lambert_vertex" ],
					THREE.ShaderChunk[ "shadowmap_vertex" ],
	
				"}"
	
			].join( "\n" ),
	
			fragmentShader: [
	
				"uniform vec3 diffuse;",
				"uniform vec3 emissive;",
				"uniform float opacity;",
	
				"varying vec3 vLightFront;",
	
				"#ifdef DOUBLE_SIDED",
	
				"	varying vec3 vLightBack;",
	
				"#endif",
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "color_pars_fragment" ],
				THREE.ShaderChunk[ "uv_pars_fragment" ],
				THREE.ShaderChunk[ "uv2_pars_fragment" ],
				THREE.ShaderChunk[ "map_pars_fragment" ],
				THREE.ShaderChunk[ "alphamap_pars_fragment" ],
				THREE.ShaderChunk[ "aomap_pars_fragment" ],
				THREE.ShaderChunk[ "lightmap_pars_fragment" ],
				THREE.ShaderChunk[ "emissivemap_pars_fragment" ],
				THREE.ShaderChunk[ "envmap_pars_fragment" ],
				THREE.ShaderChunk[ "bsdfs" ],
				THREE.ShaderChunk[ "ambient_pars" ],
				THREE.ShaderChunk[ "lights_pars" ],
				THREE.ShaderChunk[ "fog_pars_fragment" ],
				THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
				THREE.ShaderChunk[ "shadowmask_pars_fragment" ],
				THREE.ShaderChunk[ "specularmap_pars_fragment" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],
	
				"void main() {",
	
				"	vec4 diffuseColor = vec4( diffuse, opacity );",
				"	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );",
				"	vec3 totalEmissiveLight = emissive;",
	
					THREE.ShaderChunk[ "logdepthbuf_fragment" ],
					THREE.ShaderChunk[ "map_fragment" ],
					THREE.ShaderChunk[ "color_fragment" ],
					THREE.ShaderChunk[ "alphamap_fragment" ],
					THREE.ShaderChunk[ "alphatest_fragment" ],
					THREE.ShaderChunk[ "specularmap_fragment" ],
					THREE.ShaderChunk[ "emissivemap_fragment" ],
	
					// accumulation
				"	reflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );",
	
					THREE.ShaderChunk[ "lightmap_fragment" ],
	
				"	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );",
	
				"	#ifdef DOUBLE_SIDED",
	
				"		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;",
	
				"	#else",
	
				"		reflectedLight.directDiffuse = vLightFront;",
	
				"	#endif",
	
				"	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();",
	
					// modulation
					THREE.ShaderChunk[ "aomap_fragment" ],
	
				"	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveLight;",
	
					THREE.ShaderChunk[ "envmap_fragment" ],
	
					THREE.ShaderChunk[ "linear_to_gamma_fragment" ],
	
					THREE.ShaderChunk[ "fog_fragment" ],
	
				"	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",
	
				"}"
	
			].join( "\n" )
	
		},
	
		'phong': {
	
			uniforms: THREE.UniformsUtils.merge( [
	
				THREE.UniformsLib[ "common" ],
				THREE.UniformsLib[ "aomap" ],
				THREE.UniformsLib[ "lightmap" ],
				THREE.UniformsLib[ "emissivemap" ],
				THREE.UniformsLib[ "bumpmap" ],
				THREE.UniformsLib[ "normalmap" ],
				THREE.UniformsLib[ "displacementmap" ],
				THREE.UniformsLib[ "fog" ],
				THREE.UniformsLib[ "ambient" ],
				THREE.UniformsLib[ "lights" ],
	
				{
					"emissive" : { type: "c", value: new THREE.Color( 0x000000 ) },
					"specular" : { type: "c", value: new THREE.Color( 0x111111 ) },
					"shininess": { type: "f", value: 30 }
				}
	
			] ),
	
			vertexShader: [
	
				"#define PHONG",
	
				"varying vec3 vViewPosition;",
	
				"#ifndef FLAT_SHADED",
	
				"	varying vec3 vNormal;",
	
				"#endif",
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "uv_pars_vertex" ],
				THREE.ShaderChunk[ "uv2_pars_vertex" ],
				THREE.ShaderChunk[ "displacementmap_pars_vertex" ],
				THREE.ShaderChunk[ "envmap_pars_vertex" ],
				THREE.ShaderChunk[ "lights_phong_pars_vertex" ],
				THREE.ShaderChunk[ "color_pars_vertex" ],
				THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
				THREE.ShaderChunk[ "skinning_pars_vertex" ],
				THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],
	
				"void main() {",
	
					THREE.ShaderChunk[ "uv_vertex" ],
					THREE.ShaderChunk[ "uv2_vertex" ],
					THREE.ShaderChunk[ "color_vertex" ],
	
					THREE.ShaderChunk[ "beginnormal_vertex" ],
					THREE.ShaderChunk[ "morphnormal_vertex" ],
					THREE.ShaderChunk[ "skinbase_vertex" ],
					THREE.ShaderChunk[ "skinnormal_vertex" ],
					THREE.ShaderChunk[ "defaultnormal_vertex" ],
	
				"#ifndef FLAT_SHADED", // Normal computed with derivatives when FLAT_SHADED
	
				"	vNormal = normalize( transformedNormal );",
	
				"#endif",
	
					THREE.ShaderChunk[ "begin_vertex" ],
					THREE.ShaderChunk[ "displacementmap_vertex" ],
					THREE.ShaderChunk[ "morphtarget_vertex" ],
					THREE.ShaderChunk[ "skinning_vertex" ],
					THREE.ShaderChunk[ "project_vertex" ],
					THREE.ShaderChunk[ "logdepthbuf_vertex" ],
	
				"	vViewPosition = - mvPosition.xyz;",
	
					THREE.ShaderChunk[ "worldpos_vertex" ],
					THREE.ShaderChunk[ "envmap_vertex" ],
					THREE.ShaderChunk[ "lights_phong_vertex" ],
					THREE.ShaderChunk[ "shadowmap_vertex" ],
	
				"}"
	
			].join( "\n" ),
	
			fragmentShader: [
	
				"#define PHONG",
	
				"uniform vec3 diffuse;",
				"uniform vec3 emissive;",
				"uniform vec3 specular;",
				"uniform float shininess;",
				"uniform float opacity;",
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "color_pars_fragment" ],
				THREE.ShaderChunk[ "uv_pars_fragment" ],
				THREE.ShaderChunk[ "uv2_pars_fragment" ],
				THREE.ShaderChunk[ "map_pars_fragment" ],
				THREE.ShaderChunk[ "alphamap_pars_fragment" ],
				THREE.ShaderChunk[ "aomap_pars_fragment" ],
				THREE.ShaderChunk[ "lightmap_pars_fragment" ],
				THREE.ShaderChunk[ "emissivemap_pars_fragment" ],
				THREE.ShaderChunk[ "envmap_pars_fragment" ],
				THREE.ShaderChunk[ "fog_pars_fragment" ],
				THREE.ShaderChunk[ "bsdfs" ],
				THREE.ShaderChunk[ "ambient_pars" ],
				THREE.ShaderChunk[ "lights_pars" ],
				THREE.ShaderChunk[ "lights_phong_pars_fragment" ],
				THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
				THREE.ShaderChunk[ "bumpmap_pars_fragment" ],
				THREE.ShaderChunk[ "normalmap_pars_fragment" ],
				THREE.ShaderChunk[ "specularmap_pars_fragment" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],
	
				"void main() {",
	
				"	vec4 diffuseColor = vec4( diffuse, opacity );",
				"	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );",
				"	vec3 totalEmissiveLight = emissive;",
	
					THREE.ShaderChunk[ "logdepthbuf_fragment" ],
					THREE.ShaderChunk[ "map_fragment" ],
					THREE.ShaderChunk[ "color_fragment" ],
					THREE.ShaderChunk[ "alphamap_fragment" ],
					THREE.ShaderChunk[ "alphatest_fragment" ],
					THREE.ShaderChunk[ "specularmap_fragment" ],
					THREE.ShaderChunk[ "normal_fragment" ],
					THREE.ShaderChunk[ "emissivemap_fragment" ],
	
					// accumulation
					THREE.ShaderChunk[ "lights_phong_fragment" ],
					THREE.ShaderChunk[ "lights_template" ],
	
					// modulation
					THREE.ShaderChunk[ "aomap_fragment" ],
	
					"vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveLight;",
	
					THREE.ShaderChunk[ "envmap_fragment" ],
					THREE.ShaderChunk[ "linear_to_gamma_fragment" ],
	
					THREE.ShaderChunk[ "fog_fragment" ],
	
				"	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",
	
				"}"
	
			].join( "\n" )
	
		},
	
		'standard': {
	
			uniforms: THREE.UniformsUtils.merge( [
	
				THREE.UniformsLib[ "common" ],
				THREE.UniformsLib[ "aomap" ],
				THREE.UniformsLib[ "lightmap" ],
				THREE.UniformsLib[ "emissivemap" ],
				THREE.UniformsLib[ "bumpmap" ],
				THREE.UniformsLib[ "normalmap" ],
				THREE.UniformsLib[ "displacementmap" ],
				THREE.UniformsLib[ "roughnessmap" ],
				THREE.UniformsLib[ "metalnessmap" ],
				THREE.UniformsLib[ "fog" ],
				THREE.UniformsLib[ "ambient" ],
				THREE.UniformsLib[ "lights" ],
	
				{
					"emissive" : { type: "c", value: new THREE.Color( 0x000000 ) },
					"roughness": { type: "f", value: 0.5 },
					"metalness": { type: "f", value: 0 },
					"envMapIntensity" : { type: "f", value: 1 } // temporary
				}
	
			] ),
	
			vertexShader: [
	
				"#define STANDARD",
	
				"varying vec3 vViewPosition;",
	
				"#ifndef FLAT_SHADED",
	
				"	varying vec3 vNormal;",
	
				"#endif",
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "uv_pars_vertex" ],
				THREE.ShaderChunk[ "uv2_pars_vertex" ],
				THREE.ShaderChunk[ "displacementmap_pars_vertex" ],
				THREE.ShaderChunk[ "envmap_pars_vertex" ],
				THREE.ShaderChunk[ "color_pars_vertex" ],
				THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
				THREE.ShaderChunk[ "skinning_pars_vertex" ],
				THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
				THREE.ShaderChunk[ "specularmap_pars_fragment" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],
	
				"void main() {", // STANDARD
	
					THREE.ShaderChunk[ "uv_vertex" ],
					THREE.ShaderChunk[ "uv2_vertex" ],
					THREE.ShaderChunk[ "color_vertex" ],
	
					THREE.ShaderChunk[ "beginnormal_vertex" ],
					THREE.ShaderChunk[ "morphnormal_vertex" ],
					THREE.ShaderChunk[ "skinbase_vertex" ],
					THREE.ShaderChunk[ "skinnormal_vertex" ],
					THREE.ShaderChunk[ "defaultnormal_vertex" ],
	
				"#ifndef FLAT_SHADED", // Normal computed with derivatives when FLAT_SHADED
	
				"	vNormal = normalize( transformedNormal );",
	
				"#endif",
	
					THREE.ShaderChunk[ "begin_vertex" ],
					THREE.ShaderChunk[ "displacementmap_vertex" ],
					THREE.ShaderChunk[ "morphtarget_vertex" ],
					THREE.ShaderChunk[ "skinning_vertex" ],
					THREE.ShaderChunk[ "project_vertex" ],
					THREE.ShaderChunk[ "logdepthbuf_vertex" ],
	
				"	vViewPosition = - mvPosition.xyz;",
	
					THREE.ShaderChunk[ "worldpos_vertex" ],
					THREE.ShaderChunk[ "envmap_vertex" ],
					THREE.ShaderChunk[ "shadowmap_vertex" ],
	
				"}"
	
			].join( "\n" ),
	
			fragmentShader: [
	
				"#define STANDARD",
	
				"uniform vec3 diffuse;",
				"uniform vec3 emissive;",
				"uniform float roughness;",
				"uniform float metalness;",
				"uniform float opacity;",
	
				"uniform float envMapIntensity;", // temporary
	
				"varying vec3 vViewPosition;",
	
				"#ifndef FLAT_SHADED",
	
				"	varying vec3 vNormal;",
	
				"#endif",
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "color_pars_fragment" ],
				THREE.ShaderChunk[ "uv_pars_fragment" ],
				THREE.ShaderChunk[ "uv2_pars_fragment" ],
				THREE.ShaderChunk[ "map_pars_fragment" ],
				THREE.ShaderChunk[ "alphamap_pars_fragment" ],
				THREE.ShaderChunk[ "aomap_pars_fragment" ],
				THREE.ShaderChunk[ "lightmap_pars_fragment" ],
				THREE.ShaderChunk[ "emissivemap_pars_fragment" ],
				THREE.ShaderChunk[ "envmap_pars_fragment" ],
				THREE.ShaderChunk[ "fog_pars_fragment" ],
				THREE.ShaderChunk[ "bsdfs" ],
				THREE.ShaderChunk[ "ambient_pars" ],
				THREE.ShaderChunk[ "lights_pars" ],
				THREE.ShaderChunk[ "lights_standard_pars_fragment" ],
				THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
				THREE.ShaderChunk[ "bumpmap_pars_fragment" ],
				THREE.ShaderChunk[ "normalmap_pars_fragment" ],
				THREE.ShaderChunk[ "roughnessmap_pars_fragment" ],
				THREE.ShaderChunk[ "metalnessmap_pars_fragment" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],
	
				"void main() {",
	
				"	vec4 diffuseColor = vec4( diffuse, opacity );",
				"	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );",
				"	vec3 totalEmissiveLight = emissive;",
	
					THREE.ShaderChunk[ "logdepthbuf_fragment" ],
					THREE.ShaderChunk[ "map_fragment" ],
					THREE.ShaderChunk[ "color_fragment" ],
					THREE.ShaderChunk[ "alphamap_fragment" ],
					THREE.ShaderChunk[ "alphatest_fragment" ],
					THREE.ShaderChunk[ "specularmap_fragment" ],
					THREE.ShaderChunk[ "roughnessmap_fragment" ],
					THREE.ShaderChunk[ "metalnessmap_fragment" ],
					THREE.ShaderChunk[ "normal_fragment" ],
					THREE.ShaderChunk[ "emissivemap_fragment" ],
	
					// accumulation
					THREE.ShaderChunk[ "lights_standard_fragment" ],
					THREE.ShaderChunk[ "lights_template" ],
	
					// modulation
					THREE.ShaderChunk[ "aomap_fragment" ],
	
					"vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveLight;",
	
					THREE.ShaderChunk[ "linear_to_gamma_fragment" ],
	
					THREE.ShaderChunk[ "fog_fragment" ],
	
				"	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",
	
				"}"
	
			].join( "\n" )
	
		},
	
		'points': {
	
			uniforms: THREE.UniformsUtils.merge( [
	
				THREE.UniformsLib[ "points" ],
				THREE.UniformsLib[ "fog" ]
	
			] ),
	
			vertexShader: [
	
				"uniform float size;",
				"uniform float scale;",
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "color_pars_vertex" ],
				THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],
	
				"void main() {",
	
					THREE.ShaderChunk[ "color_vertex" ],
					THREE.ShaderChunk[ "begin_vertex" ],
					THREE.ShaderChunk[ "project_vertex" ],
	
				"	#ifdef USE_SIZEATTENUATION",
				"		gl_PointSize = size * ( scale / - mvPosition.z );",
				"	#else",
				"		gl_PointSize = size;",
				"	#endif",
	
					THREE.ShaderChunk[ "logdepthbuf_vertex" ],
					THREE.ShaderChunk[ "worldpos_vertex" ],
					THREE.ShaderChunk[ "shadowmap_vertex" ],
	
				"}"
	
			].join( "\n" ),
	
			fragmentShader: [
	
				"uniform vec3 diffuse;",
				"uniform float opacity;",
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "color_pars_fragment" ],
				THREE.ShaderChunk[ "map_particle_pars_fragment" ],
				THREE.ShaderChunk[ "fog_pars_fragment" ],
				THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],
	
				"void main() {",
	
				"	vec3 outgoingLight = vec3( 0.0 );",
				"	vec4 diffuseColor = vec4( diffuse, opacity );",
	
					THREE.ShaderChunk[ "logdepthbuf_fragment" ],
					THREE.ShaderChunk[ "map_particle_fragment" ],
					THREE.ShaderChunk[ "color_fragment" ],
					THREE.ShaderChunk[ "alphatest_fragment" ],
	
				"	outgoingLight = diffuseColor.rgb;",
	
					THREE.ShaderChunk[ "fog_fragment" ],
	
				"	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",
	
				"}"
	
			].join( "\n" )
	
		},
	
		'dashed': {
	
			uniforms: THREE.UniformsUtils.merge( [
	
				THREE.UniformsLib[ "common" ],
				THREE.UniformsLib[ "fog" ],
	
				{
					"scale"    : { type: "f", value: 1 },
					"dashSize" : { type: "f", value: 1 },
					"totalSize": { type: "f", value: 2 }
				}
	
			] ),
	
			vertexShader: [
	
				"uniform float scale;",
				"attribute float lineDistance;",
	
				"varying float vLineDistance;",
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "color_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],
	
				"void main() {",
	
					THREE.ShaderChunk[ "color_vertex" ],
	
				"	vLineDistance = scale * lineDistance;",
	
				"	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
				"	gl_Position = projectionMatrix * mvPosition;",
	
					THREE.ShaderChunk[ "logdepthbuf_vertex" ],
	
				"}"
	
			].join( "\n" ),
	
			fragmentShader: [
	
				"uniform vec3 diffuse;",
				"uniform float opacity;",
	
				"uniform float dashSize;",
				"uniform float totalSize;",
	
				"varying float vLineDistance;",
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "color_pars_fragment" ],
				THREE.ShaderChunk[ "fog_pars_fragment" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],
	
				"void main() {",
	
				"	if ( mod( vLineDistance, totalSize ) > dashSize ) {",
	
				"		discard;",
	
				"	}",
	
				"	vec3 outgoingLight = vec3( 0.0 );",
				"	vec4 diffuseColor = vec4( diffuse, opacity );",
	
					THREE.ShaderChunk[ "logdepthbuf_fragment" ],
					THREE.ShaderChunk[ "color_fragment" ],
	
				"	outgoingLight = diffuseColor.rgb;", // simple shader
	
					THREE.ShaderChunk[ "fog_fragment" ],
	
				"	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",
	
				"}"
	
			].join( "\n" )
	
		},
	
		'depth': {
	
			uniforms: {
	
				"mNear": { type: "f", value: 1.0 },
				"mFar" : { type: "f", value: 2000.0 },
				"opacity" : { type: "f", value: 1.0 }
	
			},
	
			vertexShader: [
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],
	
				"void main() {",
	
					THREE.ShaderChunk[ "begin_vertex" ],
					THREE.ShaderChunk[ "morphtarget_vertex" ],
					THREE.ShaderChunk[ "project_vertex" ],
					THREE.ShaderChunk[ "logdepthbuf_vertex" ],
	
				"}"
	
			].join( "\n" ),
	
			fragmentShader: [
	
				"uniform float mNear;",
				"uniform float mFar;",
				"uniform float opacity;",
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],
	
				"void main() {",
	
					THREE.ShaderChunk[ "logdepthbuf_fragment" ],
	
				"	#ifdef USE_LOGDEPTHBUF_EXT",
	
				"		float depth = gl_FragDepthEXT / gl_FragCoord.w;",
	
				"	#else",
	
				"		float depth = gl_FragCoord.z / gl_FragCoord.w;",
	
				"	#endif",
	
				"	float color = 1.0 - smoothstep( mNear, mFar, depth );",
				"	gl_FragColor = vec4( vec3( color ), opacity );",
	
				"}"
	
			].join( "\n" )
	
		},
	
		'normal': {
	
			uniforms: {
	
				"opacity" : { type: "f", value: 1.0 }
	
			},
	
			vertexShader: [
	
				"varying vec3 vNormal;",
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],
	
				"void main() {",
	
				"	vNormal = normalize( normalMatrix * normal );",
	
					THREE.ShaderChunk[ "begin_vertex" ],
					THREE.ShaderChunk[ "morphtarget_vertex" ],
					THREE.ShaderChunk[ "project_vertex" ],
					THREE.ShaderChunk[ "logdepthbuf_vertex" ],
	
				"}"
	
			].join( "\n" ),
	
			fragmentShader: [
	
				"uniform float opacity;",
				"varying vec3 vNormal;",
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],
	
				"void main() {",
	
				"	gl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );",
	
					THREE.ShaderChunk[ "logdepthbuf_fragment" ],
	
				"}"
	
			].join( "\n" )
	
		},
	
		/* -------------------------------------------------------------------------
		//	Cube map shader
		 ------------------------------------------------------------------------- */
	
		'cube': {
	
			uniforms: {
				"tCube": { type: "t", value: null },
				"tFlip": { type: "f", value: - 1 }
			},
	
			vertexShader: [
	
				"varying vec3 vWorldPosition;",
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],
	
				"void main() {",
	
				"	vWorldPosition = transformDirection( position, modelMatrix );",
	
				"	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
	
					THREE.ShaderChunk[ "logdepthbuf_vertex" ],
	
				"}"
	
			].join( "\n" ),
	
			fragmentShader: [
	
				"uniform samplerCube tCube;",
				"uniform float tFlip;",
	
				"varying vec3 vWorldPosition;",
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],
	
				"void main() {",
	
				"	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );",
	
					THREE.ShaderChunk[ "logdepthbuf_fragment" ],
	
				"}"
	
			].join( "\n" )
	
		},
	
		/* -------------------------------------------------------------------------
		//	Cube map shader
		 ------------------------------------------------------------------------- */
	
		'equirect': {
	
			uniforms: {
				"tEquirect": { type: "t", value: null },
				"tFlip": { type: "f", value: - 1 }
			},
	
			vertexShader: [
	
				"varying vec3 vWorldPosition;",
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],
	
				"void main() {",
	
				"	vWorldPosition = transformDirection( position, modelMatrix );",
	
				"	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
	
					THREE.ShaderChunk[ "logdepthbuf_vertex" ],
	
				"}"
	
			].join( "\n" ),
	
			fragmentShader: [
	
				"uniform sampler2D tEquirect;",
				"uniform float tFlip;",
	
				"varying vec3 vWorldPosition;",
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],
	
				"void main() {",
	
					// "	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );",
					"vec3 direction = normalize( vWorldPosition );",
					"vec2 sampleUV;",
					"sampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );",
					"sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;",
					"gl_FragColor = texture2D( tEquirect, sampleUV );",
	
					THREE.ShaderChunk[ "logdepthbuf_fragment" ],
	
				"}"
	
			].join( "\n" )
	
		},
	
		/* Depth encoding into RGBA texture
		 *
		 * based on SpiderGL shadow map example
		 * http://spidergl.org/example.php?id=6
		 *
		 * originally from
		 * http://www.gamedev.net/topic/442138-packing-a-float-into-a-a8r8g8b8-texture-shader/page__whichpage__1%25EF%25BF%25BD
		 *
		 * see also
		 * http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/
		 */
	
		'depthRGBA': {
	
			uniforms: {},
	
			vertexShader: [
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
				THREE.ShaderChunk[ "skinning_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],
	
				"void main() {",
	
					THREE.ShaderChunk[ "skinbase_vertex" ],
	
					THREE.ShaderChunk[ "begin_vertex" ],
					THREE.ShaderChunk[ "morphtarget_vertex" ],
					THREE.ShaderChunk[ "skinning_vertex" ],
					THREE.ShaderChunk[ "project_vertex" ],
					THREE.ShaderChunk[ "logdepthbuf_vertex" ],
	
				"}"
	
			].join( "\n" ),
	
			fragmentShader: [
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],
	
				"vec4 pack_depth( const in float depth ) {",
	
				"	const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );",
				"	const vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );",
				"	vec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );",
				"	res -= res.xxyz * bit_mask;",
				"	return res;",
	
				"}",
	
				"void main() {",
	
					THREE.ShaderChunk[ "logdepthbuf_fragment" ],
	
				"	#ifdef USE_LOGDEPTHBUF_EXT",
	
				"		gl_FragData[ 0 ] = pack_depth( gl_FragDepthEXT );",
	
				"	#else",
	
				"		gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );",
	
				"	#endif",
	
					//"gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z / gl_FragCoord.w );",
					//"float z = ( ( gl_FragCoord.z / gl_FragCoord.w ) - 3.0 ) / ( 4000.0 - 3.0 );",
					//"gl_FragData[ 0 ] = pack_depth( z );",
					//"gl_FragData[ 0 ] = vec4( z, z, z, 1.0 );",
	
				"}"
	
			].join( "\n" )
	
		},
	
	
		'distanceRGBA': {
	
			uniforms: {
	
				"lightPos": { type: "v3", value: new THREE.Vector3( 0, 0, 0 ) }
	
			},
	
			vertexShader: [
	
				"varying vec4 vWorldPosition;",
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
				THREE.ShaderChunk[ "skinning_pars_vertex" ],
	
				"void main() {",
	
					THREE.ShaderChunk[ "skinbase_vertex" ],
					THREE.ShaderChunk[ "begin_vertex" ],
					THREE.ShaderChunk[ "morphtarget_vertex" ],
					THREE.ShaderChunk[ "skinning_vertex" ],
					THREE.ShaderChunk[ "project_vertex" ],
					THREE.ShaderChunk[ "worldpos_vertex" ],
	
					"vWorldPosition = worldPosition;",
	
				"}"
	
			].join( "\n" ),
	
			fragmentShader: [
	
				"uniform vec3 lightPos;",
				"varying vec4 vWorldPosition;",
	
				THREE.ShaderChunk[ "common" ],
	
				"vec4 pack1K ( float depth ) {",
	
				"	depth /= 1000.0;",
				"	const vec4 bitSh = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );",
				"	const vec4 bitMsk = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );",
				"	vec4 res = mod( depth * bitSh * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );",
				"	res -= res.xxyz * bitMsk;",
				"	return res; ",
	
				"}",
	
				"float unpack1K ( vec4 color ) {",
	
				"	const vec4 bitSh = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );",
				"	return dot( color, bitSh ) * 1000.0;",
	
				"}",
	
				"void main () {",
	
				"	gl_FragColor = pack1K( length( vWorldPosition.xyz - lightPos.xyz ) );",
	
				"}"
	
			].join( "\n" )
	
		}
	
	};
	
	// File:src/renderers/WebGLRenderer.js
	
	/**
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author szimek / https://github.com/szimek/
	 */
	
	THREE.WebGLRenderer = function ( parameters ) {
	
		console.log( 'THREE.WebGLRenderer', THREE.REVISION );
	
		parameters = parameters || {};
	
		var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement( 'canvas' ),
		_context = parameters.context !== undefined ? parameters.context : null,
	
		_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
		_depth = parameters.depth !== undefined ? parameters.depth : true,
		_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
		_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
		_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
		_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false;
	
		var lights = [];
	
		var opaqueObjects = [];
		var opaqueObjectsLastIndex = - 1;
		var transparentObjects = [];
		var transparentObjectsLastIndex = - 1;
	
		var morphInfluences = new Float32Array( 8 );
	
		var sprites = [];
		var lensFlares = [];
	
		// public properties
	
		this.domElement = _canvas;
		this.context = null;
	
		// clearing
	
		this.autoClear = true;
		this.autoClearColor = true;
		this.autoClearDepth = true;
		this.autoClearStencil = true;
	
		// scene graph
	
		this.sortObjects = true;
	
		// physically based shading
	
		this.gammaFactor = 2.0;	// for backwards compatibility
		this.gammaInput = false;
		this.gammaOutput = false;
	
		// morphs
	
		this.maxMorphTargets = 8;
		this.maxMorphNormals = 4;
	
		// flags
	
		this.autoScaleCubemaps = true;
	
		// internal properties
	
		var _this = this,
	
		// internal state cache
	
		_currentProgram = null,
		_currentRenderTarget = null,
		_currentFramebuffer = null,
		_currentMaterialId = - 1,
		_currentGeometryProgram = '',
		_currentCamera = null,
	
		_currentScissor = new THREE.Vector4(),
		_currentScissorTest = null,
	
		_currentViewport = new THREE.Vector4(),
	
		//
	
		_usedTextureUnits = 0,
	
		//
	
		_clearColor = new THREE.Color( 0x000000 ),
		_clearAlpha = 0,
	
		_width = _canvas.width,
		_height = _canvas.height,
	
		_pixelRatio = 1,
	
		_scissor = new THREE.Vector4( 0, 0, _width, _height ),
		_scissorTest = false,
	
		_viewport = new THREE.Vector4( 0, 0, _width, _height ),
	
		// frustum
	
		_frustum = new THREE.Frustum(),
	
		// camera matrices cache
	
		_projScreenMatrix = new THREE.Matrix4(),
	
		_vector3 = new THREE.Vector3(),
	
		// light arrays cache
	
		_lights = {
	
			hash: '',
	
			ambient: [ 0, 0, 0 ],
			directional: [],
			directionalShadowMap: [],
			directionalShadowMatrix: [],
			spot: [],
			spotShadowMap: [],
			spotShadowMatrix: [],
			point: [],
			pointShadowMap: [],
			pointShadowMatrix: [],
			hemi: [],
	
			shadows: [],
			shadowsPointLight: 0
	
		},
	
		// info
	
		_infoMemory = {
	
			geometries: 0,
			textures: 0
	
		},
	
		_infoRender = {
	
			calls: 0,
			vertices: 0,
			faces: 0,
			points: 0
	
		};
	
		this.info = {
	
			render: _infoRender,
			memory: _infoMemory,
			programs: null
	
		};
	
	
		// initialize
	
		var _gl;
	
		try {
	
			var attributes = {
				alpha: _alpha,
				depth: _depth,
				stencil: _stencil,
				antialias: _antialias,
				premultipliedAlpha: _premultipliedAlpha,
				preserveDrawingBuffer: _preserveDrawingBuffer
			};
	
			_gl = _context || _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );
	
			if ( _gl === null ) {
	
				if ( _canvas.getContext( 'webgl' ) !== null ) {
	
					throw 'Error creating WebGL context with your selected attributes.';
	
				} else {
	
					throw 'Error creating WebGL context.';
	
				}
	
			}
	
			_canvas.addEventListener( 'webglcontextlost', onContextLost, false );
	
		} catch ( error ) {
	
			console.error( 'THREE.WebGLRenderer: ' + error );
	
		}
	
		var extensions = new THREE.WebGLExtensions( _gl );
	
		extensions.get( 'OES_texture_float' );
		extensions.get( 'OES_texture_float_linear' );
		extensions.get( 'OES_texture_half_float' );
		extensions.get( 'OES_texture_half_float_linear' );
		extensions.get( 'OES_standard_derivatives' );
		extensions.get( 'ANGLE_instanced_arrays' );
	
		if ( extensions.get( 'OES_element_index_uint' ) ) {
	
			THREE.BufferGeometry.MaxIndex = 4294967296;
	
		}
	
		var capabilities = new THREE.WebGLCapabilities( _gl, extensions, parameters );
	
		var state = new THREE.WebGLState( _gl, extensions, paramThreeToGL );
		var properties = new THREE.WebGLProperties();
		var objects = new THREE.WebGLObjects( _gl, properties, this.info );
		var programCache = new THREE.WebGLPrograms( this, capabilities );
		var lightCache = new THREE.WebGLLights();
	
		this.info.programs = programCache.programs;
	
		var bufferRenderer = new THREE.WebGLBufferRenderer( _gl, extensions, _infoRender );
		var indexedBufferRenderer = new THREE.WebGLIndexedBufferRenderer( _gl, extensions, _infoRender );
	
		//
	
		function getTargetPixelRatio() {
	
			return _currentRenderTarget === null ? _pixelRatio : 1;
	
		}
	
		function glClearColor( r, g, b, a ) {
	
			if ( _premultipliedAlpha === true ) {
	
				r *= a; g *= a; b *= a;
	
			}
	
			state.clearColor( r, g, b, a );
	
		}
	
		function setDefaultGLState() {
	
			state.init();
	
			state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );
			state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );
	
			glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );
	
		}
	
		function resetGLState() {
	
			_currentProgram = null;
			_currentCamera = null;
	
			_currentGeometryProgram = '';
			_currentMaterialId = - 1;
	
			state.reset();
	
		}
	
		setDefaultGLState();
	
		this.context = _gl;
		this.capabilities = capabilities;
		this.extensions = extensions;
		this.properties = properties;
		this.state = state;
	
		// shadow map
	
		var shadowMap = new THREE.WebGLShadowMap( this, _lights, objects );
	
		this.shadowMap = shadowMap;
	
	
		// Plugins
	
		var spritePlugin = new THREE.SpritePlugin( this, sprites );
		var lensFlarePlugin = new THREE.LensFlarePlugin( this, lensFlares );
	
		// API
	
		this.getContext = function () {
	
			return _gl;
	
		};
	
		this.getContextAttributes = function () {
	
			return _gl.getContextAttributes();
	
		};
	
		this.forceContextLoss = function () {
	
			extensions.get( 'WEBGL_lose_context' ).loseContext();
	
		};
	
		this.getMaxAnisotropy = ( function () {
	
			var value;
	
			return function getMaxAnisotropy() {
	
				if ( value !== undefined ) return value;
	
				var extension = extensions.get( 'EXT_texture_filter_anisotropic' );
	
				if ( extension !== null ) {
	
					value = _gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );
	
				} else {
	
					value = 0;
	
				}
	
				return value;
	
			};
	
		} )();
	
		this.getPrecision = function () {
	
			return capabilities.precision;
	
		};
	
		this.getPixelRatio = function () {
	
			return _pixelRatio;
	
		};
	
		this.setPixelRatio = function ( value ) {
	
			if ( value === undefined ) return;
	
			_pixelRatio = value;
	
			this.setSize( _viewport.z, _viewport.w, false );
	
		};
	
		this.getSize = function () {
	
			return {
				width: _width,
				height: _height
			};
	
		};
	
		this.setSize = function ( width, height, updateStyle ) {
	
			_width = width;
			_height = height;
	
			_canvas.width = width * _pixelRatio;
			_canvas.height = height * _pixelRatio;
	
			if ( updateStyle !== false ) {
	
				_canvas.style.width = width + 'px';
				_canvas.style.height = height + 'px';
	
			}
	
			this.setViewport( 0, 0, width, height );
	
		};
	
		this.setViewport = function ( x, y, width, height ) {
	
			state.viewport( _viewport.set( x, y, width, height ) );
	
		};
	
		this.setScissor = function ( x, y, width, height ) {
	
			state.scissor( _scissor.set( x, y, width, height ) );
	
		};
	
		this.setScissorTest = function ( boolean ) {
	
			state.setScissorTest( _scissorTest = boolean );
	
		};
	
		// Clearing
	
		this.getClearColor = function () {
	
			return _clearColor;
	
		};
	
		this.setClearColor = function ( color, alpha ) {
	
			_clearColor.set( color );
	
			_clearAlpha = alpha !== undefined ? alpha : 1;
	
			glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );
	
		};
	
		this.getClearAlpha = function () {
	
			return _clearAlpha;
	
		};
	
		this.setClearAlpha = function ( alpha ) {
	
			_clearAlpha = alpha;
	
			glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );
	
		};
	
		this.clear = function ( color, depth, stencil ) {
	
			var bits = 0;
	
			if ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;
			if ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;
			if ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;
	
			_gl.clear( bits );
	
		};
	
		this.clearColor = function () {
	
			this.clear( true, false, false );
	
		};
	
		this.clearDepth = function () {
	
			this.clear( false, true, false );
	
		};
	
		this.clearStencil = function () {
	
			this.clear( false, false, true );
	
		};
	
		this.clearTarget = function ( renderTarget, color, depth, stencil ) {
	
			this.setRenderTarget( renderTarget );
			this.clear( color, depth, stencil );
	
		};
	
		// Reset
	
		this.resetGLState = resetGLState;
	
		this.dispose = function() {
	
			_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );
	
		};
	
		// Events
	
		function onContextLost( event ) {
	
			event.preventDefault();
	
			resetGLState();
			setDefaultGLState();
	
			properties.clear();
	
		}
	
		function onTextureDispose( event ) {
	
			var texture = event.target;
	
			texture.removeEventListener( 'dispose', onTextureDispose );
	
			deallocateTexture( texture );
	
			_infoMemory.textures --;
	
	
		}
	
		function onRenderTargetDispose( event ) {
	
			var renderTarget = event.target;
	
			renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );
	
			deallocateRenderTarget( renderTarget );
	
			_infoMemory.textures --;
	
		}
	
		function onMaterialDispose( event ) {
	
			var material = event.target;
	
			material.removeEventListener( 'dispose', onMaterialDispose );
	
			deallocateMaterial( material );
	
		}
	
		// Buffer deallocation
	
		function deallocateTexture( texture ) {
	
			var textureProperties = properties.get( texture );
	
			if ( texture.image && textureProperties.__image__webglTextureCube ) {
	
				// cube texture
	
				_gl.deleteTexture( textureProperties.__image__webglTextureCube );
	
			} else {
	
				// 2D texture
	
				if ( textureProperties.__webglInit === undefined ) return;
	
				_gl.deleteTexture( textureProperties.__webglTexture );
	
			}
	
			// remove all webgl properties
			properties.delete( texture );
	
		}
	
		function deallocateRenderTarget( renderTarget ) {
	
			var renderTargetProperties = properties.get( renderTarget );
			var textureProperties = properties.get( renderTarget.texture );
	
			if ( ! renderTarget || textureProperties.__webglTexture === undefined ) return;
	
			_gl.deleteTexture( textureProperties.__webglTexture );
	
			if ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {
	
				for ( var i = 0; i < 6; i ++ ) {
	
					_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );
					_gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );
	
				}
	
			} else {
	
				_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );
				_gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );
	
			}
	
			properties.delete( renderTarget.texture );
			properties.delete( renderTarget );
	
		}
	
		function deallocateMaterial( material ) {
	
			releaseMaterialProgramReference( material );
	
			properties.delete( material );
	
		}
	
	
		function releaseMaterialProgramReference( material ) {
	
			var programInfo = properties.get( material ).program;
	
			material.program = undefined;
	
			if ( programInfo !== undefined ) {
	
				programCache.releaseProgram( programInfo );
	
			}
	
		}
	
		// Buffer rendering
	
		this.renderBufferImmediate = function ( object, program, material ) {
	
			state.initAttributes();
	
			var buffers = properties.get( object );
	
			if ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();
			if ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();
			if ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();
			if ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();
	
			var attributes = program.getAttributes();
	
			if ( object.hasPositions ) {
	
				_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );
				_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );
	
				state.enableAttribute( attributes.position );
				_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );
	
			}
	
			if ( object.hasNormals ) {
	
				_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );
	
				if ( material.type !== 'MeshPhongMaterial' && material.type !== 'MeshStandardMaterial' && material.shading === THREE.FlatShading ) {
	
					for ( var i = 0, l = object.count * 3; i < l; i += 9 ) {
	
						var array = object.normalArray;
	
						var nx = ( array[ i + 0 ] + array[ i + 3 ] + array[ i + 6 ] ) / 3;
						var ny = ( array[ i + 1 ] + array[ i + 4 ] + array[ i + 7 ] ) / 3;
						var nz = ( array[ i + 2 ] + array[ i + 5 ] + array[ i + 8 ] ) / 3;
	
						array[ i + 0 ] = nx;
						array[ i + 1 ] = ny;
						array[ i + 2 ] = nz;
	
						array[ i + 3 ] = nx;
						array[ i + 4 ] = ny;
						array[ i + 5 ] = nz;
	
						array[ i + 6 ] = nx;
						array[ i + 7 ] = ny;
						array[ i + 8 ] = nz;
	
					}
	
				}
	
				_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );
	
				state.enableAttribute( attributes.normal );
	
				_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );
	
			}
	
			if ( object.hasUvs && material.map ) {
	
				_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );
				_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );
	
				state.enableAttribute( attributes.uv );
	
				_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );
	
			}
	
			if ( object.hasColors && material.vertexColors !== THREE.NoColors ) {
	
				_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );
				_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );
	
				state.enableAttribute( attributes.color );
	
				_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );
	
			}
	
			state.disableUnusedAttributes();
	
			_gl.drawArrays( _gl.TRIANGLES, 0, object.count );
	
			object.count = 0;
	
		};
	
		this.renderBufferDirect = function ( camera, fog, geometry, material, object, group ) {
	
			setMaterial( material );
	
			var program = setProgram( camera, fog, material, object );
	
			var updateBuffers = false;
			var geometryProgram = geometry.id + '_' + program.id + '_' + material.wireframe;
	
			if ( geometryProgram !== _currentGeometryProgram ) {
	
				_currentGeometryProgram = geometryProgram;
				updateBuffers = true;
	
			}
	
			// morph targets
	
			var morphTargetInfluences = object.morphTargetInfluences;
	
			if ( morphTargetInfluences !== undefined ) {
	
				var activeInfluences = [];
	
				for ( var i = 0, l = morphTargetInfluences.length; i < l; i ++ ) {
	
					var influence = morphTargetInfluences[ i ];
					activeInfluences.push( [ influence, i ] );
	
				}
	
				activeInfluences.sort( absNumericalSort );
	
				if ( activeInfluences.length > 8 ) {
	
					activeInfluences.length = 8;
	
				}
	
				var morphAttributes = geometry.morphAttributes;
	
				for ( var i = 0, l = activeInfluences.length; i < l; i ++ ) {
	
					var influence = activeInfluences[ i ];
					morphInfluences[ i ] = influence[ 0 ];
	
					if ( influence[ 0 ] !== 0 ) {
	
						var index = influence[ 1 ];
	
						if ( material.morphTargets === true && morphAttributes.position ) geometry.addAttribute( 'morphTarget' + i, morphAttributes.position[ index ] );
						if ( material.morphNormals === true && morphAttributes.normal ) geometry.addAttribute( 'morphNormal' + i, morphAttributes.normal[ index ] );
	
					} else {
	
						if ( material.morphTargets === true ) geometry.removeAttribute( 'morphTarget' + i );
						if ( material.morphNormals === true ) geometry.removeAttribute( 'morphNormal' + i );
	
					}
	
				}
	
				var uniforms = program.getUniforms();
	
				if ( uniforms.morphTargetInfluences !== null ) {
	
					_gl.uniform1fv( uniforms.morphTargetInfluences, morphInfluences );
	
				}
	
				updateBuffers = true;
	
			}
	
			//
	
			var index = geometry.index;
			var position = geometry.attributes.position;
	
			if ( material.wireframe === true ) {
	
				index = objects.getWireframeAttribute( geometry );
	
			}
	
			var renderer;
	
			if ( index !== null ) {
	
				renderer = indexedBufferRenderer;
				renderer.setIndex( index );
	
			} else {
	
				renderer = bufferRenderer;
	
			}
	
			if ( updateBuffers ) {
	
				setupVertexAttributes( material, program, geometry );
	
				if ( index !== null ) {
	
					_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, objects.getAttributeBuffer( index ) );
	
				}
	
			}
	
			//
	
			var dataStart = 0;
			var dataCount = Infinity;
	
			if ( index !== null ) {
	
				dataCount = index.count;
	
			} else if ( position !== undefined ) {
	
				dataCount = position.count;
	
			}
	
			var rangeStart = geometry.drawRange.start;
			var rangeCount = geometry.drawRange.count;
	
			var groupStart = group !== null ? group.start : 0;
			var groupCount = group !== null ? group.count : Infinity;
	
			var drawStart = Math.max( dataStart, rangeStart, groupStart );
			var drawEnd = Math.min( dataStart + dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;
	
			var drawCount = Math.max( 0, drawEnd - drawStart + 1 );
	
			//
	
			if ( object instanceof THREE.Mesh ) {
	
				if ( material.wireframe === true ) {
	
					state.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );
					renderer.setMode( _gl.LINES );
	
				} else {
	
					switch ( object.drawMode ) {
	
						case THREE.TrianglesDrawMode:
							renderer.setMode( _gl.TRIANGLES );
							break;
	
						case THREE.TriangleStripDrawMode:
							renderer.setMode( _gl.TRIANGLE_STRIP );
							break;
	
						case THREE.TriangleFanDrawMode:
							renderer.setMode( _gl.TRIANGLE_FAN );
							break;
	
					}
	
				}
	
	
			} else if ( object instanceof THREE.Line ) {
	
				var lineWidth = material.linewidth;
	
				if ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material
	
				state.setLineWidth( lineWidth * getTargetPixelRatio() );
	
				if ( object instanceof THREE.LineSegments ) {
	
					renderer.setMode( _gl.LINES );
	
				} else {
	
					renderer.setMode( _gl.LINE_STRIP );
	
				}
	
			} else if ( object instanceof THREE.Points ) {
	
				renderer.setMode( _gl.POINTS );
	
			}
	
			if ( geometry instanceof THREE.InstancedBufferGeometry && geometry.maxInstancedCount > 0 ) {
	
				renderer.renderInstances( geometry, drawStart, drawCount );
	
			} else {
	
				renderer.render( drawStart, drawCount );
	
			}
	
		};
	
		function setupVertexAttributes( material, program, geometry, startIndex ) {
	
			var extension;
	
			if ( geometry instanceof THREE.InstancedBufferGeometry ) {
	
				extension = extensions.get( 'ANGLE_instanced_arrays' );
	
				if ( extension === null ) {
	
					console.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
					return;
	
				}
	
			}
	
			if ( startIndex === undefined ) startIndex = 0;
	
			state.initAttributes();
	
			var geometryAttributes = geometry.attributes;
	
			var programAttributes = program.getAttributes();
	
			var materialDefaultAttributeValues = material.defaultAttributeValues;
	
			for ( var name in programAttributes ) {
	
				var programAttribute = programAttributes[ name ];
	
				if ( programAttribute >= 0 ) {
	
					var geometryAttribute = geometryAttributes[ name ];
	
					if ( geometryAttribute !== undefined ) {
	
						var size = geometryAttribute.itemSize;
						var buffer = objects.getAttributeBuffer( geometryAttribute );
	
						if ( geometryAttribute instanceof THREE.InterleavedBufferAttribute ) {
	
							var data = geometryAttribute.data;
							var stride = data.stride;
							var offset = geometryAttribute.offset;
	
							if ( data instanceof THREE.InstancedInterleavedBuffer ) {
	
								state.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute, extension );
	
								if ( geometry.maxInstancedCount === undefined ) {
	
									geometry.maxInstancedCount = data.meshPerAttribute * data.count;
	
								}
	
							} else {
	
								state.enableAttribute( programAttribute );
	
							}
	
							_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
							_gl.vertexAttribPointer( programAttribute, size, _gl.FLOAT, false, stride * data.array.BYTES_PER_ELEMENT, ( startIndex * stride + offset ) * data.array.BYTES_PER_ELEMENT );
	
						} else {
	
							if ( geometryAttribute instanceof THREE.InstancedBufferAttribute ) {
	
								state.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute, extension );
	
								if ( geometry.maxInstancedCount === undefined ) {
	
									geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
	
								}
	
							} else {
	
								state.enableAttribute( programAttribute );
	
							}
	
							_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
							_gl.vertexAttribPointer( programAttribute, size, _gl.FLOAT, false, 0, startIndex * size * 4 ); // 4 bytes per Float32
	
						}
	
					} else if ( materialDefaultAttributeValues !== undefined ) {
	
						var value = materialDefaultAttributeValues[ name ];
	
						if ( value !== undefined ) {
	
							switch ( value.length ) {
	
								case 2:
									_gl.vertexAttrib2fv( programAttribute, value );
									break;
	
								case 3:
									_gl.vertexAttrib3fv( programAttribute, value );
									break;
	
								case 4:
									_gl.vertexAttrib4fv( programAttribute, value );
									break;
	
								default:
									_gl.vertexAttrib1fv( programAttribute, value );
	
							}
	
						}
	
					}
	
				}
	
			}
	
			state.disableUnusedAttributes();
	
		}
	
		// Sorting
	
		function absNumericalSort( a, b ) {
	
			return Math.abs( b[ 0 ] ) - Math.abs( a[ 0 ] );
	
		}
	
		function painterSortStable ( a, b ) {
	
			if ( a.object.renderOrder !== b.object.renderOrder ) {
	
				return a.object.renderOrder - b.object.renderOrder;
	
			} else if ( a.material.id !== b.material.id ) {
	
				return a.material.id - b.material.id;
	
			} else if ( a.z !== b.z ) {
	
				return a.z - b.z;
	
			} else {
	
				return a.id - b.id;
	
			}
	
		}
	
		function reversePainterSortStable ( a, b ) {
	
			if ( a.object.renderOrder !== b.object.renderOrder ) {
	
				return a.object.renderOrder - b.object.renderOrder;
	
			} if ( a.z !== b.z ) {
	
				return b.z - a.z;
	
			} else {
	
				return a.id - b.id;
	
			}
	
		}
	
		// Rendering
	
		this.render = function ( scene, camera, renderTarget, forceClear ) {
	
			if ( camera instanceof THREE.Camera === false ) {
	
				console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
				return;
	
			}
	
			var fog = scene.fog;
	
			// reset caching for this frame
	
			_currentGeometryProgram = '';
			_currentMaterialId = - 1;
			_currentCamera = null;
	
			// update scene graph
	
			if ( scene.autoUpdate === true ) scene.updateMatrixWorld();
	
			// update camera matrices and frustum
	
			if ( camera.parent === null ) camera.updateMatrixWorld();
	
			camera.matrixWorldInverse.getInverse( camera.matrixWorld );
	
			_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
			_frustum.setFromMatrix( _projScreenMatrix );
	
			lights.length = 0;
	
			opaqueObjectsLastIndex = - 1;
			transparentObjectsLastIndex = - 1;
	
			sprites.length = 0;
			lensFlares.length = 0;
	
			projectObject( scene, camera );
	
			opaqueObjects.length = opaqueObjectsLastIndex + 1;
			transparentObjects.length = transparentObjectsLastIndex + 1;
	
			if ( _this.sortObjects === true ) {
	
				opaqueObjects.sort( painterSortStable );
				transparentObjects.sort( reversePainterSortStable );
	
			}
	
			setupLights( lights, camera );
	
			//
	
			shadowMap.render( scene, camera );
	
			//
	
			_infoRender.calls = 0;
			_infoRender.vertices = 0;
			_infoRender.faces = 0;
			_infoRender.points = 0;
	
			if ( renderTarget === undefined ) {
	
				renderTarget = null;
	
			}
	
			this.setRenderTarget( renderTarget );
	
			if ( this.autoClear || forceClear ) {
	
				this.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );
	
			}
	
			//
	
			if ( scene.overrideMaterial ) {
	
				var overrideMaterial = scene.overrideMaterial;
	
				renderObjects( opaqueObjects, camera, fog, overrideMaterial );
				renderObjects( transparentObjects, camera, fog, overrideMaterial );
	
			} else {
	
				// opaque pass (front-to-back order)
	
				state.setBlending( THREE.NoBlending );
				renderObjects( opaqueObjects, camera, fog );
	
				// transparent pass (back-to-front order)
	
				renderObjects( transparentObjects, camera, fog );
	
			}
	
			// custom render plugins (post pass)
	
			spritePlugin.render( scene, camera );
			lensFlarePlugin.render( scene, camera, _currentViewport );
	
			// Generate mipmap if we're using any kind of mipmap filtering
	
			if ( renderTarget ) {
	
				var texture = renderTarget.texture;
	
				if ( texture.generateMipmaps && isPowerOfTwo( renderTarget ) &&
						texture.minFilter !== THREE.NearestFilter &&
						texture.minFilter !== THREE.LinearFilter ) {
	
					updateRenderTargetMipmap( renderTarget );
	
				}
	
			}
	
			// Ensure depth buffer writing is enabled so it can be cleared on next render
	
			state.setDepthTest( true );
			state.setDepthWrite( true );
			state.setColorWrite( true );
	
			// _gl.finish();
	
		};
	
		function pushRenderItem( object, geometry, material, z, group ) {
	
			var array, index;
	
			// allocate the next position in the appropriate array
	
			if ( material.transparent ) {
	
				array = transparentObjects;
				index = ++ transparentObjectsLastIndex;
	
			} else {
	
				array = opaqueObjects;
				index = ++ opaqueObjectsLastIndex;
	
			}
	
			// recycle existing render item or grow the array
	
			var renderItem = array[ index ];
	
			if ( renderItem !== undefined ) {
	
				renderItem.id = object.id;
				renderItem.object = object;
				renderItem.geometry = geometry;
				renderItem.material = material;
				renderItem.z = _vector3.z;
				renderItem.group = group;
	
			} else {
	
				renderItem = {
					id: object.id,
					object: object,
					geometry: geometry,
					material: material,
					z: _vector3.z,
					group: group
				};
	
				// assert( index === array.length );
				array.push( renderItem );
	
			}
	
		}
	
		function projectObject( object, camera ) {
	
			if ( object.visible === false ) return;
	
			if ( object.layers.test( camera.layers ) ) {
	
				if ( object instanceof THREE.Light ) {
	
					lights.push( object );
	
				} else if ( object instanceof THREE.Sprite ) {
	
					if ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) {
	
						sprites.push( object );
	
					}
	
				} else if ( object instanceof THREE.LensFlare ) {
	
					lensFlares.push( object );
	
				} else if ( object instanceof THREE.ImmediateRenderObject ) {
	
					if ( _this.sortObjects === true ) {
	
						_vector3.setFromMatrixPosition( object.matrixWorld );
						_vector3.applyProjection( _projScreenMatrix );
	
					}
	
					pushRenderItem( object, null, object.material, _vector3.z, null );
	
				} else if ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points ) {
	
					if ( object instanceof THREE.SkinnedMesh ) {
	
						object.skeleton.update();
	
					}
	
					if ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) {
	
						var material = object.material;
	
						if ( material.visible === true ) {
	
							if ( _this.sortObjects === true ) {
	
								_vector3.setFromMatrixPosition( object.matrixWorld );
								_vector3.applyProjection( _projScreenMatrix );
	
							}
	
							var geometry = objects.update( object );
	
							if ( material instanceof THREE.MultiMaterial ) {
	
								var groups = geometry.groups;
								var materials = material.materials;
	
								for ( var i = 0, l = groups.length; i < l; i ++ ) {
	
									var group = groups[ i ];
									var groupMaterial = materials[ group.materialIndex ];
	
									if ( groupMaterial.visible === true ) {
	
										pushRenderItem( object, geometry, groupMaterial, _vector3.z, group );
	
									}
	
								}
	
							} else {
	
								pushRenderItem( object, geometry, material, _vector3.z, null );
	
							}
	
						}
	
					}
	
				}
	
			}
	
			var children = object.children;
	
			for ( var i = 0, l = children.length; i < l; i ++ ) {
	
				projectObject( children[ i ], camera );
	
			}
	
		}
	
		function renderObjects( renderList, camera, fog, overrideMaterial ) {
	
			for ( var i = 0, l = renderList.length; i < l; i ++ ) {
	
				var renderItem = renderList[ i ];
	
				var object = renderItem.object;
				var geometry = renderItem.geometry;
				var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
				var group = renderItem.group;
	
				object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
				object.normalMatrix.getNormalMatrix( object.modelViewMatrix );
	
				if ( object instanceof THREE.ImmediateRenderObject ) {
	
					setMaterial( material );
	
					var program = setProgram( camera, fog, material, object );
	
					_currentGeometryProgram = '';
	
					object.render( function ( object ) {
	
						_this.renderBufferImmediate( object, program, material );
	
					} );
	
				} else {
	
					_this.renderBufferDirect( camera, fog, geometry, material, object, group );
	
				}
	
			}
	
		}
	
		function initMaterial( material, fog, object ) {
	
			var materialProperties = properties.get( material );
	
			var parameters = programCache.getParameters( material, _lights, fog, object );
			var code = programCache.getProgramCode( material, parameters );
	
			var program = materialProperties.program;
			var programChange = true;
	
			if ( program === undefined ) {
	
				// new material
				material.addEventListener( 'dispose', onMaterialDispose );
	
			} else if ( program.code !== code ) {
	
				// changed glsl or parameters
				releaseMaterialProgramReference( material );
	
			} else if ( parameters.shaderID !== undefined ) {
	
				// same glsl and uniform list
				return;
	
			} else {
	
				// only rebuild uniform list
				programChange = false;
	
			}
	
			if ( programChange ) {
	
				if ( parameters.shaderID ) {
	
					var shader = THREE.ShaderLib[ parameters.shaderID ];
	
					materialProperties.__webglShader = {
						name: material.type,
						uniforms: THREE.UniformsUtils.clone( shader.uniforms ),
						vertexShader: shader.vertexShader,
						fragmentShader: shader.fragmentShader
					};
	
				} else {
	
					materialProperties.__webglShader = {
						name: material.type,
						uniforms: material.uniforms,
						vertexShader: material.vertexShader,
						fragmentShader: material.fragmentShader
					};
	
				}
	
				material.__webglShader = materialProperties.__webglShader;
	
				program = programCache.acquireProgram( material, parameters, code );
	
				materialProperties.program = program;
				material.program = program;
	
			}
	
			var attributes = program.getAttributes();
	
			if ( material.morphTargets ) {
	
				material.numSupportedMorphTargets = 0;
	
				for ( var i = 0; i < _this.maxMorphTargets; i ++ ) {
	
					if ( attributes[ 'morphTarget' + i ] >= 0 ) {
	
						material.numSupportedMorphTargets ++;
	
					}
	
				}
	
			}
	
			if ( material.morphNormals ) {
	
				material.numSupportedMorphNormals = 0;
	
				for ( var i = 0; i < _this.maxMorphNormals; i ++ ) {
	
					if ( attributes[ 'morphNormal' + i ] >= 0 ) {
	
						material.numSupportedMorphNormals ++;
	
					}
	
				}
	
			}
	
			materialProperties.uniformsList = [];
	
			var uniforms = materialProperties.__webglShader.uniforms,
				uniformLocations = materialProperties.program.getUniforms();
	
			for ( var u in uniforms ) {
	
				var location = uniformLocations[ u ];
	
				if ( location ) {
	
					materialProperties.uniformsList.push( [ materialProperties.__webglShader.uniforms[ u ], location ] );
	
				}
	
			}
	
			if ( material instanceof THREE.MeshPhongMaterial ||
					material instanceof THREE.MeshLambertMaterial ||
					material instanceof THREE.MeshStandardMaterial ||
					material.lights ) {
	
				// store the light setup it was created for
	
				materialProperties.lightsHash = _lights.hash;
	
				// wire up the material to this renderer's lighting state
	
				uniforms.ambientLightColor.value = _lights.ambient;
				uniforms.directionalLights.value = _lights.directional;
				uniforms.spotLights.value = _lights.spot;
				uniforms.pointLights.value = _lights.point;
				uniforms.hemisphereLights.value = _lights.hemi;
	
				uniforms.directionalShadowMap.value = _lights.directionalShadowMap;
				uniforms.directionalShadowMatrix.value = _lights.directionalShadowMatrix;
				uniforms.spotShadowMap.value = _lights.spotShadowMap;
				uniforms.spotShadowMatrix.value = _lights.spotShadowMatrix;
				uniforms.pointShadowMap.value = _lights.pointShadowMap;
				uniforms.pointShadowMatrix.value = _lights.pointShadowMatrix;
	
			}
	
			// detect dynamic uniforms
	
			materialProperties.hasDynamicUniforms = false;
	
			for ( var j = 0, jl = materialProperties.uniformsList.length; j < jl; j ++ ) {
	
				var uniform = materialProperties.uniformsList[ j ][ 0 ];
	
				if ( uniform.dynamic === true ) {
	
					materialProperties.hasDynamicUniforms = true;
					break;
	
				}
	
			}
	
		}
	
		function setMaterial( material ) {
	
			setMaterialFaces( material );
	
			if ( material.transparent === true ) {
	
				state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha );
	
			} else {
	
				state.setBlending( THREE.NoBlending );
	
			}
	
			state.setDepthFunc( material.depthFunc );
			state.setDepthTest( material.depthTest );
			state.setDepthWrite( material.depthWrite );
			state.setColorWrite( material.colorWrite );
			state.setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );
	
		}
	
		function setMaterialFaces( material ) {
	
			material.side !== THREE.DoubleSide ? state.enable( _gl.CULL_FACE ) : state.disable( _gl.CULL_FACE );
			state.setFlipSided( material.side === THREE.BackSide );
	
		}
	
		function setProgram( camera, fog, material, object ) {
	
			_usedTextureUnits = 0;
	
			var materialProperties = properties.get( material );
	
			if ( materialProperties.program === undefined ) {
	
				material.needsUpdate = true;
	
			}
	
			if ( materialProperties.lightsHash !== undefined &&
				materialProperties.lightsHash !== _lights.hash ) {
	
				material.needsUpdate = true;
	
			}
	
			if ( material.needsUpdate ) {
	
				initMaterial( material, fog, object );
				material.needsUpdate = false;
	
			}
	
			var refreshProgram = false;
			var refreshMaterial = false;
			var refreshLights = false;
	
			var program = materialProperties.program,
				p_uniforms = program.getUniforms(),
				m_uniforms = materialProperties.__webglShader.uniforms;
	
			if ( program.id !== _currentProgram ) {
	
				_gl.useProgram( program.program );
				_currentProgram = program.id;
	
				refreshProgram = true;
				refreshMaterial = true;
				refreshLights = true;
	
			}
	
			if ( material.id !== _currentMaterialId ) {
	
				_currentMaterialId = material.id;
	
				refreshMaterial = true;
	
			}
	
			if ( refreshProgram || camera !== _currentCamera ) {
	
				_gl.uniformMatrix4fv( p_uniforms.projectionMatrix, false, camera.projectionMatrix.elements );
	
				if ( capabilities.logarithmicDepthBuffer ) {
	
					_gl.uniform1f( p_uniforms.logDepthBufFC, 2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );
	
				}
	
	
				if ( camera !== _currentCamera ) {
	
					_currentCamera = camera;
	
					// lighting uniforms depend on the camera so enforce an update
					// now, in case this material supports lights - or later, when
					// the next material that does gets activated:
	
					refreshMaterial = true;		// set to true on material change
					refreshLights = true;		// remains set until update done
	
				}
	
				// load material specific uniforms
				// (shader material also gets them for the sake of genericity)
	
				if ( material instanceof THREE.ShaderMaterial ||
					 material instanceof THREE.MeshPhongMaterial ||
					 material instanceof THREE.MeshStandardMaterial ||
					 material.envMap ) {
	
					if ( p_uniforms.cameraPosition !== undefined ) {
	
						_vector3.setFromMatrixPosition( camera.matrixWorld );
						_gl.uniform3f( p_uniforms.cameraPosition, _vector3.x, _vector3.y, _vector3.z );
	
					}
	
				}
	
				if ( material instanceof THREE.MeshPhongMaterial ||
					 material instanceof THREE.MeshLambertMaterial ||
					 material instanceof THREE.MeshBasicMaterial ||
					 material instanceof THREE.MeshStandardMaterial ||
					 material instanceof THREE.ShaderMaterial ||
					 material.skinning ) {
	
					if ( p_uniforms.viewMatrix !== undefined ) {
	
						_gl.uniformMatrix4fv( p_uniforms.viewMatrix, false, camera.matrixWorldInverse.elements );
	
					}
	
				}
	
			}
	
			// skinning uniforms must be set even if material didn't change
			// auto-setting of texture unit for bone texture must go before other textures
			// not sure why, but otherwise weird things happen
	
			if ( material.skinning ) {
	
				if ( object.bindMatrix && p_uniforms.bindMatrix !== undefined ) {
	
					_gl.uniformMatrix4fv( p_uniforms.bindMatrix, false, object.bindMatrix.elements );
	
				}
	
				if ( object.bindMatrixInverse && p_uniforms.bindMatrixInverse !== undefined ) {
	
					_gl.uniformMatrix4fv( p_uniforms.bindMatrixInverse, false, object.bindMatrixInverse.elements );
	
				}
	
				if ( capabilities.floatVertexTextures && object.skeleton && object.skeleton.useVertexTexture ) {
	
					if ( p_uniforms.boneTexture !== undefined ) {
	
						var textureUnit = getTextureUnit();
	
						_gl.uniform1i( p_uniforms.boneTexture, textureUnit );
						_this.setTexture( object.skeleton.boneTexture, textureUnit );
	
					}
	
					if ( p_uniforms.boneTextureWidth !== undefined ) {
	
						_gl.uniform1i( p_uniforms.boneTextureWidth, object.skeleton.boneTextureWidth );
	
					}
	
					if ( p_uniforms.boneTextureHeight !== undefined ) {
	
						_gl.uniform1i( p_uniforms.boneTextureHeight, object.skeleton.boneTextureHeight );
	
					}
	
				} else if ( object.skeleton && object.skeleton.boneMatrices ) {
	
					if ( p_uniforms.boneGlobalMatrices !== undefined ) {
	
						_gl.uniformMatrix4fv( p_uniforms.boneGlobalMatrices, false, object.skeleton.boneMatrices );
	
					}
	
				}
	
			}
	
			if ( refreshMaterial ) {
	
				if ( material instanceof THREE.MeshPhongMaterial ||
					 material instanceof THREE.MeshLambertMaterial ||
					 material instanceof THREE.MeshStandardMaterial ||
					 material.lights ) {
	
					// the current material requires lighting info
	
					// note: all lighting uniforms are always set correctly
					// they simply reference the renderer's state for their
					// values
					//
					// use the current material's .needsUpdate flags to set
					// the GL state when required
	
					markUniformsLightsNeedsUpdate( m_uniforms, refreshLights );
	
				}
	
				// refresh uniforms common to several materials
	
				if ( fog && material.fog ) {
	
					refreshUniformsFog( m_uniforms, fog );
	
				}
	
				if ( material instanceof THREE.MeshBasicMaterial ||
					 material instanceof THREE.MeshLambertMaterial ||
					 material instanceof THREE.MeshPhongMaterial ||
					 material instanceof THREE.MeshStandardMaterial ) {
	
					refreshUniformsCommon( m_uniforms, material );
	
				}
	
				// refresh single material specific uniforms
	
				if ( material instanceof THREE.LineBasicMaterial ) {
	
					refreshUniformsLine( m_uniforms, material );
	
				} else if ( material instanceof THREE.LineDashedMaterial ) {
	
					refreshUniformsLine( m_uniforms, material );
					refreshUniformsDash( m_uniforms, material );
	
				} else if ( material instanceof THREE.PointsMaterial ) {
	
					refreshUniformsPoints( m_uniforms, material );
	
				} else if ( material instanceof THREE.MeshLambertMaterial ) {
	
					refreshUniformsLambert( m_uniforms, material );
	
				} else if ( material instanceof THREE.MeshPhongMaterial ) {
	
					refreshUniformsPhong( m_uniforms, material );
	
				} else if ( material instanceof THREE.MeshStandardMaterial ) {
	
					refreshUniformsStandard( m_uniforms, material );
	
				} else if ( material instanceof THREE.MeshDepthMaterial ) {
	
					m_uniforms.mNear.value = camera.near;
					m_uniforms.mFar.value = camera.far;
					m_uniforms.opacity.value = material.opacity;
	
				} else if ( material instanceof THREE.MeshNormalMaterial ) {
	
					m_uniforms.opacity.value = material.opacity;
	
				}
	
				// load common uniforms
	
				loadUniformsGeneric( materialProperties.uniformsList );
	
			}
	
			loadUniformsMatrices( p_uniforms, object );
	
			if ( p_uniforms.modelMatrix !== undefined ) {
	
				_gl.uniformMatrix4fv( p_uniforms.modelMatrix, false, object.matrixWorld.elements );
	
			}
	
			if ( materialProperties.hasDynamicUniforms === true ) {
	
				updateDynamicUniforms( materialProperties.uniformsList, object, camera );
	
			}
	
			return program;
	
		}
	
		function updateDynamicUniforms ( uniforms, object, camera ) {
	
			var dynamicUniforms = [];
	
			for ( var j = 0, jl = uniforms.length; j < jl; j ++ ) {
	
				var uniform = uniforms[ j ][ 0 ];
				var onUpdateCallback = uniform.onUpdateCallback;
	
				if ( onUpdateCallback !== undefined ) {
	
					onUpdateCallback.bind( uniform )( object, camera );
					dynamicUniforms.push( uniforms[ j ] );
	
				}
	
			}
	
			loadUniformsGeneric( dynamicUniforms );
	
		}
	
		// Uniforms (refresh uniforms objects)
	
		function refreshUniformsCommon ( uniforms, material ) {
	
			uniforms.opacity.value = material.opacity;
	
			uniforms.diffuse.value = material.color;
	
			if ( material.emissive ) {
	
				uniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );
	
			}
	
			uniforms.map.value = material.map;
			uniforms.specularMap.value = material.specularMap;
			uniforms.alphaMap.value = material.alphaMap;
	
			if ( material.aoMap ) {
	
				uniforms.aoMap.value = material.aoMap;
				uniforms.aoMapIntensity.value = material.aoMapIntensity;
	
			}
	
			// uv repeat and offset setting priorities
			// 1. color map
			// 2. specular map
			// 3. normal map
			// 4. bump map
			// 5. alpha map
			// 6. emissive map
	
			var uvScaleMap;
	
			if ( material.map ) {
	
				uvScaleMap = material.map;
	
			} else if ( material.specularMap ) {
	
				uvScaleMap = material.specularMap;
	
			} else if ( material.displacementMap ) {
	
				uvScaleMap = material.displacementMap;
	
			} else if ( material.normalMap ) {
	
				uvScaleMap = material.normalMap;
	
			} else if ( material.bumpMap ) {
	
				uvScaleMap = material.bumpMap;
	
			} else if ( material.roughnessMap ) {
	
				uvScaleMap = material.roughnessMap;
	
			} else if ( material.metalnessMap ) {
	
				uvScaleMap = material.metalnessMap;
	
			} else if ( material.alphaMap ) {
	
				uvScaleMap = material.alphaMap;
	
			} else if ( material.emissiveMap ) {
	
				uvScaleMap = material.emissiveMap;
	
			}
	
			if ( uvScaleMap !== undefined ) {
	
				if ( uvScaleMap instanceof THREE.WebGLRenderTarget ) {
	
					uvScaleMap = uvScaleMap.texture;
	
				}
	
				var offset = uvScaleMap.offset;
				var repeat = uvScaleMap.repeat;
	
				uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );
	
			}
	
			uniforms.envMap.value = material.envMap;
			uniforms.flipEnvMap.value = ( material.envMap instanceof THREE.WebGLRenderTargetCube ) ? 1 : - 1;
	
			uniforms.reflectivity.value = material.reflectivity;
			uniforms.refractionRatio.value = material.refractionRatio;
	
		}
	
		function refreshUniformsLine ( uniforms, material ) {
	
			uniforms.diffuse.value = material.color;
			uniforms.opacity.value = material.opacity;
	
		}
	
		function refreshUniformsDash ( uniforms, material ) {
	
			uniforms.dashSize.value = material.dashSize;
			uniforms.totalSize.value = material.dashSize + material.gapSize;
			uniforms.scale.value = material.scale;
	
		}
	
		function refreshUniformsPoints ( uniforms, material ) {
	
			uniforms.diffuse.value = material.color;
			uniforms.opacity.value = material.opacity;
			uniforms.size.value = material.size * _pixelRatio;
			uniforms.scale.value = _canvas.clientHeight / 2.0; // TODO: Cache this.
	
			uniforms.map.value = material.map;
	
			if ( material.map !== null ) {
	
				var offset = material.map.offset;
				var repeat = material.map.repeat;
	
				uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );
	
			}
	
		}
	
		function refreshUniformsFog ( uniforms, fog ) {
	
			uniforms.fogColor.value = fog.color;
	
			if ( fog instanceof THREE.Fog ) {
	
				uniforms.fogNear.value = fog.near;
				uniforms.fogFar.value = fog.far;
	
			} else if ( fog instanceof THREE.FogExp2 ) {
	
				uniforms.fogDensity.value = fog.density;
	
			}
	
		}
	
		function refreshUniformsLambert ( uniforms, material ) {
	
			if ( material.lightMap ) {
	
				uniforms.lightMap.value = material.lightMap;
				uniforms.lightMapIntensity.value = material.lightMapIntensity;
	
			}
	
			if ( material.emissiveMap ) {
	
				uniforms.emissiveMap.value = material.emissiveMap;
	
			}
	
		}
	
		function refreshUniformsPhong ( uniforms, material ) {
	
			uniforms.specular.value = material.specular;
			uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )
	
			if ( material.lightMap ) {
	
				uniforms.lightMap.value = material.lightMap;
				uniforms.lightMapIntensity.value = material.lightMapIntensity;
	
			}
	
			if ( material.emissiveMap ) {
	
				uniforms.emissiveMap.value = material.emissiveMap;
	
			}
	
			if ( material.bumpMap ) {
	
				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
	
			}
	
			if ( material.normalMap ) {
	
				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy( material.normalScale );
	
			}
	
			if ( material.displacementMap ) {
	
				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;
	
			}
	
		}
	
		function refreshUniformsStandard ( uniforms, material ) {
	
			uniforms.roughness.value = material.roughness;
			uniforms.metalness.value = material.metalness;
	
			if ( material.roughnessMap ) {
	
				uniforms.roughnessMap.value = material.roughnessMap;
	
			}
	
			if ( material.metalnessMap ) {
	
				uniforms.metalnessMap.value = material.metalnessMap;
	
			}
	
			if ( material.lightMap ) {
	
				uniforms.lightMap.value = material.lightMap;
				uniforms.lightMapIntensity.value = material.lightMapIntensity;
	
			}
	
			if ( material.emissiveMap ) {
	
				uniforms.emissiveMap.value = material.emissiveMap;
	
			}
	
			if ( material.bumpMap ) {
	
				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
	
			}
	
			if ( material.normalMap ) {
	
				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy( material.normalScale );
	
			}
	
			if ( material.displacementMap ) {
	
				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;
	
			}
	
			if ( material.envMap ) {
	
				//uniforms.envMap.value = material.envMap; // part of uniforms common
				uniforms.envMapIntensity.value = material.envMapIntensity;
	
			}
	
		}
	
		// If uniforms are marked as clean, they don't need to be loaded to the GPU.
	
		function markUniformsLightsNeedsUpdate ( uniforms, value ) {
	
			uniforms.ambientLightColor.needsUpdate = value;
	
			uniforms.directionalLights.needsUpdate = value;
			uniforms.pointLights.needsUpdate = value;
			uniforms.spotLights.needsUpdate = value;
			uniforms.hemisphereLights.needsUpdate = value;
	
		}
	
		// Uniforms (load to GPU)
	
		function loadUniformsMatrices ( uniforms, object ) {
	
			_gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, object.modelViewMatrix.elements );
	
			if ( uniforms.normalMatrix ) {
	
				_gl.uniformMatrix3fv( uniforms.normalMatrix, false, object.normalMatrix.elements );
	
			}
	
		}
	
		function getTextureUnit() {
	
			var textureUnit = _usedTextureUnits;
	
			if ( textureUnit >= capabilities.maxTextures ) {
	
				console.warn( 'WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );
	
			}
	
			_usedTextureUnits += 1;
	
			return textureUnit;
	
		}
	
		function loadUniformsGeneric ( uniforms ) {
	
			var texture, textureUnit;
	
			for ( var j = 0, jl = uniforms.length; j < jl; j ++ ) {
	
				var uniform = uniforms[ j ][ 0 ];
	
				// needsUpdate property is not added to all uniforms.
				if ( uniform.needsUpdate === false ) continue;
	
				var type = uniform.type;
				var value = uniform.value;
				var location = uniforms[ j ][ 1 ];
	
				switch ( type ) {
	
					case '1i':
						_gl.uniform1i( location, value );
						break;
	
					case '1f':
						_gl.uniform1f( location, value );
						break;
	
					case '2f':
						_gl.uniform2f( location, value[ 0 ], value[ 1 ] );
						break;
	
					case '3f':
						_gl.uniform3f( location, value[ 0 ], value[ 1 ], value[ 2 ] );
						break;
	
					case '4f':
						_gl.uniform4f( location, value[ 0 ], value[ 1 ], value[ 2 ], value[ 3 ] );
						break;
	
					case '1iv':
						_gl.uniform1iv( location, value );
						break;
	
					case '3iv':
						_gl.uniform3iv( location, value );
						break;
	
					case '1fv':
						_gl.uniform1fv( location, value );
						break;
	
					case '2fv':
						_gl.uniform2fv( location, value );
						break;
	
					case '3fv':
						_gl.uniform3fv( location, value );
						break;
	
					case '4fv':
						_gl.uniform4fv( location, value );
						break;
	
					case 'Matrix2fv':
						_gl.uniformMatrix2fv( location, false, value );
						break;
	
					case 'Matrix3fv':
						_gl.uniformMatrix3fv( location, false, value );
						break;
	
					case 'Matrix4fv':
						_gl.uniformMatrix4fv( location, false, value );
						break;
	
					//
	
					case 'i':
	
						// single integer
						_gl.uniform1i( location, value );
	
						break;
	
					case 'f':
	
						// single float
						_gl.uniform1f( location, value );
	
						break;
	
					case 'v2':
	
						// single THREE.Vector2
						_gl.uniform2f( location, value.x, value.y );
	
						break;
	
					case 'v3':
	
						// single THREE.Vector3
						_gl.uniform3f( location, value.x, value.y, value.z );
	
						break;
	
					case 'v4':
	
						// single THREE.Vector4
						_gl.uniform4f( location, value.x, value.y, value.z, value.w );
	
						break;
	
					case 'c':
	
						// single THREE.Color
						_gl.uniform3f( location, value.r, value.g, value.b );
	
						break;
	
					/*
					case 's':
	
						// TODO: Optimize this.
						for( var propertyName in uniform.properties ) {
	
							var property = uniform.properties[ propertyName ];
							var locationProperty =  location[ propertyName ];
							var valueProperty = value[ propertyName ];
	
							switch( property.type ) {
								case 'i':
									_gl.uniform1i( locationProperty, valueProperty );
									break;
								case 'f':
									_gl.uniform1f( locationProperty, valueProperty );
									break;
								case 'v2':
									_gl.uniform2f( locationProperty, valueProperty.x, valueProperty.y );
									break;
								case 'v3':
									_gl.uniform3f( locationProperty, valueProperty.x, valueProperty.y, valueProperty.z );
									break;
								case 'v4':
									_gl.uniform4f( locationProperty, valueProperty.x, valueProperty.y, valueProperty.z, valueProperty.w );
									break;
								case 'c':
									_gl.uniform3f( locationProperty, valueProperty.r, valueProperty.g, valueProperty.b );
									break;
							};
	
						}
	
						break;
					*/
	
					case 'sa':
	
						// TODO: Optimize this.
						for ( var i = 0; i < value.length; i ++ ) {
	
							for ( var propertyName in uniform.properties ) {
	
								var property = uniform.properties[ propertyName ];
								var locationProperty =  location[ i ][ propertyName ];
								var valueProperty = value[ i ][ propertyName ];
	
								switch ( property.type ) {
									case 'i':
										_gl.uniform1i( locationProperty, valueProperty );
										break;
									case 'f':
										_gl.uniform1f( locationProperty, valueProperty );
										break;
									case 'v2':
										_gl.uniform2f( locationProperty, valueProperty.x, valueProperty.y );
										break;
									case 'v3':
										_gl.uniform3f( locationProperty, valueProperty.x, valueProperty.y, valueProperty.z );
										break;
									case 'v4':
										_gl.uniform4f( locationProperty, valueProperty.x, valueProperty.y, valueProperty.z, valueProperty.w );
										break;
									case 'c':
										_gl.uniform3f( locationProperty, valueProperty.r, valueProperty.g, valueProperty.b );
										break;
									case 'm4':
										_gl.uniformMatrix4fv( locationProperty, false, valueProperty.elements );
										break;
								}
	
							}
	
						}
	
						break;
	
					case 'iv1':
	
						// flat array of integers (JS or typed array)
						_gl.uniform1iv( location, value );
	
						break;
	
					case 'iv':
	
						// flat array of integers with 3 x N size (JS or typed array)
						_gl.uniform3iv( location, value );
	
						break;
	
					case 'fv1':
	
						// flat array of floats (JS or typed array)
						_gl.uniform1fv( location, value );
	
						break;
	
					case 'fv':
	
						// flat array of floats with 3 x N size (JS or typed array)
						_gl.uniform3fv( location, value );
	
						break;
	
					case 'v2v':
	
						// array of THREE.Vector2
	
						if ( uniform._array === undefined ) {
	
							uniform._array = new Float32Array( 2 * value.length );
	
						}
	
						for ( var i = 0, i2 = 0, il = value.length; i < il; i ++, i2 += 2 ) {
	
							uniform._array[ i2 + 0 ] = value[ i ].x;
							uniform._array[ i2 + 1 ] = value[ i ].y;
	
						}
	
						_gl.uniform2fv( location, uniform._array );
	
						break;
	
					case 'v3v':
	
						// array of THREE.Vector3
	
						if ( uniform._array === undefined ) {
	
							uniform._array = new Float32Array( 3 * value.length );
	
						}
	
						for ( var i = 0, i3 = 0, il = value.length; i < il; i ++, i3 += 3 ) {
	
							uniform._array[ i3 + 0 ] = value[ i ].x;
							uniform._array[ i3 + 1 ] = value[ i ].y;
							uniform._array[ i3 + 2 ] = value[ i ].z;
	
						}
	
						_gl.uniform3fv( location, uniform._array );
	
						break;
	
					case 'v4v':
	
						// array of THREE.Vector4
	
						if ( uniform._array === undefined ) {
	
							uniform._array = new Float32Array( 4 * value.length );
	
						}
	
						for ( var i = 0, i4 = 0, il = value.length; i < il; i ++, i4 += 4 ) {
	
							uniform._array[ i4 + 0 ] = value[ i ].x;
							uniform._array[ i4 + 1 ] = value[ i ].y;
							uniform._array[ i4 + 2 ] = value[ i ].z;
							uniform._array[ i4 + 3 ] = value[ i ].w;
	
						}
	
						_gl.uniform4fv( location, uniform._array );
	
						break;
	
					case 'm2':
	
						// single THREE.Matrix2
						_gl.uniformMatrix2fv( location, false, value.elements );
	
						break;
	
					case 'm3':
	
						// single THREE.Matrix3
						_gl.uniformMatrix3fv( location, false, value.elements );
	
						break;
	
					case 'm3v':
	
						// array of THREE.Matrix3
	
						if ( uniform._array === undefined ) {
	
							uniform._array = new Float32Array( 9 * value.length );
	
						}
	
						for ( var i = 0, il = value.length; i < il; i ++ ) {
	
							value[ i ].flattenToArrayOffset( uniform._array, i * 9 );
	
						}
	
						_gl.uniformMatrix3fv( location, false, uniform._array );
	
						break;
	
					case 'm4':
	
						// single THREE.Matrix4
						_gl.uniformMatrix4fv( location, false, value.elements );
	
						break;
	
					case 'm4v':
	
						// array of THREE.Matrix4
	
						if ( uniform._array === undefined ) {
	
							uniform._array = new Float32Array( 16 * value.length );
	
						}
	
						for ( var i = 0, il = value.length; i < il; i ++ ) {
	
							value[ i ].flattenToArrayOffset( uniform._array, i * 16 );
	
						}
	
						_gl.uniformMatrix4fv( location, false, uniform._array );
	
						break;
	
					case 't':
	
						// single THREE.Texture (2d or cube)
	
						texture = value;
						textureUnit = getTextureUnit();
	
						_gl.uniform1i( location, textureUnit );
	
						if ( ! texture ) continue;
	
						if ( texture instanceof THREE.CubeTexture ||
							 ( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {
	
							// CompressedTexture can have Array in image :/
	
							setCubeTexture( texture, textureUnit );
	
						} else if ( texture instanceof THREE.WebGLRenderTargetCube ) {
	
							setCubeTextureDynamic( texture.texture, textureUnit );
	
						} else if ( texture instanceof THREE.WebGLRenderTarget ) {
	
							_this.setTexture( texture.texture, textureUnit );
	
						} else {
	
							_this.setTexture( texture, textureUnit );
	
						}
	
						break;
	
					case 'tv':
	
						// array of THREE.Texture (2d or cube)
	
						if ( uniform._array === undefined ) {
	
							uniform._array = [];
	
						}
	
						for ( var i = 0, il = uniform.value.length; i < il; i ++ ) {
	
							uniform._array[ i ] = getTextureUnit();
	
						}
	
						_gl.uniform1iv( location, uniform._array );
	
						for ( var i = 0, il = uniform.value.length; i < il; i ++ ) {
	
							texture = uniform.value[ i ];
							textureUnit = uniform._array[ i ];
	
							if ( ! texture ) continue;
	
							if ( texture instanceof THREE.CubeTexture ||
								 ( texture.image instanceof Array && texture.image.length === 6 ) ) {
	
								// CompressedTexture can have Array in image :/
	
								setCubeTexture( texture, textureUnit );
	
							} else if ( texture instanceof THREE.WebGLRenderTarget ) {
	
								_this.setTexture( texture.texture, textureUnit );
	
							} else if ( texture instanceof THREE.WebGLRenderTargetCube ) {
	
								setCubeTextureDynamic( texture.texture, textureUnit );
	
							} else {
	
								_this.setTexture( texture, textureUnit );
	
							}
	
						}
	
						break;
	
					default:
	
						console.warn( 'THREE.WebGLRenderer: Unknown uniform type: ' + type );
	
				}
	
			}
	
		}
	
		function setupLights ( lights, camera ) {
	
			var l, ll, light,
			r = 0, g = 0, b = 0,
			color,
			intensity,
			distance,
	
			viewMatrix = camera.matrixWorldInverse,
	
			directionalLength = 0,
			pointLength = 0,
			spotLength = 0,
			hemiLength = 0,
	
			shadowsLength = 0;
	
			_lights.shadowsPointLight = 0;
	
			for ( l = 0, ll = lights.length; l < ll; l ++ ) {
	
				light = lights[ l ];
	
				color = light.color;
				intensity = light.intensity;
				distance = light.distance;
	
				if ( light instanceof THREE.AmbientLight ) {
	
					r += color.r * intensity;
					g += color.g * intensity;
					b += color.b * intensity;
	
				} else if ( light instanceof THREE.DirectionalLight ) {
	
					var uniforms = lightCache.get( light );
	
					uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
					uniforms.direction.setFromMatrixPosition( light.matrixWorld );
					_vector3.setFromMatrixPosition( light.target.matrixWorld );
					uniforms.direction.sub( _vector3 );
					uniforms.direction.transformDirection( viewMatrix );
	
					uniforms.shadow = light.castShadow;
	
					if ( light.castShadow ) {
	
						uniforms.shadowBias = light.shadow.bias;
						uniforms.shadowRadius = light.shadow.radius;
						uniforms.shadowMapSize = light.shadow.mapSize;
	
						_lights.shadows[ shadowsLength ++ ] = light;
	
					}
	
					_lights.directionalShadowMap[ directionalLength ] = light.shadow.map;
					_lights.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;
					_lights.directional[ directionalLength ++ ] = uniforms;
	
				} else if ( light instanceof THREE.SpotLight ) {
	
					var uniforms = lightCache.get( light );
	
					uniforms.position.setFromMatrixPosition( light.matrixWorld );
					uniforms.position.applyMatrix4( viewMatrix );
	
					uniforms.color.copy( color ).multiplyScalar( intensity );
					uniforms.distance = distance;
	
					uniforms.direction.setFromMatrixPosition( light.matrixWorld );
					_vector3.setFromMatrixPosition( light.target.matrixWorld );
					uniforms.direction.sub( _vector3 );
					uniforms.direction.transformDirection( viewMatrix );
	
					uniforms.angleCos = Math.cos( light.angle );
					uniforms.exponent = light.exponent;
					uniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;
	
					uniforms.shadow = light.castShadow;
	
					if ( light.castShadow ) {
	
						uniforms.shadowBias = light.shadow.bias;
						uniforms.shadowRadius = light.shadow.radius;
						uniforms.shadowMapSize = light.shadow.mapSize;
	
						_lights.shadows[ shadowsLength ++ ] = light;
	
					}
	
					_lights.spotShadowMap[ spotLength ] = light.shadow.map;
					_lights.spotShadowMatrix[ spotLength ] = light.shadow.matrix;
					_lights.spot[ spotLength ++ ] = uniforms;
	
				} else if ( light instanceof THREE.PointLight ) {
	
					var uniforms = lightCache.get( light );
	
					uniforms.position.setFromMatrixPosition( light.matrixWorld );
					uniforms.position.applyMatrix4( viewMatrix );
	
					uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
					uniforms.distance = light.distance;
					uniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;
	
					uniforms.shadow = light.castShadow;
	
					if ( light.castShadow ) {
	
						uniforms.shadowBias = light.shadow.bias;
						uniforms.shadowRadius = light.shadow.radius;
						uniforms.shadowMapSize = light.shadow.mapSize;
	
						_lights.shadows[ shadowsLength ++ ] = light;
	
					}
	
					_lights.pointShadowMap[ pointLength ] = light.shadow.map;
	
					if ( _lights.pointShadowMatrix[ pointLength ] === undefined ) {
	
						_lights.pointShadowMatrix[ pointLength ] = new THREE.Matrix4();
	
					}
	
					// for point lights we set the shadow matrix to be a translation-only matrix
					// equal to inverse of the light's position
					_vector3.setFromMatrixPosition( light.matrixWorld ).negate();
					_lights.pointShadowMatrix[ pointLength ].identity().setPosition( _vector3 );
	
					_lights.point[ pointLength ++ ] = uniforms;
	
				} else if ( light instanceof THREE.HemisphereLight ) {
	
					var uniforms = lightCache.get( light );
	
					uniforms.direction.setFromMatrixPosition( light.matrixWorld );
					uniforms.direction.transformDirection( viewMatrix );
					uniforms.direction.normalize();
	
					uniforms.skyColor.copy( light.color ).multiplyScalar( intensity );
					uniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );
	
					_lights.hemi[ hemiLength ++ ] = uniforms;
	
				}
	
			}
	
			_lights.ambient[ 0 ] = r;
			_lights.ambient[ 1 ] = g;
			_lights.ambient[ 2 ] = b;
	
			_lights.directional.length = directionalLength;
			_lights.spot.length = spotLength;
			_lights.point.length = pointLength;
			_lights.hemi.length = hemiLength;
	
			_lights.shadows.length = shadowsLength;
	
			_lights.hash = directionalLength + ',' + pointLength + ',' + spotLength + ',' + hemiLength + ',' + shadowsLength;
	
		}
	
		// GL state setting
	
		this.setFaceCulling = function ( cullFace, frontFaceDirection ) {
	
			if ( cullFace === THREE.CullFaceNone ) {
	
				state.disable( _gl.CULL_FACE );
	
			} else {
	
				if ( frontFaceDirection === THREE.FrontFaceDirectionCW ) {
	
					_gl.frontFace( _gl.CW );
	
				} else {
	
					_gl.frontFace( _gl.CCW );
	
				}
	
				if ( cullFace === THREE.CullFaceBack ) {
	
					_gl.cullFace( _gl.BACK );
	
				} else if ( cullFace === THREE.CullFaceFront ) {
	
					_gl.cullFace( _gl.FRONT );
	
				} else {
	
					_gl.cullFace( _gl.FRONT_AND_BACK );
	
				}
	
				state.enable( _gl.CULL_FACE );
	
			}
	
		};
	
		// Textures
	
		function setTextureParameters ( textureType, texture, isPowerOfTwoImage ) {
	
			var extension;
	
			if ( isPowerOfTwoImage ) {
	
				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );
				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );
	
				_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );
				_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );
	
			} else {
	
				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );
	
				if ( texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping ) {
	
					console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.', texture );
	
				}
	
				_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );
				_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );
	
				if ( texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) {
	
					console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.', texture );
	
				}
	
			}
	
			extension = extensions.get( 'EXT_texture_filter_anisotropic' );
	
			if ( extension ) {
	
				if ( texture.type === THREE.FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;
				if ( texture.type === THREE.HalfFloatType && extensions.get( 'OES_texture_half_float_linear' ) === null ) return;
	
				if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {
	
					_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, _this.getMaxAnisotropy() ) );
					properties.get( texture ).__currentAnisotropy = texture.anisotropy;
	
				}
	
			}
	
		}
	
		function uploadTexture( textureProperties, texture, slot ) {
	
			if ( textureProperties.__webglInit === undefined ) {
	
				textureProperties.__webglInit = true;
	
				texture.addEventListener( 'dispose', onTextureDispose );
	
				textureProperties.__webglTexture = _gl.createTexture();
	
				_infoMemory.textures ++;
	
			}
	
			state.activeTexture( _gl.TEXTURE0 + slot );
			state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );
	
			_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
			_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
			_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );
	
			var image = clampToMaxSize( texture.image, capabilities.maxTextureSize );
	
			if ( textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( image ) === false ) {
	
				image = makePowerOfTwo( image );
	
			}
	
			var isPowerOfTwoImage = isPowerOfTwo( image ),
			glFormat = paramThreeToGL( texture.format ),
			glType = paramThreeToGL( texture.type );
	
			setTextureParameters( _gl.TEXTURE_2D, texture, isPowerOfTwoImage );
	
			var mipmap, mipmaps = texture.mipmaps;
	
			if ( texture instanceof THREE.DataTexture ) {
	
				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels
	
				if ( mipmaps.length > 0 && isPowerOfTwoImage ) {
	
					for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {
	
						mipmap = mipmaps[ i ];
						state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );
	
					}
	
					texture.generateMipmaps = false;
	
				} else {
	
					state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );
	
				}
	
			} else if ( texture instanceof THREE.CompressedTexture ) {
	
				for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {
	
					mipmap = mipmaps[ i ];
	
					if ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {
	
						if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {
	
							state.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );
	
						} else {
	
							console.warn( "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()" );
	
						}
	
					} else {
	
						state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );
	
					}
	
				}
	
			} else {
	
				// regular Texture (image, video, canvas)
	
				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels
	
				if ( mipmaps.length > 0 && isPowerOfTwoImage ) {
	
					for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {
	
						mipmap = mipmaps[ i ];
						state.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );
	
					}
	
					texture.generateMipmaps = false;
	
				} else {
	
					state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, image );
	
				}
	
			}
	
			if ( texture.generateMipmaps && isPowerOfTwoImage ) _gl.generateMipmap( _gl.TEXTURE_2D );
	
			textureProperties.__version = texture.version;
	
			if ( texture.onUpdate ) texture.onUpdate( texture );
	
		}
	
		this.setTexture = function ( texture, slot ) {
	
			var textureProperties = properties.get( texture );
	
			if ( texture.version > 0 && textureProperties.__version !== texture.version ) {
	
				var image = texture.image;
	
				if ( image === undefined ) {
	
					console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined', texture );
					return;
	
				}
	
				if ( image.complete === false ) {
	
					console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture );
					return;
	
				}
	
				uploadTexture( textureProperties, texture, slot );
	
				return;
	
			}
	
			state.activeTexture( _gl.TEXTURE0 + slot );
			state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );
	
		};
	
		function clampToMaxSize ( image, maxSize ) {
	
			if ( image.width > maxSize || image.height > maxSize ) {
	
				// Warning: Scaling through the canvas will only work with images that use
				// premultiplied alpha.
	
				var scale = maxSize / Math.max( image.width, image.height );
	
				var canvas = document.createElement( 'canvas' );
				canvas.width = Math.floor( image.width * scale );
				canvas.height = Math.floor( image.height * scale );
	
				var context = canvas.getContext( '2d' );
				context.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );
	
				console.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );
	
				return canvas;
	
			}
	
			return image;
	
		}
	
		function isPowerOfTwo( image ) {
	
			return THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height );
	
		}
	
		function textureNeedsPowerOfTwo( texture ) {
	
			if ( texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping ) return true;
			if ( texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) return true;
	
			return false;
	
		}
	
		function makePowerOfTwo( image ) {
	
			if ( image instanceof HTMLImageElement || image instanceof HTMLCanvasElement ) {
	
				var canvas = document.createElement( 'canvas' );
				canvas.width = THREE.Math.nearestPowerOfTwo( image.width );
				canvas.height = THREE.Math.nearestPowerOfTwo( image.height );
	
				var context = canvas.getContext( '2d' );
				context.drawImage( image, 0, 0, canvas.width, canvas.height );
	
				console.warn( 'THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );
	
				return canvas;
	
			}
	
			return image;
	
		}
	
		function setCubeTexture ( texture, slot ) {
	
			var textureProperties = properties.get( texture );
	
			if ( texture.image.length === 6 ) {
	
				if ( texture.version > 0 && textureProperties.__version !== texture.version ) {
	
					if ( ! textureProperties.__image__webglTextureCube ) {
	
						texture.addEventListener( 'dispose', onTextureDispose );
	
						textureProperties.__image__webglTextureCube = _gl.createTexture();
	
						_infoMemory.textures ++;
	
					}
	
					state.activeTexture( _gl.TEXTURE0 + slot );
					state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );
	
					_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
	
					var isCompressed = texture instanceof THREE.CompressedTexture;
					var isDataTexture = texture.image[ 0 ] instanceof THREE.DataTexture;
	
					var cubeImage = [];
	
					for ( var i = 0; i < 6; i ++ ) {
	
						if ( _this.autoScaleCubemaps && ! isCompressed && ! isDataTexture ) {
	
							cubeImage[ i ] = clampToMaxSize( texture.image[ i ], capabilities.maxCubemapSize );
	
						} else {
	
							cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];
	
						}
	
					}
	
					var image = cubeImage[ 0 ],
					isPowerOfTwoImage = isPowerOfTwo( image ),
					glFormat = paramThreeToGL( texture.format ),
					glType = paramThreeToGL( texture.type );
	
					setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage );
	
					for ( var i = 0; i < 6; i ++ ) {
	
						if ( ! isCompressed ) {
	
							if ( isDataTexture ) {
	
								state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );
	
							} else {
	
								state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );
	
							}
	
						} else {
	
							var mipmap, mipmaps = cubeImage[ i ].mipmaps;
	
							for ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {
	
								mipmap = mipmaps[ j ];
	
								if ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {
	
									if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {
	
										state.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );
	
									} else {
	
										console.warn( "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setCubeTexture()" );
	
									}
	
								} else {
	
									state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );
	
								}
	
							}
	
						}
	
					}
	
					if ( texture.generateMipmaps && isPowerOfTwoImage ) {
	
						_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );
	
					}
	
					textureProperties.__version = texture.version;
	
					if ( texture.onUpdate ) texture.onUpdate( texture );
	
				} else {
	
					state.activeTexture( _gl.TEXTURE0 + slot );
					state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );
	
				}
	
			}
	
		}
	
		function setCubeTextureDynamic ( texture, slot ) {
	
			state.activeTexture( _gl.TEXTURE0 + slot );
			state.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( texture ).__webglTexture );
	
		}
	
		// Render targets
	
		// Setup storage for target texture and bind it to correct framebuffer
		function setupFrameBufferTexture ( framebuffer, renderTarget, attachment, textureTarget ) {
	
			var glFormat = paramThreeToGL( renderTarget.texture.format );
			var glType = paramThreeToGL( renderTarget.texture.type );
			state.texImage2D( textureTarget, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );
			_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
			_gl.framebufferTexture2D( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );
			_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );
	
		}
	
		// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
		function setupRenderBufferStorage ( renderbuffer, renderTarget ) {
	
			_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );
	
			if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {
	
				_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );
				_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );
	
			} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {
	
				_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );
				_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );
	
			} else {
	
				// FIXME: We don't support !depth !stencil
				_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );
	
			}
	
			_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );
	
		}
	
		// Setup GL resources for a non-texture depth buffer
		function setupDepthRenderbuffer( renderTarget ) {
	
			var renderTargetProperties = properties.get( renderTarget );
	
			var isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );
	
			if ( isCube ) {
	
				renderTargetProperties.__webglDepthbuffer = [];
	
				for ( var i = 0; i < 6; i ++ ) {
	
					_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ i ] );
					renderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();
					setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget );
	
				}
	
			} else {
	
				_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );
				renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
				setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget );
	
			}
	
			_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );
	
		}
	
		// Set up GL resources for the render target
		function setupRenderTarget( renderTarget ) {
	
			var renderTargetProperties = properties.get( renderTarget );
			var textureProperties = properties.get( renderTarget.texture );
	
			renderTarget.addEventListener( 'dispose', onRenderTargetDispose );
	
			textureProperties.__webglTexture = _gl.createTexture();
	
			_infoMemory.textures ++;
	
			var isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );
			var isTargetPowerOfTwo = THREE.Math.isPowerOfTwo( renderTarget.width ) && THREE.Math.isPowerOfTwo( renderTarget.height );
	
			// Setup framebuffer
	
			if ( isCube ) {
	
				renderTargetProperties.__webglFramebuffer = [];
	
				for ( var i = 0; i < 6; i ++ ) {
	
					renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();
	
				}
	
			} else {
	
				renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
	
			}
	
			// Setup color buffer
	
			if ( isCube ) {
	
				state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );
				setTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo );
	
				for ( var i = 0; i < 6; i ++ ) {
	
					setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );
	
				}
	
				if ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );
				state.bindTexture( _gl.TEXTURE_CUBE_MAP, null );
	
			} else {
	
				state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );
				setTextureParameters( _gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo );
				setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D );
	
				if ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );
				state.bindTexture( _gl.TEXTURE_2D, null );
	
			}
	
			// Setup depth and stencil buffers
	
			if ( renderTarget.depthBuffer ) {
	
				setupDepthRenderbuffer( renderTarget );
	
			}
	
		}
	
		this.setRenderTarget = function ( renderTarget ) {
	
			_currentRenderTarget = renderTarget;
	
			if ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {
	
				setupRenderTarget( renderTarget );
	
			}
	
			var isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );
			var framebuffer;
	
			if ( renderTarget ) {
	
				var renderTargetProperties = properties.get( renderTarget );
	
				if ( isCube ) {
	
					framebuffer = renderTargetProperties.__webglFramebuffer[ renderTarget.activeCubeFace ];
	
				} else {
	
					framebuffer = renderTargetProperties.__webglFramebuffer;
	
				}
	
				_currentScissor.copy( renderTarget.scissor );
				_currentScissorTest = renderTarget.scissorTest;
	
				_currentViewport.copy( renderTarget.viewport );
	
			} else {
	
				framebuffer = null;
	
				_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio );
				_currentScissorTest = _scissorTest;
	
				_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio );
	
			}
	
			if ( _currentFramebuffer !== framebuffer ) {
	
				_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
				_currentFramebuffer = framebuffer;
	
			}
	
			state.scissor( _currentScissor );
			state.setScissorTest( _currentScissorTest );
	
			state.viewport( _currentViewport );
	
			if ( isCube ) {
	
				var textureProperties = properties.get( renderTarget.texture );
				_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, 0 );
	
			}
	
		};
	
		this.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer ) {
	
			if ( renderTarget instanceof THREE.WebGLRenderTarget === false ) {
	
				console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
				return;
	
			}
	
			var framebuffer = properties.get( renderTarget ).__webglFramebuffer;
	
			if ( framebuffer ) {
	
				var restore = false;
	
				if ( framebuffer !== _currentFramebuffer ) {
	
					_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
	
					restore = true;
	
				}
	
				try {
	
					var texture = renderTarget.texture;
	
					if ( texture.format !== THREE.RGBAFormat
						&& paramThreeToGL( texture.format ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {
	
						console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );
						return;
	
					}
	
					if ( texture.type !== THREE.UnsignedByteType
						&& paramThreeToGL( texture.type ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_TYPE )
						&& ! ( texture.type === THREE.FloatType && extensions.get( 'WEBGL_color_buffer_float' ) )
						&& ! ( texture.type === THREE.HalfFloatType && extensions.get( 'EXT_color_buffer_half_float' ) ) ) {
	
						console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );
						return;
	
					}
	
					if ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {
	
						_gl.readPixels( x, y, width, height, paramThreeToGL( texture.format ), paramThreeToGL( texture.type ), buffer );
	
					} else {
	
						console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );
	
					}
	
				} finally {
	
					if ( restore ) {
	
						_gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );
	
					}
	
				}
	
			}
	
		};
	
		function updateRenderTargetMipmap( renderTarget ) {
	
			var target = renderTarget instanceof THREE.WebGLRenderTargetCube ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
			var texture = properties.get( renderTarget.texture ).__webglTexture;
	
			state.bindTexture( target, texture );
			_gl.generateMipmap( target );
			state.bindTexture( target, null );
	
		}
	
		// Fallback filters for non-power-of-2 textures
	
		function filterFallback ( f ) {
	
			if ( f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter ) {
	
				return _gl.NEAREST;
	
			}
	
			return _gl.LINEAR;
	
		}
	
		// Map three.js constants to WebGL constants
	
		function paramThreeToGL ( p ) {
	
			var extension;
	
			if ( p === THREE.RepeatWrapping ) return _gl.REPEAT;
			if ( p === THREE.ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;
			if ( p === THREE.MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;
	
			if ( p === THREE.NearestFilter ) return _gl.NEAREST;
			if ( p === THREE.NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;
			if ( p === THREE.NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;
	
			if ( p === THREE.LinearFilter ) return _gl.LINEAR;
			if ( p === THREE.LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;
			if ( p === THREE.LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;
	
			if ( p === THREE.UnsignedByteType ) return _gl.UNSIGNED_BYTE;
			if ( p === THREE.UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;
			if ( p === THREE.UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;
			if ( p === THREE.UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;
	
			if ( p === THREE.ByteType ) return _gl.BYTE;
			if ( p === THREE.ShortType ) return _gl.SHORT;
			if ( p === THREE.UnsignedShortType ) return _gl.UNSIGNED_SHORT;
			if ( p === THREE.IntType ) return _gl.INT;
			if ( p === THREE.UnsignedIntType ) return _gl.UNSIGNED_INT;
			if ( p === THREE.FloatType ) return _gl.FLOAT;
	
			extension = extensions.get( 'OES_texture_half_float' );
	
			if ( extension !== null ) {
	
				if ( p === THREE.HalfFloatType ) return extension.HALF_FLOAT_OES;
	
			}
	
			if ( p === THREE.AlphaFormat ) return _gl.ALPHA;
			if ( p === THREE.RGBFormat ) return _gl.RGB;
			if ( p === THREE.RGBAFormat ) return _gl.RGBA;
			if ( p === THREE.LuminanceFormat ) return _gl.LUMINANCE;
			if ( p === THREE.LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;
	
			if ( p === THREE.AddEquation ) return _gl.FUNC_ADD;
			if ( p === THREE.SubtractEquation ) return _gl.FUNC_SUBTRACT;
			if ( p === THREE.ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;
	
			if ( p === THREE.ZeroFactor ) return _gl.ZERO;
			if ( p === THREE.OneFactor ) return _gl.ONE;
			if ( p === THREE.SrcColorFactor ) return _gl.SRC_COLOR;
			if ( p === THREE.OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;
			if ( p === THREE.SrcAlphaFactor ) return _gl.SRC_ALPHA;
			if ( p === THREE.OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;
			if ( p === THREE.DstAlphaFactor ) return _gl.DST_ALPHA;
			if ( p === THREE.OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;
	
			if ( p === THREE.DstColorFactor ) return _gl.DST_COLOR;
			if ( p === THREE.OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;
			if ( p === THREE.SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;
	
			extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );
	
			if ( extension !== null ) {
	
				if ( p === THREE.RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
				if ( p === THREE.RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
				if ( p === THREE.RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
				if ( p === THREE.RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
	
			}
	
			extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );
	
			if ( extension !== null ) {
	
				if ( p === THREE.RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
				if ( p === THREE.RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
				if ( p === THREE.RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
				if ( p === THREE.RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
	
			}
	
			extension = extensions.get( 'WEBGL_compressed_texture_etc1' );
	
			if ( extension !== null ) {
	
				if ( p === THREE.RGB_ETC1_Format ) return extension.COMPRESSED_RGB_ETC1_WEBGL;
	
			}
	
			extension = extensions.get( 'EXT_blend_minmax' );
	
			if ( extension !== null ) {
	
				if ( p === THREE.MinEquation ) return extension.MIN_EXT;
				if ( p === THREE.MaxEquation ) return extension.MAX_EXT;
	
			}
	
			return 0;
	
		}
	
	};
	
	// File:src/renderers/WebGLRenderTarget.js
	
	/**
	 * @author szimek / https://github.com/szimek/
	 * @author alteredq / http://alteredqualia.com/
	 * @author Marius Kintel / https://github.com/kintel
	 */
	
	/*
	 In options, we can specify:
	 * Texture parameters for an auto-generated target texture
	 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
	*/
	THREE.WebGLRenderTarget = function ( width, height, options ) {
	
		this.uuid = THREE.Math.generateUUID();
	
		this.width = width;
		this.height = height;
	
		this.scissor = new THREE.Vector4( 0, 0, width, height );
		this.scissorTest = false;
	
		this.viewport = new THREE.Vector4( 0, 0, width, height );
	
		options = options || {};
	
		if ( options.minFilter === undefined ) options.minFilter = THREE.LinearFilter;
	
		this.texture = new THREE.Texture( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy );
	
		this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
		this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
	
	};
	
	THREE.WebGLRenderTarget.prototype = {
	
		constructor: THREE.WebGLRenderTarget,
	
		setSize: function ( width, height ) {
	
			if ( this.width !== width || this.height !== height ) {
	
				this.width = width;
				this.height = height;
	
				this.dispose();
	
			}
	
			this.viewport.set( 0, 0, width, height );
			this.scissor.set( 0, 0, width, height );
	
		},
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		},
	
		copy: function ( source ) {
	
			this.width = source.width;
			this.height = source.height;
	
			this.viewport.copy( source.viewport );
	
			this.texture = source.texture.clone();
	
			this.depthBuffer = source.depthBuffer;
			this.stencilBuffer = source.stencilBuffer;
	
			this.shareDepthFrom = source.shareDepthFrom;
	
			return this;
	
		},
	
		dispose: function () {
	
			this.dispatchEvent( { type: 'dispose' } );
	
		}
	
	};
	
	THREE.EventDispatcher.prototype.apply( THREE.WebGLRenderTarget.prototype );
	
	// File:src/renderers/WebGLRenderTargetCube.js
	
	/**
	 * @author alteredq / http://alteredqualia.com
	 */
	
	THREE.WebGLRenderTargetCube = function ( width, height, options ) {
	
		THREE.WebGLRenderTarget.call( this, width, height, options );
	
		this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5
	
	};
	
	THREE.WebGLRenderTargetCube.prototype = Object.create( THREE.WebGLRenderTarget.prototype );
	THREE.WebGLRenderTargetCube.prototype.constructor = THREE.WebGLRenderTargetCube;
	
	// File:src/renderers/webgl/WebGLBufferRenderer.js
	
	/**
	* @author mrdoob / http://mrdoob.com/
	*/
	
	THREE.WebGLBufferRenderer = function ( _gl, extensions, _infoRender ) {
	
		var mode;
	
		function setMode( value ) {
	
			mode = value;
	
		}
	
		function render( start, count ) {
	
			_gl.drawArrays( mode, start, count );
	
			_infoRender.calls ++;
			_infoRender.vertices += count;
			if ( mode === _gl.TRIANGLES ) _infoRender.faces += count / 3;
	
		}
	
		function renderInstances( geometry ) {
	
			var extension = extensions.get( 'ANGLE_instanced_arrays' );
	
			if ( extension === null ) {
	
				console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
				return;
	
			}
	
			var position = geometry.attributes.position;
	
			var count = 0;
	
			if ( position instanceof THREE.InterleavedBufferAttribute ) {
	
				count = position.data.count;
	
				extension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );
	
			} else {
	
				count = position.count;
	
				extension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );
	
			}
	
			_infoRender.calls ++;
			_infoRender.vertices += count * geometry.maxInstancedCount;
			if ( mode === _gl.TRIANGLES ) _infoRender.faces += geometry.maxInstancedCount * count / 3;
	
		}
	
		this.setMode = setMode;
		this.render = render;
		this.renderInstances = renderInstances;
	
	};
	
	// File:src/renderers/webgl/WebGLIndexedBufferRenderer.js
	
	/**
	* @author mrdoob / http://mrdoob.com/
	*/
	
	THREE.WebGLIndexedBufferRenderer = function ( _gl, extensions, _infoRender ) {
	
		var mode;
	
		function setMode( value ) {
	
			mode = value;
	
		}
	
		var type, size;
	
		function setIndex( index ) {
	
			if ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {
	
				type = _gl.UNSIGNED_INT;
				size = 4;
	
			} else {
	
				type = _gl.UNSIGNED_SHORT;
				size = 2;
	
			}
	
		}
	
		function render( start, count ) {
	
			_gl.drawElements( mode, count, type, start * size );
	
			_infoRender.calls ++;
			_infoRender.vertices += count;
			if ( mode === _gl.TRIANGLES ) _infoRender.faces += count / 3;
	
		}
	
		function renderInstances( geometry, start, count ) {
	
			var extension = extensions.get( 'ANGLE_instanced_arrays' );
	
			if ( extension === null ) {
	
				console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
				return;
	
			}
	
			extension.drawElementsInstancedANGLE( mode, count, type, start * size, geometry.maxInstancedCount );
	
			_infoRender.calls ++;
			_infoRender.vertices += count * geometry.maxInstancedCount;
			if ( mode === _gl.TRIANGLES ) _infoRender.faces += geometry.maxInstancedCount * count / 3;
		}
	
		this.setMode = setMode;
		this.setIndex = setIndex;
		this.render = render;
		this.renderInstances = renderInstances;
	
	};
	
	// File:src/renderers/webgl/WebGLExtensions.js
	
	/**
	* @author mrdoob / http://mrdoob.com/
	*/
	
	THREE.WebGLExtensions = function ( gl ) {
	
		var extensions = {};
	
		this.get = function ( name ) {
	
			if ( extensions[ name ] !== undefined ) {
	
				return extensions[ name ];
	
			}
	
			var extension;
	
			switch ( name ) {
	
				case 'EXT_texture_filter_anisotropic':
					extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
					break;
	
				case 'WEBGL_compressed_texture_s3tc':
					extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
					break;
	
				case 'WEBGL_compressed_texture_pvrtc':
					extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
					break;
	
				case 'WEBGL_compressed_texture_etc1':
					extension = gl.getExtension( 'WEBGL_compressed_texture_etc1' );
					break;
	
				default:
					extension = gl.getExtension( name );
	
			}
	
			if ( extension === null ) {
	
				console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );
	
			}
	
			extensions[ name ] = extension;
	
			return extension;
	
		};
	
	};
	
	// File:src/renderers/webgl/WebGLCapabilities.js
	
	THREE.WebGLCapabilities = function ( gl, extensions, parameters ) {
	
		function getMaxPrecision( precision ) {
	
			if ( precision === 'highp' ) {
	
				if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&
				     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {
	
					return 'highp';
	
				}
	
				precision = 'mediump';
	
			}
	
			if ( precision === 'mediump' ) {
	
				if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&
				     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {
	
					return 'mediump';
	
				}
	
			}
	
			return 'lowp';
	
		}
	
		this.getMaxPrecision = getMaxPrecision;
	
		this.precision = parameters.precision !== undefined ? parameters.precision : 'highp',
		this.logarithmicDepthBuffer = parameters.logarithmicDepthBuffer !== undefined ? parameters.logarithmicDepthBuffer : false;
	
		this.maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );
		this.maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
		this.maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );
		this.maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );
	
		this.maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
		this.maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );
		this.maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );
		this.maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );
	
		this.vertexTextures = this.maxVertexTextures > 0;
		this.floatFragmentTextures = !! extensions.get( 'OES_texture_float' );
		this.floatVertexTextures = this.vertexTextures && this.floatFragmentTextures;
	
		var _maxPrecision = getMaxPrecision( this.precision );
	
		if ( _maxPrecision !== this.precision ) {
	
			console.warn( 'THREE.WebGLRenderer:', this.precision, 'not supported, using', _maxPrecision, 'instead.' );
			this.precision = _maxPrecision;
	
		}
	
		if ( this.logarithmicDepthBuffer ) {
	
			this.logarithmicDepthBuffer = !! extensions.get( 'EXT_frag_depth' );
	
		}
	
	};
	
	// File:src/renderers/webgl/WebGLGeometries.js
	
	/**
	* @author mrdoob / http://mrdoob.com/
	*/
	
	THREE.WebGLGeometries = function ( gl, properties, info ) {
	
		var geometries = {};
	
		function get( object ) {
	
			var geometry = object.geometry;
	
			if ( geometries[ geometry.id ] !== undefined ) {
	
				return geometries[ geometry.id ];
	
			}
	
			geometry.addEventListener( 'dispose', onGeometryDispose );
	
			var buffergeometry;
	
			if ( geometry instanceof THREE.BufferGeometry ) {
	
				buffergeometry = geometry;
	
			} else if ( geometry instanceof THREE.Geometry ) {
	
				if ( geometry._bufferGeometry === undefined ) {
	
					geometry._bufferGeometry = new THREE.BufferGeometry().setFromObject( object );
	
				}
	
				buffergeometry = geometry._bufferGeometry;
	
			}
	
			geometries[ geometry.id ] = buffergeometry;
	
			info.memory.geometries ++;
	
			return buffergeometry;
	
		}
	
		function onGeometryDispose( event ) {
	
			var geometry = event.target;
			var buffergeometry = geometries[ geometry.id ];
	
			if ( buffergeometry.index !== null ) {
	
				deleteAttribute( buffergeometry.index );
	
			}
	
			deleteAttributes( buffergeometry.attributes );
	
			geometry.removeEventListener( 'dispose', onGeometryDispose );
	
			delete geometries[ geometry.id ];
	
			// TODO
	
			var property = properties.get( geometry );
	
			if ( property.wireframe ) {
	
				deleteAttribute( property.wireframe );
	
			}
	
			properties.delete( geometry );
	
			var bufferproperty = properties.get( buffergeometry );
	
			if ( bufferproperty.wireframe ) {
	
				deleteAttribute( bufferproperty.wireframe );
	
			}
	
			properties.delete( buffergeometry );
	
			//
	
			info.memory.geometries --;
	
		}
	
		function getAttributeBuffer( attribute ) {
	
			if ( attribute instanceof THREE.InterleavedBufferAttribute ) {
	
				return properties.get( attribute.data ).__webglBuffer;
	
			}
	
			return properties.get( attribute ).__webglBuffer;
	
		}
	
		function deleteAttribute( attribute ) {
	
			var buffer = getAttributeBuffer( attribute );
	
			if ( buffer !== undefined ) {
	
				gl.deleteBuffer( buffer );
				removeAttributeBuffer( attribute );
	
			}
	
		}
	
		function deleteAttributes( attributes ) {
	
			for ( var name in attributes ) {
	
				deleteAttribute( attributes[ name ] );
	
			}
	
		}
	
		function removeAttributeBuffer( attribute ) {
	
			if ( attribute instanceof THREE.InterleavedBufferAttribute ) {
	
				properties.delete( attribute.data );
	
			} else {
	
				properties.delete( attribute );
	
			}
	
		}
	
		this.get = get;
	
	};
	
	// File:src/renderers/webgl/WebGLLights.js
	
	/**
	* @author mrdoob / http://mrdoob.com/
	*/
	
	THREE.WebGLLights = function () {
	
		var lights = {};
	
		this.get = function ( light ) {
	
			if ( lights[ light.id ] !== undefined ) {
	
				return lights[ light.id ];
	
			}
	
			var uniforms;
	
			switch ( light.type ) {
	
				case 'DirectionalLight':
					uniforms = {
						direction: new THREE.Vector3(),
						color: new THREE.Color(),
	
						shadow: false,
						shadowBias: 0,
						shadowRadius: 1,
						shadowMapSize: new THREE.Vector2()
					};
					break;
	
				case 'SpotLight':
					uniforms = {
						position: new THREE.Vector3(),
						direction: new THREE.Vector3(),
						color: new THREE.Color(),
						distance: 0,
						angleCos: 0,
						exponent: 0,
						decay: 0,
	
						shadow: false,
						shadowBias: 0,
						shadowRadius: 1,
						shadowMapSize: new THREE.Vector2()
					};
					break;
	
				case 'PointLight':
					uniforms = {
						position: new THREE.Vector3(),
						color: new THREE.Color(),
						distance: 0,
						decay: 0,
	
						shadow: false,
						shadowBias: 0,
						shadowRadius: 1,
						shadowMapSize: new THREE.Vector2()
					};
					break;
	
				case 'HemisphereLight':
					uniforms = {
						direction: new THREE.Vector3(),
						skyColor: new THREE.Color(),
						groundColor: new THREE.Color()
					};
					break;
	
			}
	
			lights[ light.id ] = uniforms;
	
			return uniforms;
	
		};
	
	};
	
	// File:src/renderers/webgl/WebGLObjects.js
	
	/**
	* @author mrdoob / http://mrdoob.com/
	*/
	
	THREE.WebGLObjects = function ( gl, properties, info ) {
	
		var geometries = new THREE.WebGLGeometries( gl, properties, info );
	
		//
	
		function update( object ) {
	
			// TODO: Avoid updating twice (when using shadowMap). Maybe add frame counter.
	
			var geometry = geometries.get( object );
	
			if ( object.geometry instanceof THREE.Geometry ) {
	
				geometry.updateFromObject( object );
	
			}
	
			var index = geometry.index;
			var attributes = geometry.attributes;
	
			if ( index !== null ) {
	
				updateAttribute( index, gl.ELEMENT_ARRAY_BUFFER );
	
			}
	
			for ( var name in attributes ) {
	
				updateAttribute( attributes[ name ], gl.ARRAY_BUFFER );
	
			}
	
			// morph targets
	
			var morphAttributes = geometry.morphAttributes;
	
			for ( var name in morphAttributes ) {
	
				var array = morphAttributes[ name ];
	
				for ( var i = 0, l = array.length; i < l; i ++ ) {
	
					updateAttribute( array[ i ], gl.ARRAY_BUFFER );
	
				}
	
			}
	
			return geometry;
	
		}
	
		function updateAttribute( attribute, bufferType ) {
	
			var data = ( attribute instanceof THREE.InterleavedBufferAttribute ) ? attribute.data : attribute;
	
			var attributeProperties = properties.get( data );
	
			if ( attributeProperties.__webglBuffer === undefined ) {
	
				createBuffer( attributeProperties, data, bufferType );
	
			} else if ( attributeProperties.version !== data.version ) {
	
				updateBuffer( attributeProperties, data, bufferType );
	
			}
	
		}
	
		function createBuffer( attributeProperties, data, bufferType ) {
	
			attributeProperties.__webglBuffer = gl.createBuffer();
			gl.bindBuffer( bufferType, attributeProperties.__webglBuffer );
	
			var usage = data.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;
	
			gl.bufferData( bufferType, data.array, usage );
	
			attributeProperties.version = data.version;
	
		}
	
		function updateBuffer( attributeProperties, data, bufferType ) {
	
			gl.bindBuffer( bufferType, attributeProperties.__webglBuffer );
	
			if ( data.dynamic === false || data.updateRange.count === - 1 ) {
	
				// Not using update ranges
	
				gl.bufferSubData( bufferType, 0, data.array );
	
			} else if ( data.updateRange.count === 0 ) {
	
				console.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );
	
			} else {
	
				gl.bufferSubData( bufferType, data.updateRange.offset * data.array.BYTES_PER_ELEMENT,
								  data.array.subarray( data.updateRange.offset, data.updateRange.offset + data.updateRange.count ) );
	
				data.updateRange.count = 0; // reset range
	
			}
	
			attributeProperties.version = data.version;
	
		}
	
		function getAttributeBuffer( attribute ) {
	
			if ( attribute instanceof THREE.InterleavedBufferAttribute ) {
	
				return properties.get( attribute.data ).__webglBuffer;
	
			}
	
			return properties.get( attribute ).__webglBuffer;
	
		}
	
		function getWireframeAttribute( geometry ) {
	
			var property = properties.get( geometry );
	
			if ( property.wireframe !== undefined ) {
	
				return property.wireframe;
	
			}
	
			var indices = [];
	
			var index = geometry.index;
			var attributes = geometry.attributes;
			var position = attributes.position;
	
			// console.time( 'wireframe' );
	
			if ( index !== null ) {
	
				var edges = {};
				var array = index.array;
	
				for ( var i = 0, l = array.length; i < l; i += 3 ) {
	
					var a = array[ i + 0 ];
					var b = array[ i + 1 ];
					var c = array[ i + 2 ];
	
					if ( checkEdge( edges, a, b ) ) indices.push( a, b );
					if ( checkEdge( edges, b, c ) ) indices.push( b, c );
					if ( checkEdge( edges, c, a ) ) indices.push( c, a );
	
				}
	
			} else {
	
				var array = attributes.position.array;
	
				for ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {
	
					var a = i + 0;
					var b = i + 1;
					var c = i + 2;
	
					indices.push( a, b, b, c, c, a );
	
				}
	
			}
	
			// console.timeEnd( 'wireframe' );
	
			var TypeArray = position.count > 65535 ? Uint32Array : Uint16Array;
			var attribute = new THREE.BufferAttribute( new TypeArray( indices ), 1 );
	
			updateAttribute( attribute, gl.ELEMENT_ARRAY_BUFFER );
	
			property.wireframe = attribute;
	
			return attribute;
	
		}
	
		function checkEdge( edges, a, b ) {
	
			if ( a > b ) {
	
				var tmp = a;
				a = b;
				b = tmp;
	
			}
	
			var list = edges[ a ];
	
			if ( list === undefined ) {
	
				edges[ a ] = [ b ];
				return true;
	
			} else if ( list.indexOf( b ) === -1 ) {
	
				list.push( b );
				return true;
	
			}
	
			return false;
	
		}
	
		this.getAttributeBuffer = getAttributeBuffer;
		this.getWireframeAttribute = getWireframeAttribute;
	
		this.update = update;
	
	};
	
	// File:src/renderers/webgl/WebGLProgram.js
	
	THREE.WebGLProgram = ( function () {
	
		var programIdCount = 0;
	
		// TODO: Combine the regex
		var structRe = /^([\w\d_]+)\.([\w\d_]+)$/;
		var arrayStructRe = /^([\w\d_]+)\[(\d+)\]\.([\w\d_]+)$/;
		var arrayRe = /^([\w\d_]+)\[0\]$/;
	
		function generateExtensions( extensions, parameters, rendererExtensions ) {
	
			extensions = extensions || {};
	
			var chunks = [
				( extensions.derivatives || parameters.bumpMap || parameters.normalMap || parameters.flatShading ) ? '#extension GL_OES_standard_derivatives : enable' : '',
				( extensions.fragDepth || parameters.logarithmicDepthBuffer ) && rendererExtensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',
				( extensions.drawBuffers ) && rendererExtensions.get( 'WEBGL_draw_buffers' ) ? '#extension GL_EXT_draw_buffers : require' : '',
				( extensions.shaderTextureLOD || parameters.envMap ) && rendererExtensions.get( 'EXT_shader_texture_lod' ) ? '#extension GL_EXT_shader_texture_lod : enable' : '',
			];
	
			return chunks.filter( filterEmptyLine ).join( '\n' );
	
		}
	
		function generateDefines( defines ) {
	
			var chunks = [];
	
			for ( var name in defines ) {
	
				var value = defines[ name ];
	
				if ( value === false ) continue;
	
				chunks.push( '#define ' + name + ' ' + value );
	
			}
	
			return chunks.join( '\n' );
	
		}
	
		function fetchUniformLocations( gl, program, identifiers ) {
	
			var uniforms = {};
	
			var n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );
	
			for ( var i = 0; i < n; i ++ ) {
	
				var info = gl.getActiveUniform( program, i );
				var name = info.name;
				var location = gl.getUniformLocation( program, name );
	
				//console.log("THREE.WebGLProgram: ACTIVE UNIFORM:", name);
	
				var matches = structRe.exec( name );
				if ( matches ) {
	
					var structName = matches[ 1 ];
					var structProperty = matches[ 2 ];
	
					var uniformsStruct = uniforms[ structName ];
	
					if ( ! uniformsStruct ) {
	
						uniformsStruct = uniforms[ structName ] = {};
	
					}
	
					uniformsStruct[ structProperty ] = location;
	
					continue;
	
				}
	
				matches = arrayStructRe.exec( name );
	
				if ( matches ) {
	
					var arrayName = matches[ 1 ];
					var arrayIndex = matches[ 2 ];
					var arrayProperty = matches[ 3 ];
	
					var uniformsArray = uniforms[ arrayName ];
	
					if ( ! uniformsArray ) {
	
						uniformsArray = uniforms[ arrayName ] = [];
	
					}
	
					var uniformsArrayIndex = uniformsArray[ arrayIndex ];
	
					if ( ! uniformsArrayIndex ) {
	
						uniformsArrayIndex = uniformsArray[ arrayIndex ] = {};
	
					}
	
					uniformsArrayIndex[ arrayProperty ] = location;
	
					continue;
	
				}
	
				matches = arrayRe.exec( name );
	
				if ( matches ) {
	
					var arrayName = matches[ 1 ];
	
					uniforms[ arrayName ] = location;
	
					continue;
	
				}
	
				uniforms[ name ] = location;
	
			}
	
			return uniforms;
	
		}
	
		function fetchAttributeLocations( gl, program, identifiers ) {
	
			var attributes = {};
	
			var n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );
	
			for ( var i = 0; i < n; i ++ ) {
	
				var info = gl.getActiveAttrib( program, i );
				var name = info.name;
	
				// console.log("THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:", name, i );
	
				attributes[ name ] = gl.getAttribLocation( program, name );
	
			}
	
			return attributes;
	
		}
	
		function filterEmptyLine( string ) {
	
			return string !== '';
	
		}
	
		function replaceLightNums( string, parameters ) {
	
			return string
				.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )
				.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )
				.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )
				.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights );
	
		}
	
		function unrollLoops( string ) {
	
			var pattern = /for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
	
			function replace( match, start, end, snippet ) {
	
				var unroll = '';
	
				for ( var i = parseInt( start ); i < parseInt( end ); i ++ ) {
	
					unroll += snippet.replace( /\[ i \]/g, '[ ' + i + ' ]' );
	
				}
	
				return unroll;
	
			}
	
			return string.replace( pattern, replace );
	
		}
	
		return function WebGLProgram( renderer, code, material, parameters ) {
	
			var gl = renderer.context;
	
			var extensions = material.extensions;
			var defines = material.defines;
	
			var vertexShader = material.__webglShader.vertexShader;
			var fragmentShader = material.__webglShader.fragmentShader;
	
			var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';
	
			if ( parameters.shadowMapType === THREE.PCFShadowMap ) {
	
				shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';
	
			} else if ( parameters.shadowMapType === THREE.PCFSoftShadowMap ) {
	
				shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';
	
			}
	
			var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
			var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
			var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
	
			if ( parameters.envMap ) {
	
				switch ( material.envMap.mapping ) {
	
					case THREE.CubeReflectionMapping:
					case THREE.CubeRefractionMapping:
						envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
						break;
	
					case THREE.EquirectangularReflectionMapping:
					case THREE.EquirectangularRefractionMapping:
						envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
						break;
	
					case THREE.SphericalReflectionMapping:
						envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
						break;
	
				}
	
				switch ( material.envMap.mapping ) {
	
					case THREE.CubeRefractionMapping:
					case THREE.EquirectangularRefractionMapping:
						envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
						break;
	
				}
	
				switch ( material.combine ) {
	
					case THREE.MultiplyOperation:
						envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
						break;
	
					case THREE.MixOperation:
						envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
						break;
	
					case THREE.AddOperation:
						envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
						break;
	
				}
	
			}
	
			var gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;
	
			// console.log( 'building new program ' );
	
			//
	
			var customExtensions = generateExtensions( extensions, parameters, renderer.extensions );
	
			var customDefines = generateDefines( defines );
	
			//
	
			var program = gl.createProgram();
	
			var prefixVertex, prefixFragment;
	
			if ( material instanceof THREE.RawShaderMaterial ) {
	
				prefixVertex = '';
				prefixFragment = '';
	
			} else {
	
				prefixVertex = [
	
					'precision ' + parameters.precision + ' float;',
					'precision ' + parameters.precision + ' int;',
	
					'#define SHADER_NAME ' + material.__webglShader.name,
	
					customDefines,
	
					parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',
	
					renderer.gammaInput ? '#define GAMMA_INPUT' : '',
					renderer.gammaOutput ? '#define GAMMA_OUTPUT' : '',
					'#define GAMMA_FACTOR ' + gammaFactorDefine,
	
					'#define MAX_BONES ' + parameters.maxBones,
	
					parameters.map ? '#define USE_MAP' : '',
					parameters.envMap ? '#define USE_ENVMAP' : '',
					parameters.envMap ? '#define ' + envMapModeDefine : '',
					parameters.lightMap ? '#define USE_LIGHTMAP' : '',
					parameters.aoMap ? '#define USE_AOMAP' : '',
					parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
					parameters.bumpMap ? '#define USE_BUMPMAP' : '',
					parameters.normalMap ? '#define USE_NORMALMAP' : '',
					parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
					parameters.specularMap ? '#define USE_SPECULARMAP' : '',
					parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
					parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
					parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
					parameters.vertexColors ? '#define USE_COLOR' : '',
	
					parameters.flatShading ? '#define FLAT_SHADED' : '',
	
					parameters.skinning ? '#define USE_SKINNING' : '',
					parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',
	
					parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
					parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
					parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
					parameters.flipSided ? '#define FLIP_SIDED' : '',
	
					parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
					parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
					parameters.pointLightShadows > 0 ? '#define POINT_LIGHT_SHADOWS' : '',
	
					parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',
	
					parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
					parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',
	
	
					'uniform mat4 modelMatrix;',
					'uniform mat4 modelViewMatrix;',
					'uniform mat4 projectionMatrix;',
					'uniform mat4 viewMatrix;',
					'uniform mat3 normalMatrix;',
					'uniform vec3 cameraPosition;',
	
					'attribute vec3 position;',
					'attribute vec3 normal;',
					'attribute vec2 uv;',
	
					'#ifdef USE_COLOR',
	
					'	attribute vec3 color;',
	
					'#endif',
	
					'#ifdef USE_MORPHTARGETS',
	
					'	attribute vec3 morphTarget0;',
					'	attribute vec3 morphTarget1;',
					'	attribute vec3 morphTarget2;',
					'	attribute vec3 morphTarget3;',
	
					'	#ifdef USE_MORPHNORMALS',
	
					'		attribute vec3 morphNormal0;',
					'		attribute vec3 morphNormal1;',
					'		attribute vec3 morphNormal2;',
					'		attribute vec3 morphNormal3;',
	
					'	#else',
	
					'		attribute vec3 morphTarget4;',
					'		attribute vec3 morphTarget5;',
					'		attribute vec3 morphTarget6;',
					'		attribute vec3 morphTarget7;',
	
					'	#endif',
	
					'#endif',
	
					'#ifdef USE_SKINNING',
	
					'	attribute vec4 skinIndex;',
					'	attribute vec4 skinWeight;',
	
					'#endif',
	
					'\n'
	
				].filter( filterEmptyLine ).join( '\n' );
	
	
				prefixFragment = [
	
					customExtensions,
	
					'precision ' + parameters.precision + ' float;',
					'precision ' + parameters.precision + ' int;',
	
					'#define SHADER_NAME ' + material.__webglShader.name,
	
					customDefines,
	
					parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',
	
					renderer.gammaInput ? '#define GAMMA_INPUT' : '',
					renderer.gammaOutput ? '#define GAMMA_OUTPUT' : '',
					'#define GAMMA_FACTOR ' + gammaFactorDefine,
	
					( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
					( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',
	
					parameters.map ? '#define USE_MAP' : '',
					parameters.envMap ? '#define USE_ENVMAP' : '',
					parameters.envMap ? '#define ' + envMapTypeDefine : '',
					parameters.envMap ? '#define ' + envMapModeDefine : '',
					parameters.envMap ? '#define ' + envMapBlendingDefine : '',
					parameters.lightMap ? '#define USE_LIGHTMAP' : '',
					parameters.aoMap ? '#define USE_AOMAP' : '',
					parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
					parameters.bumpMap ? '#define USE_BUMPMAP' : '',
					parameters.normalMap ? '#define USE_NORMALMAP' : '',
					parameters.specularMap ? '#define USE_SPECULARMAP' : '',
					parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
					parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
					parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
					parameters.vertexColors ? '#define USE_COLOR' : '',
	
					parameters.flatShading ? '#define FLAT_SHADED' : '',
	
					parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
					parameters.flipSided ? '#define FLIP_SIDED' : '',
	
					parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
					parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
					parameters.pointLightShadows > 0 ? '#define POINT_LIGHT_SHADOWS' : '',
	
					parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
					parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',
	
					parameters.envMap && renderer.extensions.get( 'EXT_shader_texture_lod' ) ? '#define TEXTURE_LOD_EXT' : '',
	
					'uniform mat4 viewMatrix;',
					'uniform vec3 cameraPosition;',
	
					'\n'
	
				].filter( filterEmptyLine ).join( '\n' );
	
			}
	
			vertexShader = replaceLightNums( vertexShader, parameters );
			fragmentShader = replaceLightNums( fragmentShader, parameters );
	
			if ( material instanceof THREE.ShaderMaterial === false ) {
	
				vertexShader = unrollLoops( vertexShader );
				fragmentShader = unrollLoops( fragmentShader );
	
			}
	
			var vertexGlsl = prefixVertex + vertexShader;
			var fragmentGlsl = prefixFragment + fragmentShader;
	
			// console.log( '*VERTEX*', vertexGlsl );
			// console.log( '*FRAGMENT*', fragmentGlsl );
	
			var glVertexShader = THREE.WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );
			var glFragmentShader = THREE.WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );
	
			gl.attachShader( program, glVertexShader );
			gl.attachShader( program, glFragmentShader );
	
			// Force a particular attribute to index 0.
	
			if ( material.index0AttributeName !== undefined ) {
	
				gl.bindAttribLocation( program, 0, material.index0AttributeName );
	
			} else if ( parameters.morphTargets === true ) {
	
				// programs with morphTargets displace position out of attribute 0
				gl.bindAttribLocation( program, 0, 'position' );
	
			}
	
			gl.linkProgram( program );
	
			var programLog = gl.getProgramInfoLog( program );
			var vertexLog = gl.getShaderInfoLog( glVertexShader );
			var fragmentLog = gl.getShaderInfoLog( glFragmentShader );
	
			var runnable = true;
			var haveDiagnostics = true;
	
			// console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );
			// console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );
	
			if ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {
	
				runnable = false;
	
				console.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );
	
			} else if ( programLog !== '' ) {
	
				console.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );
	
			} else if ( vertexLog === '' || fragmentLog === '' ) {
	
				haveDiagnostics = false;
	
			}
	
			if ( haveDiagnostics ) {
	
				this.diagnostics = {
	
					runnable: runnable,
					material: material,
	
					programLog: programLog,
	
					vertexShader: {
	
						log: vertexLog,
						prefix: prefixVertex
	
					},
	
					fragmentShader: {
	
						log: fragmentLog,
						prefix: prefixFragment
	
					}
	
				};
	
			}
	
			// clean up
	
			gl.deleteShader( glVertexShader );
			gl.deleteShader( glFragmentShader );
	
			// set up caching for uniform locations
	
			var cachedUniforms;
	
			this.getUniforms = function() {
	
				if ( cachedUniforms === undefined ) {
	
					cachedUniforms = fetchUniformLocations( gl, program );
	
				}
	
				return cachedUniforms;
	
			};
	
			// set up caching for attribute locations
	
			var cachedAttributes;
	
			this.getAttributes = function() {
	
				if ( cachedAttributes === undefined ) {
	
					cachedAttributes = fetchAttributeLocations( gl, program );
	
				}
	
				return cachedAttributes;
	
			};
	
			// free resource
	
			this.destroy = function() {
	
				gl.deleteProgram( program );
				this.program = undefined;
	
			};
	
			// DEPRECATED
	
			Object.defineProperties( this, {
	
				uniforms: {
					get: function() {
	
						console.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );
						return this.getUniforms();
	
					}
				},
	
				attributes: {
					get: function() {
	
						console.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );
						return this.getAttributes();
	
					}
				}
	
			} );
	
	
			//
	
			this.id = programIdCount ++;
			this.code = code;
			this.usedTimes = 1;
			this.program = program;
			this.vertexShader = glVertexShader;
			this.fragmentShader = glFragmentShader;
	
			return this;
	
		};
	
	} )();
	
	// File:src/renderers/webgl/WebGLPrograms.js
	
	THREE.WebGLPrograms = function ( renderer, capabilities ) {
	
		var programs = [];
	
		var shaderIDs = {
			MeshDepthMaterial: 'depth',
			MeshNormalMaterial: 'normal',
			MeshBasicMaterial: 'basic',
			MeshLambertMaterial: 'lambert',
			MeshPhongMaterial: 'phong',
			MeshStandardMaterial: 'standard',
			LineBasicMaterial: 'basic',
			LineDashedMaterial: 'dashed',
			PointsMaterial: 'points'
		};
	
		var parameterNames = [
			"precision", "supportsVertexTextures", "map", "envMap", "envMapMode",
			"lightMap", "aoMap", "emissiveMap", "bumpMap", "normalMap", "displacementMap", "specularMap",
			"roughnessMap", "metalnessMap",
			"alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp",
			"flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning",
			"maxBones", "useVertexTexture", "morphTargets", "morphNormals",
			"maxMorphTargets", "maxMorphNormals",
			"numDirLights", "numPointLights", "numSpotLights", "numHemiLights",
			"shadowMapEnabled", "pointLightShadows",
			"shadowMapType",
			"alphaTest", "doubleSided", "flipSided"
		];
	
	
		function allocateBones ( object ) {
	
			if ( capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture ) {
	
				return 1024;
	
			} else {
	
				// default for when object is not specified
				// ( for example when prebuilding shader to be used with multiple objects )
				//
				//  - leave some extra space for other uniforms
				//  - limit here is ANGLE's 254 max uniform vectors
				//    (up to 54 should be safe)
	
				var nVertexUniforms = capabilities.maxVertexUniforms;
				var nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );
	
				var maxBones = nVertexMatrices;
	
				if ( object !== undefined && object instanceof THREE.SkinnedMesh ) {
	
					maxBones = Math.min( object.skeleton.bones.length, maxBones );
	
					if ( maxBones < object.skeleton.bones.length ) {
	
						console.warn( 'WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)' );
	
					}
	
				}
	
				return maxBones;
	
			}
	
		}
	
		this.getParameters = function ( material, lights, fog, object ) {
	
			var shaderID = shaderIDs[ material.type ];
			// heuristics to create shader parameters according to lights in the scene
			// (not to blow over maxLights budget)
	
			var maxBones = allocateBones( object );
			var precision = renderer.getPrecision();
	
			if ( material.precision !== null ) {
	
				precision = capabilities.getMaxPrecision( material.precision );
	
				if ( precision !== material.precision ) {
	
					console.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );
	
				}
	
			}
	
			var parameters = {
	
				shaderID: shaderID,
	
				precision: precision,
				supportsVertexTextures: capabilities.vertexTextures,
	
				map: !! material.map,
				envMap: !! material.envMap,
				envMapMode: material.envMap && material.envMap.mapping,
				lightMap: !! material.lightMap,
				aoMap: !! material.aoMap,
				emissiveMap: !! material.emissiveMap,
				bumpMap: !! material.bumpMap,
				normalMap: !! material.normalMap,
				displacementMap: !! material.displacementMap,
				roughnessMap: !! material.roughnessMap,
				metalnessMap: !! material.metalnessMap,
				specularMap: !! material.specularMap,
				alphaMap: !! material.alphaMap,
	
				combine: material.combine,
	
				vertexColors: material.vertexColors,
	
				fog: fog,
				useFog: material.fog,
				fogExp: fog instanceof THREE.FogExp2,
	
				flatShading: material.shading === THREE.FlatShading,
	
				sizeAttenuation: material.sizeAttenuation,
				logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,
	
				skinning: material.skinning,
				maxBones: maxBones,
				useVertexTexture: capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture,
	
				morphTargets: material.morphTargets,
				morphNormals: material.morphNormals,
				maxMorphTargets: renderer.maxMorphTargets,
				maxMorphNormals: renderer.maxMorphNormals,
	
				numDirLights: lights.directional.length,
				numPointLights: lights.point.length,
				numSpotLights: lights.spot.length,
				numHemiLights: lights.hemi.length,
	
				pointLightShadows: lights.shadowsPointLight,
	
				shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && lights.shadows.length > 0,
				shadowMapType: renderer.shadowMap.type,
	
				alphaTest: material.alphaTest,
				doubleSided: material.side === THREE.DoubleSide,
				flipSided: material.side === THREE.BackSide
	
			};
	
			return parameters;
	
		};
	
		this.getProgramCode = function ( material, parameters ) {
	
			var chunks = [];
	
			if ( parameters.shaderID ) {
	
				chunks.push( parameters.shaderID );
	
			} else {
	
				chunks.push( material.fragmentShader );
				chunks.push( material.vertexShader );
	
			}
	
			if ( material.defines !== undefined ) {
	
				for ( var name in material.defines ) {
	
					chunks.push( name );
					chunks.push( material.defines[ name ] );
	
				}
	
			}
	
			for ( var i = 0; i < parameterNames.length; i ++ ) {
	
				var parameterName = parameterNames[ i ];
				chunks.push( parameterName );
				chunks.push( parameters[ parameterName ] );
	
			}
	
			return chunks.join();
	
		};
	
		this.acquireProgram = function ( material, parameters, code ) {
	
			var program;
	
			// Check if code has been already compiled
			for ( var p = 0, pl = programs.length; p < pl; p ++ ) {
	
				var programInfo = programs[ p ];
	
				if ( programInfo.code === code ) {
	
					program = programInfo;
					++ program.usedTimes;
	
					break;
	
				}
	
			}
	
			if ( program === undefined ) {
	
				program = new THREE.WebGLProgram( renderer, code, material, parameters );
				programs.push( program );
	
			}
	
			return program;
	
		};
	
		this.releaseProgram = function( program ) {
	
			if ( -- program.usedTimes === 0 ) {
	
				// Remove from unordered set
				var i = programs.indexOf( program );
				programs[ i ] = programs[ programs.length - 1 ];
				programs.pop();
	
				// Free WebGL resources
				program.destroy();
	
			}
	
		};
	
		// Exposed for resource monitoring & error feedback via renderer.info:
		this.programs = programs;
	
	};
	
	// File:src/renderers/webgl/WebGLProperties.js
	
	/**
	* @author fordacious / fordacious.github.io
	*/
	
	THREE.WebGLProperties = function () {
	
		var properties = {};
	
		this.get = function ( object ) {
	
			var uuid = object.uuid;
			var map = properties[ uuid ];
	
			if ( map === undefined ) {
	
				map = {};
				properties[ uuid ] = map;
	
			}
	
			return map;
	
		};
	
		this.delete = function ( object ) {
	
			delete properties[ object.uuid ];
	
		};
	
		this.clear = function () {
	
			properties = {};
	
		};
	
	};
	
	// File:src/renderers/webgl/WebGLShader.js
	
	THREE.WebGLShader = ( function () {
	
		function addLineNumbers( string ) {
	
			var lines = string.split( '\n' );
	
			for ( var i = 0; i < lines.length; i ++ ) {
	
				lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];
	
			}
	
			return lines.join( '\n' );
	
		}
	
		return function WebGLShader( gl, type, string ) {
	
			var shader = gl.createShader( type );
	
			gl.shaderSource( shader, string );
			gl.compileShader( shader );
	
			if ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {
	
				console.error( 'THREE.WebGLShader: Shader couldn\'t compile.' );
	
			}
	
			if ( gl.getShaderInfoLog( shader ) !== '' ) {
	
				console.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );
	
			}
	
			// --enable-privileged-webgl-extension
			// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );
	
			return shader;
	
		};
	
	} )();
	
	// File:src/renderers/webgl/WebGLShadowMap.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.WebGLShadowMap = function ( _renderer, _lights, _objects ) {
	
		var _gl = _renderer.context,
		_state = _renderer.state,
		_frustum = new THREE.Frustum(),
		_projScreenMatrix = new THREE.Matrix4(),
	
		_lookTarget = new THREE.Vector3(),
		_lightPositionWorld = new THREE.Vector3(),
	
		_renderList = [],
	
		_MorphingFlag = 1,
		_SkinningFlag = 2,
	
		_NumberOfMaterialVariants = ( _MorphingFlag | _SkinningFlag ) + 1,
	
		_depthMaterials = new Array( _NumberOfMaterialVariants ),
		_distanceMaterials = new Array( _NumberOfMaterialVariants );
	
		var cubeDirections = [
			new THREE.Vector3( 1, 0, 0 ), new THREE.Vector3( - 1, 0, 0 ), new THREE.Vector3( 0, 0, 1 ),
			new THREE.Vector3( 0, 0, - 1 ), new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, - 1, 0 )
		];
	
		var cubeUps = [
			new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 1, 0 ),
			new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 0, 1 ),	new THREE.Vector3( 0, 0, - 1 )
		];
	
		var cube2DViewPorts = [
			new THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4(),
			new THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4()
		];
	
		// init
	
		var depthShader = THREE.ShaderLib[ "depthRGBA" ];
		var depthUniforms = THREE.UniformsUtils.clone( depthShader.uniforms );
	
		var distanceShader = THREE.ShaderLib[ "distanceRGBA" ];
		var distanceUniforms = THREE.UniformsUtils.clone( distanceShader.uniforms );
	
		for ( var i = 0; i !== _NumberOfMaterialVariants; ++ i ) {
	
			var useMorphing = ( i & _MorphingFlag ) !== 0;
			var useSkinning = ( i & _SkinningFlag ) !== 0;
	
			var depthMaterial = new THREE.ShaderMaterial( {
				uniforms: depthUniforms,
				vertexShader: depthShader.vertexShader,
				fragmentShader: depthShader.fragmentShader,
				morphTargets: useMorphing,
				skinning: useSkinning
			} );
	
			depthMaterial._shadowPass = true;
	
			_depthMaterials[ i ] = depthMaterial;
	
			var distanceMaterial = new THREE.ShaderMaterial( {
				uniforms: distanceUniforms,
				vertexShader: distanceShader.vertexShader,
				fragmentShader: distanceShader.fragmentShader,
				morphTargets: useMorphing,
				skinning: useSkinning
			} );
	
			distanceMaterial._shadowPass = true;
	
			_distanceMaterials[ i ] = distanceMaterial;
	
		}
	
		//
	
		var scope = this;
	
		this.enabled = false;
	
		this.autoUpdate = true;
		this.needsUpdate = false;
	
		this.type = THREE.PCFShadowMap;
		this.cullFace = THREE.CullFaceFront;
	
		this.render = function ( scene, camera ) {
	
			var faceCount, isPointLight;
	
			if ( scope.enabled === false ) return;
			if ( scope.autoUpdate === false && scope.needsUpdate === false ) return;
	
			// Set GL state for depth map.
			_state.clearColor( 1, 1, 1, 1 );
			_state.disable( _gl.BLEND );
			_state.enable( _gl.CULL_FACE );
			_gl.frontFace( _gl.CCW );
			_gl.cullFace( scope.cullFace === THREE.CullFaceFront ? _gl.FRONT : _gl.BACK );
			_state.setDepthTest( true );
			_state.setScissorTest( false );
	
			// render depth map
	
			var shadows = _lights.shadows;
	
			for ( var i = 0, il = shadows.length; i < il; i ++ ) {
	
				var light = shadows[ i ];
	
				var shadow = light.shadow;
				var shadowCamera = shadow.camera;
				var shadowMapSize = shadow.mapSize;
	
				if ( light instanceof THREE.PointLight ) {
	
					faceCount = 6;
					isPointLight = true;
	
					var vpWidth = shadowMapSize.x / 4.0;
					var vpHeight = shadowMapSize.y / 2.0;
	
					// These viewports map a cube-map onto a 2D texture with the
					// following orientation:
					//
					//  xzXZ
					//   y Y
					//
					// X - Positive x direction
					// x - Negative x direction
					// Y - Positive y direction
					// y - Negative y direction
					// Z - Positive z direction
					// z - Negative z direction
	
					// positive X
					cube2DViewPorts[ 0 ].set( vpWidth * 2, vpHeight, vpWidth, vpHeight );
					// negative X
					cube2DViewPorts[ 1 ].set( 0, vpHeight, vpWidth, vpHeight );
					// positive Z
					cube2DViewPorts[ 2 ].set( vpWidth * 3, vpHeight, vpWidth, vpHeight );
					// negative Z
					cube2DViewPorts[ 3 ].set( vpWidth, vpHeight, vpWidth, vpHeight );
					// positive Y
					cube2DViewPorts[ 4 ].set( vpWidth * 3, 0, vpWidth, vpHeight );
					// negative Y
					cube2DViewPorts[ 5 ].set( vpWidth, 0, vpWidth, vpHeight );
	
				} else {
	
					faceCount = 1;
					isPointLight = false;
	
				}
	
				if ( shadow.map === null ) {
	
					var pars = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat };
	
					shadow.map = new THREE.WebGLRenderTarget( shadowMapSize.x, shadowMapSize.y, pars );
	
					//
	
					if ( light instanceof THREE.SpotLight ) {
	
						shadowCamera.aspect = shadowMapSize.x / shadowMapSize.y;
	
					}
	
					shadowCamera.updateProjectionMatrix();
	
				}
	
				var shadowMap = shadow.map;
				var shadowMatrix = shadow.matrix;
	
				_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
				shadowCamera.position.copy( _lightPositionWorld );
	
				_renderer.setRenderTarget( shadowMap );
				_renderer.clear();
	
				// render shadow map for each cube face (if omni-directional) or
				// run a single pass if not
	
				for ( var face = 0; face < faceCount; face ++ ) {
	
					if ( isPointLight ) {
	
						_lookTarget.copy( shadowCamera.position );
						_lookTarget.add( cubeDirections[ face ] );
						shadowCamera.up.copy( cubeUps[ face ] );
						shadowCamera.lookAt( _lookTarget );
	
						var vpDimensions = cube2DViewPorts[ face ];
						_state.viewport( vpDimensions );
	
					} else {
	
						_lookTarget.setFromMatrixPosition( light.target.matrixWorld );
						shadowCamera.lookAt( _lookTarget );
	
					}
	
					shadowCamera.updateMatrixWorld();
					shadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );
	
					// compute shadow matrix
	
					shadowMatrix.set(
						0.5, 0.0, 0.0, 0.5,
						0.0, 0.5, 0.0, 0.5,
						0.0, 0.0, 0.5, 0.5,
						0.0, 0.0, 0.0, 1.0
					);
	
					shadowMatrix.multiply( shadowCamera.projectionMatrix );
					shadowMatrix.multiply( shadowCamera.matrixWorldInverse );
	
					// update camera matrices and frustum
	
					_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
					_frustum.setFromMatrix( _projScreenMatrix );
	
					// set object matrices & frustum culling
	
					_renderList.length = 0;
	
					projectObject( scene, camera, shadowCamera );
	
					// render shadow map
					// render regular objects
	
					for ( var j = 0, jl = _renderList.length; j < jl; j ++ ) {
	
						var object = _renderList[ j ];
						var geometry = _objects.update( object );
						var material = object.material;
	
						if ( material instanceof THREE.MultiMaterial ) {
	
							var groups = geometry.groups;
							var materials = material.materials;
	
							for ( var k = 0, kl = groups.length; k < kl; k ++ ) {
	
								var group = groups[ k ];
								var groupMaterial = materials[ group.materialIndex ];
	
								if ( groupMaterial.visible === true ) {
	
									var depthMaterial = getDepthMaterial( object, groupMaterial, isPointLight, _lightPositionWorld );
									_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );
	
								}
	
							}
	
						} else {
	
							var depthMaterial = getDepthMaterial( object, material, isPointLight, _lightPositionWorld );
							_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );
	
						}
	
					}
	
				}
	
				// We must call _renderer.resetGLState() at the end of each iteration of
				// the light loop in order to force material updates for each light.
				_renderer.resetGLState();
	
			}
	
			// Restore GL state.
			var clearColor = _renderer.getClearColor(),
			clearAlpha = _renderer.getClearAlpha();
			_renderer.setClearColor( clearColor, clearAlpha );
	
			_state.enable( _gl.BLEND );
	
			if ( scope.cullFace === THREE.CullFaceFront ) {
	
				_gl.cullFace( _gl.BACK );
	
			}
	
			_renderer.resetGLState();
	
			scope.needsUpdate = false;
	
		};
	
		function getDepthMaterial( object, material, isPointLight, lightPositionWorld ) {
	
			var geometry = object.geometry;
	
			var newMaterial = null;
	
			var materialVariants = _depthMaterials;
			var customMaterial = object.customDepthMaterial;
	
			if ( isPointLight ) {
	
				materialVariants = _distanceMaterials;
				customMaterial = object.customDistanceMaterial;
	
			}
	
			if ( ! customMaterial ) {
	
				var useMorphing = geometry.morphTargets !== undefined &&
						geometry.morphTargets.length > 0 && material.morphTargets;
	
				var useSkinning = object instanceof THREE.SkinnedMesh && material.skinning;
	
				var variantIndex = 0;
	
				if ( useMorphing ) variantIndex |= _MorphingFlag;
				if ( useSkinning ) variantIndex |= _SkinningFlag;
	
				newMaterial = materialVariants[ variantIndex ];
	
			} else {
	
				newMaterial = customMaterial;
	
			}
	
			newMaterial.visible = material.visible;
			newMaterial.wireframe = material.wireframe;
			newMaterial.wireframeLinewidth = material.wireframeLinewidth;
	
			if ( isPointLight && newMaterial.uniforms.lightPos !== undefined ) {
	
				newMaterial.uniforms.lightPos.value.copy( lightPositionWorld );
	
			}
	
			return newMaterial;
	
		}
	
		function projectObject( object, camera, shadowCamera ) {
	
			if ( object.visible === false ) return;
	
			if ( object.layers.test( camera.layers ) && ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points ) ) {
	
				if ( object.castShadow && ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) ) {
	
					var material = object.material;
	
					if ( material.visible === true ) {
	
						object.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );
						_renderList.push( object );
	
					}
	
				}
	
			}
	
			var children = object.children;
	
			for ( var i = 0, l = children.length; i < l; i ++ ) {
	
				projectObject( children[ i ], camera, shadowCamera );
	
			}
	
		}
	
	};
	
	// File:src/renderers/webgl/WebGLState.js
	
	/**
	* @author mrdoob / http://mrdoob.com/
	*/
	
	THREE.WebGLState = function ( gl, extensions, paramThreeToGL ) {
	
		var _this = this;
	
		var color = new THREE.Vector4();
	
		var newAttributes = new Uint8Array( 16 );
		var enabledAttributes = new Uint8Array( 16 );
		var attributeDivisors = new Uint8Array( 16 );
	
		var capabilities = {};
	
		var compressedTextureFormats = null;
	
		var currentBlending = null;
		var currentBlendEquation = null;
		var currentBlendSrc = null;
		var currentBlendDst = null;
		var currentBlendEquationAlpha = null;
		var currentBlendSrcAlpha = null;
		var currentBlendDstAlpha = null;
	
		var currentDepthFunc = null;
		var currentDepthWrite = null;
	
		var currentColorWrite = null;
	
		var currentStencilWrite = null;
		var currentStencilFunc = null;
		var currentStencilRef = null;
		var currentStencilMask = null;
		var currentStencilFail  = null;
		var currentStencilZFail = null;
		var currentStencilZPass = null;
	
		var currentFlipSided = null;
	
		var currentLineWidth = null;
	
		var currentPolygonOffsetFactor = null;
		var currentPolygonOffsetUnits = null;
	
		var currentScissorTest = null;
	
		var maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );
	
		var currentTextureSlot = undefined;
		var currentBoundTextures = {};
	
		var currentClearColor = new THREE.Vector4();
		var currentClearDepth = null;
		var currentClearStencil = null;
	
		var currentScissor = new THREE.Vector4();
		var currentViewport = new THREE.Vector4();
	
		this.init = function () {
	
			this.clearColor( 0, 0, 0, 1 );
			this.clearDepth( 1 );
			this.clearStencil( 0 );
	
			this.enable( gl.DEPTH_TEST );
			gl.depthFunc( gl.LEQUAL );
	
			gl.frontFace( gl.CCW );
			gl.cullFace( gl.BACK );
			this.enable( gl.CULL_FACE );
	
			this.enable( gl.BLEND );
			gl.blendEquation( gl.FUNC_ADD );
			gl.blendFunc( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA );
	
		};
	
		this.initAttributes = function () {
	
			for ( var i = 0, l = newAttributes.length; i < l; i ++ ) {
	
				newAttributes[ i ] = 0;
	
			}
	
		};
	
		this.enableAttribute = function ( attribute ) {
	
			newAttributes[ attribute ] = 1;
	
			if ( enabledAttributes[ attribute ] === 0 ) {
	
				gl.enableVertexAttribArray( attribute );
				enabledAttributes[ attribute ] = 1;
	
			}
	
			if ( attributeDivisors[ attribute ] !== 0 ) {
	
				var extension = extensions.get( 'ANGLE_instanced_arrays' );
	
				extension.vertexAttribDivisorANGLE( attribute, 0 );
				attributeDivisors[ attribute ] = 0;
	
			}
	
		};
	
		this.enableAttributeAndDivisor = function ( attribute, meshPerAttribute, extension ) {
	
			newAttributes[ attribute ] = 1;
	
			if ( enabledAttributes[ attribute ] === 0 ) {
	
				gl.enableVertexAttribArray( attribute );
				enabledAttributes[ attribute ] = 1;
	
			}
	
			if ( attributeDivisors[ attribute ] !== meshPerAttribute ) {
	
				extension.vertexAttribDivisorANGLE( attribute, meshPerAttribute );
				attributeDivisors[ attribute ] = meshPerAttribute;
	
			}
	
		};
	
		this.disableUnusedAttributes = function () {
	
			for ( var i = 0, l = enabledAttributes.length; i < l; i ++ ) {
	
				if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {
	
					gl.disableVertexAttribArray( i );
					enabledAttributes[ i ] = 0;
	
				}
	
			}
	
		};
	
		this.enable = function ( id ) {
	
			if ( capabilities[ id ] !== true ) {
	
				gl.enable( id );
				capabilities[ id ] = true;
	
			}
	
		};
	
		this.disable = function ( id ) {
	
			if ( capabilities[ id ] !== false ) {
	
				gl.disable( id );
				capabilities[ id ] = false;
	
			}
	
		};
	
		this.getCompressedTextureFormats = function () {
	
			if ( compressedTextureFormats === null ) {
	
				compressedTextureFormats = [];
	
				if ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||
				     extensions.get( 'WEBGL_compressed_texture_s3tc' ) ||
				     extensions.get( 'WEBGL_compressed_texture_etc1' )) {
	
					var formats = gl.getParameter( gl.COMPRESSED_TEXTURE_FORMATS );
	
					for ( var i = 0; i < formats.length; i ++ ) {
	
						compressedTextureFormats.push( formats[ i ] );
	
					}
	
				}
	
			}
	
			return compressedTextureFormats;
	
		};
	
		this.setBlending = function ( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha ) {
	
			if ( blending === THREE.NoBlending ) {
	
				this.disable( gl.BLEND );
	
			} else {
	
				this.enable( gl.BLEND );
	
			}
	
			if ( blending !== currentBlending ) {
	
				if ( blending === THREE.AdditiveBlending ) {
	
					gl.blendEquation( gl.FUNC_ADD );
					gl.blendFunc( gl.SRC_ALPHA, gl.ONE );
	
				} else if ( blending === THREE.SubtractiveBlending ) {
	
					// TODO: Find blendFuncSeparate() combination
	
					gl.blendEquation( gl.FUNC_ADD );
					gl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );
	
				} else if ( blending === THREE.MultiplyBlending ) {
	
					// TODO: Find blendFuncSeparate() combination
	
					gl.blendEquation( gl.FUNC_ADD );
					gl.blendFunc( gl.ZERO, gl.SRC_COLOR );
	
				} else {
	
					gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
					gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );
	
				}
	
				currentBlending = blending;
	
			}
	
			if ( blending === THREE.CustomBlending ) {
	
				blendEquationAlpha = blendEquationAlpha || blendEquation;
				blendSrcAlpha = blendSrcAlpha || blendSrc;
				blendDstAlpha = blendDstAlpha || blendDst;
	
				if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {
	
					gl.blendEquationSeparate( paramThreeToGL( blendEquation ), paramThreeToGL( blendEquationAlpha ) );
	
					currentBlendEquation = blendEquation;
					currentBlendEquationAlpha = blendEquationAlpha;
	
				}
	
				if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {
	
					gl.blendFuncSeparate( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ), paramThreeToGL( blendSrcAlpha ), paramThreeToGL( blendDstAlpha ) );
	
					currentBlendSrc = blendSrc;
					currentBlendDst = blendDst;
					currentBlendSrcAlpha = blendSrcAlpha;
					currentBlendDstAlpha = blendDstAlpha;
	
				}
	
			} else {
	
				currentBlendEquation = null;
				currentBlendSrc = null;
				currentBlendDst = null;
				currentBlendEquationAlpha = null;
				currentBlendSrcAlpha = null;
				currentBlendDstAlpha = null;
	
			}
	
		};
	
		this.setDepthFunc = function ( depthFunc ) {
	
			if ( currentDepthFunc !== depthFunc ) {
	
				if ( depthFunc ) {
	
					switch ( depthFunc ) {
	
						case THREE.NeverDepth:
	
							gl.depthFunc( gl.NEVER );
							break;
	
						case THREE.AlwaysDepth:
	
							gl.depthFunc( gl.ALWAYS );
							break;
	
						case THREE.LessDepth:
	
							gl.depthFunc( gl.LESS );
							break;
	
						case THREE.LessEqualDepth:
	
							gl.depthFunc( gl.LEQUAL );
							break;
	
						case THREE.EqualDepth:
	
							gl.depthFunc( gl.EQUAL );
							break;
	
						case THREE.GreaterEqualDepth:
	
							gl.depthFunc( gl.GEQUAL );
							break;
	
						case THREE.GreaterDepth:
	
							gl.depthFunc( gl.GREATER );
							break;
	
						case THREE.NotEqualDepth:
	
							gl.depthFunc( gl.NOTEQUAL );
							break;
	
						default:
	
							gl.depthFunc( gl.LEQUAL );
	
					}
	
				} else {
	
					gl.depthFunc( gl.LEQUAL );
	
				}
	
				currentDepthFunc = depthFunc;
	
			}
	
		};
	
		this.setDepthTest = function ( depthTest ) {
	
			if ( depthTest ) {
	
				this.enable( gl.DEPTH_TEST );
	
			} else {
	
				this.disable( gl.DEPTH_TEST );
	
			}
	
		};
	
		this.setDepthWrite = function ( depthWrite ) {
	
			// TODO: Rename to setDepthMask
	
			if ( currentDepthWrite !== depthWrite ) {
	
				gl.depthMask( depthWrite );
				currentDepthWrite = depthWrite;
	
			}
	
		};
	
		this.setColorWrite = function ( colorWrite ) {
	
			// TODO: Rename to setColorMask
	
			if ( currentColorWrite !== colorWrite ) {
	
				gl.colorMask( colorWrite, colorWrite, colorWrite, colorWrite );
				currentColorWrite = colorWrite;
	
			}
	
		};
	
		this.setStencilFunc = function ( stencilFunc, stencilRef, stencilMask ) {
	
			if ( currentStencilFunc !== stencilFunc ||
					 currentStencilRef 	!== stencilRef 	||
					 currentStencilMask !== stencilMask ) {
	
				gl.stencilFunc( stencilFunc,  stencilRef, stencilMask );
	
				currentStencilFunc = stencilFunc;
				currentStencilRef  = stencilRef;
				currentStencilMask = stencilMask;
	
			}
	
		};
	
		this.setStencilOp = function ( stencilFail, stencilZFail, stencilZPass ) {
	
			if ( currentStencilFail	 !== stencilFail 	||
					 currentStencilZFail !== stencilZFail ||
					 currentStencilZPass !== stencilZPass ) {
	
				gl.stencilOp( stencilFail,  stencilZFail, stencilZPass );
	
				currentStencilFail  = stencilFail;
				currentStencilZFail = stencilZFail;
				currentStencilZPass = stencilZPass;
	
			}
	
		};
	
		this.setStencilTest = function ( stencilTest ) {
	
			if ( stencilTest ) {
	
				this.enable( gl.STENCIL_TEST );
	
			} else {
	
				this.disable( gl.STENCIL_TEST );
	
			}
	
		};
	
		this.setStencilWrite = function ( stencilWrite ) {
	
			// TODO: Rename to setStencilMask
	
			if ( currentStencilWrite !== stencilWrite ) {
	
				gl.stencilMask( stencilWrite );
				currentStencilWrite = stencilWrite;
	
			}
	
		};
	
		this.setFlipSided = function ( flipSided ) {
	
			if ( currentFlipSided !== flipSided ) {
	
				if ( flipSided ) {
	
					gl.frontFace( gl.CW );
	
				} else {
	
					gl.frontFace( gl.CCW );
	
				}
	
				currentFlipSided = flipSided;
	
			}
	
		};
	
		this.setLineWidth = function ( width ) {
	
			if ( width !== currentLineWidth ) {
	
				gl.lineWidth( width );
	
				currentLineWidth = width;
	
			}
	
		};
	
		this.setPolygonOffset = function ( polygonOffset, factor, units ) {
	
			if ( polygonOffset ) {
	
				this.enable( gl.POLYGON_OFFSET_FILL );
	
			} else {
	
				this.disable( gl.POLYGON_OFFSET_FILL );
	
			}
	
			if ( polygonOffset && ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) ) {
	
				gl.polygonOffset( factor, units );
	
				currentPolygonOffsetFactor = factor;
				currentPolygonOffsetUnits = units;
	
			}
	
		};
	
		this.getScissorTest = function () {
	
			return currentScissorTest;
	
		};
	
		this.setScissorTest = function ( scissorTest ) {
	
			currentScissorTest = scissorTest;
	
			if ( scissorTest ) {
	
				this.enable( gl.SCISSOR_TEST );
	
			} else {
	
				this.disable( gl.SCISSOR_TEST );
	
			}
	
		};
	
		// texture
	
		this.activeTexture = function ( webglSlot ) {
	
			if ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;
	
			if ( currentTextureSlot !== webglSlot ) {
	
				gl.activeTexture( webglSlot );
				currentTextureSlot = webglSlot;
	
			}
	
		};
	
		this.bindTexture = function ( webglType, webglTexture ) {
	
			if ( currentTextureSlot === undefined ) {
	
				_this.activeTexture();
	
			}
	
			var boundTexture = currentBoundTextures[ currentTextureSlot ];
	
			if ( boundTexture === undefined ) {
	
				boundTexture = { type: undefined, texture: undefined };
				currentBoundTextures[ currentTextureSlot ] = boundTexture;
	
			}
	
			if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {
	
				gl.bindTexture( webglType, webglTexture );
	
				boundTexture.type = webglType;
				boundTexture.texture = webglTexture;
	
			}
	
		};
	
		this.compressedTexImage2D = function () {
	
			try {
	
				gl.compressedTexImage2D.apply( gl, arguments );
	
			} catch ( error ) {
	
				console.error( error );
	
			}
	
		};
	
		this.texImage2D = function () {
	
			try {
	
				gl.texImage2D.apply( gl, arguments );
	
			} catch ( error ) {
	
				console.error( error );
	
			}
	
		};
	
		// clear values
	
		this.clearColor = function ( r, g, b, a ) {
	
			color.set( r, g, b, a );
	
			if ( currentClearColor.equals( color ) === false ) {
	
				gl.clearColor( r, g, b, a );
				currentClearColor.copy( color );
	
			}
	
		};
	
		this.clearDepth = function ( depth ) {
	
			if ( currentClearDepth !== depth ) {
	
				gl.clearDepth( depth );
				currentClearDepth = depth;
	
			}
	
		};
	
		this.clearStencil = function ( stencil ) {
	
			if ( currentClearStencil !== stencil ) {
	
				gl.clearStencil( stencil );
				currentClearStencil = stencil;
	
			}
	
		};
	
		//
	
		this.scissor = function ( scissor ) {
	
			if ( currentScissor.equals( scissor ) === false ) {
	
				gl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );
				currentScissor.copy( scissor );
	
			}
	
		};
	
		this.viewport = function ( viewport ) {
	
			if ( currentViewport.equals( viewport ) === false ) {
	
				gl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );
				currentViewport.copy( viewport );
	
			}
	
		};
	
		//
	
		this.reset = function () {
	
			for ( var i = 0; i < enabledAttributes.length; i ++ ) {
	
				if ( enabledAttributes[ i ] === 1 ) {
	
					gl.disableVertexAttribArray( i );
					enabledAttributes[ i ] = 0;
	
				}
	
			}
	
			capabilities = {};
	
			compressedTextureFormats = null;
	
			currentBlending = null;
	
			currentColorWrite = null;
			currentDepthWrite = null;
			currentStencilWrite = null;
	
			currentFlipSided = null;
	
		};
	
	};
	
	// File:src/renderers/webgl/plugins/LensFlarePlugin.js
	
	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.LensFlarePlugin = function ( renderer, flares ) {
	
		var gl = renderer.context;
		var state = renderer.state;
	
		var vertexBuffer, elementBuffer;
		var program, attributes, uniforms;
		var hasVertexTexture;
	
		var tempTexture, occlusionTexture;
	
		function init() {
	
			var vertices = new Float32Array( [
				- 1, - 1,  0, 0,
				 1, - 1,  1, 0,
				 1,  1,  1, 1,
				- 1,  1,  0, 1
			] );
	
			var faces = new Uint16Array( [
				0, 1, 2,
				0, 2, 3
			] );
	
			// buffers
	
			vertexBuffer     = gl.createBuffer();
			elementBuffer    = gl.createBuffer();
	
			gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
			gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );
	
			gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
			gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );
	
			// textures
	
			tempTexture      = gl.createTexture();
			occlusionTexture = gl.createTexture();
	
			state.bindTexture( gl.TEXTURE_2D, tempTexture );
			gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );
	
			state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
			gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );
	
			hasVertexTexture = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS ) > 0;
	
			var shader;
	
			if ( hasVertexTexture ) {
	
				shader = {
	
					vertexShader: [
	
						"uniform lowp int renderType;",
	
						"uniform vec3 screenPosition;",
						"uniform vec2 scale;",
						"uniform float rotation;",
	
						"uniform sampler2D occlusionMap;",
	
						"attribute vec2 position;",
						"attribute vec2 uv;",
	
						"varying vec2 vUV;",
						"varying float vVisibility;",
	
						"void main() {",
	
							"vUV = uv;",
	
							"vec2 pos = position;",
	
							"if ( renderType == 2 ) {",
	
								"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );",
	
								"vVisibility =        visibility.r / 9.0;",
								"vVisibility *= 1.0 - visibility.g / 9.0;",
								"vVisibility *=       visibility.b / 9.0;",
								"vVisibility *= 1.0 - visibility.a / 9.0;",
	
								"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
								"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",
	
							"}",
	
							"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",
	
						"}"
	
					].join( "\n" ),
	
					fragmentShader: [
	
						"uniform lowp int renderType;",
	
						"uniform sampler2D map;",
						"uniform float opacity;",
						"uniform vec3 color;",
	
						"varying vec2 vUV;",
						"varying float vVisibility;",
	
						"void main() {",
	
							// pink square
	
							"if ( renderType == 0 ) {",
	
								"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );",
	
							// restore
	
							"} else if ( renderType == 1 ) {",
	
								"gl_FragColor = texture2D( map, vUV );",
	
							// flare
	
							"} else {",
	
								"vec4 texture = texture2D( map, vUV );",
								"texture.a *= opacity * vVisibility;",
								"gl_FragColor = texture;",
								"gl_FragColor.rgb *= color;",
	
							"}",
	
						"}"
	
					].join( "\n" )
	
				};
	
			} else {
	
				shader = {
	
					vertexShader: [
	
						"uniform lowp int renderType;",
	
						"uniform vec3 screenPosition;",
						"uniform vec2 scale;",
						"uniform float rotation;",
	
						"attribute vec2 position;",
						"attribute vec2 uv;",
	
						"varying vec2 vUV;",
	
						"void main() {",
	
							"vUV = uv;",
	
							"vec2 pos = position;",
	
							"if ( renderType == 2 ) {",
	
								"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
								"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",
	
							"}",
	
							"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",
	
						"}"
	
					].join( "\n" ),
	
					fragmentShader: [
	
						"precision mediump float;",
	
						"uniform lowp int renderType;",
	
						"uniform sampler2D map;",
						"uniform sampler2D occlusionMap;",
						"uniform float opacity;",
						"uniform vec3 color;",
	
						"varying vec2 vUV;",
	
						"void main() {",
	
							// pink square
	
							"if ( renderType == 0 ) {",
	
								"gl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );",
	
							// restore
	
							"} else if ( renderType == 1 ) {",
	
								"gl_FragColor = texture2D( map, vUV );",
	
							// flare
	
							"} else {",
	
								"float visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;",
								"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;",
								"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;",
								"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;",
								"visibility = ( 1.0 - visibility / 4.0 );",
	
								"vec4 texture = texture2D( map, vUV );",
								"texture.a *= opacity * visibility;",
								"gl_FragColor = texture;",
								"gl_FragColor.rgb *= color;",
	
							"}",
	
						"}"
	
					].join( "\n" )
	
				};
	
			}
	
			program = createProgram( shader );
	
			attributes = {
				vertex: gl.getAttribLocation ( program, "position" ),
				uv:     gl.getAttribLocation ( program, "uv" )
			};
	
			uniforms = {
				renderType:     gl.getUniformLocation( program, "renderType" ),
				map:            gl.getUniformLocation( program, "map" ),
				occlusionMap:   gl.getUniformLocation( program, "occlusionMap" ),
				opacity:        gl.getUniformLocation( program, "opacity" ),
				color:          gl.getUniformLocation( program, "color" ),
				scale:          gl.getUniformLocation( program, "scale" ),
				rotation:       gl.getUniformLocation( program, "rotation" ),
				screenPosition: gl.getUniformLocation( program, "screenPosition" )
			};
	
		}
	
		/*
		 * Render lens flares
		 * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,
		 *         reads these back and calculates occlusion.
		 */
	
		this.render = function ( scene, camera, viewport ) {
	
			if ( flares.length === 0 ) return;
	
			var tempPosition = new THREE.Vector3();
	
			var invAspect = viewport.w / viewport.z,
				halfViewportWidth = viewport.z * 0.5,
				halfViewportHeight = viewport.w * 0.5;
	
			var size = 16 / viewport.w,
				scale = new THREE.Vector2( size * invAspect, size );
	
			var screenPosition = new THREE.Vector3( 1, 1, 0 ),
				screenPositionPixels = new THREE.Vector2( 1, 1 );
	
			if ( program === undefined ) {
	
				init();
	
			}
	
			gl.useProgram( program );
	
			state.initAttributes();
			state.enableAttribute( attributes.vertex );
			state.enableAttribute( attributes.uv );
			state.disableUnusedAttributes();
	
			// loop through all lens flares to update their occlusion and positions
			// setup gl and common used attribs/uniforms
	
			gl.uniform1i( uniforms.occlusionMap, 0 );
			gl.uniform1i( uniforms.map, 1 );
	
			gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
			gl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );
			gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );
	
			gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
	
			state.disable( gl.CULL_FACE );
			state.setDepthWrite( false );
	
			for ( var i = 0, l = flares.length; i < l; i ++ ) {
	
				size = 16 / viewport.w;
				scale.set( size * invAspect, size );
	
				// calc object screen position
	
				var flare = flares[ i ];
	
				tempPosition.set( flare.matrixWorld.elements[ 12 ], flare.matrixWorld.elements[ 13 ], flare.matrixWorld.elements[ 14 ] );
	
				tempPosition.applyMatrix4( camera.matrixWorldInverse );
				tempPosition.applyProjection( camera.projectionMatrix );
	
				// setup arrays for gl programs
	
				screenPosition.copy( tempPosition );
	
				screenPositionPixels.x = screenPosition.x * halfViewportWidth + halfViewportWidth;
				screenPositionPixels.y = screenPosition.y * halfViewportHeight + halfViewportHeight;
	
				// screen cull
	
				if ( hasVertexTexture || (
					screenPositionPixels.x > 0 &&
					screenPositionPixels.x < viewport.z &&
					screenPositionPixels.y > 0 &&
					screenPositionPixels.y < viewport.w ) ) {
	
					// save current RGB to temp texture
	
					state.activeTexture( gl.TEXTURE0 );
					state.bindTexture( gl.TEXTURE_2D, null );
					state.activeTexture( gl.TEXTURE1 );
					state.bindTexture( gl.TEXTURE_2D, tempTexture );
					gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, viewport.x + screenPositionPixels.x - 8, viewport.y + screenPositionPixels.y - 8, 16, 16, 0 );
	
	
					// render pink quad
	
					gl.uniform1i( uniforms.renderType, 0 );
					gl.uniform2f( uniforms.scale, scale.x, scale.y );
					gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );
	
					state.disable( gl.BLEND );
					state.enable( gl.DEPTH_TEST );
	
					gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );
	
	
					// copy result to occlusionMap
	
					state.activeTexture( gl.TEXTURE0 );
					state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
					gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, viewport.x + screenPositionPixels.x - 8, viewport.y + screenPositionPixels.y - 8, 16, 16, 0 );
	
	
					// restore graphics
	
					gl.uniform1i( uniforms.renderType, 1 );
					state.disable( gl.DEPTH_TEST );
	
					state.activeTexture( gl.TEXTURE1 );
					state.bindTexture( gl.TEXTURE_2D, tempTexture );
					gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );
	
	
					// update object positions
	
					flare.positionScreen.copy( screenPosition );
	
					if ( flare.customUpdateCallback ) {
	
						flare.customUpdateCallback( flare );
	
					} else {
	
						flare.updateLensFlares();
	
					}
	
					// render flares
	
					gl.uniform1i( uniforms.renderType, 2 );
					state.enable( gl.BLEND );
	
					for ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {
	
						var sprite = flare.lensFlares[ j ];
	
						if ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {
	
							screenPosition.x = sprite.x;
							screenPosition.y = sprite.y;
							screenPosition.z = sprite.z;
	
							size = sprite.size * sprite.scale / viewport.w;
	
							scale.x = size * invAspect;
							scale.y = size;
	
							gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );
							gl.uniform2f( uniforms.scale, scale.x, scale.y );
							gl.uniform1f( uniforms.rotation, sprite.rotation );
	
							gl.uniform1f( uniforms.opacity, sprite.opacity );
							gl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );
	
							state.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );
							renderer.setTexture( sprite.texture, 1 );
	
							gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );
	
						}
	
					}
	
				}
	
			}
	
			// restore gl
	
			state.enable( gl.CULL_FACE );
			state.enable( gl.DEPTH_TEST );
			state.setDepthWrite( true );
	
			renderer.resetGLState();
	
		};
	
		function createProgram ( shader ) {
	
			var program = gl.createProgram();
	
			var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );
			var vertexShader = gl.createShader( gl.VERTEX_SHADER );
	
			var prefix = "precision " + renderer.getPrecision() + " float;\n";
	
			gl.shaderSource( fragmentShader, prefix + shader.fragmentShader );
			gl.shaderSource( vertexShader, prefix + shader.vertexShader );
	
			gl.compileShader( fragmentShader );
			gl.compileShader( vertexShader );
	
			gl.attachShader( program, fragmentShader );
			gl.attachShader( program, vertexShader );
	
			gl.linkProgram( program );
	
			return program;
	
		}
	
	};
	
	// File:src/renderers/webgl/plugins/SpritePlugin.js
	
	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.SpritePlugin = function ( renderer, sprites ) {
	
		var gl = renderer.context;
		var state = renderer.state;
	
		var vertexBuffer, elementBuffer;
		var program, attributes, uniforms;
	
		var texture;
	
		// decompose matrixWorld
	
		var spritePosition = new THREE.Vector3();
		var spriteRotation = new THREE.Quaternion();
		var spriteScale = new THREE.Vector3();
	
		function init() {
	
			var vertices = new Float32Array( [
				- 0.5, - 0.5,  0, 0,
				  0.5, - 0.5,  1, 0,
				  0.5,   0.5,  1, 1,
				- 0.5,   0.5,  0, 1
			] );
	
			var faces = new Uint16Array( [
				0, 1, 2,
				0, 2, 3
			] );
	
			vertexBuffer  = gl.createBuffer();
			elementBuffer = gl.createBuffer();
	
			gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
			gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );
	
			gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
			gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );
	
			program = createProgram();
	
			attributes = {
				position:			gl.getAttribLocation ( program, 'position' ),
				uv:					gl.getAttribLocation ( program, 'uv' )
			};
	
			uniforms = {
				uvOffset:			gl.getUniformLocation( program, 'uvOffset' ),
				uvScale:			gl.getUniformLocation( program, 'uvScale' ),
	
				rotation:			gl.getUniformLocation( program, 'rotation' ),
				scale:				gl.getUniformLocation( program, 'scale' ),
	
				color:				gl.getUniformLocation( program, 'color' ),
				map:				gl.getUniformLocation( program, 'map' ),
				opacity:			gl.getUniformLocation( program, 'opacity' ),
	
				modelViewMatrix: 	gl.getUniformLocation( program, 'modelViewMatrix' ),
				projectionMatrix:	gl.getUniformLocation( program, 'projectionMatrix' ),
	
				fogType:			gl.getUniformLocation( program, 'fogType' ),
				fogDensity:			gl.getUniformLocation( program, 'fogDensity' ),
				fogNear:			gl.getUniformLocation( program, 'fogNear' ),
				fogFar:				gl.getUniformLocation( program, 'fogFar' ),
				fogColor:			gl.getUniformLocation( program, 'fogColor' ),
	
				alphaTest:			gl.getUniformLocation( program, 'alphaTest' )
			};
	
			var canvas = document.createElement( 'canvas' );
			canvas.width = 8;
			canvas.height = 8;
	
			var context = canvas.getContext( '2d' );
			context.fillStyle = 'white';
			context.fillRect( 0, 0, 8, 8 );
	
			texture = new THREE.Texture( canvas );
			texture.needsUpdate = true;
	
		}
	
		this.render = function ( scene, camera ) {
	
			if ( sprites.length === 0 ) return;
	
			// setup gl
	
			if ( program === undefined ) {
	
				init();
	
			}
	
			gl.useProgram( program );
	
			state.initAttributes();
			state.enableAttribute( attributes.position );
			state.enableAttribute( attributes.uv );
			state.disableUnusedAttributes();
	
			state.disable( gl.CULL_FACE );
			state.enable( gl.BLEND );
	
			gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
			gl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );
			gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );
	
			gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
	
			gl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );
	
			state.activeTexture( gl.TEXTURE0 );
			gl.uniform1i( uniforms.map, 0 );
	
			var oldFogType = 0;
			var sceneFogType = 0;
			var fog = scene.fog;
	
			if ( fog ) {
	
				gl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );
	
				if ( fog instanceof THREE.Fog ) {
	
					gl.uniform1f( uniforms.fogNear, fog.near );
					gl.uniform1f( uniforms.fogFar, fog.far );
	
					gl.uniform1i( uniforms.fogType, 1 );
					oldFogType = 1;
					sceneFogType = 1;
	
				} else if ( fog instanceof THREE.FogExp2 ) {
	
					gl.uniform1f( uniforms.fogDensity, fog.density );
	
					gl.uniform1i( uniforms.fogType, 2 );
					oldFogType = 2;
					sceneFogType = 2;
	
				}
	
			} else {
	
				gl.uniform1i( uniforms.fogType, 0 );
				oldFogType = 0;
				sceneFogType = 0;
	
			}
	
	
			// update positions and sort
	
			for ( var i = 0, l = sprites.length; i < l; i ++ ) {
	
				var sprite = sprites[ i ];
	
				sprite.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );
				sprite.z = - sprite.modelViewMatrix.elements[ 14 ];
	
			}
	
			sprites.sort( painterSortStable );
	
			// render all sprites
	
			var scale = [];
	
			for ( var i = 0, l = sprites.length; i < l; i ++ ) {
	
				var sprite = sprites[ i ];
				var material = sprite.material;
	
				gl.uniform1f( uniforms.alphaTest, material.alphaTest );
				gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements );
	
				sprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );
	
				scale[ 0 ] = spriteScale.x;
				scale[ 1 ] = spriteScale.y;
	
				var fogType = 0;
	
				if ( scene.fog && material.fog ) {
	
					fogType = sceneFogType;
	
				}
	
				if ( oldFogType !== fogType ) {
	
					gl.uniform1i( uniforms.fogType, fogType );
					oldFogType = fogType;
	
				}
	
				if ( material.map !== null ) {
	
					gl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );
					gl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );
	
				} else {
	
					gl.uniform2f( uniforms.uvOffset, 0, 0 );
					gl.uniform2f( uniforms.uvScale, 1, 1 );
	
				}
	
				gl.uniform1f( uniforms.opacity, material.opacity );
				gl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );
	
				gl.uniform1f( uniforms.rotation, material.rotation );
				gl.uniform2fv( uniforms.scale, scale );
	
				state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );
				state.setDepthTest( material.depthTest );
				state.setDepthWrite( material.depthWrite );
	
				if ( material.map && material.map.image && material.map.image.width ) {
	
					renderer.setTexture( material.map, 0 );
	
				} else {
	
					renderer.setTexture( texture, 0 );
	
				}
	
				gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );
	
			}
	
			// restore gl
	
			state.enable( gl.CULL_FACE );
	
			renderer.resetGLState();
	
		};
	
		function createProgram () {
	
			var program = gl.createProgram();
	
			var vertexShader = gl.createShader( gl.VERTEX_SHADER );
			var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );
	
			gl.shaderSource( vertexShader, [
	
				'precision ' + renderer.getPrecision() + ' float;',
	
				'uniform mat4 modelViewMatrix;',
				'uniform mat4 projectionMatrix;',
				'uniform float rotation;',
				'uniform vec2 scale;',
				'uniform vec2 uvOffset;',
				'uniform vec2 uvScale;',
	
				'attribute vec2 position;',
				'attribute vec2 uv;',
	
				'varying vec2 vUV;',
	
				'void main() {',
	
					'vUV = uvOffset + uv * uvScale;',
	
					'vec2 alignedPosition = position * scale;',
	
					'vec2 rotatedPosition;',
					'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',
					'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',
	
					'vec4 finalPosition;',
	
					'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',
					'finalPosition.xy += rotatedPosition;',
					'finalPosition = projectionMatrix * finalPosition;',
	
					'gl_Position = finalPosition;',
	
				'}'
	
			].join( '\n' ) );
	
			gl.shaderSource( fragmentShader, [
	
				'precision ' + renderer.getPrecision() + ' float;',
	
				'uniform vec3 color;',
				'uniform sampler2D map;',
				'uniform float opacity;',
	
				'uniform int fogType;',
				'uniform vec3 fogColor;',
				'uniform float fogDensity;',
				'uniform float fogNear;',
				'uniform float fogFar;',
				'uniform float alphaTest;',
	
				'varying vec2 vUV;',
	
				'void main() {',
	
					'vec4 texture = texture2D( map, vUV );',
	
					'if ( texture.a < alphaTest ) discard;',
	
					'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',
	
					'if ( fogType > 0 ) {',
	
						'float depth = gl_FragCoord.z / gl_FragCoord.w;',
						'float fogFactor = 0.0;',
	
						'if ( fogType == 1 ) {',
	
							'fogFactor = smoothstep( fogNear, fogFar, depth );',
	
						'} else {',
	
							'const float LOG2 = 1.442695;',
							'fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',
							'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',
	
						'}',
	
						'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',
	
					'}',
	
				'}'
	
			].join( '\n' ) );
	
			gl.compileShader( vertexShader );
			gl.compileShader( fragmentShader );
	
			gl.attachShader( program, vertexShader );
			gl.attachShader( program, fragmentShader );
	
			gl.linkProgram( program );
	
			return program;
	
		}
	
		function painterSortStable ( a, b ) {
			
			if ( a.renderOrder !== b.renderOrder ) {
	
				return a.renderOrder - b.renderOrder;
	
			} else if ( a.z !== b.z ) {
	
				return b.z - a.z;
	
			} else {
	
				return b.id - a.id;
	
			}
	
		}
	
	};
	
	// File:src/Three.Legacy.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	Object.defineProperties( THREE.Box2.prototype, {
		empty: {
			value: function () {
				console.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );
				return this.isEmpty();
			}
		},
		isIntersectionBox: {
			value: function ( box ) {
				console.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );
				return this.intersectsBox( box );
			}
		}
	} );
	
	Object.defineProperties( THREE.Box3.prototype, {
		empty: {
			value: function () {
				console.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );
				return this.isEmpty();
			}
		},
		isIntersectionBox: {
			value: function ( box ) {
				console.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );
				return this.intersectsBox( box );
			}
		},
		isIntersectionSphere: {
			value: function ( sphere ) {
				console.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
				return this.intersectsSphere( sphere );
			}
		}
	} );
	
	Object.defineProperties( THREE.Matrix3.prototype, {
		multiplyVector3: {
			value: function ( vector ) {
				console.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
				return vector.applyMatrix3( this );
			}
		},
		multiplyVector3Array: {
			value: function ( a ) {
				console.warn( 'THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
				return this.applyToVector3Array( a );
			}
		}
	} );
	
	Object.defineProperties( THREE.Matrix4.prototype, {
		extractPosition: {
			value: function ( m ) {
				console.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );
				return this.copyPosition( m );
			}
		},
		setRotationFromQuaternion: {
			value: function ( q ) {
				console.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );
				return this.makeRotationFromQuaternion( q );
			}
		},
		multiplyVector3: {
			value: function ( vector ) {
				console.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );
				return vector.applyProjection( this );
			}
		},
		multiplyVector4: {
			value: function ( vector ) {
				console.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
				return vector.applyMatrix4( this );
			}
		},
		multiplyVector3Array: {
			value: function ( a ) {
				console.warn( 'THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
				return this.applyToVector3Array( a );
			}
		},
		rotateAxis: {
			value: function ( v ) {
				console.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );
				v.transformDirection( this );
			}
		},
		crossVector: {
			value: function ( vector ) {
				console.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
				return vector.applyMatrix4( this );
			}
		},
		translate: {
			value: function ( v ) {
				console.error( 'THREE.Matrix4: .translate() has been removed.' );
			}
		},
		rotateX: {
			value: function ( angle ) {
				console.error( 'THREE.Matrix4: .rotateX() has been removed.' );
			}
		},
		rotateY: {
			value: function ( angle ) {
				console.error( 'THREE.Matrix4: .rotateY() has been removed.' );
			}
		},
		rotateZ: {
			value: function ( angle ) {
				console.error( 'THREE.Matrix4: .rotateZ() has been removed.' );
			}
		},
		rotateByAxis: {
			value: function ( axis, angle ) {
				console.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );
			}
		}
	} );
	
	Object.defineProperties( THREE.Plane.prototype, {
		isIntersectionLine: {
			value: function ( line ) {
				console.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );
				return this.intersectsLine( line );
			}
		}
	} );
	
	Object.defineProperties( THREE.Quaternion.prototype, {
		multiplyVector3: {
			value: function ( vector ) {
				console.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
				return vector.applyQuaternion( this );
			}
		}
	} );
	
	Object.defineProperties( THREE.Ray.prototype, {
		isIntersectionBox: {
			value: function ( box ) {
				console.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );
				return this.intersectsBox( box );
			}
		},
		isIntersectionPlane: {
			value: function ( plane ) {
				console.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );
				return this.intersectsPlane( plane );
			}
		},
		isIntersectionSphere: {
			value: function ( sphere ) {
				console.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
				return this.intersectsSphere( sphere );
			}
		}
	} );
	
	Object.defineProperties( THREE.Vector3.prototype, {
		setEulerFromRotationMatrix: {
			value: function () {
				console.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );
			}
		},
		setEulerFromQuaternion: {
			value: function () {
				console.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );
			}
		},
		getPositionFromMatrix: {
			value: function ( m ) {
				console.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );
				return this.setFromMatrixPosition( m );
			}
		},
		getScaleFromMatrix: {
			value: function ( m ) {
				console.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );
				return this.setFromMatrixScale( m );
			}
		},
		getColumnFromMatrix: {
			value: function ( index, matrix ) {
				console.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );
				return this.setFromMatrixColumn( index, matrix );
			}
		}
	} );
	
	//
	
	THREE.Face4 = function ( a, b, c, d, normal, color, materialIndex ) {
	
		console.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );
		return new THREE.Face3( a, b, c, normal, color, materialIndex );
	
	};
	
	//
	
	Object.defineProperties( THREE.Object3D.prototype, {
		eulerOrder: {
			get: function () {
				console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
				return this.rotation.order;
			},
			set: function ( value ) {
				console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
				this.rotation.order = value;
			}
		},
		getChildByName: {
			value: function ( name ) {
				console.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );
				return this.getObjectByName( name );
			}
		},
		renderDepth: {
			set: function ( value ) {
				console.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );
			}
		},
		translate: {
			value: function ( distance, axis ) {
				console.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );
				return this.translateOnAxis( axis, distance );
			}
		},
		useQuaternion: {
			get: function () {
				console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );
			},
			set: function ( value ) {
				console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );
			}
		}
	} );
	
	//
	
	Object.defineProperties( THREE, {
		PointCloud: {
			value: function ( geometry, material ) {
				console.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );
				return new THREE.Points( geometry, material );
			}
		},
		ParticleSystem: {
			value: function ( geometry, material ) {
				console.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );
				return new THREE.Points( geometry, material );
			}
		}
	} );
	
	//
	
	Object.defineProperties( THREE.Light.prototype, {
		onlyShadow: {
			set: function ( value ) {
				console.warn( 'THREE.Light: .onlyShadow has been removed.' );
			}
		},
		shadowCameraFov: {
			set: function ( value ) {
				console.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );
				this.shadow.camera.fov = value;
			}
		},
		shadowCameraLeft: {
			set: function ( value ) {
				console.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );
				this.shadow.camera.left = value;
			}
		},
		shadowCameraRight: {
			set: function ( value ) {
				console.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );
				this.shadow.camera.right = value;
			}
		},
		shadowCameraTop: {
			set: function ( value ) {
				console.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );
				this.shadow.camera.top = value;
			}
		},
		shadowCameraBottom: {
			set: function ( value ) {
				console.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );
				this.shadow.camera.bottom = value;
			}
		},
		shadowCameraNear: {
			set: function ( value ) {
				console.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );
				this.shadow.camera.near = value;
			}
		},
		shadowCameraFar: {
			set: function ( value ) {
				console.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );
				this.shadow.camera.far = value;
			}
		},
		shadowCameraVisible: {
			set: function ( value ) {
				console.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );
			}
		},
		shadowBias: {
			set: function ( value ) {
				console.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );
				this.shadow.bias = value;
			}
		},
		shadowDarkness: {
			set: function ( value ) {
				console.warn( 'THREE.Light: .shadowDarkness has been removed.' );
			}
		},
		shadowMapWidth: {
			set: function ( value ) {
				console.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );
				this.shadow.mapSize.width = value;
			}
		},
		shadowMapHeight: {
			set: function ( value ) {
				console.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );
				this.shadow.mapSize.height = value;
			}
		}
	} );
	
	//
	
	Object.defineProperties( THREE.BufferAttribute.prototype, {
		length: {
			get: function () {
				console.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );
				return this.array.length;
			}
		}
	} );
	
	Object.defineProperties( THREE.BufferGeometry.prototype, {
		drawcalls: {
			get: function () {
				console.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );
				return this.groups;
			}
		},
		offsets: {
			get: function () {
				console.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );
				return this.groups;
			}
		},
		addIndex: {
			value: function ( index ) {
				console.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );
				this.setIndex( index );
			}
		},
		addDrawCall: {
			value: function ( start, count, indexOffset ) {
				if ( indexOffset !== undefined ) {
					console.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );
				}
				console.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );
				this.addGroup( start, count );
			}
		},
		clearDrawCalls: {
			value: function () {
				console.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );
				this.clearGroups();
			}
		},
		computeTangents: {
			value: function () {
				console.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );
			}
		},
		computeOffsets: {
			value: function () {
				console.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );
			}
		}
	} );
	
	//
	
	Object.defineProperties( THREE.Material.prototype, {
		wrapAround: {
			get: function () {
				console.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );
			},
			set: function ( value ) {
				console.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );
			}
		},
		wrapRGB: {
			get: function () {
				console.warn( 'THREE.' + this.type + ': .wrapRGB has been removed.' );
				return new THREE.Color();
			}
		}
	} );
	
	Object.defineProperties( THREE, {
		PointCloudMaterial: {
			value: function ( parameters ) {
				console.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );
				return new THREE.PointsMaterial( parameters );
			}
		},
		ParticleBasicMaterial: {
			value: function ( parameters ) {
				console.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );
				return new THREE.PointsMaterial( parameters );
			}
		},
		ParticleSystemMaterial:{
			value: function ( parameters ) {
				console.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );
				return new THREE.PointsMaterial( parameters );
			}
		}
	} );
	
	Object.defineProperties( THREE.MeshPhongMaterial.prototype, {
		metal: {
			get: function () {
				console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.' );
				return false;
			},
			set: function ( value ) {
				console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead' );
			}
		}
	} );
	
	Object.defineProperties( THREE.ShaderMaterial.prototype, {
		derivatives: {
			get: function () {
				console.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
				return this.extensions.derivatives;
			},
			set: function ( value ) {
				console.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
				this.extensions.derivatives = value;
			}
		}
	} );
	
	//
	
	Object.defineProperties( THREE.WebGLRenderer.prototype, {
		supportsFloatTextures: {
			value: function () {
				console.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).' );
				return this.extensions.get( 'OES_texture_float' );
			}
		},
		supportsHalfFloatTextures: {
			value: function () {
				console.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).' );
				return this.extensions.get( 'OES_texture_half_float' );
			}
		},
		supportsStandardDerivatives: {
			value: function () {
				console.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).' );
				return this.extensions.get( 'OES_standard_derivatives' );
			}
		},
		supportsCompressedTextureS3TC: {
			value: function () {
				console.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).' );
				return this.extensions.get( 'WEBGL_compressed_texture_s3tc' );
			}
		},
		supportsCompressedTexturePVRTC: {
			value: function () {
				console.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).' );
				return this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );
			}
		},
		supportsBlendMinMax: {
			value: function () {
				console.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).' );
				return this.extensions.get( 'EXT_blend_minmax' );
			}
		},
		supportsVertexTextures: {
			value: function () {
				return this.capabilities.vertexTextures;
			}
		},
		supportsInstancedArrays: {
			value: function () {
				console.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).' );
				return this.extensions.get( 'ANGLE_instanced_arrays' );
			}
		},
		enableScissorTest: {
			value: function ( boolean ) {
				console.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );
				this.setScissorTest( boolean );
			}
		},
		initMaterial: {
			value: function () {
				console.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );
			}
		},
		addPrePlugin: {
			value: function () {
				console.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );
			}
		},
		addPostPlugin: {
			value: function () {
				console.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );
			}
		},
		updateShadowMap: {
			value: function () {
				console.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );
			}
		},
		shadowMapEnabled: {
			get: function () {
				return this.shadowMap.enabled;
			},
			set: function ( value ) {
				console.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );
				this.shadowMap.enabled = value;
			}
		},
		shadowMapType: {
			get: function () {
				return this.shadowMap.type;
			},
			set: function ( value ) {
				console.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );
				this.shadowMap.type = value;
			}
		},
		shadowMapCullFace: {
			get: function () {
				return this.shadowMap.cullFace;
			},
			set: function ( value ) {
				console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.' );
				this.shadowMap.cullFace = value;
			}
		}
	} );
	
	//
	
	Object.defineProperties( THREE.WebGLRenderTarget.prototype, {
		wrapS: {
			get: function () {
				console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
				return this.texture.wrapS;
			},
			set: function ( value ) {
				console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
				this.texture.wrapS = value;
			}
		},
		wrapT: {
			get: function () {
				console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
				return this.texture.wrapT;
			},
			set: function ( value ) {
				console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
				this.texture.wrapT = value;
			}
		},
		magFilter: {
			get: function () {
				console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
				return this.texture.magFilter;
			},
			set: function ( value ) {
				console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
				this.texture.magFilter = value;
			}
		},
		minFilter: {
			get: function () {
				console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
				return this.texture.minFilter;
			},
			set: function ( value ) {
				console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
				this.texture.minFilter = value;
			}
		},
		anisotropy: {
			get: function () {
				console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
				return this.texture.anisotropy;
			},
			set: function ( value ) {
				console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
				this.texture.anisotropy = value;
			}
		},
		offset: {
			get: function () {
				console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
				return this.texture.offset;
			},
			set: function ( value ) {
				console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
				this.texture.offset = value;
			}
		},
		repeat: {
			get: function () {
				console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
				return this.texture.repeat;
			},
			set: function ( value ) {
				console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
				this.texture.repeat = value;
			}
		},
		format: {
			get: function () {
				console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
				return this.texture.format;
			},
			set: function ( value ) {
				console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
				this.texture.format = value;
			}
		},
		type: {
			get: function () {
				console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
				return this.texture.type;
			},
			set: function ( value ) {
				console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
				this.texture.type = value;
			}
		},
		generateMipmaps: {
			get: function () {
				console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
				return this.texture.generateMipmaps;
			},
			set: function ( value ) {
				console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
				this.texture.generateMipmaps = value;
			}
		}
	} );
	
	//
	
	THREE.GeometryUtils = {
	
		merge: function ( geometry1, geometry2, materialIndexOffset ) {
	
			console.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );
	
			var matrix;
	
			if ( geometry2 instanceof THREE.Mesh ) {
	
				geometry2.matrixAutoUpdate && geometry2.updateMatrix();
	
				matrix = geometry2.matrix;
				geometry2 = geometry2.geometry;
	
			}
	
			geometry1.merge( geometry2, matrix, materialIndexOffset );
	
		},
	
		center: function ( geometry ) {
	
			console.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );
			return geometry.center();
	
		}
	
	};
	
	THREE.ImageUtils = {
	
		crossOrigin: undefined,
	
		loadTexture: function ( url, mapping, onLoad, onError ) {
	
			console.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );
	
			var loader = new THREE.TextureLoader();
			loader.setCrossOrigin( this.crossOrigin );
	
			var texture = loader.load( url, onLoad, undefined, onError );
	
			if ( mapping ) texture.mapping = mapping;
	
			return texture;
	
		},
	
		loadTextureCube: function ( urls, mapping, onLoad, onError ) {
	
			console.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );
	
			var loader = new THREE.CubeTextureLoader();
			loader.setCrossOrigin( this.crossOrigin );
	
			var texture = loader.load( urls, onLoad, undefined, onError );
	
			if ( mapping ) texture.mapping = mapping;
	
			return texture;
	
		},
	
		loadCompressedTexture: function () {
	
			console.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );
	
		},
	
		loadCompressedTextureCube: function () {
	
			console.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );
	
		}
	
	};
	
	//
	
	THREE.Projector = function () {
	
		console.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );
	
		this.projectVector = function ( vector, camera ) {
	
			console.warn( 'THREE.Projector: .projectVector() is now vector.project().' );
			vector.project( camera );
	
		};
	
		this.unprojectVector = function ( vector, camera ) {
	
			console.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );
			vector.unproject( camera );
	
		};
	
		this.pickingRay = function ( vector, camera ) {
	
			console.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );
	
		};
	
	};
	
	//
	
	THREE.CanvasRenderer = function () {
	
		console.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );
	
		this.domElement = document.createElement( 'canvas' );
		this.clear = function () {};
		this.render = function () {};
		this.setClearColor = function () {};
		this.setSize = function () {};
	
	};
	
	//
	
	THREE.MeshFaceMaterial = THREE.MultiMaterial;
	
	// File:src/extras/CurveUtils.js
	
	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 */
	
	THREE.CurveUtils = {
	
		tangentQuadraticBezier: function ( t, p0, p1, p2 ) {
	
			return 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );
	
		},
	
		// Puay Bing, thanks for helping with this derivative!
	
		tangentCubicBezier: function ( t, p0, p1, p2, p3 ) {
	
			return - 3 * p0 * ( 1 - t ) * ( 1 - t )  +
				3 * p1 * ( 1 - t ) * ( 1 - t ) - 6 * t * p1 * ( 1 - t ) +
				6 * t *  p2 * ( 1 - t ) - 3 * t * t * p2 +
				3 * t * t * p3;
	
		},
	
		tangentSpline: function ( t, p0, p1, p2, p3 ) {
	
			// To check if my formulas are correct
	
			var h00 = 6 * t * t - 6 * t; 	// derived from 2t^3 − 3t^2 + 1
			var h10 = 3 * t * t - 4 * t + 1; // t^3 − 2t^2 + t
			var h01 = - 6 * t * t + 6 * t; 	// − 2t3 + 3t2
			var h11 = 3 * t * t - 2 * t;	// t3 − t2
	
			return h00 + h10 + h01 + h11;
	
		},
	
		// Catmull-Rom
	
		interpolate: function( p0, p1, p2, p3, t ) {
	
			var v0 = ( p2 - p0 ) * 0.5;
			var v1 = ( p3 - p1 ) * 0.5;
			var t2 = t * t;
			var t3 = t * t2;
			return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;
	
		}
	
	};
	
	// File:src/extras/SceneUtils.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.SceneUtils = {
	
		createMultiMaterialObject: function ( geometry, materials ) {
	
			var group = new THREE.Group();
	
			for ( var i = 0, l = materials.length; i < l; i ++ ) {
	
				group.add( new THREE.Mesh( geometry, materials[ i ] ) );
	
			}
	
			return group;
	
		},
	
		detach: function ( child, parent, scene ) {
	
			child.applyMatrix( parent.matrixWorld );
			parent.remove( child );
			scene.add( child );
	
		},
	
		attach: function ( child, scene, parent ) {
	
			var matrixWorldInverse = new THREE.Matrix4();
			matrixWorldInverse.getInverse( parent.matrixWorld );
			child.applyMatrix( matrixWorldInverse );
	
			scene.remove( child );
			parent.add( child );
	
		}
	
	};
	
	// File:src/extras/ShapeUtils.js
	
	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 */
	
	THREE.ShapeUtils = {
	
		// calculate area of the contour polygon
	
		area: function ( contour ) {
	
			var n = contour.length;
			var a = 0.0;
	
			for ( var p = n - 1, q = 0; q < n; p = q ++ ) {
	
				a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;
	
			}
	
			return a * 0.5;
	
		},
	
		triangulate: ( function () {
	
			/**
			 * This code is a quick port of code written in C++ which was submitted to
			 * flipcode.com by John W. Ratcliff  // July 22, 2000
			 * See original code and more information here:
			 * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
			 *
			 * ported to actionscript by Zevan Rosser
			 * www.actionsnippet.com
			 *
			 * ported to javascript by Joshua Koo
			 * http://www.lab4games.net/zz85/blog
			 *
			 */
	
			function snip( contour, u, v, w, n, verts ) {
	
				var p;
				var ax, ay, bx, by;
				var cx, cy, px, py;
	
				ax = contour[ verts[ u ] ].x;
				ay = contour[ verts[ u ] ].y;
	
				bx = contour[ verts[ v ] ].x;
				by = contour[ verts[ v ] ].y;
	
				cx = contour[ verts[ w ] ].x;
				cy = contour[ verts[ w ] ].y;
	
				if ( Number.EPSILON > ( ( ( bx - ax ) * ( cy - ay ) ) - ( ( by - ay ) * ( cx - ax ) ) ) ) return false;
	
				var aX, aY, bX, bY, cX, cY;
				var apx, apy, bpx, bpy, cpx, cpy;
				var cCROSSap, bCROSScp, aCROSSbp;
	
				aX = cx - bx;  aY = cy - by;
				bX = ax - cx;  bY = ay - cy;
				cX = bx - ax;  cY = by - ay;
	
				for ( p = 0; p < n; p ++ ) {
	
					px = contour[ verts[ p ] ].x;
					py = contour[ verts[ p ] ].y;
	
					if ( ( ( px === ax ) && ( py === ay ) ) ||
						 ( ( px === bx ) && ( py === by ) ) ||
						 ( ( px === cx ) && ( py === cy ) ) )	continue;
	
					apx = px - ax;  apy = py - ay;
					bpx = px - bx;  bpy = py - by;
					cpx = px - cx;  cpy = py - cy;
	
					// see if p is inside triangle abc
	
					aCROSSbp = aX * bpy - aY * bpx;
					cCROSSap = cX * apy - cY * apx;
					bCROSScp = bX * cpy - bY * cpx;
	
					if ( ( aCROSSbp >= - Number.EPSILON ) && ( bCROSScp >= - Number.EPSILON ) && ( cCROSSap >= - Number.EPSILON ) ) return false;
	
				}
	
				return true;
	
			}
	
			// takes in an contour array and returns
	
			return function ( contour, indices ) {
	
				var n = contour.length;
	
				if ( n < 3 ) return null;
	
				var result = [],
					verts = [],
					vertIndices = [];
	
				/* we want a counter-clockwise polygon in verts */
	
				var u, v, w;
	
				if ( THREE.ShapeUtils.area( contour ) > 0.0 ) {
	
					for ( v = 0; v < n; v ++ ) verts[ v ] = v;
	
				} else {
	
					for ( v = 0; v < n; v ++ ) verts[ v ] = ( n - 1 ) - v;
	
				}
	
				var nv = n;
	
				/*  remove nv - 2 vertices, creating 1 triangle every time */
	
				var count = 2 * nv;   /* error detection */
	
				for ( v = nv - 1; nv > 2; ) {
	
					/* if we loop, it is probably a non-simple polygon */
	
					if ( ( count -- ) <= 0 ) {
	
						//** Triangulate: ERROR - probable bad polygon!
	
						//throw ( "Warning, unable to triangulate polygon!" );
						//return null;
						// Sometimes warning is fine, especially polygons are triangulated in reverse.
						console.warn( 'THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()' );
	
						if ( indices ) return vertIndices;
						return result;
	
					}
	
					/* three consecutive vertices in current polygon, <u,v,w> */
	
					u = v; 	 	if ( nv <= u ) u = 0;     /* previous */
					v = u + 1;  if ( nv <= v ) v = 0;     /* new v    */
					w = v + 1;  if ( nv <= w ) w = 0;     /* next     */
	
					if ( snip( contour, u, v, w, nv, verts ) ) {
	
						var a, b, c, s, t;
	
						/* true names of the vertices */
	
						a = verts[ u ];
						b = verts[ v ];
						c = verts[ w ];
	
						/* output Triangle */
	
						result.push( [ contour[ a ],
							contour[ b ],
							contour[ c ] ] );
	
	
						vertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );
	
						/* remove v from the remaining polygon */
	
						for ( s = v, t = v + 1; t < nv; s ++, t ++ ) {
	
							verts[ s ] = verts[ t ];
	
						}
	
						nv --;
	
						/* reset error detection counter */
	
						count = 2 * nv;
	
					}
	
				}
	
				if ( indices ) return vertIndices;
				return result;
	
			}
	
		} )(),
	
		triangulateShape: function ( contour, holes ) {
	
			function point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {
	
				// inOtherPt needs to be collinear to the inSegment
				if ( inSegPt1.x !== inSegPt2.x ) {
	
					if ( inSegPt1.x < inSegPt2.x ) {
	
						return	( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );
	
					} else {
	
						return	( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );
	
					}
	
				} else {
	
					if ( inSegPt1.y < inSegPt2.y ) {
	
						return	( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );
	
					} else {
	
						return	( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );
	
					}
	
				}
	
			}
	
			function intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {
	
				var seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,   seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;
				var seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,   seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;
	
				var seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;
				var seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;
	
				var limit		= seg1dy * seg2dx - seg1dx * seg2dy;
				var perpSeg1	= seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;
	
				if ( Math.abs( limit ) > Number.EPSILON ) {
	
					// not parallel
	
					var perpSeg2;
					if ( limit > 0 ) {
	
						if ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) ) 		return [];
						perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
						if ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) ) 		return [];
	
					} else {
	
						if ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) ) 		return [];
						perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
						if ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) ) 		return [];
	
					}
	
					// i.e. to reduce rounding errors
					// intersection at endpoint of segment#1?
					if ( perpSeg2 === 0 ) {
	
						if ( ( inExcludeAdjacentSegs ) &&
							 ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )		return [];
						return [ inSeg1Pt1 ];
	
					}
					if ( perpSeg2 === limit ) {
	
						if ( ( inExcludeAdjacentSegs ) &&
							 ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )		return [];
						return [ inSeg1Pt2 ];
	
					}
					// intersection at endpoint of segment#2?
					if ( perpSeg1 === 0 )		return [ inSeg2Pt1 ];
					if ( perpSeg1 === limit )	return [ inSeg2Pt2 ];
	
					// return real intersection point
					var factorSeg1 = perpSeg2 / limit;
					return	[ { x: inSeg1Pt1.x + factorSeg1 * seg1dx,
								y: inSeg1Pt1.y + factorSeg1 * seg1dy } ];
	
				} else {
	
					// parallel or collinear
					if ( ( perpSeg1 !== 0 ) ||
						 ( seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy ) ) 			return [];
	
					// they are collinear or degenerate
					var seg1Pt = ( ( seg1dx === 0 ) && ( seg1dy === 0 ) );	// segment1 is just a point?
					var seg2Pt = ( ( seg2dx === 0 ) && ( seg2dy === 0 ) );	// segment2 is just a point?
					// both segments are points
					if ( seg1Pt && seg2Pt ) {
	
						if ( ( inSeg1Pt1.x !== inSeg2Pt1.x ) ||
							 ( inSeg1Pt1.y !== inSeg2Pt1.y ) )		return [];	// they are distinct  points
						return [ inSeg1Pt1 ];                 						// they are the same point
	
					}
					// segment#1  is a single point
					if ( seg1Pt ) {
	
						if ( ! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )		return [];		// but not in segment#2
						return [ inSeg1Pt1 ];
	
					}
					// segment#2  is a single point
					if ( seg2Pt ) {
	
						if ( ! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )		return [];		// but not in segment#1
						return [ inSeg2Pt1 ];
	
					}
	
					// they are collinear segments, which might overlap
					var seg1min, seg1max, seg1minVal, seg1maxVal;
					var seg2min, seg2max, seg2minVal, seg2maxVal;
					if ( seg1dx !== 0 ) {
	
						// the segments are NOT on a vertical line
						if ( inSeg1Pt1.x < inSeg1Pt2.x ) {
	
							seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;
							seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;
	
						} else {
	
							seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;
							seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;
	
						}
						if ( inSeg2Pt1.x < inSeg2Pt2.x ) {
	
							seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;
							seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;
	
						} else {
	
							seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;
							seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;
	
						}
	
					} else {
	
						// the segments are on a vertical line
						if ( inSeg1Pt1.y < inSeg1Pt2.y ) {
	
							seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;
							seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;
	
						} else {
	
							seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;
							seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;
	
						}
						if ( inSeg2Pt1.y < inSeg2Pt2.y ) {
	
							seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;
							seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;
	
						} else {
	
							seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;
							seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;
	
						}
	
					}
					if ( seg1minVal <= seg2minVal ) {
	
						if ( seg1maxVal <  seg2minVal )	return [];
						if ( seg1maxVal === seg2minVal )	{
	
							if ( inExcludeAdjacentSegs )		return [];
							return [ seg2min ];
	
						}
						if ( seg1maxVal <= seg2maxVal )	return [ seg2min, seg1max ];
						return	[ seg2min, seg2max ];
	
					} else {
	
						if ( seg1minVal >  seg2maxVal )	return [];
						if ( seg1minVal === seg2maxVal )	{
	
							if ( inExcludeAdjacentSegs )		return [];
							return [ seg1min ];
	
						}
						if ( seg1maxVal <= seg2maxVal )	return [ seg1min, seg1max ];
						return	[ seg1min, seg2max ];
	
					}
	
				}
	
			}
	
			function isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {
	
				// The order of legs is important
	
				// translation of all points, so that Vertex is at (0,0)
				var legFromPtX	= inLegFromPt.x - inVertex.x,  legFromPtY	= inLegFromPt.y - inVertex.y;
				var legToPtX	= inLegToPt.x	- inVertex.x,  legToPtY		= inLegToPt.y	- inVertex.y;
				var otherPtX	= inOtherPt.x	- inVertex.x,  otherPtY		= inOtherPt.y	- inVertex.y;
	
				// main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.
				var from2toAngle	= legFromPtX * legToPtY - legFromPtY * legToPtX;
				var from2otherAngle	= legFromPtX * otherPtY - legFromPtY * otherPtX;
	
				if ( Math.abs( from2toAngle ) > Number.EPSILON ) {
	
					// angle != 180 deg.
	
					var other2toAngle		= otherPtX * legToPtY - otherPtY * legToPtX;
					// console.log( "from2to: " + from2toAngle + ", from2other: " + from2otherAngle + ", other2to: " + other2toAngle );
	
					if ( from2toAngle > 0 ) {
	
						// main angle < 180 deg.
						return	( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );
	
					} else {
	
						// main angle > 180 deg.
						return	( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );
	
					}
	
				} else {
	
					// angle == 180 deg.
					// console.log( "from2to: 180 deg., from2other: " + from2otherAngle  );
					return	( from2otherAngle > 0 );
	
				}
	
			}
	
	
			function removeHoles( contour, holes ) {
	
				var shape = contour.concat(); // work on this shape
				var hole;
	
				function isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {
	
					// Check if hole point lies within angle around shape point
					var lastShapeIdx = shape.length - 1;
	
					var prevShapeIdx = inShapeIdx - 1;
					if ( prevShapeIdx < 0 )			prevShapeIdx = lastShapeIdx;
	
					var nextShapeIdx = inShapeIdx + 1;
					if ( nextShapeIdx > lastShapeIdx )	nextShapeIdx = 0;
	
					var insideAngle = isPointInsideAngle( shape[ inShapeIdx ], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[ inHoleIdx ] );
					if ( ! insideAngle ) {
	
						// console.log( "Vertex (Shape): " + inShapeIdx + ", Point: " + hole[inHoleIdx].x + "/" + hole[inHoleIdx].y );
						return	false;
	
					}
	
					// Check if shape point lies within angle around hole point
					var lastHoleIdx = hole.length - 1;
	
					var prevHoleIdx = inHoleIdx - 1;
					if ( prevHoleIdx < 0 )			prevHoleIdx = lastHoleIdx;
	
					var nextHoleIdx = inHoleIdx + 1;
					if ( nextHoleIdx > lastHoleIdx )	nextHoleIdx = 0;
	
					insideAngle = isPointInsideAngle( hole[ inHoleIdx ], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[ inShapeIdx ] );
					if ( ! insideAngle ) {
	
						// console.log( "Vertex (Hole): " + inHoleIdx + ", Point: " + shape[inShapeIdx].x + "/" + shape[inShapeIdx].y );
						return	false;
	
					}
	
					return	true;
	
				}
	
				function intersectsShapeEdge( inShapePt, inHolePt ) {
	
					// checks for intersections with shape edges
					var sIdx, nextIdx, intersection;
					for ( sIdx = 0; sIdx < shape.length; sIdx ++ ) {
	
						nextIdx = sIdx + 1; nextIdx %= shape.length;
						intersection = intersect_segments_2D( inShapePt, inHolePt, shape[ sIdx ], shape[ nextIdx ], true );
						if ( intersection.length > 0 )		return	true;
	
					}
	
					return	false;
	
				}
	
				var indepHoles = [];
	
				function intersectsHoleEdge( inShapePt, inHolePt ) {
	
					// checks for intersections with hole edges
					var ihIdx, chkHole,
						hIdx, nextIdx, intersection;
					for ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx ++ ) {
	
						chkHole = holes[ indepHoles[ ihIdx ]];
						for ( hIdx = 0; hIdx < chkHole.length; hIdx ++ ) {
	
							nextIdx = hIdx + 1; nextIdx %= chkHole.length;
							intersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[ hIdx ], chkHole[ nextIdx ], true );
							if ( intersection.length > 0 )		return	true;
	
						}
	
					}
					return	false;
	
				}
	
				var holeIndex, shapeIndex,
					shapePt, holePt,
					holeIdx, cutKey, failedCuts = [],
					tmpShape1, tmpShape2,
					tmpHole1, tmpHole2;
	
				for ( var h = 0, hl = holes.length; h < hl; h ++ ) {
	
					indepHoles.push( h );
	
				}
	
				var minShapeIndex = 0;
				var counter = indepHoles.length * 2;
				while ( indepHoles.length > 0 ) {
	
					counter --;
					if ( counter < 0 ) {
	
						console.log( "Infinite Loop! Holes left:" + indepHoles.length + ", Probably Hole outside Shape!" );
						break;
	
					}
	
					// search for shape-vertex and hole-vertex,
					// which can be connected without intersections
					for ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex ++ ) {
	
						shapePt = shape[ shapeIndex ];
						holeIndex	= - 1;
	
						// search for hole which can be reached without intersections
						for ( var h = 0; h < indepHoles.length; h ++ ) {
	
							holeIdx = indepHoles[ h ];
	
							// prevent multiple checks
							cutKey = shapePt.x + ":" + shapePt.y + ":" + holeIdx;
							if ( failedCuts[ cutKey ] !== undefined )			continue;
	
							hole = holes[ holeIdx ];
							for ( var h2 = 0; h2 < hole.length; h2 ++ ) {
	
								holePt = hole[ h2 ];
								if ( ! isCutLineInsideAngles( shapeIndex, h2 ) )		continue;
								if ( intersectsShapeEdge( shapePt, holePt ) )		continue;
								if ( intersectsHoleEdge( shapePt, holePt ) )		continue;
	
								holeIndex = h2;
								indepHoles.splice( h, 1 );
	
								tmpShape1 = shape.slice( 0, shapeIndex + 1 );
								tmpShape2 = shape.slice( shapeIndex );
								tmpHole1 = hole.slice( holeIndex );
								tmpHole2 = hole.slice( 0, holeIndex + 1 );
	
								shape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );
	
								minShapeIndex = shapeIndex;
	
								// Debug only, to show the selected cuts
								// glob_CutLines.push( [ shapePt, holePt ] );
	
								break;
	
							}
							if ( holeIndex >= 0 )	break;		// hole-vertex found
	
							failedCuts[ cutKey ] = true;			// remember failure
	
						}
						if ( holeIndex >= 0 )	break;		// hole-vertex found
	
					}
	
				}
	
				return shape; 			/* shape with no holes */
	
			}
	
	
			var i, il, f, face,
				key, index,
				allPointsMap = {};
	
			// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.
	
			var allpoints = contour.concat();
	
			for ( var h = 0, hl = holes.length; h < hl; h ++ ) {
	
				Array.prototype.push.apply( allpoints, holes[ h ] );
	
			}
	
			//console.log( "allpoints",allpoints, allpoints.length );
	
			// prepare all points map
	
			for ( i = 0, il = allpoints.length; i < il; i ++ ) {
	
				key = allpoints[ i ].x + ":" + allpoints[ i ].y;
	
				if ( allPointsMap[ key ] !== undefined ) {
	
					console.warn( "THREE.Shape: Duplicate point", key );
	
				}
	
				allPointsMap[ key ] = i;
	
			}
	
			// remove holes by cutting paths to holes and adding them to the shape
			var shapeWithoutHoles = removeHoles( contour, holes );
	
			var triangles = THREE.ShapeUtils.triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape
			//console.log( "triangles",triangles, triangles.length );
	
			// check all face vertices against all points map
	
			for ( i = 0, il = triangles.length; i < il; i ++ ) {
	
				face = triangles[ i ];
	
				for ( f = 0; f < 3; f ++ ) {
	
					key = face[ f ].x + ":" + face[ f ].y;
	
					index = allPointsMap[ key ];
	
					if ( index !== undefined ) {
	
						face[ f ] = index;
	
					}
	
				}
	
			}
	
			return triangles.concat();
	
		},
	
		isClockWise: function ( pts ) {
	
			return THREE.ShapeUtils.area( pts ) < 0;
	
		},
	
		// Bezier Curves formulas obtained from
		// http://en.wikipedia.org/wiki/B%C3%A9zier_curve
	
		// Quad Bezier Functions
	
		b2: ( function () {
	
			function b2p0( t, p ) {
	
				var k = 1 - t;
				return k * k * p;
	
			}
	
			function b2p1( t, p ) {
	
				return 2 * ( 1 - t ) * t * p;
	
			}
	
			function b2p2( t, p ) {
	
				return t * t * p;
	
			}
	
			return function ( t, p0, p1, p2 ) {
	
				return b2p0( t, p0 ) + b2p1( t, p1 ) + b2p2( t, p2 );
	
			};
	
		} )(),
	
		// Cubic Bezier Functions
	
		b3: ( function () {
	
			function b3p0( t, p ) {
	
				var k = 1 - t;
				return k * k * k * p;
	
			}
	
			function b3p1( t, p ) {
	
				var k = 1 - t;
				return 3 * k * k * t * p;
	
			}
	
			function b3p2( t, p ) {
	
				var k = 1 - t;
				return 3 * k * t * t * p;
	
			}
	
			function b3p3( t, p ) {
	
				return t * t * t * p;
	
			}
	
			return function ( t, p0, p1, p2, p3 ) {
	
				return b3p0( t, p0 ) + b3p1( t, p1 ) + b3p2( t, p2 ) + b3p3( t, p3 );
	
			};
	
		} )()
	
	};
	
	// File:src/extras/core/Curve.js
	
	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Extensible curve object
	 *
	 * Some common of Curve methods
	 * .getPoint(t), getTangent(t)
	 * .getPointAt(u), getTagentAt(u)
	 * .getPoints(), .getSpacedPoints()
	 * .getLength()
	 * .updateArcLengths()
	 *
	 * This following classes subclasses THREE.Curve:
	 *
	 * -- 2d classes --
	 * THREE.LineCurve
	 * THREE.QuadraticBezierCurve
	 * THREE.CubicBezierCurve
	 * THREE.SplineCurve
	 * THREE.ArcCurve
	 * THREE.EllipseCurve
	 *
	 * -- 3d classes --
	 * THREE.LineCurve3
	 * THREE.QuadraticBezierCurve3
	 * THREE.CubicBezierCurve3
	 * THREE.SplineCurve3
	 * THREE.ClosedSplineCurve3
	 *
	 * A series of curves can be represented as a THREE.CurvePath
	 *
	 **/
	
	/**************************************************************
	 *	Abstract Curve base class
	 **************************************************************/
	
	THREE.Curve = function () {
	
	};
	
	THREE.Curve.prototype = {
	
		constructor: THREE.Curve,
	
		// Virtual base class method to overwrite and implement in subclasses
		//	- t [0 .. 1]
	
		getPoint: function ( t ) {
	
			console.warn( "THREE.Curve: Warning, getPoint() not implemented!" );
			return null;
	
		},
	
		// Get point at relative position in curve according to arc length
		// - u [0 .. 1]
	
		getPointAt: function ( u ) {
	
			var t = this.getUtoTmapping( u );
			return this.getPoint( t );
	
		},
	
		// Get sequence of points using getPoint( t )
	
		getPoints: function ( divisions ) {
	
			if ( ! divisions ) divisions = 5;
	
			var d, pts = [];
	
			for ( d = 0; d <= divisions; d ++ ) {
	
				pts.push( this.getPoint( d / divisions ) );
	
			}
	
			return pts;
	
		},
	
		// Get sequence of points using getPointAt( u )
	
		getSpacedPoints: function ( divisions ) {
	
			if ( ! divisions ) divisions = 5;
	
			var d, pts = [];
	
			for ( d = 0; d <= divisions; d ++ ) {
	
				pts.push( this.getPointAt( d / divisions ) );
	
			}
	
			return pts;
	
		},
	
		// Get total curve arc length
	
		getLength: function () {
	
			var lengths = this.getLengths();
			return lengths[ lengths.length - 1 ];
	
		},
	
		// Get list of cumulative segment lengths
	
		getLengths: function ( divisions ) {
	
			if ( ! divisions ) divisions = ( this.__arcLengthDivisions ) ? ( this.__arcLengthDivisions ) : 200;
	
			if ( this.cacheArcLengths
				&& ( this.cacheArcLengths.length === divisions + 1 )
				&& ! this.needsUpdate ) {
	
				//console.log( "cached", this.cacheArcLengths );
				return this.cacheArcLengths;
	
			}
	
			this.needsUpdate = false;
	
			var cache = [];
			var current, last = this.getPoint( 0 );
			var p, sum = 0;
	
			cache.push( 0 );
	
			for ( p = 1; p <= divisions; p ++ ) {
	
				current = this.getPoint ( p / divisions );
				sum += current.distanceTo( last );
				cache.push( sum );
				last = current;
	
			}
	
			this.cacheArcLengths = cache;
	
			return cache; // { sums: cache, sum:sum }; Sum is in the last element.
	
		},
	
		updateArcLengths: function() {
	
			this.needsUpdate = true;
			this.getLengths();
	
		},
	
		// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
	
		getUtoTmapping: function ( u, distance ) {
	
			var arcLengths = this.getLengths();
	
			var i = 0, il = arcLengths.length;
	
			var targetArcLength; // The targeted u distance value to get
	
			if ( distance ) {
	
				targetArcLength = distance;
	
			} else {
	
				targetArcLength = u * arcLengths[ il - 1 ];
	
			}
	
			//var time = Date.now();
	
			// binary search for the index with largest value smaller than target u distance
	
			var low = 0, high = il - 1, comparison;
	
			while ( low <= high ) {
	
				i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats
	
				comparison = arcLengths[ i ] - targetArcLength;
	
				if ( comparison < 0 ) {
	
					low = i + 1;
	
				} else if ( comparison > 0 ) {
	
					high = i - 1;
	
				} else {
	
					high = i;
					break;
	
					// DONE
	
				}
	
			}
	
			i = high;
	
			//console.log('b' , i, low, high, Date.now()- time);
	
			if ( arcLengths[ i ] === targetArcLength ) {
	
				var t = i / ( il - 1 );
				return t;
	
			}
	
			// we could get finer grain at lengths, or use simple interpolation between two points
	
			var lengthBefore = arcLengths[ i ];
			var lengthAfter = arcLengths[ i + 1 ];
	
			var segmentLength = lengthAfter - lengthBefore;
	
			// determine where we are between the 'before' and 'after' points
	
			var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;
	
			// add that fractional amount to t
	
			var t = ( i + segmentFraction ) / ( il - 1 );
	
			return t;
	
		},
	
		// Returns a unit vector tangent at t
		// In case any sub curve does not implement its tangent derivation,
		// 2 points a small delta apart will be used to find its gradient
		// which seems to give a reasonable approximation
	
		getTangent: function( t ) {
	
			var delta = 0.0001;
			var t1 = t - delta;
			var t2 = t + delta;
	
			// Capping in case of danger
	
			if ( t1 < 0 ) t1 = 0;
			if ( t2 > 1 ) t2 = 1;
	
			var pt1 = this.getPoint( t1 );
			var pt2 = this.getPoint( t2 );
	
			var vec = pt2.clone().sub( pt1 );
			return vec.normalize();
	
		},
	
		getTangentAt: function ( u ) {
	
			var t = this.getUtoTmapping( u );
			return this.getTangent( t );
	
		}
	
	};
	
	// TODO: Transformation for Curves?
	
	/**************************************************************
	 *	3D Curves
	 **************************************************************/
	
	// A Factory method for creating new curve subclasses
	
	THREE.Curve.create = function ( constructor, getPointFunc ) {
	
		constructor.prototype = Object.create( THREE.Curve.prototype );
		constructor.prototype.constructor = constructor;
		constructor.prototype.getPoint = getPointFunc;
	
		return constructor;
	
	};
	
	// File:src/extras/core/CurvePath.js
	
	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 *
	 **/
	
	/**************************************************************
	 *	Curved Path - a curve path is simply a array of connected
	 *  curves, but retains the api of a curve
	 **************************************************************/
	
	THREE.CurvePath = function () {
	
		this.curves = [];
	
		this.autoClose = false; // Automatically closes the path
	
	};
	
	THREE.CurvePath.prototype = Object.create( THREE.Curve.prototype );
	THREE.CurvePath.prototype.constructor = THREE.CurvePath;
	
	THREE.CurvePath.prototype.add = function ( curve ) {
	
		this.curves.push( curve );
	
	};
	
	/*
	THREE.CurvePath.prototype.checkConnection = function() {
		// TODO
		// If the ending of curve is not connected to the starting
		// or the next curve, then, this is not a real path
	};
	*/
	
	THREE.CurvePath.prototype.closePath = function() {
	
		// TODO Test
		// and verify for vector3 (needs to implement equals)
		// Add a line curve if start and end of lines are not connected
		var startPoint = this.curves[ 0 ].getPoint( 0 );
		var endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );
	
		if ( ! startPoint.equals( endPoint ) ) {
	
			this.curves.push( new THREE.LineCurve( endPoint, startPoint ) );
	
		}
	
	};
	
	// To get accurate point with reference to
	// entire path distance at time t,
	// following has to be done:
	
	// 1. Length of each sub path have to be known
	// 2. Locate and identify type of curve
	// 3. Get t for the curve
	// 4. Return curve.getPointAt(t')
	
	THREE.CurvePath.prototype.getPoint = function( t ) {
	
		var d = t * this.getLength();
		var curveLengths = this.getCurveLengths();
		var i = 0;
	
		// To think about boundaries points.
	
		while ( i < curveLengths.length ) {
	
			if ( curveLengths[ i ] >= d ) {
	
				var diff = curveLengths[ i ] - d;
				var curve = this.curves[ i ];
	
				var u = 1 - diff / curve.getLength();
	
				return curve.getPointAt( u );
	
			}
	
			i ++;
	
		}
	
		return null;
	
		// loop where sum != 0, sum > d , sum+1 <d
	
	};
	
	/*
	THREE.CurvePath.prototype.getTangent = function( t ) {
	};
	*/
	
	// We cannot use the default THREE.Curve getPoint() with getLength() because in
	// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
	// getPoint() depends on getLength
	
	THREE.CurvePath.prototype.getLength = function() {
	
		var lens = this.getCurveLengths();
		return lens[ lens.length - 1 ];
	
	};
	
	// Compute lengths and cache them
	// We cannot overwrite getLengths() because UtoT mapping uses it.
	
	THREE.CurvePath.prototype.getCurveLengths = function() {
	
		// We use cache values if curves and cache array are same length
	
		if ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {
	
			return this.cacheLengths;
	
		}
	
		// Get length of sub-curve
		// Push sums into cached array
	
		var lengths = [], sums = 0;
	
		for ( var i = 0, l = this.curves.length; i < l; i ++ ) {
	
			sums += this.curves[ i ].getLength();
			lengths.push( sums );
	
		}
	
		this.cacheLengths = lengths;
	
		return lengths;
	
	};
	
	
	
	/**************************************************************
	 *	Create Geometries Helpers
	 **************************************************************/
	
	/// Generate geometry from path points (for Line or Points objects)
	
	THREE.CurvePath.prototype.createPointsGeometry = function( divisions ) {
	
		var pts = this.getPoints( divisions );
		return this.createGeometry( pts );
	
	};
	
	// Generate geometry from equidistant sampling along the path
	
	THREE.CurvePath.prototype.createSpacedPointsGeometry = function( divisions ) {
	
		var pts = this.getSpacedPoints( divisions );
		return this.createGeometry( pts );
	
	};
	
	THREE.CurvePath.prototype.createGeometry = function( points ) {
	
		var geometry = new THREE.Geometry();
	
		for ( var i = 0, l = points.length; i < l; i ++ ) {
	
			var point = points[ i ];
			geometry.vertices.push( new THREE.Vector3( point.x, point.y, point.z || 0 ) );
	
		}
	
		return geometry;
	
	};
	
	// File:src/extras/core/Font.js
	
	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.Font = function ( data ) {
	
		this.data = data;
	
	};
	
	THREE.Font.prototype = {
	
		constructor: THREE.Font,
	
		generateShapes: function ( text, size, divisions ) {
	
			function createPaths( text ) {
	
				var chars = String( text ).split( '' );
				var scale = size / data.resolution;
				var offset = 0;
	
				var paths = [];
	
				for ( var i = 0; i < chars.length; i ++ ) {
	
					var ret = createPath( chars[ i ], scale, offset );
					offset += ret.offset;
	
					paths.push( ret.path );
	
				}
	
				return paths;
	
			}
	
			function createPath( c, scale, offset ) {
	
				var glyph = data.glyphs[ c ] || data.glyphs[ '?' ];
	
				if ( ! glyph ) return;
	
				var path = new THREE.Path();
	
				var pts = [], b2 = THREE.ShapeUtils.b2, b3 = THREE.ShapeUtils.b3;
				var x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2, laste;
	
				if ( glyph.o ) {
	
					var outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );
	
					for ( var i = 0, l = outline.length; i < l; ) {
	
						var action = outline[ i ++ ];
	
						switch ( action ) {
	
							case 'm': // moveTo
	
								x = outline[ i ++ ] * scale + offset;
								y = outline[ i ++ ] * scale;
	
								path.moveTo( x, y );
	
								break;
	
							case 'l': // lineTo
	
								x = outline[ i ++ ] * scale + offset;
								y = outline[ i ++ ] * scale;
	
								path.lineTo( x, y );
	
								break;
	
							case 'q': // quadraticCurveTo
	
								cpx  = outline[ i ++ ] * scale + offset;
								cpy  = outline[ i ++ ] * scale;
								cpx1 = outline[ i ++ ] * scale + offset;
								cpy1 = outline[ i ++ ] * scale;
	
								path.quadraticCurveTo( cpx1, cpy1, cpx, cpy );
	
								laste = pts[ pts.length - 1 ];
	
								if ( laste ) {
	
									cpx0 = laste.x;
									cpy0 = laste.y;
	
									for ( var i2 = 1; i2 <= divisions; i2 ++ ) {
	
										var t = i2 / divisions;
										b2( t, cpx0, cpx1, cpx );
										b2( t, cpy0, cpy1, cpy );
	
									}
	
								}
	
								break;
	
							case 'b': // bezierCurveTo
	
								cpx  = outline[ i ++ ] * scale + offset;
								cpy  = outline[ i ++ ] * scale;
								cpx1 = outline[ i ++ ] * scale + offset;
								cpy1 = outline[ i ++ ] * scale;
								cpx2 = outline[ i ++ ] * scale + offset;
								cpy2 = outline[ i ++ ] * scale;
	
								path.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );
	
								laste = pts[ pts.length - 1 ];
	
								if ( laste ) {
	
									cpx0 = laste.x;
									cpy0 = laste.y;
	
									for ( var i2 = 1; i2 <= divisions; i2 ++ ) {
	
										var t = i2 / divisions;
										b3( t, cpx0, cpx1, cpx2, cpx );
										b3( t, cpy0, cpy1, cpy2, cpy );
	
									}
	
								}
	
								break;
	
						}
	
					}
	
				}
	
				return { offset: glyph.ha * scale, path: path };
	
			}
	
			//
	
			if ( size === undefined ) size = 100;
			if ( divisions === undefined ) divisions = 4;
	
			var data = this.data;
	
			var paths = createPaths( text );
			var shapes = [];
	
			for ( var p = 0, pl = paths.length; p < pl; p ++ ) {
	
				Array.prototype.push.apply( shapes, paths[ p ].toShapes() );
	
			}
	
			return shapes;
	
		}
	
	};
	
	// File:src/extras/core/Path.js
	
	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Creates free form 2d path using series of points, lines or curves.
	 *
	 **/
	
	THREE.Path = function ( points ) {
	
		THREE.CurvePath.call( this );
	
		this.actions = [];
	
		if ( points ) {
	
			this.fromPoints( points );
	
		}
	
	};
	
	THREE.Path.prototype = Object.create( THREE.CurvePath.prototype );
	THREE.Path.prototype.constructor = THREE.Path;
	
	// TODO Clean up PATH API
	
	// Create path using straight lines to connect all points
	// - vectors: array of Vector2
	
	THREE.Path.prototype.fromPoints = function ( vectors ) {
	
		this.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );
	
		for ( var i = 1, l = vectors.length; i < l; i ++ ) {
	
			this.lineTo( vectors[ i ].x, vectors[ i ].y );
	
		}
	
	};
	
	// startPath() endPath()?
	
	THREE.Path.prototype.moveTo = function ( x, y ) {
	
		this.actions.push( { action: 'moveTo', args: [ x, y ] } );
	
	};
	
	THREE.Path.prototype.lineTo = function ( x, y ) {
	
		var lastargs = this.actions[ this.actions.length - 1 ].args;
	
		var x0 = lastargs[ lastargs.length - 2 ];
		var y0 = lastargs[ lastargs.length - 1 ];
	
		var curve = new THREE.LineCurve( new THREE.Vector2( x0, y0 ), new THREE.Vector2( x, y ) );
		this.curves.push( curve );
	
		this.actions.push( { action: 'lineTo', args: [ x, y ] } );
	
	};
	
	THREE.Path.prototype.quadraticCurveTo = function( aCPx, aCPy, aX, aY ) {
	
		var lastargs = this.actions[ this.actions.length - 1 ].args;
	
		var x0 = lastargs[ lastargs.length - 2 ];
		var y0 = lastargs[ lastargs.length - 1 ];
	
		var curve = new THREE.QuadraticBezierCurve(
			new THREE.Vector2( x0, y0 ),
			new THREE.Vector2( aCPx, aCPy ),
			new THREE.Vector2( aX, aY )
		);
	
		this.curves.push( curve );
	
		this.actions.push( { action: 'quadraticCurveTo', args: [ aCPx, aCPy, aX, aY ] } );
	
	};
	
	THREE.Path.prototype.bezierCurveTo = function( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {
	
		var lastargs = this.actions[ this.actions.length - 1 ].args;
	
		var x0 = lastargs[ lastargs.length - 2 ];
		var y0 = lastargs[ lastargs.length - 1 ];
	
		var curve = new THREE.CubicBezierCurve(
			new THREE.Vector2( x0, y0 ),
			new THREE.Vector2( aCP1x, aCP1y ),
			new THREE.Vector2( aCP2x, aCP2y ),
			new THREE.Vector2( aX, aY )
		);
	
		this.curves.push( curve );
	
		this.actions.push( { action: 'bezierCurveTo', args: [ aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ] } );
	
	};
	
	THREE.Path.prototype.splineThru = function( pts /*Array of Vector*/ ) {
	
		var args = Array.prototype.slice.call( arguments );
	
		var lastargs = this.actions[ this.actions.length - 1 ].args;
	
		var x0 = lastargs[ lastargs.length - 2 ];
		var y0 = lastargs[ lastargs.length - 1 ];
	
		var npts = [ new THREE.Vector2( x0, y0 ) ];
		Array.prototype.push.apply( npts, pts );
	
		var curve = new THREE.SplineCurve( npts );
		this.curves.push( curve );
	
		this.actions.push( { action: 'splineThru', args: args } );
	
	};
	
	// FUTURE: Change the API or follow canvas API?
	
	THREE.Path.prototype.arc = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {
	
		var lastargs = this.actions[ this.actions.length - 1 ].args;
		var x0 = lastargs[ lastargs.length - 2 ];
		var y0 = lastargs[ lastargs.length - 1 ];
	
		this.absarc( aX + x0, aY + y0, aRadius,
			aStartAngle, aEndAngle, aClockwise );
	
	 };
	
	 THREE.Path.prototype.absarc = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {
	
		this.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );
	
	 };
	
	THREE.Path.prototype.ellipse = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {
	
		var lastargs = this.actions[ this.actions.length - 1 ].args;
		var x0 = lastargs[ lastargs.length - 2 ];
		var y0 = lastargs[ lastargs.length - 1 ];
	
		this.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );
	
	 };
	
	
	THREE.Path.prototype.absellipse = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {
	
		var args = [
			aX, aY,
			xRadius, yRadius,
			aStartAngle, aEndAngle,
			aClockwise,
			aRotation || 0 // aRotation is optional.
		];
	
		var curve = new THREE.EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );
		this.curves.push( curve );
	
		var lastPoint = curve.getPoint( 1 );
		args.push( lastPoint.x );
		args.push( lastPoint.y );
	
		this.actions.push( { action: 'ellipse', args: args } );
	
	 };
	
	THREE.Path.prototype.getSpacedPoints = function ( divisions ) {
	
		if ( ! divisions ) divisions = 40;
	
		var points = [];
	
		for ( var i = 0; i < divisions; i ++ ) {
	
			points.push( this.getPoint( i / divisions ) );
	
			//if ( !this.getPoint( i / divisions ) ) throw "DIE";
	
		}
	
		if ( this.autoClose ) {
	
			points.push( points[ 0 ] );
	
		}
	
		return points;
	
	};
	
	/* Return an array of vectors based on contour of the path */
	
	THREE.Path.prototype.getPoints = function( divisions ) {
	
		divisions = divisions || 12;
	
		var b2 = THREE.ShapeUtils.b2;
		var b3 = THREE.ShapeUtils.b3;
	
		var points = [];
	
		var cpx, cpy, cpx2, cpy2, cpx1, cpy1, cpx0, cpy0,
			laste, tx, ty;
	
		for ( var i = 0, l = this.actions.length; i < l; i ++ ) {
	
			var item = this.actions[ i ];
	
			var action = item.action;
			var args = item.args;
	
			switch ( action ) {
	
			case 'moveTo':
	
				points.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );
	
				break;
	
			case 'lineTo':
	
				points.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );
	
				break;
	
			case 'quadraticCurveTo':
	
				cpx  = args[ 2 ];
				cpy  = args[ 3 ];
	
				cpx1 = args[ 0 ];
				cpy1 = args[ 1 ];
	
				if ( points.length > 0 ) {
	
					laste = points[ points.length - 1 ];
	
					cpx0 = laste.x;
					cpy0 = laste.y;
	
				} else {
	
					laste = this.actions[ i - 1 ].args;
	
					cpx0 = laste[ laste.length - 2 ];
					cpy0 = laste[ laste.length - 1 ];
	
				}
	
				for ( var j = 1; j <= divisions; j ++ ) {
	
					var t = j / divisions;
	
					tx = b2( t, cpx0, cpx1, cpx );
					ty = b2( t, cpy0, cpy1, cpy );
	
					points.push( new THREE.Vector2( tx, ty ) );
	
				}
	
				break;
	
			case 'bezierCurveTo':
	
				cpx  = args[ 4 ];
				cpy  = args[ 5 ];
	
				cpx1 = args[ 0 ];
				cpy1 = args[ 1 ];
	
				cpx2 = args[ 2 ];
				cpy2 = args[ 3 ];
	
				if ( points.length > 0 ) {
	
					laste = points[ points.length - 1 ];
	
					cpx0 = laste.x;
					cpy0 = laste.y;
	
				} else {
	
					laste = this.actions[ i - 1 ].args;
	
					cpx0 = laste[ laste.length - 2 ];
					cpy0 = laste[ laste.length - 1 ];
	
				}
	
	
				for ( var j = 1; j <= divisions; j ++ ) {
	
					var t = j / divisions;
	
					tx = b3( t, cpx0, cpx1, cpx2, cpx );
					ty = b3( t, cpy0, cpy1, cpy2, cpy );
	
					points.push( new THREE.Vector2( tx, ty ) );
	
				}
	
				break;
	
			case 'splineThru':
	
				laste = this.actions[ i - 1 ].args;
	
				var last = new THREE.Vector2( laste[ laste.length - 2 ], laste[ laste.length - 1 ] );
				var spts = [ last ];
	
				var n = divisions * args[ 0 ].length;
	
				spts = spts.concat( args[ 0 ] );
	
				var spline = new THREE.SplineCurve( spts );
	
				for ( var j = 1; j <= n; j ++ ) {
	
					points.push( spline.getPointAt( j / n ) );
	
				}
	
				break;
	
			case 'arc':
	
				var aX = args[ 0 ], aY = args[ 1 ],
					aRadius = args[ 2 ],
					aStartAngle = args[ 3 ], aEndAngle = args[ 4 ],
					aClockwise = !! args[ 5 ];
	
				var deltaAngle = aEndAngle - aStartAngle;
				var angle;
				var tdivisions = divisions * 2;
	
				for ( var j = 1; j <= tdivisions; j ++ ) {
	
					var t = j / tdivisions;
	
					if ( ! aClockwise ) {
	
						t = 1 - t;
	
					}
	
					angle = aStartAngle + t * deltaAngle;
	
					tx = aX + aRadius * Math.cos( angle );
					ty = aY + aRadius * Math.sin( angle );
	
					//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);
	
					points.push( new THREE.Vector2( tx, ty ) );
	
				}
	
				//console.log(points);
	
				break;
	
			case 'ellipse':
	
				var aX = args[ 0 ], aY = args[ 1 ],
					xRadius = args[ 2 ],
					yRadius = args[ 3 ],
					aStartAngle = args[ 4 ], aEndAngle = args[ 5 ],
					aClockwise = !! args[ 6 ],
					aRotation = args[ 7 ];
	
	
				var deltaAngle = aEndAngle - aStartAngle;
				var angle;
				var tdivisions = divisions * 2;
	
				var cos, sin;
				if ( aRotation !== 0 ) {
	
					cos = Math.cos( aRotation );
					sin = Math.sin( aRotation );
	
				}
	
				for ( var j = 1; j <= tdivisions; j ++ ) {
	
					var t = j / tdivisions;
	
					if ( ! aClockwise ) {
	
						t = 1 - t;
	
					}
	
					angle = aStartAngle + t * deltaAngle;
	
					tx = aX + xRadius * Math.cos( angle );
					ty = aY + yRadius * Math.sin( angle );
	
					if ( aRotation !== 0 ) {
	
						var x = tx, y = ty;
	
						// Rotate the point about the center of the ellipse.
						tx = ( x - aX ) * cos - ( y - aY ) * sin + aX;
						ty = ( x - aX ) * sin + ( y - aY ) * cos + aY;
	
					}
	
					//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);
	
					points.push( new THREE.Vector2( tx, ty ) );
	
				}
	
				//console.log(points);
	
				break;
	
			} // end switch
	
		}
	
	
	
		// Normalize to remove the closing point by default.
		var lastPoint = points[ points.length - 1 ];
		if ( Math.abs( lastPoint.x - points[ 0 ].x ) < Number.EPSILON &&
				 Math.abs( lastPoint.y - points[ 0 ].y ) < Number.EPSILON )
			points.splice( points.length - 1, 1 );
	
		if ( this.autoClose ) {
	
			points.push( points[ 0 ] );
	
		}
	
		return points;
	
	};
	
	//
	// Breaks path into shapes
	//
	//	Assumptions (if parameter isCCW==true the opposite holds):
	//	- solid shapes are defined clockwise (CW)
	//	- holes are defined counterclockwise (CCW)
	//
	//	If parameter noHoles==true:
	//  - all subPaths are regarded as solid shapes
	//  - definition order CW/CCW has no relevance
	//
	
	THREE.Path.prototype.toShapes = function( isCCW, noHoles ) {
	
		function extractSubpaths( inActions ) {
	
			var subPaths = [], lastPath = new THREE.Path();
	
			for ( var i = 0, l = inActions.length; i < l; i ++ ) {
	
				var item = inActions[ i ];
	
				var args = item.args;
				var action = item.action;
	
				if ( action === 'moveTo' ) {
	
					if ( lastPath.actions.length !== 0 ) {
	
						subPaths.push( lastPath );
						lastPath = new THREE.Path();
	
					}
	
				}
	
				lastPath[ action ].apply( lastPath, args );
	
			}
	
			if ( lastPath.actions.length !== 0 ) {
	
				subPaths.push( lastPath );
	
			}
	
			// console.log(subPaths);
	
			return	subPaths;
	
		}
	
		function toShapesNoHoles( inSubpaths ) {
	
			var shapes = [];
	
			for ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {
	
				var tmpPath = inSubpaths[ i ];
	
				var tmpShape = new THREE.Shape();
				tmpShape.actions = tmpPath.actions;
				tmpShape.curves = tmpPath.curves;
	
				shapes.push( tmpShape );
	
			}
	
			//console.log("shape", shapes);
	
			return shapes;
	
		}
	
		function isPointInsidePolygon( inPt, inPolygon ) {
	
			var polyLen = inPolygon.length;
	
			// inPt on polygon contour => immediate success    or
			// toggling of inside/outside at every single! intersection point of an edge
			//  with the horizontal line through inPt, left of inPt
			//  not counting lowerY endpoints of edges and whole edges on that line
			var inside = false;
			for ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {
	
				var edgeLowPt  = inPolygon[ p ];
				var edgeHighPt = inPolygon[ q ];
	
				var edgeDx = edgeHighPt.x - edgeLowPt.x;
				var edgeDy = edgeHighPt.y - edgeLowPt.y;
	
				if ( Math.abs( edgeDy ) > Number.EPSILON ) {
	
					// not parallel
					if ( edgeDy < 0 ) {
	
						edgeLowPt  = inPolygon[ q ]; edgeDx = - edgeDx;
						edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;
	
					}
					if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) 		continue;
	
					if ( inPt.y === edgeLowPt.y ) {
	
						if ( inPt.x === edgeLowPt.x )		return	true;		// inPt is on contour ?
						// continue;				// no intersection or edgeLowPt => doesn't count !!!
	
					} else {
	
						var perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );
						if ( perpEdge === 0 )				return	true;		// inPt is on contour ?
						if ( perpEdge < 0 ) 				continue;
						inside = ! inside;		// true intersection left of inPt
	
					}
	
				} else {
	
					// parallel or collinear
					if ( inPt.y !== edgeLowPt.y ) 		continue;			// parallel
					// edge lies on the same horizontal line as inPt
					if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||
						 ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )		return	true;	// inPt: Point on contour !
					// continue;
	
				}
	
			}
	
			return	inside;
	
		}
	
		var isClockWise = THREE.ShapeUtils.isClockWise;
	
		var subPaths = extractSubpaths( this.actions );
		if ( subPaths.length === 0 ) return [];
	
		if ( noHoles === true )	return	toShapesNoHoles( subPaths );
	
	
		var solid, tmpPath, tmpShape, shapes = [];
	
		if ( subPaths.length === 1 ) {
	
			tmpPath = subPaths[ 0 ];
			tmpShape = new THREE.Shape();
			tmpShape.actions = tmpPath.actions;
			tmpShape.curves = tmpPath.curves;
			shapes.push( tmpShape );
			return shapes;
	
		}
	
		var holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );
		holesFirst = isCCW ? ! holesFirst : holesFirst;
	
		// console.log("Holes first", holesFirst);
	
		var betterShapeHoles = [];
		var newShapes = [];
		var newShapeHoles = [];
		var mainIdx = 0;
		var tmpPoints;
	
		newShapes[ mainIdx ] = undefined;
		newShapeHoles[ mainIdx ] = [];
	
		for ( var i = 0, l = subPaths.length; i < l; i ++ ) {
	
			tmpPath = subPaths[ i ];
			tmpPoints = tmpPath.getPoints();
			solid = isClockWise( tmpPoints );
			solid = isCCW ? ! solid : solid;
	
			if ( solid ) {
	
				if ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )	mainIdx ++;
	
				newShapes[ mainIdx ] = { s: new THREE.Shape(), p: tmpPoints };
				newShapes[ mainIdx ].s.actions = tmpPath.actions;
				newShapes[ mainIdx ].s.curves = tmpPath.curves;
	
				if ( holesFirst )	mainIdx ++;
				newShapeHoles[ mainIdx ] = [];
	
				//console.log('cw', i);
	
			} else {
	
				newShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );
	
				//console.log('ccw', i);
	
			}
	
		}
	
		// only Holes? -> probably all Shapes with wrong orientation
		if ( ! newShapes[ 0 ] )	return	toShapesNoHoles( subPaths );
	
	
		if ( newShapes.length > 1 ) {
	
			var ambiguous = false;
			var toChange = [];
	
			for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {
	
				betterShapeHoles[ sIdx ] = [];
	
			}
	
			for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {
	
				var sho = newShapeHoles[ sIdx ];
	
				for ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {
	
					var ho = sho[ hIdx ];
					var hole_unassigned = true;
	
					for ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {
	
						if ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {
	
							if ( sIdx !== s2Idx )	toChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );
							if ( hole_unassigned ) {
	
								hole_unassigned = false;
								betterShapeHoles[ s2Idx ].push( ho );
	
							} else {
	
								ambiguous = true;
	
							}
	
						}
	
					}
					if ( hole_unassigned ) {
	
						betterShapeHoles[ sIdx ].push( ho );
	
					}
	
				}
	
			}
			// console.log("ambiguous: ", ambiguous);
			if ( toChange.length > 0 ) {
	
				// console.log("to change: ", toChange);
				if ( ! ambiguous )	newShapeHoles = betterShapeHoles;
	
			}
	
		}
	
		var tmpHoles;
	
		for ( var i = 0, il = newShapes.length; i < il; i ++ ) {
	
			tmpShape = newShapes[ i ].s;
			shapes.push( tmpShape );
			tmpHoles = newShapeHoles[ i ];
	
			for ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {
	
				tmpShape.holes.push( tmpHoles[ j ].h );
	
			}
	
		}
	
		//console.log("shape", shapes);
	
		return shapes;
	
	};
	
	// File:src/extras/core/Shape.js
	
	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Defines a 2d shape plane using paths.
	 **/
	
	// STEP 1 Create a path.
	// STEP 2 Turn path into shape.
	// STEP 3 ExtrudeGeometry takes in Shape/Shapes
	// STEP 3a - Extract points from each shape, turn to vertices
	// STEP 3b - Triangulate each shape, add faces.
	
	THREE.Shape = function () {
	
		THREE.Path.apply( this, arguments );
	
		this.holes = [];
	
	};
	
	THREE.Shape.prototype = Object.create( THREE.Path.prototype );
	THREE.Shape.prototype.constructor = THREE.Shape;
	
	// Convenience method to return ExtrudeGeometry
	
	THREE.Shape.prototype.extrude = function ( options ) {
	
		return new THREE.ExtrudeGeometry( this, options );
	
	};
	
	// Convenience method to return ShapeGeometry
	
	THREE.Shape.prototype.makeGeometry = function ( options ) {
	
		return new THREE.ShapeGeometry( this, options );
	
	};
	
	// Get points of holes
	
	THREE.Shape.prototype.getPointsHoles = function ( divisions ) {
	
		var holesPts = [];
	
		for ( var i = 0, l = this.holes.length; i < l; i ++ ) {
	
			holesPts[ i ] = this.holes[ i ].getPoints( divisions );
	
		}
	
		return holesPts;
	
	};
	
	
	// Get points of shape and holes (keypoints based on segments parameter)
	
	THREE.Shape.prototype.extractAllPoints = function ( divisions ) {
	
		return {
	
			shape: this.getPoints( divisions ),
			holes: this.getPointsHoles( divisions )
	
		};
	
	};
	
	THREE.Shape.prototype.extractPoints = function ( divisions ) {
	
		return this.extractAllPoints( divisions );
	
	};
	
	// File:src/extras/curves/LineCurve.js
	
	/**************************************************************
	 *	Line
	 **************************************************************/
	
	THREE.LineCurve = function ( v1, v2 ) {
	
		this.v1 = v1;
		this.v2 = v2;
	
	};
	
	THREE.LineCurve.prototype = Object.create( THREE.Curve.prototype );
	THREE.LineCurve.prototype.constructor = THREE.LineCurve;
	
	THREE.LineCurve.prototype.getPoint = function ( t ) {
	
		var point = this.v2.clone().sub( this.v1 );
		point.multiplyScalar( t ).add( this.v1 );
	
		return point;
	
	};
	
	// Line curve is linear, so we can overwrite default getPointAt
	
	THREE.LineCurve.prototype.getPointAt = function ( u ) {
	
		return this.getPoint( u );
	
	};
	
	THREE.LineCurve.prototype.getTangent = function( t ) {
	
		var tangent = this.v2.clone().sub( this.v1 );
	
		return tangent.normalize();
	
	};
	
	// File:src/extras/curves/QuadraticBezierCurve.js
	
	/**************************************************************
	 *	Quadratic Bezier curve
	 **************************************************************/
	
	
	THREE.QuadraticBezierCurve = function ( v0, v1, v2 ) {
	
		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;
	
	};
	
	THREE.QuadraticBezierCurve.prototype = Object.create( THREE.Curve.prototype );
	THREE.QuadraticBezierCurve.prototype.constructor = THREE.QuadraticBezierCurve;
	
	
	THREE.QuadraticBezierCurve.prototype.getPoint = function ( t ) {
	
		var b2 = THREE.ShapeUtils.b2;
	
		return new THREE.Vector2(
			b2( t, this.v0.x, this.v1.x, this.v2.x ),
			b2( t, this.v0.y, this.v1.y, this.v2.y )
		);
	
	};
	
	
	THREE.QuadraticBezierCurve.prototype.getTangent = function( t ) {
	
		var tangentQuadraticBezier = THREE.CurveUtils.tangentQuadraticBezier;
	
		return new THREE.Vector2(
			tangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x ),
			tangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y )
		).normalize();
	
	};
	
	// File:src/extras/curves/CubicBezierCurve.js
	
	/**************************************************************
	 *	Cubic Bezier curve
	 **************************************************************/
	
	THREE.CubicBezierCurve = function ( v0, v1, v2, v3 ) {
	
		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;
		this.v3 = v3;
	
	};
	
	THREE.CubicBezierCurve.prototype = Object.create( THREE.Curve.prototype );
	THREE.CubicBezierCurve.prototype.constructor = THREE.CubicBezierCurve;
	
	THREE.CubicBezierCurve.prototype.getPoint = function ( t ) {
	
		var b3 = THREE.ShapeUtils.b3;
	
		return new THREE.Vector2( 
			b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),
			b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )
		);
	
	};
	
	THREE.CubicBezierCurve.prototype.getTangent = function( t ) {
	
		var tangentCubicBezier = THREE.CurveUtils.tangentCubicBezier;
	
		return new THREE.Vector2( 
			tangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),
			tangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )
		).normalize();
	
	};
	
	// File:src/extras/curves/SplineCurve.js
	
	/**************************************************************
	 *	Spline curve
	 **************************************************************/
	
	THREE.SplineCurve = function ( points /* array of Vector2 */ ) {
	
		this.points = ( points == undefined ) ? [] : points;
	
	};
	
	THREE.SplineCurve.prototype = Object.create( THREE.Curve.prototype );
	THREE.SplineCurve.prototype.constructor = THREE.SplineCurve;
	
	THREE.SplineCurve.prototype.getPoint = function ( t ) {
	
		var points = this.points;
		var point = ( points.length - 1 ) * t;
	
		var intPoint = Math.floor( point );
		var weight = point - intPoint;
	
		var point0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];
		var point1 = points[ intPoint ];
		var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
		var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];
	
		var interpolate = THREE.CurveUtils.interpolate;
	
		return new THREE.Vector2(
			interpolate( point0.x, point1.x, point2.x, point3.x, weight ),
			interpolate( point0.y, point1.y, point2.y, point3.y, weight )
		);
	
	};
	
	// File:src/extras/curves/EllipseCurve.js
	
	/**************************************************************
	 *	Ellipse curve
	 **************************************************************/
	
	THREE.EllipseCurve = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {
	
		this.aX = aX;
		this.aY = aY;
	
		this.xRadius = xRadius;
		this.yRadius = yRadius;
	
		this.aStartAngle = aStartAngle;
		this.aEndAngle = aEndAngle;
	
		this.aClockwise = aClockwise;
		
		this.aRotation = aRotation || 0;
	
	};
	
	THREE.EllipseCurve.prototype = Object.create( THREE.Curve.prototype );
	THREE.EllipseCurve.prototype.constructor = THREE.EllipseCurve;
	
	THREE.EllipseCurve.prototype.getPoint = function ( t ) {
	
		var deltaAngle = this.aEndAngle - this.aStartAngle;
	
		if ( deltaAngle < 0 ) deltaAngle += Math.PI * 2;
		if ( deltaAngle > Math.PI * 2 ) deltaAngle -= Math.PI * 2;
	
		var angle;
	
		if ( this.aClockwise === true ) {
	
			angle = this.aEndAngle + ( 1 - t ) * ( Math.PI * 2 - deltaAngle );
	
		} else {
	
			angle = this.aStartAngle + t * deltaAngle;
	
		}
		
		var x = this.aX + this.xRadius * Math.cos( angle );
		var y = this.aY + this.yRadius * Math.sin( angle );
	
		if ( this.aRotation !== 0 ) {
	
			var cos = Math.cos( this.aRotation );
			var sin = Math.sin( this.aRotation );
	
			var tx = x, ty = y;
	
			// Rotate the point about the center of the ellipse.
			x = ( tx - this.aX ) * cos - ( ty - this.aY ) * sin + this.aX;
			y = ( tx - this.aX ) * sin + ( ty - this.aY ) * cos + this.aY;
	
		}
	
		return new THREE.Vector2( x, y );
	
	};
	
	// File:src/extras/curves/ArcCurve.js
	
	/**************************************************************
	 *	Arc curve
	 **************************************************************/
	
	THREE.ArcCurve = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {
	
		THREE.EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );
	
	};
	
	THREE.ArcCurve.prototype = Object.create( THREE.EllipseCurve.prototype );
	THREE.ArcCurve.prototype.constructor = THREE.ArcCurve;
	
	// File:src/extras/curves/LineCurve3.js
	
	/**************************************************************
	 *	Line3D
	 **************************************************************/
	
	THREE.LineCurve3 = THREE.Curve.create(
	
		function ( v1, v2 ) {
	
			this.v1 = v1;
			this.v2 = v2;
	
		},
	
		function ( t ) {
	
			var vector = new THREE.Vector3();
	
			vector.subVectors( this.v2, this.v1 ); // diff
			vector.multiplyScalar( t );
			vector.add( this.v1 );
	
			return vector;
	
		}
	
	);
	
	// File:src/extras/curves/QuadraticBezierCurve3.js
	
	/**************************************************************
	 *	Quadratic Bezier 3D curve
	 **************************************************************/
	
	THREE.QuadraticBezierCurve3 = THREE.Curve.create(
	
		function ( v0, v1, v2 ) {
	
			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;
	
		},
	
		function ( t ) {
	
			var b2 = THREE.ShapeUtils.b2;		
	
			return new THREE.Vector3(
				b2( t, this.v0.x, this.v1.x, this.v2.x ),
				b2( t, this.v0.y, this.v1.y, this.v2.y ),
				b2( t, this.v0.z, this.v1.z, this.v2.z )
			);
	
		}
	
	);
	
	// File:src/extras/curves/CubicBezierCurve3.js
	
	/**************************************************************
	 *	Cubic Bezier 3D curve
	 **************************************************************/
	
	THREE.CubicBezierCurve3 = THREE.Curve.create(
	
		function ( v0, v1, v2, v3 ) {
	
			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;
			this.v3 = v3;
	
		},
	
		function ( t ) {
	
			var b3 = THREE.ShapeUtils.b3;
	
			return new THREE.Vector3(
				b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),
				b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y ),
				b3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z )
			);
	
		}
	
	);
	
	// File:src/extras/curves/SplineCurve3.js
	
	/**************************************************************
	 *	Spline 3D curve
	 **************************************************************/
	
	
	THREE.SplineCurve3 = THREE.Curve.create(
	
		function ( points /* array of Vector3 */ ) {
	
			console.warn( 'THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3' );
			this.points = ( points == undefined ) ? [] : points;
	
		},
	
		function ( t ) {
	
			var points = this.points;
			var point = ( points.length - 1 ) * t;
	
			var intPoint = Math.floor( point );
			var weight = point - intPoint;
	
			var point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ];
			var point1 = points[ intPoint ];
			var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
			var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];
	
			var interpolate = THREE.CurveUtils.interpolate;
	
			return new THREE.Vector3(
				interpolate( point0.x, point1.x, point2.x, point3.x, weight ),
				interpolate( point0.y, point1.y, point2.y, point3.y, weight ),
				interpolate( point0.z, point1.z, point2.z, point3.z, weight )
			);
	
		}
	
	);
	
	// File:src/extras/curves/CatmullRomCurve3.js
	
	/**
	 * @author zz85 https://github.com/zz85
	 *
	 * Centripetal CatmullRom Curve - which is useful for avoiding
	 * cusps and self-intersections in non-uniform catmull rom curves.
	 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
	 *
	 * curve.type accepts centripetal(default), chordal and catmullrom
	 * curve.tension is used for catmullrom which defaults to 0.5
	 */
	
	THREE.CatmullRomCurve3 = ( function() {
	
		var
			tmp = new THREE.Vector3(),
			px = new CubicPoly(),
			py = new CubicPoly(),
			pz = new CubicPoly();
	
		/*
		Based on an optimized c++ solution in
		 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
		 - http://ideone.com/NoEbVM
	
		This CubicPoly class could be used for reusing some variables and calculations,
		but for three.js curve use, it could be possible inlined and flatten into a single function call
		which can be placed in CurveUtils.
		*/
	
		function CubicPoly() {
	
		}
	
		/*
		 * Compute coefficients for a cubic polynomial
		 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
		 * such that
		 *   p(0) = x0, p(1) = x1
		 *  and
		 *   p'(0) = t0, p'(1) = t1.
		 */
		CubicPoly.prototype.init = function( x0, x1, t0, t1 ) {
	
			this.c0 = x0;
			this.c1 = t0;
			this.c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;
			this.c3 = 2 * x0 - 2 * x1 + t0 + t1;
	
		};
	
		CubicPoly.prototype.initNonuniformCatmullRom = function( x0, x1, x2, x3, dt0, dt1, dt2 ) {
	
			// compute tangents when parameterized in [t1,t2]
			var t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;
			var t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;
	
			// rescale tangents for parametrization in [0,1]
			t1 *= dt1;
			t2 *= dt1;
	
			// initCubicPoly
			this.init( x1, x2, t1, t2 );
	
		};
	
		// standard Catmull-Rom spline: interpolate between x1 and x2 with previous/following points x1/x4
		CubicPoly.prototype.initCatmullRom = function( x0, x1, x2, x3, tension ) {
	
			this.init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );
	
		};
	
		CubicPoly.prototype.calc = function( t ) {
	
			var t2 = t * t;
			var t3 = t2 * t;
			return this.c0 + this.c1 * t + this.c2 * t2 + this.c3 * t3;
	
		};
	
		// Subclass Three.js curve
		return THREE.Curve.create(
	
			function ( p /* array of Vector3 */ ) {
	
				this.points = p || [];
				this.closed = false;
	
			},
	
			function ( t ) {
	
				var points = this.points,
					point, intPoint, weight, l;
	
				l = points.length;
	
				if ( l < 2 ) console.log( 'duh, you need at least 2 points' );
	
				point = ( l - ( this.closed ? 0 : 1 ) ) * t;
				intPoint = Math.floor( point );
				weight = point - intPoint;
	
				if ( this.closed ) {
	
					intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;
	
				} else if ( weight === 0 && intPoint === l - 1 ) {
	
					intPoint = l - 2;
					weight = 1;
	
				}
	
				var p0, p1, p2, p3; // 4 points
	
				if ( this.closed || intPoint > 0 ) {
	
					p0 = points[ ( intPoint - 1 ) % l ];
	
				} else {
	
					// extrapolate first point
					tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );
					p0 = tmp;
	
				}
	
				p1 = points[ intPoint % l ];
				p2 = points[ ( intPoint + 1 ) % l ];
	
				if ( this.closed || intPoint + 2 < l ) {
	
					p3 = points[ ( intPoint + 2 ) % l ];
	
				} else {
	
					// extrapolate last point
					tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );
					p3 = tmp;
	
				}
	
				if ( this.type === undefined || this.type === 'centripetal' || this.type === 'chordal' ) {
	
					// init Centripetal / Chordal Catmull-Rom
					var pow = this.type === 'chordal' ? 0.5 : 0.25;
					var dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );
					var dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );
					var dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );
	
					// safety check for repeated points
					if ( dt1 < 1e-4 ) dt1 = 1.0;
					if ( dt0 < 1e-4 ) dt0 = dt1;
					if ( dt2 < 1e-4 ) dt2 = dt1;
	
					px.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );
					py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );
					pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );
	
				} else if ( this.type === 'catmullrom' ) {
	
					var tension = this.tension !== undefined ? this.tension : 0.5;
					px.initCatmullRom( p0.x, p1.x, p2.x, p3.x, tension );
					py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, tension );
					pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, tension );
	
				}
	
				var v = new THREE.Vector3(
					px.calc( weight ),
					py.calc( weight ),
					pz.calc( weight )
				);
	
				return v;
	
			}
	
		);
	
	} )();
	
	// File:src/extras/curves/ClosedSplineCurve3.js
	
	/**************************************************************
	 *	Closed Spline 3D curve
	 **************************************************************/
	
	
	THREE.ClosedSplineCurve3 = function ( points ) {
	
		console.warn( 'THREE.ClosedSplineCurve3 has been deprecated. Please use THREE.CatmullRomCurve3.' );
	
		THREE.CatmullRomCurve3.call( this, points );
		this.type = 'catmullrom';
		this.closed = true;
	
	};
	
	THREE.ClosedSplineCurve3.prototype = Object.create( THREE.CatmullRomCurve3.prototype );
	
	// File:src/extras/geometries/BoxGeometry.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as
	 */
	
	THREE.BoxGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {
	
		THREE.Geometry.call( this );
	
		this.type = 'BoxGeometry';
	
		this.parameters = {
			width: width,
			height: height,
			depth: depth,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			depthSegments: depthSegments
		};
	
		this.widthSegments = widthSegments || 1;
		this.heightSegments = heightSegments || 1;
		this.depthSegments = depthSegments || 1;
	
		var scope = this;
	
		var width_half = width / 2;
		var height_half = height / 2;
		var depth_half = depth / 2;
	
		buildPlane( 'z', 'y', - 1, - 1, depth, height, width_half, 0 ); // px
		buildPlane( 'z', 'y',   1, - 1, depth, height, - width_half, 1 ); // nx
		buildPlane( 'x', 'z',   1,   1, width, depth, height_half, 2 ); // py
		buildPlane( 'x', 'z',   1, - 1, width, depth, - height_half, 3 ); // ny
		buildPlane( 'x', 'y',   1, - 1, width, height, depth_half, 4 ); // pz
		buildPlane( 'x', 'y', - 1, - 1, width, height, - depth_half, 5 ); // nz
	
		function buildPlane( u, v, udir, vdir, width, height, depth, materialIndex ) {
	
			var w, ix, iy,
			gridX = scope.widthSegments,
			gridY = scope.heightSegments,
			width_half = width / 2,
			height_half = height / 2,
			offset = scope.vertices.length;
	
			if ( ( u === 'x' && v === 'y' ) || ( u === 'y' && v === 'x' ) ) {
	
				w = 'z';
	
			} else if ( ( u === 'x' && v === 'z' ) || ( u === 'z' && v === 'x' ) ) {
	
				w = 'y';
				gridY = scope.depthSegments;
	
			} else if ( ( u === 'z' && v === 'y' ) || ( u === 'y' && v === 'z' ) ) {
	
				w = 'x';
				gridX = scope.depthSegments;
	
			}
	
			var gridX1 = gridX + 1,
			gridY1 = gridY + 1,
			segment_width = width / gridX,
			segment_height = height / gridY,
			normal = new THREE.Vector3();
	
			normal[ w ] = depth > 0 ? 1 : - 1;
	
			for ( iy = 0; iy < gridY1; iy ++ ) {
	
				for ( ix = 0; ix < gridX1; ix ++ ) {
	
					var vector = new THREE.Vector3();
					vector[ u ] = ( ix * segment_width - width_half ) * udir;
					vector[ v ] = ( iy * segment_height - height_half ) * vdir;
					vector[ w ] = depth;
	
					scope.vertices.push( vector );
	
				}
	
			}
	
			for ( iy = 0; iy < gridY; iy ++ ) {
	
				for ( ix = 0; ix < gridX; ix ++ ) {
	
					var a = ix + gridX1 * iy;
					var b = ix + gridX1 * ( iy + 1 );
					var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
					var d = ( ix + 1 ) + gridX1 * iy;
	
					var uva = new THREE.Vector2( ix / gridX, 1 - iy / gridY );
					var uvb = new THREE.Vector2( ix / gridX, 1 - ( iy + 1 ) / gridY );
					var uvc = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - ( iy + 1 ) / gridY );
					var uvd = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - iy / gridY );
	
					var face = new THREE.Face3( a + offset, b + offset, d + offset );
					face.normal.copy( normal );
					face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );
					face.materialIndex = materialIndex;
	
					scope.faces.push( face );
					scope.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );
	
					face = new THREE.Face3( b + offset, c + offset, d + offset );
					face.normal.copy( normal );
					face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );
					face.materialIndex = materialIndex;
	
					scope.faces.push( face );
					scope.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );
	
				}
	
			}
	
		}
	
		this.mergeVertices();
	
	};
	
	THREE.BoxGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.BoxGeometry.prototype.constructor = THREE.BoxGeometry;
	
	THREE.CubeGeometry = THREE.BoxGeometry;
	
	// File:src/extras/geometries/CircleGeometry.js
	
	/**
	 * @author hughes
	 */
	
	THREE.CircleGeometry = function ( radius, segments, thetaStart, thetaLength ) {
	
		THREE.Geometry.call( this );
	
		this.type = 'CircleGeometry';
	
		this.parameters = {
			radius: radius,
			segments: segments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};
	
		this.fromBufferGeometry( new THREE.CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );
	
	};
	
	THREE.CircleGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.CircleGeometry.prototype.constructor = THREE.CircleGeometry;
	
	// File:src/extras/geometries/CircleBufferGeometry.js
	
	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */
	
	THREE.CircleBufferGeometry = function ( radius, segments, thetaStart, thetaLength ) {
	
		THREE.BufferGeometry.call( this );
	
		this.type = 'CircleBufferGeometry';
	
		this.parameters = {
			radius: radius,
			segments: segments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};
	
		radius = radius || 50;
		segments = segments !== undefined ? Math.max( 3, segments ) : 8;
	
		thetaStart = thetaStart !== undefined ? thetaStart : 0;
		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
	
		var vertices = segments + 2;
	
		var positions = new Float32Array( vertices * 3 );
		var normals = new Float32Array( vertices * 3 );
		var uvs = new Float32Array( vertices * 2 );
	
		// center data is already zero, but need to set a few extras
		normals[ 2 ] = 1.0;
		uvs[ 0 ] = 0.5;
		uvs[ 1 ] = 0.5;
	
		for ( var s = 0, i = 3, ii = 2 ; s <= segments; s ++, i += 3, ii += 2 ) {
	
			var segment = thetaStart + s / segments * thetaLength;
	
			positions[ i ] = radius * Math.cos( segment );
			positions[ i + 1 ] = radius * Math.sin( segment );
	
			normals[ i + 2 ] = 1; // normal z
	
			uvs[ ii ] = ( positions[ i ] / radius + 1 ) / 2;
			uvs[ ii + 1 ] = ( positions[ i + 1 ] / radius + 1 ) / 2;
	
		}
	
		var indices = [];
	
		for ( var i = 1; i <= segments; i ++ ) {
	
			indices.push( i, i + 1, 0 );
	
		}
	
		this.setIndex( new THREE.BufferAttribute( new Uint16Array( indices ), 1 ) );
		this.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
		this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );
	
		this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );
	
	};
	
	THREE.CircleBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
	THREE.CircleBufferGeometry.prototype.constructor = THREE.CircleBufferGeometry;
	
	// File:src/extras/geometries/CylinderGeometry.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.CylinderGeometry = function ( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {
	
		THREE.Geometry.call( this );
	
		this.type = 'CylinderGeometry';
	
		this.parameters = {
			radiusTop: radiusTop,
			radiusBottom: radiusBottom,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			openEnded: openEnded,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};
	
		radiusTop = radiusTop !== undefined ? radiusTop : 20;
		radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;
		height = height !== undefined ? height : 100;
	
		radialSegments = radialSegments || 8;
		heightSegments = heightSegments || 1;
	
		openEnded = openEnded !== undefined ? openEnded : false;
		thetaStart = thetaStart !== undefined ? thetaStart : 0;
		thetaLength = thetaLength !== undefined ? thetaLength : 2 * Math.PI;
	
		var heightHalf = height / 2;
	
		var x, y, vertices = [], uvs = [];
	
		for ( y = 0; y <= heightSegments; y ++ ) {
	
			var verticesRow = [];
			var uvsRow = [];
	
			var v = y / heightSegments;
			var radius = v * ( radiusBottom - radiusTop ) + radiusTop;
	
			for ( x = 0; x <= radialSegments; x ++ ) {
	
				var u = x / radialSegments;
	
				var vertex = new THREE.Vector3();
				vertex.x = radius * Math.sin( u * thetaLength + thetaStart );
				vertex.y = - v * height + heightHalf;
				vertex.z = radius * Math.cos( u * thetaLength + thetaStart );
	
				this.vertices.push( vertex );
	
				verticesRow.push( this.vertices.length - 1 );
				uvsRow.push( new THREE.Vector2( u, 1 - v ) );
	
			}
	
			vertices.push( verticesRow );
			uvs.push( uvsRow );
	
		}
	
		var tanTheta = ( radiusBottom - radiusTop ) / height;
		var na, nb;
	
		for ( x = 0; x < radialSegments; x ++ ) {
	
			if ( radiusTop !== 0 ) {
	
				na = this.vertices[ vertices[ 0 ][ x ] ].clone();
				nb = this.vertices[ vertices[ 0 ][ x + 1 ] ].clone();
	
			} else {
	
				na = this.vertices[ vertices[ 1 ][ x ] ].clone();
				nb = this.vertices[ vertices[ 1 ][ x + 1 ] ].clone();
	
			}
	
			na.setY( Math.sqrt( na.x * na.x + na.z * na.z ) * tanTheta ).normalize();
			nb.setY( Math.sqrt( nb.x * nb.x + nb.z * nb.z ) * tanTheta ).normalize();
	
			for ( y = 0; y < heightSegments; y ++ ) {
	
				var v1 = vertices[ y ][ x ];
				var v2 = vertices[ y + 1 ][ x ];
				var v3 = vertices[ y + 1 ][ x + 1 ];
				var v4 = vertices[ y ][ x + 1 ];
	
				var n1 = na.clone();
				var n2 = na.clone();
				var n3 = nb.clone();
				var n4 = nb.clone();
	
				var uv1 = uvs[ y ][ x ].clone();
				var uv2 = uvs[ y + 1 ][ x ].clone();
				var uv3 = uvs[ y + 1 ][ x + 1 ].clone();
				var uv4 = uvs[ y ][ x + 1 ].clone();
	
				this.faces.push( new THREE.Face3( v1, v2, v4, [ n1, n2, n4 ] ) );
				this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv4 ] );
	
				this.faces.push( new THREE.Face3( v2, v3, v4, [ n2.clone(), n3, n4.clone() ] ) );
				this.faceVertexUvs[ 0 ].push( [ uv2.clone(), uv3, uv4.clone() ] );
	
			}
	
		}
	
		// top cap
	
		if ( openEnded === false && radiusTop > 0 ) {
	
			this.vertices.push( new THREE.Vector3( 0, heightHalf, 0 ) );
	
			for ( x = 0; x < radialSegments; x ++ ) {
	
				var v1 = vertices[ 0 ][ x ];
				var v2 = vertices[ 0 ][ x + 1 ];
				var v3 = this.vertices.length - 1;
	
				var n1 = new THREE.Vector3( 0, 1, 0 );
				var n2 = new THREE.Vector3( 0, 1, 0 );
				var n3 = new THREE.Vector3( 0, 1, 0 );
	
				var uv1 = uvs[ 0 ][ x ].clone();
				var uv2 = uvs[ 0 ][ x + 1 ].clone();
				var uv3 = new THREE.Vector2( uv2.x, 0 );
	
				this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ], undefined, 1 ) );
				this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );
	
			}
	
		}
	
		// bottom cap
	
		if ( openEnded === false && radiusBottom > 0 ) {
	
			this.vertices.push( new THREE.Vector3( 0, - heightHalf, 0 ) );
	
			for ( x = 0; x < radialSegments; x ++ ) {
	
				var v1 = vertices[ heightSegments ][ x + 1 ];
				var v2 = vertices[ heightSegments ][ x ];
				var v3 = this.vertices.length - 1;
	
				var n1 = new THREE.Vector3( 0, - 1, 0 );
				var n2 = new THREE.Vector3( 0, - 1, 0 );
				var n3 = new THREE.Vector3( 0, - 1, 0 );
	
				var uv1 = uvs[ heightSegments ][ x + 1 ].clone();
				var uv2 = uvs[ heightSegments ][ x ].clone();
				var uv3 = new THREE.Vector2( uv2.x, 1 );
	
				this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ], undefined, 2 ) );
				this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );
	
			}
	
		}
	
		this.computeFaceNormals();
	
	};
	
	THREE.CylinderGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.CylinderGeometry.prototype.constructor = THREE.CylinderGeometry;
	
	// File:src/extras/geometries/EdgesGeometry.js
	
	/**
	 * @author WestLangley / http://github.com/WestLangley
	 */
	
	THREE.EdgesGeometry = function ( geometry, thresholdAngle ) {
	
		THREE.BufferGeometry.call( this );
	
		thresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;
	
		var thresholdDot = Math.cos( THREE.Math.degToRad( thresholdAngle ) );
	
		var edge = [ 0, 0 ], hash = {};
	
		function sortFunction( a, b ) {
	
			return a - b;
	
		}
	
		var keys = [ 'a', 'b', 'c' ];
	
		var geometry2;
	
		if ( geometry instanceof THREE.BufferGeometry ) {
	
			geometry2 = new THREE.Geometry();
			geometry2.fromBufferGeometry( geometry );
	
		} else {
	
			geometry2 = geometry.clone();
	
		}
	
		geometry2.mergeVertices();
		geometry2.computeFaceNormals();
	
		var vertices = geometry2.vertices;
		var faces = geometry2.faces;
	
		for ( var i = 0, l = faces.length; i < l; i ++ ) {
	
			var face = faces[ i ];
	
			for ( var j = 0; j < 3; j ++ ) {
	
				edge[ 0 ] = face[ keys[ j ] ];
				edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
				edge.sort( sortFunction );
	
				var key = edge.toString();
	
				if ( hash[ key ] === undefined ) {
	
					hash[ key ] = { vert1: edge[ 0 ], vert2: edge[ 1 ], face1: i, face2: undefined };
	
				} else {
	
					hash[ key ].face2 = i;
	
				}
	
			}
	
		}
	
		var coords = [];
	
		for ( var key in hash ) {
	
			var h = hash[ key ];
	
			if ( h.face2 === undefined || faces[ h.face1 ].normal.dot( faces[ h.face2 ].normal ) <= thresholdDot ) {
	
				var vertex = vertices[ h.vert1 ];
				coords.push( vertex.x );
				coords.push( vertex.y );
				coords.push( vertex.z );
	
				vertex = vertices[ h.vert2 ];
				coords.push( vertex.x );
				coords.push( vertex.y );
				coords.push( vertex.z );
	
			}
	
		}
	
		this.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( coords ), 3 ) );
	
	};
	
	THREE.EdgesGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
	THREE.EdgesGeometry.prototype.constructor = THREE.EdgesGeometry;
	
	// File:src/extras/geometries/ExtrudeGeometry.js
	
	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 *
	 * Creates extruded geometry from a path shape.
	 *
	 * parameters = {
	 *
	 *  curveSegments: <int>, // number of points on the curves
	 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
	 *  amount: <int>, // Depth to extrude the shape
	 *
	 *  bevelEnabled: <bool>, // turn on bevel
	 *  bevelThickness: <float>, // how deep into the original shape bevel goes
	 *  bevelSize: <float>, // how far from shape outline is bevel
	 *  bevelSegments: <int>, // number of bevel layers
	 *
	 *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)
	 *  frames: <THREE.TubeGeometry.FrenetFrames> // containing arrays of tangents, normals, binormals
	 *
	 *  uvGenerator: <Object> // object that provides UV generator functions
	 *
	 * }
	 **/
	
	THREE.ExtrudeGeometry = function ( shapes, options ) {
	
		if ( typeof( shapes ) === "undefined" ) {
	
			shapes = [];
			return;
	
		}
	
		THREE.Geometry.call( this );
	
		this.type = 'ExtrudeGeometry';
	
		shapes = Array.isArray( shapes ) ? shapes : [ shapes ];
	
		this.addShapeList( shapes, options );
	
		this.computeFaceNormals();
	
		// can't really use automatic vertex normals
		// as then front and back sides get smoothed too
		// should do separate smoothing just for sides
	
		//this.computeVertexNormals();
	
		//console.log( "took", ( Date.now() - startTime ) );
	
	};
	
	THREE.ExtrudeGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.ExtrudeGeometry.prototype.constructor = THREE.ExtrudeGeometry;
	
	THREE.ExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {
	
		var sl = shapes.length;
	
		for ( var s = 0; s < sl; s ++ ) {
	
			var shape = shapes[ s ];
			this.addShape( shape, options );
	
		}
	
	};
	
	THREE.ExtrudeGeometry.prototype.addShape = function ( shape, options ) {
	
		var amount = options.amount !== undefined ? options.amount : 100;
	
		var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10
		var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8
		var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;
	
		var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false
	
		var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
	
		var steps = options.steps !== undefined ? options.steps : 1;
	
		var extrudePath = options.extrudePath;
		var extrudePts, extrudeByPath = false;
	
		// Use default WorldUVGenerator if no UV generators are specified.
		var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;
	
		var splineTube, binormal, normal, position2;
		if ( extrudePath ) {
	
			extrudePts = extrudePath.getSpacedPoints( steps );
	
			extrudeByPath = true;
			bevelEnabled = false; // bevels not supported for path extrusion
	
			// SETUP TNB variables
	
			// Reuse TNB from TubeGeomtry for now.
			// TODO1 - have a .isClosed in spline?
	
			splineTube = options.frames !== undefined ? options.frames : new THREE.TubeGeometry.FrenetFrames( extrudePath, steps, false );
	
			// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);
	
			binormal = new THREE.Vector3();
			normal = new THREE.Vector3();
			position2 = new THREE.Vector3();
	
		}
	
		// Safeguards if bevels are not enabled
	
		if ( ! bevelEnabled ) {
	
			bevelSegments = 0;
			bevelThickness = 0;
			bevelSize = 0;
	
		}
	
		// Variables initialization
	
		var ahole, h, hl; // looping of holes
		var scope = this;
	
		var shapesOffset = this.vertices.length;
	
		var shapePoints = shape.extractPoints( curveSegments );
	
		var vertices = shapePoints.shape;
		var holes = shapePoints.holes;
	
		var reverse = ! THREE.ShapeUtils.isClockWise( vertices );
	
		if ( reverse ) {
	
			vertices = vertices.reverse();
	
			// Maybe we should also check if holes are in the opposite direction, just to be safe ...
	
			for ( h = 0, hl = holes.length; h < hl; h ++ ) {
	
				ahole = holes[ h ];
	
				if ( THREE.ShapeUtils.isClockWise( ahole ) ) {
	
					holes[ h ] = ahole.reverse();
	
				}
	
			}
	
			reverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!
	
		}
	
	
		var faces = THREE.ShapeUtils.triangulateShape( vertices, holes );
	
		/* Vertices */
	
		var contour = vertices; // vertices has all points but contour has only points of circumference
	
		for ( h = 0, hl = holes.length; h < hl; h ++ ) {
	
			ahole = holes[ h ];
	
			vertices = vertices.concat( ahole );
	
		}
	
	
		function scalePt2 ( pt, vec, size ) {
	
			if ( ! vec ) console.error( "THREE.ExtrudeGeometry: vec does not exist" );
	
			return vec.clone().multiplyScalar( size ).add( pt );
	
		}
	
		var b, bs, t, z,
			vert, vlen = vertices.length,
			face, flen = faces.length;
	
	
		// Find directions for point movement
	
	
		function getBevelVec( inPt, inPrev, inNext ) {
	
			// computes for inPt the corresponding point inPt' on a new contour
			//   shifted by 1 unit (length of normalized vector) to the left
			// if we walk along contour clockwise, this new contour is outside the old one
			//
			// inPt' is the intersection of the two lines parallel to the two
			//  adjacent edges of inPt at a distance of 1 unit on the left side.
	
			var v_trans_x, v_trans_y, shrink_by = 1;		// resulting translation vector for inPt
	
			// good reading for geometry algorithms (here: line-line intersection)
			// http://geomalgorithms.com/a05-_intersect-1.html
	
			var v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
			var v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;
	
			var v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );
	
			// check for collinear edges
			var collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );
	
			if ( Math.abs( collinear0 ) > Number.EPSILON ) {
	
				// not collinear
	
				// length of vectors for normalizing
	
				var v_prev_len = Math.sqrt( v_prev_lensq );
				var v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );
	
				// shift adjacent points by unit vectors to the left
	
				var ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
				var ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );
	
				var ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
				var ptNextShift_y = ( inNext.y + v_next_x / v_next_len );
	
				// scaling factor for v_prev to intersection point
	
				var sf = (  ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
							( ptNextShift_y - ptPrevShift_y ) * v_next_x    ) /
						  ( v_prev_x * v_next_y - v_prev_y * v_next_x );
	
				// vector from inPt to intersection point
	
				v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
				v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );
	
				// Don't normalize!, otherwise sharp corners become ugly
				//  but prevent crazy spikes
				var v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );
				if ( v_trans_lensq <= 2 ) {
	
					return	new THREE.Vector2( v_trans_x, v_trans_y );
	
				} else {
	
					shrink_by = Math.sqrt( v_trans_lensq / 2 );
	
				}
	
			} else {
	
				// handle special case of collinear edges
	
				var direction_eq = false;		// assumes: opposite
				if ( v_prev_x > Number.EPSILON ) {
	
					if ( v_next_x > Number.EPSILON ) {
	
						direction_eq = true;
	
					}
	
				} else {
	
					if ( v_prev_x < - Number.EPSILON ) {
	
						if ( v_next_x < - Number.EPSILON ) {
	
							direction_eq = true;
	
						}
	
					} else {
	
						if ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {
	
							direction_eq = true;
	
						}
	
					}
	
				}
	
				if ( direction_eq ) {
	
					// console.log("Warning: lines are a straight sequence");
					v_trans_x = - v_prev_y;
					v_trans_y =  v_prev_x;
					shrink_by = Math.sqrt( v_prev_lensq );
	
				} else {
	
					// console.log("Warning: lines are a straight spike");
					v_trans_x = v_prev_x;
					v_trans_y = v_prev_y;
					shrink_by = Math.sqrt( v_prev_lensq / 2 );
	
				}
	
			}
	
			return	new THREE.Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );
	
		}
	
	
		var contourMovements = [];
	
		for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {
	
			if ( j === il ) j = 0;
			if ( k === il ) k = 0;
	
			//  (j)---(i)---(k)
			// console.log('i,j,k', i, j , k)
	
			contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );
	
		}
	
		var holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();
	
		for ( h = 0, hl = holes.length; h < hl; h ++ ) {
	
			ahole = holes[ h ];
	
			oneHoleMovements = [];
	
			for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {
	
				if ( j === il ) j = 0;
				if ( k === il ) k = 0;
	
				//  (j)---(i)---(k)
				oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );
	
			}
	
			holesMovements.push( oneHoleMovements );
			verticesMovements = verticesMovements.concat( oneHoleMovements );
	
		}
	
	
		// Loop bevelSegments, 1 for the front, 1 for the back
	
		for ( b = 0; b < bevelSegments; b ++ ) {
	
			//for ( b = bevelSegments; b > 0; b -- ) {
	
			t = b / bevelSegments;
			z = bevelThickness * ( 1 - t );
	
			//z = bevelThickness * t;
			bs = bevelSize * ( Math.sin ( t * Math.PI / 2 ) ); // curved
			//bs = bevelSize * t; // linear
	
			// contract shape
	
			for ( i = 0, il = contour.length; i < il; i ++ ) {
	
				vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
	
				v( vert.x, vert.y,  - z );
	
			}
	
			// expand holes
	
			for ( h = 0, hl = holes.length; h < hl; h ++ ) {
	
				ahole = holes[ h ];
				oneHoleMovements = holesMovements[ h ];
	
				for ( i = 0, il = ahole.length; i < il; i ++ ) {
	
					vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );
	
					v( vert.x, vert.y,  - z );
	
				}
	
			}
	
		}
	
		bs = bevelSize;
	
		// Back facing vertices
	
		for ( i = 0; i < vlen; i ++ ) {
	
			vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];
	
			if ( ! extrudeByPath ) {
	
				v( vert.x, vert.y, 0 );
	
			} else {
	
				// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );
	
				normal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );
				binormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );
	
				position2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );
	
				v( position2.x, position2.y, position2.z );
	
			}
	
		}
	
		// Add stepped vertices...
		// Including front facing vertices
	
		var s;
	
		for ( s = 1; s <= steps; s ++ ) {
	
			for ( i = 0; i < vlen; i ++ ) {
	
				vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];
	
				if ( ! extrudeByPath ) {
	
					v( vert.x, vert.y, amount / steps * s );
	
				} else {
	
					// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );
	
					normal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );
					binormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );
	
					position2.copy( extrudePts[ s ] ).add( normal ).add( binormal );
	
					v( position2.x, position2.y, position2.z );
	
				}
	
			}
	
		}
	
	
		// Add bevel segments planes
	
		//for ( b = 1; b <= bevelSegments; b ++ ) {
		for ( b = bevelSegments - 1; b >= 0; b -- ) {
	
			t = b / bevelSegments;
			z = bevelThickness * ( 1 - t );
			//bs = bevelSize * ( 1-Math.sin ( ( 1 - t ) * Math.PI/2 ) );
			bs = bevelSize * Math.sin ( t * Math.PI / 2 );
	
			// contract shape
	
			for ( i = 0, il = contour.length; i < il; i ++ ) {
	
				vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
				v( vert.x, vert.y,  amount + z );
	
			}
	
			// expand holes
	
			for ( h = 0, hl = holes.length; h < hl; h ++ ) {
	
				ahole = holes[ h ];
				oneHoleMovements = holesMovements[ h ];
	
				for ( i = 0, il = ahole.length; i < il; i ++ ) {
	
					vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );
	
					if ( ! extrudeByPath ) {
	
						v( vert.x, vert.y,  amount + z );
	
					} else {
	
						v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );
	
					}
	
				}
	
			}
	
		}
	
		/* Faces */
	
		// Top and bottom faces
	
		buildLidFaces();
	
		// Sides faces
	
		buildSideFaces();
	
	
		/////  Internal functions
	
		function buildLidFaces() {
	
			if ( bevelEnabled ) {
	
				var layer = 0; // steps + 1
				var offset = vlen * layer;
	
				// Bottom faces
	
				for ( i = 0; i < flen; i ++ ) {
	
					face = faces[ i ];
					f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );
	
				}
	
				layer = steps + bevelSegments * 2;
				offset = vlen * layer;
	
				// Top faces
	
				for ( i = 0; i < flen; i ++ ) {
	
					face = faces[ i ];
					f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );
	
				}
	
			} else {
	
				// Bottom faces
	
				for ( i = 0; i < flen; i ++ ) {
	
					face = faces[ i ];
					f3( face[ 2 ], face[ 1 ], face[ 0 ] );
	
				}
	
				// Top faces
	
				for ( i = 0; i < flen; i ++ ) {
	
					face = faces[ i ];
					f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );
	
				}
	
			}
	
		}
	
		// Create faces for the z-sides of the shape
	
		function buildSideFaces() {
	
			var layeroffset = 0;
			sidewalls( contour, layeroffset );
			layeroffset += contour.length;
	
			for ( h = 0, hl = holes.length; h < hl; h ++ ) {
	
				ahole = holes[ h ];
				sidewalls( ahole, layeroffset );
	
				//, true
				layeroffset += ahole.length;
	
			}
	
		}
	
		function sidewalls( contour, layeroffset ) {
	
			var j, k;
			i = contour.length;
	
			while ( -- i >= 0 ) {
	
				j = i;
				k = i - 1;
				if ( k < 0 ) k = contour.length - 1;
	
				//console.log('b', i,j, i-1, k,vertices.length);
	
				var s = 0, sl = steps  + bevelSegments * 2;
	
				for ( s = 0; s < sl; s ++ ) {
	
					var slen1 = vlen * s;
					var slen2 = vlen * ( s + 1 );
	
					var a = layeroffset + j + slen1,
						b = layeroffset + k + slen1,
						c = layeroffset + k + slen2,
						d = layeroffset + j + slen2;
	
					f4( a, b, c, d, contour, s, sl, j, k );
	
				}
	
			}
	
		}
	
	
		function v( x, y, z ) {
	
			scope.vertices.push( new THREE.Vector3( x, y, z ) );
	
		}
	
		function f3( a, b, c ) {
	
			a += shapesOffset;
			b += shapesOffset;
			c += shapesOffset;
	
			scope.faces.push( new THREE.Face3( a, b, c, null, null, 0 ) );
	
			var uvs = uvgen.generateTopUV( scope, a, b, c );
	
			scope.faceVertexUvs[ 0 ].push( uvs );
	
		}
	
		function f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {
	
			a += shapesOffset;
			b += shapesOffset;
			c += shapesOffset;
			d += shapesOffset;
	
			scope.faces.push( new THREE.Face3( a, b, d, null, null, 1 ) );
			scope.faces.push( new THREE.Face3( b, c, d, null, null, 1 ) );
	
			var uvs = uvgen.generateSideWallUV( scope, a, b, c, d );
	
			scope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );
			scope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );
	
		}
	
	};
	
	THREE.ExtrudeGeometry.WorldUVGenerator = {
	
		generateTopUV: function ( geometry, indexA, indexB, indexC ) {
	
			var vertices = geometry.vertices;
	
			var a = vertices[ indexA ];
			var b = vertices[ indexB ];
			var c = vertices[ indexC ];
	
			return [
				new THREE.Vector2( a.x, a.y ),
				new THREE.Vector2( b.x, b.y ),
				new THREE.Vector2( c.x, c.y )
			];
	
		},
	
		generateSideWallUV: function ( geometry, indexA, indexB, indexC, indexD ) {
	
			var vertices = geometry.vertices;
	
			var a = vertices[ indexA ];
			var b = vertices[ indexB ];
			var c = vertices[ indexC ];
			var d = vertices[ indexD ];
	
			if ( Math.abs( a.y - b.y ) < 0.01 ) {
	
				return [
					new THREE.Vector2( a.x, 1 - a.z ),
					new THREE.Vector2( b.x, 1 - b.z ),
					new THREE.Vector2( c.x, 1 - c.z ),
					new THREE.Vector2( d.x, 1 - d.z )
				];
	
			} else {
	
				return [
					new THREE.Vector2( a.y, 1 - a.z ),
					new THREE.Vector2( b.y, 1 - b.z ),
					new THREE.Vector2( c.y, 1 - c.z ),
					new THREE.Vector2( d.y, 1 - d.z )
				];
	
			}
	
		}
	};
	
	// File:src/extras/geometries/ShapeGeometry.js
	
	/**
	 * @author jonobr1 / http://jonobr1.com
	 *
	 * Creates a one-sided polygonal geometry from a path shape. Similar to
	 * ExtrudeGeometry.
	 *
	 * parameters = {
	 *
	 *	curveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.
	 *
	 *	material: <int> // material index for front and back faces
	 *	uvGenerator: <Object> // object that provides UV generator functions
	 *
	 * }
	 **/
	
	THREE.ShapeGeometry = function ( shapes, options ) {
	
		THREE.Geometry.call( this );
	
		this.type = 'ShapeGeometry';
	
		if ( Array.isArray( shapes ) === false ) shapes = [ shapes ];
	
		this.addShapeList( shapes, options );
	
		this.computeFaceNormals();
	
	};
	
	THREE.ShapeGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.ShapeGeometry.prototype.constructor = THREE.ShapeGeometry;
	
	/**
	 * Add an array of shapes to THREE.ShapeGeometry.
	 */
	THREE.ShapeGeometry.prototype.addShapeList = function ( shapes, options ) {
	
		for ( var i = 0, l = shapes.length; i < l; i ++ ) {
	
			this.addShape( shapes[ i ], options );
	
		}
	
		return this;
	
	};
	
	/**
	 * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.
	 */
	THREE.ShapeGeometry.prototype.addShape = function ( shape, options ) {
	
		if ( options === undefined ) options = {};
		var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
	
		var material = options.material;
		var uvgen = options.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;
	
		//
	
		var i, l, hole;
	
		var shapesOffset = this.vertices.length;
		var shapePoints = shape.extractPoints( curveSegments );
	
		var vertices = shapePoints.shape;
		var holes = shapePoints.holes;
	
		var reverse = ! THREE.ShapeUtils.isClockWise( vertices );
	
		if ( reverse ) {
	
			vertices = vertices.reverse();
	
			// Maybe we should also check if holes are in the opposite direction, just to be safe...
	
			for ( i = 0, l = holes.length; i < l; i ++ ) {
	
				hole = holes[ i ];
	
				if ( THREE.ShapeUtils.isClockWise( hole ) ) {
	
					holes[ i ] = hole.reverse();
	
				}
	
			}
	
			reverse = false;
	
		}
	
		var faces = THREE.ShapeUtils.triangulateShape( vertices, holes );
	
		// Vertices
	
		for ( i = 0, l = holes.length; i < l; i ++ ) {
	
			hole = holes[ i ];
			vertices = vertices.concat( hole );
	
		}
	
		//
	
		var vert, vlen = vertices.length;
		var face, flen = faces.length;
	
		for ( i = 0; i < vlen; i ++ ) {
	
			vert = vertices[ i ];
	
			this.vertices.push( new THREE.Vector3( vert.x, vert.y, 0 ) );
	
		}
	
		for ( i = 0; i < flen; i ++ ) {
	
			face = faces[ i ];
	
			var a = face[ 0 ] + shapesOffset;
			var b = face[ 1 ] + shapesOffset;
			var c = face[ 2 ] + shapesOffset;
	
			this.faces.push( new THREE.Face3( a, b, c, null, null, material ) );
			this.faceVertexUvs[ 0 ].push( uvgen.generateTopUV( this, a, b, c ) );
	
		}
	
	};
	
	// File:src/extras/geometries/LatheGeometry.js
	
	/**
	 * @author astrodud / http://astrodud.isgreat.org/
	 * @author zz85 / https://github.com/zz85
	 * @author bhouston / http://clara.io
	 */
	
	// points - to create a closed torus, one must use a set of points
	//    like so: [ a, b, c, d, a ], see first is the same as last.
	// segments - the number of circumference segments to create
	// phiStart - the starting radian
	// phiLength - the radian (0 to 2*PI) range of the lathed section
	//    2*pi is a closed lathe, less than 2PI is a portion.
	
	THREE.LatheGeometry = function ( points, segments, phiStart, phiLength ) {
	
		THREE.Geometry.call( this );
	
		this.type = 'LatheGeometry';
	
		this.parameters = {
			points: points,
			segments: segments,
			phiStart: phiStart,
			phiLength: phiLength
		};
	
		segments = segments || 12;
		phiStart = phiStart || 0;
		phiLength = phiLength || 2 * Math.PI;
	
		var inversePointLength = 1.0 / ( points.length - 1 );
		var inverseSegments = 1.0 / segments;
	
		for ( var i = 0, il = segments; i <= il; i ++ ) {
	
			var phi = phiStart + i * inverseSegments * phiLength;
	
			var sin = Math.sin( phi );
			var cos = Math.cos( phi );
	
			for ( var j = 0, jl = points.length; j < jl; j ++ ) {
	
				var point = points[ j ];
	
				var vertex = new THREE.Vector3();
	
				vertex.x = point.x * sin;
				vertex.y = point.y;
				vertex.z = point.x * cos;
	
				this.vertices.push( vertex );
	
			}
	
		}
	
		var np = points.length;
	
		for ( var i = 0, il = segments; i < il; i ++ ) {
	
			for ( var j = 0, jl = points.length - 1; j < jl; j ++ ) {
	
				var base = j + np * i;
				var a = base;
				var b = base + np;
				var c = base + 1 + np;
				var d = base + 1;
	
				var u0 = i * inverseSegments;
				var v0 = j * inversePointLength;
				var u1 = u0 + inverseSegments;
				var v1 = v0 + inversePointLength;
	
				this.faces.push( new THREE.Face3( a, b, d ) );
	
				this.faceVertexUvs[ 0 ].push( [
	
					new THREE.Vector2( u0, v0 ),
					new THREE.Vector2( u1, v0 ),
					new THREE.Vector2( u0, v1 )
	
				] );
	
				this.faces.push( new THREE.Face3( b, c, d ) );
	
				this.faceVertexUvs[ 0 ].push( [
	
					new THREE.Vector2( u1, v0 ),
					new THREE.Vector2( u1, v1 ),
					new THREE.Vector2( u0, v1 )
	
				] );
	
	
			}
	
		}
	
		this.mergeVertices();
		this.computeFaceNormals();
		this.computeVertexNormals();
	
	};
	
	THREE.LatheGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.LatheGeometry.prototype.constructor = THREE.LatheGeometry;
	
	// File:src/extras/geometries/PlaneGeometry.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
	 */
	
	THREE.PlaneGeometry = function ( width, height, widthSegments, heightSegments ) {
	
		THREE.Geometry.call( this );
	
		this.type = 'PlaneGeometry';
	
		this.parameters = {
			width: width,
			height: height,
			widthSegments: widthSegments,
			heightSegments: heightSegments
		};
	
		this.fromBufferGeometry( new THREE.PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );
	
	};
	
	THREE.PlaneGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.PlaneGeometry.prototype.constructor = THREE.PlaneGeometry;
	
	// File:src/extras/geometries/PlaneBufferGeometry.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
	 */
	
	THREE.PlaneBufferGeometry = function ( width, height, widthSegments, heightSegments ) {
	
		THREE.BufferGeometry.call( this );
	
		this.type = 'PlaneBufferGeometry';
	
		this.parameters = {
			width: width,
			height: height,
			widthSegments: widthSegments,
			heightSegments: heightSegments
		};
	
		var width_half = width / 2;
		var height_half = height / 2;
	
		var gridX = Math.floor( widthSegments ) || 1;
		var gridY = Math.floor( heightSegments ) || 1;
	
		var gridX1 = gridX + 1;
		var gridY1 = gridY + 1;
	
		var segment_width = width / gridX;
		var segment_height = height / gridY;
	
		var vertices = new Float32Array( gridX1 * gridY1 * 3 );
		var normals = new Float32Array( gridX1 * gridY1 * 3 );
		var uvs = new Float32Array( gridX1 * gridY1 * 2 );
	
		var offset = 0;
		var offset2 = 0;
	
		for ( var iy = 0; iy < gridY1; iy ++ ) {
	
			var y = iy * segment_height - height_half;
	
			for ( var ix = 0; ix < gridX1; ix ++ ) {
	
				var x = ix * segment_width - width_half;
	
				vertices[ offset ] = x;
				vertices[ offset + 1 ] = - y;
	
				normals[ offset + 2 ] = 1;
	
				uvs[ offset2 ] = ix / gridX;
				uvs[ offset2 + 1 ] = 1 - ( iy / gridY );
	
				offset += 3;
				offset2 += 2;
	
			}
	
		}
	
		offset = 0;
	
		var indices = new ( ( vertices.length / 3 ) > 65535 ? Uint32Array : Uint16Array )( gridX * gridY * 6 );
	
		for ( var iy = 0; iy < gridY; iy ++ ) {
	
			for ( var ix = 0; ix < gridX; ix ++ ) {
	
				var a = ix + gridX1 * iy;
				var b = ix + gridX1 * ( iy + 1 );
				var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
				var d = ( ix + 1 ) + gridX1 * iy;
	
				indices[ offset ] = a;
				indices[ offset + 1 ] = b;
				indices[ offset + 2 ] = d;
	
				indices[ offset + 3 ] = b;
				indices[ offset + 4 ] = c;
				indices[ offset + 5 ] = d;
	
				offset += 6;
	
			}
	
		}
	
		this.setIndex( new THREE.BufferAttribute( indices, 1 ) );
		this.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );
	
	};
	
	THREE.PlaneBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
	THREE.PlaneBufferGeometry.prototype.constructor = THREE.PlaneBufferGeometry;
	
	// File:src/extras/geometries/RingGeometry.js
	
	/**
	 * @author Kaleb Murphy
	 */
	
	THREE.RingGeometry = function ( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {
	
		THREE.Geometry.call( this );
	
		this.type = 'RingGeometry';
	
		this.parameters = {
			innerRadius: innerRadius,
			outerRadius: outerRadius,
			thetaSegments: thetaSegments,
			phiSegments: phiSegments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};
	
		innerRadius = innerRadius || 0;
		outerRadius = outerRadius || 50;
	
		thetaStart = thetaStart !== undefined ? thetaStart : 0;
		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
	
		thetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;
		phiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 8;
	
		var i, o, uvs = [], radius = innerRadius, radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );
	
		for ( i = 0; i < phiSegments + 1; i ++ ) {
	
			// concentric circles inside ring
	
			for ( o = 0; o < thetaSegments + 1; o ++ ) {
	
				// number of segments per circle
	
				var vertex = new THREE.Vector3();
				var segment = thetaStart + o / thetaSegments * thetaLength;
				vertex.x = radius * Math.cos( segment );
				vertex.y = radius * Math.sin( segment );
	
				this.vertices.push( vertex );
				uvs.push( new THREE.Vector2( ( vertex.x / outerRadius + 1 ) / 2, ( vertex.y / outerRadius + 1 ) / 2 ) );
	
			}
	
			radius += radiusStep;
	
		}
	
		var n = new THREE.Vector3( 0, 0, 1 );
	
		for ( i = 0; i < phiSegments; i ++ ) {
	
			// concentric circles inside ring
	
			var thetaSegment = i * ( thetaSegments + 1 );
	
			for ( o = 0; o < thetaSegments ; o ++ ) {
	
				// number of segments per circle
	
				var segment = o + thetaSegment;
	
				var v1 = segment;
				var v2 = segment + thetaSegments + 1;
				var v3 = segment + thetaSegments + 2;
	
				this.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );
				this.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ] );
	
				v1 = segment;
				v2 = segment + thetaSegments + 2;
				v3 = segment + 1;
	
				this.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );
				this.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ] );
	
			}
	
		}
	
		this.computeFaceNormals();
	
		this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );
	
	};
	
	THREE.RingGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.RingGeometry.prototype.constructor = THREE.RingGeometry;
	
	// File:src/extras/geometries/SphereGeometry.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.SphereGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {
	
		THREE.Geometry.call( this );
	
		this.type = 'SphereGeometry';
	
		this.parameters = {
			radius: radius,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			phiStart: phiStart,
			phiLength: phiLength,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};
	
		this.fromBufferGeometry( new THREE.SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );
	
	};
	
	THREE.SphereGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.SphereGeometry.prototype.constructor = THREE.SphereGeometry;
	
	// File:src/extras/geometries/SphereBufferGeometry.js
	
	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 * based on THREE.SphereGeometry
	 */
	
	THREE.SphereBufferGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {
	
		THREE.BufferGeometry.call( this );
	
		this.type = 'SphereBufferGeometry';
	
		this.parameters = {
			radius: radius,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			phiStart: phiStart,
			phiLength: phiLength,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};
	
		radius = radius || 50;
	
		widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );
		heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );
	
		phiStart = phiStart !== undefined ? phiStart : 0;
		phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;
	
		thetaStart = thetaStart !== undefined ? thetaStart : 0;
		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;
	
		var thetaEnd = thetaStart + thetaLength;
	
		var vertexCount = ( ( widthSegments + 1 ) * ( heightSegments + 1 ) );
	
		var positions = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
		var normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
		var uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );
	
		var index = 0, vertices = [], normal = new THREE.Vector3();
	
		for ( var y = 0; y <= heightSegments; y ++ ) {
	
			var verticesRow = [];
	
			var v = y / heightSegments;
	
			for ( var x = 0; x <= widthSegments; x ++ ) {
	
				var u = x / widthSegments;
	
				var px = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
				var py = radius * Math.cos( thetaStart + v * thetaLength );
				var pz = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
	
				normal.set( px, py, pz ).normalize();
	
				positions.setXYZ( index, px, py, pz );
				normals.setXYZ( index, normal.x, normal.y, normal.z );
				uvs.setXY( index, u, 1 - v );
	
				verticesRow.push( index );
	
				index ++;
	
			}
	
			vertices.push( verticesRow );
	
		}
	
		var indices = [];
	
		for ( var y = 0; y < heightSegments; y ++ ) {
	
			for ( var x = 0; x < widthSegments; x ++ ) {
	
				var v1 = vertices[ y ][ x + 1 ];
				var v2 = vertices[ y ][ x ];
				var v3 = vertices[ y + 1 ][ x ];
				var v4 = vertices[ y + 1 ][ x + 1 ];
	
				if ( y !== 0 || thetaStart > 0 ) indices.push( v1, v2, v4 );
				if ( y !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( v2, v3, v4 );
	
			}
	
		}
	
		this.setIndex( new ( positions.count > 65535 ? THREE.Uint32Attribute : THREE.Uint16Attribute )( indices, 1 ) );
		this.addAttribute( 'position', positions );
		this.addAttribute( 'normal', normals );
		this.addAttribute( 'uv', uvs );
	
		this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );
	
	};
	
	THREE.SphereBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
	THREE.SphereBufferGeometry.prototype.constructor = THREE.SphereBufferGeometry;
	
	// File:src/extras/geometries/TextGeometry.js
	
	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * Text = 3D Text
	 *
	 * parameters = {
	 *  font: <THREE.Font>, // font
	 *
	 *  size: <float>, // size of the text
	 *  height: <float>, // thickness to extrude text
	 *  curveSegments: <int>, // number of points on the curves
	 *
	 *  bevelEnabled: <bool>, // turn on bevel
	 *  bevelThickness: <float>, // how deep into text bevel goes
	 *  bevelSize: <float> // how far from text outline is bevel
	 * }
	 */
	
	THREE.TextGeometry = function ( text, parameters ) {
	
		parameters = parameters || {};
	
		var font = parameters.font;
	
		if ( font instanceof THREE.Font === false ) {
	
			console.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' );
			return new THREE.Geometry();
	
		}
	
		var shapes = font.generateShapes( text, parameters.size, parameters.curveSegments );
	
		// translate parameters to ExtrudeGeometry API
	
		parameters.amount = parameters.height !== undefined ? parameters.height : 50;
	
		// defaults
	
		if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;
		if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;
		if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;
	
		THREE.ExtrudeGeometry.call( this, shapes, parameters );
	
		this.type = 'TextGeometry';
	
	};
	
	THREE.TextGeometry.prototype = Object.create( THREE.ExtrudeGeometry.prototype );
	THREE.TextGeometry.prototype.constructor = THREE.TextGeometry;
	
	// File:src/extras/geometries/TorusGeometry.js
	
	/**
	 * @author oosmoxiecode
	 * @author mrdoob / http://mrdoob.com/
	 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888
	 */
	
	THREE.TorusGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {
	
		THREE.Geometry.call( this );
	
		this.type = 'TorusGeometry';
	
		this.parameters = {
			radius: radius,
			tube: tube,
			radialSegments: radialSegments,
			tubularSegments: tubularSegments,
			arc: arc
		};
	
		radius = radius || 100;
		tube = tube || 40;
		radialSegments = radialSegments || 8;
		tubularSegments = tubularSegments || 6;
		arc = arc || Math.PI * 2;
	
		var center = new THREE.Vector3(), uvs = [], normals = [];
	
		for ( var j = 0; j <= radialSegments; j ++ ) {
	
			for ( var i = 0; i <= tubularSegments; i ++ ) {
	
				var u = i / tubularSegments * arc;
				var v = j / radialSegments * Math.PI * 2;
	
				center.x = radius * Math.cos( u );
				center.y = radius * Math.sin( u );
	
				var vertex = new THREE.Vector3();
				vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
				vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
				vertex.z = tube * Math.sin( v );
	
				this.vertices.push( vertex );
	
				uvs.push( new THREE.Vector2( i / tubularSegments, j / radialSegments ) );
				normals.push( vertex.clone().sub( center ).normalize() );
	
			}
	
		}
	
		for ( var j = 1; j <= radialSegments; j ++ ) {
	
			for ( var i = 1; i <= tubularSegments; i ++ ) {
	
				var a = ( tubularSegments + 1 ) * j + i - 1;
				var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
				var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
				var d = ( tubularSegments + 1 ) * j + i;
	
				var face = new THREE.Face3( a, b, d, [ normals[ a ].clone(), normals[ b ].clone(), normals[ d ].clone() ] );
				this.faces.push( face );
				this.faceVertexUvs[ 0 ].push( [ uvs[ a ].clone(), uvs[ b ].clone(), uvs[ d ].clone() ] );
	
				face = new THREE.Face3( b, c, d, [ normals[ b ].clone(), normals[ c ].clone(), normals[ d ].clone() ] );
				this.faces.push( face );
				this.faceVertexUvs[ 0 ].push( [ uvs[ b ].clone(), uvs[ c ].clone(), uvs[ d ].clone() ] );
	
			}
	
		}
	
		this.computeFaceNormals();
	
	};
	
	THREE.TorusGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.TorusGeometry.prototype.constructor = THREE.TorusGeometry;
	
	// File:src/extras/geometries/TorusKnotGeometry.js
	
	/**
	 * @author oosmoxiecode
	 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473
	 */
	
	THREE.TorusKnotGeometry = function ( radius, tube, radialSegments, tubularSegments, p, q, heightScale ) {
	
		THREE.Geometry.call( this );
	
		this.type = 'TorusKnotGeometry';
	
		this.parameters = {
			radius: radius,
			tube: tube,
			radialSegments: radialSegments,
			tubularSegments: tubularSegments,
			p: p,
			q: q,
			heightScale: heightScale
		};
	
		radius = radius || 100;
		tube = tube || 40;
		radialSegments = radialSegments || 64;
		tubularSegments = tubularSegments || 8;
		p = p || 2;
		q = q || 3;
		heightScale = heightScale || 1;
	
		var grid = new Array( radialSegments );
		var tang = new THREE.Vector3();
		var n = new THREE.Vector3();
		var bitan = new THREE.Vector3();
	
		for ( var i = 0; i < radialSegments; ++ i ) {
	
			grid[ i ] = new Array( tubularSegments );
			var u = i / radialSegments * 2 * p * Math.PI;
			var p1 = getPos( u, q, p, radius, heightScale );
			var p2 = getPos( u + 0.01, q, p, radius, heightScale );
			tang.subVectors( p2, p1 );
			n.addVectors( p2, p1 );
	
			bitan.crossVectors( tang, n );
			n.crossVectors( bitan, tang );
			bitan.normalize();
			n.normalize();
	
			for ( var j = 0; j < tubularSegments; ++ j ) {
	
				var v = j / tubularSegments * 2 * Math.PI;
				var cx = - tube * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.
				var cy = tube * Math.sin( v );
	
				var pos = new THREE.Vector3();
				pos.x = p1.x + cx * n.x + cy * bitan.x;
				pos.y = p1.y + cx * n.y + cy * bitan.y;
				pos.z = p1.z + cx * n.z + cy * bitan.z;
	
				grid[ i ][ j ] = this.vertices.push( pos ) - 1;
	
			}
	
		}
	
		for ( var i = 0; i < radialSegments; ++ i ) {
	
			for ( var j = 0; j < tubularSegments; ++ j ) {
	
				var ip = ( i + 1 ) % radialSegments;
				var jp = ( j + 1 ) % tubularSegments;
	
				var a = grid[ i ][ j ];
				var b = grid[ ip ][ j ];
				var c = grid[ ip ][ jp ];
				var d = grid[ i ][ jp ];
	
				var uva = new THREE.Vector2( i / radialSegments, j / tubularSegments );
				var uvb = new THREE.Vector2( ( i + 1 ) / radialSegments, j / tubularSegments );
				var uvc = new THREE.Vector2( ( i + 1 ) / radialSegments, ( j + 1 ) / tubularSegments );
				var uvd = new THREE.Vector2( i / radialSegments, ( j + 1 ) / tubularSegments );
	
				this.faces.push( new THREE.Face3( a, b, d ) );
				this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );
	
				this.faces.push( new THREE.Face3( b, c, d ) );
				this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );
	
			}
	
		}
	
		this.computeFaceNormals();
		this.computeVertexNormals();
	
		function getPos( u, in_q, in_p, radius, heightScale ) {
	
			var cu = Math.cos( u );
			var su = Math.sin( u );
			var quOverP = in_q / in_p * u;
			var cs = Math.cos( quOverP );
	
			var tx = radius * ( 2 + cs ) * 0.5 * cu;
			var ty = radius * ( 2 + cs ) * su * 0.5;
			var tz = heightScale * radius * Math.sin( quOverP ) * 0.5;
	
			return new THREE.Vector3( tx, ty, tz );
	
		}
	
	};
	
	THREE.TorusKnotGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.TorusKnotGeometry.prototype.constructor = THREE.TorusKnotGeometry;
	
	// File:src/extras/geometries/TubeGeometry.js
	
	/**
	 * @author WestLangley / https://github.com/WestLangley
	 * @author zz85 / https://github.com/zz85
	 * @author miningold / https://github.com/miningold
	 * @author jonobr1 / https://github.com/jonobr1
	 *
	 * Modified from the TorusKnotGeometry by @oosmoxiecode
	 *
	 * Creates a tube which extrudes along a 3d spline
	 *
	 * Uses parallel transport frames as described in
	 * http://www.cs.indiana.edu/pub/techreports/TR425.pdf
	 */
	
	THREE.TubeGeometry = function ( path, segments, radius, radialSegments, closed, taper ) {
	
		THREE.Geometry.call( this );
	
		this.type = 'TubeGeometry';
	
		this.parameters = {
			path: path,
			segments: segments,
			radius: radius,
			radialSegments: radialSegments,
			closed: closed,
			taper: taper
		};
	
		segments = segments || 64;
		radius = radius || 1;
		radialSegments = radialSegments || 8;
		closed = closed || false;
		taper = taper || THREE.TubeGeometry.NoTaper;
	
		var grid = [];
	
		var scope = this,
	
			tangent,
			normal,
			binormal,
	
			numpoints = segments + 1,
	
			u, v, r,
	
			cx, cy,
			pos, pos2 = new THREE.Vector3(),
			i, j,
			ip, jp,
			a, b, c, d,
			uva, uvb, uvc, uvd;
	
		var frames = new THREE.TubeGeometry.FrenetFrames( path, segments, closed ),
			tangents = frames.tangents,
			normals = frames.normals,
			binormals = frames.binormals;
	
		// proxy internals
		this.tangents = tangents;
		this.normals = normals;
		this.binormals = binormals;
	
		function vert( x, y, z ) {
	
			return scope.vertices.push( new THREE.Vector3( x, y, z ) ) - 1;
	
		}
	
		// construct the grid
	
		for ( i = 0; i < numpoints; i ++ ) {
	
			grid[ i ] = [];
	
			u = i / ( numpoints - 1 );
	
			pos = path.getPointAt( u );
	
			tangent = tangents[ i ];
			normal = normals[ i ];
			binormal = binormals[ i ];
	
			r = radius * taper( u );
	
			for ( j = 0; j < radialSegments; j ++ ) {
	
				v = j / radialSegments * 2 * Math.PI;
	
				cx = - r * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.
				cy = r * Math.sin( v );
	
				pos2.copy( pos );
				pos2.x += cx * normal.x + cy * binormal.x;
				pos2.y += cx * normal.y + cy * binormal.y;
				pos2.z += cx * normal.z + cy * binormal.z;
	
				grid[ i ][ j ] = vert( pos2.x, pos2.y, pos2.z );
	
			}
	
		}
	
	
		// construct the mesh
	
		for ( i = 0; i < segments; i ++ ) {
	
			for ( j = 0; j < radialSegments; j ++ ) {
	
				ip = ( closed ) ? ( i + 1 ) % segments : i + 1;
				jp = ( j + 1 ) % radialSegments;
	
				a = grid[ i ][ j ];		// *** NOT NECESSARILY PLANAR ! ***
				b = grid[ ip ][ j ];
				c = grid[ ip ][ jp ];
				d = grid[ i ][ jp ];
	
				uva = new THREE.Vector2( i / segments, j / radialSegments );
				uvb = new THREE.Vector2( ( i + 1 ) / segments, j / radialSegments );
				uvc = new THREE.Vector2( ( i + 1 ) / segments, ( j + 1 ) / radialSegments );
				uvd = new THREE.Vector2( i / segments, ( j + 1 ) / radialSegments );
	
				this.faces.push( new THREE.Face3( a, b, d ) );
				this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );
	
				this.faces.push( new THREE.Face3( b, c, d ) );
				this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );
	
			}
	
		}
	
		this.computeFaceNormals();
		this.computeVertexNormals();
	
	};
	
	THREE.TubeGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.TubeGeometry.prototype.constructor = THREE.TubeGeometry;
	
	THREE.TubeGeometry.NoTaper = function ( u ) {
	
		return 1;
	
	};
	
	THREE.TubeGeometry.SinusoidalTaper = function ( u ) {
	
		return Math.sin( Math.PI * u );
	
	};
	
	// For computing of Frenet frames, exposing the tangents, normals and binormals the spline
	THREE.TubeGeometry.FrenetFrames = function ( path, segments, closed ) {
	
		var	normal = new THREE.Vector3(),
	
			tangents = [],
			normals = [],
			binormals = [],
	
			vec = new THREE.Vector3(),
			mat = new THREE.Matrix4(),
	
			numpoints = segments + 1,
			theta,
			smallest,
	
			tx, ty, tz,
			i, u;
	
	
		// expose internals
		this.tangents = tangents;
		this.normals = normals;
		this.binormals = binormals;
	
		// compute the tangent vectors for each segment on the path
	
		for ( i = 0; i < numpoints; i ++ ) {
	
			u = i / ( numpoints - 1 );
	
			tangents[ i ] = path.getTangentAt( u );
			tangents[ i ].normalize();
	
		}
	
		initialNormal3();
	
		/*
		function initialNormal1(lastBinormal) {
			// fixed start binormal. Has dangers of 0 vectors
			normals[ 0 ] = new THREE.Vector3();
			binormals[ 0 ] = new THREE.Vector3();
			if (lastBinormal===undefined) lastBinormal = new THREE.Vector3( 0, 0, 1 );
			normals[ 0 ].crossVectors( lastBinormal, tangents[ 0 ] ).normalize();
			binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();
		}
	
		function initialNormal2() {
	
			// This uses the Frenet-Serret formula for deriving binormal
			var t2 = path.getTangentAt( epsilon );
	
			normals[ 0 ] = new THREE.Vector3().subVectors( t2, tangents[ 0 ] ).normalize();
			binormals[ 0 ] = new THREE.Vector3().crossVectors( tangents[ 0 ], normals[ 0 ] );
	
			normals[ 0 ].crossVectors( binormals[ 0 ], tangents[ 0 ] ).normalize(); // last binormal x tangent
			binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();
	
		}
		*/
	
		function initialNormal3() {
	
			// select an initial normal vector perpendicular to the first tangent vector,
			// and in the direction of the smallest tangent xyz component
	
			normals[ 0 ] = new THREE.Vector3();
			binormals[ 0 ] = new THREE.Vector3();
			smallest = Number.MAX_VALUE;
			tx = Math.abs( tangents[ 0 ].x );
			ty = Math.abs( tangents[ 0 ].y );
			tz = Math.abs( tangents[ 0 ].z );
	
			if ( tx <= smallest ) {
	
				smallest = tx;
				normal.set( 1, 0, 0 );
	
			}
	
			if ( ty <= smallest ) {
	
				smallest = ty;
				normal.set( 0, 1, 0 );
	
			}
	
			if ( tz <= smallest ) {
	
				normal.set( 0, 0, 1 );
	
			}
	
			vec.crossVectors( tangents[ 0 ], normal ).normalize();
	
			normals[ 0 ].crossVectors( tangents[ 0 ], vec );
			binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );
	
		}
	
	
		// compute the slowly-varying normal and binormal vectors for each segment on the path
	
		for ( i = 1; i < numpoints; i ++ ) {
	
			normals[ i ] = normals[ i - 1 ].clone();
	
			binormals[ i ] = binormals[ i - 1 ].clone();
	
			vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );
	
			if ( vec.length() > Number.EPSILON ) {
	
				vec.normalize();
	
				theta = Math.acos( THREE.Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors
	
				normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );
	
			}
	
			binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );
	
		}
	
	
		// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same
	
		if ( closed ) {
	
			theta = Math.acos( THREE.Math.clamp( normals[ 0 ].dot( normals[ numpoints - 1 ] ), - 1, 1 ) );
			theta /= ( numpoints - 1 );
	
			if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ numpoints - 1 ] ) ) > 0 ) {
	
				theta = - theta;
	
			}
	
			for ( i = 1; i < numpoints; i ++ ) {
	
				// twist a little...
				normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
				binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );
	
			}
	
		}
	
	};
	
	// File:src/extras/geometries/PolyhedronGeometry.js
	
	/**
	 * @author clockworkgeek / https://github.com/clockworkgeek
	 * @author timothypratley / https://github.com/timothypratley
	 * @author WestLangley / http://github.com/WestLangley
	*/
	
	THREE.PolyhedronGeometry = function ( vertices, indices, radius, detail ) {
	
		THREE.Geometry.call( this );
	
		this.type = 'PolyhedronGeometry';
	
		this.parameters = {
			vertices: vertices,
			indices: indices,
			radius: radius,
			detail: detail
		};
	
		radius = radius || 1;
		detail = detail || 0;
	
		var that = this;
	
		for ( var i = 0, l = vertices.length; i < l; i += 3 ) {
	
			prepare( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );
	
		}
	
		var p = this.vertices;
	
		var faces = [];
	
		for ( var i = 0, j = 0, l = indices.length; i < l; i += 3, j ++ ) {
	
			var v1 = p[ indices[ i ] ];
			var v2 = p[ indices[ i + 1 ] ];
			var v3 = p[ indices[ i + 2 ] ];
	
			faces[ j ] = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ], undefined, j );
	
		}
	
		var centroid = new THREE.Vector3();
	
		for ( var i = 0, l = faces.length; i < l; i ++ ) {
	
			subdivide( faces[ i ], detail );
	
		}
	
	
		// Handle case when face straddles the seam
	
		for ( var i = 0, l = this.faceVertexUvs[ 0 ].length; i < l; i ++ ) {
	
			var uvs = this.faceVertexUvs[ 0 ][ i ];
	
			var x0 = uvs[ 0 ].x;
			var x1 = uvs[ 1 ].x;
			var x2 = uvs[ 2 ].x;
	
			var max = Math.max( x0, x1, x2 );
			var min = Math.min( x0, x1, x2 );
	
			if ( max > 0.9 && min < 0.1 ) {
	
				// 0.9 is somewhat arbitrary
	
				if ( x0 < 0.2 ) uvs[ 0 ].x += 1;
				if ( x1 < 0.2 ) uvs[ 1 ].x += 1;
				if ( x2 < 0.2 ) uvs[ 2 ].x += 1;
	
			}
	
		}
	
	
		// Apply radius
	
		for ( var i = 0, l = this.vertices.length; i < l; i ++ ) {
	
			this.vertices[ i ].multiplyScalar( radius );
	
		}
	
	
		// Merge vertices
	
		this.mergeVertices();
	
		this.computeFaceNormals();
	
		this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );
	
	
		// Project vector onto sphere's surface
	
		function prepare( vector ) {
	
			var vertex = vector.normalize().clone();
			vertex.index = that.vertices.push( vertex ) - 1;
	
			// Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.
	
			var u = azimuth( vector ) / 2 / Math.PI + 0.5;
			var v = inclination( vector ) / Math.PI + 0.5;
			vertex.uv = new THREE.Vector2( u, 1 - v );
	
			return vertex;
	
		}
	
	
		// Approximate a curved face with recursively sub-divided triangles.
	
		function make( v1, v2, v3, materialIndex ) {
	
			var face = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ], undefined, materialIndex );
			that.faces.push( face );
	
			centroid.copy( v1 ).add( v2 ).add( v3 ).divideScalar( 3 );
	
			var azi = azimuth( centroid );
	
			that.faceVertexUvs[ 0 ].push( [
				correctUV( v1.uv, v1, azi ),
				correctUV( v2.uv, v2, azi ),
				correctUV( v3.uv, v3, azi )
			] );
	
		}
	
	
		// Analytically subdivide a face to the required detail level.
	
		function subdivide( face, detail ) {
	
			var cols = Math.pow( 2, detail );
			var a = prepare( that.vertices[ face.a ] );
			var b = prepare( that.vertices[ face.b ] );
			var c = prepare( that.vertices[ face.c ] );
			var v = [];
	
			var materialIndex = face.materialIndex;
	
			// Construct all of the vertices for this subdivision.
	
			for ( var i = 0 ; i <= cols; i ++ ) {
	
				v[ i ] = [];
	
				var aj = prepare( a.clone().lerp( c, i / cols ) );
				var bj = prepare( b.clone().lerp( c, i / cols ) );
				var rows = cols - i;
	
				for ( var j = 0; j <= rows; j ++ ) {
	
					if ( j === 0 && i === cols ) {
	
						v[ i ][ j ] = aj;
	
					} else {
	
						v[ i ][ j ] = prepare( aj.clone().lerp( bj, j / rows ) );
	
					}
	
				}
	
			}
	
			// Construct all of the faces.
	
			for ( var i = 0; i < cols ; i ++ ) {
	
				for ( var j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {
	
					var k = Math.floor( j / 2 );
	
					if ( j % 2 === 0 ) {
	
						make(
							v[ i ][ k + 1 ],
							v[ i + 1 ][ k ],
							v[ i ][ k ],
							materialIndex
						);
	
					} else {
	
						make(
							v[ i ][ k + 1 ],
							v[ i + 1 ][ k + 1 ],
							v[ i + 1 ][ k ],
							materialIndex
						);
	
					}
	
				}
	
			}
	
		}
	
	
		// Angle around the Y axis, counter-clockwise when looking from above.
	
		function azimuth( vector ) {
	
			return Math.atan2( vector.z, - vector.x );
	
		}
	
	
		// Angle above the XZ plane.
	
		function inclination( vector ) {
	
			return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );
	
		}
	
	
		// Texture fixing helper. Spheres have some odd behaviours.
	
		function correctUV( uv, vector, azimuth ) {
	
			if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) uv = new THREE.Vector2( uv.x - 1, uv.y );
			if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) uv = new THREE.Vector2( azimuth / 2 / Math.PI + 0.5, uv.y );
			return uv.clone();
	
		}
	
	
	};
	
	THREE.PolyhedronGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.PolyhedronGeometry.prototype.constructor = THREE.PolyhedronGeometry;
	
	// File:src/extras/geometries/DodecahedronGeometry.js
	
	/**
	 * @author Abe Pazos / https://hamoid.com
	 */
	
	THREE.DodecahedronGeometry = function ( radius, detail ) {
	
		var t = ( 1 + Math.sqrt( 5 ) ) / 2;
		var r = 1 / t;
	
		var vertices = [
	
			// (±1, ±1, ±1)
			- 1, - 1, - 1,    - 1, - 1,  1,
			- 1,  1, - 1,    - 1,  1,  1,
			 1, - 1, - 1,     1, - 1,  1,
			 1,  1, - 1,     1,  1,  1,
	
			// (0, ±1/φ, ±φ)
			 0, - r, - t,     0, - r,  t,
			 0,  r, - t,     0,  r,  t,
	
			// (±1/φ, ±φ, 0)
			- r, - t,  0,    - r,  t,  0,
			 r, - t,  0,     r,  t,  0,
	
			// (±φ, 0, ±1/φ)
			- t,  0, - r,     t,  0, - r,
			- t,  0,  r,     t,  0,  r
		];
	
		var indices = [
			 3, 11,  7,      3,  7, 15,      3, 15, 13,
			 7, 19, 17,      7, 17,  6,      7,  6, 15,
			17,  4,  8,     17,  8, 10,     17, 10,  6,
			 8,  0, 16,      8, 16,  2,      8,  2, 10,
			 0, 12,  1,      0,  1, 18,      0, 18, 16,
			 6, 10,  2,      6,  2, 13,      6, 13, 15,
			 2, 16, 18,      2, 18,  3,      2,  3, 13,
			18,  1,  9,     18,  9, 11,     18, 11,  3,
			 4, 14, 12,      4, 12,  0,      4,  0,  8,
			11,  9,  5,     11,  5, 19,     11, 19,  7,
			19,  5, 14,     19, 14,  4,     19,  4, 17,
			 1, 12, 14,      1, 14,  5,      1,  5,  9
		];
	
		THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );
	
		this.type = 'DodecahedronGeometry';
	
		this.parameters = {
			radius: radius,
			detail: detail
		};
	
	};
	
	THREE.DodecahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );
	THREE.DodecahedronGeometry.prototype.constructor = THREE.DodecahedronGeometry;
	
	// File:src/extras/geometries/IcosahedronGeometry.js
	
	/**
	 * @author timothypratley / https://github.com/timothypratley
	 */
	
	THREE.IcosahedronGeometry = function ( radius, detail ) {
	
		var t = ( 1 + Math.sqrt( 5 ) ) / 2;
	
		var vertices = [
			- 1,  t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,
			 0, - 1,  t,    0,  1,  t,    0, - 1, - t,    0,  1, - t,
			 t,  0, - 1,    t,  0,  1,   - t,  0, - 1,   - t,  0,  1
		];
	
		var indices = [
			 0, 11,  5,    0,  5,  1,    0,  1,  7,    0,  7, 10,    0, 10, 11,
			 1,  5,  9,    5, 11,  4,   11, 10,  2,   10,  7,  6,    7,  1,  8,
			 3,  9,  4,    3,  4,  2,    3,  2,  6,    3,  6,  8,    3,  8,  9,
			 4,  9,  5,    2,  4, 11,    6,  2, 10,    8,  6,  7,    9,  8,  1
		];
	
		THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );
	
		this.type = 'IcosahedronGeometry';
	
		this.parameters = {
			radius: radius,
			detail: detail
		};
	
	};
	
	THREE.IcosahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );
	THREE.IcosahedronGeometry.prototype.constructor = THREE.IcosahedronGeometry;
	
	// File:src/extras/geometries/OctahedronGeometry.js
	
	/**
	 * @author timothypratley / https://github.com/timothypratley
	 */
	
	THREE.OctahedronGeometry = function ( radius, detail ) {
	
		var vertices = [
			1, 0, 0,   - 1, 0, 0,    0, 1, 0,    0, - 1, 0,    0, 0, 1,    0, 0, - 1
		];
	
		var indices = [
			0, 2, 4,    0, 4, 3,    0, 3, 5,    0, 5, 2,    1, 2, 5,    1, 5, 3,    1, 3, 4,    1, 4, 2
		];
	
		THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );
	
		this.type = 'OctahedronGeometry';
	
		this.parameters = {
			radius: radius,
			detail: detail
		};
	
	};
	
	THREE.OctahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );
	THREE.OctahedronGeometry.prototype.constructor = THREE.OctahedronGeometry;
	
	// File:src/extras/geometries/TetrahedronGeometry.js
	
	/**
	 * @author timothypratley / https://github.com/timothypratley
	 */
	
	THREE.TetrahedronGeometry = function ( radius, detail ) {
	
		var vertices = [
			 1,  1,  1,   - 1, - 1,  1,   - 1,  1, - 1,    1, - 1, - 1
		];
	
		var indices = [
			 2,  1,  0,    0,  3,  2,    1,  3,  0,    2,  3,  1
		];
	
		THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );
	
		this.type = 'TetrahedronGeometry';
	
		this.parameters = {
			radius: radius,
			detail: detail
		};
	
	};
	
	THREE.TetrahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );
	THREE.TetrahedronGeometry.prototype.constructor = THREE.TetrahedronGeometry;
	
	// File:src/extras/geometries/ParametricGeometry.js
	
	/**
	 * @author zz85 / https://github.com/zz85
	 * Parametric Surfaces Geometry
	 * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
	 *
	 * new THREE.ParametricGeometry( parametricFunction, uSegments, ySegements );
	 *
	 */
	
	THREE.ParametricGeometry = function ( func, slices, stacks ) {
	
		THREE.Geometry.call( this );
	
		this.type = 'ParametricGeometry';
	
		this.parameters = {
			func: func,
			slices: slices,
			stacks: stacks
		};
	
		var verts = this.vertices;
		var faces = this.faces;
		var uvs = this.faceVertexUvs[ 0 ];
	
		var i, j, p;
		var u, v;
	
		var sliceCount = slices + 1;
	
		for ( i = 0; i <= stacks; i ++ ) {
	
			v = i / stacks;
	
			for ( j = 0; j <= slices; j ++ ) {
	
				u = j / slices;
	
				p = func( u, v );
				verts.push( p );
	
			}
	
		}
	
		var a, b, c, d;
		var uva, uvb, uvc, uvd;
	
		for ( i = 0; i < stacks; i ++ ) {
	
			for ( j = 0; j < slices; j ++ ) {
	
				a = i * sliceCount + j;
				b = i * sliceCount + j + 1;
				c = ( i + 1 ) * sliceCount + j + 1;
				d = ( i + 1 ) * sliceCount + j;
	
				uva = new THREE.Vector2( j / slices, i / stacks );
				uvb = new THREE.Vector2( ( j + 1 ) / slices, i / stacks );
				uvc = new THREE.Vector2( ( j + 1 ) / slices, ( i + 1 ) / stacks );
				uvd = new THREE.Vector2( j / slices, ( i + 1 ) / stacks );
	
				faces.push( new THREE.Face3( a, b, d ) );
				uvs.push( [ uva, uvb, uvd ] );
	
				faces.push( new THREE.Face3( b, c, d ) );
				uvs.push( [ uvb.clone(), uvc, uvd.clone() ] );
	
			}
	
		}
	
		// console.log(this);
	
		// magic bullet
		// var diff = this.mergeVertices();
		// console.log('removed ', diff, ' vertices by merging');
	
		this.computeFaceNormals();
		this.computeVertexNormals();
	
	};
	
	THREE.ParametricGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.ParametricGeometry.prototype.constructor = THREE.ParametricGeometry;
	
	// File:src/extras/geometries/WireframeGeometry.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.WireframeGeometry = function ( geometry ) {
	
		THREE.BufferGeometry.call( this );
	
		var edge = [ 0, 0 ], hash = {};
	
		function sortFunction( a, b ) {
	
			return a - b;
	
		}
	
		var keys = [ 'a', 'b', 'c' ];
	
		if ( geometry instanceof THREE.Geometry ) {
	
			var vertices = geometry.vertices;
			var faces = geometry.faces;
			var numEdges = 0;
	
			// allocate maximal size
			var edges = new Uint32Array( 6 * faces.length );
	
			for ( var i = 0, l = faces.length; i < l; i ++ ) {
	
				var face = faces[ i ];
	
				for ( var j = 0; j < 3; j ++ ) {
	
					edge[ 0 ] = face[ keys[ j ] ];
					edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
					edge.sort( sortFunction );
	
					var key = edge.toString();
	
					if ( hash[ key ] === undefined ) {
	
						edges[ 2 * numEdges ] = edge[ 0 ];
						edges[ 2 * numEdges + 1 ] = edge[ 1 ];
						hash[ key ] = true;
						numEdges ++;
	
					}
	
				}
	
			}
	
			var coords = new Float32Array( numEdges * 2 * 3 );
	
			for ( var i = 0, l = numEdges; i < l; i ++ ) {
	
				for ( var j = 0; j < 2; j ++ ) {
	
					var vertex = vertices[ edges [ 2 * i + j ] ];
	
					var index = 6 * i + 3 * j;
					coords[ index + 0 ] = vertex.x;
					coords[ index + 1 ] = vertex.y;
					coords[ index + 2 ] = vertex.z;
	
				}
	
			}
	
			this.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );
	
		} else if ( geometry instanceof THREE.BufferGeometry ) {
	
			if ( geometry.index !== null ) {
	
				// Indexed BufferGeometry
	
				var indices = geometry.index.array;
				var vertices = geometry.attributes.position;
				var groups = geometry.groups;
				var numEdges = 0;
	
				if ( groups.length === 0 ) {
	
					geometry.addGroup( 0, indices.length );
	
				}
	
				// allocate maximal size
				var edges = new Uint32Array( 2 * indices.length );
	
				for ( var o = 0, ol = groups.length; o < ol; ++ o ) {
	
					var group = groups[ o ];
	
					var start = group.start;
					var count = group.count;
	
					for ( var i = start, il = start + count; i < il; i += 3 ) {
	
						for ( var j = 0; j < 3; j ++ ) {
	
							edge[ 0 ] = indices[ i + j ];
							edge[ 1 ] = indices[ i + ( j + 1 ) % 3 ];
							edge.sort( sortFunction );
	
							var key = edge.toString();
	
							if ( hash[ key ] === undefined ) {
	
								edges[ 2 * numEdges ] = edge[ 0 ];
								edges[ 2 * numEdges + 1 ] = edge[ 1 ];
								hash[ key ] = true;
								numEdges ++;
	
							}
	
						}
	
					}
	
				}
	
				var coords = new Float32Array( numEdges * 2 * 3 );
	
				for ( var i = 0, l = numEdges; i < l; i ++ ) {
	
					for ( var j = 0; j < 2; j ++ ) {
	
						var index = 6 * i + 3 * j;
						var index2 = edges[ 2 * i + j ];
	
						coords[ index + 0 ] = vertices.getX( index2 );
						coords[ index + 1 ] = vertices.getY( index2 );
						coords[ index + 2 ] = vertices.getZ( index2 );
	
					}
	
				}
	
				this.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );
	
			} else {
	
				// non-indexed BufferGeometry
	
				var vertices = geometry.attributes.position.array;
				var numEdges = vertices.length / 3;
				var numTris = numEdges / 3;
	
				var coords = new Float32Array( numEdges * 2 * 3 );
	
				for ( var i = 0, l = numTris; i < l; i ++ ) {
	
					for ( var j = 0; j < 3; j ++ ) {
	
						var index = 18 * i + 6 * j;
	
						var index1 = 9 * i + 3 * j;
						coords[ index + 0 ] = vertices[ index1 ];
						coords[ index + 1 ] = vertices[ index1 + 1 ];
						coords[ index + 2 ] = vertices[ index1 + 2 ];
	
						var index2 = 9 * i + 3 * ( ( j + 1 ) % 3 );
						coords[ index + 3 ] = vertices[ index2 ];
						coords[ index + 4 ] = vertices[ index2 + 1 ];
						coords[ index + 5 ] = vertices[ index2 + 2 ];
	
					}
	
				}
	
				this.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );
	
			}
	
		}
	
	};
	
	THREE.WireframeGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
	THREE.WireframeGeometry.prototype.constructor = THREE.WireframeGeometry;
	
	// File:src/extras/helpers/AxisHelper.js
	
	/**
	 * @author sroucheray / http://sroucheray.org/
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.AxisHelper = function ( size ) {
	
		size = size || 1;
	
		var vertices = new Float32Array( [
			0, 0, 0,  size, 0, 0,
			0, 0, 0,  0, size, 0,
			0, 0, 0,  0, 0, size
		] );
	
		var colors = new Float32Array( [
			1, 0, 0,  1, 0.6, 0,
			0, 1, 0,  0.6, 1, 0,
			0, 0, 1,  0, 0.6, 1
		] );
	
		var geometry = new THREE.BufferGeometry();
		geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
		geometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );
	
		var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );
	
		THREE.LineSegments.call( this, geometry, material );
	
	};
	
	THREE.AxisHelper.prototype = Object.create( THREE.LineSegments.prototype );
	THREE.AxisHelper.prototype.constructor = THREE.AxisHelper;
	
	// File:src/extras/helpers/ArrowHelper.js
	
	/**
	 * @author WestLangley / http://github.com/WestLangley
	 * @author zz85 / http://github.com/zz85
	 * @author bhouston / http://clara.io
	 *
	 * Creates an arrow for visualizing directions
	 *
	 * Parameters:
	 *  dir - Vector3
	 *  origin - Vector3
	 *  length - Number
	 *  color - color in hex value
	 *  headLength - Number
	 *  headWidth - Number
	 */
	
	THREE.ArrowHelper = ( function () {
	
		var lineGeometry = new THREE.Geometry();
		lineGeometry.vertices.push( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 1, 0 ) );
	
		var coneGeometry = new THREE.CylinderGeometry( 0, 0.5, 1, 5, 1 );
		coneGeometry.translate( 0, - 0.5, 0 );
	
		return function ArrowHelper( dir, origin, length, color, headLength, headWidth ) {
	
			// dir is assumed to be normalized
	
			THREE.Object3D.call( this );
	
			if ( color === undefined ) color = 0xffff00;
			if ( length === undefined ) length = 1;
			if ( headLength === undefined ) headLength = 0.2 * length;
			if ( headWidth === undefined ) headWidth = 0.2 * headLength;
	
			this.position.copy( origin );
			
			this.line = new THREE.Line( lineGeometry, new THREE.LineBasicMaterial( { color: color } ) );
			this.line.matrixAutoUpdate = false;
			this.add( this.line );
	
			this.cone = new THREE.Mesh( coneGeometry, new THREE.MeshBasicMaterial( { color: color } ) );
			this.cone.matrixAutoUpdate = false;
			this.add( this.cone );
	
			this.setDirection( dir );
			this.setLength( length, headLength, headWidth );
	
		}
	
	}() );
	
	THREE.ArrowHelper.prototype = Object.create( THREE.Object3D.prototype );
	THREE.ArrowHelper.prototype.constructor = THREE.ArrowHelper;
	
	THREE.ArrowHelper.prototype.setDirection = ( function () {
	
		var axis = new THREE.Vector3();
		var radians;
	
		return function setDirection( dir ) {
	
			// dir is assumed to be normalized
	
			if ( dir.y > 0.99999 ) {
	
				this.quaternion.set( 0, 0, 0, 1 );
	
			} else if ( dir.y < - 0.99999 ) {
	
				this.quaternion.set( 1, 0, 0, 0 );
	
			} else {
	
				axis.set( dir.z, 0, - dir.x ).normalize();
	
				radians = Math.acos( dir.y );
	
				this.quaternion.setFromAxisAngle( axis, radians );
	
			}
	
		};
	
	}() );
	
	THREE.ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {
	
		if ( headLength === undefined ) headLength = 0.2 * length;
		if ( headWidth === undefined ) headWidth = 0.2 * headLength;
	
		this.line.scale.set( 1, Math.max( 0, length - headLength ), 1 );
		this.line.updateMatrix();
	
		this.cone.scale.set( headWidth, headLength, headWidth );
		this.cone.position.y = length;
		this.cone.updateMatrix();
	
	};
	
	THREE.ArrowHelper.prototype.setColor = function ( color ) {
	
		this.line.material.color.set( color );
		this.cone.material.color.set( color );
	
	};
	
	// File:src/extras/helpers/BoxHelper.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.BoxHelper = function ( object ) {
	
		var indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );
		var positions = new Float32Array( 8 * 3 );
	
		var geometry = new THREE.BufferGeometry();
		geometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );
		geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
	
		THREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: 0xffff00 } ) );
	
		if ( object !== undefined ) {
	
			this.update( object );
	
		}
	
	};
	
	THREE.BoxHelper.prototype = Object.create( THREE.LineSegments.prototype );
	THREE.BoxHelper.prototype.constructor = THREE.BoxHelper;
	
	THREE.BoxHelper.prototype.update = ( function () {
	
		var box = new THREE.Box3();
	
		return function ( object ) {
	
			box.setFromObject( object );
	
			if ( box.isEmpty() ) return;
	
			var min = box.min;
			var max = box.max;
	
			/*
			  5____4
			1/___0/|
			| 6__|_7
			2/___3/
	
			0: max.x, max.y, max.z
			1: min.x, max.y, max.z
			2: min.x, min.y, max.z
			3: max.x, min.y, max.z
			4: max.x, max.y, min.z
			5: min.x, max.y, min.z
			6: min.x, min.y, min.z
			7: max.x, min.y, min.z
			*/
	
			var position = this.geometry.attributes.position;
			var array = position.array;
	
			array[  0 ] = max.x; array[  1 ] = max.y; array[  2 ] = max.z;
			array[  3 ] = min.x; array[  4 ] = max.y; array[  5 ] = max.z;
			array[  6 ] = min.x; array[  7 ] = min.y; array[  8 ] = max.z;
			array[  9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;
			array[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;
			array[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;
			array[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;
			array[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;
	
			position.needsUpdate = true;
	
			this.geometry.computeBoundingSphere();
	
		};
	
	} )();
	
	// File:src/extras/helpers/BoundingBoxHelper.js
	
	/**
	 * @author WestLangley / http://github.com/WestLangley
	 */
	
	// a helper to show the world-axis-aligned bounding box for an object
	
	THREE.BoundingBoxHelper = function ( object, hex ) {
	
		var color = ( hex !== undefined ) ? hex : 0x888888;
	
		this.object = object;
	
		this.box = new THREE.Box3();
	
		THREE.Mesh.call( this, new THREE.BoxGeometry( 1, 1, 1 ), new THREE.MeshBasicMaterial( { color: color, wireframe: true } ) );
	
	};
	
	THREE.BoundingBoxHelper.prototype = Object.create( THREE.Mesh.prototype );
	THREE.BoundingBoxHelper.prototype.constructor = THREE.BoundingBoxHelper;
	
	THREE.BoundingBoxHelper.prototype.update = function () {
	
		this.box.setFromObject( this.object );
	
		this.box.size( this.scale );
	
		this.box.center( this.position );
	
	};
	
	// File:src/extras/helpers/CameraHelper.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 *	- shows frustum, line of sight and up of the camera
	 *	- suitable for fast updates
	 * 	- based on frustum visualization in lightgl.js shadowmap example
	 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
	 */
	
	THREE.CameraHelper = function ( camera ) {
	
		var geometry = new THREE.Geometry();
		var material = new THREE.LineBasicMaterial( { color: 0xffffff, vertexColors: THREE.FaceColors } );
	
		var pointMap = {};
	
		// colors
	
		var hexFrustum = 0xffaa00;
		var hexCone = 0xff0000;
		var hexUp = 0x00aaff;
		var hexTarget = 0xffffff;
		var hexCross = 0x333333;
	
		// near
	
		addLine( "n1", "n2", hexFrustum );
		addLine( "n2", "n4", hexFrustum );
		addLine( "n4", "n3", hexFrustum );
		addLine( "n3", "n1", hexFrustum );
	
		// far
	
		addLine( "f1", "f2", hexFrustum );
		addLine( "f2", "f4", hexFrustum );
		addLine( "f4", "f3", hexFrustum );
		addLine( "f3", "f1", hexFrustum );
	
		// sides
	
		addLine( "n1", "f1", hexFrustum );
		addLine( "n2", "f2", hexFrustum );
		addLine( "n3", "f3", hexFrustum );
		addLine( "n4", "f4", hexFrustum );
	
		// cone
	
		addLine( "p", "n1", hexCone );
		addLine( "p", "n2", hexCone );
		addLine( "p", "n3", hexCone );
		addLine( "p", "n4", hexCone );
	
		// up
	
		addLine( "u1", "u2", hexUp );
		addLine( "u2", "u3", hexUp );
		addLine( "u3", "u1", hexUp );
	
		// target
	
		addLine( "c", "t", hexTarget );
		addLine( "p", "c", hexCross );
	
		// cross
	
		addLine( "cn1", "cn2", hexCross );
		addLine( "cn3", "cn4", hexCross );
	
		addLine( "cf1", "cf2", hexCross );
		addLine( "cf3", "cf4", hexCross );
	
		function addLine( a, b, hex ) {
	
			addPoint( a, hex );
			addPoint( b, hex );
	
		}
	
		function addPoint( id, hex ) {
	
			geometry.vertices.push( new THREE.Vector3() );
			geometry.colors.push( new THREE.Color( hex ) );
	
			if ( pointMap[ id ] === undefined ) {
	
				pointMap[ id ] = [];
	
			}
	
			pointMap[ id ].push( geometry.vertices.length - 1 );
	
		}
	
		THREE.LineSegments.call( this, geometry, material );
	
		this.camera = camera;
		this.camera.updateProjectionMatrix();
	
		this.matrix = camera.matrixWorld;
		this.matrixAutoUpdate = false;
	
		this.pointMap = pointMap;
	
		this.update();
	
	};
	
	THREE.CameraHelper.prototype = Object.create( THREE.LineSegments.prototype );
	THREE.CameraHelper.prototype.constructor = THREE.CameraHelper;
	
	THREE.CameraHelper.prototype.update = function () {
	
		var geometry, pointMap;
	
		var vector = new THREE.Vector3();
		var camera = new THREE.Camera();
	
		function setPoint( point, x, y, z ) {
	
			vector.set( x, y, z ).unproject( camera );
	
			var points = pointMap[ point ];
	
			if ( points !== undefined ) {
	
				for ( var i = 0, il = points.length; i < il; i ++ ) {
	
					geometry.vertices[ points[ i ] ].copy( vector );
	
				}
	
			}
	
		}
	
		return function () {
	
			geometry = this.geometry;
			pointMap = this.pointMap;
	
			var w = 1, h = 1;
	
			// we need just camera projection matrix
			// world matrix must be identity
	
			camera.projectionMatrix.copy( this.camera.projectionMatrix );
	
			// center / target
	
			setPoint( "c", 0, 0, - 1 );
			setPoint( "t", 0, 0,  1 );
	
			// near
	
			setPoint( "n1", - w, - h, - 1 );
			setPoint( "n2",   w, - h, - 1 );
			setPoint( "n3", - w,   h, - 1 );
			setPoint( "n4",   w,   h, - 1 );
	
			// far
	
			setPoint( "f1", - w, - h, 1 );
			setPoint( "f2",   w, - h, 1 );
			setPoint( "f3", - w,   h, 1 );
			setPoint( "f4",   w,   h, 1 );
	
			// up
	
			setPoint( "u1",   w * 0.7, h * 1.1, - 1 );
			setPoint( "u2", - w * 0.7, h * 1.1, - 1 );
			setPoint( "u3",         0, h * 2,   - 1 );
	
			// cross
	
			setPoint( "cf1", - w,   0, 1 );
			setPoint( "cf2",   w,   0, 1 );
			setPoint( "cf3",   0, - h, 1 );
			setPoint( "cf4",   0,   h, 1 );
	
			setPoint( "cn1", - w,   0, - 1 );
			setPoint( "cn2",   w,   0, - 1 );
			setPoint( "cn3",   0, - h, - 1 );
			setPoint( "cn4",   0,   h, - 1 );
	
			geometry.verticesNeedUpdate = true;
	
		};
	
	}();
	
	// File:src/extras/helpers/DirectionalLightHelper.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */
	
	THREE.DirectionalLightHelper = function ( light, size ) {
	
		THREE.Object3D.call( this );
	
		this.light = light;
		this.light.updateMatrixWorld();
	
		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;
	
		size = size || 1;
	
		var geometry = new THREE.Geometry();
		geometry.vertices.push(
			new THREE.Vector3( - size,   size, 0 ),
			new THREE.Vector3(   size,   size, 0 ),
			new THREE.Vector3(   size, - size, 0 ),
			new THREE.Vector3( - size, - size, 0 ),
			new THREE.Vector3( - size,   size, 0 )
		);
	
		var material = new THREE.LineBasicMaterial( { fog: false } );
		material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );
	
		this.lightPlane = new THREE.Line( geometry, material );
		this.add( this.lightPlane );
	
		geometry = new THREE.Geometry();
		geometry.vertices.push(
			new THREE.Vector3(),
			new THREE.Vector3()
		);
	
		material = new THREE.LineBasicMaterial( { fog: false } );
		material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );
	
		this.targetLine = new THREE.Line( geometry, material );
		this.add( this.targetLine );
	
		this.update();
	
	};
	
	THREE.DirectionalLightHelper.prototype = Object.create( THREE.Object3D.prototype );
	THREE.DirectionalLightHelper.prototype.constructor = THREE.DirectionalLightHelper;
	
	THREE.DirectionalLightHelper.prototype.dispose = function () {
	
		this.lightPlane.geometry.dispose();
		this.lightPlane.material.dispose();
		this.targetLine.geometry.dispose();
		this.targetLine.material.dispose();
	
	};
	
	THREE.DirectionalLightHelper.prototype.update = function () {
	
		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();
		var v3 = new THREE.Vector3();
	
		return function () {
	
			v1.setFromMatrixPosition( this.light.matrixWorld );
			v2.setFromMatrixPosition( this.light.target.matrixWorld );
			v3.subVectors( v2, v1 );
	
			this.lightPlane.lookAt( v3 );
			this.lightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );
	
			this.targetLine.geometry.vertices[ 1 ].copy( v3 );
			this.targetLine.geometry.verticesNeedUpdate = true;
			this.targetLine.material.color.copy( this.lightPlane.material.color );
	
		};
	
	}();
	
	// File:src/extras/helpers/EdgesHelper.js
	
	/**
	 * @author WestLangley / http://github.com/WestLangley
	 * @param object THREE.Mesh whose geometry will be used
	 * @param hex line color
	 * @param thresholdAngle the minimum angle (in degrees),
	 * between the face normals of adjacent faces,
	 * that is required to render an edge. A value of 10 means
	 * an edge is only rendered if the angle is at least 10 degrees.
	 */
	
	THREE.EdgesHelper = function ( object, hex, thresholdAngle ) {
	
		var color = ( hex !== undefined ) ? hex : 0xffffff;
	
		THREE.LineSegments.call( this, new THREE.EdgesGeometry( object.geometry, thresholdAngle ), new THREE.LineBasicMaterial( { color: color } ) );
	
		this.matrix = object.matrixWorld;
		this.matrixAutoUpdate = false;
	
	};
	
	THREE.EdgesHelper.prototype = Object.create( THREE.LineSegments.prototype );
	THREE.EdgesHelper.prototype.constructor = THREE.EdgesHelper;
	
	// File:src/extras/helpers/FaceNormalsHelper.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	*/
	
	THREE.FaceNormalsHelper = function ( object, size, hex, linewidth ) {
	
		// FaceNormalsHelper only supports THREE.Geometry
	
		this.object = object;
	
		this.size = ( size !== undefined ) ? size : 1;
	
		var color = ( hex !== undefined ) ? hex : 0xffff00;
	
		var width = ( linewidth !== undefined ) ? linewidth : 1;
	
		//
	
		var nNormals = 0;
	
		var objGeometry = this.object.geometry;
	
		if ( objGeometry instanceof THREE.Geometry ) {
	
			nNormals = objGeometry.faces.length;
	
		} else {
	
			console.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );
	
		}
	
		//
	
		var geometry = new THREE.BufferGeometry();
	
		var positions = new THREE.Float32Attribute( nNormals * 2 * 3, 3 );
	
		geometry.addAttribute( 'position', positions );
	
		THREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ) );
	
		//
	
		this.matrixAutoUpdate = false;
		this.update();
	
	};
	
	THREE.FaceNormalsHelper.prototype = Object.create( THREE.LineSegments.prototype );
	THREE.FaceNormalsHelper.prototype.constructor = THREE.FaceNormalsHelper;
	
	THREE.FaceNormalsHelper.prototype.update = ( function () {
	
		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();
		var normalMatrix = new THREE.Matrix3();
	
		return function update() {
	
			this.object.updateMatrixWorld( true );
	
			normalMatrix.getNormalMatrix( this.object.matrixWorld );
	
			var matrixWorld = this.object.matrixWorld;
	
			var position = this.geometry.attributes.position;
	
			//
	
			var objGeometry = this.object.geometry;
	
			var vertices = objGeometry.vertices;
	
			var faces = objGeometry.faces;
	
			var idx = 0;
	
			for ( var i = 0, l = faces.length; i < l; i ++ ) {
	
				var face = faces[ i ];
	
				var normal = face.normal;
	
				v1.copy( vertices[ face.a ] )
					.add( vertices[ face.b ] )
					.add( vertices[ face.c ] )
					.divideScalar( 3 )
					.applyMatrix4( matrixWorld );
	
				v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );
	
				position.setXYZ( idx, v1.x, v1.y, v1.z );
	
				idx = idx + 1;
	
				position.setXYZ( idx, v2.x, v2.y, v2.z );
	
				idx = idx + 1;
	
			}
	
			position.needsUpdate = true;
	
			return this;
	
		}
	
	}() );
	
	// File:src/extras/helpers/GridHelper.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.GridHelper = function ( size, step ) {
	
		var geometry = new THREE.Geometry();
		var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );
	
		this.color1 = new THREE.Color( 0x444444 );
		this.color2 = new THREE.Color( 0x888888 );
	
		for ( var i = - size; i <= size; i += step ) {
	
			geometry.vertices.push(
				new THREE.Vector3( - size, 0, i ), new THREE.Vector3( size, 0, i ),
				new THREE.Vector3( i, 0, - size ), new THREE.Vector3( i, 0, size )
			);
	
			var color = i === 0 ? this.color1 : this.color2;
	
			geometry.colors.push( color, color, color, color );
	
		}
	
		THREE.LineSegments.call( this, geometry, material );
	
	};
	
	THREE.GridHelper.prototype = Object.create( THREE.LineSegments.prototype );
	THREE.GridHelper.prototype.constructor = THREE.GridHelper;
	
	THREE.GridHelper.prototype.setColors = function( colorCenterLine, colorGrid ) {
	
		this.color1.set( colorCenterLine );
		this.color2.set( colorGrid );
	
		this.geometry.colorsNeedUpdate = true;
	
	};
	
	// File:src/extras/helpers/HemisphereLightHelper.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.HemisphereLightHelper = function ( light, sphereSize ) {
	
		THREE.Object3D.call( this );
	
		this.light = light;
		this.light.updateMatrixWorld();
	
		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;
	
		this.colors = [ new THREE.Color(), new THREE.Color() ];
	
		var geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );
		geometry.rotateX( - Math.PI / 2 );
	
		for ( var i = 0, il = 8; i < il; i ++ ) {
	
			geometry.faces[ i ].color = this.colors[ i < 4 ? 0 : 1 ];
	
		}
	
		var material = new THREE.MeshBasicMaterial( { vertexColors: THREE.FaceColors, wireframe: true } );
	
		this.lightSphere = new THREE.Mesh( geometry, material );
		this.add( this.lightSphere );
	
		this.update();
	
	};
	
	THREE.HemisphereLightHelper.prototype = Object.create( THREE.Object3D.prototype );
	THREE.HemisphereLightHelper.prototype.constructor = THREE.HemisphereLightHelper;
	
	THREE.HemisphereLightHelper.prototype.dispose = function () {
	
		this.lightSphere.geometry.dispose();
		this.lightSphere.material.dispose();
	
	};
	
	THREE.HemisphereLightHelper.prototype.update = function () {
	
		var vector = new THREE.Vector3();
	
		return function () {
	
			this.colors[ 0 ].copy( this.light.color ).multiplyScalar( this.light.intensity );
			this.colors[ 1 ].copy( this.light.groundColor ).multiplyScalar( this.light.intensity );
	
			this.lightSphere.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );
			this.lightSphere.geometry.colorsNeedUpdate = true;
	
		}
	
	}();
	
	// File:src/extras/helpers/PointLightHelper.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.PointLightHelper = function ( light, sphereSize ) {
	
		this.light = light;
		this.light.updateMatrixWorld();
	
		var geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );
		var material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );
		material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );
	
		THREE.Mesh.call( this, geometry, material );
	
		this.matrix = this.light.matrixWorld;
		this.matrixAutoUpdate = false;
	
		/*
		var distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
		var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );
	
		this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
		this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );
	
		var d = light.distance;
	
		if ( d === 0.0 ) {
	
			this.lightDistance.visible = false;
	
		} else {
	
			this.lightDistance.scale.set( d, d, d );
	
		}
	
		this.add( this.lightDistance );
		*/
	
	};
	
	THREE.PointLightHelper.prototype = Object.create( THREE.Mesh.prototype );
	THREE.PointLightHelper.prototype.constructor = THREE.PointLightHelper;
	
	THREE.PointLightHelper.prototype.dispose = function () {
	
		this.geometry.dispose();
		this.material.dispose();
	
	};
	
	THREE.PointLightHelper.prototype.update = function () {
	
		this.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );
	
		/*
		var d = this.light.distance;
	
		if ( d === 0.0 ) {
	
			this.lightDistance.visible = false;
	
		} else {
	
			this.lightDistance.visible = true;
			this.lightDistance.scale.set( d, d, d );
	
		}
		*/
	
	};
	
	// File:src/extras/helpers/SkeletonHelper.js
	
	/**
	 * @author Sean Griffin / http://twitter.com/sgrif
	 * @author Michael Guerrero / http://realitymeltdown.com
	 * @author mrdoob / http://mrdoob.com/
	 * @author ikerr / http://verold.com
	 */
	
	THREE.SkeletonHelper = function ( object ) {
	
		this.bones = this.getBoneList( object );
	
		var geometry = new THREE.Geometry();
	
		for ( var i = 0; i < this.bones.length; i ++ ) {
	
			var bone = this.bones[ i ];
	
			if ( bone.parent instanceof THREE.Bone ) {
	
				geometry.vertices.push( new THREE.Vector3() );
				geometry.vertices.push( new THREE.Vector3() );
				geometry.colors.push( new THREE.Color( 0, 0, 1 ) );
				geometry.colors.push( new THREE.Color( 0, 1, 0 ) );
	
			}
	
		}
	
		geometry.dynamic = true;
	
		var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors, depthTest: false, depthWrite: false, transparent: true } );
	
		THREE.LineSegments.call( this, geometry, material );
	
		this.root = object;
	
		this.matrix = object.matrixWorld;
		this.matrixAutoUpdate = false;
	
		this.update();
	
	};
	
	
	THREE.SkeletonHelper.prototype = Object.create( THREE.LineSegments.prototype );
	THREE.SkeletonHelper.prototype.constructor = THREE.SkeletonHelper;
	
	THREE.SkeletonHelper.prototype.getBoneList = function( object ) {
	
		var boneList = [];
	
		if ( object instanceof THREE.Bone ) {
	
			boneList.push( object );
	
		}
	
		for ( var i = 0; i < object.children.length; i ++ ) {
	
			boneList.push.apply( boneList, this.getBoneList( object.children[ i ] ) );
	
		}
	
		return boneList;
	
	};
	
	THREE.SkeletonHelper.prototype.update = function () {
	
		var geometry = this.geometry;
	
		var matrixWorldInv = new THREE.Matrix4().getInverse( this.root.matrixWorld );
	
		var boneMatrix = new THREE.Matrix4();
	
		var j = 0;
	
		for ( var i = 0; i < this.bones.length; i ++ ) {
	
			var bone = this.bones[ i ];
	
			if ( bone.parent instanceof THREE.Bone ) {
	
				boneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );
				geometry.vertices[ j ].setFromMatrixPosition( boneMatrix );
	
				boneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );
				geometry.vertices[ j + 1 ].setFromMatrixPosition( boneMatrix );
	
				j += 2;
	
			}
	
		}
	
		geometry.verticesNeedUpdate = true;
	
		geometry.computeBoundingSphere();
	
	};
	
	// File:src/extras/helpers/SpotLightHelper.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	*/
	
	THREE.SpotLightHelper = function ( light ) {
	
		THREE.Object3D.call( this );
	
		this.light = light;
		this.light.updateMatrixWorld();
	
		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;
	
		var geometry = new THREE.CylinderGeometry( 0, 1, 1, 8, 1, true );
	
		geometry.translate( 0, - 0.5, 0 );
		geometry.rotateX( - Math.PI / 2 );
	
		var material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );
	
		this.cone = new THREE.Mesh( geometry, material );
		this.add( this.cone );
	
		this.update();
	
	};
	
	THREE.SpotLightHelper.prototype = Object.create( THREE.Object3D.prototype );
	THREE.SpotLightHelper.prototype.constructor = THREE.SpotLightHelper;
	
	THREE.SpotLightHelper.prototype.dispose = function () {
	
		this.cone.geometry.dispose();
		this.cone.material.dispose();
	
	};
	
	THREE.SpotLightHelper.prototype.update = function () {
	
		var vector = new THREE.Vector3();
		var vector2 = new THREE.Vector3();
	
		return function () {
	
			var coneLength = this.light.distance ? this.light.distance : 10000;
			var coneWidth = coneLength * Math.tan( this.light.angle );
	
			this.cone.scale.set( coneWidth, coneWidth, coneLength );
	
			vector.setFromMatrixPosition( this.light.matrixWorld );
			vector2.setFromMatrixPosition( this.light.target.matrixWorld );
	
			this.cone.lookAt( vector2.sub( vector ) );
	
			this.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );
	
		};
	
	}();
	
	// File:src/extras/helpers/VertexNormalsHelper.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	*/
	
	THREE.VertexNormalsHelper = function ( object, size, hex, linewidth ) {
	
		this.object = object;
	
		this.size = ( size !== undefined ) ? size : 1;
	
		var color = ( hex !== undefined ) ? hex : 0xff0000;
	
		var width = ( linewidth !== undefined ) ? linewidth : 1;
	
		//
	
		var nNormals = 0;
	
		var objGeometry = this.object.geometry;
	
		if ( objGeometry instanceof THREE.Geometry ) {
	
			nNormals = objGeometry.faces.length * 3;
	
		} else if ( objGeometry instanceof THREE.BufferGeometry ) {
	
			nNormals = objGeometry.attributes.normal.count
	
		}
	
		//
	
		var geometry = new THREE.BufferGeometry();
	
		var positions = new THREE.Float32Attribute( nNormals * 2 * 3, 3 );
	
		geometry.addAttribute( 'position', positions );
	
		THREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ) );
	
		//
	
		this.matrixAutoUpdate = false;
	
		this.update();
	
	};
	
	THREE.VertexNormalsHelper.prototype = Object.create( THREE.LineSegments.prototype );
	THREE.VertexNormalsHelper.prototype.constructor = THREE.VertexNormalsHelper;
	
	THREE.VertexNormalsHelper.prototype.update = ( function () {
	
		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();
		var normalMatrix = new THREE.Matrix3();
	
		return function update() {
	
			var keys = [ 'a', 'b', 'c' ];
	
			this.object.updateMatrixWorld( true );
	
			normalMatrix.getNormalMatrix( this.object.matrixWorld );
	
			var matrixWorld = this.object.matrixWorld;
	
			var position = this.geometry.attributes.position;
	
			//
	
			var objGeometry = this.object.geometry;
	
			if ( objGeometry instanceof THREE.Geometry ) {
	
				var vertices = objGeometry.vertices;
	
				var faces = objGeometry.faces;
	
				var idx = 0;
	
				for ( var i = 0, l = faces.length; i < l; i ++ ) {
	
					var face = faces[ i ];
	
					for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {
	
						var vertex = vertices[ face[ keys[ j ] ] ];
	
						var normal = face.vertexNormals[ j ];
	
						v1.copy( vertex ).applyMatrix4( matrixWorld );
	
						v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );
	
						position.setXYZ( idx, v1.x, v1.y, v1.z );
	
						idx = idx + 1;
	
						position.setXYZ( idx, v2.x, v2.y, v2.z );
	
						idx = idx + 1;
	
					}
	
				}
	
			} else if ( objGeometry instanceof THREE.BufferGeometry ) {
	
				var objPos = objGeometry.attributes.position;
	
				var objNorm = objGeometry.attributes.normal;
	
				var idx = 0;
	
				// for simplicity, ignore index and drawcalls, and render every normal
	
				for ( var j = 0, jl = objPos.count; j < jl; j ++ ) {
	
					v1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );
	
					v2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );
	
					v2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );
	
					position.setXYZ( idx, v1.x, v1.y, v1.z );
	
					idx = idx + 1;
	
					position.setXYZ( idx, v2.x, v2.y, v2.z );
	
					idx = idx + 1;
	
				}
	
			}
	
			position.needsUpdate = true;
	
			return this;
	
		}
	
	}() );
	
	// File:src/extras/helpers/WireframeHelper.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.WireframeHelper = function ( object, hex ) {
	
		var color = ( hex !== undefined ) ? hex : 0xffffff;
	
		THREE.LineSegments.call( this, new THREE.WireframeGeometry( object.geometry ), new THREE.LineBasicMaterial( { color: color } ) );
	
		this.matrix = object.matrixWorld;
		this.matrixAutoUpdate = false;
	
	};
	
	THREE.WireframeHelper.prototype = Object.create( THREE.LineSegments.prototype );
	THREE.WireframeHelper.prototype.constructor = THREE.WireframeHelper;
	
	// File:src/extras/objects/ImmediateRenderObject.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.ImmediateRenderObject = function ( material ) {
	
		THREE.Object3D.call( this );
	
		this.material = material;
		this.render = function ( renderCallback ) {};
	
	};
	
	THREE.ImmediateRenderObject.prototype = Object.create( THREE.Object3D.prototype );
	THREE.ImmediateRenderObject.prototype.constructor = THREE.ImmediateRenderObject;
	
	// File:src/extras/objects/MorphBlendMesh.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.MorphBlendMesh = function( geometry, material ) {
	
		THREE.Mesh.call( this, geometry, material );
	
		this.animationsMap = {};
		this.animationsList = [];
	
		// prepare default animation
		// (all frames played together in 1 second)
	
		var numFrames = this.geometry.morphTargets.length;
	
		var name = "__default";
	
		var startFrame = 0;
		var endFrame = numFrames - 1;
	
		var fps = numFrames / 1;
	
		this.createAnimation( name, startFrame, endFrame, fps );
		this.setAnimationWeight( name, 1 );
	
	};
	
	THREE.MorphBlendMesh.prototype = Object.create( THREE.Mesh.prototype );
	THREE.MorphBlendMesh.prototype.constructor = THREE.MorphBlendMesh;
	
	THREE.MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {
	
		var animation = {
	
			start: start,
			end: end,
	
			length: end - start + 1,
	
			fps: fps,
			duration: ( end - start ) / fps,
	
			lastFrame: 0,
			currentFrame: 0,
	
			active: false,
	
			time: 0,
			direction: 1,
			weight: 1,
	
			directionBackwards: false,
			mirroredLoop: false
	
		};
	
		this.animationsMap[ name ] = animation;
		this.animationsList.push( animation );
	
	};
	
	THREE.MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {
	
		var pattern = /([a-z]+)_?(\d+)/i;
	
		var firstAnimation, frameRanges = {};
	
		var geometry = this.geometry;
	
		for ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {
	
			var morph = geometry.morphTargets[ i ];
			var chunks = morph.name.match( pattern );
	
			if ( chunks && chunks.length > 1 ) {
	
				var name = chunks[ 1 ];
	
				if ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: - Infinity };
	
				var range = frameRanges[ name ];
	
				if ( i < range.start ) range.start = i;
				if ( i > range.end ) range.end = i;
	
				if ( ! firstAnimation ) firstAnimation = name;
	
			}
	
		}
	
		for ( var name in frameRanges ) {
	
			var range = frameRanges[ name ];
			this.createAnimation( name, range.start, range.end, fps );
	
		}
	
		this.firstAnimation = firstAnimation;
	
	};
	
	THREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {
	
		var animation = this.animationsMap[ name ];
	
		if ( animation ) {
	
			animation.direction = 1;
			animation.directionBackwards = false;
	
		}
	
	};
	
	THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {
	
		var animation = this.animationsMap[ name ];
	
		if ( animation ) {
	
			animation.direction = - 1;
			animation.directionBackwards = true;
	
		}
	
	};
	
	THREE.MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {
	
		var animation = this.animationsMap[ name ];
	
		if ( animation ) {
	
			animation.fps = fps;
			animation.duration = ( animation.end - animation.start ) / animation.fps;
	
		}
	
	};
	
	THREE.MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {
	
		var animation = this.animationsMap[ name ];
	
		if ( animation ) {
	
			animation.duration = duration;
			animation.fps = ( animation.end - animation.start ) / animation.duration;
	
		}
	
	};
	
	THREE.MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {
	
		var animation = this.animationsMap[ name ];
	
		if ( animation ) {
	
			animation.weight = weight;
	
		}
	
	};
	
	THREE.MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {
	
		var animation = this.animationsMap[ name ];
	
		if ( animation ) {
	
			animation.time = time;
	
		}
	
	};
	
	THREE.MorphBlendMesh.prototype.getAnimationTime = function ( name ) {
	
		var time = 0;
	
		var animation = this.animationsMap[ name ];
	
		if ( animation ) {
	
			time = animation.time;
	
		}
	
		return time;
	
	};
	
	THREE.MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {
	
		var duration = - 1;
	
		var animation = this.animationsMap[ name ];
	
		if ( animation ) {
	
			duration = animation.duration;
	
		}
	
		return duration;
	
	};
	
	THREE.MorphBlendMesh.prototype.playAnimation = function ( name ) {
	
		var animation = this.animationsMap[ name ];
	
		if ( animation ) {
	
			animation.time = 0;
			animation.active = true;
	
		} else {
	
			console.warn( "THREE.MorphBlendMesh: animation[" + name + "] undefined in .playAnimation()" );
	
		}
	
	};
	
	THREE.MorphBlendMesh.prototype.stopAnimation = function ( name ) {
	
		var animation = this.animationsMap[ name ];
	
		if ( animation ) {
	
			animation.active = false;
	
		}
	
	};
	
	THREE.MorphBlendMesh.prototype.update = function ( delta ) {
	
		for ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {
	
			var animation = this.animationsList[ i ];
	
			if ( ! animation.active ) continue;
	
			var frameTime = animation.duration / animation.length;
	
			animation.time += animation.direction * delta;
	
			if ( animation.mirroredLoop ) {
	
				if ( animation.time > animation.duration || animation.time < 0 ) {
	
					animation.direction *= - 1;
	
					if ( animation.time > animation.duration ) {
	
						animation.time = animation.duration;
						animation.directionBackwards = true;
	
					}
	
					if ( animation.time < 0 ) {
	
						animation.time = 0;
						animation.directionBackwards = false;
	
					}
	
				}
	
			} else {
	
				animation.time = animation.time % animation.duration;
	
				if ( animation.time < 0 ) animation.time += animation.duration;
	
			}
	
			var keyframe = animation.start + THREE.Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );
			var weight = animation.weight;
	
			if ( keyframe !== animation.currentFrame ) {
	
				this.morphTargetInfluences[ animation.lastFrame ] = 0;
				this.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;
	
				this.morphTargetInfluences[ keyframe ] = 0;
	
				animation.lastFrame = animation.currentFrame;
				animation.currentFrame = keyframe;
	
			}
	
			var mix = ( animation.time % frameTime ) / frameTime;
	
			if ( animation.directionBackwards ) mix = 1 - mix;
	
			if ( animation.currentFrame !== animation.lastFrame ) {
	
				this.morphTargetInfluences[ animation.currentFrame ] = mix * weight;
				this.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;
	
			} else {
	
				this.morphTargetInfluences[ animation.currentFrame ] = weight;
	
			}
	
		}
	
	};
	
	
	// Export the THREE object for **Node.js**, with
	// backwards-compatibility for the old `require()` API. If we're in
	// the browser, add `_` as a global object via a string identifier,
	// for Closure Compiler "advanced" mode.
	if (typeof exports !== 'undefined') {
	  if (typeof module !== 'undefined' && module.exports) {
	    exports = module.exports = THREE;
	  }
	  exports.THREE = THREE;
	} else {
	  this['THREE'] = THREE;
	}
	
	},{}],22:[function(_dereq_,module,exports){
	/**
	 * Tween.js - Licensed under the MIT license
	 * https://github.com/sole/tween.js
	 * ----------------------------------------------
	 *
	 * See https://github.com/sole/tween.js/graphs/contributors for the full list of contributors.
	 * Thank you all, you're awesome!
	 */
	
	// performance.now polyfill
	( function ( root ) {
	
		if ( 'performance' in root === false ) {
			root.performance = {};
		}
	
		// IE 8
		Date.now = ( Date.now || function () {
			return new Date().getTime();
		} );
	
		if ( 'now' in root.performance === false ) {
			var offset = root.performance.timing && root.performance.timing.navigationStart ? performance.timing.navigationStart
			                                                                                : Date.now();
	
			root.performance.now = function () {
				return Date.now() - offset;
			};
		}
	
	} )( this );
	
	var TWEEN = TWEEN || ( function () {
	
		var _tweens = [];
	
		return {
	
			REVISION: '14',
	
			getAll: function () {
	
				return _tweens;
	
			},
	
			removeAll: function () {
	
				_tweens = [];
	
			},
	
			add: function ( tween ) {
	
				_tweens.push( tween );
	
			},
	
			remove: function ( tween ) {
	
				var i = _tweens.indexOf( tween );
	
				if ( i !== -1 ) {
	
					_tweens.splice( i, 1 );
	
				}
	
			},
	
			update: function ( time ) {
	
				if ( _tweens.length === 0 ) return false;
	
				var i = 0;
	
				time = time !== undefined ? time : window.performance.now();
	
				while ( i < _tweens.length ) {
	
					if ( _tweens[ i ].update( time ) ) {
	
						i++;
	
					} else {
	
						_tweens.splice( i, 1 );
	
					}
	
				}
	
				return true;
	
			}
		};
	
	} )();
	
	TWEEN.Tween = function ( object ) {
	
		var _object = object;
		var _valuesStart = {};
		var _valuesEnd = {};
		var _valuesStartRepeat = {};
		var _duration = 1000;
		var _repeat = 0;
		var _yoyo = false;
		var _isPlaying = false;
		var _reversed = false;
		var _delayTime = 0;
		var _startTime = null;
		var _easingFunction = TWEEN.Easing.Linear.None;
		var _interpolationFunction = TWEEN.Interpolation.Linear;
		var _chainedTweens = [];
		var _onStartCallback = null;
		var _onStartCallbackFired = false;
		var _onUpdateCallback = null;
		var _onCompleteCallback = null;
		var _onStopCallback = null;
	
		// Set all starting values present on the target object
		for ( var field in object ) {
	
			_valuesStart[ field ] = parseFloat(object[field], 10);
	
		}
	
		this.to = function ( properties, duration ) {
	
			if ( duration !== undefined ) {
	
				_duration = duration;
	
			}
	
			_valuesEnd = properties;
	
			return this;
	
		};
	
		this.start = function ( time ) {
	
			TWEEN.add( this );
	
			_isPlaying = true;
	
			_onStartCallbackFired = false;
	
			_startTime = time !== undefined ? time : window.performance.now();
			_startTime += _delayTime;
	
			for ( var property in _valuesEnd ) {
	
				// check if an Array was provided as property value
				if ( _valuesEnd[ property ] instanceof Array ) {
	
					if ( _valuesEnd[ property ].length === 0 ) {
	
						continue;
	
					}
	
					// create a local copy of the Array with the start value at the front
					_valuesEnd[ property ] = [ _object[ property ] ].concat( _valuesEnd[ property ] );
	
				}
	
				_valuesStart[ property ] = _object[ property ];
	
				if( ( _valuesStart[ property ] instanceof Array ) === false ) {
					_valuesStart[ property ] *= 1.0; // Ensures we're using numbers, not strings
				}
	
				_valuesStartRepeat[ property ] = _valuesStart[ property ] || 0;
	
			}
	
			return this;
	
		};
	
		this.stop = function () {
	
			if ( !_isPlaying ) {
				return this;
			}
	
			TWEEN.remove( this );
			_isPlaying = false;
	
			if ( _onStopCallback !== null ) {
	
				_onStopCallback.call( _object );
	
			}
	
			this.stopChainedTweens();
			return this;
	
		};
	
		this.stopChainedTweens = function () {
	
			for ( var i = 0, numChainedTweens = _chainedTweens.length; i < numChainedTweens; i++ ) {
	
				_chainedTweens[ i ].stop();
	
			}
	
		};
	
		this.delay = function ( amount ) {
	
			_delayTime = amount;
			return this;
	
		};
	
		this.repeat = function ( times ) {
	
			_repeat = times;
			return this;
	
		};
	
		this.yoyo = function( yoyo ) {
	
			_yoyo = yoyo;
			return this;
	
		};
	
	
		this.easing = function ( easing ) {
	
			_easingFunction = easing;
			return this;
	
		};
	
		this.interpolation = function ( interpolation ) {
	
			_interpolationFunction = interpolation;
			return this;
	
		};
	
		this.chain = function () {
	
			_chainedTweens = arguments;
			return this;
	
		};
	
		this.onStart = function ( callback ) {
	
			_onStartCallback = callback;
			return this;
	
		};
	
		this.onUpdate = function ( callback ) {
	
			_onUpdateCallback = callback;
			return this;
	
		};
	
		this.onComplete = function ( callback ) {
	
			_onCompleteCallback = callback;
			return this;
	
		};
	
		this.onStop = function ( callback ) {
	
			_onStopCallback = callback;
			return this;
	
		};
	
		this.update = function ( time ) {
	
			var property;
	
			if ( time < _startTime ) {
	
				return true;
	
			}
	
			if ( _onStartCallbackFired === false ) {
	
				if ( _onStartCallback !== null ) {
	
					_onStartCallback.call( _object );
	
				}
	
				_onStartCallbackFired = true;
	
			}
	
			var elapsed = ( time - _startTime ) / _duration;
			elapsed = elapsed > 1 ? 1 : elapsed;
	
			var value = _easingFunction( elapsed );
	
			for ( property in _valuesEnd ) {
	
				var start = _valuesStart[ property ] || 0;
				var end = _valuesEnd[ property ];
	
				if ( end instanceof Array ) {
	
					_object[ property ] = _interpolationFunction( end, value );
	
				} else {
	
					// Parses relative end values with start as base (e.g.: +10, -3)
					if ( typeof(end) === "string" ) {
						end = start + parseFloat(end, 10);
					}
	
					// protect against non numeric properties.
					if ( typeof(end) === "number" ) {
						_object[ property ] = start + ( end - start ) * value;
					}
	
				}
	
			}
	
			if ( _onUpdateCallback !== null ) {
	
				_onUpdateCallback.call( _object, value );
	
			}
	
			if ( elapsed == 1 ) {
	
				if ( _repeat > 0 ) {
	
					if( isFinite( _repeat ) ) {
						_repeat--;
					}
	
					// reassign starting values, restart by making startTime = now
					for( property in _valuesStartRepeat ) {
	
						if ( typeof( _valuesEnd[ property ] ) === "string" ) {
							_valuesStartRepeat[ property ] = _valuesStartRepeat[ property ] + parseFloat(_valuesEnd[ property ], 10);
						}
	
						if (_yoyo) {
							var tmp = _valuesStartRepeat[ property ];
							_valuesStartRepeat[ property ] = _valuesEnd[ property ];
							_valuesEnd[ property ] = tmp;
						}
	
						_valuesStart[ property ] = _valuesStartRepeat[ property ];
	
					}
	
					if (_yoyo) {
						_reversed = !_reversed;
					}
	
					_startTime = time + _delayTime;
	
					return true;
	
				} else {
	
					if ( _onCompleteCallback !== null ) {
	
						_onCompleteCallback.call( _object );
	
					}
	
					for ( var i = 0, numChainedTweens = _chainedTweens.length; i < numChainedTweens; i++ ) {
	
						_chainedTweens[ i ].start( time );
	
					}
	
					return false;
	
				}
	
			}
	
			return true;
	
		};
	
	};
	
	
	TWEEN.Easing = {
	
		Linear: {
	
			None: function ( k ) {
	
				return k;
	
			}
	
		},
	
		Quadratic: {
	
			In: function ( k ) {
	
				return k * k;
	
			},
	
			Out: function ( k ) {
	
				return k * ( 2 - k );
	
			},
	
			InOut: function ( k ) {
	
				if ( ( k *= 2 ) < 1 ) return 0.5 * k * k;
				return - 0.5 * ( --k * ( k - 2 ) - 1 );
	
			}
	
		},
	
		Cubic: {
	
			In: function ( k ) {
	
				return k * k * k;
	
			},
	
			Out: function ( k ) {
	
				return --k * k * k + 1;
	
			},
	
			InOut: function ( k ) {
	
				if ( ( k *= 2 ) < 1 ) return 0.5 * k * k * k;
				return 0.5 * ( ( k -= 2 ) * k * k + 2 );
	
			}
	
		},
	
		Quartic: {
	
			In: function ( k ) {
	
				return k * k * k * k;
	
			},
	
			Out: function ( k ) {
	
				return 1 - ( --k * k * k * k );
	
			},
	
			InOut: function ( k ) {
	
				if ( ( k *= 2 ) < 1) return 0.5 * k * k * k * k;
				return - 0.5 * ( ( k -= 2 ) * k * k * k - 2 );
	
			}
	
		},
	
		Quintic: {
	
			In: function ( k ) {
	
				return k * k * k * k * k;
	
			},
	
			Out: function ( k ) {
	
				return --k * k * k * k * k + 1;
	
			},
	
			InOut: function ( k ) {
	
				if ( ( k *= 2 ) < 1 ) return 0.5 * k * k * k * k * k;
				return 0.5 * ( ( k -= 2 ) * k * k * k * k + 2 );
	
			}
	
		},
	
		Sinusoidal: {
	
			In: function ( k ) {
	
				return 1 - Math.cos( k * Math.PI / 2 );
	
			},
	
			Out: function ( k ) {
	
				return Math.sin( k * Math.PI / 2 );
	
			},
	
			InOut: function ( k ) {
	
				return 0.5 * ( 1 - Math.cos( Math.PI * k ) );
	
			}
	
		},
	
		Exponential: {
	
			In: function ( k ) {
	
				return k === 0 ? 0 : Math.pow( 1024, k - 1 );
	
			},
	
			Out: function ( k ) {
	
				return k === 1 ? 1 : 1 - Math.pow( 2, - 10 * k );
	
			},
	
			InOut: function ( k ) {
	
				if ( k === 0 ) return 0;
				if ( k === 1 ) return 1;
				if ( ( k *= 2 ) < 1 ) return 0.5 * Math.pow( 1024, k - 1 );
				return 0.5 * ( - Math.pow( 2, - 10 * ( k - 1 ) ) + 2 );
	
			}
	
		},
	
		Circular: {
	
			In: function ( k ) {
	
				return 1 - Math.sqrt( 1 - k * k );
	
			},
	
			Out: function ( k ) {
	
				return Math.sqrt( 1 - ( --k * k ) );
	
			},
	
			InOut: function ( k ) {
	
				if ( ( k *= 2 ) < 1) return - 0.5 * ( Math.sqrt( 1 - k * k) - 1);
				return 0.5 * ( Math.sqrt( 1 - ( k -= 2) * k) + 1);
	
			}
	
		},
	
		Elastic: {
	
			In: function ( k ) {
	
				var s, a = 0.1, p = 0.4;
				if ( k === 0 ) return 0;
				if ( k === 1 ) return 1;
				if ( !a || a < 1 ) { a = 1; s = p / 4; }
				else s = p * Math.asin( 1 / a ) / ( 2 * Math.PI );
				return - ( a * Math.pow( 2, 10 * ( k -= 1 ) ) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) );
	
			},
	
			Out: function ( k ) {
	
				var s, a = 0.1, p = 0.4;
				if ( k === 0 ) return 0;
				if ( k === 1 ) return 1;
				if ( !a || a < 1 ) { a = 1; s = p / 4; }
				else s = p * Math.asin( 1 / a ) / ( 2 * Math.PI );
				return ( a * Math.pow( 2, - 10 * k) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) + 1 );
	
			},
	
			InOut: function ( k ) {
	
				var s, a = 0.1, p = 0.4;
				if ( k === 0 ) return 0;
				if ( k === 1 ) return 1;
				if ( !a || a < 1 ) { a = 1; s = p / 4; }
				else s = p * Math.asin( 1 / a ) / ( 2 * Math.PI );
				if ( ( k *= 2 ) < 1 ) return - 0.5 * ( a * Math.pow( 2, 10 * ( k -= 1 ) ) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) );
				return a * Math.pow( 2, -10 * ( k -= 1 ) ) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) * 0.5 + 1;
	
			}
	
		},
	
		Back: {
	
			In: function ( k ) {
	
				var s = 1.70158;
				return k * k * ( ( s + 1 ) * k - s );
	
			},
	
			Out: function ( k ) {
	
				var s = 1.70158;
				return --k * k * ( ( s + 1 ) * k + s ) + 1;
	
			},
	
			InOut: function ( k ) {
	
				var s = 1.70158 * 1.525;
				if ( ( k *= 2 ) < 1 ) return 0.5 * ( k * k * ( ( s + 1 ) * k - s ) );
				return 0.5 * ( ( k -= 2 ) * k * ( ( s + 1 ) * k + s ) + 2 );
	
			}
	
		},
	
		Bounce: {
	
			In: function ( k ) {
	
				return 1 - TWEEN.Easing.Bounce.Out( 1 - k );
	
			},
	
			Out: function ( k ) {
	
				if ( k < ( 1 / 2.75 ) ) {
	
					return 7.5625 * k * k;
	
				} else if ( k < ( 2 / 2.75 ) ) {
	
					return 7.5625 * ( k -= ( 1.5 / 2.75 ) ) * k + 0.75;
	
				} else if ( k < ( 2.5 / 2.75 ) ) {
	
					return 7.5625 * ( k -= ( 2.25 / 2.75 ) ) * k + 0.9375;
	
				} else {
	
					return 7.5625 * ( k -= ( 2.625 / 2.75 ) ) * k + 0.984375;
	
				}
	
			},
	
			InOut: function ( k ) {
	
				if ( k < 0.5 ) return TWEEN.Easing.Bounce.In( k * 2 ) * 0.5;
				return TWEEN.Easing.Bounce.Out( k * 2 - 1 ) * 0.5 + 0.5;
	
			}
	
		}
	
	};
	
	TWEEN.Interpolation = {
	
		Linear: function ( v, k ) {
	
			var m = v.length - 1, f = m * k, i = Math.floor( f ), fn = TWEEN.Interpolation.Utils.Linear;
	
			if ( k < 0 ) return fn( v[ 0 ], v[ 1 ], f );
			if ( k > 1 ) return fn( v[ m ], v[ m - 1 ], m - f );
	
			return fn( v[ i ], v[ i + 1 > m ? m : i + 1 ], f - i );
	
		},
	
		Bezier: function ( v, k ) {
	
			var b = 0, n = v.length - 1, pw = Math.pow, bn = TWEEN.Interpolation.Utils.Bernstein, i;
	
			for ( i = 0; i <= n; i++ ) {
				b += pw( 1 - k, n - i ) * pw( k, i ) * v[ i ] * bn( n, i );
			}
	
			return b;
	
		},
	
		CatmullRom: function ( v, k ) {
	
			var m = v.length - 1, f = m * k, i = Math.floor( f ), fn = TWEEN.Interpolation.Utils.CatmullRom;
	
			if ( v[ 0 ] === v[ m ] ) {
	
				if ( k < 0 ) i = Math.floor( f = m * ( 1 + k ) );
	
				return fn( v[ ( i - 1 + m ) % m ], v[ i ], v[ ( i + 1 ) % m ], v[ ( i + 2 ) % m ], f - i );
	
			} else {
	
				if ( k < 0 ) return v[ 0 ] - ( fn( v[ 0 ], v[ 0 ], v[ 1 ], v[ 1 ], -f ) - v[ 0 ] );
				if ( k > 1 ) return v[ m ] - ( fn( v[ m ], v[ m ], v[ m - 1 ], v[ m - 1 ], f - m ) - v[ m ] );
	
				return fn( v[ i ? i - 1 : 0 ], v[ i ], v[ m < i + 1 ? m : i + 1 ], v[ m < i + 2 ? m : i + 2 ], f - i );
	
			}
	
		},
	
		Utils: {
	
			Linear: function ( p0, p1, t ) {
	
				return ( p1 - p0 ) * t + p0;
	
			},
	
			Bernstein: function ( n , i ) {
	
				var fc = TWEEN.Interpolation.Utils.Factorial;
				return fc( n ) / fc( i ) / fc( n - i );
	
			},
	
			Factorial: ( function () {
	
				var a = [ 1 ];
	
				return function ( n ) {
	
					var s = 1, i;
					if ( a[ n ] ) return a[ n ];
					for ( i = n; i > 1; i-- ) s *= i;
					return a[ n ] = s;
	
				};
	
			} )(),
	
			CatmullRom: function ( p0, p1, p2, p3, t ) {
	
				var v0 = ( p2 - p0 ) * 0.5, v1 = ( p3 - p1 ) * 0.5, t2 = t * t, t3 = t * t2;
				return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;
	
			}
	
		}
	
	};
	
	// UMD (Universal Module Definition)
	( function ( root ) {
	
		if ( typeof define === 'function' && define.amd ) {
	
			// AMD
			define( [], function () {
				return TWEEN;
			} );
	
		} else if ( typeof exports === 'object' ) {
	
			// Node.js
			module.exports = TWEEN;
	
		} else {
	
			// Global variable
			root.TWEEN = TWEEN;
	
		}
	
	} )( this );
	
	},{}],23:[function(_dereq_,module,exports){
	(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof _dereq_=="function"&&_dereq_;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof _dereq_=="function"&&_dereq_;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
	/*
	 * Copyright 2015 Google Inc. All Rights Reserved.
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	
	/**
	 * The base class for all VR devices.
	 */
	function VRDevice() {
	  this.hardwareUnitId = 'webvr-polyfill hardwareUnitId';
	  this.deviceId = 'webvr-polyfill deviceId';
	  this.deviceName = 'webvr-polyfill deviceName';
	}
	
	/**
	 * The base class for all VR HMD devices.
	 */
	function HMDVRDevice() {
	}
	HMDVRDevice.prototype = new VRDevice();
	
	/**
	 * The base class for all VR position sensor devices.
	 */
	function PositionSensorVRDevice() {
	}
	PositionSensorVRDevice.prototype = new VRDevice();
	
	module.exports.VRDevice = VRDevice;
	module.exports.HMDVRDevice = HMDVRDevice;
	module.exports.PositionSensorVRDevice = PositionSensorVRDevice;
	
	},{}],2:[function(_dereq_,module,exports){
	/*
	 * Copyright 2015 Google Inc. All Rights Reserved.
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var HMDVRDevice = _dereq_('./base.js').HMDVRDevice;
	
	// Constants from vrtoolkit: https://github.com/googlesamples/cardboard-java.
	var INTERPUPILLARY_DISTANCE = 0.06;
	var DEFAULT_MAX_FOV_LEFT_RIGHT = 40;
	var DEFAULT_MAX_FOV_BOTTOM = 40;
	var DEFAULT_MAX_FOV_TOP = 40;
	
	/**
	 * The HMD itself, providing rendering parameters.
	 */
	function CardboardHMDVRDevice() {
	  // From com/google/vrtoolkit/cardboard/FieldOfView.java.
	  this.fov = {
	    upDegrees: DEFAULT_MAX_FOV_TOP,
	    downDegrees: DEFAULT_MAX_FOV_BOTTOM,
	    leftDegrees: DEFAULT_MAX_FOV_LEFT_RIGHT,
	    rightDegrees: DEFAULT_MAX_FOV_LEFT_RIGHT
	  };
	  // Set display constants.
	  this.eyeTranslationLeft = {
	    x: INTERPUPILLARY_DISTANCE * -0.5,
	    y: 0,
	    z: 0
	  };
	  this.eyeTranslationRight = {
	    x: INTERPUPILLARY_DISTANCE * 0.5,
	    y: 0,
	    z: 0
	  };
	}
	CardboardHMDVRDevice.prototype = new HMDVRDevice();
	
	CardboardHMDVRDevice.prototype.getEyeParameters = function(whichEye) {
	  var eyeTranslation;
	  if (whichEye == 'left') {
	    eyeTranslation = this.eyeTranslationLeft;
	  } else if (whichEye == 'right') {
	    eyeTranslation = this.eyeTranslationRight;
	  } else {
	    console.error('Invalid eye provided: %s', whichEye);
	    return null;
	  }
	  return {
	    recommendedFieldOfView: this.fov,
	    eyeTranslation: eyeTranslation
	  };
	};
	
	module.exports = CardboardHMDVRDevice;
	
	},{"./base.js":1}],3:[function(_dereq_,module,exports){
	/*
	 * Copyright 2015 Google Inc. All Rights Reserved.
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	
	/**
	 * TODO: Fix up all "new THREE" instantiations to improve performance.
	 */
	var SensorSample = _dereq_('./sensor-sample.js');
	var THREE = _dereq_('./three-math.js');
	var Util = _dereq_('./util.js');
	
	var DEBUG = false;
	
	/**
	 * An implementation of a simple complementary filter, which fuses gyroscope and
	 * accelerometer data from the 'devicemotion' event.
	 *
	 * Accelerometer data is very noisy, but stable over the long term.
	 * Gyroscope data is smooth, but tends to drift over the long term.
	 *
	 * This fusion is relatively simple:
	 * 1. Get orientation estimates from accelerometer by applying a low-pass filter
	 *    on that data.
	 * 2. Get orientation estimates from gyroscope by integrating over time.
	 * 3. Combine the two estimates, weighing (1) in the long term, but (2) for the
	 *    short term.
	 */
	function ComplementaryFilter(kFilter) {
	  this.kFilter = kFilter;
	
	  // Raw sensor measurements.
	  this.currentAccelMeasurement = new SensorSample();
	  this.currentGyroMeasurement = new SensorSample();
	  this.previousGyroMeasurement = new SensorSample();
	
	  // Current filter orientation
	  this.filterQ = new THREE.Quaternion();
	  this.previousFilterQ = new THREE.Quaternion();
	
	  // Orientation based on the accelerometer.
	  this.accelQ = new THREE.Quaternion();
	  // Whether or not the orientation has been initialized.
	  this.isOrientationInitialized = false;
	  // Running estimate of gravity based on the current orientation.
	  this.estimatedGravity = new THREE.Vector3();
	  // Measured gravity based on accelerometer.
	  this.measuredGravity = new THREE.Vector3();
	
	  // Debug only quaternion of gyro-based orientation.
	  this.gyroIntegralQ = new THREE.Quaternion();
	}
	
	ComplementaryFilter.prototype.addAccelMeasurement = function(vector, timestampS) {
	  this.currentAccelMeasurement.set(vector, timestampS);
	};
	
	ComplementaryFilter.prototype.addGyroMeasurement = function(vector, timestampS) {
	  this.currentGyroMeasurement.set(vector, timestampS);
	
	  var deltaT = timestampS - this.previousGyroMeasurement.timestampS;
	  if (Util.isTimestampDeltaValid(deltaT)) {
	    this.run_();
	  }
	  
	  this.previousGyroMeasurement.copy(this.currentGyroMeasurement);
	};
	
	ComplementaryFilter.prototype.run_ = function() {
	
	  if (!this.isOrientationInitialized) {
	    this.accelQ = this.accelToQuaternion_(this.currentAccelMeasurement.sample);
	    this.previousFilterQ.copy(this.accelQ);
	    this.isOrientationInitialized = true;
	    return;
	  }
	
	  var deltaT = this.currentGyroMeasurement.timestampS -
	      this.previousGyroMeasurement.timestampS;
	
	  // Convert gyro rotation vector to a quaternion delta.
	  var gyroDeltaQ = this.gyroToQuaternionDelta_(this.currentGyroMeasurement.sample, deltaT);
	  this.gyroIntegralQ.multiply(gyroDeltaQ);
	
	  // filter_1 = K * (filter_0 + gyro * dT) + (1 - K) * accel.
	  this.filterQ.copy(this.previousFilterQ);
	  this.filterQ.multiply(gyroDeltaQ);
	
	  // Calculate the delta between the current estimated gravity and the real
	  // gravity vector from accelerometer.
	  var invFilterQ = new THREE.Quaternion();
	  invFilterQ.copy(this.filterQ);
	  invFilterQ.inverse();
	
	  this.estimatedGravity.set(0, 0, -1);
	  this.estimatedGravity.applyQuaternion(invFilterQ);
	  this.estimatedGravity.normalize();
	
	  this.measuredGravity.copy(this.currentAccelMeasurement.sample);
	  this.measuredGravity.normalize();
	
	  // Compare estimated gravity with measured gravity, get the delta quaternion
	  // between the two.
	  var deltaQ = new THREE.Quaternion();
	  deltaQ.setFromUnitVectors(this.estimatedGravity, this.measuredGravity);
	  deltaQ.inverse();
	
	  if (DEBUG) {
	    console.log('Delta: %d deg, G_est: (%s, %s, %s), G_meas: (%s, %s, %s)',
	                THREE.Math.radToDeg(Util.getQuaternionAngle(deltaQ)),
	                (this.estimatedGravity.x).toFixed(1),
	                (this.estimatedGravity.y).toFixed(1),
	                (this.estimatedGravity.z).toFixed(1),
	                (this.measuredGravity.x).toFixed(1),
	                (this.measuredGravity.y).toFixed(1),
	                (this.measuredGravity.z).toFixed(1));
	  }
	
	  // Calculate the SLERP target: current orientation plus the measured-estimated
	  // quaternion delta.
	  var targetQ = new THREE.Quaternion();
	  targetQ.copy(this.filterQ);
	  targetQ.multiply(deltaQ);
	
	  // SLERP factor: 0 is pure gyro, 1 is pure accel.
	  this.filterQ.slerp(targetQ, 1 - this.kFilter);
	
	  this.previousFilterQ.copy(this.filterQ);
	};
	
	ComplementaryFilter.prototype.getOrientation = function() {
	  return this.filterQ;
	};
	
	ComplementaryFilter.prototype.accelToQuaternion_ = function(accel) {
	  var normAccel = new THREE.Vector3();
	  normAccel.copy(accel);
	  normAccel.normalize();
	  var quat = new THREE.Quaternion();
	  quat.setFromUnitVectors(new THREE.Vector3(0, 0, -1), normAccel);
	  quat.inverse();
	  return quat;
	};
	
	ComplementaryFilter.prototype.gyroToQuaternionDelta_ = function(gyro, dt) {
	  // Extract axis and angle from the gyroscope data.
	  var quat = new THREE.Quaternion();
	  var axis = new THREE.Vector3();
	  axis.copy(gyro);
	  axis.normalize();
	  quat.setFromAxisAngle(axis, gyro.length() * dt);
	  return quat;
	};
	
	
	module.exports = ComplementaryFilter;
	
	},{"./sensor-sample.js":8,"./three-math.js":9,"./util.js":11}],4:[function(_dereq_,module,exports){
	/*
	 * Copyright 2015 Google Inc. All Rights Reserved.
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var PositionSensorVRDevice = _dereq_('./base.js').PositionSensorVRDevice;
	
	var ComplementaryFilter = _dereq_('./complementary-filter.js');
	var PosePredictor = _dereq_('./pose-predictor.js');
	var TouchPanner = _dereq_('./touch-panner.js');
	var THREE = _dereq_('./three-math.js');
	var Util = _dereq_('./util.js');
	
	/**
	 * The positional sensor, implemented using DeviceMotion APIs.
	 */
	function FusionPositionSensorVRDevice() {
	  this.deviceId = 'webvr-polyfill:fused';
	  this.deviceName = 'VR Position Device (webvr-polyfill:fused)';
	
	  this.accelerometer = new THREE.Vector3();
	  this.gyroscope = new THREE.Vector3();
	
	  window.addEventListener('devicemotion', this.onDeviceMotionChange_.bind(this));
	  window.addEventListener('orientationchange', this.onScreenOrientationChange_.bind(this));
	
	  this.filter = new ComplementaryFilter(WebVRConfig.K_FILTER || 0.98);
	  this.posePredictor = new PosePredictor(WebVRConfig.PREDICTION_TIME_S || 0.040);
	  this.touchPanner = new TouchPanner();
	
	  this.filterToWorldQ = new THREE.Quaternion();
	
	  // Set the filter to world transform, depending on OS.
	  if (Util.isIOS()) {
	    this.filterToWorldQ.setFromAxisAngle(new THREE.Vector3(1, 0, 0), Math.PI/2);
	  } else {
	    this.filterToWorldQ.setFromAxisAngle(new THREE.Vector3(1, 0, 0), -Math.PI/2);
	  }
	
	  this.worldToScreenQ = new THREE.Quaternion();
	  this.setScreenTransform_();
	
	  // Keep track of a reset transform for resetSensor.
	  this.resetQ = new THREE.Quaternion();
	
	  this.isFirefoxAndroid = Util.isFirefoxAndroid();
	  this.isIOS = Util.isIOS();
	}
	FusionPositionSensorVRDevice.prototype = new PositionSensorVRDevice();
	
	/**
	 * Returns {orientation: {x,y,z,w}, position: null}.
	 * Position is not supported since we can't do 6DOF.
	 */
	FusionPositionSensorVRDevice.prototype.getState = function() {
	  return {
	    hasOrientation: true,
	    orientation: this.getOrientation(),
	    hasPosition: false,
	    position: null
	  }
	};
	
	FusionPositionSensorVRDevice.prototype.getOrientation = function() {
	  // Convert from filter space to the the same system used by the
	  // deviceorientation event.
	  var orientation = this.filter.getOrientation();
	
	  // Predict orientation.
	  this.predictedQ = this.posePredictor.getPrediction(orientation, this.gyroscope, this.previousTimestampS);
	
	  // Convert to THREE coordinate system: -Z forward, Y up, X right.
	  var out = new THREE.Quaternion();
	  out.copy(this.filterToWorldQ);
	  out.multiply(this.resetQ);
	  if (!WebVRConfig.TOUCH_PANNER_DISABLED) {
	    out.multiply(this.touchPanner.getOrientation());
	  }
	  out.multiply(this.predictedQ);
	  out.multiply(this.worldToScreenQ);
	
	  // Handle the yaw-only case.
	  if (WebVRConfig.YAW_ONLY) {
	    // Make a quaternion that only turns around the Y-axis.
	    out.x = 0;
	    out.z = 0;
	    out.normalize();
	  }
	  return out;
	};
	
	FusionPositionSensorVRDevice.prototype.resetSensor = function() {
	  var euler = new THREE.Euler();
	  euler.setFromQuaternion(this.filter.getOrientation());
	  var yaw = euler.y;
	  console.log('resetSensor with yaw: %f', yaw);
	  this.resetQ.setFromAxisAngle(new THREE.Vector3(0, 0, 1), -yaw);
	  if (!WebVRConfig.TOUCH_PANNER_DISABLED) {
	    this.touchPanner.resetSensor();
	  }
	};
	
	FusionPositionSensorVRDevice.prototype.onDeviceMotionChange_ = function(deviceMotion) {
	  var accGravity = deviceMotion.accelerationIncludingGravity;
	  var rotRate = deviceMotion.rotationRate;
	  var timestampS = deviceMotion.timeStamp / 1000;
	
	  // Firefox Android timeStamp returns one thousandth of a millisecond.
	  if (this.isFirefoxAndroid) {
	    timestampS /= 1000;
	  }
	
	  var deltaS = timestampS - this.previousTimestampS;
	  if (deltaS <= Util.MIN_TIMESTEP || deltaS > Util.MAX_TIMESTEP) {
	    console.warn('Invalid timestamps detected. Time step between successive ' +
	                 'gyroscope sensor samples is very small or not monotonic');
	    this.previousTimestampS = timestampS;
	    return;
	  }
	  this.accelerometer.set(-accGravity.x, -accGravity.y, -accGravity.z);
	  this.gyroscope.set(rotRate.alpha, rotRate.beta, rotRate.gamma);
	
	  // With iOS and Firefox Android, rotationRate is reported in degrees,
	  // so we first convert to radians.
	  if (this.isIOS || this.isFirefoxAndroid) {
	    this.gyroscope.multiplyScalar(Math.PI / 180);
	  }
	
	  this.filter.addAccelMeasurement(this.accelerometer, timestampS);
	  this.filter.addGyroMeasurement(this.gyroscope, timestampS);
	
	  this.previousTimestampS = timestampS;
	};
	
	FusionPositionSensorVRDevice.prototype.onScreenOrientationChange_ =
	    function(screenOrientation) {
	  this.setScreenTransform_();
	};
	
	FusionPositionSensorVRDevice.prototype.setScreenTransform_ = function() {
	  this.worldToScreenQ.set(0, 0, 0, 1);
	  switch (window.orientation) {
	    case 0:
	      break;
	    case 90:
	      this.worldToScreenQ.setFromAxisAngle(new THREE.Vector3(0, 0, 1), -Math.PI/2);
	      break;
	    case -90:
	      this.worldToScreenQ.setFromAxisAngle(new THREE.Vector3(0, 0, 1), Math.PI/2);
	      break;
	    case 180:
	      // TODO.
	      break;
	  }
	};
	
	
	module.exports = FusionPositionSensorVRDevice;
	
	},{"./base.js":1,"./complementary-filter.js":3,"./pose-predictor.js":7,"./three-math.js":9,"./touch-panner.js":10,"./util.js":11}],5:[function(_dereq_,module,exports){
	/*
	 * Copyright 2015 Google Inc. All Rights Reserved.
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var WebVRPolyfill = _dereq_('./webvr-polyfill.js');
	
	// Initialize a WebVRConfig just in case.
	window.WebVRConfig = window.WebVRConfig || {};
	new WebVRPolyfill();
	
	},{"./webvr-polyfill.js":12}],6:[function(_dereq_,module,exports){
	/*
	 * Copyright 2015 Google Inc. All Rights Reserved.
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var PositionSensorVRDevice = _dereq_('./base.js').PositionSensorVRDevice;
	var THREE = _dereq_('./three-math.js');
	var Util = _dereq_('./util.js');
	
	// How much to rotate per key stroke.
	var KEY_SPEED = 0.15;
	var KEY_ANIMATION_DURATION = 80;
	
	// How much to rotate for mouse events.
	var MOUSE_SPEED_X = 0.5;
	var MOUSE_SPEED_Y = 0.3;
	
	/**
	 * A virtual position sensor, implemented using keyboard and
	 * mouse APIs. This is designed as for desktops/laptops where no Device*
	 * events work.
	 */
	function MouseKeyboardPositionSensorVRDevice() {
	  this.deviceId = 'webvr-polyfill:mouse-keyboard';
	  this.deviceName = 'VR Position Device (webvr-polyfill:mouse-keyboard)';
	
	  // Attach to mouse and keyboard events.
	  window.addEventListener('keydown', this.onKeyDown_.bind(this));
	  window.addEventListener('mousemove', this.onMouseMove_.bind(this));
	  window.addEventListener('mousedown', this.onMouseDown_.bind(this));
	  window.addEventListener('mouseup', this.onMouseUp_.bind(this));
	
	  this.phi = 0;
	  this.theta = 0;
	
	  // Variables for keyboard-based rotation animation.
	  this.targetAngle = null;
	
	  // State variables for calculations.
	  this.euler = new THREE.Euler();
	  this.orientation = new THREE.Quaternion();
	
	  // Variables for mouse-based rotation.
	  this.rotateStart = new THREE.Vector2();
	  this.rotateEnd = new THREE.Vector2();
	  this.rotateDelta = new THREE.Vector2();
	}
	MouseKeyboardPositionSensorVRDevice.prototype = new PositionSensorVRDevice();
	
	/**
	 * Returns {orientation: {x,y,z,w}, position: null}.
	 * Position is not supported for parity with other PositionSensors.
	 */
	MouseKeyboardPositionSensorVRDevice.prototype.getState = function() {
	  this.euler.set(this.phi, this.theta, 0, 'YXZ');
	  this.orientation.setFromEuler(this.euler);
	
	  return {
	    hasOrientation: true,
	    orientation: this.orientation,
	    hasPosition: false,
	    position: null
	  }
	};
	
	MouseKeyboardPositionSensorVRDevice.prototype.onKeyDown_ = function(e) {
	  // Track WASD and arrow keys.
	  if (e.keyCode == 38) { // Up key.
	    this.animatePhi_(this.phi + KEY_SPEED);
	  } else if (e.keyCode == 39) { // Right key.
	    this.animateTheta_(this.theta - KEY_SPEED);
	  } else if (e.keyCode == 40) { // Down key.
	    this.animatePhi_(this.phi - KEY_SPEED);
	  } else if (e.keyCode == 37) { // Left key.
	    this.animateTheta_(this.theta + KEY_SPEED);
	  }
	};
	
	MouseKeyboardPositionSensorVRDevice.prototype.animateTheta_ = function(targetAngle) {
	  this.animateKeyTransitions_('theta', targetAngle);
	};
	
	MouseKeyboardPositionSensorVRDevice.prototype.animatePhi_ = function(targetAngle) {
	  // Prevent looking too far up or down.
	  targetAngle = Util.clamp(targetAngle, -Math.PI/2, Math.PI/2);
	  this.animateKeyTransitions_('phi', targetAngle);
	};
	
	/**
	 * Start an animation to transition an angle from one value to another.
	 */
	MouseKeyboardPositionSensorVRDevice.prototype.animateKeyTransitions_ = function(angleName, targetAngle) {
	  // If an animation is currently running, cancel it.
	  if (this.angleAnimation) {
	    clearInterval(this.angleAnimation);
	  }
	  var startAngle = this[angleName];
	  var startTime = new Date();
	  // Set up an interval timer to perform the animation.
	  this.angleAnimation = setInterval(function() {
	    // Once we're finished the animation, we're done.
	    var elapsed = new Date() - startTime;
	    if (elapsed >= KEY_ANIMATION_DURATION) {
	      this[angleName] = targetAngle;
	      clearInterval(this.angleAnimation);
	      return;
	    }
	    // Linearly interpolate the angle some amount.
	    var percent = elapsed / KEY_ANIMATION_DURATION;
	    this[angleName] = startAngle + (targetAngle - startAngle) * percent;
	  }.bind(this), 1000/60);
	};
	
	MouseKeyboardPositionSensorVRDevice.prototype.onMouseDown_ = function(e) {
	  this.rotateStart.set(e.clientX, e.clientY);
	  this.isDragging = true;
	};
	
	// Very similar to https://gist.github.com/mrflix/8351020
	MouseKeyboardPositionSensorVRDevice.prototype.onMouseMove_ = function(e) {
	  if (!this.isDragging && !this.isPointerLocked_()) {
	    return;
	  }
	  // Support pointer lock API.
	  if (this.isPointerLocked_()) {
	    var movementX = e.movementX || e.mozMovementX || 0;
	    var movementY = e.movementY || e.mozMovementY || 0;
	    this.rotateEnd.set(this.rotateStart.x - movementX, this.rotateStart.y - movementY);
	  } else {
	    this.rotateEnd.set(e.clientX, e.clientY);
	  }
	  // Calculate how much we moved in mouse space.
	  this.rotateDelta.subVectors(this.rotateEnd, this.rotateStart);
	  this.rotateStart.copy(this.rotateEnd);
	
	  // Keep track of the cumulative euler angles.
	  var element = document.body;
	  this.phi += 2 * Math.PI * this.rotateDelta.y / element.clientHeight * MOUSE_SPEED_Y;
	  this.theta += 2 * Math.PI * this.rotateDelta.x / element.clientWidth * MOUSE_SPEED_X;
	
	  // Prevent looking too far up or down.
	  this.phi = Util.clamp(this.phi, -Math.PI/2, Math.PI/2);
	};
	
	MouseKeyboardPositionSensorVRDevice.prototype.onMouseUp_ = function(e) {
	  this.isDragging = false;
	};
	
	MouseKeyboardPositionSensorVRDevice.prototype.isPointerLocked_ = function() {
	  var el = document.pointerLockElement || document.mozPointerLockElement ||
	      document.webkitPointerLockElement;
	  return el !== undefined;
	};
	
	MouseKeyboardPositionSensorVRDevice.prototype.resetSensor = function() {
	  console.error('Not implemented yet.');
	};
	
	module.exports = MouseKeyboardPositionSensorVRDevice;
	
	},{"./base.js":1,"./three-math.js":9,"./util.js":11}],7:[function(_dereq_,module,exports){
	/*
	 * Copyright 2015 Google Inc. All Rights Reserved.
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var THREE = _dereq_('./three-math.js');
	
	var DEBUG = false;
	
	/**
	 * Given an orientation and the gyroscope data, predicts the future orientation
	 * of the head. This makes rendering appear faster.
	 *
	 * Also see: http://msl.cs.uiuc.edu/~lavalle/papers/LavYerKatAnt14.pdf
	 *
	 * @param {Number} predictionTimeS time from head movement to the appearance of
	 * the corresponding image.
	 */
	function PosePredictor(predictionTimeS) {
	  this.predictionTimeS = predictionTimeS;
	
	  // The quaternion corresponding to the previous state.
	  this.previousQ = new THREE.Quaternion();
	  // Previous time a prediction occurred.
	  this.previousTimestampS = null;
	
	  // The delta quaternion that adjusts the current pose.
	  this.deltaQ = new THREE.Quaternion();
	  // The output quaternion.
	  this.outQ = new THREE.Quaternion();
	}
	
	PosePredictor.prototype.getPrediction = function(currentQ, gyro, timestampS) {
	  if (!this.previousTimestampS) {
	    this.previousQ.copy(currentQ);
	    this.previousTimestampS = timestampS;
	    return currentQ;
	  }
	
	  // Calculate axis and angle based on gyroscope rotation rate data.
	  var axis = new THREE.Vector3();
	  axis.copy(gyro);
	  axis.normalize();
	
	  var angularSpeed = gyro.length();
	
	  // If we're rotating slowly, don't do prediction.
	  if (angularSpeed < THREE.Math.degToRad(20)) {
	    if (DEBUG) {
	      console.log('Moving slowly, at %s deg/s: no prediction',
	                  THREE.Math.radToDeg(angularSpeed).toFixed(1));
	    }
	    this.outQ.copy(currentQ);
	    this.previousQ.copy(currentQ);
	    return this.outQ;
	  }
	
	  // Get the predicted angle based on the time delta and latency.
	  var deltaT = timestampS - this.previousTimestampS;
	  var predictAngle = angularSpeed * this.predictionTimeS;
	
	  this.deltaQ.setFromAxisAngle(axis, predictAngle);
	  this.outQ.copy(this.previousQ);
	  this.outQ.multiply(this.deltaQ);
	
	  this.previousQ.copy(currentQ);
	
	  return this.outQ;
	};
	
	
	module.exports = PosePredictor;
	
	},{"./three-math.js":9}],8:[function(_dereq_,module,exports){
	function SensorSample(sample, timestampS) {
	  this.set(sample, timestampS);
	};
	
	SensorSample.prototype.set = function(sample, timestampS) {
	  this.sample = sample;
	  this.timestampS = timestampS;
	};
	
	SensorSample.prototype.copy = function(sensorSample) {
	  this.set(sensorSample.sample, sensorSample.timestampS);
	};
	
	module.exports = SensorSample;
	
	},{}],9:[function(_dereq_,module,exports){
	/*
	 * A subset of THREE.js, providing mostly quaternion and euler-related
	 * operations, manually lifted from
	 * https://github.com/mrdoob/three.js/tree/master/src/math, as of 9c30286b38df039fca389989ff06ea1c15d6bad1
	 */
	
	// Only use if the real THREE is not provided.
	var THREE = window.THREE || {};
	
	// If some piece of THREE is missing, fill it in here.
	if (!THREE.Quaternion || !THREE.Vector3 || !THREE.Vector2 || !THREE.Euler || !THREE.Math) {
	console.log('No THREE.js found.');
	
	
	/*** START Quaternion ***/
	
	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://exocortex.com
	 */
	
	THREE.Quaternion = function ( x, y, z, w ) {
	
		this._x = x || 0;
		this._y = y || 0;
		this._z = z || 0;
		this._w = ( w !== undefined ) ? w : 1;
	
	};
	
	THREE.Quaternion.prototype = {
	
		constructor: THREE.Quaternion,
	
		_x: 0,_y: 0, _z: 0, _w: 0,
	
		get x () {
	
			return this._x;
	
		},
	
		set x ( value ) {
	
			this._x = value;
			this.onChangeCallback();
	
		},
	
		get y () {
	
			return this._y;
	
		},
	
		set y ( value ) {
	
			this._y = value;
			this.onChangeCallback();
	
		},
	
		get z () {
	
			return this._z;
	
		},
	
		set z ( value ) {
	
			this._z = value;
			this.onChangeCallback();
	
		},
	
		get w () {
	
			return this._w;
	
		},
	
		set w ( value ) {
	
			this._w = value;
			this.onChangeCallback();
	
		},
	
		set: function ( x, y, z, w ) {
	
			this._x = x;
			this._y = y;
			this._z = z;
			this._w = w;
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		copy: function ( quaternion ) {
	
			this._x = quaternion.x;
			this._y = quaternion.y;
			this._z = quaternion.z;
			this._w = quaternion.w;
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		setFromEuler: function ( euler, update ) {
	
			if ( euler instanceof THREE.Euler === false ) {
	
				throw new Error( 'THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );
			}
	
			// http://www.mathworks.com/matlabcentral/fileexchange/
			// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
			//	content/SpinCalc.m
	
			var c1 = Math.cos( euler._x / 2 );
			var c2 = Math.cos( euler._y / 2 );
			var c3 = Math.cos( euler._z / 2 );
			var s1 = Math.sin( euler._x / 2 );
			var s2 = Math.sin( euler._y / 2 );
			var s3 = Math.sin( euler._z / 2 );
	
			if ( euler.order === 'XYZ' ) {
	
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
	
			} else if ( euler.order === 'YXZ' ) {
	
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
	
			} else if ( euler.order === 'ZXY' ) {
	
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
	
			} else if ( euler.order === 'ZYX' ) {
	
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
	
			} else if ( euler.order === 'YZX' ) {
	
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
	
			} else if ( euler.order === 'XZY' ) {
	
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
	
			}
	
			if ( update !== false ) this.onChangeCallback();
	
			return this;
	
		},
	
		setFromAxisAngle: function ( axis, angle ) {
	
			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
	
			// assumes axis is normalized
	
			var halfAngle = angle / 2, s = Math.sin( halfAngle );
	
			this._x = axis.x * s;
			this._y = axis.y * s;
			this._z = axis.z * s;
			this._w = Math.cos( halfAngle );
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		setFromRotationMatrix: function ( m ) {
	
			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
	
			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
	
			var te = m.elements,
	
				m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
				m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
				m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],
	
				trace = m11 + m22 + m33,
				s;
	
			if ( trace > 0 ) {
	
				s = 0.5 / Math.sqrt( trace + 1.0 );
	
				this._w = 0.25 / s;
				this._x = ( m32 - m23 ) * s;
				this._y = ( m13 - m31 ) * s;
				this._z = ( m21 - m12 ) * s;
	
			} else if ( m11 > m22 && m11 > m33 ) {
	
				s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );
	
				this._w = ( m32 - m23 ) / s;
				this._x = 0.25 * s;
				this._y = ( m12 + m21 ) / s;
				this._z = ( m13 + m31 ) / s;
	
			} else if ( m22 > m33 ) {
	
				s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );
	
				this._w = ( m13 - m31 ) / s;
				this._x = ( m12 + m21 ) / s;
				this._y = 0.25 * s;
				this._z = ( m23 + m32 ) / s;
	
			} else {
	
				s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );
	
				this._w = ( m21 - m12 ) / s;
				this._x = ( m13 + m31 ) / s;
				this._y = ( m23 + m32 ) / s;
				this._z = 0.25 * s;
	
			}
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		setFromUnitVectors: function () {
	
			// http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final
	
			// assumes direction vectors vFrom and vTo are normalized
	
			var v1, r;
	
			var EPS = 0.000001;
	
			return function ( vFrom, vTo ) {
	
				if ( v1 === undefined ) v1 = new THREE.Vector3();
	
				r = vFrom.dot( vTo ) + 1;
	
				if ( r < EPS ) {
	
					r = 0;
	
					if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {
	
						v1.set( - vFrom.y, vFrom.x, 0 );
	
					} else {
	
						v1.set( 0, - vFrom.z, vFrom.y );
	
					}
	
				} else {
	
					v1.crossVectors( vFrom, vTo );
	
				}
	
				this._x = v1.x;
				this._y = v1.y;
				this._z = v1.z;
				this._w = r;
	
				this.normalize();
	
				return this;
	
			}
	
		}(),
	
		inverse: function () {
	
			this.conjugate().normalize();
	
			return this;
	
		},
	
		conjugate: function () {
	
			this._x *= - 1;
			this._y *= - 1;
			this._z *= - 1;
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		dot: function ( v ) {
	
			return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
	
		},
	
		lengthSq: function () {
	
			return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
	
		},
	
		length: function () {
	
			return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );
	
		},
	
		normalize: function () {
	
			var l = this.length();
	
			if ( l === 0 ) {
	
				this._x = 0;
				this._y = 0;
				this._z = 0;
				this._w = 1;
	
			} else {
	
				l = 1 / l;
	
				this._x = this._x * l;
				this._y = this._y * l;
				this._z = this._z * l;
				this._w = this._w * l;
	
			}
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		multiply: function ( q, p ) {
	
			if ( p !== undefined ) {
	
				console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
				return this.multiplyQuaternions( q, p );
	
			}
	
			return this.multiplyQuaternions( this, q );
	
		},
	
		multiplyQuaternions: function ( a, b ) {
	
			// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
	
			var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
			var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
	
			this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
			this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
			this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
			this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		multiplyVector3: function ( vector ) {
	
			console.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
			return vector.applyQuaternion( this );
	
		},
	
		slerp: function ( qb, t ) {
	
			if ( t === 0 ) return this;
			if ( t === 1 ) return this.copy( qb );
	
			var x = this._x, y = this._y, z = this._z, w = this._w;
	
			// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/
	
			var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
	
			if ( cosHalfTheta < 0 ) {
	
				this._w = - qb._w;
				this._x = - qb._x;
				this._y = - qb._y;
				this._z = - qb._z;
	
				cosHalfTheta = - cosHalfTheta;
	
			} else {
	
				this.copy( qb );
	
			}
	
			if ( cosHalfTheta >= 1.0 ) {
	
				this._w = w;
				this._x = x;
				this._y = y;
				this._z = z;
	
				return this;
	
			}
	
			var halfTheta = Math.acos( cosHalfTheta );
			var sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );
	
			if ( Math.abs( sinHalfTheta ) < 0.001 ) {
	
				this._w = 0.5 * ( w + this._w );
				this._x = 0.5 * ( x + this._x );
				this._y = 0.5 * ( y + this._y );
				this._z = 0.5 * ( z + this._z );
	
				return this;
	
			}
	
			var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
			ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;
	
			this._w = ( w * ratioA + this._w * ratioB );
			this._x = ( x * ratioA + this._x * ratioB );
			this._y = ( y * ratioA + this._y * ratioB );
			this._z = ( z * ratioA + this._z * ratioB );
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		equals: function ( quaternion ) {
	
			return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );
	
		},
	
		fromArray: function ( array, offset ) {
	
			if ( offset === undefined ) offset = 0;
	
			this._x = array[ offset ];
			this._y = array[ offset + 1 ];
			this._z = array[ offset + 2 ];
			this._w = array[ offset + 3 ];
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		toArray: function ( array, offset ) {
	
			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;
	
			array[ offset ] = this._x;
			array[ offset + 1 ] = this._y;
			array[ offset + 2 ] = this._z;
			array[ offset + 3 ] = this._w;
	
			return array;
	
		},
	
		onChange: function ( callback ) {
	
			this.onChangeCallback = callback;
	
			return this;
	
		},
	
		onChangeCallback: function () {},
	
		clone: function () {
	
			return new THREE.Quaternion( this._x, this._y, this._z, this._w );
	
		}
	
	};
	
	THREE.Quaternion.slerp = function ( qa, qb, qm, t ) {
	
		return qm.copy( qa ).slerp( qb, t );
	
	}
	
	/*** END Quaternion ***/
	/*** START Vector2 ***/
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author philogb / http://blog.thejit.org/
	 * @author egraether / http://egraether.com/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 */
	
	THREE.Vector2 = function ( x, y ) {
	
		this.x = x || 0;
		this.y = y || 0;
	
	};
	
	THREE.Vector2.prototype = {
	
		constructor: THREE.Vector2,
	
		set: function ( x, y ) {
	
			this.x = x;
			this.y = y;
	
			return this;
	
		},
	
		setX: function ( x ) {
	
			this.x = x;
	
			return this;
	
		},
	
		setY: function ( y ) {
	
			this.y = y;
	
			return this;
	
		},
	
		setComponent: function ( index, value ) {
	
			switch ( index ) {
	
				case 0: this.x = value; break;
				case 1: this.y = value; break;
				default: throw new Error( 'index is out of range: ' + index );
	
			}
	
		},
	
		getComponent: function ( index ) {
	
			switch ( index ) {
	
				case 0: return this.x;
				case 1: return this.y;
				default: throw new Error( 'index is out of range: ' + index );
	
			}
	
		},
	
		copy: function ( v ) {
	
			this.x = v.x;
			this.y = v.y;
	
			return this;
	
		},
	
		add: function ( v, w ) {
	
			if ( w !== undefined ) {
	
				console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );
	
			}
	
			this.x += v.x;
			this.y += v.y;
	
			return this;
	
		},
	
		addVectors: function ( a, b ) {
	
			this.x = a.x + b.x;
			this.y = a.y + b.y;
	
			return this;
	
		},
	
		addScalar: function ( s ) {
	
			this.x += s;
			this.y += s;
	
			return this;
	
		},
	
		sub: function ( v, w ) {
	
			if ( w !== undefined ) {
	
				console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );
	
			}
	
			this.x -= v.x;
			this.y -= v.y;
	
			return this;
	
		},
	
		subVectors: function ( a, b ) {
	
			this.x = a.x - b.x;
			this.y = a.y - b.y;
	
			return this;
	
		},
	
		multiply: function ( v ) {
	
			this.x *= v.x;
			this.y *= v.y;
	
			return this;
	
		},
	
		multiplyScalar: function ( s ) {
	
			this.x *= s;
			this.y *= s;
	
			return this;
	
		},
	
		divide: function ( v ) {
	
			this.x /= v.x;
			this.y /= v.y;
	
			return this;
	
		},
	
		divideScalar: function ( scalar ) {
	
			if ( scalar !== 0 ) {
	
				var invScalar = 1 / scalar;
	
				this.x *= invScalar;
				this.y *= invScalar;
	
			} else {
	
				this.x = 0;
				this.y = 0;
	
			}
	
			return this;
	
		},
	
		min: function ( v ) {
	
			if ( this.x > v.x ) {
	
				this.x = v.x;
	
			}
	
			if ( this.y > v.y ) {
	
				this.y = v.y;
	
			}
	
			return this;
	
		},
	
		max: function ( v ) {
	
			if ( this.x < v.x ) {
	
				this.x = v.x;
	
			}
	
			if ( this.y < v.y ) {
	
				this.y = v.y;
	
			}
	
			return this;
	
		},
	
		clamp: function ( min, max ) {
	
			// This function assumes min < max, if this assumption isn't true it will not operate correctly
	
			if ( this.x < min.x ) {
	
				this.x = min.x;
	
			} else if ( this.x > max.x ) {
	
				this.x = max.x;
	
			}
	
			if ( this.y < min.y ) {
	
				this.y = min.y;
	
			} else if ( this.y > max.y ) {
	
				this.y = max.y;
	
			}
	
			return this;
		},
	
		clampScalar: ( function () {
	
			var min, max;
	
			return function ( minVal, maxVal ) {
	
				if ( min === undefined ) {
	
					min = new THREE.Vector2();
					max = new THREE.Vector2();
	
				}
	
				min.set( minVal, minVal );
				max.set( maxVal, maxVal );
	
				return this.clamp( min, max );
	
			};
	
		} )(),
	
		floor: function () {
	
			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );
	
			return this;
	
		},
	
		ceil: function () {
	
			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );
	
			return this;
	
		},
	
		round: function () {
	
			this.x = Math.round( this.x );
			this.y = Math.round( this.y );
	
			return this;
	
		},
	
		roundToZero: function () {
	
			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
	
			return this;
	
		},
	
		negate: function () {
	
			this.x = - this.x;
			this.y = - this.y;
	
			return this;
	
		},
	
		dot: function ( v ) {
	
			return this.x * v.x + this.y * v.y;
	
		},
	
		lengthSq: function () {
	
			return this.x * this.x + this.y * this.y;
	
		},
	
		length: function () {
	
			return Math.sqrt( this.x * this.x + this.y * this.y );
	
		},
	
		normalize: function () {
	
			return this.divideScalar( this.length() );
	
		},
	
		distanceTo: function ( v ) {
	
			return Math.sqrt( this.distanceToSquared( v ) );
	
		},
	
		distanceToSquared: function ( v ) {
	
			var dx = this.x - v.x, dy = this.y - v.y;
			return dx * dx + dy * dy;
	
		},
	
		setLength: function ( l ) {
	
			var oldLength = this.length();
	
			if ( oldLength !== 0 && l !== oldLength ) {
	
				this.multiplyScalar( l / oldLength );
			}
	
			return this;
	
		},
	
		lerp: function ( v, alpha ) {
	
			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;
	
			return this;
	
		},
	
		equals: function ( v ) {
	
			return ( ( v.x === this.x ) && ( v.y === this.y ) );
	
		},
	
		fromArray: function ( array, offset ) {
	
			if ( offset === undefined ) offset = 0;
	
			this.x = array[ offset ];
			this.y = array[ offset + 1 ];
	
			return this;
	
		},
	
		toArray: function ( array, offset ) {
	
			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;
	
			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;
	
			return array;
	
		},
	
		fromAttribute: function ( attribute, index, offset ) {
	
		    if ( offset === undefined ) offset = 0;
	
		    index = index * attribute.itemSize + offset;
	
		    this.x = attribute.array[ index ];
		    this.y = attribute.array[ index + 1 ];
	
		    return this;
	
		},
	
		clone: function () {
	
			return new THREE.Vector2( this.x, this.y );
	
		}
	
	};
	/*** END Vector2 ***/
	/*** START Vector3 ***/
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author *kile / http://kile.stravaganza.org/
	 * @author philogb / http://blog.thejit.org/
	 * @author mikael emtinger / http://gomo.se/
	 * @author egraether / http://egraether.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */
	
	THREE.Vector3 = function ( x, y, z ) {
	
		this.x = x || 0;
		this.y = y || 0;
		this.z = z || 0;
	
	};
	
	THREE.Vector3.prototype = {
	
		constructor: THREE.Vector3,
	
		set: function ( x, y, z ) {
	
			this.x = x;
			this.y = y;
			this.z = z;
	
			return this;
	
		},
	
		setX: function ( x ) {
	
			this.x = x;
	
			return this;
	
		},
	
		setY: function ( y ) {
	
			this.y = y;
	
			return this;
	
		},
	
		setZ: function ( z ) {
	
			this.z = z;
	
			return this;
	
		},
	
		setComponent: function ( index, value ) {
	
			switch ( index ) {
	
				case 0: this.x = value; break;
				case 1: this.y = value; break;
				case 2: this.z = value; break;
				default: throw new Error( 'index is out of range: ' + index );
	
			}
	
		},
	
		getComponent: function ( index ) {
	
			switch ( index ) {
	
				case 0: return this.x;
				case 1: return this.y;
				case 2: return this.z;
				default: throw new Error( 'index is out of range: ' + index );
	
			}
	
		},
	
		copy: function ( v ) {
	
			this.x = v.x;
			this.y = v.y;
			this.z = v.z;
	
			return this;
	
		},
	
		add: function ( v, w ) {
	
			if ( w !== undefined ) {
	
				console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );
	
			}
	
			this.x += v.x;
			this.y += v.y;
			this.z += v.z;
	
			return this;
	
		},
	
		addScalar: function ( s ) {
	
			this.x += s;
			this.y += s;
			this.z += s;
	
			return this;
	
		},
	
		addVectors: function ( a, b ) {
	
			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;
	
			return this;
	
		},
	
		sub: function ( v, w ) {
	
			if ( w !== undefined ) {
	
				console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );
	
			}
	
			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;
	
			return this;
	
		},
	
		subVectors: function ( a, b ) {
	
			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;
	
			return this;
	
		},
	
		multiply: function ( v, w ) {
	
			if ( w !== undefined ) {
	
				console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
				return this.multiplyVectors( v, w );
	
			}
	
			this.x *= v.x;
			this.y *= v.y;
			this.z *= v.z;
	
			return this;
	
		},
	
		multiplyScalar: function ( scalar ) {
	
			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;
	
			return this;
	
		},
	
		multiplyVectors: function ( a, b ) {
	
			this.x = a.x * b.x;
			this.y = a.y * b.y;
			this.z = a.z * b.z;
	
			return this;
	
		},
	
		applyEuler: function () {
	
			var quaternion;
	
			return function ( euler ) {
	
				if ( euler instanceof THREE.Euler === false ) {
	
					console.error( 'THREE.Vector3: .applyEuler() now expects a Euler rotation rather than a Vector3 and order.' );
	
				}
	
				if ( quaternion === undefined ) quaternion = new THREE.Quaternion();
	
				this.applyQuaternion( quaternion.setFromEuler( euler ) );
	
				return this;
	
			};
	
		}(),
	
		applyAxisAngle: function () {
	
			var quaternion;
	
			return function ( axis, angle ) {
	
				if ( quaternion === undefined ) quaternion = new THREE.Quaternion();
	
				this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );
	
				return this;
	
			};
	
		}(),
	
		applyMatrix3: function ( m ) {
	
			var x = this.x;
			var y = this.y;
			var z = this.z;
	
			var e = m.elements;
	
			this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
			this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
			this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;
	
			return this;
	
		},
	
		applyMatrix4: function ( m ) {
	
			// input: THREE.Matrix4 affine matrix
	
			var x = this.x, y = this.y, z = this.z;
	
			var e = m.elements;
	
			this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ];
			this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ];
			this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ];
	
			return this;
	
		},
	
		applyProjection: function ( m ) {
	
			// input: THREE.Matrix4 projection matrix
	
			var x = this.x, y = this.y, z = this.z;
	
			var e = m.elements;
			var d = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] ); // perspective divide
	
			this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ] ) * d;
			this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ] ) * d;
			this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * d;
	
			return this;
	
		},
	
		applyQuaternion: function ( q ) {
	
			var x = this.x;
			var y = this.y;
			var z = this.z;
	
			var qx = q.x;
			var qy = q.y;
			var qz = q.z;
			var qw = q.w;
	
			// calculate quat * vector
	
			var ix =  qw * x + qy * z - qz * y;
			var iy =  qw * y + qz * x - qx * z;
			var iz =  qw * z + qx * y - qy * x;
			var iw = - qx * x - qy * y - qz * z;
	
			// calculate result * inverse quat
	
			this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
			this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
			this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;
	
			return this;
	
		},
	
		project: function () {
	
			var matrix;
	
			return function ( camera ) {
	
				if ( matrix === undefined ) matrix = new THREE.Matrix4();
	
				matrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );
				return this.applyProjection( matrix );
	
			};
	
		}(),
	
		unproject: function () {
	
			var matrix;
	
			return function ( camera ) {
	
				if ( matrix === undefined ) matrix = new THREE.Matrix4();
	
				matrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );
				return this.applyProjection( matrix );
	
			};
	
		}(),
	
		transformDirection: function ( m ) {
	
			// input: THREE.Matrix4 affine matrix
			// vector interpreted as a direction
	
			var x = this.x, y = this.y, z = this.z;
	
			var e = m.elements;
	
			this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z;
			this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z;
			this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;
	
			this.normalize();
	
			return this;
	
		},
	
		divide: function ( v ) {
	
			this.x /= v.x;
			this.y /= v.y;
			this.z /= v.z;
	
			return this;
	
		},
	
		divideScalar: function ( scalar ) {
	
			if ( scalar !== 0 ) {
	
				var invScalar = 1 / scalar;
	
				this.x *= invScalar;
				this.y *= invScalar;
				this.z *= invScalar;
	
			} else {
	
				this.x = 0;
				this.y = 0;
				this.z = 0;
	
			}
	
			return this;
	
		},
	
		min: function ( v ) {
	
			if ( this.x > v.x ) {
	
				this.x = v.x;
	
			}
	
			if ( this.y > v.y ) {
	
				this.y = v.y;
	
			}
	
			if ( this.z > v.z ) {
	
				this.z = v.z;
	
			}
	
			return this;
	
		},
	
		max: function ( v ) {
	
			if ( this.x < v.x ) {
	
				this.x = v.x;
	
			}
	
			if ( this.y < v.y ) {
	
				this.y = v.y;
	
			}
	
			if ( this.z < v.z ) {
	
				this.z = v.z;
	
			}
	
			return this;
	
		},
	
		clamp: function ( min, max ) {
	
			// This function assumes min < max, if this assumption isn't true it will not operate correctly
	
			if ( this.x < min.x ) {
	
				this.x = min.x;
	
			} else if ( this.x > max.x ) {
	
				this.x = max.x;
	
			}
	
			if ( this.y < min.y ) {
	
				this.y = min.y;
	
			} else if ( this.y > max.y ) {
	
				this.y = max.y;
	
			}
	
			if ( this.z < min.z ) {
	
				this.z = min.z;
	
			} else if ( this.z > max.z ) {
	
				this.z = max.z;
	
			}
	
			return this;
	
		},
	
		clampScalar: ( function () {
	
			var min, max;
	
			return function ( minVal, maxVal ) {
	
				if ( min === undefined ) {
	
					min = new THREE.Vector3();
					max = new THREE.Vector3();
	
				}
	
				min.set( minVal, minVal, minVal );
				max.set( maxVal, maxVal, maxVal );
	
				return this.clamp( min, max );
	
			};
	
		} )(),
	
		floor: function () {
	
			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );
			this.z = Math.floor( this.z );
	
			return this;
	
		},
	
		ceil: function () {
	
			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );
			this.z = Math.ceil( this.z );
	
			return this;
	
		},
	
		round: function () {
	
			this.x = Math.round( this.x );
			this.y = Math.round( this.y );
			this.z = Math.round( this.z );
	
			return this;
	
		},
	
		roundToZero: function () {
	
			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
			this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
	
			return this;
	
		},
	
		negate: function () {
	
			this.x = - this.x;
			this.y = - this.y;
			this.z = - this.z;
	
			return this;
	
		},
	
		dot: function ( v ) {
	
			return this.x * v.x + this.y * v.y + this.z * v.z;
	
		},
	
		lengthSq: function () {
	
			return this.x * this.x + this.y * this.y + this.z * this.z;
	
		},
	
		length: function () {
	
			return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );
	
		},
	
		lengthManhattan: function () {
	
			return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );
	
		},
	
		normalize: function () {
	
			return this.divideScalar( this.length() );
	
		},
	
		setLength: function ( l ) {
	
			var oldLength = this.length();
	
			if ( oldLength !== 0 && l !== oldLength  ) {
	
				this.multiplyScalar( l / oldLength );
			}
	
			return this;
	
		},
	
		lerp: function ( v, alpha ) {
	
			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;
			this.z += ( v.z - this.z ) * alpha;
	
			return this;
	
		},
	
		cross: function ( v, w ) {
	
			if ( w !== undefined ) {
	
				console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
				return this.crossVectors( v, w );
	
			}
	
			var x = this.x, y = this.y, z = this.z;
	
			this.x = y * v.z - z * v.y;
			this.y = z * v.x - x * v.z;
			this.z = x * v.y - y * v.x;
	
			return this;
	
		},
	
		crossVectors: function ( a, b ) {
	
			var ax = a.x, ay = a.y, az = a.z;
			var bx = b.x, by = b.y, bz = b.z;
	
			this.x = ay * bz - az * by;
			this.y = az * bx - ax * bz;
			this.z = ax * by - ay * bx;
	
			return this;
	
		},
	
		projectOnVector: function () {
	
			var v1, dot;
	
			return function ( vector ) {
	
				if ( v1 === undefined ) v1 = new THREE.Vector3();
	
				v1.copy( vector ).normalize();
	
				dot = this.dot( v1 );
	
				return this.copy( v1 ).multiplyScalar( dot );
	
			};
	
		}(),
	
		projectOnPlane: function () {
	
			var v1;
	
			return function ( planeNormal ) {
	
				if ( v1 === undefined ) v1 = new THREE.Vector3();
	
				v1.copy( this ).projectOnVector( planeNormal );
	
				return this.sub( v1 );
	
			}
	
		}(),
	
		reflect: function () {
	
			// reflect incident vector off plane orthogonal to normal
			// normal is assumed to have unit length
	
			var v1;
	
			return function ( normal ) {
	
				if ( v1 === undefined ) v1 = new THREE.Vector3();
	
				return this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );
	
			}
	
		}(),
	
		angleTo: function ( v ) {
	
			var theta = this.dot( v ) / ( this.length() * v.length() );
	
			// clamp, to handle numerical problems
	
			return Math.acos( THREE.Math.clamp( theta, - 1, 1 ) );
	
		},
	
		distanceTo: function ( v ) {
	
			return Math.sqrt( this.distanceToSquared( v ) );
	
		},
	
		distanceToSquared: function ( v ) {
	
			var dx = this.x - v.x;
			var dy = this.y - v.y;
			var dz = this.z - v.z;
	
			return dx * dx + dy * dy + dz * dz;
	
		},
	
		setEulerFromRotationMatrix: function ( m, order ) {
	
			console.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );
	
		},
	
		setEulerFromQuaternion: function ( q, order ) {
	
			console.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );
	
		},
	
		getPositionFromMatrix: function ( m ) {
	
			console.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );
	
			return this.setFromMatrixPosition( m );
	
		},
	
		getScaleFromMatrix: function ( m ) {
	
			console.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );
	
			return this.setFromMatrixScale( m );
		},
	
		getColumnFromMatrix: function ( index, matrix ) {
	
			console.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );
	
			return this.setFromMatrixColumn( index, matrix );
	
		},
	
		setFromMatrixPosition: function ( m ) {
	
			this.x = m.elements[ 12 ];
			this.y = m.elements[ 13 ];
			this.z = m.elements[ 14 ];
	
			return this;
	
		},
	
		setFromMatrixScale: function ( m ) {
	
			var sx = this.set( m.elements[ 0 ], m.elements[ 1 ], m.elements[  2 ] ).length();
			var sy = this.set( m.elements[ 4 ], m.elements[ 5 ], m.elements[  6 ] ).length();
			var sz = this.set( m.elements[ 8 ], m.elements[ 9 ], m.elements[ 10 ] ).length();
	
			this.x = sx;
			this.y = sy;
			this.z = sz;
	
			return this;
		},
	
		setFromMatrixColumn: function ( index, matrix ) {
	
			var offset = index * 4;
	
			var me = matrix.elements;
	
			this.x = me[ offset ];
			this.y = me[ offset + 1 ];
			this.z = me[ offset + 2 ];
	
			return this;
	
		},
	
		equals: function ( v ) {
	
			return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );
	
		},
	
		fromArray: function ( array, offset ) {
	
			if ( offset === undefined ) offset = 0;
	
			this.x = array[ offset ];
			this.y = array[ offset + 1 ];
			this.z = array[ offset + 2 ];
	
			return this;
	
		},
	
		toArray: function ( array, offset ) {
	
			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;
	
			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;
			array[ offset + 2 ] = this.z;
	
			return array;
	
		},
	
		fromAttribute: function ( attribute, index, offset ) {
	
		    if ( offset === undefined ) offset = 0;
	
		    index = index * attribute.itemSize + offset;
	
		    this.x = attribute.array[ index ];
		    this.y = attribute.array[ index + 1 ];
		    this.z = attribute.array[ index + 2 ];
	
		    return this;
	
		},
	
		clone: function () {
	
			return new THREE.Vector3( this.x, this.y, this.z );
	
		}
	
	};
	/*** END Vector3 ***/
	/*** START Euler ***/
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://exocortex.com
	 */
	
	THREE.Euler = function ( x, y, z, order ) {
	
		this._x = x || 0;
		this._y = y || 0;
		this._z = z || 0;
		this._order = order || THREE.Euler.DefaultOrder;
	
	};
	
	THREE.Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];
	
	THREE.Euler.DefaultOrder = 'XYZ';
	
	THREE.Euler.prototype = {
	
		constructor: THREE.Euler,
	
		_x: 0, _y: 0, _z: 0, _order: THREE.Euler.DefaultOrder,
	
		get x () {
	
			return this._x;
	
		},
	
		set x ( value ) {
	
			this._x = value;
			this.onChangeCallback();
	
		},
	
		get y () {
	
			return this._y;
	
		},
	
		set y ( value ) {
	
			this._y = value;
			this.onChangeCallback();
	
		},
	
		get z () {
	
			return this._z;
	
		},
	
		set z ( value ) {
	
			this._z = value;
			this.onChangeCallback();
	
		},
	
		get order () {
	
			return this._order;
	
		},
	
		set order ( value ) {
	
			this._order = value;
			this.onChangeCallback();
	
		},
	
		set: function ( x, y, z, order ) {
	
			this._x = x;
			this._y = y;
			this._z = z;
			this._order = order || this._order;
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		copy: function ( euler ) {
	
			this._x = euler._x;
			this._y = euler._y;
			this._z = euler._z;
			this._order = euler._order;
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		setFromRotationMatrix: function ( m, order, update ) {
	
			var clamp = THREE.Math.clamp;
	
			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
	
			var te = m.elements;
			var m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
			var m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
			var m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];
	
			order = order || this._order;
	
			if ( order === 'XYZ' ) {
	
				this._y = Math.asin( clamp( m13, - 1, 1 ) );
	
				if ( Math.abs( m13 ) < 0.99999 ) {
	
					this._x = Math.atan2( - m23, m33 );
					this._z = Math.atan2( - m12, m11 );
	
				} else {
	
					this._x = Math.atan2( m32, m22 );
					this._z = 0;
	
				}
	
			} else if ( order === 'YXZ' ) {
	
				this._x = Math.asin( - clamp( m23, - 1, 1 ) );
	
				if ( Math.abs( m23 ) < 0.99999 ) {
	
					this._y = Math.atan2( m13, m33 );
					this._z = Math.atan2( m21, m22 );
	
				} else {
	
					this._y = Math.atan2( - m31, m11 );
					this._z = 0;
	
				}
	
			} else if ( order === 'ZXY' ) {
	
				this._x = Math.asin( clamp( m32, - 1, 1 ) );
	
				if ( Math.abs( m32 ) < 0.99999 ) {
	
					this._y = Math.atan2( - m31, m33 );
					this._z = Math.atan2( - m12, m22 );
	
				} else {
	
					this._y = 0;
					this._z = Math.atan2( m21, m11 );
	
				}
	
			} else if ( order === 'ZYX' ) {
	
				this._y = Math.asin( - clamp( m31, - 1, 1 ) );
	
				if ( Math.abs( m31 ) < 0.99999 ) {
	
					this._x = Math.atan2( m32, m33 );
					this._z = Math.atan2( m21, m11 );
	
				} else {
	
					this._x = 0;
					this._z = Math.atan2( - m12, m22 );
	
				}
	
			} else if ( order === 'YZX' ) {
	
				this._z = Math.asin( clamp( m21, - 1, 1 ) );
	
				if ( Math.abs( m21 ) < 0.99999 ) {
	
					this._x = Math.atan2( - m23, m22 );
					this._y = Math.atan2( - m31, m11 );
	
				} else {
	
					this._x = 0;
					this._y = Math.atan2( m13, m33 );
	
				}
	
			} else if ( order === 'XZY' ) {
	
				this._z = Math.asin( - clamp( m12, - 1, 1 ) );
	
				if ( Math.abs( m12 ) < 0.99999 ) {
	
					this._x = Math.atan2( m32, m22 );
					this._y = Math.atan2( m13, m11 );
	
				} else {
	
					this._x = Math.atan2( - m23, m33 );
					this._y = 0;
	
				}
	
			} else {
	
				console.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order )
	
			}
	
			this._order = order;
	
			if ( update !== false ) this.onChangeCallback();
	
			return this;
	
		},
	
		setFromQuaternion: function () {
	
			var matrix;
	
			return function ( q, order, update ) {
	
				if ( matrix === undefined ) matrix = new THREE.Matrix4();
				matrix.makeRotationFromQuaternion( q );
				this.setFromRotationMatrix( matrix, order, update );
	
				return this;
	
			};
	
		}(),
	
		setFromVector3: function ( v, order ) {
	
			return this.set( v.x, v.y, v.z, order || this._order );
	
		},
	
		reorder: function () {
	
			// WARNING: this discards revolution information -bhouston
	
			var q = new THREE.Quaternion();
	
			return function ( newOrder ) {
	
				q.setFromEuler( this );
				this.setFromQuaternion( q, newOrder );
	
			};
	
		}(),
	
		equals: function ( euler ) {
	
			return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );
	
		},
	
		fromArray: function ( array ) {
	
			this._x = array[ 0 ];
			this._y = array[ 1 ];
			this._z = array[ 2 ];
			if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		toArray: function () {
	
			return [ this._x, this._y, this._z, this._order ];
	
		},
	
		toVector3: function ( optionalResult ) {
	
			if ( optionalResult ) {
	
				return optionalResult.set( this._x, this._y, this._z );
	
			} else {
	
				return new THREE.Vector3( this._x, this._y, this._z );
	
			}
	
		},
	
		onChange: function ( callback ) {
	
			this.onChangeCallback = callback;
	
			return this;
	
		},
	
		onChangeCallback: function () {},
	
		clone: function () {
	
			return new THREE.Euler( this._x, this._y, this._z, this._order );
	
		}
	
	};
	/*** END Euler ***/
	/*** START Math ***/
	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.Math = {
	
		generateUUID: function () {
	
			// http://www.broofa.com/Tools/Math.uuid.htm
	
			var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );
			var uuid = new Array( 36 );
			var rnd = 0, r;
	
			return function () {
	
				for ( var i = 0; i < 36; i ++ ) {
	
					if ( i == 8 || i == 13 || i == 18 || i == 23 ) {
	
						uuid[ i ] = '-';
	
					} else if ( i == 14 ) {
	
						uuid[ i ] = '4';
	
					} else {
	
						if ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;
						r = rnd & 0xf;
						rnd = rnd >> 4;
						uuid[ i ] = chars[ ( i == 19 ) ? ( r & 0x3 ) | 0x8 : r ];
	
					}
				}
	
				return uuid.join( '' );
	
			};
	
		}(),
	
		// Clamp value to range <a, b>
	
		clamp: function ( x, a, b ) {
	
			return ( x < a ) ? a : ( ( x > b ) ? b : x );
	
		},
	
		// Clamp value to range <a, inf)
	
		clampBottom: function ( x, a ) {
	
			return x < a ? a : x;
	
		},
	
		// Linear mapping from range <a1, a2> to range <b1, b2>
	
		mapLinear: function ( x, a1, a2, b1, b2 ) {
	
			return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );
	
		},
	
		// http://en.wikipedia.org/wiki/Smoothstep
	
		smoothstep: function ( x, min, max ) {
	
			if ( x <= min ) return 0;
			if ( x >= max ) return 1;
	
			x = ( x - min ) / ( max - min );
	
			return x * x * ( 3 - 2 * x );
	
		},
	
		smootherstep: function ( x, min, max ) {
	
			if ( x <= min ) return 0;
			if ( x >= max ) return 1;
	
			x = ( x - min ) / ( max - min );
	
			return x * x * x * ( x * ( x * 6 - 15 ) + 10 );
	
		},
	
		// Random float from <0, 1> with 16 bits of randomness
		// (standard Math.random() creates repetitive patterns when applied over larger space)
	
		random16: function () {
	
			return ( 65280 * Math.random() + 255 * Math.random() ) / 65535;
	
		},
	
		// Random integer from <low, high> interval
	
		randInt: function ( low, high ) {
	
			return Math.floor( this.randFloat( low, high ) );
	
		},
	
		// Random float from <low, high> interval
	
		randFloat: function ( low, high ) {
	
			return low + Math.random() * ( high - low );
	
		},
	
		// Random float from <-range/2, range/2> interval
	
		randFloatSpread: function ( range ) {
	
			return range * ( 0.5 - Math.random() );
	
		},
	
		degToRad: function () {
	
			var degreeToRadiansFactor = Math.PI / 180;
	
			return function ( degrees ) {
	
				return degrees * degreeToRadiansFactor;
	
			};
	
		}(),
	
		radToDeg: function () {
	
			var radianToDegreesFactor = 180 / Math.PI;
	
			return function ( radians ) {
	
				return radians * radianToDegreesFactor;
	
			};
	
		}(),
	
		isPowerOfTwo: function ( value ) {
	
			return ( value & ( value - 1 ) ) === 0 && value !== 0;
	
		},
	
		nextPowerOfTwo: function ( value ) {
	
			value --;
			value |= value >> 1;
			value |= value >> 2;
			value |= value >> 4;
			value |= value >> 8;
			value |= value >> 16;
			value ++;
	
			return value;
		}
	
	};
	
	/*** END Math ***/
	
	}
	
	module.exports = THREE;
	
	},{}],10:[function(_dereq_,module,exports){
	/*
	 * Copyright 2015 Google Inc. All Rights Reserved.
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var THREE = _dereq_('./three-math.js');
	var Util = _dereq_('./util.js');
	
	var ROTATE_SPEED = 0.5;
	/**
	 * Provides a quaternion responsible for pre-panning the scene before further
	 * transformations due to device sensors.
	 */
	function TouchPanner() {
	  window.addEventListener('touchstart', this.onTouchStart_.bind(this));
	  window.addEventListener('touchmove', this.onTouchMove_.bind(this));
	  window.addEventListener('touchend', this.onTouchEnd_.bind(this));
	
	  this.isTouching = false;
	  this.rotateStart = new THREE.Vector2();
	  this.rotateEnd = new THREE.Vector2();
	  this.rotateDelta = new THREE.Vector2();
	
	  this.theta = 0;
	  this.orientation = new THREE.Quaternion();
	}
	
	TouchPanner.prototype.getOrientation = function() {
	  this.orientation.setFromEuler(new THREE.Euler(0, 0, this.theta));
	  return this.orientation;
	};
	
	TouchPanner.prototype.resetSensor = function() {
	  this.theta = 0;
	};
	
	TouchPanner.prototype.onTouchStart_ = function(e) {
	  // Only respond if there is exactly one touch.
	  if (e.touches.length != 1) {
	    return;
	  }
	  this.rotateStart.set(e.touches[0].pageX, e.touches[0].pageY);
	  this.isTouching = true;
	};
	
	TouchPanner.prototype.onTouchMove_ = function(e) {
	  if (!this.isTouching) {
	    return;
	  }
	  this.rotateEnd.set(e.touches[0].pageX, e.touches[0].pageY);
	  this.rotateDelta.subVectors(this.rotateEnd, this.rotateStart);
	  this.rotateStart.copy(this.rotateEnd);
	
	  // On iOS, direction is inverted.
	  if (Util.isIOS()) {
	    this.rotateDelta.x *= -1;
	  }
	
	  var element = document.body;
	  this.theta += 2 * Math.PI * this.rotateDelta.x / element.clientWidth * ROTATE_SPEED;
	};
	
	TouchPanner.prototype.onTouchEnd_ = function(e) {
	  this.isTouching = false;
	};
	
	module.exports = TouchPanner;
	
	},{"./three-math.js":9,"./util.js":11}],11:[function(_dereq_,module,exports){
	/*
	 * Copyright 2015 Google Inc. All Rights Reserved.
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var Util = window.Util || {};
	
	Util.MIN_TIMESTEP = 0.001;
	Util.MAX_TIMESTEP = 1;
	
	Util.clamp = function(value, min, max) {
	  return Math.min(Math.max(min, value), max);
	};
	
	Util.isIOS = function() {
	  return /iPad|iPhone|iPod/.test(navigator.platform);
	};
	
	Util.isFirefoxAndroid = function() {
	  return navigator.userAgent.indexOf('Firefox') !== -1 && navigator.userAgent.indexOf('Android') !== -1;
	}
	
	// Helper method to validate the time steps of sensor timestamps.
	Util.isTimestampDeltaValid = function(timestampDeltaS) {
	  if (isNaN(timestampDeltaS)) {
	    return false;
	  }
	  if (timestampDeltaS <= Util.MIN_TIMESTEP) {
	    return false;
	  }
	  if (timestampDeltaS > Util.MAX_TIMESTEP) {
	    return false;
	  }
	  return true;
	}
	
	module.exports = Util;
	
	},{}],12:[function(_dereq_,module,exports){
	/*
	 * Copyright 2015 Google Inc. All Rights Reserved.
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	
	var CardboardHMDVRDevice = _dereq_('./cardboard-hmd-vr-device.js');
	//var OrientationPositionSensorVRDevice = require('./orientation-position-sensor-vr-device.js');
	var FusionPositionSensorVRDevice = _dereq_('./fusion-position-sensor-vr-device.js');
	var MouseKeyboardPositionSensorVRDevice = _dereq_('./mouse-keyboard-position-sensor-vr-device.js');
	// Uncomment to add positional tracking via webcam.
	//var WebcamPositionSensorVRDevice = require('./webcam-position-sensor-vr-device.js');
	var HMDVRDevice = _dereq_('./base.js').HMDVRDevice;
	var PositionSensorVRDevice = _dereq_('./base.js').PositionSensorVRDevice;
	
	function WebVRPolyfill() {
	  this.devices = [];
	
	  if (!this.isWebVRAvailable()) {
	    this.enablePolyfill();
	  }
	}
	
	WebVRPolyfill.prototype.isWebVRAvailable = function() {
	  return ('getVRDevices' in navigator) || ('mozGetVRDevices' in navigator);
	};
	
	
	WebVRPolyfill.prototype.enablePolyfill = function() {
	  // Initialize our virtual VR devices.
	  if (this.isCardboardCompatible()) {
	    this.devices.push(new CardboardHMDVRDevice());
	  }
	
	  // Polyfill using the right position sensor.
	  if (this.isMobile()) {
	    //this.devices.push(new OrientationPositionSensorVRDevice());
	    this.devices.push(new FusionPositionSensorVRDevice());
	  } else {
	    if (!WebVRConfig.MOUSE_KEYBOARD_CONTROLS_DISABLED) {
	      this.devices.push(new MouseKeyboardPositionSensorVRDevice());
	    }
	    // Uncomment to add positional tracking via webcam.
	    //this.devices.push(new WebcamPositionSensorVRDevice());
	  }
	
	  // Provide navigator.getVRDevices.
	  navigator.getVRDevices = this.getVRDevices.bind(this);
	
	  // Provide the CardboardHMDVRDevice and PositionSensorVRDevice objects.
	  window.HMDVRDevice = HMDVRDevice;
	  window.PositionSensorVRDevice = PositionSensorVRDevice;
	};
	
	WebVRPolyfill.prototype.getVRDevices = function() {
	  var devices = this.devices;
	  return new Promise(function(resolve, reject) {
	    try {
	      resolve(devices);
	    } catch (e) {
	      reject(e);
	    }
	  });
	};
	
	/**
	 * Determine if a device is mobile.
	 */
	WebVRPolyfill.prototype.isMobile = function() {
	  return /Android/i.test(navigator.userAgent) ||
	      /iPhone|iPad|iPod/i.test(navigator.userAgent);
	};
	
	WebVRPolyfill.prototype.isCardboardCompatible = function() {
	  // For now, support all iOS and Android devices.
	  // Also enable the WebVRConfig.FORCE_VR flag for debugging.
	  return this.isMobile() || WebVRConfig.FORCE_ENABLE_VR;
	};
	
	module.exports = WebVRPolyfill;
	
	},{"./base.js":1,"./cardboard-hmd-vr-device.js":2,"./fusion-position-sensor-vr-device.js":4,"./mouse-keyboard-position-sensor-vr-device.js":6}]},{},[5]);
	
	},{}],24:[function(_dereq_,module,exports){
	module.exports={
	  "name": "aframe",
	  "version": "0.2.0-rc1",
	  "description": "Building blocks for the VR Web",
	  "main": "dist/aframe.js",
	  "scripts": {
	    "browserify": "browserify src/index.js -s 'AFRAME' -p browserify-derequire",
	    "build": "mkdirp build/ && npm run browserify -- --debug -o build/aframe.js",
	    "dev": "npm run build && node ./scripts/budo",
	    "dist": "mkdirp dist/ && npm run browserify -s -- --debug | exorcist dist/aframe.js.map > dist/aframe.js && uglifyjs dist/aframe.js -c warnings=false -m -o dist/aframe.min.js",
	    "gh-pages": "npm run ghpages",
	    "ghpages": "node ./scripts/gh-pages",
	    "lint": "semistandard -v | snazzy",
	    "precommit": "npm run lint",
	    "preghpages": "npm run dist && rimraf gh-pages && mkdirp gh-pages && cp -r {.nojekyll,dist,lib,examples,index.html,style} gh-pages/. 2>/dev/null || : && git checkout dist/ && replace 'build/aframe.js' 'dist/aframe.min.js' gh-pages/ -r --silent",
	    "release:bump": "npm run dist && git commit -am 'bump dist' && npm version patch --preminor",
	    "release:push": "npm login && npm publish && git push --follow-tags",
	    "start": "npm run dev",
	    "test": "karma start ./tests/karma.conf.js",
	    "test:ci": "TEST_ENV=ci karma start ./tests/karma.conf.js --single-run",
	    "version": "npm run dist"
	  },
	  "repository": "aframevr/aframe",
	  "license": "MIT",
	  "dependencies": {
	    "browserify-css": "^0.8.2",
	    "debug": "^2.2.0",
	    "deep-assign": "^2.0.0",
	    "document-register-element": "dmarcos/document-register-element#8ccc532b7",
	    "promise-polyfill": "^3.1.0",
	    "object-assign": "^4.0.1",
	    "polymerize": "^1.0.0",
	    "present": "0.0.6",
	    "request-interval": "^1.0.0",
	    "style-attr": "^1.0.2",
	    "three": "^0.74.0",
	    "tween.js": "^15.0.0",
	    "webvr-polyfill": "borismus/webvr-polyfill#3f47796"
	  },
	  "devDependencies": {
	    "browserify": "^11.0.1",
	    "browserify-derequire": "^0.9.4",
	    "budo": "^8.1.0",
	    "chai": "^3.5.0",
	    "chai-shallow-deep-equal": "^1.3.0",
	    "exorcist": "^0.4.0",
	    "gh-pages": "^0.6.0",
	    "husky": "^0.10.1",
	    "karma": "^0.13.15",
	    "karma-browserify": "^4.4.0",
	    "karma-chai-shallow-deep-equal": "0.0.4",
	    "karma-env-preprocessor": "^0.1.1",
	    "karma-firefox-launcher": "^0.1.6",
	    "karma-mocha": "^0.2.0",
	    "karma-mocha-reporter": "^1.1.0",
	    "karma-sinon-chai": "^1.1.0",
	    "lolex": "^1.4.0",
	    "mkdirp": "0.5.1",
	    "mocha": "^2.3.3",
	    "mozilla-download": "^1.0.5",
	    "open": "0.0.5",
	    "replace": "^0.3.0",
	    "rimraf": "2.5.0",
	    "semistandard": "^7.0.2",
	    "sinon": "^1.17.3",
	    "sinon-chai": "^2.8.0",
	    "snazzy" : "^3.0.0",
	    "uglifyjs": "^2.4.10"
	  },
	  "link": true,
	  "browserify": {
	    "transform": [
	      "browserify-css",
	      [
	        "polymerize",
	        {
	          "match": ".*.html$"
	        }
	      ]
	    ]
	  },
	  "semistandard": {
	    "ignore": [
	      "build/**",
	      "dist/**",
	      "examples/_js/**",
	      "examples/**/shaders/*.js",
	      "vendor/**"
	    ]
	  },
	  "keywords": [
	    "aframe",
	    "vr",
	    "webvr",
	    "3d",
	    "three",
	    "components",
	    "elements"
	  ],
	  "browserify-css": {
	    "minify": true
	  },
	  "engines": {
	    "node": ">= 0.12.7",
	    "npm": "^2.12.1"
	  }
	}
	
	},{}],25:[function(_dereq_,module,exports){
	var registerComponent = _dereq_('../core/component').registerComponent;
	var THREE = _dereq_('../lib/three');
	
	/**
	 * Camera component.
	 * Pairs along with camera system to handle tracking the active camera.
	 */
	module.exports.Component = registerComponent('camera', {
	  schema: {
	    active: { default: true },
	    far: { default: 10000 },
	    fov: { default: 80, min: 0 },
	    near: { default: 0.5, min: 0 }
	  },
	
	  /**
	   * Initialize three.js camera and add it to the entity.
	   * Add reference from scene to this entity as the camera.
	   */
	  init: function () {
	    var camera = this.camera = new THREE.PerspectiveCamera();
	    this.el.setObject3D('camera', camera);
	  },
	
	  /**
	   * Remove camera on remove (callback).
	   */
	  remove: function () {
	    this.el.removeObject3D('camera');
	  },
	
	  /**
	   * Update three.js camera.
	   */
	  update: function (oldData) {
	    var el = this.el;
	    var data = this.data;
	    var camera = this.camera;
	    var system = this.system;
	
	    // Update properties.
	    camera.aspect = data.aspect || (window.innerWidth / window.innerHeight);
	    camera.far = data.far;
	    camera.fov = data.fov;
	    camera.near = data.near;
	    camera.updateProjectionMatrix();
	
	    // Active property did not change.
	    if (oldData && oldData.active === data.active) { return; }
	
	    // If `active` property changes, or first update, handle active camera with system.
	    if (data.active && system.activeCameraEl !== this.el) {
	      // Camera enabled. Set camera to this camera.
	      system.setActiveCamera(el, camera);
	    } else if (!data.active && system.activeCameraEl === this.el) {
	      // Camera disabled. Set camera to another camera.
	      system.disableActiveCamera();
	    }
	  }
	});
	
	},{"../core/component":56,"../lib/three":90}],26:[function(_dereq_,module,exports){
	var registerComponent = _dereq_('../core/component').registerComponent;
	var THREE = _dereq_('../lib/three');
	
	var loader = new THREE.ColladaLoader();
	loader.options.convertUpAxis = true;
	
	module.exports.Component = registerComponent('collada-model', {
	  schema: {
	    type: 'src'
	  },
	
	  init: function () {
	    this.model = null;
	  },
	
	  update: function () {
	    var self = this;
	    var el = this.el;
	    var src = this.data;
	
	    if (!src) { return; }
	
	    this.remove();
	
	    loader.load(src, function (colladaModel) {
	      self.model = colladaModel.scene;
	      el.setObject3D('mesh', self.model);
	      el.emit('model-loaded', {format: 'collada', model: self.model});
	    });
	  },
	
	  remove: function () {
	    if (!this.model) { return; }
	    this.el.removeObject3D('mesh');
	  }
	});
	
	},{"../core/component":56,"../lib/three":90}],27:[function(_dereq_,module,exports){
	var registerComponent = _dereq_('../core/component').registerComponent;
	var utils = _dereq_('../utils/');
	
	module.exports.Component = registerComponent('cursor', {
	  schema: {
	    timeout: { default: 1500, min: 0 },
	    maxDistance: { default: 5, min: 0 },
	    fuse: { default: false }
	  },
	
	  dependencies: [ 'raycaster' ],
	
	  init: function () {
	    this.raycaster = this.el.components.raycaster;
	    // The cursor defaults to fuse in mobile environments
	    this.schema.fuse.default = utils.isMobile();
	    this.attachEventListeners();
	  },
	
	  attachEventListeners: function () {
	    var el = this.el;
	    var canvas = el.sceneEl.canvas;
	
	    // listen for canvas to load.
	    if (!canvas) {
	      el.sceneEl.addEventListener('render-target-loaded', this.attachEventListeners.bind(this));
	      return;
	    }
	
	    canvas.addEventListener('mousedown', this.onMouseDown.bind(this));
	    canvas.addEventListener('mouseup', this.onMouseUp.bind(this));
	
	    el.addEventListener('intersection', this.onIntersection.bind(this));
	    el.addEventListener('intersectioncleared', this.onIntersectionCleared.bind(this));
	  },
	
	  onMouseDown: function (evt) {
	    this.emit('mousedown');
	    this.mouseDownEl = this.intersectedEl;
	  },
	
	  onMouseUp: function () {
	    this.emit('mouseup');
	    if (this.data.fuse) { return; }
	    if (!this.intersectedEl) { return; }
	    if (this.mouseDownEl === this.intersectedEl) {
	      this.emit('click');
	    }
	  },
	
	  emit: function (evt) {
	    var intersectedEl = this.intersectedEl;
	    this.el.emit(evt, { target: this.intersectedEl });
	    if (intersectedEl) { intersectedEl.emit(evt); }
	  },
	
	  emitter: function (evt) {
	    return function () {
	      this.emit(evt);
	    }.bind(this);
	  },
	
	  onIntersection: function (evt) {
	    var self = this;
	    var data = this.data;
	    var el = evt.detail.el;
	    var distance = evt.detail.distance;
	    if (this.intersectedEl === el) { return; }
	    if (distance >= this.data.maxDistance) { return; }
	    this.intersectedEl = el;
	    el.addState('hovered');
	    el.emit('mouseenter');
	    this.el.addState('hovering');
	    if (data.timeout === 0) { return; }
	    if (!data.fuse) { return; }
	    this.el.addState('fusing');
	    this.fuseTimeout = setTimeout(fuse, data.timeout);
	    function fuse () {
	      self.el.removeState('fusing');
	      self.emit('click');
	    }
	  },
	
	  onIntersectionCleared: function (evt) {
	    var el = evt.detail.el;
	    if (!el || !this.intersectedEl) { return; }
	    el.removeState('hovered');
	    el.emit('mouseleave');
	    this.el.removeState('hovering');
	    this.el.removeState('fusing');
	    this.intersectedEl = null;
	    clearTimeout(this.fuseTimeout);
	  }
	});
	
	},{"../core/component":56,"../utils/":102}],28:[function(_dereq_,module,exports){
	var debug = _dereq_('../utils/debug');
	var registerComponent = _dereq_('../core/component').registerComponent;
	var THREE = _dereq_('../lib/three');
	var utils = _dereq_('../utils');
	
	var DEFAULT_RADIUS = 1;
	var helperMatrix = new THREE.Matrix4();
	var degToRad = THREE.Math.degToRad;
	var warn = debug('components:geometry:warn');
	
	/**
	 * Geometry component. Combined with material component to make a mesh in 3D object.
	 */
	module.exports.Component = registerComponent('geometry', {
	  schema: {
	    arc: { default: 360, if: { primitive: ['torus'] } },
	    depth: { default: 1, min: 0, if: { primitive: ['box'] } },
	    height: { default: 1, min: 0, if: { primitive: ['box', 'plane'] } },
	    openEnded: { default: false, if: { primitive: ['cylinder'] } },
	    p: { default: 2, if: { primitive: ['torusKnot'] }, type: 'int' },
	    primitive: {
	      default: '',
	      oneOf: ['', 'box', 'circle', 'cylinder', 'plane',
	              'ring', 'sphere', 'torus', 'torusKnot'] },
	    q: { default: 3, if: { primitive: ['torusKnot'] }, type: 'int' },
	    phiLength: { default: 360, if: { primitive: ['sphere'] } },
	    phiStart: { default: 0, min: 0, if: { primitive: ['sphere'] } },
	    radius: { default: DEFAULT_RADIUS, min: 0, if: { primitive: ['circle', 'cylinder', 'sphere', 'torus', 'torusKnot'] } },
	    radiusBottom: { default: DEFAULT_RADIUS, min: 0, if: { primitive: ['cylinder'] } },
	    radiusInner: { default: 0.8, min: 0, if: { primitive: ['ring'] } },
	    radiusOuter: { default: 1.2, min: 0, if: { primitive: ['ring'] } },
	    radiusTop: { default: DEFAULT_RADIUS, if: { primitive: ['cylinder'] } },
	    radiusTubular: { default: 0.2, min: 0, if: { primitive: ['torus'] } },
	    scaleHeight: { default: 1, min: 0, if: { primitive: ['torusKnot'] } },
	    segments: { default: 32, min: 0, if: { primitive: ['circle'] }, type: 'int' },
	    segmentsHeight: { default: 18, min: 0, if: { primitive: ['cylinder', 'sphere'] }, type: 'int' },
	    segmentsPhi: { default: 8, min: 0, if: { primitive: ['ring'] }, type: 'int' },
	    segmentsRadial: { default: 36, min: 0, if: { primitive: ['cylinder'] }, type: 'int' },
	    segmentsTheta: { default: 32, min: 0, if: { primitive: ['ring'] }, type: 'int' },
	    segmentsTubular: { default: 32, min: 0, if: { primitive: ['torus', 'torusKnot'] }, type: 'int' },
	    segmentsWidth: { default: 36, min: 0, if: { primitive: ['sphere'] }, type: 'int' },
	    thetaLength: { default: 360, min: 0, if: { primitive: ['circle', 'cylinder', 'ring',
	                                                           'sphere'] } },
	    thetaStart: { default: 0, if: { primitive: ['circle', 'cylinder', 'ring', 'sphere'] } },
	    translate: { type: 'vec3' },
	    width: { default: 1, min: 0, if: { primitive: ['box', 'plane'] } }
	  },
	
	  /**
	   * Creates a new geometry on every update as there's not an easy way to
	   * update a geometry that would be faster than just creating a new one.
	   */
	  update: function (previousData) {
	    previousData = previousData || {};
	    var data = this.data;
	    var currentTranslate = previousData.translate || this.schema.translate.default;
	    var diff = utils.diff(previousData, data);
	    var mesh = this.el.getOrCreateObject3D('mesh', THREE.Mesh);
	    var geometry = mesh.geometry;
	    var geometryNeedsUpdate = !(Object.keys(diff).length === 1 && 'translate' in diff);
	    var translateNeedsUpdate = !utils.deepEqual(data.translate, currentTranslate);
	
	    if (geometryNeedsUpdate) {
	      geometry = mesh.geometry = getGeometry(this.data, this.schema);
	    }
	    if (translateNeedsUpdate) {
	      applyTranslate(geometry, data.translate, currentTranslate);
	    }
	  },
	
	  /**
	   * Removes geometry on remove (callback).
	   */
	  remove: function () {
	    this.el.getObject3D('mesh').geometry = new THREE.Geometry();
	  }
	});
	
	/**
	 * Creates a three.js geometry.
	 *
	 * @param {object} data
	 * @param {object} schema
	 * @returns {object} geometry
	 */
	function getGeometry (data, schema) {
	  if (data.primitive === 'cube') {
	    warn('geometry.primitive="cube" should be "box"');
	  }
	
	  switch (data.primitive) {
	    case 'box': {
	      return new THREE.BoxGeometry(data.width, data.height, data.depth);
	    }
	    case 'circle': {
	      return new THREE.CircleGeometry(
	        data.radius, data.segments, degToRad(data.thetaStart), degToRad(data.thetaLength));
	    }
	    case 'cone': {
	      return new THREE.CylinderGeometry(
	        data.radiusTop, data.radiusBottom, data.height,
	        data.segmentsRadial, data.segmentsHeight,
	        data.openEnded, degToRad(data.thetaStart), degToRad(data.thetaLength));
	    }
	    case 'cylinder': {
	      return new THREE.CylinderGeometry(
	        data.radius, data.radius, data.height,
	        data.segmentsRadial, data.segmentsHeight,
	        data.openEnded, degToRad(data.thetaStart), degToRad(data.thetaLength));
	    }
	    case 'plane': {
	      return new THREE.PlaneBufferGeometry(data.width, data.height);
	    }
	    case 'ring': {
	      return new THREE.RingGeometry(
	        data.radiusInner, data.radiusOuter, data.segmentsTheta, data.segmentsPhi,
	        degToRad(data.thetaStart), degToRad(data.thetaLength));
	    }
	    case 'sphere': {
	      // thetaLength's default for spheres is different from those of the other geometries.
	      // For now, we detect if thetaLength is exactly 360 to switch to a different default.
	      if (data.thetaLength === 360) { data.thetaLength = 180; }
	      return new THREE.SphereBufferGeometry(
	        data.radius, data.segmentsWidth, data.segmentsHeight, degToRad(data.phiStart),
	        degToRad(data.phiLength), degToRad(data.thetaStart), degToRad(data.thetaLength));
	    }
	    case 'torus': {
	      return new THREE.TorusGeometry(
	        data.radius, data.radiusTubular * 2, data.segmentsRadial, data.segmentsTubular,
	        degToRad(data.arc));
	    }
	    case 'torusKnot': {
	      return new THREE.TorusKnotGeometry(
	        data.radius, data.radiusTubular * 2, data.segmentsRadial, data.segmentsTubular,
	        data.p, data.q, data.scaleHeight);
	    }
	    default: {
	      warn('Primitive type not supported: ' + data.primitive);
	      return new THREE.Geometry();
	    }
	  }
	}
	
	/**
	 * Translates geometry vertices.
	 *
	 * @param {object} geometry - three.js geometry.
	 * @param {object} translate - New translation.
	 * @param {object} currentTranslate - Currently applied translation.
	 */
	function applyTranslate (geometry, translate, currentTranslate) {
	  var translation = helperMatrix.makeTranslation(
	    translate.x - currentTranslate.x,
	    translate.y - currentTranslate.y,
	    translate.z - currentTranslate.z
	  );
	  geometry.applyMatrix(translation);
	  geometry.verticesNeedsUpdate = true;
	}
	
	},{"../core/component":56,"../lib/three":90,"../utils":102,"../utils/debug":101}],29:[function(_dereq_,module,exports){
	_dereq_('./camera');
	_dereq_('./collada-model');
	_dereq_('./cursor');
	_dereq_('./geometry');
	_dereq_('./light');
	_dereq_('./look-at');
	_dereq_('./look-controls');
	_dereq_('./material');
	_dereq_('./obj-model');
	_dereq_('./position');
	_dereq_('./raycaster');
	_dereq_('./rotation');
	_dereq_('./scale');
	_dereq_('./sound');
	_dereq_('./visible');
	_dereq_('./wasd-controls');
	
	_dereq_('./scene/canvas');
	_dereq_('./scene/fog');
	_dereq_('./scene/keyboard-shortcuts');
	_dereq_('./scene/stats');
	_dereq_('./scene/vr-mode-ui');
	
	// Deprecated.
	_dereq_('./loader');
	
	},{"./camera":25,"./collada-model":26,"./cursor":27,"./geometry":28,"./light":30,"./loader":31,"./look-at":32,"./look-controls":33,"./material":34,"./obj-model":35,"./position":36,"./raycaster":37,"./rotation":38,"./scale":39,"./scene/canvas":40,"./scene/fog":41,"./scene/keyboard-shortcuts":42,"./scene/stats":43,"./scene/vr-mode-ui":44,"./sound":45,"./visible":46,"./wasd-controls":47}],30:[function(_dereq_,module,exports){
	var diff = _dereq_('../utils').diff;
	var debug = _dereq_('../utils/debug');
	var registerComponent = _dereq_('../core/component').registerComponent;
	var THREE = _dereq_('../lib/three');
	
	var degToRad = THREE.Math.degToRad;
	var warn = debug('components:light:warn');
	
	/**
	 * Light component.
	 */
	module.exports.Component = registerComponent('light', {
	  schema: {
	    angle: { default: 60, if: { type: ['spot'] } },
	    color: { type: 'color' },
	    groundColor: { type: 'color', if: { type: ['hemisphere'] } },
	    decay: { default: 1, if: { type: ['point', 'spot'] } },
	    distance: { default: 0.0, min: 0, if: { type: ['point', 'spot'] } },
	    exponent: { default: 10.0, if: { type: ['spot'] } },
	    intensity: { default: 1.0, min: 0, if: { type: ['directional', 'hemisphere', 'point', 'spot'] } },
	    type: { default: 'directional',
	            oneOf: ['ambient', 'directional', 'hemisphere', 'point', 'spot']
	    }
	  },
	
	  /**
	   * Notifies scene a light has been added to remove default lighting.
	   */
	  init: function () {
	    var el = this.el;
	    this.light = null;
	    this.system.registerLight(el);
	  },
	
	  /**
	   * (Re)create or update light.
	   */
	  update: function (oldData) {
	    var data = this.data;
	    var diffData = diff(data, oldData || {});
	    var light = this.light;
	
	    // Existing light.
	    if (light && !('type' in diffData)) {
	      // Light type has not changed. Update light.
	      Object.keys(diffData).forEach(function (key) {
	        var value = data[key];
	        if (['color', 'groundColor'].indexOf(key) !== -1) {
	          value = new THREE.Color(value);
	        }
	        light[key] = value;
	      });
	      return;
	    }
	
	    // No light yet or light type has changed. Create and add light.
	    this.setLight(this.data);
	  },
	
	  setLight: function (data) {
	    var el = this.el;
	
	    var newLight = getLight(data);
	    if (newLight) {
	      if (this.light) {
	        el.removeObject3D('light');
	      }
	
	      this.light = newLight;
	      this.light.el = el;
	      el.setObject3D('light', this.light);
	    }
	  },
	
	  /**
	   * Remove light on remove (callback).
	   */
	  remove: function () {
	    this.el.removeObject3D('light');
	  }
	});
	
	/**
	 * Creates a new three.js light object given data object defining the light.
	 *
	 * @param {object} data
	 */
	function getLight (data) {
	  var angle = data.angle;
	  var color = new THREE.Color(data.color).getHex();
	  var decay = data.decay;
	  var distance = data.distance;
	  var groundColor = new THREE.Color(data.groundColor).getHex();
	  var intensity = data.intensity;
	  var type = data.type;
	
	  switch (type.toLowerCase()) {
	    case 'ambient': {
	      return new THREE.AmbientLight(color);
	    }
	    case 'directional': {
	      return new THREE.DirectionalLight(color, intensity);
	    }
	    case 'hemisphere': {
	      return new THREE.HemisphereLight(color, groundColor, intensity);
	    }
	    case 'point': {
	      return new THREE.PointLight(color, intensity, distance, decay);
	    }
	    case 'spot': {
	      return new THREE.SpotLight(color, intensity, distance, degToRad(angle), data.exponent,
	                                 decay);
	    }
	    default: {
	      warn('%s is not a valid light type. ' +
	           'Choose from ambient, directional, hemisphere, point, spot.', type);
	    }
	  }
	}
	
	},{"../core/component":56,"../lib/three":90,"../utils":102,"../utils/debug":101}],31:[function(_dereq_,module,exports){
	var debug = _dereq_('../utils/debug');
	var registerComponent = _dereq_('../core/component').registerComponent;
	var parseUrl = _dereq_('../utils/src-loader').parseUrl;
	var THREE = _dereq_('../lib/three');
	
	var warn = debug('components:loader:warn');
	
	module.exports.Component = registerComponent('loader', {
	  dependencies: [ 'material' ],
	
	  schema: {
	    src: { default: '' },
	    format: {
	      default: 'obj',
	      oneOf: ['obj', 'collada']
	    }
	  },
	
	  init: function () {
	    warn('loader component is deprecated. Use collada-model or obj-model component instead.');
	  },
	
	  update: function () {
	    var el = this.el;
	    var data = this.data;
	    var model = this.model;
	    var url = parseUrl(data.src);
	    var format = data.format;
	    if (model) { el.removeObject3D('mesh'); }
	    if (!url) {
	      warn('Model URL not provided');
	      return;
	    }
	    switch (format) {
	      case 'obj':
	        this.loadObj(url);
	        break;
	      case 'collada':
	        this.loadCollada(url);
	        break;
	      default:
	        warn('Model format not supported');
	    }
	  },
	
	  loadObj: function (objUrl) {
	    var el = this.el;
	    var objLoader = new THREE.OBJLoader();
	    objLoader.load(objUrl, function (object) {
	      this.model = object;
	      this.applyMaterial();
	      el.setObject3D('mesh', object);
	    });
	  },
	
	  applyMaterial: function () {
	    var material = this.el.components.material.material;
	    if (!this.model) { return; }
	    this.model.traverse(function (child) {
	      if (child instanceof THREE.Mesh) {
	        child.material = material;
	      }
	    });
	  },
	
	  loadCollada: function (url) {
	    var self = this;
	    var el = this.el;
	    var loader = new THREE.ColladaLoader();
	    loader.options.convertUpAxis = true;
	    loader.load(url, function (collada) {
	      self.model = collada.scene;
	      el.setObject3D('mesh', collada.scene);
	    });
	  }
	});
	
	},{"../core/component":56,"../lib/three":90,"../utils/debug":101,"../utils/src-loader":103}],32:[function(_dereq_,module,exports){
	var debug = _dereq_('../utils/debug');
	var coordinates = _dereq_('../utils/coordinates');
	var registerComponent = _dereq_('../core/component').registerComponent;
	var THREE = _dereq_('../lib/three');
	
	var warn = debug('components:look-at:warn');
	var isCoordinate = coordinates.isCoordinate;
	
	/**
	 * Look-at component.
	 *
	 * Modifies rotation to either track another entity OR do a one-time turn towards a position
	 * vector.
	 *
	 * If tracking an object via setting the component value via a selector, look-at will register
	 * a behavior to the scene to update rotation on every tick.
	 */
	module.exports.Component = registerComponent('look-at', {
	  schema: {
	    default: '',
	
	    parse: function (value) {
	      // A static position to look at.
	      if (isCoordinate(value) || typeof value === 'object') {
	        return coordinates.parse(value);
	      }
	      // A selector to a target entity.
	      return value;
	    },
	
	    stringify: function (data) {
	      if (typeof data === 'object') {
	        return coordinates.stringify(data);
	      }
	      return data;
	    }
	  },
	
	  init: function () {
	    this.target3D = null;
	    this.vector = new THREE.Vector3();
	  },
	
	  /**
	   * If tracking an object, this will be called on every tick.
	   * If looking at a position vector, this will only be called once (until further updates).
	   */
	  update: function () {
	    var self = this;
	    var target = self.data;
	    var object3D = self.el.object3D;
	    var targetEl;
	
	    // No longer looking at anything (i.e., look-at="").
	    if (!target || (typeof target === 'object' && !Object.keys(target).length)) {
	      return self.remove();
	    }
	
	    // Look at a position.
	    if (typeof target === 'object') {
	      return object3D.lookAt(new THREE.Vector3(target.x, target.y, target.z));
	    }
	
	    // Assume target is a string.
	    // Query for the element, grab its object3D, then register a behavior on the scene to
	    // track the target on every tick.
	    targetEl = self.el.sceneEl.querySelector(target);
	    if (!targetEl) {
	      warn('"' + target + '" does not point to a valid entity to look-at');
	      return;
	    }
	    if (!targetEl.hasLoaded) {
	      return targetEl.addEventListener('loaded', function () {
	        self.beginTracking(targetEl);
	      });
	    }
	    return self.beginTracking(targetEl);
	  },
	
	  tick: function (t) {
	    // Track target object position. Depends on parent object keeping global transforms up
	    // to state with updateMatrixWorld(). In practice, this is handled by the renderer.
	    var target3D = this.target3D;
	    if (target3D) {
	      return this.el.object3D.lookAt(this.vector.setFromMatrixPosition(target3D.matrixWorld));
	    }
	  },
	
	  beginTracking: function (targetEl) {
	    this.target3D = targetEl.object3D;
	  }
	});
	
	},{"../core/component":56,"../lib/three":90,"../utils/coordinates":100,"../utils/debug":101}],33:[function(_dereq_,module,exports){
	var registerComponent = _dereq_('../core/component').registerComponent;
	var THREE = _dereq_('../lib/three');
	
	// To avoid recalculation at every mouse movement tick
	var PI_2 = Math.PI / 2;
	
	module.exports.Component = registerComponent('look-controls', {
	  dependencies: ['position', 'rotation'],
	
	  schema: {
	    enabled: { default: true }
	  },
	
	  init: function () {
	    this.previousPosition = new THREE.Vector3();
	    this.deltaPosition = new THREE.Vector3();
	    this.setupMouseControls();
	    this.setupHMDControls();
	    this.bindMethods();
	  },
	
	  update: function () {
	    if (!this.data.enabled) { return; }
	    this.controls.update();
	    this.updateOrientation();
	    this.updatePosition();
	  },
	
	  play: function () {
	    this.previousPosition.set(0, 0, 0);
	    this.addEventListeners();
	  },
	
	  pause: function () {
	    this.removeEventListeners();
	  },
	
	  tick: function (t) {
	    this.update();
	  },
	
	  remove: function () {
	    this.pause();
	  },
	
	  bindMethods: function () {
	    this.onMouseDown = this.onMouseDown.bind(this);
	    this.onMouseMove = this.onMouseMove.bind(this);
	    this.releaseMouse = this.releaseMouse.bind(this);
	    this.onTouchStart = this.onTouchStart.bind(this);
	    this.onTouchMove = this.onTouchMove.bind(this);
	    this.onTouchEnd = this.onTouchEnd.bind(this);
	  },
	
	  setupMouseControls: function () {
	    // The canvas where the scene is painted
	    this.mouseDown = false;
	    this.pitchObject = new THREE.Object3D();
	    this.yawObject = new THREE.Object3D();
	    this.yawObject.position.y = 10;
	    this.yawObject.add(this.pitchObject);
	  },
	
	  setupHMDControls: function () {
	    this.dolly = new THREE.Object3D();
	    this.euler = new THREE.Euler();
	    this.controls = new THREE.VRControls(this.dolly);
	    this.zeroQuaternion = new THREE.Quaternion();
	  },
	
	  addEventListeners: function () {
	    var sceneEl = this.el.sceneEl;
	    var canvasEl = sceneEl.canvas;
	
	    // listen for canvas to load.
	    if (!canvasEl) {
	      sceneEl.addEventListener('render-target-loaded', this.addEventListeners.bind(this));
	      return;
	    }
	
	    // Mouse Events
	    canvasEl.addEventListener('mousedown', this.onMouseDown, false);
	    canvasEl.addEventListener('mousemove', this.onMouseMove, false);
	    canvasEl.addEventListener('mouseup', this.releaseMouse, false);
	    canvasEl.addEventListener('mouseout', this.releaseMouse, false);
	
	    // Touch events
	    canvasEl.addEventListener('touchstart', this.onTouchStart);
	    canvasEl.addEventListener('touchmove', this.onTouchMove);
	    canvasEl.addEventListener('touchend', this.onTouchEnd);
	  },
	
	  removeEventListeners: function () {
	    var sceneEl = document.querySelector('a-scene');
	    var canvasEl = sceneEl && sceneEl.canvas;
	    if (!canvasEl) { return; }
	
	    // Mouse Events
	    canvasEl.removeEventListener('mousedown', this.onMouseDown);
	    canvasEl.removeEventListener('mousemove', this.onMouseMove);
	    canvasEl.removeEventListener('mouseup', this.releaseMouse);
	    canvasEl.removeEventListener('mouseout', this.releaseMouse);
	
	    // Touch events
	    canvasEl.removeEventListener('touchstart', this.onTouchStart);
	    canvasEl.removeEventListener('touchmove', this.onTouchMove);
	    canvasEl.removeEventListener('touchend', this.onTouchEnd);
	  },
	
	  updateOrientation: (function () {
	    var hmdEuler = new THREE.Euler();
	    hmdEuler.order = 'YXZ';
	    return function () {
	      var pitchObject = this.pitchObject;
	      var yawObject = this.yawObject;
	      var hmdQuaternion = this.calculateHMDQuaternion();
	      hmdEuler.setFromQuaternion(hmdQuaternion);
	      this.el.setAttribute('rotation', {
	        x: THREE.Math.radToDeg(hmdEuler.x) + THREE.Math.radToDeg(pitchObject.rotation.x),
	        y: THREE.Math.radToDeg(hmdEuler.y) + THREE.Math.radToDeg(yawObject.rotation.y),
	        z: THREE.Math.radToDeg(hmdEuler.z)
	      });
	    };
	  })(),
	
	  calculateHMDQuaternion: (function () {
	    var hmdQuaternion = new THREE.Quaternion();
	    return function () {
	      var dolly = this.dolly;
	      if (!this.zeroed && !dolly.quaternion.equals(this.zeroQuaternion)) {
	        this.zeroOrientation();
	        this.zeroed = true;
	      }
	      hmdQuaternion.copy(this.zeroQuaternion).multiply(dolly.quaternion);
	      return hmdQuaternion;
	    };
	  })(),
	
	  updatePosition: function () {
	    var el = this.el;
	    var deltaPosition = this.calculateDeltaPosition();
	    var currentPosition = el.getComputedAttribute('position');
	    el.setAttribute('position', {
	      x: currentPosition.x + deltaPosition.x,
	      y: currentPosition.y + deltaPosition.y,
	      z: currentPosition.z + deltaPosition.z
	    });
	  },
	
	  calculateDeltaPosition: function () {
	    var dolly = this.dolly;
	    var deltaPosition = this.deltaPosition;
	    var previousPosition = this.previousPosition;
	    deltaPosition.copy(dolly.position);
	    deltaPosition.sub(previousPosition);
	    previousPosition.copy(dolly.position);
	    return deltaPosition;
	  },
	
	  updateHMDQuaternion: (function () {
	    var hmdQuaternion = new THREE.Quaternion();
	    return function () {
	      var dolly = this.dolly;
	      this.controls.update();
	      if (!this.zeroed && !dolly.quaternion.equals(this.zeroQuaternion)) {
	        this.zeroOrientation();
	        this.zeroed = true;
	      }
	      hmdQuaternion.copy(this.zeroQuaternion).multiply(dolly.quaternion);
	      return hmdQuaternion;
	    };
	  })(),
	
	  zeroOrientation: function () {
	    var euler = new THREE.Euler();
	    euler.setFromQuaternion(this.dolly.quaternion.clone().inverse());
	    // Cancel out roll and pitch. We want to only reset yaw
	    euler.z = 0;
	    euler.x = 0;
	    this.zeroQuaternion.setFromEuler(euler);
	  },
	
	  onMouseMove: function (event) {
	    var pitchObject = this.pitchObject;
	    var yawObject = this.yawObject;
	    var previousMouseEvent = this.previousMouseEvent;
	
	    if (!this.mouseDown || !this.data.enabled) { return; }
	
	    var movementX = event.movementX || event.mozMovementX;
	    var movementY = event.movementY || event.mozMovementY;
	
	    if (movementX === undefined || movementY === undefined) {
	      movementX = event.screenX - previousMouseEvent.screenX;
	      movementY = event.screenY - previousMouseEvent.screenY;
	    }
	    this.previousMouseEvent = event;
	
	    yawObject.rotation.y -= movementX * 0.002;
	    pitchObject.rotation.x -= movementY * 0.002;
	    pitchObject.rotation.x = Math.max(-PI_2, Math.min(PI_2, pitchObject.rotation.x));
	  },
	
	  onMouseDown: function (event) {
	    this.mouseDown = true;
	    this.previousMouseEvent = event;
	  },
	
	  releaseMouse: function () {
	    this.mouseDown = false;
	  },
	
	  onTouchStart: function (e) {
	    if (e.touches.length !== 1) { return; }
	    this.touchStart = {
	      x: e.touches[0].pageX,
	      y: e.touches[0].pageY
	    };
	    this.touchStarted = true;
	  },
	
	  onTouchMove: function (e) {
	    var deltaY;
	    var yawObject = this.yawObject;
	    if (!this.touchStarted) { return; }
	    deltaY = 2 * Math.PI * (e.touches[0].pageX - this.touchStart.x) /
	            this.el.sceneEl.canvas.clientWidth;
	    // Limits touch orientaion to to yaw (y axis)
	    yawObject.rotation.y -= deltaY * 0.5;
	    this.touchStart = {
	      x: e.touches[0].pageX,
	      y: e.touches[0].pageY
	    };
	  },
	
	  onTouchEnd: function () {
	    this.touchStarted = false;
	  }
	});
	
	},{"../core/component":56,"../lib/three":90}],34:[function(_dereq_,module,exports){
	/* global Promise */
	var debug = _dereq_('../utils/debug');
	var utils = _dereq_('../utils');
	var component = _dereq_('../core/component');
	var THREE = _dereq_('../lib/three');
	var shader = _dereq_('../core/shader');
	
	var error = debug('components:material:error');
	var diff = utils.diff;
	var registerComponent = component.registerComponent;
	var shaders = shader.shaders;
	var shaderNames = shader.shaderNames;
	
	/**
	 * Material component.
	 *
	 * @member {object} shader - Determines how material is shaded. Defaults to `standard`,
	 *         three.js's implementation of PBR. Another standard shading model is `flat` which
	 *         uses MeshBasicMaterial.
	 */
	module.exports.Component = registerComponent('material', {
	  schema: {
	    shader: { default: 'standard', oneOf: shaderNames },
	    transparent: { default: false },
	    opacity: { default: 1.0, min: 0.0, max: 1.0 },
	    side: { default: 'front', oneOf: ['front', 'back', 'double'] },
	    depthTest: { default: true }
	  },
	
	  init: function () {
	    this.material = null;
	  },
	
	  /**
	   * Update or create material.
	   *
	   * @param {object|null} oldData
	   */
	  update: function (oldData) {
	    var data = this.data;
	    var dataDiff = oldData ? diff(oldData, data) : data;
	
	    if (!this.shader || dataDiff.shader) {
	      this.updateShader(data.shader);
	    }
	    this.shader.update(this.data);
	    this.updateMaterial();
	  },
	
	  updateSchema: function (data) {
	    var newShader = data.shader;
	    var currentShader = this.data && this.data.shader;
	    var shader = newShader || currentShader;
	    var schema = shaders[shader] && shaders[shader].schema;
	    if (!schema) { error('Unknown shader schema ' + shader); }
	    if (currentShader && newShader === currentShader) { return; }
	    this.extendSchema(schema);
	    this.updateBehavior();
	  },
	
	  updateBehavior: function () {
	    var scene = this.el.sceneEl;
	    var schema = this.schema;
	    var self = this;
	    var tickProperties = {};
	    var tick = function (time, delta) {
	      var keys = Object.keys(tickProperties);
	      keys.forEach(update);
	      function update (key) { tickProperties[key] = time; }
	      self.shader.update(tickProperties);
	    };
	    var keys = Object.keys(schema);
	    keys.forEach(function (key) {
	      if (schema[key].type === 'time') {
	        self.tick = tick;
	        tickProperties[key] = true;
	        scene.addBehavior(self);
	      }
	    });
	    if (Object.keys(tickProperties).length === 0) {
	      scene.removeBehavior(this);
	    }
	  },
	
	  updateShader: function (shaderName) {
	    var data = this.data;
	    var Shader = shaders[shaderName] && shaders[shaderName].Shader;
	    var material;
	    if (!Shader) { throw new Error('Unknown shader ' + shaderName); }
	    this.shader = new Shader();
	    this.shader.el = this.el;
	    material = this.shader.init(data);
	    this.setMaterial(material);
	    this.updateSchema(data);
	  },
	
	  updateMaterial: function () {
	    var data = this.data;
	    var material = this.material;
	    material.side = parseSide(data.side);
	    material.opacity = data.opacity;
	    material.transparent = data.transparent !== false || data.opacity < 1.0;
	    material.depthTest = data.depthTest !== false;
	  },
	
	  /**
	   * Remove material on remove (callback).
	   */
	  remove: function () {
	    var defaultMaterial = new THREE.MeshBasicMaterial();
	    var object3D = this.el.getObject3D('mesh');
	    if (object3D) { object3D.material = defaultMaterial; }
	    this.system.unregisterMaterial(this.material);
	  },
	
	  /**
	   * (Re)create new material. Has side-effects of setting `this.material` and updating
	   * material registration in scene.
	   *
	   * @param {object} data - Material component data.
	   * @param {object} type - Material type to create.
	   * @returns {object} Material.
	   */
	  setMaterial: function (material) {
	    var mesh = this.el.getOrCreateObject3D('mesh', THREE.Mesh);
	    var system = this.system;
	    if (this.material) { system.unregisterMaterial(this.material); }
	    this.material = mesh.material = material;
	    system.registerMaterial(material);
	  }
	});
	
	/**
	 * Returns a three.js constant determining which material face sides to render
	 * based on the side parameter (passed as a component property).
	 *
	 * @param {string} [side=front] - `front`, `back`, or `double`.
	 * @returns {number} THREE.FrontSide, THREE.BackSide, or THREE.DoubleSide.
	 */
	function parseSide (side) {
	  switch (side) {
	    case 'back': {
	      return THREE.BackSide;
	    }
	    case 'double': {
	      return THREE.DoubleSide;
	    }
	    default: {
	      // Including case `front`.
	      return THREE.FrontSide;
	    }
	  }
	}
	
	},{"../core/component":56,"../core/shader":63,"../lib/three":90,"../utils":102,"../utils/debug":101}],35:[function(_dereq_,module,exports){
	/* global HTMLElement */
	var debug = _dereq_('../utils/debug');
	var registerComponent = _dereq_('../core/component').registerComponent;
	var THREE = _dereq_('../lib/three');
	
	var warn = debug('components:obj-model:warn');
	
	module.exports.Component = registerComponent('obj-model', {
	  dependencies: ['material'],
	
	  schema: {
	    mtl: { type: 'src' },
	    obj: { type: 'src' }
	  },
	
	  init: function () {
	    this.model = null;
	    this.objLoader = new THREE.OBJLoader();
	    this.mtlLoader = new THREE.MTLLoader(this.objLoader.manager);
	  },
	
	  update: function () {
	    var data = this.data;
	    if (!data.obj) { return; }
	    this.remove();
	    this.loadObj(data.obj, data.mtl);
	  },
	
	  remove: function () {
	    if (!this.model) { return; }
	    this.el.removeObject3D('mesh');
	  },
	
	  loadObj: function (objUrl, mtlUrl) {
	    var self = this;
	    var el = this.el;
	    var mtlLoader = this.mtlLoader;
	    var objLoader = this.objLoader;
	
	    if (mtlUrl) {
	      // .OBJ with an .MTL.
	      if (HTMLElement.prototype.getAttribute.call(el, 'material')) {
	        warn('Material component properties are ignored when a .MTL is provided');
	      }
	      mtlLoader.setBaseUrl(mtlUrl.substr(0, mtlUrl.lastIndexOf('/') + 1));
	      mtlLoader.load(mtlUrl, function (materials) {
	        materials.preload();
	        objLoader.setMaterials(materials);
	        objLoader.load(objUrl, function (objModel) {
	          self.model = objModel;
	          el.setObject3D('mesh', objModel);
	          el.emit('model-loaded', {format: 'obj', model: objModel});
	        });
	      });
	      return;
	    }
	
	    // .OBJ only.
	    objLoader.load(objUrl, function (objModel) {
	      // Apply material.
	      var material = el.components.material.material;
	      objModel.traverse(function (child) {
	        if (child instanceof THREE.Mesh) {
	          child.material = material;
	        }
	      });
	
	      self.model = objModel;
	      el.setObject3D('mesh', objModel);
	      el.emit('model-loaded', {format: 'obj', model: objModel});
	    });
	  }
	});
	
	},{"../core/component":56,"../lib/three":90,"../utils/debug":101}],36:[function(_dereq_,module,exports){
	var registerComponent = _dereq_('../core/component').registerComponent;
	
	module.exports.Component = registerComponent('position', {
	  schema: { type: 'vec3' },
	
	  update: function () {
	    var object3D = this.el.object3D;
	    var data = this.data;
	    object3D.position.set(data.x, data.y, data.z);
	  }
	});
	
	},{"../core/component":56}],37:[function(_dereq_,module,exports){
	var registerComponent = _dereq_('../core/component').registerComponent;
	var requestInterval = _dereq_('request-interval');
	var THREE = _dereq_('../lib/three');
	
	module.exports.Component = registerComponent('raycaster', {
	  init: function () {
	    this.raycaster = new THREE.Raycaster();
	    this.intersectedEl = null;
	  },
	
	  play: function () {
	    this.pollForHoverIntersections();
	  },
	
	  pause: function () {
	    var pollInterval = this.pollInterval;
	    if (!pollInterval) { return; }
	    requestInterval.clear(this.pollInterval);
	  },
	
	  remove: function () {
	    this.pause();
	  },
	
	  pollForHoverIntersections: function () {
	    this.pollInterval = requestInterval(100, this.getIntersections.bind(this));
	  },
	
	  getIntersections: function () {
	    var closest = this.getClosestIntersected();
	    if (closest) {
	      this.handleIntersection(closest);
	      return;
	    }
	    // If we have no intersections other than the cursor itself,
	    // but we still have a previously intersected element, clear it.
	    if (this.intersectedEl) {
	      this.clearExistingIntersection();
	    }
	  },
	
	  intersect: function (objects) {
	    var el = this.el;
	    var raycaster = this.raycaster;
	    var cursor = el.object3D;
	    var parent = el.parentNode.object3D;
	    var originPosition = new THREE.Vector3().setFromMatrixPosition(parent.matrixWorld);
	    var cursorPosition = new THREE.Vector3().setFromMatrixPosition(cursor.matrixWorld);
	    var direction = cursorPosition.sub(originPosition).normalize();
	    raycaster.set(originPosition, direction);
	    return raycaster.intersectObjects(objects, true);
	  },
	
	  /**
	   * Returns the closest intersected object.
	   *
	   * @returns {Object|null}
	   *   The closest intersected element that is not the cursor itself,
	   *   an invisible element, or not a a-frame entity element.
	   *   If no objects are intersected, `null` is returned.
	   */
	  getClosestIntersected: function () {
	    var scene = this.el.sceneEl.object3D;
	    var cursorEl = this.el;
	    var intersectedObj;
	    var intersectedObjs = this.intersect(scene.children);
	    for (var i = 0; i < intersectedObjs.length; ++i) {
	      intersectedObj = intersectedObjs[i];
	
	      while (intersectedObj.object.parent && intersectedObj.object.el === undefined) {
	        intersectedObj.object = intersectedObj.object.parent;
	      }
	
	      // If the intersected object is the cursor itself
	      // or the object is further than the max distance
	
	      if (intersectedObj.object.el === undefined) { continue; }
	      if (intersectedObj.object.el === cursorEl) { continue; }
	      if (!intersectedObj.object.visible) { continue; }
	      return intersectedObj;
	    }
	    return null;
	  },
	
	  /**
	   * Remembers the last intersected element
	   */
	  setExistingIntersection: function (el, distance) {
	    this.intersectedEl = el;
	    this.el.emit('intersection', { el: el, distance: distance });
	  },
	
	  /**
	   * Emits a `mouseleave` event and clears info about the last intersection.
	   */
	  clearExistingIntersection: function () {
	    var intersectedEl = this.intersectedEl;
	    this.el.emit('intersectioncleared', { el: intersectedEl });
	    this.intersectedEl = null;
	  },
	
	  handleIntersection: function (obj) {
	    var el = obj.object.el;
	
	    // A new intersection where previously a different element was
	    // and now needs a mouseleave event.
	    if (this.intersectedEl !== el) {
	      this.clearExistingIntersection();
	    }
	    this.setExistingIntersection(el, obj.distance);
	  }
	});
	
	},{"../core/component":56,"../lib/three":90,"request-interval":12}],38:[function(_dereq_,module,exports){
	var degToRad = _dereq_('../lib/three').Math.degToRad;
	var registerComponent = _dereq_('../core/component').registerComponent;
	
	module.exports.Component = registerComponent('rotation', {
	  schema: { type: 'vec3' },
	
	  /**
	   * Updates object3D rotation.
	   */
	  update: function () {
	    var data = this.data;
	    var object3D = this.el.object3D;
	    object3D.rotation.set(degToRad(data.x), degToRad(data.y), degToRad(data.z));
	    object3D.rotation.order = 'YXZ';
	  }
	});
	
	},{"../core/component":56,"../lib/three":90}],39:[function(_dereq_,module,exports){
	var registerComponent = _dereq_('../core/component').registerComponent;
	
	// Avoids triggering a zero-determinant which makes object3D matrix non-invertible.
	var zeroScale = 0.00001;
	
	module.exports.Component = registerComponent('scale', {
	  schema: {
	    type: 'vec3',
	    default: { x: 1, y: 1, z: 1 }
	  },
	
	  update: function () {
	    var data = this.data;
	    var object3D = this.el.object3D;
	    var x = data.x === 0 ? zeroScale : data.x;
	    var y = data.y === 0 ? zeroScale : data.y;
	    var z = data.z === 0 ? zeroScale : data.z;
	    object3D.scale.set(x, y, z);
	  }
	});
	
	},{"../core/component":56}],40:[function(_dereq_,module,exports){
	var register = _dereq_('../../core/component').registerComponent;
	
	module.exports.Component = register('canvas', {
	  schema: {
	    canvas: {
	      type: 'selector',
	      default: undefined
	    },
	    height: {
	      default: 100
	    },
	    width: {
	      default: 100
	    }
	  },
	
	  update: function () {
	    var data = this.data;
	    var canvas = data.canvas;
	    var scene = this.el;
	
	    // No updating canvas.
	    if (scene.canvas) { return; }
	
	    // Inject canvas if one not specified with height and width.
	    if (!canvas) {
	      canvas = document.createElement('canvas');
	      canvas.classList.add('a-canvas');
	      canvas.style.height = data.height + '%';
	      canvas.style.width = data.width + '%';
	      scene.appendChild(canvas);
	    }
	
	    // Prevent overscroll on mobile.
	    canvas.addEventListener('touchmove', function (event) {
	      event.preventDefault();
	    });
	
	    // Set canvas on scene.
	    scene.canvas = canvas;
	    scene.emit('render-target-loaded', {
	      target: canvas
	    });
	  }
	});
	
	},{"../../core/component":56}],41:[function(_dereq_,module,exports){
	var register = _dereq_('../../core/component').registerComponent;
	var THREE = _dereq_('../../lib/three');
	var debug = _dereq_('../../utils/debug');
	
	var warn = debug('components:fog:warn');
	
	/**
	 * Fog component.
	 * Applies only to the scene entity.
	 */
	module.exports.Component = register('fog', {
	  schema: {
	    color: { default: '#000' },
	    density: { default: 0.00025 },
	    far: { default: 1000, min: 0 },
	    near: { default: 1, min: 0 },
	    type: { default: 'linear', oneOf: ['linear', 'exponential'] }
	  },
	
	  update: function () {
	    var data = this.data;
	    var el = this.el;
	    var fog = this.el.object3D.fog;
	
	    if (!el.isScene) {
	      warn('Fog component can only be applied to <a-scene>');
	      return;
	    }
	
	    // (Re)create fog if fog doesn't exist or fog type changed.
	    if (!fog || data.type !== fog.name) {
	      el.object3D.fog = getFog(data);
	      el.systems.material.updateMaterials();
	      return;
	    }
	
	    // Fog data changed. Update fog.
	    Object.keys(this.schema).forEach(function (key) {
	      var value = data[key];
	      if (key === 'color') { value = new THREE.Color(value); }
	      fog[key] = value;
	    });
	  },
	
	  /**
	   * Remove fog on remove (callback).
	   */
	  remove: function () {
	    var fog = this.el.object3D.fog;
	    if (fog) {
	      fog.density = 0;
	      fog.far = 0;
	      fog.near = 0;
	    }
	  }
	});
	
	/**
	 * Creates a fog object. Sets fog.name to be able to detect fog type changes.
	 *
	 * @param {object} data - Fog data.
	 * @returns {object} fog
	 */
	function getFog (data) {
	  var fog;
	  if (data.type === 'exponential') {
	    fog = new THREE.FogExp2(data.color, data.density);
	  } else {
	    fog = new THREE.Fog(data.color, data.near, data.far);
	  }
	  fog.name = data.type;
	  return fog;
	}
	
	},{"../../core/component":56,"../../lib/three":90,"../../utils/debug":101}],42:[function(_dereq_,module,exports){
	var registerComponent = _dereq_('../../core/component').registerComponent;
	var shouldCaptureKeyEvent = _dereq_('../../utils/').shouldCaptureKeyEvent;
	var THREE = _dereq_('../../lib/three');
	
	var controls = new THREE.VRControls(new THREE.Object3D());
	
	module.exports.Component = registerComponent('keyboard-shortcuts', {
	  schema: {
	    enterVR: { default: true },
	    resetSensor: { default: true }
	  },
	
	  init: function () {
	    var self = this;
	    var scene = this.el;
	
	    this.listener = window.addEventListener('keyup', function (event) {
	      if (!shouldCaptureKeyEvent(event)) { return; }
	      if (self.enterVREnabled && event.keyCode === 70) {  // f.
	        scene.enterVR();
	      }
	      if (self.resetSensorEnabled && event.keyCode === 90) {  // z.
	        controls.resetSensor();
	      }
	    }, false);
	  },
	
	  update: function (oldData) {
	    var data = this.data;
	    this.enterVREnabled = data.enterVR;
	    this.resetSensorEnabled = data.resetSensor;
	  },
	
	  remove: function () {
	    window.removeEventListener('keyup', this.listener);
	  }
	});
	
	},{"../../core/component":56,"../../lib/three":90,"../../utils/":102}],43:[function(_dereq_,module,exports){
	var registerComponent = _dereq_('../../core/component').registerComponent;
	var RStats = _dereq_('../../../vendor/rStats');
	_dereq_('../../../vendor/rStats.extras');
	_dereq_('../../lib/rStatsAframe');
	
	var HIDDEN_CLASS = 'a-hidden';
	var ThreeStats = window.threeStats;
	var AFrameStats = window.aframeStats;
	
	/**
	 * Stats appended to document.body by RStats.
	 */
	module.exports.Component = registerComponent('stats', {
	  init: function () {
	    var scene = this.el;
	    this.stats = createStats(scene);
	    this.statsEl = document.querySelector('.rs-base');
	
	    this.hideBound = this.hide.bind(this);
	    this.showBound = this.show.bind(this);
	
	    scene.addEventListener('enter-vr', this.hideBound);
	    scene.addEventListener('exit-vr', this.showBound);
	  },
	
	  remove: function () {
	    this.el.removeEventListener('enter-vr', this.hideBound);
	    this.el.removeEventListener('exit-vr', this.showBound);
	    this.statsEl.parentNode.removeChild(this.statsEl);
	  },
	
	  tick: function () {
	    var stats = this.stats;
	    stats('rAF').tick();
	    stats('FPS').frame();
	    stats().update();
	  },
	
	  hide: function () {
	    this.statsEl.classList.add(HIDDEN_CLASS);
	  },
	
	  show: function () {
	    this.statsEl.classList.remove(HIDDEN_CLASS);
	  }
	});
	
	function createStats (scene) {
	  var threeStats = new ThreeStats(scene.renderer);
	  var aframeStats = new AFrameStats(scene);
	  var plugins = scene.isMobile ? [] : [threeStats, aframeStats];
	  return new RStats({
	    css: [],  // Our stylesheet is injected from `src/index.js`.
	    values: {
	      fps: {caption: 'fps', below: 30}
	    },
	    groups: [
	      {caption: 'Framerate', values: ['fps', 'raf']}
	    ],
	    plugins: plugins
	  });
	}
	
	},{"../../../vendor/rStats":107,"../../../vendor/rStats.extras":106,"../../core/component":56,"../../lib/rStatsAframe":89}],44:[function(_dereq_,module,exports){
	var registerComponent = _dereq_('../../core/component').registerComponent;
	var THREE = _dereq_('../../lib/three');
	var utils = _dereq_('../../utils/');
	
	var dummyDolly = new THREE.Object3D();
	var controls = new THREE.VRControls(dummyDolly);
	
	var ENTER_VR_CLASS = 'a-enter-vr';
	var ENTER_VR_NO_HEADSET = 'data-a-enter-vr-no-headset';
	var ENTER_VR_NO_WEBVR = 'data-a-enter-vr-no-webvr';
	var ENTER_VR_BTN_CLASS = 'a-enter-vr-button';
	var ENTER_VR_MODAL_CLASS = 'a-enter-vr-modal';
	var HIDDEN_CLASS = 'a-hidden';
	var ORIENTATION_MODAL_CLASS = 'a-orientation-modal';
	
	/**
	 * UI for entering VR mode.
	 */
	module.exports.Component = registerComponent('vr-mode-ui', {
	  dependencies: [ 'canvas' ],
	
	  schema: {
	    enabled: { default: true }
	  },
	
	  init: function () {
	    var self = this;
	    var scene = this.el;
	
	    this.enterVR = scene.enterVR.bind(scene);
	    this.exitVR = scene.exitVR.bind(scene);
	    this.insideLoader = false;
	    this.enterVREl = null;
	    this.orientationModalEl = null;
	
	    // Hide/show VR UI when entering/exiting VR mode.
	    scene.addEventListener('enter-vr', this.updateEnterVRInterface.bind(this));
	    scene.addEventListener('exit-vr', this.updateEnterVRInterface.bind(this));
	
	    window.addEventListener('message', function (event) {
	      if (event.data.type === 'loaderReady') {
	        self.insideLoader = true;
	        self.remove();
	      }
	    });
	
	    // Modal that tells the user to change orientation if in portrait.
	    window.addEventListener('orientationchange', this.toggleOrientationModalIfNeeded.bind(this));
	  },
	
	  update: function () {
	    var scene = this.el;
	
	    if (!this.data.enabled || this.insideLoader) { return this.remove(); }
	    if (this.enterVREl || this.orientationModalEl) { return; }
	
	    // Add UI if enabled and not already present.
	    this.enterVREl = createEnterVR(this.enterVR, scene.isMobile);
	    this.el.appendChild(this.enterVREl);
	
	    this.orientationModalEl = createOrientationModal(this.exitVR);
	    this.el.appendChild(this.orientationModalEl);
	
	    this.updateEnterVRInterface();
	  },
	
	  remove: function () {
	    [this.enterVREl, this.orientationModalEl].forEach(function (uiElement) {
	      if (uiElement) {
	        uiElement.parentNode.removeChild(uiElement);
	      }
	    });
	  },
	
	  updateEnterVRInterface: function () {
	    this.toggleEnterVRButtonIfNeeded();
	    this.toggleOrientationModalIfNeeded();
	  },
	
	  toggleEnterVRButtonIfNeeded: function () {
	    if (!this.enterVREl) { return; }
	    var scene = this.el;
	    if (scene.is('vr-mode')) {
	      this.enterVREl.classList.add(HIDDEN_CLASS);
	    } else {
	      this.enterVREl.classList.remove(HIDDEN_CLASS);
	    }
	  },
	
	  toggleOrientationModalIfNeeded: function () {
	    var scene = this.el;
	    if (!this.orientationModalEl || !scene.isMobile) { return; }
	    if (!utils.isLandscape() && scene.is('vr-mode')) {
	      // Show if in VR mode on portrait.
	      this.orientationModalEl.classList.remove(HIDDEN_CLASS);
	    } else {
	      this.orientationModalEl.classList.add(HIDDEN_CLASS);
	    }
	  }
	});
	
	/**
	 * Creates Enter VR flow (button and compatibility modal).
	 *
	 * Creates a button that when clicked will enter into stereo-rendering mode for VR.
	 *
	 * For compatibility:
	 *   - Mobile always has compatibility via polyfill.
	 *   - If desktop browser does not have WebVR excluding polyfill, disable button, show modal.
	 *   - If desktop browser has WebVR excluding polyfill but not headset connected,
	 *     don't disable button, but show modal.
	 *   - If desktop browser has WebVR excluding polyfill and has headset connected, then
	 *     then no modal.
	 *
	 * Structure: <div><modal/><button></div>
	 *
	 * @returns {Element} Wrapper <div>.
	 */
	function createEnterVR (enterVRHandler, isMobile) {
	  var compatModal;
	  var compatModalLink;
	  var compatModalText;
	  // window.hasNonPolyfillWebVRSupport is set in src/index.js.
	  var hasWebVR = isMobile || window.hasNonPolyfillWebVRSupport;
	  var orientation;
	  var vrButton;
	  var wrapper;
	
	  // Create elements.
	  wrapper = document.createElement('div');
	  wrapper.classList.add(ENTER_VR_CLASS);
	  compatModal = document.createElement('div');
	  compatModal.className = ENTER_VR_MODAL_CLASS;
	  compatModalText = document.createElement('p');
	  compatModalLink = document.createElement('a');
	  compatModalLink.setAttribute('href', 'http://mozvr.com/#start');
	  compatModalLink.setAttribute('target', '_blank');
	  compatModalLink.innerHTML = 'Learn more.';
	  vrButton = document.createElement('button');
	  vrButton.className = ENTER_VR_BTN_CLASS;
	
	  // Insert elements.
	  wrapper.appendChild(vrButton);
	  if (compatModal) {
	    compatModal.appendChild(compatModalText);
	    compatModal.appendChild(compatModalLink);
	    wrapper.appendChild(compatModal);
	  }
	
	  if (!checkHeadsetConnected() && !isMobile) {
	    compatModalText.innerHTML = 'Your browser supports WebVR. To enter VR, connect a headset, or use a mobile phone.';
	    wrapper.setAttribute(ENTER_VR_NO_HEADSET, '');
	  }
	
	  // Handle enter VR flows.
	  if (!hasWebVR) {
	    compatModalText.innerHTML = 'Your browser does not support WebVR. To enter VR, use a VR-compatible browser or a mobile phone.';
	    wrapper.setAttribute(ENTER_VR_NO_WEBVR, '');
	  } else {
	    vrButton.addEventListener('click', enterVRHandler);
	  }
	  return wrapper;
	
	  /**
	   * Check for headset connection by looking at orientation {0 0 0}.
	   */
	  function checkHeadsetConnected () {
	    controls.update();
	    orientation = dummyDolly.quaternion;
	    if (orientation._x !== 0 || orientation._y !== 0 || orientation._z !== 0) {
	      return true;
	    }
	  }
	}
	
	/**
	 * Create a modal that tells mobile users to orient the phone to landscape.
	 * Add a close button that if clicked, exits VR and closes the modal.
	 */
	function createOrientationModal (exitVRHandler) {
	  var modal = document.createElement('div');
	  modal.className = ORIENTATION_MODAL_CLASS;
	  modal.classList.add(HIDDEN_CLASS);
	
	  var exit = document.createElement('button');
	  exit.innerHTML = 'Exit VR';
	
	  // Exit VR on close.
	  exit.addEventListener('click', exitVRHandler);
	
	  modal.appendChild(exit);
	
	  return modal;
	}
	
	},{"../../core/component":56,"../../lib/three":90,"../../utils/":102}],45:[function(_dereq_,module,exports){
	var debug = _dereq_('../utils/debug');
	var diff = _dereq_('../utils').diff;
	var registerComponent = _dereq_('../core/component').registerComponent;
	var THREE = _dereq_('../lib/three');
	
	var warn = debug('components:sound:warn');
	
	/**
	 * Sound component.
	 */
	module.exports.Component = registerComponent('sound', {
	  schema: {
	    src: { default: '' },
	    on: { default: 'click' },
	    autoplay: { default: false },
	    loop: { default: false },
	    volume: { default: 1 }
	  },
	
	  init: function () {
	    this.listener = null;
	    this.sound = null;
	  },
	
	  update: function (oldData) {
	    var data = this.data;
	    var diffData = diff(oldData || {}, data);
	    var el = this.el;
	    var sound = this.sound;
	    var src = data.src;
	    var srcChanged = 'src' in diffData;
	
	    // Create new sound if not yet created or changing `src`.
	    if (srcChanged) {
	      if (!src) {
	        warn('Audio source was not specified with `src`');
	        return;
	      }
	      sound = this.setupSound();
	    }
	
	    if (srcChanged || 'autoplay' in diffData) {
	      sound.autoplay = data.autoplay;
	    }
	
	    if (srcChanged || 'loop' in diffData) {
	      sound.setLoop(data.loop);
	    }
	
	    if (srcChanged || 'volume' in diffData) {
	      sound.setVolume(data.volume);
	    }
	
	    if ('on' in diffData) {
	      if (oldData && oldData.on) {
	        el.removeEventListener(oldData.on);
	      }
	      el.addEventListener(data.on, this.play.bind(this));
	    }
	
	    // All sound values set. Load in `src.
	    if (srcChanged) {
	      sound.load(src);
	    }
	  },
	
	  remove: function () {
	    this.el.removeObject3D('sound');
	    this.sound.disconnect();
	  },
	
	  /**
	   * Removes current sound object, creates new sound object, adds to entity.
	   *
	   * @returns {object} sound
	   */
	  setupSound: function () {
	    var el = this.el;
	    var sceneEl = el.sceneEl;
	    var sound = this.sound;
	
	    if (sound) {
	      this.stop();
	      el.removeObject3D('sound');
	    }
	
	    // Only want one AudioListener. Cache it on the scene.
	    var listener = this.listener = sceneEl.audioListener || new THREE.AudioListener();
	    sceneEl.audioListener = listener;
	
	    if (sceneEl.camera) {
	      sceneEl.camera.add(listener);
	    }
	
	    // Wait for camera if necessary.
	    sceneEl.addEventListener('camera-set-active', function (evt) {
	      evt.detail.cameraEl.getObject3D('camera').add(listener);
	    });
	
	    sound = this.sound = new THREE.PositionalAudio(listener);
	    el.setObject3D('sound', sound);
	
	    sound.source.onended = function () {
	      sound.onEnded();
	      el.emit('sound-ended');
	    };
	
	    return sound;
	  },
	
	  play: function () {
	    if (!this.sound.source.buffer) { return; }
	    this.sound.play();
	  },
	
	  stop: function () {
	    if (!this.sound.source.buffer) { return; }
	    this.sound.stop();
	  },
	
	  pause: function () {
	    if (!this.sound.source.buffer || !this.sound.isPlaying) { return; }
	    this.sound.pause();
	  }
	});
	
	},{"../core/component":56,"../lib/three":90,"../utils":102,"../utils/debug":101}],46:[function(_dereq_,module,exports){
	var registerComponent = _dereq_('../core/component').registerComponent;
	
	/**
	 * Visibility component.
	 */
	module.exports.Component = registerComponent('visible', {
	  schema: {
	    type: 'boolean',
	    default: true
	  },
	
	  update: function () {
	    this.el.object3D.visible = this.data;
	  }
	});
	
	},{"../core/component":56}],47:[function(_dereq_,module,exports){
	var registerComponent = _dereq_('../core/component').registerComponent;
	var shouldCaptureKeyEvent = _dereq_('../utils/').shouldCaptureKeyEvent;
	var THREE = _dereq_('../lib/three');
	
	var MAX_DELTA = 0.2;
	
	/**
	 * WASD component to control entities using WASD keys.
	 */
	module.exports.Component = registerComponent('wasd-controls', {
	  schema: {
	    easing: { default: 20 },
	    acceleration: { default: 65 },
	    enabled: { default: true },
	    fly: { default: false },
	    wsAxis: { default: 'z', oneOf: [ 'x', 'y', 'z' ] },
	    adAxis: { default: 'x', oneOf: [ 'x', 'y', 'z' ] },
	    wsInverted: { default: false },
	    wsEnabled: { default: true },
	    adInverted: { default: false },
	    adEnabled: { default: true }
	  },
	
	  init: function () {
	    this.velocity = new THREE.Vector3();
	    // To keep track of the pressed keys
	    this.keys = {};
	    this.onBlur = this.onBlur.bind(this);
	    this.onFocus = this.onFocus.bind(this);
	    this.onVisibilityChange = this.onVisibilityChange.bind(this);
	    this.onKeyDown = this.onKeyDown.bind(this);
	    this.onKeyUp = this.onKeyUp.bind(this);
	    this.attachVisibilityEventListeners();
	  },
	
	  update: function (previousData) {
	    var data = this.data;
	    var acceleration = data.acceleration;
	    var easing = data.easing;
	    var velocity = this.velocity;
	    var prevTime = this.prevTime = this.prevTime || Date.now();
	    var time = window.performance.now();
	    var delta = (time - prevTime) / 1000;
	    var keys = this.keys;
	    var movementVector;
	    var adAxis = data.adAxis;
	    var wsAxis = data.wsAxis;
	    var adSign = data.adInverted ? -1 : 1;
	    var wsSign = data.wsInverted ? -1 : 1;
	    var el = this.el;
	    this.prevTime = time;
	
	    // If data changed or FPS too low, reset velocity.
	    if (previousData || delta > MAX_DELTA) {
	      velocity[adAxis] = 0;
	      velocity[wsAxis] = 0;
	      return;
	    }
	
	    velocity[adAxis] -= velocity[adAxis] * easing * delta;
	    velocity[wsAxis] -= velocity[wsAxis] * easing * delta;
	
	    var position = el.getComputedAttribute('position');
	
	    if (data.enabled) {
	      if (data.adEnabled) {
	        if (keys[65]) { velocity[adAxis] -= adSign * acceleration * delta; } // Left
	        if (keys[68]) { velocity[adAxis] += adSign * acceleration * delta; } // Right
	      }
	      if (data.wsEnabled) {
	        if (keys[87]) { velocity[wsAxis] -= wsSign * acceleration * delta; } // Up
	        if (keys[83]) { velocity[wsAxis] += wsSign * acceleration * delta; } // Down
	      }
	    }
	
	    movementVector = this.getMovementVector(delta);
	    el.object3D.translateX(movementVector.x);
	    el.object3D.translateY(movementVector.y);
	    el.object3D.translateZ(movementVector.z);
	
	    el.setAttribute('position', {
	      x: position.x + movementVector.x,
	      y: position.y + movementVector.y,
	      z: position.z + movementVector.z
	    });
	  },
	
	  play: function () {
	    this.attachKeyEventListeners();
	  },
	
	  pause: function () {
	    this.keys = {};
	    this.removeKeyEventListeners();
	  },
	
	  tick: function (t) {
	    this.update();
	  },
	
	  remove: function () {
	    this.pause();
	    this.removeVisibilityEventListeners();
	  },
	
	  attachVisibilityEventListeners: function () {
	    window.addEventListener('blur', this.onBlur);
	    window.addEventListener('focus', this.onFocus);
	    document.addEventListener('visibilitychange', this.onVisibilityChange);
	  },
	
	  removeVisibilityEventListeners: function () {
	    window.removeEventListener('blur', this.onBlur);
	    window.removeEventListener('focus', this.onFocus);
	    document.removeEventListener('visibilitychange', this.onVisibilityChange);
	  },
	
	  attachKeyEventListeners: function () {
	    window.addEventListener('keydown', this.onKeyDown);
	    window.addEventListener('keyup', this.onKeyUp);
	  },
	
	  removeKeyEventListeners: function () {
	    window.removeEventListener('keydown', this.onKeyDown);
	    window.removeEventListener('keyup', this.onKeyUp);
	  },
	
	  onBlur: function () {
	    this.pause();
	  },
	
	  onFocus: function () {
	    this.play();
	  },
	
	  onVisibilityChange: function () {
	    if (document.hidden) {
	      this.onBlur();
	    } else {
	      this.onFocus();
	    }
	  },
	
	  onKeyDown: function (event) {
	    if (!shouldCaptureKeyEvent(event)) { return; }
	    this.keys[event.keyCode] = true;
	  },
	
	  onKeyUp: function (event) {
	    if (!shouldCaptureKeyEvent(event)) { return; }
	    this.keys[event.keyCode] = false;
	  },
	
	  getMovementVector: (function (delta) {
	    var direction = new THREE.Vector3(0, 0, 0);
	    var rotation = new THREE.Euler(0, 0, 0, 'YXZ');
	    return function (delta) {
	      var velocity = this.velocity;
	      var elRotation = this.el.getAttribute('rotation');
	      direction.copy(velocity);
	      direction.multiplyScalar(delta);
	      if (!elRotation) { return direction; }
	      if (!this.data.fly) { elRotation.x = 0; }
	      rotation.set(THREE.Math.degToRad(elRotation.x),
	                   THREE.Math.degToRad(elRotation.y), 0);
	      direction.applyEuler(rotation);
	      return direction;
	    };
	  })()
	});
	
	},{"../core/component":56,"../lib/three":90,"../utils/":102}],48:[function(_dereq_,module,exports){
	/**
	 * Animation configuration options for TWEEN.js animations.
	 * Used by `<a-animation>`.
	 */
	var TWEEN = _dereq_('tween.js');
	
	var DIRECTIONS = {
	  alternate: 'alternate',
	  alternateReverse: 'alternate-reverse',
	  normal: 'normal',
	  reverse: 'reverse'
	};
	
	var EASING_FUNCTIONS = {
	  'linear': TWEEN.Easing.Linear.None,
	
	  'ease': TWEEN.Easing.Cubic.InOut,
	  'ease-in': TWEEN.Easing.Cubic.In,
	  'ease-out': TWEEN.Easing.Cubic.Out,
	  'ease-in-out': TWEEN.Easing.Cubic.InOut,
	
	  'ease-cubic': TWEEN.Easing.Cubic.In,
	  'ease-in-cubic': TWEEN.Easing.Cubic.In,
	  'ease-out-cubic': TWEEN.Easing.Cubic.Out,
	  'ease-in-out-cubic': TWEEN.Easing.Cubic.InOut,
	
	  'ease-quad': TWEEN.Easing.Quadratic.InOut,
	  'ease-in-quad': TWEEN.Easing.Quadratic.In,
	  'ease-out-quad': TWEEN.Easing.Quadratic.Out,
	  'ease-in-out-quad': TWEEN.Easing.Quadratic.InOut,
	
	  'ease-quart': TWEEN.Easing.Quartic.InOut,
	  'ease-in-quart': TWEEN.Easing.Quartic.In,
	  'ease-out-quart': TWEEN.Easing.Quartic.Out,
	  'ease-in-out-quart': TWEEN.Easing.Quartic.InOut,
	
	  'ease-quint': TWEEN.Easing.Quintic.InOut,
	  'ease-in-quint': TWEEN.Easing.Quintic.In,
	  'ease-out-quint': TWEEN.Easing.Quintic.Out,
	  'ease-in-out-quint': TWEEN.Easing.Quintic.InOut,
	
	  'ease-sine': TWEEN.Easing.Sinusoidal.InOut,
	  'ease-in-sine': TWEEN.Easing.Sinusoidal.In,
	  'ease-out-sine': TWEEN.Easing.Sinusoidal.Out,
	  'ease-in-out-sine': TWEEN.Easing.Sinusoidal.InOut,
	
	  'ease-expo': TWEEN.Easing.Exponential.InOut,
	  'ease-in-expo': TWEEN.Easing.Exponential.In,
	  'ease-out-expo': TWEEN.Easing.Exponential.Out,
	  'ease-in-out-expo': TWEEN.Easing.Exponential.InOut,
	
	  'ease-circ': TWEEN.Easing.Circular.InOut,
	  'ease-in-circ': TWEEN.Easing.Circular.In,
	  'ease-out-circ': TWEEN.Easing.Circular.Out,
	  'ease-in-out-circ': TWEEN.Easing.Circular.InOut,
	
	  'ease-elastic': TWEEN.Easing.Elastic.InOut,
	  'ease-in-elastic': TWEEN.Easing.Elastic.In,
	  'ease-out-elastic': TWEEN.Easing.Elastic.Out,
	  'ease-in-out-elastic': TWEEN.Easing.Elastic.InOut,
	
	  'ease-back': TWEEN.Easing.Back.InOut,
	  'ease-in-back': TWEEN.Easing.Back.In,
	  'ease-out-back': TWEEN.Easing.Back.Out,
	  'ease-in-out-back': TWEEN.Easing.Back.InOut,
	
	  'ease-bounce': TWEEN.Easing.Bounce.InOut,
	  'ease-in-bounce': TWEEN.Easing.Bounce.In,
	  'ease-out-bounce': TWEEN.Easing.Bounce.Out,
	  'ease-in-out-bounce': TWEEN.Easing.Bounce.InOut
	};
	
	var FILLS = {
	  backwards: 'backwards',
	  both: 'both',
	  forwards: 'forwards',
	  none: 'none'
	};
	
	var REPEATS = {
	  indefinite: 'indefinite'
	};
	
	var DEFAULTS = {
	  attribute: 'rotation',
	  begin: '0',
	  dur: 1000,
	  easing: 'ease',
	  direction: DIRECTIONS.normal,
	  fill: FILLS.forwards,
	  from: undefined,
	  repeat: 0,
	  to: undefined
	};
	
	module.exports.defaults = DEFAULTS;
	module.exports.directions = DIRECTIONS;
	module.exports.easingFunctions = EASING_FUNCTIONS;
	module.exports.fills = FILLS;
	module.exports.repeats = REPEATS;
	
	},{"tween.js":22}],49:[function(_dereq_,module,exports){
	var ANode = _dereq_('./a-node');
	var constants = _dereq_('../constants/animation');
	var coordinates = _dereq_('../utils/').coordinates;
	var parseProperty = _dereq_('./schema').parseProperty;
	var registerElement = _dereq_('./a-register-element').registerElement;
	var TWEEN = _dereq_('tween.js');
	var utils = _dereq_('../utils/');
	
	var DEFAULTS = constants.defaults;
	var DIRECTIONS = constants.directions;
	var EASING_FUNCTIONS = constants.easingFunctions;
	var FILLS = constants.fills;
	var REPEATS = constants.repeats;
	var isCoordinate = coordinates.isCoordinate;
	
	/**
	 * Animation element that applies Tween animation to parent element (entity).
	 * Takes after the Web Animations spec.
	 *
	 * @member {number} count - Decrementing counter for how many cycles of animations left to
	 *         run.
	 * @member {Element} el - Entity which the animation is modifying.
	 * @member initialValue - Value before animation started. Used to restore state.
	 * @member {bool} isRunning - Whether animation is currently running.
	 * @member {function} partialSetAttribute -
	 *   setAttribute function that is agnostic to whether we are setting an attribute value
	 *   or a component property value. The el and the attribute names are bundled with
	 *   the function.
	 * @member {object} tween - tween.js object.
	 */
	module.exports.AAnimation = registerElement('a-animation', {
	  prototype: Object.create(ANode.prototype, {
	    createdCallback: {
	      value: function () {
	        this.bindMethods();
	        this.isRunning = false;
	        this.partialSetAttribute = function () { /* no-op */ };
	        this.tween = null;
	      }
	    },
	
	    attachedCallback: {
	      value: function () {
	        var self = this;
	        var el = self.el = self.parentNode;
	
	        if (el.isNode) {
	          if (el.hasLoaded) {
	            init();
	          } else {
	            el.addEventListener('loaded', init.bind(self));
	          }
	        } else {
	          // To handle elements that are not yet `<a-entity>`s (e.g., templates).
	          el.addEventListener('nodeready', init.bind(self));
	        }
	
	        function init () {
	          self.applyMixin();
	          self.update();
	          self.load();
	        }
	      }
	    },
	
	    attributeChangedCallback: {
	      value: function (attr, oldVal, newVal) {
	        if (!this.hasLoaded || !this.isRunning) { return; }
	        this.stop();
	        this.applyMixin();
	        this.update();
	      }
	    },
	
	    detachedCallback: {
	      value: function () {
	        if (!this.isRunning) { return; }
	        this.stop();
	      }
	    },
	
	    /**
	     * Builds a Tween object to handle animations.
	     * Uses tween.js's from, to, delay, easing, repeat, onUpdate, and onComplete.
	     * Note: tween.js takes objects for its `from` and `to` values.
	     *
	     * @returns {object}
	     */
	    getTween: {
	      value: function () {
	        var self = this;
	        var data = self.data;
	        var el = self.el;
	        var animationValues;
	        var attribute = data.attribute;
	        var begin = parseInt(data.begin, 10);
	        var currentValue = el.getComputedAttribute(attribute);
	        var direction = self.getDirection(data.direction);
	        var easing = EASING_FUNCTIONS[data.easing];
	        var fill = data.fill;
	        var from;
	        var repeat = data.repeat === REPEATS.indefinite ? Infinity : 0;
	        var to;
	        var toTemp;
	        var yoyo = false;
	
	        animationValues = getAnimationValues(el, attribute, data.from || self.initialValue, data.to, currentValue);
	        from = animationValues.from;
	        to = animationValues.to;
	        self.partialSetAttribute = animationValues.partialSetAttribute;
	
	        if (self.count === undefined) {
	          self.count = repeat === Infinity ? 0 : parseInt(data.repeat, 10);
	        }
	
	        if (isNaN(begin)) { begin = 0; }
	
	        // Store initial state.
	        self.initialValue = self.initialValue || cloneValue(currentValue);
	
	        // Handle indefinite + forwards + alternate yoyo edge-case (#405).
	        if (repeat === Infinity && fill === FILLS.forwards &&
	            [DIRECTIONS.alternate,
	             DIRECTIONS.alternateReverse].indexOf(data.direction) !== -1) {
	          yoyo = true;
	        }
	
	        // If reversing, swap from and to.
	        if (direction === DIRECTIONS.reverse) {
	          toTemp = to;
	          to = cloneValue(from);
	          from = cloneValue(toTemp);
	        }
	
	        // If fill is backwards or both, start animation at the specified from.
	        if ([FILLS.backwards, FILLS.both].indexOf(fill) !== -1) {
	          self.partialSetAttribute(from);
	        }
	
	        // Create Tween.
	        return new TWEEN.Tween(cloneValue(from))
	          .to(to, data.dur)
	          .delay(begin)
	          .easing(easing)
	          .repeat(repeat)
	          .yoyo(yoyo)
	          .onUpdate(function () {
	            self.partialSetAttribute(this);
	          })
	          .onComplete(self.onCompleted.bind(self));
	      }
	    },
	
	    /**
	     * Animation parameters changed. Stop current animation, get a new one, and start it.
	     */
	    update: {
	      value: function () {
	        var data = this.data;
	        var begin = data.begin;
	        // Cancel previous event listeners
	        this.removeEventListeners(this.evt);
	        this.addEventListeners(begin);
	        // Store new event name.
	        this.evt = begin;
	        // If `begin` is a number, start the animation right away.
	        if (!isNaN(begin)) {
	          this.stop();
	          this.start();
	        }
	      },
	      writable: window.debug
	    },
	
	    /**
	     * Callback for when a cycle of an animation is complete. Handles when to completely
	     * finish the animation.
	     *
	     * If `repeat` is set to a value, this method is called after each repeat. Repeats are
	     * handled by ending the current animation and creating a new one with `count` updated.
	     * Note that this method is *not* called if repeat is set to `indefinite`.
	     */
	    onCompleted: {
	      value: function () {
	        var data = this.data;
	        this.isRunning = false;
	        if ([FILLS.backwards, FILLS.none].indexOf(data.fill) !== -1) {
	          this.partialSetAttribute(this.initialValue);
	        }
	        if (this.count === 0) {
	          this.count = undefined;
	          this.emit('animationend');
	          return;
	        }
	        this.isRunning = false;
	        this.count--;
	        this.start();
	      }
	    },
	
	    start: {
	      value: function () {
	        if (this.isRunning || !this.el.isPlaying) { return; }
	        this.tween = this.getTween();
	        this.isRunning = true;
	        this.tween.start();
	        this.emit('animationstart');
	      },
	      writable: true
	    },
	
	    stop: {
	      value: function () {
	        var tween = this.tween;
	        if (!tween) { return; }
	        tween.stop();
	        this.isRunning = false;
	        if ([FILLS.backwards, FILLS.none].indexOf(this.data.fill) !== -1) {
	          this.partialSetAttribute(this.initialValue);
	        }
	        this.emit('animationstop');
	      },
	      writable: true
	    },
	
	    /**
	     * Handle alternating directions. Given the current direction, calculate the next one,
	     * and store the current one.
	     *
	     * @param {string} direction
	     * @returns {string} Direction that the next individual cycle of the animation will go
	     *          towards.
	     */
	    getDirection: {
	      value: function (direction) {
	        if (direction === DIRECTIONS.alternate) {
	          this.prevDirection =
	            this.prevDirection === DIRECTIONS.normal ? DIRECTIONS.reverse : DIRECTIONS.normal;
	          return this.prevDirection;
	        }
	        if (direction === DIRECTIONS.alternateReverse) {
	          this.prevDirection =
	            this.prevDirection === DIRECTIONS.reverse ? DIRECTIONS.normal : DIRECTIONS.reverse;
	          return this.prevDirection;
	        }
	        return direction;
	      }
	    },
	
	    /**
	     * Preemptive binding to attach/detach event listeners (see `update`).
	     */
	    bindMethods: {
	      value: function () {
	        this.start = this.start.bind(this);
	        this.stop = this.stop.bind(this);
	        this.onStateAdded = this.onStateAdded.bind(this);
	        this.onStateRemoved = this.onStateRemoved.bind(this);
	      }
	    },
	
	    addEventListeners: {
	      value: function (evts) {
	        var el = this.el;
	        var self = this;
	        utils.splitString(evts).forEach(function (evt) {
	          el.addEventListener(evt, self.start);
	        });
	        // If "begin" is an event name, wait. If it is a delay or not defined, start.
	        if (!isNaN(evts)) { el.addEventListener('play', this.start); }
	        el.addEventListener('pause', this.stop);
	        el.addEventListener('stateadded', this.onStateAdded);
	        el.addEventListener('stateremoved', this.onStateRemoved);
	      }
	    },
	
	    removeEventListeners: {
	      value: function (evts) {
	        var el = this.el;
	        var start = this.start;
	        utils.splitString(evts).forEach(function (evt) {
	          el.removeEventListener(evt, start);
	        });
	        el.removeEventListener('stateadded', this.onStateAdded);
	        el.removeEventListener('stateremoved', this.onStateRemoved);
	      }
	    },
	
	    onStateAdded: {
	      value: function (evt) {
	        if (evt.detail.state === this.data.begin) { this.start(); }
	      },
	      writable: true
	    },
	
	    onStateRemoved: {
	      value: function (evt) {
	        if (evt.detail.state === this.data.begin) { this.stop(); }
	      },
	      writable: true
	    },
	
	    /**
	     * Applies animation data from a mixin element.
	     * Works the same as component mixins but reimplemented because animations
	     * aren't components.
	     */
	    applyMixin: {
	      value: function () {
	        var data = {};
	        var elData;
	        var mixinData;
	        var mixinEl;
	
	        // Get mixin data.
	        mixinEl = document.querySelector('#' + this.getAttribute('mixin'));
	        mixinData = mixinEl ? utils.getElData(mixinEl, DEFAULTS) : {};
	
	        elData = utils.getElData(this, DEFAULTS);
	        utils.extend(data, DEFAULTS, mixinData, elData);
	        this.data = data;
	      }
	    }
	  })
	});
	
	function cloneValue (val) {
	  return utils.extend({}, val);
	}
	
	/**
	 * Deduces different animation values based on whether we are:
	 *   - animating an inner attribute of a component.
	 *   - animating a coordinate component.
	 *   - animating a boolean.
	 *   - animating a number.
	 *
	 * @param {Element} el
	 * @param {string} attribute - Tells what to animate based on whether it is dot-separated.
	 * @param {string} dataFrom - Data `from` value.
	 * @param {string} dataTo - Data `to` value.
	 * @param currentValue
	 * @returns {object}
	 *   Object with keys [from, to, partialSetAttribute].
	 *     `from` and `to`
	 *        Objects where key is attribute being animated and value is value.
	 *     `partialSetAttribute`
	 *        Closured-function that tells tween how to update the component.
	 */
	function getAnimationValues (el, attribute, dataFrom, dataTo, currentValue) {
	  var attributeSplit = attribute.split('.');
	  var schema;
	  var component;
	  var componentPropName;
	  var componentName;
	  var from = {};
	  var partialSetAttribute;
	  var to = {};
	
	  if (attributeSplit.length === 2) {
	    getForComponentAttribute();
	  } else if (dataTo && isCoordinate(dataTo)) {
	    getForCoordinateComponent();
	  } else if (['true', 'false'].indexOf(dataTo) !== -1) {
	    getForBoolean();
	  } else {
	    getForNumber();
	  }
	  return {
	    from: from,
	    partialSetAttribute: partialSetAttribute,
	    to: to
	  };
	
	  /**
	   * Animating a component that has multiple attributes (e.g., geometry.width).
	   */
	  function getForComponentAttribute () {
	    componentName = attributeSplit[0];
	    componentPropName = attributeSplit[1];
	    component = el.components[componentName];
	    if (!component) {
	      el.setAttribute(componentName, '');
	      component = el.components[componentName];
	    }
	    schema = component.schema;
	    if (dataFrom === undefined) {  // dataFrom can be 0.
	      from[attribute] = el.getComputedAttribute(componentName)[componentPropName];
	    } else {
	      from[attribute] = dataFrom;
	    }
	    from[attribute] = parseProperty(from[attribute], schema[componentPropName]);
	    to[attribute] = parseProperty(dataTo, schema[componentPropName]);
	    partialSetAttribute = function (value) {
	      if (!(attribute in value)) { return; }
	      el.setAttribute(componentName, componentPropName, value[attribute]);
	    };
	  }
	
	  /**
	   * Animating a component that is an XYZ coordinate (e.g., position).
	   * Will be tweening {x, y, z} all at once.
	   */
	  function getForCoordinateComponent () {
	    from = dataFrom ? coordinates.parse(dataFrom) : currentValue;
	    to = coordinates.parse(dataTo);
	    partialSetAttribute = function (value) {
	      el.setAttribute(attribute, value);
	    };
	  }
	
	  /**
	   * Animation a boolean (e.g., visible).
	   * Have to convert from boolean to an integer (0 is false, > 0 is true) for tween.
	   */
	  function getForBoolean () {
	    if (dataFrom === undefined) {
	      from[attribute] = false;
	    } else {
	      from[attribute] = strToBool(dataFrom);
	    }
	    from[attribute] = boolToNum(from[attribute]);
	    to[attribute] = boolToNum(strToBool(dataTo));
	    partialSetAttribute = function (value) {
	      el.setAttribute(attribute, !!value[attribute]);
	    };
	  }
	
	  /**
	   * Animating a numbered attribute (e.g., opacity).
	   */
	  function getForNumber () {
	    if (dataFrom === undefined) {  // dataFrom can be 0.
	      from[attribute] = parseFloat(el.getAttribute(attribute));
	    } else {
	      from[attribute] = parseFloat(dataFrom);
	    }
	    to[attribute] = parseFloat(dataTo);
	    partialSetAttribute = function (value) {
	      el.setAttribute(attribute, value[attribute]);
	    };
	  }
	}
	module.exports.getAnimationValues = getAnimationValues;
	
	/**
	 * Converts string to bool.
	 *
	 * @param {string} str - `true` or `false`.
	 * @returns {bool}
	 */
	function strToBool (str) {
	  if (str === 'true') { return true; }
	  return false;
	}
	
	/**
	 * Converts boolean to number.
	 *
	 * @param {bool}
	 * @returns {number}
	 */
	function boolToNum (bool) {
	  return bool ? 1 : 0;
	}
	
	},{"../constants/animation":48,"../utils/":102,"./a-node":54,"./a-register-element":55,"./schema":62,"tween.js":22}],50:[function(_dereq_,module,exports){
	var ANode = _dereq_('./a-node');
	var debug = _dereq_('../utils/debug');
	var registerElement = _dereq_('./a-register-element').registerElement;
	var THREE = _dereq_('../lib/three');
	
	var xhrLoader = new THREE.XHRLoader();
	var warn = debug('core:a-assets:warn');
	
	/**
	 * Asset management system. Handles blocking on asset loading.
	 */
	module.exports = registerElement('a-assets', {
	  prototype: Object.create(ANode.prototype, {
	    createdCallback: {
	      value: function () {
	        this.isAssets = true;
	      }
	    },
	
	    attachedCallback: {
	      value: function () {
	        var self = this;
	        var loaded = [];
	        var audios = this.querySelectorAll('audio');
	        var imgs = this.querySelectorAll('img');
	        var timeout = parseInt(this.getAttribute('timeout'), 10) || 3000;
	        var videos = this.querySelectorAll('video');
	
	        if (this.parentNode.tagName !== 'A-SCENE') {
	          throw new Error('<a-assets> must be a child of a <a-scene>.');
	        }
	
	        // Wait for <img>s.
	        for (var i = 0; i < imgs.length; i++) {
	          loaded.push(new Promise(function (resolve, reject) {
	            var img = imgs[i];
	            img.onload = resolve;
	            img.onerror = reject;
	          }));
	        }
	
	        // Wait for <audio>s.
	        for (i = 0; i < audios.length; i++) {
	          loaded.push(mediaElementLoaded(audios[i]));
	        }
	
	        // Wait for <video>s.
	        for (i = 0; i < videos.length; i++) {
	          loaded.push(mediaElementLoaded(videos[i]));
	        }
	
	        // Trigger loaded for scene to start rendering.
	        Promise.all(loaded).then(this.load.bind(this));
	
	        setTimeout(function () {
	          if (self.hasLoaded) { return; }
	          warn('Asset loading timed out in ', timeout, 'ms');
	          self.emit('timeout');
	          self.load();
	        }, timeout);
	      }
	    },
	
	    load: {
	      value: function () {
	        ANode.prototype.load.call(this, null, function waitOnFilter (el) {
	          return el.isAssetItem && el.hasAttribute('src');
	        });
	      }
	    }
	  })
	});
	
	registerElement('a-asset-item', {
	  prototype: Object.create(ANode.prototype, {
	    createdCallback: {
	      value: function () {
	        this.data = null;
	        this.isAssetItem = true;
	      }
	    },
	
	    attachedCallback: {
	      value: function () {
	        var self = this;
	        var src = this.getAttribute('src');
	
	        xhrLoader.load(src, function (textResponse) {
	          self.data = textResponse;
	          ANode.prototype.load.call(self);
	        });
	      }
	    }
	  })
	});
	
	/**
	 * Create a Promise that resolves once the media element has finished buffering.
	 *
	 * @param {Element} el - HTMLMediaElement.
	 * @returns {Promise}
	 */
	function mediaElementLoaded (el) {
	  if (!el.hasAttribute('autoplay') && el.getAttribute('preload') !== 'auto') {
	    return;
	  }
	
	  // If media specifies autoplay or preload, wait until media is completely buffered.
	  return new Promise(function (resolve, reject) {
	    if (el.readyState === 4) { return resolve(); }  // Already loaded.
	    if (el.error) { return reject(); }  // Error.
	
	    el.addEventListener('loadeddata', checkProgress, false);
	    el.addEventListener('progress', checkProgress, false);
	    el.addEventListener('error', reject, false);
	
	    function checkProgress () {
	      // Add up the seconds buffered.
	      var secondsBuffered = 0;
	      for (var i = 0; i < el.buffered.length; i++) {
	        secondsBuffered += el.buffered.end(i) - el.buffered.start(i);
	      }
	
	      // Compare seconds buffered to media duration.
	      if (secondsBuffered >= el.duration) {
	        resolve();
	      }
	    }
	  });
	}
	
	},{"../lib/three":90,"../utils/debug":101,"./a-node":54,"./a-register-element":55}],51:[function(_dereq_,module,exports){
	/* global HTMLElement */
	var debug = _dereq_('../utils/debug');
	var registerElement = _dereq_('./a-register-element').registerElement;
	
	var warn = debug('core:cubemap:warn');
	
	/**
	 * Cubemap element that handles validation and exposes list of URLs.
	 * Does not listen to updates.
	 */
	module.exports = registerElement('a-cubemap', {
	  prototype: Object.create(HTMLElement.prototype, {
	    /**
	     * Calculates this.srcs.
	     */
	    attachedCallback: {
	      value: function () {
	        this.srcs = this.validate();
	      },
	      writable: window.debug
	    },
	
	    /**
	     * Checks for exactly six elements with [src].
	     * Does not check explicitly for <img>s in case user does not want
	     * prefetching.
	     *
	     * @returns {Array|null} - six URLs if valid, else null.
	     */
	    validate: {
	      value: function () {
	        var elements = this.querySelectorAll('[src]');
	        var i;
	        var srcs = [];
	        if (elements.length === 6) {
	          for (i = 0; i < elements.length; i++) {
	            srcs.push(elements[i].getAttribute('src'));
	          }
	          return srcs;
	        }
	        // Else if there are not six elements, throw a warning.
	        warn(
	          '<a-cubemap> did not contain exactly six elements each with a ' +
	          '`src` attribute.');
	      },
	      writable: window.debug
	    }
	  })
	});
	
	},{"../utils/debug":101,"./a-register-element":55}],52:[function(_dereq_,module,exports){
	/* global HTMLElement */
	var ANode = _dereq_('./a-node');
	var components = _dereq_('./component').components;
	var re = _dereq_('./a-register-element');
	var THREE = _dereq_('../lib/three');
	var utils = _dereq_('../utils/');
	
	var AEntity;
	var isNode = re.isNode;
	var debug = utils.debug('core:a-entity:debug');
	var registerElement = re.registerElement;
	var styleParser = utils.styleParser;
	
	/**
	 * Entity is a container object that components are plugged into to comprise everything in
	 * the scene. In A-Frame, they inherently have position, rotation, and scale.
	 *
	 * To be able to take components, the scene element inherits from the entity definition.
	 *
	 * @member {object} components - entity's currently initialized components.
	 * @member {object} object3D - three.js object.
	 * @member {array} states
	 * @member {boolean} isPlaying - false if dynamic behavior of the entity is paused.
	 */
	var proto = Object.create(ANode.prototype, {
	  defaultComponents: {
	    value: {
	      position: '',
	      rotation: '',
	      scale: '',
	      visible: ''
	    }
	  },
	
	  createdCallback: {
	    value: function () {
	      this.components = {};
	      this.isEntity = true;
	      this.isPlaying = false;
	      this.object3D = new THREE.Group();
	      this.object3D.el = this;
	      this.object3DMap = {};
	      this.states = [];
	    }
	  },
	
	  /**
	   * Handle changes coming from the browser DOM inspector.
	   */
	  attributeChangedCallback: {
	    value: function (attr, oldVal, newVal) {
	      this.setEntityAttribute(attr, oldVal, newVal);
	    }
	  },
	
	  attachedCallback: {
	    value: function () {
	      this.addToParent();
	      if (!this.isScene) {
	        this.load();
	        if (!this.parentNode.paused) { this.play(); }
	      }
	    }
	  },
	
	  /**
	   * Tell parent to remove this element's object3D from its object3D.
	   * Do not call on scene element because that will cause a call to document.body.remove().
	   */
	  detachedCallback: {
	    value: function () {
	      if (!this.parentEl || this.isScene) { return; }
	      // Remove components.
	      Object.keys(this.components).forEach(this.removeComponent.bind(this));
	      this.parentEl.remove(this);
	    }
	  },
	
	  applyMixin: {
	    value: function (attr) {
	      var attrValue = this.getAttribute(attr);
	      if (!attr) {
	        this.updateComponents();
	        return;
	      }
	      this.updateComponent(attr, attrValue);
	    }
	  },
	
	  mapStateMixins: {
	    value: function (state, op) {
	      var mixins = this.getAttribute('mixin');
	      var mixinIds;
	      if (!mixins) { return; }
	      mixinIds = mixins.split(' ');
	      mixinIds.forEach(function (id) {
	        var mixinId = id + '-' + state;
	        op(mixinId);
	      });
	      this.updateComponents();
	    }
	  },
	
	  updateStateMixins: {
	    value: function (newMixins, oldMixins) {
	      var self = this;
	      oldMixins = oldMixins || '';
	      var newMixinsIds = newMixins.split(' ');
	      var oldMixinsIds = oldMixins ? oldMixins.split(' ') : [];
	      // The list of mixins that might have been removed on update
	      var diff = oldMixinsIds.filter(function (i) { return newMixinsIds.indexOf(i) < 0; });
	      // Remove the mixins that are gone on update
	      diff.forEach(function (mixinId) {
	        var forEach = Array.prototype.forEach;
	        // State Mixins
	        var stateMixinsEls = document.querySelectorAll('[id^=' + mixinId + '-]');
	        var stateMixinIds = [];
	        forEach.call(stateMixinsEls, function (el) { stateMixinIds.push(el.id); });
	        stateMixinIds.forEach(self.unregisterMixin.bind(self));
	      });
	      this.states.forEach(function (state) {
	        newMixinsIds.forEach(function (id) {
	          var mixinId = id + '-' + state;
	          self.registerMixin(mixinId);
	        });
	      });
	    }
	  },
	
	  getObject3D: {
	    value: function (type) {
	      return this.object3DMap[type];
	    }
	  },
	
	  setObject3D: {
	    value: function (type, obj) {
	      var oldObj = this.object3DMap[type];
	      if (oldObj) { this.object3D.remove(oldObj); }
	      if (obj instanceof THREE.Object3D) {
	        obj.el = this;
	        this.object3D.add(obj);
	      }
	      this.object3DMap[type] = obj;
	    }
	  },
	
	  removeObject3D: {
	    value: function (type) {
	      this.setObject3D(type, null);
	    }
	  },
	
	  /**
	   * Gets or creates an object3D of a given type.
	
	   * @param {string} type - Type of the object3D.
	   * @param {string} Constructor - Constructor to use if need to create the object3D.
	   * @type {Object}
	   */
	  getOrCreateObject3D: {
	    value: function (type, Constructor) {
	      var object3D = this.getObject3D(type);
	      if (!object3D && Constructor) {
	        object3D = new Constructor();
	        this.setObject3D(type, object3D);
	      }
	      return object3D;
	    }
	  },
	
	  add: {
	    value: function (el) {
	      if (!el.object3D) {
	        throw new Error("Trying to add an element that doesn't have an `object3D`");
	      }
	      this.emit('child-attached', { el: el });
	      this.object3D.add(el.object3D);
	    }
	  },
	
	  addToParent: {
	    value: function () {
	      var self = this;
	      var parent = this.parentEl = this.parentNode;
	      var attachedToParent = this.attachedToParent;
	      if (!parent || attachedToParent) { return; }
	      if (isNode(parent)) {
	        attach();
	        return;
	      }
	      parent.addEventListener('nodeready', attach);
	      function attach () {
	        // To prevent an object to attach itself multiple times to the parent.
	        self.attachedToParent = true;
	        if (parent.add) {
	          parent.add(self);
	        }
	      }
	    }
	  },
	
	  load: {
	    value: function () {
	      if (this.hasLoaded) { return; }
	
	      // Attach to parent object3D.
	      this.addToParent();
	
	      if (this.isScene) {
	        ANode.prototype.load.call(this, this.updateComponents.bind(this));
	      } else {
	        ANode.prototype.load.call(this, this.updateComponents.bind(this),
	                                  function (el) { return el.isEntity; });
	      }
	    },
	    writable: window.debug
	  },
	
	  remove: {
	    value: function (el) {
	      this.object3D.remove(el.object3D);
	    }
	  },
	
	  /**
	   * @returns {array} Direct children that are entities.
	   */
	  getChildEntities: {
	    value: function () {
	      var children = this.children;
	      var childEntities = [];
	
	      for (var i = 0; i < children.length; i++) {
	        var child = children[i];
	        if (child instanceof AEntity) {
	          childEntities.push(child);
	        }
	      }
	
	      return childEntities;
	    }
	  },
	
	  /**
	   * Initialize component.
	   */
	  initComponent: {
	    value: function (name, isDependency) {
	      var component;
	      var isComponentDefined = checkComponentDefined(this, name);
	
	      // Check if component is registered and whether component should be iniitalized.
	      if (!components[name] || (!isComponentDefined && !isDependency)) {
	        return;
	      }
	
	      // Initialize dependencies.
	      this.initComponentDependencies(name);
	
	      if (isDependency && !isComponentDefined) {
	        // Add component if it is a dependency and not yet defined.
	        this.setAttribute(name, '');
	      } else {
	        if (this.isScene && !this.hasAttribute(name) && name in this.defaultComponents) {
	          // For scene default components, expose them in the DOM.
	          HTMLElement.prototype.setAttribute.call(this, name, this.defaultComponents[name]);
	        }
	
	        // Check if component already initialized.
	        if (name in this.components) { return; }
	
	        component = this.components[name] = new components[name].Component(this);
	        if (this.isPlaying) { playComponent(component, this.sceneEl); }
	      }
	      debug('Component initialized: %s', name);
	    },
	    writable: window.debug
	  },
	
	  initComponentDependencies: {
	    value: function (name) {
	      var self = this;
	      var component = components[name];
	      var dependencies;
	      if (!component) { return; }
	      dependencies = components[name].dependencies;
	      if (!dependencies) { return; }
	      dependencies.forEach(function (component) {
	        self.initComponent(component, true);
	      });
	    }
	  },
	
	  removeComponent: {
	    value: function (name) {
	      var component = this.components[name];
	      pauseComponent(component, this.sceneEl);
	      component.remove();
	      delete this.components[name];
	    }
	  },
	
	  updateComponents: {
	    value: function () {
	      var self = this;
	      var allComponents = Object.keys(components);
	      allComponents.forEach(updateComponent);
	      function updateComponent (name) {
	        var elValue = self.getAttribute(name);
	        self.updateComponent(name, elValue);
	      }
	    }
	  },
	
	  /**
	   * Initialize, update, or remove a single component.
	   *
	   * When initializing, we set the component on `this.components`.
	   *
	   * @param {string} name - Component name.
	   * @param {object} newData - The new properties assigned to the component
	   */
	  updateComponent: {
	    value: function (name, newData) {
	      var component = this.components[name];
	      var isDefault = name in this.defaultComponents;
	      var isMixedIn = isComponentMixedIn(name, this.mixinEls);
	      if (component) {
	        // Attribute was removed, remove component if:
	        // 1. If component not defined in the defaults/mixins/attribute.
	        // 2. If new data is null, then not a default component and component is not defined
	        //    via mixins
	        if (!checkComponentDefined(this, name) ||
	            newData === null && !isDefault && !isMixedIn) {
	          this.removeComponent(name);
	          return;
	        }
	        // Component already initialized. Update component.
	        component.updateProperties(newData);
	        return;
	      }
	      // Component not yet initialized. Initialize component.
	      this.initComponent(name);
	    }
	  },
	
	  /**
	   * If `attr` is a component name, removeAttribute detaches the component from the
	   * entity.
	   *
	   * @param {string} attr - Attribute name, which could also be a component name.
	   */
	  removeAttribute: {
	    value: function (attr) {
	      var component = components[attr];
	      if (component) {
	        this.setEntityAttribute(attr, undefined, null);
	      }
	      HTMLElement.prototype.removeAttribute.call(this, attr);
	    }
	  },
	
	  /**
	   * Start dynamic behavior associated with entity such as dynamic components and animations.
	   * Tell all children entities to also play.
	   */
	  play: {
	    value: function () {
	      var components = this.components;
	      var componentKeys = Object.keys(components);
	      var sceneEl = this.sceneEl;
	
	      // Already playing.
	      if (this.isPlaying) { return; }
	      this.isPlaying = true;
	
	      // Wake up all components.
	      componentKeys.forEach(function _playComponent (key) {
	        playComponent(components[key], sceneEl);
	      });
	
	      // Tell all child entities to play.
	      this.getChildEntities().forEach(function play (obj) {
	        obj.play();
	      });
	
	      this.emit('play');
	    },
	    writable: true
	  },
	
	  /**
	   * Pause dynamic behavior associated with entity such as dynamic components and animations.
	   * Tell all children entities to also pause.
	   */
	  pause: {
	    value: function () {
	      var components = this.components;
	      var componentKeys = Object.keys(components);
	      var sceneEl = this.sceneEl;
	
	      if (!this.isPlaying) { return; }
	      this.isPlaying = false;
	
	      // Sleep all components.
	      componentKeys.forEach(function _pauseComponent (key) {
	        pauseComponent(components[key], sceneEl);
	      });
	
	      // Tell all child entities to pause.
	      this.getChildEntities().forEach(function pause (obj) {
	        obj.pause();
	      });
	
	      this.emit('pause');
	    },
	    writable: true
	  },
	
	  /**
	   * Deals with updates on entity-specific attributes (i.e., components and mixins).
	   *
	   * @param {string} attr
	   * @param {string} oldVal
	   * @param {string|object} newVal
	   */
	  setEntityAttribute: {
	    value: function (attr, oldVal, newVal) {
	      var component = components[attr];
	      oldVal = oldVal || this.getAttribute(attr);
	      // When creating entities programatically and setting attributes, it is not part
	      // of the scene until it is inserted into the DOM. This does not apply to scenes as
	      // scenes depend on its child entities to load.
	      if (!this.hasLoaded && !this.isScene) { return; }
	      if (attr === 'mixin') {
	        this.updateStateMixins(newVal, oldVal);
	        this.updateComponents();
	        return;
	      }
	      if (component) { this.updateComponent(attr, newVal); }
	    }
	  },
	
	  /**
	   * If attribute is a component, setAttribute will apply the value to the
	   * existing component data, not replace it. Examples:
	   *
	   * Examples:
	   *
	   * setAttribute('id', 'my-element');
	   * setAttribute('material', { color: 'crimson' });
	   * setAttribute('material', 'color', 'crimson');
	   *
	   * @param {string} attr - Attribute name. setAttribute will initialize or update
	   *        a component if the name corresponds to a registered component.
	   * @param {string|object} value - If a string, setAttribute will update the attribute or.
	   *        component. If an object, the value will be mixed into the component.
	   * @param {string} componentPropValue - If defined, `value` will act as the property
	   *        name and setAttribute will only set a single component property.
	   */
	  setAttribute: {
	    value: function (attr, value, componentPropValue) {
	      var self = this;
	      var component = this.components[attr] || components[attr];
	      var partialComponentData;
	      value = value === undefined ? '' : value;
	      var componentObj = value;  // Deserialized value to send to the component.
	      var componentStr = value;  // Serialized value to send to the DOM.
	      var oldValue;
	
	      if (component) {
	        if (typeof value === 'string' && componentPropValue !== undefined) {
	          // Update currently-defined component data with the new property value.
	          // Use native setAttribute in order not to double-parse properties.
	          partialComponentData = styleParser.parse(
	            HTMLElement.prototype.getAttribute.call(this, attr)) || {};
	          partialComponentData[value] = componentPropValue;
	          componentObj = partialComponentData;
	        }
	        componentStr = component.stringify(componentObj);
	      }
	      oldValue = this.getAttribute(attr);
	      ANode.prototype.setAttribute.call(self, attr, componentStr);
	      self.setEntityAttribute(attr, oldValue, componentObj);
	    },
	    writable: window.debug
	  },
	
	  /**
	   * If `attr` is a component, returns JUST the component data specified in the HTML
	   * by parsing the style-like string into an object. Like a partial version of
	   * `getComputedAttribute` as returned component data does not include applied mixins or
	   * defaults.
	   *
	   * If `attr` is not a component, fall back to HTML getAttribute.
	   *
	   * @param {string} attr
	   * @returns {object|string} Object if component, else string.
	   */
	  getAttribute: {
	    value: function (attr) {
	      var component = this.components[attr] || components[attr];
	      var value = HTMLElement.prototype.getAttribute.call(this, attr);
	      if (!component || typeof value !== 'string') { return value; }
	      return component.parse(value, true);
	    },
	    writable: window.debug
	  },
	
	  /**
	   * If `attr` is a component, returns ALL component data including applied mixins and
	   * defaults.
	   *
	   * If `attr` is not a component, fall back to HTML getAttribute.
	   *
	   * @param {string} attr
	   * @returns {object|string} Object if component, else string.
	   */
	  getComputedAttribute: {
	    value: function (attr) {
	      var component = this.components[attr];
	      if (component) { return component.getData(); }
	      return HTMLElement.prototype.getAttribute.call(this, attr);
	    }
	  },
	
	  addState: {
	    value: function (state) {
	      if (this.is(state)) { return; }
	      this.states.push(state);
	      this.mapStateMixins(state, this.registerMixin.bind(this));
	      this.emit('stateadded', {state: state});
	    }
	  },
	
	  removeState: {
	    value: function (state) {
	      var stateIndex = this.states.indexOf(state);
	      if (stateIndex === -1) { return; }
	      this.states.splice(stateIndex, 1);
	      this.mapStateMixins(state, this.unregisterMixin.bind(this));
	      this.emit('stateremoved', {state: state});
	    }
	  },
	
	  /**
	   * Checks if the element is in a given state. e.g. el.is('alive');
	   * @type {string} state - Name of the state we want to check
	   */
	  is: {
	    value: function (state) {
	      return this.states.indexOf(state) !== -1;
	    }
	  }
	});
	
	/**
	 * Check if a component is *defined* for an entity, including defaults and mixins.
	 * Does not check whether the component has been *initialized* for an entity.
	 *
	 * @param {string} el - Entity.
	 * @param {string} name - Component name.
	 * @returns {boolean}
	 */
	function checkComponentDefined (el, name) {
	  // Check if default components contain the component.
	  if (el.defaultComponents[name] !== undefined) { return true; }
	
	  // Check if element contains the component.
	  if (el.hasAttribute(name)) { return true; }
	
	  return isComponentMixedIn(name, el.mixinEls);
	}
	
	/**
	 * Check if any mixins contains a component.
	 *
	 * @param {string} name - Component name.
	 * @param {array} mixinEls - Array of <a-mixin>s.
	 */
	function isComponentMixedIn (name, mixinEls) {
	  var i;
	  var inMixin = false;
	
	  for (i = 0; i < mixinEls.length; ++i) {
	    inMixin = mixinEls[i].hasAttribute(name);
	    if (inMixin) { break; }
	  }
	  return inMixin;
	}
	
	/**
	 * Pause component by removing tick behavior and calling pause handler.
	 *
	 * @param component {object} - Component to pause.
	 * @param sceneEl {Element} - Scene, needed to remove the tick behavior.
	 */
	function pauseComponent (component, sceneEl) {
	  component.pause();
	  // Remove tick behavior.
	  if (!component.tick) { return; }
	  sceneEl.removeBehavior(component);
	}
	
	/**
	 * Play component by adding tick behavior and calling play handler.
	 *
	 * @param component {object} - Component to play.
	 * @param sceneEl {Element} - Scene, needed to add the tick behavior.
	 */
	function playComponent (component, sceneEl) {
	  component.play();
	  // Add tick behavior.
	  if (!component.tick) { return; }
	  sceneEl.addBehavior(component);
	}
	
	AEntity = registerElement('a-entity', {
	  prototype: proto
	});
	module.exports = AEntity;
	
	},{"../lib/three":90,"../utils/":102,"./a-node":54,"./a-register-element":55,"./component":56}],53:[function(_dereq_,module,exports){
	/* global HTMLElement */
	var AComponents = _dereq_('./component').components;
	var ANode = _dereq_('./a-node');
	var registerElement = _dereq_('./a-register-element').registerElement;
	
	module.exports = registerElement('a-mixin', {
	  prototype: Object.create(
	    ANode.prototype,
	    {
	      attachedCallback: {
	        value: function () {
	          this.load();
	        },
	        writable: window.debug
	      },
	
	      setAttribute: {
	        value: function (attr, value) {
	          var component = AComponents[attr];
	          if (component && typeof value === 'object') {
	            value = component.stringify(value);
	          }
	          HTMLElement.prototype.setAttribute.call(this, attr, value);
	        },
	        writable: window.debug
	      },
	
	      getAttribute: {
	        value: function (attr) {
	          var component = AComponents[attr];
	          var value = HTMLElement.prototype.getAttribute.call(this, attr);
	          if (!component || typeof value !== 'string') { return value; }
	          return component.parse(value);
	        },
	        writable: window.debug
	      }
	    }
	  )
	});
	
	},{"./a-node":54,"./a-register-element":55,"./component":56}],54:[function(_dereq_,module,exports){
	/* global HTMLElement, MutationObserver */
	var registerElement = _dereq_('./a-register-element').registerElement;
	var utils = _dereq_('../utils/');
	
	/**
	 * Base class for A-Frame that manages loading of objects.
	 *
	 * Nodes can be modified using mixins.
	 * Nodes emit a `loaded` event when they and their children have initialized.
	 */
	module.exports = registerElement('a-node', {
	  prototype: Object.create(HTMLElement.prototype, {
	    createdCallback: {
	      value: function () {
	        this.hasLoaded = false;
	        this.isNode = true;
	        this.mixinEls = [];
	        this.mixinObservers = {};
	      }
	    },
	
	    attachedCallback: {
	      value: function () {
	        var mixins = this.getAttribute('mixin');
	        this.sceneEl = this.tagName === 'A-SCENE' ? this : this.closest('a-scene');
	        this.emit('nodeready', {}, false);
	        if (mixins) { this.updateMixins(mixins); }
	      }
	    },
	
	    attributeChangedCallback: {
	      value: function (attr, oldVal, newVal) {
	        if (attr === 'mixin') { this.updateMixins(newVal, oldVal); }
	      }
	    },
	
	    /**
	     * Returns first element matching a selector by traversing up the tree starting
	     * from and including receiver element.
	     *
	     * @param {string} selector - Selector of element to find.
	     */
	    closest: {
	      value: function closest (selector) {
	        var matches = this.matches || this.mozMatchesSelector ||
	          this.msMatchesSelector || this.oMatchesSelector || this.webkitMatchesSelector;
	        var element = this;
	        while (element) {
	          if (matches.call(element, selector)) { break; }
	          element = element.parentElement;
	        }
	        return element;
	      }
	    },
	
	    detachedCallback: {
	      value: function () { /* no-op */ }
	    },
	
	    /**
	     * Wait for children to load, if any.
	     * Then emit `loaded` event and set `hasLoaded`.
	     */
	    load: {
	      value: function (cb, childFilter) {
	        var children;
	        var childrenLoaded;
	        var self = this;
	
	        if (this.hasLoaded) { return; }
	
	        // Default to waiting for all nodes.
	        childFilter = childFilter || function (el) { return el.isNode; };
	
	        // Wait for children to load (if any), then load.
	        children = this.getChildren();
	        childrenLoaded = children.filter(childFilter).map(function (child) {
	          return new Promise(function waitForLoaded (resolve) {
	            if (child.hasLoaded) { return resolve(); }
	            child.addEventListener('loaded', resolve);
	          });
	        });
	
	        Promise.all(childrenLoaded).then(function emitLoaded () {
	          if (cb) { cb(); }
	          self.hasLoaded = true;
	          self.emit('loaded', {}, false);
	        });
	      },
	      writable: true
	    },
	
	    getChildren: {
	      value: function () {
	        var children = [];
	        for (var i = 0; i < this.children.length; i++) {
	          children.push(this.children[i]);
	        }
	        return children;
	      }
	    },
	
	    updateMixins: {
	      value: function (newMixins, oldMixins) {
	        var newMixinsIds = newMixins.split(' ');
	        var oldMixinsIds = oldMixins ? oldMixins.split(' ') : [];
	        // To determine what listeners will be removed
	        var diff = oldMixinsIds.filter(function (i) { return newMixinsIds.indexOf(i) < 0; });
	        this.mixinEls = [];
	        diff.forEach(this.unregisterMixin.bind(this));
	        newMixinsIds.forEach(this.registerMixin.bind(this));
	      }
	    },
	
	    addMixin: {
	      value: function (mixinId) {
	        var mixins = this.getAttribute('mixin');
	        var mixinIds = mixins.split(' ');
	        var i;
	        for (i = 0; i < mixinIds.length; ++i) {
	          if (mixinIds[i] === mixinId) { return; }
	        }
	        mixinIds.push(mixinId);
	        this.setAttribute('mixin', mixinIds.join(' '));
	      }
	    },
	
	    removeMixin: {
	      value: function (mixinId) {
	        var mixins = this.getAttribute('mixin');
	        var mixinIds = mixins.split(' ');
	        var i;
	        for (i = 0; i < mixinIds.length; ++i) {
	          if (mixinIds[i] === mixinId) {
	            mixinIds.splice(i, 1);
	            this.setAttribute('mixin', mixinIds.join(' '));
	            return;
	          }
	        }
	      }
	    },
	
	    registerMixin: {
	      value: function (mixinId) {
	        if (!this.sceneEl) { return; }
	        var mixinEl = this.sceneEl.querySelector('a-mixin#' + mixinId);
	        if (!mixinEl) { return; }
	        this.attachMixinListener(mixinEl);
	        this.mixinEls.push(mixinEl);
	      }
	    },
	
	    setAttribute: {
	      value: function (attr, newValue) {
	        if (attr === 'mixin') { this.updateMixins(newValue); }
	        HTMLElement.prototype.setAttribute.call(this, attr, newValue);
	      }
	    },
	
	    unregisterMixin: {
	      value: function (mixinId) {
	        var mixinEls = this.mixinEls;
	        var mixinEl;
	        var i;
	        for (i = 0; i < mixinEls.length; ++i) {
	          mixinEl = mixinEls[i];
	          if (mixinId === mixinEl.id) {
	            mixinEls.splice(i, 1);
	            break;
	          }
	        }
	        this.removeMixinListener(mixinId);
	      }
	    },
	
	    removeMixinListener: {
	      value: function (mixinId) {
	        var observer = this.mixinObservers[mixinId];
	        if (!observer) { return; }
	        observer.disconnect();
	        this.mixinObservers[mixinId] = null;
	      }
	    },
	
	    attachMixinListener: {
	      value: function (mixinEl) {
	        var self = this;
	        var mixinId = mixinEl.id;
	        var currentObserver = this.mixinObservers[mixinId];
	        if (!mixinEl) { return; }
	        if (currentObserver) { return; }
	        var observer = new MutationObserver(function (mutations) {
	          var attr = mutations[0].attributeName;
	          self.applyMixin(attr);
	        });
	        var config = { attributes: true };
	        observer.observe(mixinEl, config);
	        this.mixinObservers[mixinId] = observer;
	      }
	    },
	
	    applyMixin: {
	      value: function () { /* no-op */ }
	    },
	
	    /**
	     * Emits a DOM event.
	     *
	     * @param {String} name
	     *   Name of event (use a space-delimited string for multiple events).
	     * @param {Object=} [detail={}]
	     *   Custom data to pass as `detail` to the event.
	     * @param {Boolean=} [bubbles=true]
	     *   Whether the event should bubble.
	     */
	    emit: {
	      value: function (name, detail, bubbles) {
	        var self = this;
	        detail = detail || {};
	        if (bubbles === undefined) { bubbles = true; }
	        var data = { bubbles: !!bubbles, detail: detail };
	        return name.split(' ').map(function (eventName) {
	          return utils.fireEvent(self, eventName, data);
	        });
	      }
	    },
	
	    /**
	     * Returns a closure that emits a DOM event.
	     *
	     * @param {String} name
	     *   Name of event (use a space-delimited string for multiple events).
	     * @param {Object} detail
	     *   Custom data (optional) to pass as `detail` if the event is to
	     *   be a `CustomEvent`.
	     * @param {Boolean} bubbles
	     *   Whether the event should be bubble.
	     */
	    emitter: {
	      value: function (name, detail, bubbles) {
	        var self = this;
	        return function () {
	          self.emit(name, detail, bubbles);
	        };
	      }
	    }
	  })
	});
	
	},{"../utils/":102,"./a-register-element":55}],55:[function(_dereq_,module,exports){
	// Polyfill `document.registerElement`.
	_dereq_('document-register-element');
	
	/*
	 ------------------------------------------------------------
	 ------------- WARNING WARNING WARNING WARNING --------------
	 ------------------------------------------------------------
	
	 This module wraps registerElement to deal with
	 components that inherit from `ANode` and `AEntity`.
	 It's a pass through in any other case.
	
	 It wraps some of the prototype methods
	 of the created element to make sure that the corresponding
	 functions in the base classes (`AEntity` and `ANode`) are also
	 invoked. The method in the base class is always called before the
	 one in the derived object.
	
	*/
	var registerElement = document.registerElement;
	
	var knownTags = module.exports.knownTags = {};
	
	var addTagName = function (tagName) {
	  knownTags[tagName.toLowerCase()] = true;
	};
	
	/**
	 * Returns whether the element type is one of our known registered ones
	 *
	 * @param   {string} node The name of the tag to register
	 * @returns {boolean} Whether the tag name matches that of our registered
	 *                    custom elements
	 */
	module.exports.isNode = function (node) {
	  return node.tagName.toLowerCase() in knownTags || node.isNode;
	};
	
	/**
	 * @param   {string} tagName The name of the tag to register
	 * @param   {object} obj The prototype of the new element
	 * @returns {object} The prototype of the new element
	 */
	module.exports.registerElement = document.registerElement = function (tagName, obj) {
	  var proto = Object.getPrototypeOf(obj.prototype);
	  var newObj = obj;
	  var isANode = ANode && proto === ANode.prototype;
	  var isAEntity = AEntity && proto === AEntity.prototype;
	
	  if (isANode || isAEntity) { addTagName(tagName); }
	
	  // Does the element inherit from `ANode`?
	  if (isANode) {
	    newObj = wrapANodeMethods(obj.prototype);
	    newObj = {prototype: Object.create(proto, newObj)};
	  }
	
	  // Does the element inherit from `AEntity`?
	  if (isAEntity) {
	    newObj = wrapAEntityMethods(obj.prototype);
	    newObj = {prototype: Object.create(proto, newObj)};
	  }
	
	  return registerElement.call(document, tagName, newObj);
	};
	
	/**
	 * This wraps some of the obj methods to call those on `ANode` base clase.
	 * @param  {object} obj The objects that contains the methods that will be wrapped.
	 * @return {object} An object with the same properties as the input parameter but
	 * with some of methods wrapped.
	 */
	function wrapANodeMethods (obj) {
	  var newObj = {};
	  var ANodeMethods = [
	    'attachedCallback',
	    'attributeChangedCallback',
	    'createdCallback'
	  ];
	  wrapMethods(newObj, ANodeMethods, obj, ANode.prototype);
	  copyProperties(obj, newObj);
	  return newObj;
	}
	
	/**
	 * This wraps some of the obj methods to call those on `AEntity` base class.
	 * @param  {object} obj The objects that contains the methods that will be wrapped.
	 * @return {object} An object with the same properties as the input parameter but
	 * with some of methods wrapped.
	 */
	function wrapAEntityMethods (obj) {
	  var newObj = {};
	  var ANodeMethods = [
	    'attachedCallback',
	    'attributeChangedCallback',
	    'createdCallback'
	  ];
	  var AEntityMethods = [
	    'attributeChangedCallback',
	    'attachedCallback',
	    'createdCallback',
	    'detachedCallback'
	  ];
	  wrapMethods(newObj, ANodeMethods, obj, ANode.prototype);
	  wrapMethods(newObj, AEntityMethods, obj, AEntity.prototype);
	  // Copies the remaining properties into the new object
	  copyProperties(obj, newObj);
	  return newObj;
	}
	
	/**
	 * Wraps a list a methods to ensure that those in the base class are called through the derived one.
	 * @param  {object} targetObj Object that will contain the wrapped methods
	 * @param  {array} methodList List of methods from the derivedObj that will be wrapped
	 * @param  {object} derivedObject Object that inherits from the baseObj
	 * @param  {object} baseObj Object that derivedObj inherits from
	 * @return {undefined}
	 */
	function wrapMethods (targetObj, methodList, derivedObj, baseObj) {
	  methodList.forEach(function (methodName) {
	    wrapMethod(targetObj, methodName, derivedObj, baseObj);
	  });
	}
	
	/**
	 * Wraps one method to ensure that the one in the base class is called before the one
	 * in the derived one
	 * @param  {object} obj Object that will contain the wrapped method
	 * @param  {string} methodName The name of the method that will be wrapped
	 * @param  {object} derivedObject Object that inherits from the baseObj
	 * @param  {object} baseObj Object that derivedObj inherits from
	 * @return {undefined}
	 */
	function wrapMethod (obj, methodName, derivedObj, baseObj) {
	  var derivedMethod = derivedObj[methodName];
	  var baseMethod = baseObj[methodName];
	  if (!derivedMethod || !baseMethod) { return; }
	  // The derived class doesn't override the one in the base one
	  if (derivedMethod === baseMethod) { return; }
	  // Wrapper
	  // The base method is called before the one in the derived class
	  var wrapperMethod = function () {
	    baseMethod.apply(this, arguments);
	    return derivedMethod.apply(this, arguments);
	  };
	  obj[methodName] = {value: wrapperMethod, writable: window.debug};
	}
	
	/**
	 * It copies the properties from source to destination object
	 * if they don't exist already
	 * @param  {object} source The object where properties are copied from
	 * @param  {type} destination The object where properties are copied to
	 * @return {undefined}
	 */
	function copyProperties (source, destination) {
	  var props = Object.getOwnPropertyNames(source);
	  props.forEach(function (prop) {
	    var desc;
	    if (!destination[prop]) {
	      desc = Object.getOwnPropertyDescriptor(source, prop);
	      destination[prop] = {value: source[prop], writable: desc.writable};
	    }
	  });
	}
	
	var ANode = _dereq_('./a-node');
	var AEntity = _dereq_('./a-entity');
	
	},{"./a-entity":52,"./a-node":54,"document-register-element":8}],56:[function(_dereq_,module,exports){
	/* global HTMLElement */
	var schema = _dereq_('./schema');
	var systems = _dereq_('./system');
	var utils = _dereq_('../utils/');
	
	var components = module.exports.components = {}; // Keep track of registered components.
	var parseProperties = schema.parseProperties;
	var parseProperty = schema.parseProperty;
	var processSchema = schema.process;
	var isSingleProp = schema.isSingleProperty;
	var stringifyProperties = schema.stringifyProperties;
	var stringifyProperty = schema.stringifyProperty;
	var styleParser = utils.styleParser;
	
	/**
	 * Component class definition.
	 *
	 * Components configure appearance, modify behavior, or add functionality to
	 * entities. The behavior and appearance of an entity can be changed at runtime
	 * by adding, removing, or updating components. Entities do not share instances
	 * of components.
	 *
	 * @member {object} data - Component data populated by parsing the
	 *         mapped attribute of the component plus applying defaults and mixins.
	 * @member {object} el - Reference to the entity element.
	 * @member {string} name - Component name exposed as an HTML attribute.
	 */
	var Component = module.exports.Component = function (el) {
	  var name = this.name;
	  var elData = HTMLElement.prototype.getAttribute.call(el, name);
	
	  this.el = el;
	  // Check whether we need to rebuild the schema depending on the data.
	  // Call buildData with silent flag to suppress warnings when parsing data before updating
	  // the schema.
	  if (this.updateSchema) {
	    this.updateSchema(buildData(el, name, this.schema, elData, true));
	  }
	  this.data = buildData(el, name, this.schema, elData);
	  this.init();
	  this.update();
	};
	
	Component.prototype = {
	  /**
	   * Contains the type schema and defaults for the data values.
	   * Data is coerced into the types of the values of the defaults.
	   */
	  schema: { },
	
	  /**
	   * Init handler. Similar to attachedCallback.
	   * Called during component initialization and is only run once.
	   * Components can use this to set initial state.
	   */
	  init: function () { /* no-op */ },
	
	  /**
	   * Update handler. Similar to attributeChangedCallback.
	   * Called whenever component's data changes.
	   * Also called on component initialization when the component receives initial data.
	   *
	   * @param {object} prevData - Previous attributes of the component.
	   */
	  update: function (prevData) { /* no-op */ },
	
	  updateSchema: undefined,
	
	  /**
	   * Tick handler.
	   * Called on each tick of the scene render loop.
	   * Affected by play and pause.
	   *
	   * @param {number} time - Scene tick time.
	   * @param {number} timeDelta - Difference in current render time and previous render time.
	   */
	  tick: undefined,
	
	  /**
	   * Called to start any dynamic behavior (e.g., animation, AI, events, physics).
	   */
	  play: function () { /* no-op */ },
	
	  /**
	   * Called to stop any dynamic behavior (e.g., animation, AI, events, physics).
	   */
	  pause: function () { /* no-op */ },
	
	  /**
	   * Remove handler. Similar to detachedCallback.
	   * Called whenever component is removed from the entity (i.e., removeAttribute).
	   * Components can use this to reset behavior on the entity.
	   */
	  remove: function () { /* no-op */ },
	
	  /**
	   * Parses each property based on property type.
	   * If component is single-property, then parses the single property value.
	   *
	   * @param {string} value - HTML attribute value.
	   * @param {boolean} silent - Suppress warning messages.
	   * @returns {object} Component data.
	   */
	  parse: function (value, silent) {
	    var schema = this.schema;
	    if (isSingleProp(schema)) { return parseProperty(value, schema); }
	    return parseProperties(styleParser.parse(value), schema, true, silent);
	  },
	
	  /**
	   * Stringify properties if necessary.
	   *
	   * Only called from `Entity.setAttribute` for properties whose parsers accept a non-string
	   * value (e.g., selector, vec3 property types).
	   *
	   * @param {object} data - Complete component data.
	   * @returns {string}
	   */
	  stringify: function (data) {
	    var schema = this.schema;
	    if (typeof data === 'string') { return data; }
	
	    if (isSingleProp(schema)) { return stringifyProperty(data, schema); }
	    data = stringifyProperties(data, schema);
	    return styleParser.stringify(data);
	  },
	
	  /**
	   * Returns a copy of data such that we don't expose the private this.data.
	   *
	   * @returns {object} data
	   */
	  getData: function () {
	    var data = this.data;
	    if (typeof data !== 'object') { return data; }
	    return utils.extend({}, data);
	  },
	
	  /**
	   * Apply new component data if data has changed.
	   *
	   * @param {string} value - HTML attribute value.
	   */
	  updateProperties: function (value) {
	    var el = this.el;
	    var isSinglePropSchema = isSingleProp(this.schema);
	    var previousData = extendProperties({}, this.data, isSinglePropSchema);
	
	    if (this.updateSchema) {
	      this.updateSchema(buildData(el, this.name, this.schema, value, true));
	    }
	    this.data = buildData(el, this.name, this.schema, value);
	
	    // Don't update if properties haven't changed
	    if (!isSinglePropSchema && utils.deepEqual(previousData, this.data)) { return; }
	
	    this.update(previousData);
	
	    el.emit('componentchanged', {
	      name: this.name,
	      newData: this.getData(),
	      oldData: previousData
	    });
	  },
	
	  /**
	   * Extend schema of component given a partial schema.
	   *
	   * Some components might want to mutate their schema based on certain properties.
	   * e.g., Material component changes its schema based on `shader` to account for different
	   * uniforms
	   *
	   * @param {object} schemaAddon - Schema chunk that extend base schema.
	   */
	  extendSchema: function (schemaAddon) {
	    // Clone base schema.
	    var extendedSchema = utils.extend({}, components[this.name].schema);
	    // Extend base schema with new schema chunk.
	    utils.extend(extendedSchema, schemaAddon);
	    this.schema = processSchema(extendedSchema);
	    this.el.emit('schemachanged', { component: this.name });
	  }
	};
	
	/**
	 * Registers a component to A-Frame.
	 *
	 * @param {string} name - Component name.
	 * @param {object} definition - Component schema and lifecycle method handlers.
	 * @returns {object} Component.
	 */
	module.exports.registerComponent = function (name, definition) {
	  var NewComponent;
	  var proto = {};
	
	  // Format definition object to prototype object.
	  Object.keys(definition).forEach(function (key) {
	    proto[key] = {
	      value: definition[key],
	      writable: true
	    };
	  });
	
	  if (components[name]) {
	    throw new Error('The component `' + name + '` has been already registered. ' +
	                    'Check that you are not loading two versions of the same component ' +
	                    'or two different components of the same name.');
	  }
	  NewComponent = function (el) {
	    Component.call(this, el);
	  };
	  NewComponent.prototype = Object.create(Component.prototype, proto);
	  NewComponent.prototype.name = name;
	  NewComponent.prototype.constructor = NewComponent;
	  NewComponent.prototype.system = systems && systems.systems[name];
	
	  components[name] = {
	    Component: NewComponent,
	    dependencies: NewComponent.prototype.dependencies,
	    parse: NewComponent.prototype.parse.bind(NewComponent.prototype),
	    schema: utils.extend(processSchema(NewComponent.prototype.schema)),
	    stringify: NewComponent.prototype.stringify.bind(NewComponent.prototype),
	    type: NewComponent.prototype.type
	  };
	  return NewComponent;
	};
	
	/**
	 * Builds component data from the current state of the entity, ultimately
	 * updating this.data.
	 *
	 * If the component was detached completely, set data to null.
	 *
	 * Precedence:
	 * 1. Defaults data
	 * 2. Mixin data.
	 * 3. Attribute data.
	 *
	 * Finally coerce the data to the types of the defaults.
	 *
	 * @param {object} el - Element to build data from.
	 * @param {object} name - Component name.
	 * @param {object} schema - Component schema.
	 * @param {object} elData - Element current data.
	 * @param {boolean} silent - Suppress warning messages.
	 * @return {object} The component data
	 */
	function buildData (el, name, schema, elData, silent) {
	  var componentDefined = elData !== null;
	  var data = {};
	  var isSinglePropSchema = isSingleProp(schema);
	  var mixinEls = el.mixinEls;
	
	  if (!isSinglePropSchema && typeof elData === 'string') {
	    elData = styleParser.parse(elData);
	  }
	
	  // 1. Default values (lowest precendence).
	  if (isSinglePropSchema) {
	    data = schema.default;
	  } else {
	    Object.keys(schema).forEach(function applyDefault (key) {
	      data[key] = schema[key].default;
	    });
	  }
	
	  // 2. Mixin values.
	  mixinEls.forEach(applyMixin);
	  function applyMixin (mixinEl) {
	    var mixinData = HTMLElement.prototype.getAttribute.call(mixinEl, name);
	    if (mixinData) {
	      mixinData = isSinglePropSchema
	        ? mixinData : styleParser.parse(mixinData);
	      data = extendProperties(data, mixinData, isSinglePropSchema);
	    }
	  }
	
	  // 3. Attribute values (highest precendence).
	  if (componentDefined) {
	    data = extendProperties(data, elData, isSinglePropSchema);
	  }
	
	  // Parse and coerce using the schema.
	  if (isSingleProp(schema)) {
	    return parseProperty(data, schema);
	  }
	
	  return parseProperties(data, schema, undefined, silent);
	}
	module.exports.buildData = buildData;
	
	/**
	* Object extending with checking for single-property schema.
	*
	* @param dest - Destination object or value.
	* @param source - Source object or value
	* @param {boolean} isSinglePropSchema - Whether or not schema is only a single property.
	* @returns Overridden object or value.
	*/
	function extendProperties (dest, source, isSinglePropSchema) {
	  if (isSinglePropSchema) {
	    if (source === undefined ||
	        (typeof source === 'object' && Object.keys(source).length === 0)) {
	      return dest;
	    }
	    return source;
	  }
	  return utils.extend(dest, source);
	}
	
	},{"../utils/":102,"./schema":62,"./system":64}],57:[function(_dereq_,module,exports){
	var coordinates = _dereq_('../utils/coordinates');
	var debug = _dereq_('debug');
	
	var error = debug('core:propertyTypes:warn');
	
	var propertyTypes = module.exports.propertyTypes = {};
	
	// Built-in property types.
	registerPropertyType('array', [], arrayParse, arrayStringify);
	registerPropertyType('boolean', false, boolParse);
	registerPropertyType('color', '#FFF', defaultParse, defaultStringify);
	registerPropertyType('int', 0, intParse);
	registerPropertyType('number', 0, numberParse);
	registerPropertyType('selector', '', selectorParse, selectorStringify);
	registerPropertyType('selectorAll', '', selectorAllParse, selectorAllStringify);
	registerPropertyType('src', '', srcParse);
	registerPropertyType('string', '', defaultParse, defaultStringify);
	registerPropertyType('time', 0, intParse);
	registerPropertyType('vec2', { x: 0, y: 0 }, vecParse, coordinates.stringify);
	registerPropertyType('vec3', { x: 0, y: 0, z: 0 }, vecParse, coordinates.stringify);
	registerPropertyType('vec4', { x: 0, y: 0, z: 0, w: 0 }, vecParse, coordinates.stringify);
	
	/**
	 * Register a parser for re-use such that when someone uses `type` in the schema,
	 * `schema.process` will set the property `parse` and `stringify`.
	 *
	 * @param {string} type - Type name.
	 * @param [defaultValue=null] -
	 *   Default value to use if component does not define default value.
	 * @param {function} [parse=defaultParse] - Parse string function.
	 * @param {function} [stringify=defaultStringify] - Stringify to DOM function.
	 */
	function registerPropertyType (type, defaultValue, parse, stringify) {
	  if ('type' in propertyTypes) {
	    error('Property type ' + type + ' is already registered.');
	    return;
	  }
	
	  propertyTypes[type] = {
	    default: defaultValue,
	    parse: parse || defaultParse,
	    stringify: stringify || defaultStringify
	  };
	}
	module.exports.registerPropertyType = registerPropertyType;
	
	function arrayParse (value) {
	  if (Array.isArray(value)) { return value; }
	  if (!value || typeof value !== 'string') { return []; }
	  return value.split(',').map(trim);
	  function trim (str) { return str.trim(); }
	}
	
	function arrayStringify (value) {
	  return value.join(', ');
	}
	
	function defaultParse (value) {
	  return value;
	}
	
	function defaultStringify (value) {
	  if (value === null) { return 'null'; }
	  return value.toString();
	}
	
	function boolParse (value) {
	  return value !== 'false' && value !== false;
	}
	
	function intParse (value) {
	  return parseInt(value, 10);
	}
	
	function numberParse (value) {
	  return parseFloat(value, 10);
	}
	
	function selectorParse (value) {
	  if (!value) { return null; }
	  if (typeof value !== 'string') { return value; }
	  return document.querySelector(value);
	}
	
	function selectorAllParse (value) {
	  if (!value) { return null; }
	  if (typeof value !== 'string') { return value; }
	  return document.querySelectorAll(value);
	}
	
	function selectorStringify (value) {
	  if (value.getAttribute) {
	    return '#' + value.getAttribute('id');
	  }
	  return defaultStringify(value);
	}
	
	function selectorAllStringify (value) {
	  if (value.item) {
	    var els = '';
	    var i;
	    for (i = 0; i < value.length; ++i) {
	      els += '#' + value[i].getAttribute('id');
	      if (i !== value.length - 1) { els += ', '; }
	    }
	    return els;
	  }
	  return defaultStringify(value);
	}
	
	/**
	 * `src` parser for assets.
	 *
	 * @param {string} value - Can either be `url(<value>)` or a selector to an asset.
	 * @returns {string} Parsed value from `url(<value>)` or src from `<someasset src>`.
	 */
	function srcParse (value) {
	  var parsedUrl = value.match(/\url\((.+)\)/);
	  if (parsedUrl) { return parsedUrl[1]; }
	
	  var el = selectorParse(value);
	  if (el) { return el.getAttribute('src'); }
	
	  return '';
	}
	
	function vecParse (value) {
	  return coordinates.parse(value, this.default);
	}
	
	},{"../utils/coordinates":100,"debug":3}],58:[function(_dereq_,module,exports){
	/* global Promise */
	var initFullscreen = _dereq_('./fullscreen');
	var initMetaTags = _dereq_('./metaTags').inject;
	var initWakelock = _dereq_('./wakelock');
	var re = _dereq_('../a-register-element');
	var systems = _dereq_('../system').systems;
	var THREE = _dereq_('../../lib/three');
	var TWEEN = _dereq_('tween.js');
	var utils = _dereq_('../../utils/');
	// Require after.
	var AEntity = _dereq_('../a-entity');
	var ANode = _dereq_('../a-node');
	
	var registerElement = re.registerElement;
	var isIOS = utils.isIOS();
	var isMobile = utils.isMobile();
	
	/**
	 * Scene element, holds all entities.
	 *
	 * @member {number} animationFrameID
	 * @member {array} behaviors - Component instances that have registered themselves to be
	           updated on every tick.
	 * @member {object} camera - three.js Camera object.
	 * @member {object} canvas
	 * @member {bool} isScene - Differentiates as scene entity as opposed to other entites.
	 * @member {bool} isMobile - Whether browser is mobile (via UA detection).
	 * @member {object} object3D - Root three.js Scene object.
	 * @member {object} monoRenderer
	 * @member {object} renderer
	 * @member {bool} renderStarted
	 * @member {object} stereoRenderer
	 * @member {object} systems - Registered instantiated systems.
	 * @member {number} time
	 */
	var AScene = module.exports = registerElement('a-scene', {
	  prototype: Object.create(AEntity.prototype, {
	    defaultComponents: {
	      value: {
	        'canvas': '',
	        'keyboard-shortcuts': '',
	        'vr-mode-ui': ''
	      }
	    },
	
	    createdCallback: {
	      value: function () {
	        this.isMobile = isMobile;
	        this.isIOS = isIOS;
	        this.isScene = true;
	        this.object3D = new THREE.Scene();
	        this.systems = {};
	        this.time = 0;
	        this.init();
	      }
	    },
	
	    init: {
	      value: function () {
	        this.behaviors = [];
	        this.hasLoaded = false;
	        this.isPlaying = true;
	        this.originalHTML = this.innerHTML;
	        this.setupSystems();
	        this.addEventListener('render-target-loaded', function () {
	          this.setupRenderer();
	          this.resize();
	        });
	      },
	      writable: true
	    },
	
	    attachedCallback: {
	      value: function () {
	        initFullscreen(this);
	        initMetaTags(this);
	        initWakelock(this);
	
	        window.addEventListener('load', this.resize.bind(this));
	        window.addEventListener('resize', this.resize.bind(this), false);
	        this.addEventListener('fullscreen-exit', this.exitVR.bind(this));
	        this.play();
	      },
	      writable: window.debug
	    },
	
	    setupSystems: {
	      value: function () {
	        var systemsKeys = Object.keys(systems);
	        systemsKeys.forEach(this.initSystem.bind(this));
	      }
	    },
	
	    initSystem: {
	      value: function (name) {
	        var system;
	        if (this.systems[name]) { return; }
	        system = this.systems[name] = new systems[name]();
	        system.sceneEl = this;
	        system.init();
	      }
	    },
	
	    /**
	     * Shuts down scene on detach.
	     */
	    detachedCallback: {
	      value: function () {
	        window.cancelAnimationFrame(this.animationFrameID);
	        this.animationFrameID = null;
	      }
	    },
	
	    /**
	     * @param {object} behavior - Generally a component. Must implement a .update() method to
	     *        be called on every tick.
	     */
	    addBehavior: {
	      value: function (behavior) {
	        var behaviors = this.behaviors;
	        if (behaviors.indexOf(behavior) !== -1) { return; }
	        behaviors.push(behavior);
	      }
	    },
	
	    /**
	     * Generally must be triggered on user action for requesting fullscreen.
	     */
	    enterVR: {
	      value: function (event) {
	        this.setStereoRenderer();
	        if (isMobile) {
	          setFullscreen(this.canvas);
	        } else {
	          this.stereoRenderer.setFullScreen(true);
	        }
	        this.addState('vr-mode');
	        this.emit('enter-vr', event);
	      }
	    },
	
	    exitVR: {
	      value: function () {
	        this.setMonoRenderer();
	        this.removeState('vr-mode');
	        this.emit('exit-vr', { target: this });
	      }
	    },
	
	    /**
	     * @param {object} behavior - Generally a component. Has registered itself to behaviors.
	     */
	    removeBehavior: {
	      value: function (behavior) {
	        var behaviors = this.behaviors;
	        var index = behaviors.indexOf(behavior);
	        if (index === -1) { return; }
	        behaviors.splice(index, 1);
	      }
	    },
	
	    resize: {
	      value: function () {
	        var camera = this.camera;
	        var canvas = this.canvas;
	        var size;
	
	        // Possible camera or canvas not injected yet.
	        if (!camera || !canvas) { return; }
	
	        // Update canvas.
	        if (!isMobile) {
	          canvas.style.width = '100%';
	          canvas.style.height = '100%';
	        }
	
	        // Update camera.
	        size = getCanvasSize(canvas, isMobile);
	        camera.aspect = size.width / size.height;
	        camera.updateProjectionMatrix();
	
	        // Notify renderer of size change.
	        this.renderer.setSize(size.width, size.height, true);
	      },
	      writable: window.debug
	    },
	
	    /**
	     * Sets renderer to mono (one eye).
	     */
	    setMonoRenderer: {
	      value: function () {
	        this.renderer = this.monoRenderer;
	        this.resize();
	      }
	    },
	
	    /**
	     * Sets renderer to stereo (two eyes).
	     */
	    setStereoRenderer: {
	      value: function () {
	        this.renderer = this.stereoRenderer;
	        this.resize();
	      }
	    },
	
	    setupRenderer: {
	      value: function () {
	        var canvas = this.canvas;
	        // Set at startup. To enable/disable antialias
	        // at runttime we would have to recreate the whole context
	        var antialias = this.getAttribute('antialias') === 'true';
	        var renderer = this.renderer = this.monoRenderer =
	          new THREE.WebGLRenderer({
	            canvas: canvas,
	            antialias: antialias,
	            alpha: true
	          });
	        renderer.setPixelRatio(window.devicePixelRatio);
	        renderer.sortObjects = false;
	        AScene.renderer = renderer;
	        this.stereoRenderer = new THREE.VREffect(renderer);
	      },
	      writable: window.debug
	    },
	
	    /**
	     * Handler attached to elements to help scene know when to kick off.
	     * Scene waits for all entities to load.
	     */
	    play: {
	      value: function () {
	        var self = this;
	
	        if (this.renderStarted) {
	          AEntity.prototype.play.call(this);
	          return;
	        }
	
	        this.addEventListener('loaded', function () {
	          if (this.renderStarted) { return; }
	
	          AEntity.prototype.play.call(this);
	          this.resize();
	
	          // Kick off render loop.
	          if (this.renderer) {
	            if (window.performance) {
	              window.performance.mark('render-started');
	            }
	            this.render();
	            this.renderStarted = true;
	            this.emit('renderstart');
	          }
	        });
	
	        // setTimeout to wait for all nodes to attach and run their callbacks.
	        setTimeout(function () {
	          AEntity.prototype.load.call(self);
	        });
	      }
	    },
	
	    /**
	     * Reload the scene to the original DOM content.
	     *
	     * @param {bool} doPause - Whether to reload the scene with all dynamic behavior paused.
	     */
	    reload: {
	      value: function (doPause) {
	        var self = this;
	        if (doPause) { this.pause(); }
	        this.innerHTML = this.originalHTML;
	        this.init();
	        ANode.prototype.load.call(this, play);
	        function play () {
	          if (!self.isPlaying) { return; }
	          AEntity.prototype.play.call(self);
	        }
	      }
	    },
	
	    /**
	     * The render loop.
	     *
	     * Updates animations.
	     * Updates behaviors.
	     * Renders with request animation frame.
	     */
	    render: {
	      value: function (time) {
	        var camera = this.camera;
	        var timeDelta = time - this.time;
	        var systems = this.systems;
	
	        if (this.isPlaying) {
	          TWEEN.update(time);
	          this.behaviors.forEach(function (component) {
	            if (!component.el.isPlaying) { return; }
	            component.tick(time, timeDelta);
	          });
	          Object.keys(systems).forEach(function (key) {
	            if (!systems[key].tick) { return; }
	            systems[key].tick(time, timeDelta);
	          });
	        }
	
	        this.renderer.render(this.object3D, camera);
	
	        this.time = time;
	        this.animationFrameID = window.requestAnimationFrame(this.render.bind(this));
	      },
	      writable: window.debug
	    }
	  })
	});
	
	function getCanvasSize (canvas) {
	  if (isMobile) {
	    return {
	      height: window.innerHeight,
	      width: window.innerWidth
	    };
	  }
	  return {
	    height: canvas.offsetHeight,
	    width: canvas.offsetWidth
	  };
	}
	
	/**
	 * Manually handles fullscreen for non-VR mobile where the renderer' VR
	 * display is not polyfilled.
	 *
	 * Desktop just works so use the renderer.setFullScreen in that case.
	 */
	function setFullscreen (canvas) {
	  if (canvas.requestFullscreen) {
	    canvas.requestFullscreen();
	  } else if (canvas.mozRequestFullScreen) {
	    canvas.mozRequestFullScreen();
	  } else if (canvas.webkitRequestFullscreen) {
	    canvas.webkitRequestFullscreen();
	  }
	}
	
	},{"../../lib/three":90,"../../utils/":102,"../a-entity":52,"../a-node":54,"../a-register-element":55,"../system":64,"./fullscreen":59,"./metaTags":60,"./wakelock":61,"tween.js":22}],59:[function(_dereq_,module,exports){
	var isIframed = _dereq_('../../utils/').isIframed;
	
	/**
	 * Register fullscreen listener to scene.
	 */
	module.exports = function initFullscreenListener (scene) {
	  var handler = fullscreenChangeHandler.bind(scene);
	  document.addEventListener('mozfullscreenchange', handler);
	  document.addEventListener('webkitfullscreenchange', handler);
	
	  // Handles fullscreen behavior when inside an iframe.
	  if (!isIframed()) { return; }
	  window.addEventListener('message', iframedFullscreenChangeHandler.bind(scene));
	};
	
	function fullscreenChangeHandler (event) {
	  var fullscreenElement = document.fullscreenElement ||
	                          document.mozFullScreenElement ||
	                          document.webkitFullscreenElement;
	  var scene = this;
	
	  // Lock to landscape orientation on mobile.
	  if (scene.isMobile && window.screen.orientation) {
	    if (fullscreenElement) {
	      window.screen.orientation.lock('landscape');
	    } else {
	      window.screen.orientation.unlock();
	    }
	  }
	
	  if (fullscreenElement) {
	    enterFullscreenHandler(scene);
	  } else {
	    exitFullscreenHandler(scene);
	  }
	}
	
	function iframedFullscreenChangeHandler (event) {
	  var scene = this;
	  if (!event.data) { return; }
	
	  switch (event.data.type) {
	    case 'fullscreen': {
	      switch (event.data.data) {
	        case 'enter':
	          enterFullscreenHandler(scene);
	          break;
	        case 'exit':
	          exitFullscreenHandler(scene);
	          break;
	      }
	    }
	  }
	}
	
	function enterFullscreenHandler (scene) {
	  scene.addState('fullscreen');
	  scene.emit('fullscreen-enter');
	}
	
	function exitFullscreenHandler (scene) {
	  scene.removeState('fullscreen');
	  scene.emit('fullscreen-exit');
	}
	
	},{"../../utils/":102}],60:[function(_dereq_,module,exports){
	var extend = _dereq_('../../utils').extend;
	
	var MOBILE_HEAD_TAGS = module.exports.MOBILE_HEAD_TAGS = [
	  Meta({name: 'viewport', content: 'width=device-width,initial-scale=1,maximum-scale=1,shrink-to-fit=no,user-scalable=no,minimal-ui'}),
	
	  // W3C-standardised meta tags.
	  Meta({name: 'mobile-web-app-capable', content: 'yes'}),
	  Meta({name: 'theme-color', content: 'black'}),
	  Link({rel: 'icon', sizes: '192x192', href: 'https://aframe.io/images/aframe-logo-192.png'})
	];
	
	var MOBILE_IOS_HEAD_TAGS = [
	  // iOS-specific meta tags for fullscreen when pinning to homescreen.
	  Meta({name: 'apple-mobile-web-app-capable', content: 'yes'}),
	  Meta({name: 'apple-mobile-web-app-status-bar-style', content: 'black'}),
	  Link({rel: 'apple-touch-icon', href: 'https://aframe.io/images/aframe-logo-152.png'})
	];
	
	function Meta (attrs) {
	  return {
	    tagName: 'meta',
	    attributes: attrs,
	    exists: function () { return document.querySelector('meta[name="' + attrs.name + '"]'); }
	  };
	}
	
	function Link (attrs) {
	  return {
	    tagName: 'link',
	    attributes: attrs,
	    exists: function () { return document.querySelector('link[rel="' + attrs.rel + '"]'); }
	  };
	}
	
	/**
	 * Injects the necessary metatags in the document for mobile support:
	 * 1. Prevent the user to zoom in the document.
	 * 2. Ensure that window.innerWidth and window.innerHeight have the correct
	 *    values and the canvas is properly scaled.
	 * 3. To allow fullscreen mode when pinning a web app on the home screen on
	 *    iOS.
	 * Adapted from https://www.reddit.com/r/web_design/comments/3la04p/
	 *
	 * @param {object} scene - Scene element
	 * @returns {Array}
	 */
	module.exports.inject = function injectHeadTags (scene) {
	  var headEl = document.head;
	  var headScriptEl = headEl.querySelector('script');
	  var tag;
	  var headTags = [];
	  MOBILE_HEAD_TAGS.forEach(createAndInjectTag);
	  if (scene.isIOS) {
	    MOBILE_IOS_HEAD_TAGS.forEach(createAndInjectTag);
	  }
	  return headTags;
	
	  function createAndInjectTag (tagObj) {
	    if (!tagObj || tagObj.exists()) { return; }
	
	    tag = createTag(tagObj);
	    if (!tag) { return; }
	
	    if (headScriptEl) {
	      headScriptEl.parentNode.insertBefore(tag, headScriptEl);
	    } else {
	      headEl.appendChild(tag);
	    }
	
	    headTags.push(tag);
	  }
	};
	
	function createTag (tagObj) {
	  if (!tagObj || !tagObj.tagName) { return; }
	  var meta = document.createElement(tagObj.tagName);
	  return extend(meta, tagObj.attributes);
	}
	
	},{"../../utils":102}],61:[function(_dereq_,module,exports){
	var Wakelock = _dereq_('../../../vendor/wakelock/wakelock');
	
	module.exports = function initWakelock (scene) {
	  if (!scene.isMobile) { return; }
	
	  var wakelock = scene.wakelock = new Wakelock();
	  scene.addEventListener('enter-vr', function () { wakelock.request(); });
	  scene.addEventListener('exit-vr', function () { wakelock.release(); });
	};
	
	},{"../../../vendor/wakelock/wakelock":109}],62:[function(_dereq_,module,exports){
	var debug = _dereq_('../utils/debug');
	var propertyTypes = _dereq_('./propertyTypes').propertyTypes;
	var warn = debug('core:schema:warn');
	
	/**
	 * A schema is classified as a schema for a single property if:
	 * - `type` is defined on the schema as a string.
	 * - OR `default` is defined on the schema, as a reserved keyword.
	 * - OR schema is empty.
	 */
	function isSingleProperty (schema) {
	  if ('type' in schema) {
	    return typeof schema.type === 'string';
	  }
	  return 'default' in schema;
	}
	module.exports.isSingleProperty = isSingleProperty;
	
	/**
	 * Build step to schema to use `type` to inject default value, parser, and stringifier.
	 *
	 * @param {object} schema
	 * @returns {object} Schema.
	 */
	module.exports.process = function (schema) {
	  // For single property schema, run processPropDefinition over the whole schema.
	  if (isSingleProperty(schema)) {
	    return processPropertyDefinition(schema);
	  }
	
	  // For multi-property schema, run processPropDefinition over each property definition.
	  Object.keys(schema).forEach(function (propName) {
	    schema[propName] = processPropertyDefinition(schema[propName]);
	  });
	  return schema;
	};
	
	/**
	 * Inject default value, parser, stringifier for single property.
	 */
	function processPropertyDefinition (propDefinition) {
	  var defaultVal = propDefinition.default;
	  var propType;
	  var typeName = propDefinition.type;
	
	  // Type inference.
	  if (!propDefinition.type) {
	    if (defaultVal !== undefined && ['boolean', 'number'].indexOf(typeof defaultVal) !== -1) {
	      // Type inference.
	      typeName = typeof defaultVal;
	    } else if (Array.isArray(defaultVal)) {
	      typeName = 'array';
	    } else {
	      // Fall back to string.
	      typeName = 'string';
	    }
	  } else if (propDefinition.type === 'bool') {
	    typeName = 'boolean';
	  } else if (propDefinition.type === 'float') {
	    typeName = 'number';
	  }
	
	  propType = propertyTypes[typeName];
	  if (!propType) {
	    warn('Unknown property type: ' + typeName);
	  }
	
	  // Fill in parse and stringify using property types.
	  propDefinition.parse = propDefinition.parse || propType.parse;
	  propDefinition.stringify = propDefinition.stringify || propType.stringify;
	
	  // Fill in type name.
	  propDefinition.type = typeName;
	
	  // Fill in default value.
	  if (!('default' in propDefinition)) {
	    propDefinition.default = propType.default;
	  }
	
	  return propDefinition;
	}
	module.exports.processPropertyDefinition = processPropertyDefinition;
	
	/**
	 * Parse propData using schema. Use default values if not existing in propData.
	 *
	 * @param {object} propData - Unparsed properties.
	 * @param {object} schema - Property types definition.
	 * @param {boolean} getPartialData - Whether to return full component data or just the data
	 *        with keys in `propData`.
	 * @param {boolean} silent - Suppress warning messages.
	 */
	module.exports.parseProperties = function (propData, schema, getPartialData, silent) {
	  var propNames = Object.keys(getPartialData ? propData : schema);
	
	  if (propData === null || typeof propData !== 'object') { return propData; }
	
	  // Validation errors.
	  Object.keys(propData).forEach(function (propName) {
	    if (!schema[propName] && !silent) {
	      warn('Unknown component property: ' + propName);
	    }
	  });
	
	  propNames.forEach(function parse (propName) {
	    var propDefinition = schema[propName];
	    var propValue = propData[propName];
	
	    if (!(schema[propName])) { return; }
	
	    propValue = propValue === undefined ? propDefinition.default : propValue;
	    propData[propName] = parseProperty(propValue, propDefinition);
	  });
	
	  return propData;
	};
	
	/**
	 * Deserialize a single property.
	 */
	function parseProperty (value, propDefinition) {
	  if (typeof value !== 'string') { return value; }
	  if (typeof value === 'undefined') { return value; }
	  return propDefinition.parse(value);
	}
	module.exports.parseProperty = parseProperty;
	
	/**
	 * Serialize a group of properties.
	 */
	module.exports.stringifyProperties = function (propData, schema) {
	  var stringifiedData = {};
	  Object.keys(propData).forEach(function (propName) {
	    var propDefinition = schema[propName];
	    var propValue = propData[propName];
	    var value = propValue;
	    if (typeof value === 'object') {
	      value = stringifyProperty(propValue, propDefinition);
	      if (!propDefinition) { warn('Unknown component property: ' + propName); }
	    }
	    stringifiedData[propName] = value;
	  });
	  return stringifiedData;
	};
	
	/**
	 * Serialize a single property.
	 */
	function stringifyProperty (value, propDefinition) {
	  if (typeof value !== 'object') { return value; }
	  // if there's no schema for the property we use standar JSON stringify
	  if (!propDefinition) { return JSON.stringify(value); }
	  return propDefinition.stringify(value);
	}
	module.exports.stringifyProperty = stringifyProperty;
	
	},{"../utils/debug":101,"./propertyTypes":57}],63:[function(_dereq_,module,exports){
	var schema = _dereq_('./schema');
	
	var processSchema = schema.process;
	var shaders = module.exports.shaders = {};  // Keep track of registered shaders.
	var shaderNames = module.exports.shaderNames = [];  // Keep track of the names of registered shaders.
	var THREE = _dereq_('../lib/three');
	
	var propertyToThreeMapping = {
	  number: 'f',
	  time: 'f',
	  vec4: 'v4',
	  vec3: 'v3',
	  vec2: 'v2',
	  color: 'v3'
	};
	
	/**
	 * Shader class definition.
	 *
	 * Shaders extend the material component API so you can create your own library
	 * of customized materials
	 *
	 */
	var Shader = module.exports.Shader = function () {};
	
	Shader.prototype = {
	  /**
	   * Contains the type schema and defaults for the data values.
	   * Data is coerced into the types of the values of the defaults.
	   */
	  schema: { },
	
	  vertexShader:
	    'void main() {' +
	      'gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);' +
	    '}',
	
	  fragmentShader:
	    'void main() {' +
	      'gl_FragColor = vec4(1.0,0.0,1.0,1.0);' +
	    '}',
	
	  /**
	   * Init handler. Similar to attachedCallback.
	   * Called during shader initialization and is only run once.
	   */
	  init: function (data) {
	    this.attributes = this.initVariables(data, 'attribute');
	    this.uniforms = this.initVariables(data, 'uniform');
	    this.material = new THREE.ShaderMaterial({
	      // attributes: this.attributes,
	      uniforms: this.uniforms,
	      vertexShader: this.vertexShader,
	      fragmentShader: this.fragmentShader
	    });
	    return this.material;
	  },
	
	  initVariables: function (data, type) {
	    var self = this;
	    var variables = {};
	    var schema = this.schema;
	    var squemaKeys = Object.keys(schema);
	    squemaKeys.forEach(processSquema);
	    function processSquema (key) {
	      if (schema[key].is !== type) { return; }
	      var varType = propertyToThreeMapping[schema[key].type];
	      var varValue = schema[key].parse(data[key] || schema[key].default);
	      variables[key] = {
	        type: varType,
	        value: self.parseValue(schema[key].type, varValue)
	      };
	    }
	    return variables;
	  },
	
	  /**
	   * Update handler. Similar to attributeChangedCallback.
	   * Called whenever the associated material data changes.
	   *
	   * @param {object} data - New material data.
	   */
	  update: function (data) {
	    this.updateVariables(data, 'attribute');
	    this.updateVariables(data, 'uniform');
	  },
	
	  updateVariables: function (data, type) {
	    var self = this;
	    var variables = type === 'uniform' ? this.uniforms : this.attributes;
	    var dataKeys = Object.keys(data);
	    var schema = this.schema;
	    dataKeys.forEach(processData);
	    function processData (key) {
	      if (!schema[key] || schema[key].is !== type) { return; }
	      if (variables[key].value === data[key]) { return; }
	      variables[key].value = self.parseValue(schema[key].type, data[key]);
	      variables[key].needsUpdate = true;
	    }
	  },
	
	  parseValue: function (type, value) {
	    var color;
	    switch (type) {
	      case 'vec2': {
	        return new THREE.Vector2(value.x, value.y);
	      }
	      case 'vec3': {
	        return new THREE.Vector3(value.x, value.y, value.z);
	      }
	      case 'vec4': {
	        return new THREE.Vector4(value.x, value.y, value.z, value.w);
	      }
	      case 'color': {
	        color = new THREE.Color(value);
	        return new THREE.Vector3(color.r, color.g, color.b);
	      }
	      default: {
	        return value;
	      }
	    }
	  }
	};
	
	/**
	 * Registers a shader to A-Frame.
	 *
	 * @param {string} name - shader name.
	 * @param {object} definition - shader property and methods.
	 * @returns {object} Shader.
	 */
	module.exports.registerShader = function (name, definition) {
	  var NewShader;
	  var proto = {};
	
	  // Format definition object to prototype object.
	  Object.keys(definition).forEach(function (key) {
	    proto[key] = {
	      value: definition[key],
	      writable: true
	    };
	  });
	
	  if (shaders[name]) {
	    throw Error('The shader ' + name + ' has been already registered');
	  }
	  NewShader = function () { Shader.call(this); };
	  NewShader.prototype = Object.create(Shader.prototype, proto);
	  NewShader.prototype.name = name;
	  NewShader.prototype.constructor = NewShader;
	  shaders[name] = {
	    Shader: NewShader,
	    schema: processSchema(NewShader.prototype.schema)
	  };
	  shaderNames.push(name);
	  return NewShader;
	};
	
	},{"../lib/three":90,"./schema":62}],64:[function(_dereq_,module,exports){
	var components = _dereq_('./component');
	var systems = module.exports.systems = {};  // Keep track of registered components.
	
	/**
	 * System class definition.
	 *
	 * Systems provide global scope and services to a group of instantiated components of the.
	 * same class. For example, a physics component that creates a physics world that oversees
	 * all entities with a physics or rigid body component.
	 *
	 * @member {string} name - Name that system is registered under.
	 * @member {Element} sceneEl - Handle to the scene element where system applies to.
	 */
	var System = module.exports.System = function () {
	  var component = components && components.components[this.name];
	  if (component) { component.Component.prototype.system = this; }
	};
	
	System.prototype = {
	
	  /**
	   * Init handler. Called during scene initialization and is only run once.
	   * Systems can use this to set initial state.
	   */
	  init: function () { /* no-op */ },
	
	  /**
	   * Tick handler.
	   * Called on each tick of the scene render loop.
	   * Affected by play and pause.
	   *
	   * @param {number} time - Scene tick time.
	   * @param {number} timeDelta - Difference in current render time and previous render time.
	   */
	  tick: undefined,
	
	  /**
	   * Called to start any dynamic behavior (e.g., animation, AI, events, physics).
	   */
	  play: function () { /* no-op */ },
	
	  /**
	   * Called to stop any dynamic behavior (e.g., animation, AI, events, physics).
	   */
	  pause: function () { /* no-op */ }
	};
	
	/**
	 * Registers a system to A-Frame.
	 *
	 * @param {string} name - Component name.
	 * @param {object} definition - Component property and methods.
	 * @returns {object} Component.
	 */
	module.exports.registerSystem = function (name, definition) {
	  var i;
	  var NewSystem;
	  var proto = {};
	  var scenes = document.querySelectorAll('a-scene');
	
	  // Format definition object to prototype object.
	  Object.keys(definition).forEach(function (key) {
	    proto[key] = {
	      value: definition[key],
	      writable: true
	    };
	  });
	
	  if (systems[name]) {
	    throw new Error('The system `' + name + '` has been already registered. ' +
	                    'Check that you are not loading two versions of the same system ' +
	                    'or two different systems of the same name.');
	  }
	  NewSystem = function () { System.call(this); };
	  NewSystem.prototype = Object.create(System.prototype, proto);
	  NewSystem.prototype.name = name;
	  NewSystem.prototype.constructor = NewSystem;
	  systems[name] = NewSystem;
	
	  // Initialize systems for existing scenes
	  for (i = 0; i < scenes.length; i++) { scenes[i].initSystem(name); }
	};
	
	},{"./component":56}],65:[function(_dereq_,module,exports){
	var ANode = _dereq_('../../core/a-node');
	var registerElement = _dereq_('../../core/a-register-element').registerElement;
	
	/**
	 * Declarative events to help register event listeners that set attributes on other entities.
	 * A convenience layer and helper for those that might not know Javascript.
	 *
	 * Note that the event that <a-event> registers is not delegated as this helper is mainly
	 * for those that do not know Javascript and writing raw markup. In which case, delegated
	 * events are not needed. Also helps reduce scope of this helper and encourages people to
	 * learn to register their own event handlers.
	 *
	 * @member {string} name - Event name.
	 * @member {array} targetEls - Elements to modify on event. Defaults to parent element.
	 */
	module.exports = registerElement('a-event', {
	  prototype: Object.create(ANode.prototype, {
	    createdCallback: {
	      value: function () {
	        this.el = null;
	        this.isAEvent = true;
	        this.name = '';
	        this.targetEls = [];
	      }
	    },
	
	    attachedCallback: {
	      value: function () {
	        var targetSelector = this.getAttribute('target');
	        this.el = this.parentNode;
	        this.name = this.getAttribute('name') || this.getAttribute('type');
	
	        if (targetSelector) {
	          this.targetEls = this.closest('a-scene').querySelectorAll(targetSelector);
	        } else {
	          this.targetEls = [this.el];
	        }
	
	        if (this.deprecated) {
	          console.warn(
	            '<' + this.tagName.toLowerCase() + '>' +
	            ' has been DEPRECATED. Use <a-event name="' + this.name + '">' +
	            ' instead.'
	          );
	        }
	
	        // Deprecate `type` for `name`.
	        if (this.hasAttribute('type')) {
	          console.log(
	            '<a-event type> has been DEPRECATED. Use <a-event name> instead.'
	          );
	        }
	
	        this.listener = this.attachEventListener();
	        this.load();
	      }
	    },
	
	    detachedCallback: {
	      value: function () {
	        var listener = this.listener;
	        if (!listener) { return; }
	        this.removeEventListener(this.name, listener);
	      }
	    },
	
	    attachEventListener: {
	      value: function () {
	        var attributes = this.attributes;
	        var el = this.el;
	        var name = this.name;
	        var targetEls = this.targetEls;
	
	        return el.addEventListener(name, function () {
	          var attribute;
	          var attributeName;
	          var attributeSplit;
	          var attributeValue;
	          var targetEl;
	
	          for (var i = 0; i < targetEls.length; i++) {
	            for (var j = 0; j < attributes.length; j++) {
	              attribute = attributes[j];
	              attributeName = attribute.name;
	              attributeValue = attribute.value;
	              targetEl = targetEls[i];
	
	              // target is a keyword for <a-event>.
	              if (attributeName === 'target') { continue; }
	
	              // Handle component property selector like `material.color`.
	              if (attributeName.indexOf('.') !== -1) {
	                attributeSplit = attributeName.split('.');
	                targetEl.setAttribute(attributeSplit[0], attributeSplit[1],
	                                      attributeValue);
	                continue;
	              }
	
	              // Set plain attribute.
	              targetEl.setAttribute(attributeName, attributeValue);
	            }
	          }
	        });
	      }
	    }
	  })
	});
	
	},{"../../core/a-node":54,"../../core/a-register-element":55}],66:[function(_dereq_,module,exports){
	/**
	 * Common mesh defaults, mappings, and transforms.
	 */
	module.exports = function getMeshMixin () {
	  return {
	    defaultAttributes: {
	      material: { }
	    },
	
	    mappings: {
	      color: 'material.color',
	      metalness: 'material.metalness',
	      opacity: 'material.opacity',
	      repeat: 'material.repeat',
	      roughness: 'material.roughness',
	      shader: 'material.shader',
	      side: 'material.side',
	      src: 'material.src',
	      translate: 'geometry.translate',
	      transparent: 'material.transparent'
	    },
	
	    transforms: {
	      src: function (value) {
	        // Selector.
	        if (value[0] === '#') { return value; }
	        // Inline url().
	        return 'url(' + value + ')';
	      }
	    }
	  };
	};
	
	},{}],67:[function(_dereq_,module,exports){
	_dereq_('./primitives/a-box');
	_dereq_('./primitives/a-camera');
	_dereq_('./primitives/a-circle');
	_dereq_('./primitives/a-collada-model');
	_dereq_('./primitives/a-cone');
	_dereq_('./primitives/a-cursor');
	_dereq_('./primitives/a-curvedimage');
	_dereq_('./primitives/a-cylinder');
	_dereq_('./primitives/a-image');
	_dereq_('./primitives/a-light');
	_dereq_('./primitives/a-model');
	_dereq_('./primitives/a-obj-model');
	_dereq_('./primitives/a-plane');
	_dereq_('./primitives/a-ring');
	_dereq_('./primitives/a-sky');
	_dereq_('./primitives/a-sphere');
	_dereq_('./primitives/a-torus');
	_dereq_('./primitives/a-video');
	_dereq_('./primitives/a-videosphere');
	
	},{"./primitives/a-box":68,"./primitives/a-camera":69,"./primitives/a-circle":70,"./primitives/a-collada-model":71,"./primitives/a-cone":72,"./primitives/a-cursor":73,"./primitives/a-curvedimage":74,"./primitives/a-cylinder":75,"./primitives/a-image":76,"./primitives/a-light":77,"./primitives/a-model":78,"./primitives/a-obj-model":79,"./primitives/a-plane":80,"./primitives/a-ring":81,"./primitives/a-sky":82,"./primitives/a-sphere":83,"./primitives/a-torus":84,"./primitives/a-video":85,"./primitives/a-videosphere":86}],68:[function(_dereq_,module,exports){
	var getMeshMixin = _dereq_('../getMeshMixin');
	var registerPrimitive = _dereq_('../registerPrimitive');
	var utils = _dereq_('../../../utils/');
	
	var boxDefinition = utils.extendDeep({}, getMeshMixin(), {
	  defaultAttributes: {
	    geometry: {
	      primitive: 'box'
	    }
	  },
	
	  mappings: {
	    depth: 'geometry.depth',
	    height: 'geometry.height',
	    translate: 'geometry.translate',
	    width: 'geometry.width'
	  }
	});
	
	registerPrimitive('a-box', boxDefinition);
	registerPrimitive('a-cube', utils.extendDeep({
	  deprecated: '<a-cube> is deprecated. Use <a-box> instead.'
	}, boxDefinition));
	
	},{"../../../utils/":102,"../getMeshMixin":66,"../registerPrimitive":87}],69:[function(_dereq_,module,exports){
	var registerPrimitive = _dereq_('../registerPrimitive');
	
	registerPrimitive('a-camera', {
	  defaultAttributes: {
	    camera: {},
	    'look-controls': {},
	    'wasd-controls': {}
	  },
	
	  mappings: {
	    active: 'camera.active',
	    far: 'camera.far',
	    fov: 'camera.fov',
	    'look-controls-enabled': 'look-controls.enabled',
	    near: 'camera.near',
	    'wasd-controls-enabled': 'wasd-controls.enabled'
	  },
	
	  deprecatedMappings: {
	    'cursor-color': 'a-camera[cursor-color] has been removed. Use a-cursor[color] instead.',
	    'cursor-maxdistance': 'a-camera[cursor-maxdistance] has been removed. Use a-cursor[max-distance] instead.',
	    'cursor-offset': 'a-camera[cursor-offset] has been removed. Use a-cursor[position] instead.',
	    'cursor-opacity': 'a-camera[cursor-offset] has been removed. Use a-cursor[opacity] instead.',
	    'cursor-scale': 'a-camera[cursor-scale] has been removed. Use a-cursor[scale] instead.',
	    'cursor-visible': 'a-camera[cursor-visible] has been removed. Use a-cursor[visible] instead.'
	  }
	});
	
	},{"../registerPrimitive":87}],70:[function(_dereq_,module,exports){
	var getMeshMixin = _dereq_('../getMeshMixin');
	var registerPrimitive = _dereq_('../registerPrimitive');
	var utils = _dereq_('../../../utils/');
	
	registerPrimitive('a-circle', utils.extendDeep({}, getMeshMixin(), {
	  defaultAttributes: {
	    geometry: {
	      primitive: 'circle'
	    }
	  },
	
	  mappings: {
	    'radius': 'geometry.radius',
	    'segments': 'geometry.segments',
	    'theta-length': 'geometry.theta-length',
	    'theta-start': 'geometry.theta-start'
	  }
	}));
	
	},{"../../../utils/":102,"../getMeshMixin":66,"../registerPrimitive":87}],71:[function(_dereq_,module,exports){
	var getMeshMixin = _dereq_('../getMeshMixin');
	var registerPrimitive = _dereq_('../registerPrimitive');
	var utils = _dereq_('../../../utils/');
	
	registerPrimitive('a-collada-model', utils.extendDeep({}, getMeshMixin(), {
	  mappings: {
	    src: 'collada-model'
	  }
	}));
	
	},{"../../../utils/":102,"../getMeshMixin":66,"../registerPrimitive":87}],72:[function(_dereq_,module,exports){
	var getMeshMixin = _dereq_('../getMeshMixin');
	var registerPrimitive = _dereq_('../registerPrimitive');
	var utils = _dereq_('../../../utils/');
	
	registerPrimitive('a-cone', utils.extendDeep({}, getMeshMixin(), {
	  defaultAttributes: {
	    geometry: {
	      primitive: 'cone'
	    }
	  },
	
	  mappings: {
	    height: 'geometry.height',
	    'open-ended': 'geometry.openEnded',
	    'radius-bottom': 'geometry.radiusBottom',
	    'radius-top': 'geometry.radiusTop',
	    'segments-height': 'geometry.segmentsHeight',
	    'segments-radial': 'geometry.segmentsRadial',
	    'theta-length': 'geometry.thetaLength',
	    'theta-start': 'geometry.thetaStart',
	    translate: 'geometry.translate'
	  }
	}));
	
	},{"../../../utils/":102,"../getMeshMixin":66,"../registerPrimitive":87}],73:[function(_dereq_,module,exports){
	var getMeshMixin = _dereq_('../getMeshMixin');
	var registerPrimitive = _dereq_('../registerPrimitive');
	var utils = _dereq_('../../../utils/');
	
	registerPrimitive('a-cursor', utils.extendDeep({}, getMeshMixin(), {
	  defaultAttributes: {
	    cursor: {
	      maxDistance: 1000
	    },
	    geometry: {
	      primitive: 'ring',
	      radiusOuter: 0.016,
	      radiusInner: 0.01,
	      segmentsTheta: 64
	    },
	    material: {
	      shader: 'flat',
	      opacity: 0.8
	    },
	    position: {
	      x: 0,
	      y: 0,
	      z: -1
	    }
	  },
	
	  mappings: {
	    fuse: 'cursor.fuse',
	    'max-distance': 'cursor.maxDistance',
	    timeout: 'cursor.timeout'
	  }
	}));
	
	},{"../../../utils/":102,"../getMeshMixin":66,"../registerPrimitive":87}],74:[function(_dereq_,module,exports){
	var getMeshMixin = _dereq_('../getMeshMixin');
	var registerPrimitive = _dereq_('../registerPrimitive');
	var utils = _dereq_('../../../utils/');
	
	registerPrimitive('a-curvedimage', utils.extendDeep({}, getMeshMixin(), {
	  defaultAttributes: {
	    geometry: {
	      height: 1,
	      primitive: 'cylinder',
	      radius: 2,
	      segmentsRadial: 48,
	      thetaLength: 270,
	      openEnded: true,
	      thetaStart: 0
	    },
	    material: {
	      color: '#FFF',
	      shader: 'flat',
	      side: 'double',
	      transparent: true,
	      repeat: '-1 1'
	    }
	  },
	
	  mappings: {
	    height: 'geometry.height',
	    'open-ended': 'geometry.openEnded',
	    radius: 'geometry.radius',
	    segments: 'geometry.segmentsRadial',
	    start: 'geometry.thetaStart',
	    'theta-length': 'geometry.thetaLength',
	    'theta-start': 'geometry.thetaStart',
	    translate: 'geometry.translate',
	    'width': 'geometry.thetaLength'
	  }
	}));
	
	},{"../../../utils/":102,"../getMeshMixin":66,"../registerPrimitive":87}],75:[function(_dereq_,module,exports){
	var getMeshMixin = _dereq_('../getMeshMixin');
	var registerPrimitive = _dereq_('../registerPrimitive');
	var utils = _dereq_('../../../utils/');
	
	registerPrimitive('a-cylinder', utils.extendDeep({}, getMeshMixin(), {
	  defaultAttributes: {
	    geometry: {
	      primitive: 'cylinder'
	    }
	  },
	
	  mappings: {
	    height: 'geometry.height',
	    'open-ended': 'geometry.openEnded',
	    radius: 'geometry.radius',
	    'radius-bottom': 'geometry.radiusBottom',
	    'radius-top': 'geometry.radiusTop',
	    'segments-radial': 'geometry.segmentsRadial',
	    'theta-length': 'geometry.thetaLength',
	    'theta-start': 'geometry.thetaStart',
	    translate: 'geometry.translate'
	  }
	}));
	
	},{"../../../utils/":102,"../getMeshMixin":66,"../registerPrimitive":87}],76:[function(_dereq_,module,exports){
	var getMeshMixin = _dereq_('../getMeshMixin');
	var registerPrimitive = _dereq_('../registerPrimitive');
	var utils = _dereq_('../../../utils/');
	
	registerPrimitive('a-image', utils.extendDeep({}, getMeshMixin(), {
	  defaultAttributes: {
	    geometry: {
	      primitive: 'plane'
	    },
	    material: {
	      color: '#FFF',
	      shader: 'flat',
	      side: 'double',
	      transparent: true
	    }
	  },
	
	  mappings: {
	    height: 'geometry.height',
	    translate: 'geometry.translate',
	    width: 'geometry.width'
	  }
	}));
	
	},{"../../../utils/":102,"../getMeshMixin":66,"../registerPrimitive":87}],77:[function(_dereq_,module,exports){
	var registerPrimitive = _dereq_('../registerPrimitive');
	
	registerPrimitive('a-light', {
	  defaultAttributes: {
	    light: {}
	  },
	
	  mappings: {
	    angle: 'light.angle',
	    color: 'light.color',
	    'ground-color': 'light.groundColor',
	    decay: 'light.decay',
	    distance: 'light.distance',
	    exponent: 'light.exponent',
	    intensity: 'light.intensity',
	    type: 'light.type'
	  }
	});
	
	},{"../registerPrimitive":87}],78:[function(_dereq_,module,exports){
	var getMeshMixin = _dereq_('../getMeshMixin');
	var registerPrimitive = _dereq_('../registerPrimitive');
	var utils = _dereq_('../../../utils/');
	
	registerPrimitive('a-model', utils.extend({}, getMeshMixin(), {
	  deprecated: '<a-model> is deprecated. Use <a-obj-model> or <a-collada-model> instead.',
	
	  defaultAttributes: {
	    loader: {
	      format: 'collada'
	    },
	    material: {
	      color: '#FFF'
	    }
	  },
	
	  mappings: {
	    src: 'loader.src',
	    format: 'loader.format'
	  }
	}));
	
	},{"../../../utils/":102,"../getMeshMixin":66,"../registerPrimitive":87}],79:[function(_dereq_,module,exports){
	var meshMixin = _dereq_('../getMeshMixin')();
	var registerPrimitive = _dereq_('../registerPrimitive');
	var utils = _dereq_('../../../utils/');
	
	registerPrimitive('a-obj-model', utils.extendDeep({}, meshMixin, {
	  mappings: {
	    src: 'obj-model.obj',
	    mtl: 'obj-model.mtl'
	  },
	
	  transforms: {
	    mtl: meshMixin.transforms.src
	  }
	}));
	
	},{"../../../utils/":102,"../getMeshMixin":66,"../registerPrimitive":87}],80:[function(_dereq_,module,exports){
	var getMeshMixin = _dereq_('../getMeshMixin');
	var registerPrimitive = _dereq_('../registerPrimitive');
	var utils = _dereq_('../../../utils/');
	
	registerPrimitive('a-plane', utils.extendDeep({}, getMeshMixin(), {
	  defaultAttributes: {
	    geometry: {
	      primitive: 'plane'
	    }
	  },
	
	  mappings: {
	    height: 'geometry.height',
	    translate: 'geometry.translate',
	    width: 'geometry.width'
	  }
	}));
	
	},{"../../../utils/":102,"../getMeshMixin":66,"../registerPrimitive":87}],81:[function(_dereq_,module,exports){
	var getMeshMixin = _dereq_('../getMeshMixin');
	var registerPrimitive = _dereq_('../registerPrimitive');
	var utils = _dereq_('../../../utils/');
	
	registerPrimitive('a-ring', utils.extendDeep({}, getMeshMixin(), {
	  defaultAttributes: {
	    geometry: {
	      primitive: 'ring'
	    }
	  },
	
	  mappings: {
	    'radius-inner': 'geometry.radiusInner',
	    'radius-outer': 'geometry.radiusOuter',
	    'segments-phi': 'geometry.segments-phi',
	    'segments-theta': 'geometry.segments-theta',
	    'theta-length': 'geometry.theta-length',
	    'theta-start': 'geometry.theta-start'
	  }
	}));
	
	},{"../../../utils/":102,"../getMeshMixin":66,"../registerPrimitive":87}],82:[function(_dereq_,module,exports){
	var getMeshMixin = _dereq_('../getMeshMixin');
	var registerPrimitive = _dereq_('../registerPrimitive');
	var utils = _dereq_('../../../utils/');
	
	registerPrimitive('a-sky', utils.extendDeep({}, getMeshMixin(), {
	  defaultAttributes: {
	    geometry: {
	      primitive: 'sphere',
	      radius: 5000,
	      segmentsWidth: 64,
	      segmentsHeight: 64
	    },
	    material: {
	      color: '#FFF',
	      shader: 'flat'
	    },
	    scale: '-1 1 1'
	  },
	
	  mappings: {
	    radius: 'geometry.radius',
	    'segments-width': 'geometry.segmentsWidth',
	    'segments-height': 'geometry.segmentsHeight'
	  }
	}));
	
	},{"../../../utils/":102,"../getMeshMixin":66,"../registerPrimitive":87}],83:[function(_dereq_,module,exports){
	var getMeshMixin = _dereq_('../getMeshMixin');
	var registerPrimitive = _dereq_('../registerPrimitive');
	var utils = _dereq_('../../../utils/');
	
	registerPrimitive('a-sphere', utils.extendDeep({}, getMeshMixin(), {
	  defaultAttributes: {
	    geometry: {
	      primitive: 'sphere'
	    }
	  },
	
	  mappings: {
	    radius: 'geometry.radius',
	    'segments-height': 'geometry.segmentsHeight',
	    'segments-width': 'geometry.segmentsWidth',
	    translate: 'geometry.translate'
	  }
	}));
	
	},{"../../../utils/":102,"../getMeshMixin":66,"../registerPrimitive":87}],84:[function(_dereq_,module,exports){
	var getMeshMixin = _dereq_('../getMeshMixin');
	var registerPrimitive = _dereq_('../registerPrimitive');
	var utils = _dereq_('../../../utils/');
	
	registerPrimitive('a-torus', utils.extendDeep({}, getMeshMixin(), {
	  defaultAttributes: {
	    geometry: {
	      primitive: 'torus'
	    }
	  },
	
	  mappings: {
	    'arc': 'geometry.arc',
	    'radius': 'geometry.radius',
	    'radius-tubular': 'geometry.radiusTubular',
	    'segments-radial': 'geometry.segmentsRadial',
	    'segments-tubular': 'geometry.segmentsTubular'
	  }
	}));
	
	},{"../../../utils/":102,"../getMeshMixin":66,"../registerPrimitive":87}],85:[function(_dereq_,module,exports){
	var getMeshMixin = _dereq_('../getMeshMixin');
	var registerPrimitive = _dereq_('../registerPrimitive');
	var utils = _dereq_('../../../utils/');
	
	registerPrimitive('a-video', utils.extendDeep({}, getMeshMixin(), {
	  defaultAttributes: {
	    geometry: {
	      primitive: 'plane'
	    },
	    material: {
	      color: '#FFF',
	      shader: 'flat',
	      side: 'double',
	      transparent: true
	    }
	  },
	
	  mappings: {
	    height: 'geometry.height',
	    translate: 'geometry.translate',
	    width: 'geometry.width'
	  }
	}));
	
	},{"../../../utils/":102,"../getMeshMixin":66,"../registerPrimitive":87}],86:[function(_dereq_,module,exports){
	var getMeshMixin = _dereq_('../getMeshMixin');
	var registerPrimitive = _dereq_('../registerPrimitive');
	var utils = _dereq_('../../../utils/');
	
	registerPrimitive('a-videosphere', utils.extendDeep({}, getMeshMixin(), {
	  defaultAttributes: {
	    geometry: {
	      primitive: 'sphere',
	      radius: 5000,
	      segmentsWidth: 64,
	      segmentsHeight: 64
	    },
	    material: {
	      color: '#FFF',
	      shader: 'flat'
	    },
	    scale: '-1 1 1'
	  },
	
	  mappings: {
	    radius: 'geometry.radius',
	    'segments-height': 'geometry.segmentsHeight',
	    'segments-width': 'geometry.segmentsWidth'
	  }
	}));
	
	},{"../../../utils/":102,"../getMeshMixin":66,"../registerPrimitive":87}],87:[function(_dereq_,module,exports){
	var AEntity = _dereq_('../../core/a-entity');
	var components = _dereq_('../../core/component').components;
	var registerElement = _dereq_('../../core/a-register-element').registerElement;
	var utils = _dereq_('../../utils/');
	
	var debug = utils.debug;
	var log = debug('extras:primitives');
	
	module.exports = function registerPrimitive (name, definition) {
	  name = name.toLowerCase();
	  log('Registering <%s>', name);
	
	  return registerElement(name, {
	    prototype: Object.create(AEntity.prototype, {
	      defaultAttributes: {
	        value: definition.defaultAttributes || {}
	      },
	
	      deprecated: {
	        value: definition.deprecated || null
	      },
	
	      deprecatedMappings: {
	        value: definition.deprecatedMappings || {}
	      },
	
	      mappings: {
	        value: definition.mappings || {}
	      },
	
	      transforms: {
	        value: definition.transforms || {}
	      },
	
	      createdCallback: {
	        value: function () {
	          this.componentData = {};
	          if (definition.deprecated) {
	            console.warn(definition.deprecated);
	          }
	        }
	      },
	
	      attachedCallback: {
	        value: function () {
	          var self = this;
	          var attributes = this.attributes;
	
	          // Apply default components.
	          this.componentData = cloneObject(this.defaultAttributes);
	          Object.keys(this.componentData).forEach(function (componentName) {
	            if (!self.hasAttribute(componentName)) {
	              self.setAttribute(componentName, self.componentData[componentName]);
	            }
	          });
	
	          // Apply initial attributes.
	          Object.keys(attributes).forEach(function (attributeName) {
	            var attr = attributes[attributeName];
	            self.syncAttributeToComponent(attr.name, attr.value);
	          });
	        }
	      },
	
	      /**
	       * Sync to attribute to component property whenever mapped attribute changes.
	       */
	      attributeChangedCallback: {
	        value: function (attr, oldVal, newVal) {
	          if (!this.mappings[attr]) {
	            AEntity.prototype.attributeChangedCallback.call(this, attr, oldVal, newVal);
	            return;
	          }
	          this.syncAttributeToComponent(attr, newVal);
	        }
	      },
	
	      /**
	       * If attribute is mapped to a component property, set the component property using
	       * the attribute value.
	       */
	      syncAttributeToComponent: {
	        value: function (attr, value) {
	          var componentName;
	          var split;
	          var propertyName;
	
	          if (attr in this.deprecatedMappings) {
	            console.warn(this.deprecatedMappings[attr]);
	          }
	
	          if (!attr || !this.mappings[attr]) { return; }
	
	          // Differentiate between single-property and multi-property component.
	          componentName = this.mappings[attr];
	          if (componentName.indexOf('.') !== -1) {
	            split = this.mappings[attr].split('.');
	            componentName = split[0];
	            propertyName = split[1];
	          }
	
	          if (!components[componentName]) { return; }
	
	          // Run transform.
	          value = this.getTransformedValue(attr, value);
	
	          // Initialize internal component data if necessary.
	          if (!this.componentData[componentName]) {
	            this.componentData[componentName] = this.defaultAttributes[componentName] || {};
	          }
	
	          // Update internal component data.
	          if (propertyName) {
	            this.componentData[componentName][propertyName] = value;
	          } else {
	            this.componentData[componentName] = value;
	          }
	
	          // Put component data.
	          this.setAttribute(componentName, this.componentData[componentName]);
	        }
	      },
	
	      /**
	       * Calls defined transform function on value if any.
	       */
	      getTransformedValue: {
	        value: function (attr, value) {
	          if (!this.transforms || !this.transforms[attr]) { return value; }
	          return this.transforms[attr].bind(this)(value);
	        }
	      }
	    })
	  });
	};
	
	/**
	 * Clone an object, including inner objects one-level deep.
	 * Used for copying defaultAttributes to componentData so primitives of the same type don't
	 * affect each others' defaultAttributes object.
	 */
	function cloneObject (obj) {
	  var clone = {};
	  Object.keys(obj).forEach(function (key) {
	    var value = obj[key];
	    if (typeof value === 'object') {
	      clone[key] = utils.extend({}, value);
	    } else {
	      clone[key] = value;
	    }
	  });
	  return clone;
	}
	
	},{"../../core/a-entity":52,"../../core/a-register-element":55,"../../core/component":56,"../../utils/":102}],88:[function(_dereq_,module,exports){
	// Polyfill `Promise`.
	window.Promise = window.Promise || _dereq_('promise-polyfill');
	
	_dereq_('present'); // Polyfill `performance.now()`.
	// CSS.
	_dereq_('./style/aframe.css');
	_dereq_('./style/rStats.css');
	
	// Required before `AEntity` so that all components are registered.
	var AScene = _dereq_('./core/scene/a-scene');
	var components = _dereq_('./core/component').components;
	var registerComponent = _dereq_('./core/component').registerComponent;
	var registerPrimitive = _dereq_('./extras/primitives/registerPrimitive');
	var registerShader = _dereq_('./core/shader').registerShader;
	var registerSystem = _dereq_('./core/system').registerSystem;
	var shaders = _dereq_('./core/shader').shaders;
	var systems = _dereq_('./core/system').systems;
	// Exports THREE to window so three.js can be used without alteration.
	var THREE = window.THREE = _dereq_('./lib/three');
	var TWEEN = window.TWEEN = _dereq_('tween.js');
	
	var pkg = _dereq_('../package');
	var utils = _dereq_('./utils/');
	
	_dereq_('./systems/index'); // Register core systems.
	_dereq_('./components/index'); // Register core components.
	_dereq_('./shaders/index'); // Register core shaders.
	var ANode = _dereq_('./core/a-node');
	var AEntity = _dereq_('./core/a-entity'); // Depends on ANode and core components.
	
	// Webvr polyfill configuration.
	window.hasNonPolyfillWebVRSupport = !!navigator.getVRDevices;
	window.WebVRConfig = {
	  TOUCH_PANNER_DISABLED: true,
	  MOUSE_KEYBOARD_CONTROLS_DISABLED: true
	};
	_dereq_('webvr-polyfill');
	
	_dereq_('./core/a-animation');
	_dereq_('./core/a-assets');
	_dereq_('./core/a-cubemap');
	_dereq_('./core/a-mixin');
	
	// Extras.
	_dereq_('./extras/declarative-events/');
	_dereq_('./extras/primitives/');
	
	console.log('A-Frame Version:', pkg.version);
	console.log('three Version:', pkg.dependencies['three']);
	console.log('WebVR Polyfill Version:', pkg.dependencies['webvr-polyfill']);
	
	module.exports = window.AFRAME = {
	  AEntity: AEntity,
	  ANode: ANode,
	  AScene: AScene,
	  components: components,
	  registerComponent: registerComponent,
	  registerShader: registerShader,
	  registerSystem: registerSystem,
	  registerPrimitive: registerPrimitive,
	  shaders: shaders,
	  systems: systems,
	  THREE: THREE,
	  TWEEN: TWEEN,
	  utils: utils,
	  version: pkg.version
	};
	
	},{"../package":24,"./components/index":29,"./core/a-animation":49,"./core/a-assets":50,"./core/a-cubemap":51,"./core/a-entity":52,"./core/a-mixin":53,"./core/a-node":54,"./core/component":56,"./core/scene/a-scene":58,"./core/shader":63,"./core/system":64,"./extras/declarative-events/":65,"./extras/primitives/":67,"./extras/primitives/registerPrimitive":87,"./lib/three":90,"./shaders/index":92,"./style/aframe.css":94,"./style/rStats.css":95,"./systems/index":97,"./utils/":102,"present":10,"promise-polyfill":11,"tween.js":22,"webvr-polyfill":23}],89:[function(_dereq_,module,exports){
	window.aframeStats = function (scene) {
	  var _rS = null;
	  var _scene = scene;
	  var _values = {
	    te: {
	      caption: 'Entities'
	    },
	    lt: {
	      caption: 'Load Time'
	    }
	  };
	  var _groups = [ {
	    caption: 'A-Frame',
	    values: [ 'te', 'lt' ]
	  } ];
	
	  function _update () {
	    _rS('te').set(_scene.querySelectorAll('a-entity').length);
	    _rS('lt').set(window.performance.getEntriesByName('render-started')[0].startTime.toFixed(0));
	  }
	
	  function _start () {}
	
	  function _end () {}
	
	  function _attach (r) {
	    _rS = r;
	  }
	
	  return {
	    update: _update,
	    start: _start,
	    end: _end,
	    attach: _attach,
	    values: _values,
	    groups: _groups,
	    fractions: []
	  };
	};
	
	if (typeof module === 'object') {
	  module.exports = {
	    aframeStats: window.aframeStats
	  };
	}
	
	},{}],90:[function(_dereq_,module,exports){
	(function (global){
	var THREE = global.THREE = _dereq_('three');
	
	// Allow cross-origin images to be loaded.
	
	// This should not be on `THREE.Loader` nor `THREE.ImageUtils`.
	// Must be on `THREE.TextureLoader`.
	if (THREE.TextureLoader) {
	  THREE.TextureLoader.prototype.crossOrigin = '';
	}
	
	// This is for images loaded from the model loaders.
	if (THREE.ImageLoader) {
	  THREE.ImageLoader.prototype.crossOrigin = '';
	}
	
	// In-memory caching for XHRs (for images, audio files, textures, etc.).
	if (THREE.Cache) {
	  THREE.Cache.enabled = true;
	}
	
	// TODO: Eventually include these only if they are needed by a component.
	_dereq_('../../node_modules/three/examples/js/loaders/OBJLoader');  // THREE.OBJLoader
	_dereq_('../../node_modules/three/examples/js/loaders/MTLLoader');  // THREE.MTLLoader
	_dereq_('../../node_modules/three/examples/js/loaders/ColladaLoader');  // THREE.ColladaLoader
	_dereq_('../../node_modules/three/examples/js/controls/VRControls');  // THREE.VRControls
	_dereq_('../../node_modules/three/examples/js/effects/VREffect');  // THREE.VREffect
	
	module.exports = THREE;
	
	}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
	
	},{"../../node_modules/three/examples/js/controls/VRControls":16,"../../node_modules/three/examples/js/effects/VREffect":17,"../../node_modules/three/examples/js/loaders/ColladaLoader":18,"../../node_modules/three/examples/js/loaders/MTLLoader":19,"../../node_modules/three/examples/js/loaders/OBJLoader":20,"three":21}],91:[function(_dereq_,module,exports){
	var registerShader = _dereq_('../core/shader').registerShader;
	var srcLoader = _dereq_('../utils/src-loader');
	var THREE = _dereq_('../lib/three');
	var utils = _dereq_('../utils/texture');
	
	/**
	 * Flat shader using THREE.MeshBasicMaterial.
	 */
	module.exports.Component = registerShader('flat', {
	  schema: {
	    color: { type: 'color' },
	    fog: { default: true },
	    height: { default: 256 },
	    repeat: { default: '' },
	    src: { default: '' },
	    width: { default: 512 }
	  },
	
	  /**
	   * Initializes the shader.
	   * Adds a reference from the scene to this entity as the camera.
	   */
	  init: function (data) {
	    this.textureSrc = null;
	    this.material = new THREE.MeshBasicMaterial(getMaterialData(data));
	    this.updateTexture(data);
	    return this.material;
	  },
	
	  update: function (data) {
	    this.updateMaterial(data);
	    this.updateTexture(data);
	    return this.material;
	  },
	
	  /**
	   * Update or create material.
	   *
	   * @param {object|null} oldData
	   */
	  updateTexture: function (data) {
	    var src = data.src;
	    var material = this.material;
	    if (src) {
	      if (src === this.textureSrc) { return; }
	      // Texture added or changed.
	      this.textureSrc = src;
	      srcLoader.validateSrc(src,
	        utils.loadImage.bind(this, material, data),
	        utils.loadVideo.bind(this, material, data)
	      );
	    } else {
	      // Texture removed.
	      utils.updateMaterial(material, null);
	    }
	  },
	
	  /**
	   * Updating existing material.
	   *
	   * @param {object} data - Material component data.
	   */
	  updateMaterial: function (data) {
	    var material = this.material;
	    data = getMaterialData(data);
	    Object.keys(data).forEach(function (key) {
	      material[key] = data[key];
	    });
	  }
	});
	
	/**
	 * Builds and normalize material data, normalizing stuff along the way.
	 *
	 * @param {object} data - Material data.
	 * @returns {object} data - Processed material data.
	 */
	function getMaterialData (data) {
	  var materialData = {
	    fog: data.fog,
	    color: new THREE.Color(data.color)
	  };
	  return materialData;
	}
	
	},{"../core/shader":63,"../lib/three":90,"../utils/src-loader":103,"../utils/texture":105}],92:[function(_dereq_,module,exports){
	_dereq_('./flat');
	_dereq_('./standard');
	
	},{"./flat":91,"./standard":93}],93:[function(_dereq_,module,exports){
	var registerShader = _dereq_('../core/shader').registerShader;
	var srcLoader = _dereq_('../utils/src-loader');
	var THREE = _dereq_('../lib/three');
	var utils = _dereq_('../utils/');
	
	var CubeLoader = new THREE.CubeTextureLoader();
	var texturePromises = {};
	
	/**
	 * Standard (physically-based) shader using THREE.MeshStandardMaterial.
	 */
	module.exports.Component = registerShader('standard', {
	  schema: {
	    color: { type: 'color' },
	    envMap: { default: '' },
	    fog: { default: true },
	    height: { default: 256 },
	    metalness: { default: 0.0, min: 0.0, max: 1.0 },
	    repeat: { default: '' },
	    src: { default: '' },
	    roughness: { default: 0.5, min: 0.0, max: 1.0 },
	    width: { default: 512 }
	  },
	  /**
	   * Initializes the shader.
	   * Adds a reference from the scene to this entity as the camera.
	   */
	  init: function (data) {
	    this.material = new THREE.MeshStandardMaterial(getMaterialData(data));
	    this.updateTexture(data);
	    this.updateEnvMap(data);
	    return this.material;
	  },
	
	  update: function (data) {
	    this.updateMaterial(data);
	    this.updateTexture(data);
	    this.updateEnvMap(data);
	    return this.material;
	  },
	
	  /**
	   * Update or create material.
	   *
	   * @param {object|null} oldData
	   */
	  updateTexture: function (data) {
	    var src = data.src;
	    var material = this.material;
	    if (src) {
	      if (src === this.textureSrc) { return; }
	      // Texture added or changed.
	      this.textureSrc = src;
	      srcLoader.validateSrc(src,
	        utils.texture.loadImage.bind(this, material, data),
	        utils.texture.loadVideo.bind(this, material, data)
	      );
	    } else {
	      // Texture removed.
	      utils.texture.updateMaterial(material, null);
	    }
	  },
	
	  /**
	   * Updating existing material.
	   *
	   * @param {object} data - Material component data.
	   * @returns {object} Material.
	   */
	  updateMaterial: function (data) {
	    var material = this.material;
	    data = getMaterialData(data);
	    Object.keys(data).forEach(function (key) {
	      material[key] = data[key];
	    });
	  },
	
	  /**
	   * Handle environment cubemap. Textures are cached in texturePromises.
	   */
	  updateEnvMap: function (data) {
	    var self = this;
	    var material = this.material;
	    var envMap = data.envMap;
	
	    // No envMap defined or already loading.
	    if (!envMap || this.isLoadingEnvMap) {
	      material.envMap = null;
	      material.needsUpdate = true;
	      return;
	    }
	    this.isLoadingEnvMap = true;
	
	    // Another material is already loading this texture. Wait on promise.
	    if (texturePromises[envMap]) {
	      texturePromises[envMap].then(function (cube) {
	        self.isLoadingEnvMap = false;
	        material.envMap = cube;
	        material.needsUpdate = true;
	      });
	      return;
	    }
	
	    // Material is first to load this texture. Load and resolve texture.
	    texturePromises[envMap] = new Promise(function (resolve) {
	      srcLoader.validateCubemapSrc(envMap, function loadEnvMap (urls) {
	        CubeLoader.load(urls, function (cube) {
	          // Texture loaded.
	          self.isLoadingEnvMap = false;
	          material.envMap = cube;
	          resolve(cube);
	        });
	      });
	    });
	  }
	});
	
	/**
	 * Builds and normalize material data, normalizing stuff along the way.
	 *
	 * @param {object} data - Material data.
	 * @returns {object} data - Processed material data.
	 */
	function getMaterialData (data) {
	  var materialData = {
	    color: new THREE.Color(data.color),
	    metalness: data.metalness,
	    roughness: data.roughness
	  };
	  return materialData;
	}
	
	},{"../core/shader":63,"../lib/three":90,"../utils/":102,"../utils/src-loader":103}],94:[function(_dereq_,module,exports){
	var css = "html{bottom:0;left:0;position:fixed;right:0;top:0}body{height:100%;margin:0;overflow:hidden;padding:0;width:100%}.a-hidden{display:none!important}.a-canvas{height:100%;left:0;position:absolute;top:0;width:100%}a-assets,a-scene img,a-scene video{display:none}.a-enter-vr{align-items:flex-end;-webkit-align-items:flex-end;bottom:5px;display:flex;display:-webkit-flex;font-family:sans-serif,monospace;font-size:13px;font-weight:200;line-height:16px;height:72px;position:fixed;right:5px}.a-enter-vr-button{background:url(data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20viewBox%3D%220%200%20245.82%20141.73%22%3E%3Cdefs%3E%3Cstyle%3E.a%7Bfill%3A%23fff%3Bfill-rule%3Aevenodd%3B%7D%3C%2Fstyle%3E%3C%2Fdefs%3E%3Ctitle%3Emask%3C%2Ftitle%3E%3Cpath%20class%3D%22a%22%20d%3D%22M175.56%2C111.37c-22.52%2C0-40.77-18.84-40.77-42.07S153%2C27.24%2C175.56%2C27.24s40.77%2C18.84%2C40.77%2C42.07S198.08%2C111.37%2C175.56%2C111.37ZM26.84%2C69.31c0-23.23%2C18.25-42.07%2C40.77-42.07s40.77%2C18.84%2C40.77%2C42.07-18.26%2C42.07-40.77%2C42.07S26.84%2C92.54%2C26.84%2C69.31ZM27.27%2C0C11.54%2C0%2C0%2C12.34%2C0%2C28.58V110.9c0%2C16.24%2C11.54%2C30.83%2C27.27%2C30.83H99.57c2.17%2C0%2C4.19-1.83%2C5.4-3.7L116.47%2C118a8%2C8%2C0%2C0%2C1%2C12.52-.18l11.51%2C20.34c1.2%2C1.86%2C3.22%2C3.61%2C5.39%2C3.61h72.29c15.74%2C0%2C27.63-14.6%2C27.63-30.83V28.58C245.82%2C12.34%2C233.93%2C0%2C218.19%2C0H27.27Z%22%2F%3E%3C%2Fsvg%3E) 50% 50%/70% 70% no-repeat rgba(0,0,0,.35);border:0;bottom:0;color:#FFF;cursor:pointer;height:50px;position:absolute;right:0;transition:background-color .05s ease;-webkit-transition:background-color .05s ease;width:60px;z-index:999999}.a-enter-vr-button:active,.a-enter-vr-button:hover{background-color:#666}[data-a-enter-vr-no-webvr] .a-enter-vr-button{border-color:#666;opacity:.65}[data-a-enter-vr-no-webvr] .a-enter-vr-button:active,[data-a-enter-vr-no-webvr] .a-enter-vr-button:hover{background-color:rgba(0,0,0,.35);cursor:not-allowed}.a-enter-vr-modal{background-color:#666;border-radius:0;color:#FFF;height:32px;margin-right:70px;padding:9px;width:280px;position:relative;display:none}.a-enter-vr-modal:after{border-bottom:10px solid transparent;border-left:10px solid #666;border-top:10px solid transparent;display:inline-block;content:'';position:absolute;right:-5px;top:5px;width:0;height:0}.a-enter-vr-modal p{margin:0;display:inline}.a-enter-vr-modal p:after{content:' '}.a-enter-vr-modal a{color:#FFF;display:inline}[data-a-enter-vr-no-headset].a-enter-vr:hover .a-enter-vr-modal,[data-a-enter-vr-no-webvr].a-enter-vr:hover .a-enter-vr-modal{display:block}.a-orientation-modal{position:absolute;width:100%;height:100%;top:0;left:0;background:url(data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20xmlns%3Axlink%3D%22http%3A//www.w3.org/1999/xlink%22%20version%3D%221.1%22%20x%3D%220px%22%20y%3D%220px%22%20viewBox%3D%220%200%2090%2090%22%20enable-background%3D%22new%200%200%2090%2090%22%20xml%3Aspace%3D%22preserve%22%3E%3Cpolygon%20points%3D%220%2C0%200%2C0%200%2C0%20%22%3E%3C/polygon%3E%3Cg%3E%3Cpath%20d%3D%22M71.545%2C48.145h-31.98V20.743c0-2.627-2.138-4.765-4.765-4.765H18.456c-2.628%2C0-4.767%2C2.138-4.767%2C4.765v42.789%20%20%20c0%2C2.628%2C2.138%2C4.766%2C4.767%2C4.766h5.535v0.959c0%2C2.628%2C2.138%2C4.765%2C4.766%2C4.765h42.788c2.628%2C0%2C4.766-2.137%2C4.766-4.765V52.914%20%20%20C76.311%2C50.284%2C74.173%2C48.145%2C71.545%2C48.145z%20M18.455%2C16.935h16.344c2.1%2C0%2C3.808%2C1.708%2C3.808%2C3.808v27.401H37.25V22.636%20%20%20c0-0.264-0.215-0.478-0.479-0.478H16.482c-0.264%2C0-0.479%2C0.214-0.479%2C0.478v36.585c0%2C0.264%2C0.215%2C0.478%2C0.479%2C0.478h7.507v7.644%20%20%20h-5.534c-2.101%2C0-3.81-1.709-3.81-3.81V20.743C14.645%2C18.643%2C16.354%2C16.935%2C18.455%2C16.935z%20M16.96%2C23.116h19.331v25.031h-7.535%20%20%20c-2.628%2C0-4.766%2C2.139-4.766%2C4.768v5.828h-7.03V23.116z%20M71.545%2C73.064H28.757c-2.101%2C0-3.81-1.708-3.81-3.808V52.914%20%20%20c0-2.102%2C1.709-3.812%2C3.81-3.812h42.788c2.1%2C0%2C3.809%2C1.71%2C3.809%2C3.812v16.343C75.354%2C71.356%2C73.645%2C73.064%2C71.545%2C73.064z%22%3E%3C/path%3E%3Cpath%20d%3D%22M28.919%2C58.424c-1.466%2C0-2.659%2C1.193-2.659%2C2.66c0%2C1.466%2C1.193%2C2.658%2C2.659%2C2.658c1.468%2C0%2C2.662-1.192%2C2.662-2.658%20%20%20C31.581%2C59.617%2C30.387%2C58.424%2C28.919%2C58.424z%20M28.919%2C62.786c-0.939%2C0-1.703-0.764-1.703-1.702c0-0.939%2C0.764-1.704%2C1.703-1.704%20%20%20c0.94%2C0%2C1.705%2C0.765%2C1.705%2C1.704C30.623%2C62.022%2C29.858%2C62.786%2C28.919%2C62.786z%22%3E%3C/path%3E%3Cpath%20d%3D%22M69.654%2C50.461H33.069c-0.264%2C0-0.479%2C0.215-0.479%2C0.479v20.288c0%2C0.264%2C0.215%2C0.478%2C0.479%2C0.478h36.585%20%20%20c0.263%2C0%2C0.477-0.214%2C0.477-0.478V50.939C70.131%2C50.676%2C69.917%2C50.461%2C69.654%2C50.461z%20M69.174%2C51.417V70.75H33.548V51.417H69.174z%22%3E%3C/path%3E%3Cpath%20d%3D%22M45.201%2C30.296c6.651%2C0%2C12.233%2C5.351%2C12.551%2C11.977l-3.033-2.638c-0.193-0.165-0.507-0.142-0.675%2C0.048%20%20%20c-0.174%2C0.198-0.153%2C0.501%2C0.045%2C0.676l3.883%2C3.375c0.09%2C0.075%2C0.198%2C0.115%2C0.312%2C0.115c0.141%2C0%2C0.273-0.061%2C0.362-0.166%20%20%20l3.371-3.877c0.173-0.2%2C0.151-0.502-0.047-0.675c-0.194-0.166-0.508-0.144-0.676%2C0.048l-2.592%2C2.979%20%20%20c-0.18-3.417-1.629-6.605-4.099-9.001c-2.538-2.461-5.877-3.817-9.404-3.817c-0.264%2C0-0.479%2C0.215-0.479%2C0.479%20%20%20C44.72%2C30.083%2C44.936%2C30.296%2C45.201%2C30.296z%22%3E%3C/path%3E%3C/g%3E%3C/svg%3E) center center/50% 50% no-repeat rgba(244,244,244,1)}.a-orientation-modal:after{display:block;content:\"Insert phone into Cardboard holder.\";color:#333;font-family:sans-serif,monospace;font-size:13px;text-align:center;position:absolute;width:100%;top:70%;transform:translateY(-70%)}.a-orientation-modal button{background:url(data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20xmlns%3Axlink%3D%22http%3A//www.w3.org/1999/xlink%22%20version%3D%221.1%22%20x%3D%220px%22%20y%3D%220px%22%20viewBox%3D%220%200%20100%20100%22%20enable-background%3D%22new%200%200%20100%20100%22%20xml%3Aspace%3D%22preserve%22%3E%3Cpath%20fill%3D%22%23000000%22%20d%3D%22M55.209%2C50l17.803-17.803c1.416-1.416%2C1.416-3.713%2C0-5.129c-1.416-1.417-3.713-1.417-5.129%2C0L50.08%2C44.872%20%20L32.278%2C27.069c-1.416-1.417-3.714-1.417-5.129%2C0c-1.417%2C1.416-1.417%2C3.713%2C0%2C5.129L44.951%2C50L27.149%2C67.803%20%20c-1.417%2C1.416-1.417%2C3.713%2C0%2C5.129c0.708%2C0.708%2C1.636%2C1.062%2C2.564%2C1.062c0.928%2C0%2C1.856-0.354%2C2.564-1.062L50.08%2C55.13l17.803%2C17.802%20%20c0.708%2C0.708%2C1.637%2C1.062%2C2.564%2C1.062s1.856-0.354%2C2.564-1.062c1.416-1.416%2C1.416-3.713%2C0-5.129L55.209%2C50z%22%3E%3C/path%3E%3C/svg%3E);width:50px;height:50px;border:none;text-indent:-9999px}@media (min-width:480px){.a-enter-vr{bottom:20px;right:20px}.a-enter-vr-modal{width:400px}}"; (_dereq_("browserify-css").createStyle(css, { "href": "src/style/aframe.css"})); module.exports = css;
	},{"browserify-css":1}],95:[function(_dereq_,module,exports){
	var css = ".rs-base{background-color:#EF2D5E;border-radius:0;font:10px monospace;left:5px;line-height:1em;opacity:.75;overflow:hidden;padding:10px;position:fixed;top:5px;width:300px;z-index:10000}.rs-base div.hidden{display:none}.rs-base h1{color:#fff;cursor:pointer;font-size:1.4em;font-weight:300;margin:0 0 5px;padding:0}.rs-group{display:-webkit-box;display:-webkit-flex;display:flex;-webkit-flex-direction:column-reverse;flex-direction:column-reverse;margin-bottom:5px}.rs-group:last-child{margin-bottom:0}.rs-counter-base{align-items:center;display:-webkit-box;display:-webkit-flex;display:flex;height:10px;-webkit-justify-content:space-between;justify-content:space-between;margin:2px 0}.rs-counter-id{font-weight:300;-webkit-box-ordinal-group:0;-webkit-order:0;order:0;width:50px}.rs-counter-value{font-weight:300;-webkit-box-ordinal-group:1;-webkit-order:1;order:1;text-align:right;width:35px}.rs-canvas{-webkit-box-ordinal-group:2;-webkit-order:2;order:2}@media (min-width:480px){.rs-base{left:20px;top:20px}}"; (_dereq_("browserify-css").createStyle(css, { "href": "src/style/rStats.css"})); module.exports = css;
	},{"browserify-css":1}],96:[function(_dereq_,module,exports){
	var registerSystem = _dereq_('../core/system').registerSystem;
	
	var DEFAULT_CAMERA_ATTR = 'data-aframe-default-camera';
	
	/**
	 * Camera system. Manages which camera is active among multiple cameras in scene.
	 *
	 * @member {object} activeCameraEl - Active camera entity.
	 */
	module.exports.System = registerSystem('camera', {
	  init: function () {
	    this.activeCameraEl = null;
	    this.setupDefaultCamera();
	  },
	
	  /**
	   * Creates a default camera if user has not added one during the initial scene traversal.
	   *
	   * Default camera height is at human level (~1.8m) and back such that
	   * entities at the origin (0, 0, 0) are well-centered.
	   */
	  setupDefaultCamera: function () {
	    var sceneEl = this.sceneEl;
	    var cameraWrapperEl;
	    var defaultCameraEl;
	
	    // setTimeout in case the camera is being set dynamically with a setAttribute.
	    setTimeout(function checkForCamera () {
	      var cameraEl = sceneEl.querySelector('[camera]');
	
	      if (cameraEl && cameraEl.isEntity) {
	        sceneEl.emit('camera-ready', {cameraEl: cameraEl});
	        return;
	      }
	
	      // DOM calls to create camera.
	      cameraWrapperEl = document.createElement('a-entity');
	      cameraWrapperEl.setAttribute('position', {x: 0, y: 1.8, z: 4});
	      cameraWrapperEl.setAttribute(DEFAULT_CAMERA_ATTR, '');
	      defaultCameraEl = document.createElement('a-entity');
	      defaultCameraEl.setAttribute('camera', {'active': true});
	      defaultCameraEl.setAttribute('wasd-controls');
	      defaultCameraEl.setAttribute('look-controls');
	      cameraWrapperEl.appendChild(defaultCameraEl);
	      sceneEl.appendChild(cameraWrapperEl);
	      sceneEl.emit('camera-ready', {cameraEl: defaultCameraEl});
	    });
	  },
	
	  /**
	   * Set a different active camera.
	   * When we choose a (sort of) random scene camera as the replacement, set its `active` to
	   * true. The camera component will call `setActiveCamera` and handle passing the torch to
	   * the new camera.
	   */
	  disableActiveCamera: function () {
	    var sceneEl = this.sceneEl;
	    var sceneCameras = sceneEl.querySelectorAll('[camera]');
	    var newActiveCameraEl = sceneCameras[sceneCameras.length - 1];
	    newActiveCameraEl.setAttribute('camera', 'active', true);
	  },
	
	  /**
	   * Set active camera to be used by renderer.
	   * Removes the default camera (if present).
	   * Disables all other cameras in the scene.
	   *
	   * @param {Element} newCameraEl - Entity with camera component.
	   * @param {object} newCamera - three.js Camera object.
	   */
	  setActiveCamera: function (newCameraEl, newCamera) {
	    var cameraEl;
	    var i;
	    var sceneEl = this.sceneEl;
	    var sceneCameraEls = sceneEl.querySelectorAll('[camera]');
	
	    // Grab the default camera.
	    var defaultCameraWrapper = sceneEl.querySelector('[' + DEFAULT_CAMERA_ATTR + ']');
	    var defaultCameraEl = defaultCameraWrapper &&
	                          defaultCameraWrapper.querySelector('[camera]');
	    // Remove default camera if new camera is not the default camera.
	    if (newCameraEl !== defaultCameraEl) { removeDefaultCamera(sceneEl); }
	
	    // Make new camera active.
	    this.activeCameraEl = newCameraEl;
	    if (sceneEl.isPlaying) { newCameraEl.play(); }
	    newCameraEl.setAttribute('camera', 'active', true);
	    sceneEl.camera = newCamera;
	    sceneEl.emit('camera-set-active', {cameraEl: newCameraEl});
	
	    // Disable other cameras.
	    for (i = 0; i < sceneCameraEls.length; i++) {
	      cameraEl = sceneCameraEls[i];
	      if (newCameraEl === cameraEl) { continue; }
	      cameraEl.setAttribute('camera', 'active', false);
	      cameraEl.pause();
	    }
	  }
	});
	
	/**
	 * Remove injected default camera from scene, if present.
	 *
	 * @param {Element} sceneEl
	 */
	function removeDefaultCamera (sceneEl) {
	  var defaultCameraWrapper;
	  var camera = sceneEl.camera;
	  if (!camera) { return; }
	
	  // Remove default camera if present.
	  defaultCameraWrapper = sceneEl.querySelector('[' + DEFAULT_CAMERA_ATTR + ']');
	  if (!defaultCameraWrapper) { return; }
	  sceneEl.removeChild(defaultCameraWrapper);
	}
	
	},{"../core/system":64}],97:[function(_dereq_,module,exports){
	_dereq_('./camera');
	_dereq_('./material');
	_dereq_('./light');
	
	},{"./camera":96,"./light":98,"./material":99}],98:[function(_dereq_,module,exports){
	var registerSystem = _dereq_('../core/system').registerSystem;
	
	var DEFAULT_LIGHT_ATTR = 'data-aframe-default-light';
	
	/**
	 * Light system.
	 *
	 * Prescribes default lighting if not specified (one ambient, one directional).
	 * Removes default lighting from the scene when a new light is added.
	 *
	 * @param {bool} defaultLightsEnabled - Whether default lighting is active.
	 */
	module.exports.System = registerSystem('light', {
	  init: function () {
	    this.defaultLightsEnabled = null;
	    this.setupDefaultLights();
	  },
	
	  /**
	   * Notify scene that light has been added and to remove the default.
	   *
	   * @param {object} el - element holding the light component.
	   */
	  registerLight: function (el) {
	    var defaultLights;
	    var sceneEl = this.sceneEl;
	
	    if (this.defaultLightsEnabled && !el.hasAttribute(DEFAULT_LIGHT_ATTR)) {
	      // User added a light, remove default lights through DOM.
	      defaultLights = document.querySelectorAll('[' + DEFAULT_LIGHT_ATTR + ']');
	      for (var i = 0; i < defaultLights.length; i++) {
	        sceneEl.removeChild(defaultLights[i]);
	      }
	      this.defaultLightsEnabled = false;
	    }
	  },
	
	  /**
	   * Prescibe default lights to the scene.
	   * Does so by injecting markup such that this state is not invisible.
	   * These lights are removed if the user adds any lights.
	   */
	  setupDefaultLights: function () {
	    var sceneEl = this.sceneEl;
	    var ambientLight = document.createElement('a-entity');
	    var directionalLight = document.createElement('a-entity');
	
	    ambientLight.setAttribute('light',
	                              {color: '#fff', type: 'ambient'});
	    ambientLight.setAttribute(DEFAULT_LIGHT_ATTR, '');
	    sceneEl.appendChild(ambientLight);
	
	    directionalLight.setAttribute('light', { color: '#fff', intensity: 0.2 });
	    directionalLight.setAttribute('position', { x: -1, y: 2, z: 1 });
	    directionalLight.setAttribute(DEFAULT_LIGHT_ATTR, '');
	    sceneEl.appendChild(directionalLight);
	
	    this.defaultLightsEnabled = true;
	  }
	});
	
	},{"../core/system":64}],99:[function(_dereq_,module,exports){
	var registerSystem = _dereq_('../core/system').registerSystem;
	
	module.exports.System = registerSystem('material', {
	  init: function () {
	    this.materials = {};
	  },
	
	  /**
	   * Keep track of material in case an update trigger is needed (e.g., fog).
	   *
	   * @param {object} material
	   */
	  registerMaterial: function (material) {
	    this.materials[material.uuid] = material;
	  },
	
	  /**
	   * Stops tracking material.
	   *
	   * @param {object} material
	   */
	  unregisterMaterial: function (material) {
	    delete this.materials[material.uuid];
	  },
	
	  /**
	   * Trigger update to all registered materials.
	   */
	  updateMaterials: function (material) {
	    var materials = this.materials;
	    Object.keys(materials).forEach(function (uuid) {
	      materials[uuid].needsUpdate = true;
	    });
	  }
	
	});
	
	},{"../core/system":64}],100:[function(_dereq_,module,exports){
	// Coordinate string regex. Handles negative, positive, and decimals.
	var regex = /\s*(-?\d*\.{0,1}\d+)\s*(-?\d*\.{0,1}\d+)\s*(-?\d*\.{0,1}\d+)\s*/;
	module.exports.regex = regex;
	
	/**
	 * Parses coordinates from an "x y z" string.
	 * Example: "3 10 -5" to {x: 3, y: 10, z: -5}.
	 *
	 * @param {string} val - An "x y z" string.
	 * @param {string} defaults - fallback value.
	 * @returns {object} An object with keys [x, y, z].
	 */
	function parse (value, defaultVec) {
	  var coordinate;
	  var vec = {};
	
	  if (value && typeof value === 'object') {
	    return vecParseFloat(value);
	  }
	
	  if (typeof value !== 'string' || value === null) {
	    return defaultVec;
	  }
	
	  coordinate = value.trim().replace(/\s+/g, ' ').split(' ');
	  vec.x = coordinate[0] || defaultVec && defaultVec.x;
	  vec.y = coordinate[1] || defaultVec && defaultVec.y;
	  vec.z = coordinate[2] || defaultVec && defaultVec.z;
	  vec.w = coordinate[3] || defaultVec && defaultVec.w;
	  return vecParseFloat(vec);
	}
	module.exports.parse = parse;
	
	/**
	 * Stringifies coordinates from an object with keys [x y z].
	 * Example: {x: 3, y: 10, z: -5} to "3 10 -5".
	 *
	 * @param {object|string} data - An object with keys [x y z].
	 * @returns {string} An "x y z" string.
	 */
	function stringify (data) {
	  if (typeof data !== 'object') { return data; }
	  return [data.x, data.y, data.z].join(' ');
	}
	module.exports.stringify = stringify;
	
	/**
	 * @returns {bool}
	 */
	module.exports.isCoordinate = function (value) {
	  return regex.test(value);
	};
	
	function vecParseFloat (vec) {
	  Object.keys(vec).forEach(function (key) {
	    if (vec[key] === undefined) {
	      delete vec[key];
	      return;
	    }
	    vec[key] = parseFloat(vec[key], 10);
	  });
	  return vec;
	}
	
	},{}],101:[function(_dereq_,module,exports){
	(function (process){
	var debugLib = _dereq_('debug');
	var extend = _dereq_('object-assign');
	
	var settings = {
	  colors: {
	    debug: 'gray',
	    error: 'red',
	    info: 'gray',
	    warn: 'orange'
	  }
	};
	
	/**
	 * Monkeypatches `debug` so we can colorize error/warning messages.
	 *
	 * (See issue: https://github.com/visionmedia/debug/issues/137)
	 */
	var debug = function (namespace) {
	  var d = debugLib(namespace);
	
	  d.color = getDebugNamespaceColor(namespace);
	
	  return d;
	};
	extend(debug, debugLib);
	
	/**
	 * Returns the type of the namespace (e.g., `error`, `warn`).
	 *
	 * @param {String} namespace
	 *   The debug logger's namespace (e.g., `components:geometry:warn`).
	 * @returns {String} The type of the namespace (e.g., `warn`).
	 * @api private
	 */
	function getDebugNamespaceType (namespace) {
	  var chunks = namespace.split(':');
	
	  return chunks[chunks.length - 1];  // Return the last one
	}
	
	/**
	 * Returns the color of the namespace (e.g., `orange`).
	 *
	 * @param {String} namespace
	 *   The debug logger's namespace (e.g., `components:geometry:warn`).
	 * @returns {String} The color of the namespace (e.g., `orange`).
	 * @api private
	 */
	function getDebugNamespaceColor (namespace) {
	  var type = getDebugNamespaceType(namespace);
	
	  var color = settings.colors && settings.colors[type];
	
	  return color || null;
	}
	
	/**
	 * Returns `localStorage` if possible.
	 *
	 * This is necessary because Safari throws when a user disables
	 * cookies or `localStorage` and you attempt to access it.
	 *
	 * @returns {localStorage}
	 * @api private
	 */
	function storage () {
	  try {
	    return window.localStorage;
	  } catch (e) {
	  }
	}
	
	/**
	 * To enable console logging, type this in the Console of your Dev Tools:
	 *
	 *   localStorage.logs = 1
	 *
	 * To disable console logging:
	 *
	 *   localStorage.logs = 0
	 *
	 */
	var ls = storage();
	if (ls && (parseInt(ls.logs, 10) || ls.logs === 'true')) {
	  debug.enable('*');
	} else {
	  debug.enable('*:error,*:info,*:warn');
	}
	
	if (process.browser) { window.logs = debug; }
	
	module.exports = debug;
	
	}).call(this,_dereq_('_process'))
	
	},{"_process":2,"debug":3,"object-assign":9}],102:[function(_dereq_,module,exports){
	/* global CustomEvent, location */
	/* Centralized place to reference utilities since utils is exposed to the user. */
	
	var deepAssign = _dereq_('deep-assign');
	var objectAssign = _dereq_('object-assign');
	
	module.exports.coordinates = _dereq_('./coordinates');
	module.exports.debug = _dereq_('./debug');
	module.exports.styleParser = _dereq_('./styleParser');
	module.exports.texture = _dereq_('./texture');
	
	/**
	 * Fires a custom DOM event.
	 *
	 * @param {Element} el Element on which to fire the event.
	 * @param {String} name Name of the event.
	 * @param {Object=} [data={bubbles: true, {detail: <el>}}]
	 *   Data to pass as `customEventInit` to the event.
	 */
	module.exports.fireEvent = function (el, name, data) {
	  data = data || {};
	  data.detail = data.detail || {};
	  data.detail.target = data.detail.target || el;
	  var evt = new CustomEvent(name, data);
	  evt.target = el;
	  el.dispatchEvent(evt);
	};
	
	/**
	 * Throws an error given a message.
	 *
	 * @param {String} msg Error message.
	 */
	module.exports.error = function (msg) {
	  throw new Error(msg);
	};
	
	/**
	 * Emits a console warning given passed message argument(s).
	 */
	module.exports.warn = function () {
	  console.warn.apply(console, arguments);
	};
	
	/**
	 * Emits a console log given passed message argument(s).
	 */
	module.exports.log = function () {
	  console.log.apply(console, arguments);
	};
	
	/**
	 * Mix the properties of source object(s) into a destination object.
	 *
	 * @param  {object} dest - The object to which properties will be copied.
	 * @param  {...object} source - The object(s) from which properties will be copied.
	 */
	module.exports.extend = objectAssign;
	module.exports.extendDeep = deepAssign;
	
	/**
	 * Checks if two objects have the same attributes and values, including nested objects.
	 *
	 * @param {object} a - First object.
	 * @param {object} b - Second object.
	 * @returns {boolean} Whether two objects are deeply equal.
	 */
	function deepEqual (a, b) {
	  var keysA = Object.keys(a);
	  var keysB = Object.keys(b);
	  var i;
	  if (keysA.length !== keysB.length) { return false; }
	  // If there are no keys, compare the objects.
	  if (keysA.length === 0) { return a === b; }
	  for (i = 0; i < keysA.length; ++i) {
	    if (a[keysA[i]] !== b[keysA[i]]) { return false; }
	  }
	  return true;
	}
	module.exports.deepEqual = deepEqual;
	
	/**
	 * Computes the difference between two objects.
	 *
	 * @param {object} a - First object to compare (e.g., oldData).
	 * @param {object} b - Second object to compare (e.g., newData).
	 * @returns {object}
	 *   Difference object where set of keys note which values were not equal, and values are
	 *   `b`'s values.
	 */
	module.exports.diff = function (a, b) {
	  var diff = {};
	  var keys = Object.keys(a);
	  Object.keys(b).forEach(function collectKeys (bKey) {
	    if (keys.indexOf(bKey) === -1) {
	      keys.push(bKey);
	    }
	  });
	  keys.forEach(function doDiff (key) {
	    var aVal = a[key];
	    var bVal = b[key];
	    var isComparingObjects = aVal && bVal &&
	                             aVal.constructor === Object && bVal.constructor === Object;
	    if ((isComparingObjects && !deepEqual(aVal, bVal)) ||
	        (!isComparingObjects && aVal !== bVal)) {
	      diff[key] = bVal;
	    }
	  });
	  return diff;
	};
	
	/**
	 * Checks if browser is mobile.
	 * @return {Boolean} True if mobile browser detected.
	 */
	module.exports.isMobile = function () {
	  var check = false;
	  (function (a) {
	    if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4))) {
	      check = true;
	    }
	    if (isIOS()) {
	      check = true;
	    }
	  })(navigator.userAgent || navigator.vendor || window.opera);
	  return check;
	};
	
	var isIOS = module.exports.isIOS = function () {
	  return /iPad|iPhone|iPod/.test(navigator.platform);
	};
	
	/**
	 * Checks mobile device orientation.
	 * @return {Boolean} True if landscape orientation.
	 */
	module.exports.isLandscape = function () {
	  return window.orientation === 90 || window.orientation === -90;
	};
	
	/**
	 * Returns whether we should capture this keyboard event for keyboard shortcuts.
	 * @param {Event} event Event object.
	 * @returns {Boolean} Whether the key event should be captured.
	 */
	module.exports.shouldCaptureKeyEvent = function (event) {
	  if (event.shiftKey || event.metaKey || event.altKey || event.ctrlKey) {
	    return false;
	  }
	  return document.activeElement === document.body;
	};
	
	/**
	 * Splits a string into an array based on a delimiter.
	 *
	 * @param   {string=} [str='']        Source string
	 * @param   {string=} [delimiter=' '] Delimiter to use
	 * @returns {array}                   Array of delimited strings
	 */
	module.exports.splitString = function (str, delimiter) {
	  if (typeof delimiter === 'undefined') { delimiter = ' '; }
	  // First collapse the whitespace (or whatever the delimiter is).
	  var regex = new RegExp(delimiter, 'g');
	  str = (str || '').replace(regex, delimiter);
	  // Then split.
	  return str.split(delimiter);
	};
	
	/**
	 * Extracts data from the element given an object that contains expected keys.
	 *
	 * @param {Element} Source element.
	 * @param {Object} [defaults={}] Object of default key-value pairs.
	 * @returns {Object}
	 */
	module.exports.getElData = function (el, defaults) {
	  defaults = defaults || {};
	  var data = {};
	  Object.keys(defaults).forEach(copyAttribute);
	  function copyAttribute (key) {
	    if (el.hasAttribute(key)) {
	      data[key] = el.getAttribute(key);
	    }
	  }
	  return data;
	};
	
	/**
	 * Retrieves querystring value.
	 * @param  {String} name Name of querystring key.
	 * @return {String}      Value
	 */
	module.exports.getUrlParameter = function (name) {
	  name = name.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]');
	  var regex = new RegExp('[\\?&]' + name + '=([^&#]*)');
	  var results = regex.exec(location.search);
	  return results === null ? '' : decodeURIComponent(results[1].replace(/\+/g, ' '));
	};
	
	/**
	 * Detects whether context is within iframe.
	 */
	module.exports.isIframed = function () {
	  return window.top !== window.self;
	};
	
	// Must be at bottom to avoid circular dependency.
	module.exports.srcLoader = _dereq_('./src-loader');
	
	},{"./coordinates":100,"./debug":101,"./src-loader":103,"./styleParser":104,"./texture":105,"deep-assign":6,"object-assign":9}],103:[function(_dereq_,module,exports){
	/* global Image */
	var debug = _dereq_('./debug');
	
	var warn = debug('utils:src-loader:warn');
	
	/**
	 * Validates a texture, either as a selector or as a URL.
	 * Detects whether `src` is pointing to an image or to a video, and invokes the
	 * appropriate callback.
	 *
	 * If `src` is selector, check if it's valid, return the el in the callback.
	 * An el is returned so that it can be reused for texture loading.
	 *
	 * If `src` is a URL, check if it's valid, return the src in the callback.
	 *
	 * @params {string} src - A selector or a URL. URLs must be wrapped by `url()`.
	 * @params {function} isImageCb - callback if texture is an image.
	 * @params {function} isVideoCb - callback if texture is a video.
	 */
	function validateSrc (src, isImageCb, isVideoCb) {
	  var textureEl;
	  var isImage;
	  var isVideo;
	  var url = parseUrl(src);
	
	  // src is a url.
	  if (url) {
	    validateImageUrl(url, function isAnImageUrl (isImage) {
	      if (!isImage) { isVideoCb(url); return; }
	      isImageCb(url);
	    });
	    return;
	  }
	
	  // src is a query selector.
	  textureEl = validateAndGetQuerySelector(src);
	  if (!textureEl) { return; }
	  isImage = textureEl && textureEl.tagName === 'IMG';
	  isVideo = textureEl && textureEl.tagName === 'VIDEO';
	  if (isImage) { return isImageCb(textureEl); }
	  if (isVideo) { return isVideoCb(textureEl); }
	
	  // src is a valid selector but doesn't match with a <img> or <video> element.
	  warn('"%s" does not point to a valid <img> or <video> element', src);
	}
	
	/**
	 * Validates six images as a cubemap, either as selector or comma-separated
	 * URLs.
	 *
	 * @param {string} src - A selector or comma-separated image URLs. Image URLs
	          must be wrapped by `url()`.
	 * @param {string} src - A selector or comma-separated image URLs. Image URLs
	          must be wrapped by `url()`.
	 */
	function validateCubemapSrc (src, cb) {
	  var aCubemap;
	  var cubemapSrcRegex = '';
	  var i;
	  var urls;
	  var validatedUrls = [];
	
	  for (i = 0; i < 6; i++) {
	    cubemapSrcRegex += 'url\((.+)\)\s*,\s*';
	  }
	  urls = src.match(cubemapSrcRegex);
	
	  // `src` is a comma-separated list of URLs.
	  // In this case, re-use validateSrc for each side of the cube.
	  function isImageCb (url) {
	    validatedUrls.push(url);
	    if (validatedUrls.length === 6) {
	      cb(validatedUrls);
	    }
	  }
	  if (urls) {
	    for (i = 1; i < 7; i++) {
	      validateSrc(urls[i], isImageCb);
	    }
	    return;
	  }
	
	  // `src` is a query selector to <a-cubemap> containing six $([src])s.
	  aCubemap = validateAndGetQuerySelector(src);
	  if (!aCubemap) { return; }
	  if (aCubemap.tagName === 'A-CUBEMAP' && aCubemap.srcs) {
	    return cb(aCubemap.srcs);
	  }
	  // Else if aCubeMap is not a <a-cubemap>.
	  warn('Selector "%s" does not point to <a-cubemap>', src);
	}
	
	/**
	 * Parses src from `url(src)`.
	 * @param  {string} src - String to parse.
	 * @return {string} The parsed src, if parseable.
	 */
	function parseUrl (src) {
	  var parsedSrc = src.match(/\url\((.+)\)/);
	  if (!parsedSrc) { return; }
	  return parsedSrc[1];
	}
	
	/**
	 * Validate src is a valid image url
	 * @param  {string} src - url that will be tested
	 * @param  {function} onResult - callback with the test result
	 */
	function validateImageUrl (src, onResult) {
	  var tester = new Image();
	  tester.addEventListener('load', onLoad);
	  function onLoad () { onResult(true); }
	  tester.addEventListener('error', onError);
	  function onError () { onResult(false); }
	  tester.src = src;
	}
	
	/**
	 * Query and validate a query selector,
	 *
	 * @param  {string} selector - DOM selector.
	 * @return {object|null|undefined} Selected DOM element if exists.
	           null if query yields no results.
	           undefined if `selector` is not a valid selector.
	 */
	function validateAndGetQuerySelector (selector) {
	  try {
	    var el = document.querySelector(selector);
	    if (!el) {
	      warn('No element was found matching the selector: "%s"', selector);
	    }
	    return el;
	  } catch (e) {  // Capture exception if it's not a valid selector.
	    warn('"%s" is not a valid selector', selector);
	    return undefined;
	  }
	}
	
	module.exports = {
	  parseUrl: parseUrl,
	  validateSrc: validateSrc,
	  validateCubemapSrc: validateCubemapSrc
	};
	
	},{"./debug":101}],104:[function(_dereq_,module,exports){
	/* Utils for parsing style-like strings (e.g., "primitive: box; width: 5; height: 4.5"). */
	var styleParser = _dereq_('style-attr');
	
	/**
	 * Deserializes style-like string into an object of properties.
	 *
	 * @param {string} value - HTML attribute value.
	 * @returns {object} Property data.
	 */
	module.exports.parse = function (value) {
	  var parsedData;
	  if (typeof value !== 'string') { return value; }
	  parsedData = styleParser.parse(value);
	  return transformKeysToCamelCase(parsedData);
	};
	
	/**
	 * Serialize an object of properties into a style-like string.
	 *
	 * @param {object} data - Property data.
	 * @returns {string}
	 */
	module.exports.stringify = function (data) {
	  if (typeof data === 'string') { return data; }
	  return styleParser.stringify(data);
	};
	
	/**
	 * Converts string from hyphen to camelCase.
	 *
	 * @param {string} str - String to camelCase.
	 * @return {string} CamelCased string.
	 */
	function toCamelCase (str) {
	  return str.replace(/-([a-z])/g, camelCase);
	  function camelCase (g) { return g[1].toUpperCase(); }
	}
	module.exports.toCamelCase = toCamelCase;
	
	/**
	 * Converts object's keys from hyphens to camelCase (e.g., `max-value` to
	 * `maxValue`).
	 *
	 * @param {object} obj - The object to camelCase keys.
	 * @return {object} The object with keys camelCased.
	 */
	function transformKeysToCamelCase (obj) {
	  var keys = Object.keys(obj);
	  var camelCaseObj = {};
	  keys.forEach(function (key) {
	    var camelCaseKey = toCamelCase(key);
	    camelCaseObj[camelCaseKey] = obj[key];
	  });
	  return camelCaseObj;
	}
	module.exports.transformKeysToCamelCase = transformKeysToCamelCase;
	
	},{"style-attr":15}],105:[function(_dereq_,module,exports){
	/**
	 * Texture helpers for standard material component.
	 *
	 * @member textureCache {object} - Texture cache for:
	 *   - Images: textureCache has mapping of src -> repeat -> cached three.js texture.
	 *   - Videos: textureCache has mapping of videoElement -> cached three.js texture.
	 * @member videoCache {object} - Cache of video elements.
	 */
	var debug = _dereq_('./debug');
	var THREE = _dereq_('../lib/three');
	
	var EVENTS = {
	  TEXTURE_LOADED: 'material-texture-loaded'
	};
	var error = debug('components:texture:error');
	var textureCache = {};
	var TextureLoader = new THREE.TextureLoader();
	var warn = debug('components:texture:warn');
	
	/**
	 * High-level function for loading image textures. Meat of logic is in `loadImageTexture`.
	 * Bound to material component instance and three.js material.
	 *
	 * @param material {object} - three.js material, bound by the A-Frame shader.
	 * @param data {object} - Shader data, bound by the A-Frame shader.
	 * @param src {Element|string} - Texture source, bound by `src-loader` utils.
	 */
	function loadImage (material, data, src) {
	  var el = this.el;
	  var repeat = data.repeat || '1 1';
	  var srcString = src;
	
	  if (typeof src !== 'string') { srcString = src.getAttribute('src'); }
	
	  // Another material is already loading this texture. Wait on promise.
	  if (textureCache[src] && textureCache[src][repeat]) {
	    textureCache[src][repeat].then(handleImageTextureLoaded);
	    return;
	  }
	
	  // Material instance is first to try to load this texture. Load it.
	  textureCache[srcString] = textureCache[srcString] || {};
	  textureCache[srcString][repeat] = textureCache[srcString][repeat] || {};
	  textureCache[srcString][repeat] = loadImageTexture(material, src, repeat);
	  textureCache[srcString][repeat].then(handleImageTextureLoaded);
	
	  function handleImageTextureLoaded (texture) {
	    updateMaterial(material, texture);
	    el.emit(EVENTS.TEXTURE_LOADED, { src: src, texture: texture });
	  }
	}
	
	/**
	 * Load video texture.
	 * Bound to material component instance and three.js material.
	 * Note that creating a video texture is more synchronous than creating an image texture.
	 *
	 * @param material {object} - three.js material, bound by the A-Frame shader.
	 * @param data {object} - Shader data, bound by the A-Frame shader.
	 * @param src {Element|string} - Texture source, bound by `src-loader` utils.
	 */
	function loadVideo (material, data, src) {
	  var el = this.el;
	  var hash;
	  var texture;
	  var videoEl;
	  var videoTextureResult;
	
	  if (typeof src !== 'string') {
	    // Check cache before creating texture.
	    videoEl = src;
	    hash = calculateVideoCacheHash(videoEl);
	    if (textureCache[hash]) {
	      textureCache[hash].then(handleVideoTextureLoaded);
	      return;
	    }
	
	    // If not in cache, fix up the attributes then start to create the texture.
	    fixVideoAttributes(videoEl);
	  }
	
	  // Use video element to create texture.
	  videoEl = videoEl || createVideoEl(material, src, data.width, data.height);
	
	  // Generated video element already cached. Use that.
	  hash = calculateVideoCacheHash(videoEl);
	  if (textureCache[hash]) {
	    textureCache[hash].then(handleVideoTextureLoaded);
	    return;
	  }
	
	  // Create new video texture.
	  texture = new THREE.VideoTexture(videoEl);
	  texture.minFilter = THREE.LinearFilter;
	
	  videoTextureResult = {
	    texture: texture,
	    videoEl: videoEl
	  };
	
	  // Cache as promise to be consistent with image texture caching.
	  textureCache[hash] = Promise.resolve(videoTextureResult);
	  handleVideoTextureLoaded(videoTextureResult);
	
	  function handleVideoTextureLoaded (res) {
	    texture = res.texture;
	    videoEl = res.videoEl;
	    updateMaterial(material, texture);
	    el.emit(EVENTS.TEXTURE_LOADED, { element: videoEl, src: src });
	    videoEl.addEventListener('loadeddata', function () {
	      el.emit('material-video-loadeddata', { element: videoEl, src: src });
	    });
	    videoEl.addEventListener('ended', function () {
	      // Works for non-looping videos only.
	      el.emit('material-video-ended', { element: videoEl, src: src });
	    });
	  }
	}
	
	/**
	 * Calculates consistent hash from a video element using its attributes.
	 * If the video element has an ID, use that.
	 * Else build a hash that looks like `src:myvideo.mp4;height:200;width:400;`.
	 *
	 * @param videoEl {Element} - Video element.
	 * @returns {string}
	 */
	function calculateVideoCacheHash (videoEl) {
	  var i;
	  var id = videoEl.getAttribute('id');
	  var hash;
	  var videoAttributes;
	
	  if (id) { return id; }
	
	  // Calculate hash using sorted video attributes.
	  hash = '';
	  videoAttributes = {};
	  for (i = 0; i < videoEl.attributes.length; i++) {
	    videoAttributes[videoEl.attributes[i].name] = videoEl.attributes[i].value;
	  }
	  Object.keys(videoAttributes).sort().forEach(function (name) {
	    hash += name + ':' + videoAttributes[name] + ';';
	  });
	
	  return hash;
	}
	
	/**
	 * Set material texture and update if necessary.
	 *
	 * @param {object} material
	 * @param {object} texture
	 */
	function updateMaterial (material, texture) {
	  var oldMap = material.map;
	  if (texture) { texture.needsUpdate = true; }
	  material.map = texture;
	
	  // Only need to update three.js material if presence or not of texture has changed.
	  if (oldMap === null && material.map || material.map === null && oldMap) {
	    material.needsUpdate = true;
	  }
	}
	
	/**
	 * Set image texture on material as `map`.
	 *
	 * @private
	 * @param {object} el - Entity element.
	 * @param {object} material - three.js material.
	 * @param {string|object} src - An <img> element or url to an image file.
	 * @param {string} repeat - X and Y value for size of texture repeating (in UV units).
	 * @returns {Promise} Resolves once texture is loaded.
	 */
	function loadImageTexture (material, src, repeat) {
	  return new Promise(doLoadImageTexture);
	
	  function doLoadImageTexture (resolve, reject) {
	    var isEl = typeof src !== 'string';
	
	    // Create texture from an element.
	    if (isEl) {
	      createTexture(src);
	      return;
	    }
	
	    // Load texture from src string. THREE will create underlying element.
	    // Use THREE.TextureLoader (src, onLoad, onProgress, onError) to load texture.
	    TextureLoader.load(
	      src,
	      createTexture,
	      function () { /* no-op */ },
	      function (xhr) {
	        error('`$s` could not be fetched (Error code: %s; Response: %s)', xhr.status,
	              xhr.statusText);
	      }
	    );
	
	    /**
	     * Texture loaded. Set it.
	     */
	    function createTexture (texture) {
	      var repeatXY;
	      if (!(texture instanceof THREE.Texture)) { texture = new THREE.Texture(texture); }
	
	      // Handle UV repeat.
	      repeatXY = repeat.split(' ');
	      if (repeatXY.length === 2) {
	        texture.wrapS = THREE.RepeatWrapping;
	        texture.wrapT = THREE.RepeatWrapping;
	        texture.repeat.set(parseInt(repeatXY[0], 10), parseInt(repeatXY[1], 10));
	      }
	
	      resolve(texture);
	    }
	  }
	}
	
	/**
	 * Create video element to be used as a texture.
	 *
	 * @param {object} material - three.js material.
	 * @param {string} src - Url to a video file.
	 * @param {number} width - Width of the video.
	 * @param {number} height - Height of the video.
	 * @returns {Element} Video element.
	 */
	function createVideoEl (material, src, width, height) {
	  var el = material.videoEl || document.createElement('video');
	  el.width = width;
	  el.height = height;
	  if (el !== this.videoEl) {
	    el.setAttribute('webkit-playsinline', '');  // To support inline videos in iOS webviews.
	    el.autoplay = true;
	    el.loop = true;
	    el.crossOrigin = true;
	    el.addEventListener('error', function () {
	      warn('`$s` is not a valid video', src);
	    }, true);
	    material.videoEl = el;
	  }
	  el.src = src;
	  return el;
	}
	
	/**
	 * Fixes a video element's attributes to prevent developers from accidentally passing the
	 * wrong attribute values to commonly misused video attributes.
	 *
	 * <video> does not treat `autoplay`, `controls`, `crossorigin`, `loop`, and `preload` as
	 * as booleans. Existence of those attributes will mean truthy.
	 *
	 * For example, translates <video loop="false"> to <video>.
	 *
	 * @see https://developer.mozilla.org/docs/Web/HTML/Element/video#Attributes
	 * @param {Element} videoEl - Video element.
	 * @returns {Element} Video element with the correct properties updated.
	 */
	function fixVideoAttributes (videoEl) {
	  videoEl.autoplay = videoEl.getAttribute('autoplay') !== 'false';
	  videoEl.controls = videoEl.getAttribute('controls') !== 'false';
	  if (videoEl.getAttribute('loop') === 'false') {
	    videoEl.removeAttribute('loop');
	  }
	  if (videoEl.getAttribute('preload') === 'false') {
	    videoEl.preload = 'none';
	  }
	  if (!videoEl.hasAttribute('crossorigin')) {
	    videoEl.crossOrigin = true;
	  }
	  if (!videoEl.hasAttribute('webkit-playsinline')) {
	    videoEl.setAttribute('webkit-playsinline', '');  // To support inline videos in iOS webviews.
	  }
	  return videoEl;
	}
	
	function clearTextureCache () {
	  textureCache = {};
	}
	
	module.exports = {
	  clearTextureCache: clearTextureCache,
	  createVideoEl: createVideoEl,
	  fixVideoAttributes: fixVideoAttributes,
	  loadImage: loadImage,
	  loadVideo: loadVideo,
	  textureCache: textureCache,
	  updateMaterial: updateMaterial
	};
	
	},{"../lib/three":90,"./debug":101}],106:[function(_dereq_,module,exports){
	window.glStats = function () {
	
	    var _rS = null;
	
	    var _totalDrawArraysCalls = 0,
	        _totalDrawElementsCalls = 0,
	        _totalUseProgramCalls = 0,
	        _totalFaces = 0,
	        _totalVertices = 0,
	        _totalPoints = 0,
	        _totalBindTexures = 0;
	
	    function _h ( f, c ) {
	        return function () {
	            c.apply( this, arguments );
	            f.apply( this, arguments );
	        };
	    }
	
	    WebGLRenderingContext.prototype.drawArrays = _h( WebGLRenderingContext.prototype.drawArrays, function () {
	        _totalDrawArraysCalls++;
	        if ( arguments[ 0 ] == this.POINTS ) _totalPoints += arguments[ 2 ];
	        else _totalVertices += arguments[ 2 ];
	    } );
	
	    WebGLRenderingContext.prototype.drawElements = _h( WebGLRenderingContext.prototype.drawElements, function () {
	        _totalDrawElementsCalls++;
	        _totalFaces += arguments[ 1 ] / 3;
	        _totalVertices += arguments[ 1 ];
	    } );
	
	    WebGLRenderingContext.prototype.useProgram = _h( WebGLRenderingContext.prototype.useProgram, function () {
	        _totalUseProgramCalls++;
	    } );
	
	    WebGLRenderingContext.prototype.bindTexture = _h( WebGLRenderingContext.prototype.bindTexture, function () {
	        _totalBindTexures++;
	    } );
	
	    var _values = {
	        allcalls: {
	            over: 3000,
	            caption: 'Calls (hook)'
	        },
	        drawelements: {
	            caption: 'drawElements (hook)'
	        },
	        drawarrays: {
	            caption: 'drawArrays (hook)'
	        }
	    };
	
	    var _groups = [ {
	        caption: 'WebGL',
	        values: [ 'allcalls', 'drawelements', 'drawarrays', 'useprogram', 'bindtexture', 'glfaces', 'glvertices', 'glpoints' ]
	    } ];
	
	    var _fractions = [ {
	        base: 'allcalls',
	        steps: [ 'drawelements', 'drawarrays' ]
	    } ];
	
	    function _update () {
	        _rS( 'allcalls' ).set( _totalDrawArraysCalls + _totalDrawElementsCalls );
	        _rS( 'drawElements' ).set( _totalDrawElementsCalls );
	        _rS( 'drawArrays' ).set( _totalDrawArraysCalls );
	        _rS( 'bindTexture' ).set( _totalBindTexures );
	        _rS( 'useProgram' ).set( _totalUseProgramCalls );
	        _rS( 'glfaces' ).set( _totalFaces );
	        _rS( 'glvertices' ).set( _totalVertices );
	        _rS( 'glpoints' ).set( _totalPoints );
	    }
	
	    function _start () {
	        _totalDrawArraysCalls = 0;
	        _totalDrawElementsCalls = 0;
	        _totalUseProgramCalls = 0;
	        _totalFaces = 0;
	        _totalVertices = 0;
	        _totalPoints = 0;
	        _totalBindTexures = 0;
	    }
	
	    function _end () {}
	
	    function _attach ( r ) {
	        _rS = r;
	    }
	
	    return {
	        update: _update,
	        start: _start,
	        end: _end,
	        attach: _attach,
	        values: _values,
	        groups: _groups,
	        fractions: _fractions
	    };
	
	};
	
	window.threeStats = function ( renderer ) {
	
	    var _rS = null;
	
	    var _values = {
	        'renderer.info.memory.geometries': {
	            caption: 'Geometries'
	        },
	        'renderer.info.memory.textures': {
	            caption: 'Textures'
	        },
	        'renderer.info.memory.programs': {
	            caption: 'Programs'
	        },
	        'renderer.info.render.calls': {
	            caption: 'Calls'
	        },
	        'renderer.info.render.faces': {
	            caption: 'Faces',
	            over: 1000
	        },
	        'renderer.info.render.points': {
	            caption: 'Points'
	        },
	        'renderer.info.render.vertices': {
	            caption: 'Vertices'
	        }
	    };
	
	    var _groups = [ {
	        caption: 'Three.js - memory',
	        values: [ 'renderer.info.memory.geometries', 'renderer.info.memory.programs', 'renderer.info.memory.textures' ]
	    }, {
	        caption: 'Three.js - render',
	        values: [ 'renderer.info.render.calls', 'renderer.info.render.faces', 'renderer.info.render.points', 'renderer.info.render.vertices' ]
	    } ];
	
	    var _fractions = [];
	
	    function _update () {
	
	        _rS( 'renderer.info.memory.geometries' ).set( renderer.info.memory.geometries );
	        _rS( 'renderer.info.memory.programs' ).set( renderer.info.memory.programs );
	        _rS( 'renderer.info.memory.textures' ).set( renderer.info.memory.textures );
	        _rS( 'renderer.info.render.calls' ).set( renderer.info.render.calls );
	        _rS( 'renderer.info.render.faces' ).set( renderer.info.render.faces );
	        _rS( 'renderer.info.render.points' ).set( renderer.info.render.points );
	        _rS( 'renderer.info.render.vertices' ).set( renderer.info.render.vertices );
	
	    }
	
	    function _start () {}
	
	    function _end () {}
	
	    function _attach ( r ) {
	        _rS = r;
	    }
	
	    return {
	        update: _update,
	        start: _start,
	        end: _end,
	        attach: _attach,
	        values: _values,
	        groups: _groups,
	        fractions: _fractions
	    };
	
	};
	
	/*
	 *   From https://github.com/paulirish/memory-stats.js
	 */
	
	window.BrowserStats = function () {
	
	    var _rS = null;
	
	    var _usedJSHeapSize = 0,
	        _totalJSHeapSize = 0;
	
	    if ( window.performance && !performance.memory ) {
	        performance.memory = {
	            usedJSHeapSize: 0,
	            totalJSHeapSize: 0
	        };
	    }
	
	    if ( performance.memory.totalJSHeapSize === 0 ) {
	        console.warn( 'totalJSHeapSize === 0... performance.memory is only available in Chrome .' );
	    }
	
	    var _values = {
	        memory: {
	            caption: 'Used Memory',
	            average: true,
	            avgMs: 1000,
	            over: 22
	        },
	        total: {
	            caption: 'Total Memory'
	        }
	    };
	
	    var _groups = [ {
	        caption: 'Browser',
	        values: [ 'memory', 'total' ]
	    } ];
	
	    var _fractions = [ {
	        base: 'total',
	        steps: [ 'memory' ]
	    } ];
	
	    var log1024 = Math.log( 1024 );
	
	    function _size ( v ) {
	
	        var precision = 100; //Math.pow(10, 2);
	        var i = Math.floor( Math.log( v ) / log1024 );
	        return Math.round( v * precision / Math.pow( 1024, i ) ) / precision; // + ' ' + sizes[i];
	
	    }
	
	    function _update () {
	        _usedJSHeapSize = _size( performance.memory.usedJSHeapSize );
	        _totalJSHeapSize = _size( performance.memory.totalJSHeapSize );
	
	        _rS( 'memory' ).set( _usedJSHeapSize );
	        _rS( 'total' ).set( _totalJSHeapSize );
	    }
	
	    function _start () {
	        _usedJSHeapSize = 0;
	    }
	
	    function _end () {}
	
	    function _attach ( r ) {
	        _rS = r;
	    }
	
	    return {
	        update: _update,
	        start: _start,
	        end: _end,
	        attach: _attach,
	        values: _values,
	        groups: _groups,
	        fractions: _fractions
	    };
	
	};
	
	if (typeof module === 'object') {
	  module.exports = {
	    aframeStats: window.aframeStats,
	    glStats: window.glStats,
	    threeStats: window.threeStats,
	    BrowserStats: window.BrowserStats
	  };
	}
	
	},{}],107:[function(_dereq_,module,exports){
	// performance.now() polyfill from https://gist.github.com/paulirish/5438650
	'use strict';
	
	( function () {
	
	    // prepare base perf object
	    if ( typeof window.performance === 'undefined' ) {
	        window.performance = {};
	    }
	
	    if ( !window.performance.now ) {
	
	        var nowOffset = Date.now();
	
	        if ( performance.timing && performance.timing.navigationStart ) {
	            nowOffset = performance.timing.navigationStart;
	        }
	
	        window.performance.now = function now () {
	            return Date.now() - nowOffset;
	        };
	
	    }
	
	    if( !window.performance.mark ) {
	        window.performance.mark = function(){}
	    }
	
	    if( !window.performance.measure ) {
	        window.performance.measure = function(){}
	    }
	
	} )();
	
	window.rStats = function rStats ( settings ) {
	
	    function iterateKeys ( array, callback ) {
	        var keys = Object.keys( array );
	        for ( var j = 0, l = keys.length; j < l; j++ ) {
	            callback( keys[ j ] );
	        }
	    }
	
	    function importCSS ( url ) {
	
	        var element = document.createElement( 'link' );
	        element.href = url;
	        element.rel = 'stylesheet';
	        element.type = 'text/css';
	        document.getElementsByTagName( 'head' )[ 0 ].appendChild( element );
	
	    }
	
	    var _settings = settings || {};
	    var _colours = _settings.colours || [ '#850700', '#c74900', '#fcb300', '#284280', '#4c7c0c' ];
	
	    var _cssFont = '//fonts.googleapis.com/css?family=Roboto+Condensed:400,700,300';
	    var _cssRStats = ( _settings.CSSPath ? _settings.CSSPath : '' ) + 'rStats.css';
	
	    var _css = _settings.css || [ _cssFont, _cssRStats ];
	    _css.forEach(function (uri) {
	        importCSS( uri );
	    });
	
	    if ( !_settings.values ) _settings.values = {};
	
	    var _base, _div, _elHeight = 10, _elWidth = 200;
	    var _perfCounters = {};
	
	
	    function Graph ( _dom, _id, _defArg ) {
	
	        var _def = _defArg || {};
	        var _canvas = document.createElement( 'canvas' ),
	            _ctx = _canvas.getContext( '2d' ),
	            _max = 0,
	            _current = 0;
	
	        var c = _def.color ? _def.color : '#666666';
	
	        var _dotCanvas = document.createElement( 'canvas' ),
	            _dotCtx = _dotCanvas.getContext( '2d' );
	        _dotCanvas.width = 1;
	        _dotCanvas.height = 2 * _elHeight;
	        _dotCtx.fillStyle = '#444444';
	        _dotCtx.fillRect( 0, 0, 1, 2 * _elHeight );
	        _dotCtx.fillStyle = c;
	        _dotCtx.fillRect( 0, _elHeight, 1, _elHeight );
	        _dotCtx.fillStyle = '#ffffff';
	        _dotCtx.globalAlpha = 0.5;
	        _dotCtx.fillRect( 0, _elHeight, 1, 1 );
	        _dotCtx.globalAlpha = 1;
	
	        var _alarmCanvas = document.createElement( 'canvas' ),
	            _alarmCtx = _alarmCanvas.getContext( '2d' );
	        _alarmCanvas.width = 1;
	        _alarmCanvas.height = 2 * _elHeight;
	        _alarmCtx.fillStyle = '#444444';
	        _alarmCtx.fillRect( 0, 0, 1, 2 * _elHeight );
	        _alarmCtx.fillStyle = '#b70000';
	        _alarmCtx.fillRect( 0, _elHeight, 1, _elHeight );
	        _alarmCtx.globalAlpha = 0.5;
	        _alarmCtx.fillStyle = '#ffffff';
	        _alarmCtx.fillRect( 0, _elHeight, 1, 1 );
	        _alarmCtx.globalAlpha = 1;
	
	        function _init () {
	
	            _canvas.width = _elWidth;
	            _canvas.height = _elHeight;
	            _canvas.style.width = _canvas.width + 'px';
	            _canvas.style.height = _canvas.height + 'px';
	            _canvas.className = 'rs-canvas';
	            _dom.appendChild( _canvas );
	
	            _ctx.fillStyle = '#444444';
	            _ctx.fillRect( 0, 0, _canvas.width, _canvas.height );
	
	        }
	
	        function _draw ( v, alarm ) {
	            _current += ( v - _current ) * 0.1;
	            _max *= 0.99;
	            if ( _current > _max ) _max = _current;
	            _ctx.drawImage( _canvas, 1, 0, _canvas.width - 1, _canvas.height, 0, 0, _canvas.width - 1, _canvas.height );
	            if ( alarm ) {
	                _ctx.drawImage( _alarmCanvas, _canvas.width - 1, _canvas.height - _current * _canvas.height / _max - _elHeight );
	            } else {
	                _ctx.drawImage( _dotCanvas, _canvas.width - 1, _canvas.height - _current * _canvas.height / _max - _elHeight );
	            }
	        }
	
	        _init();
	
	        return {
	            draw: _draw
	        };
	
	    }
	
	    function StackGraph ( _dom, _num ) {
	
	        var _canvas = document.createElement( 'canvas' ),
	            _ctx = _canvas.getContext( '2d' );
	
	        function _init () {
	
	            _canvas.width = _elWidth;
	            _canvas.height = _elHeight * _num;
	            _canvas.style.width = _canvas.width + 'px';
	            _canvas.style.height = _canvas.height + 'px';
	            _canvas.className = 'rs-canvas';
	            _dom.appendChild( _canvas );
	
	            _ctx.fillStyle = '#444444';
	            _ctx.fillRect( 0, 0, _canvas.width, _canvas.height );
	
	        }
	
	        function _draw ( v ) {
	            _ctx.drawImage( _canvas, 1, 0, _canvas.width - 1, _canvas.height, 0, 0, _canvas.width - 1, _canvas.height );
	            var th = 0;
	            iterateKeys( v, function ( j ) {
	                var h = v[ j ] * _canvas.height;
	                _ctx.fillStyle = _colours[ j ];
	                _ctx.fillRect( _canvas.width - 1, th, 1, h );
	                th += h;
	            } );
	        }
	
	        _init();
	
	        return {
	            draw: _draw
	        };
	
	    }
	
	    function PerfCounter ( id, group ) {
	
	        var _id = id,
	            _time,
	            _value = 0,
	            _total = 0,
	            _averageValue = 0,
	            _accumValue = 0,
	            _accumStart = performance.now(),
	            _accumSamples = 0,
	            _dom = document.createElement( 'div' ),
	            _spanId = document.createElement( 'span' ),
	            _spanValue = document.createElement( 'div' ),
	            _spanValueText = document.createTextNode( '' ),
	            _def = _settings ? _settings.values[ _id.toLowerCase() ] : null,
	            _graph = new Graph( _dom, _id, _def ),
	            _started = false;
	
	        _dom.className = 'rs-counter-base';
	
	        _spanId.className = 'rs-counter-id';
	        _spanId.textContent = ( _def && _def.caption ) ? _def.caption : _id;
	
	        _spanValue.className = 'rs-counter-value';
	        _spanValue.appendChild( _spanValueText );
	
	        _dom.appendChild( _spanId );
	        _dom.appendChild( _spanValue );
	        if ( group ) group.div.appendChild( _dom );
	        else _div.appendChild( _dom );
	
	        _time = performance.now();
	
	        function _average ( v ) {
	            if ( _def && _def.average ) {
	                _accumValue += v;
	                _accumSamples++;
	                var t = performance.now();
	                if ( t - _accumStart >= ( _def.avgMs || 1000 ) ) {
	                    _averageValue = _accumValue / _accumSamples;
	                    _accumValue = 0;
	                    _accumStart = t;
	                    _accumSamples = 0;
	                }
	            }
	        }
	
	        function _start () {
	            _time = performance.now();
	            if( _settings.userTimingAPI ) performance.mark( _id + '-start' );
	            _started = true;
	        }
	
	        function _end () {
	            _value = performance.now() - _time;
	            if( _settings.userTimingAPI ) {
	                performance.mark( _id + '-end' );
	                if( _started ) {
	                    performance.measure( _id, _id + '-start', _id + '-end' );
	                }
	            }
	            _average( _value );
	        }
	
	        function _tick () {
	            _end();
	            _start();
	        }
	
	        function _draw () {
	            var v = ( _def && _def.average ) ? _averageValue : _value;
	            _spanValueText.nodeValue = Math.round( v * 100 ) / 100;
	            var a = ( _def && ( ( _def.below && _value < _def.below ) || ( _def.over && _value > _def.over ) ) );
	            _graph.draw( _value, a );
	            _dom.style.color = a ? '#b70000' : '#ffffff';
	        }
	
	        function _frame () {
	            var t = performance.now();
	            var e = t - _time;
	            _total++;
	            if ( e > 1000 ) {
	                if ( _def && _def.interpolate === false ) {
	                    _value = _total;
	                } else {
	                    _value = _total * 1000 / e;
	                }
	                _total = 0;
	                _time = t;
	                _average( _value );
	            }
	        }
	
	        function _set ( v ) {
	            _value = v;
	            _average( _value );
	        }
	
	        return {
	            set: _set,
	            start: _start,
	            tick: _tick,
	            end: _end,
	            frame: _frame,
	            value: function () {
	                return _value;
	            },
	            draw: _draw
	        };
	
	    }
	
	    function sample () {
	
	        var _value = 0;
	
	        function _set ( v ) {
	            _value = v;
	        }
	
	        return {
	            set: _set,
	            value: function () {
	                return _value;
	            }
	        };
	
	    }
	
	    function _perf ( idArg ) {
	
	        var id = idArg.toLowerCase();
	        if ( id === undefined ) id = 'default';
	        if ( _perfCounters[ id ] ) return _perfCounters[ id ];
	
	        var group = null;
	        if ( _settings && _settings.groups ) {
	            iterateKeys( _settings.groups, function ( j ) {
	                var g = _settings.groups[ parseInt( j, 10 ) ];
	                if ( !group && g.values.indexOf( id.toLowerCase() ) !== -1 ) {
	                    group = g;
	                }
	            } );
	        }
	
	        var p = new PerfCounter( id, group );
	        _perfCounters[ id ] = p;
	        return p;
	
	    }
	
	    function _init () {
	
	        if ( _settings.plugins ) {
	            if ( !_settings.values ) _settings.values = {};
	            if ( !_settings.groups ) _settings.groups = [];
	            if ( !_settings.fractions ) _settings.fractions = [];
	            for ( var j = 0; j < _settings.plugins.length; j++ ) {
	                _settings.plugins[ j ].attach( _perf );
	                iterateKeys( _settings.plugins[ j ].values, function ( k ) {
	                    _settings.values[ k ] = _settings.plugins[ j ].values[ k ];
	                } );
	                _settings.groups = _settings.groups.concat( _settings.plugins[ j ].groups );
	                _settings.fractions = _settings.fractions.concat( _settings.plugins[ j ].fractions );
	            }
	        } else {
	            _settings.plugins = {};
	        }
	
	        _base = document.createElement( 'div' );
	        _base.className = 'rs-base';
	        _div = document.createElement( 'div' );
	        _div.className = 'rs-container';
	        _div.style.height = 'auto';
	        _base.appendChild( _div );
	        document.body.appendChild( _base );
	
	        if ( !_settings ) return;
	
	        if ( _settings.groups ) {
	            iterateKeys( _settings.groups, function ( j ) {
	                var g = _settings.groups[ parseInt( j, 10 ) ];
	                var div = document.createElement( 'div' );
	                div.className = 'rs-group';
	                g.div = div;
	                var h1 = document.createElement( 'h1' );
	                h1.textContent = g.caption;
	                h1.addEventListener( 'click', function ( e ) {
	                    this.classList.toggle( 'hidden' );
	                    e.preventDefault();
	                }.bind( div ) );
	                _div.appendChild( h1 );
	                _div.appendChild( div );
	            } );
	        }
	
	        if ( _settings.fractions ) {
	            iterateKeys( _settings.fractions, function ( j ) {
	                var f = _settings.fractions[ parseInt( j, 10 ) ];
	                var div = document.createElement( 'div' );
	                div.className = 'rs-fraction';
	                var legend = document.createElement( 'div' );
	                legend.className = 'rs-legend';
	
	                var h = 0;
	                iterateKeys( _settings.fractions[ j ].steps, function ( k ) {
	                    var p = document.createElement( 'p' );
	                    p.textContent = _settings.fractions[ j ].steps[ k ];
	                    p.style.color = _colours[ h ];
	                    legend.appendChild( p );
	                    h++;
	                } );
	                div.appendChild( legend );
	                div.style.height = h * _elHeight + 'px';
	                f.div = div;
	                var graph = new StackGraph( div, h );
	                f.graph = graph;
	                _div.appendChild( div );
	            } );
	        }
	
	    }
	
	    function _update () {
	
	        iterateKeys( _settings.plugins, function ( j ) {
	            _settings.plugins[ j ].update();
	        } );
	
	        iterateKeys( _perfCounters, function ( j ) {
	            _perfCounters[ j ].draw();
	        } );
	
	        if ( _settings && _settings.fractions ) {
	            iterateKeys( _settings.fractions, function ( j ) {
	                var f = _settings.fractions[ parseInt( j, 10 ) ];
	                var v = [];
	                var base = _perfCounters[ f.base.toLowerCase() ];
	                if ( base ) {
	                    base = base.value();
	                    iterateKeys( _settings.fractions[ j ].steps, function ( k ) {
	                        var s = _settings.fractions[ j ].steps[ parseInt( k, 10 ) ].toLowerCase();
	                        var val = _perfCounters[ s ];
	                        if ( val ) {
	                            v.push( val.value() / base );
	                        }
	                    } );
	                }
	                f.graph.draw( v );
	            } );
	        }
	
	        /*if( _height != _div.clientHeight ) {
	            _height = _div.clientHeight;
	            _base.style.height = _height + 2 * _elHeight + 'px';
	        console.log( _base.clientHeight );
	        }*/
	
	    }
	
	    _init();
	
	    return function ( id ) {
	        if ( id ) return _perf( id );
	        return {
	            element: _base,
	            update: _update
	        };
	    };
	
	}
	
	if (typeof module === 'object') {
	  module.exports = window.rStats;
	}
	
	},{}],108:[function(_dereq_,module,exports){
	/*
	 * Copyright 2015 Google Inc. All Rights Reserved.
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	
	var Util = {};
	
	Util.base64 = function(mimeType, base64) {
	  return 'data:' + mimeType + ';base64,' + base64;
	};
	
	Util.isMobile = function() {
	  var check = false;
	  (function(a){if(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0,4)))check = true})(navigator.userAgent||navigator.vendor||window.opera);
	  return check;
	};
	
	Util.isIOS = function() {
	  return /(iPad|iPhone|iPod)/g.test(navigator.userAgent);
	};
	
	Util.isIFrame = function() {
	  try {
	    return window.self !== window.top;
	  } catch (e) {
	    return true;
	  }
	};
	
	Util.appendQueryParameter = function(url, key, value) {
	  // Determine delimiter based on if the URL already GET parameters in it.
	  var delimiter = (url.indexOf('?') < 0 ? '?' : '&');
	  url += delimiter + key + '=' + value;
	  return url;
	};
	
	// From http://goo.gl/4WX3tg
	Util.getQueryParameter = function(name) {
	  name = name.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]");
	  var regex = new RegExp("[\\?&]" + name + "=([^&#]*)"),
	      results = regex.exec(location.search);
	  return results === null ? "" : decodeURIComponent(results[1].replace(/\+/g, " "));
	};
	
	Util.isLandscapeMode = function() {
	  return (window.orientation == 90 || window.orientation == -90);
	};
	
	
	module.exports = Util;
	
	},{}],109:[function(_dereq_,module,exports){
	/*
	 * Copyright 2015 Google Inc. All Rights Reserved.
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	
	var Util = _dereq_('./util.js');
	
	/**
	 * Android and iOS compatible wakelock implementation.
	 *
	 * Refactored thanks to dkovalev@.
	 */
	function AndroidWakeLock() {
	  var video = document.createElement('video');
	
	  video.addEventListener('ended', function() {
	    video.play();
	  });
	
	  this.request = function() {
	    if (video.paused) {
	      // Base64 version of videos_src/no-sleep-60s.webm.
	      video.src = Util.base64('video/webm', 'GkXfowEAAAAAAAAfQoaBAUL3gQFC8oEEQvOBCEKChHdlYm1Ch4ECQoWBAhhTgGcBAAAAAAAH4xFNm3RALE27i1OrhBVJqWZTrIHfTbuMU6uEFlSua1OsggEwTbuMU6uEHFO7a1OsggfG7AEAAAAAAACkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmAQAAAAAAAEUq17GDD0JATYCNTGF2ZjU2LjQwLjEwMVdBjUxhdmY1Ni40MC4xMDFzpJAGSJTMbsLpDt/ySkipgX1fRImIQO1MAAAAAAAWVK5rAQAAAAAAADuuAQAAAAAAADLXgQFzxYEBnIEAIrWcg3VuZIaFVl9WUDmDgQEj44OEO5rKAOABAAAAAAAABrCBsLqBkB9DtnUBAAAAAAAAo+eBAKOmgQAAgKJJg0IAAV4BHsAHBIODCoAACmH2MAAAZxgz4dPSTFi5JACjloED6ACmAECSnABMQAADYAAAWi0quoCjloEH0ACmAECSnABNwAADYAAAWi0quoCjloELuACmAECSnABNgAADYAAAWi0quoCjloEPoACmAECSnABNYAADYAAAWi0quoCjloETiACmAECSnABNIAADYAAAWi0quoAfQ7Z1AQAAAAAAAJTnghdwo5aBAAAApgBAkpwATOAAA2AAAFotKrqAo5aBA+gApgBAkpwATMAAA2AAAFotKrqAo5aBB9AApgBAkpwATIAAA2AAAFotKrqAo5aBC7gApgBAkpwATEAAA2AAAFotKrqAo5aBD6AApgDAkpwAQ2AAA2AAAFotKrqAo5aBE4gApgBAkpwATCAAA2AAAFotKrqAH0O2dQEAAAAAAACU54Iu4KOWgQAAAKYAQJKcAEvAAANgAABaLSq6gKOWgQPoAKYAQJKcAEtgAANgAABaLSq6gKOWgQfQAKYAQJKcAEsAAANgAABaLSq6gKOWgQu4AKYAQJKcAEqAAANgAABaLSq6gKOWgQ+gAKYAQJKcAEogAANgAABaLSq6gKOWgROIAKYAQJKcAEnAAANgAABaLSq6gB9DtnUBAAAAAAAAlOeCRlCjloEAAACmAECSnABJgAADYAAAWi0quoCjloED6ACmAECSnABJIAADYAAAWi0quoCjloEH0ACmAMCSnABDYAADYAAAWi0quoCjloELuACmAECSnABI4AADYAAAWi0quoCjloEPoACmAECSnABIoAADYAAAWi0quoCjloETiACmAECSnABIYAADYAAAWi0quoAfQ7Z1AQAAAAAAAJTngl3Ao5aBAAAApgBAkpwASCAAA2AAAFotKrqAo5aBA+gApgBAkpwASAAAA2AAAFotKrqAo5aBB9AApgBAkpwAR8AAA2AAAFotKrqAo5aBC7gApgBAkpwAR4AAA2AAAFotKrqAo5aBD6AApgBAkpwAR2AAA2AAAFotKrqAo5aBE4gApgBAkpwARyAAA2AAAFotKrqAH0O2dQEAAAAAAACU54J1MKOWgQAAAKYAwJKcAENgAANgAABaLSq6gKOWgQPoAKYAQJKcAEbgAANgAABaLSq6gKOWgQfQAKYAQJKcAEagAANgAABaLSq6gKOWgQu4AKYAQJKcAEaAAANgAABaLSq6gKOWgQ+gAKYAQJKcAEZAAANgAABaLSq6gKOWgROIAKYAQJKcAEYAAANgAABaLSq6gB9DtnUBAAAAAAAAlOeCjKCjloEAAACmAECSnABF4AADYAAAWi0quoCjloED6ACmAECSnABFwAADYAAAWi0quoCjloEH0ACmAECSnABFoAADYAAAWi0quoCjloELuACmAECSnABFgAADYAAAWi0quoCjloEPoACmAMCSnABDYAADYAAAWi0quoCjloETiACmAECSnABFYAADYAAAWi0quoAfQ7Z1AQAAAAAAAJTngqQQo5aBAAAApgBAkpwARUAAA2AAAFotKrqAo5aBA+gApgBAkpwARSAAA2AAAFotKrqAo5aBB9AApgBAkpwARQAAA2AAAFotKrqAo5aBC7gApgBAkpwARQAAA2AAAFotKrqAo5aBD6AApgBAkpwAROAAA2AAAFotKrqAo5aBE4gApgBAkpwARMAAA2AAAFotKrqAH0O2dQEAAAAAAACU54K7gKOWgQAAAKYAQJKcAESgAANgAABaLSq6gKOWgQPoAKYAQJKcAESAAANgAABaLSq6gKOWgQfQAKYAwJKcAENgAANgAABaLSq6gKOWgQu4AKYAQJKcAERgAANgAABaLSq6gKOWgQ+gAKYAQJKcAERAAANgAABaLSq6gKOWgROIAKYAQJKcAEQgAANgAABaLSq6gB9DtnUBAAAAAAAAlOeC0vCjloEAAACmAECSnABEIAADYAAAWi0quoCjloED6ACmAECSnABEAAADYAAAWi0quoCjloEH0ACmAECSnABD4AADYAAAWi0quoCjloELuACmAECSnABDwAADYAAAWi0quoCjloEPoACmAECSnABDoAADYAAAWi0quoCjloETiACmAECSnABDgAADYAAAWi0quoAcU7trAQAAAAAAABG7j7OBALeK94EB8YIBd/CBAw==');
	      video.play();
	    }
	  };
	
	  this.release = function() {
	    video.pause();
	    video.src = '';
	  };
	}
	
	function iOSWakeLock() {
	  var timer = null;
	
	  this.request = function() {
	    if (!timer) {
	      timer = setInterval(function() {
	        window.location = window.location;
	        setTimeout(window.stop, 0);
	      }, 30000);
	    }
	  }
	
	  this.release = function() {
	    if (timer) {
	      clearInterval(timer);
	      timer = null;
	    }
	  }
	}
	
	
	function getWakeLock() {
	  var userAgent = navigator.userAgent || navigator.vendor || window.opera;
	  if (userAgent.match(/iPhone/i) || userAgent.match(/iPod/i)) {
	    return iOSWakeLock;
	  } else {
	    return AndroidWakeLock;
	  }
	}
	
	module.exports = getWakeLock();
	
	},{"./util.js":108}]},{},[88])(88)
	});
	//# sourceMappingURL=aframe.js.map
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(3).setImmediate))

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate) {var nextTick = __webpack_require__(4).nextTick;
	var apply = Function.prototype.apply;
	var slice = Array.prototype.slice;
	var immediateIds = {};
	var nextImmediateId = 0;
	
	// DOM APIs, for completeness
	
	exports.setTimeout = function() {
	  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
	};
	exports.setInterval = function() {
	  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
	};
	exports.clearTimeout =
	exports.clearInterval = function(timeout) { timeout.close(); };
	
	function Timeout(id, clearFn) {
	  this._id = id;
	  this._clearFn = clearFn;
	}
	Timeout.prototype.unref = Timeout.prototype.ref = function() {};
	Timeout.prototype.close = function() {
	  this._clearFn.call(window, this._id);
	};
	
	// Does not start the time, just sets up the members needed.
	exports.enroll = function(item, msecs) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = msecs;
	};
	
	exports.unenroll = function(item) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = -1;
	};
	
	exports._unrefActive = exports.active = function(item) {
	  clearTimeout(item._idleTimeoutId);
	
	  var msecs = item._idleTimeout;
	  if (msecs >= 0) {
	    item._idleTimeoutId = setTimeout(function onTimeout() {
	      if (item._onTimeout)
	        item._onTimeout();
	    }, msecs);
	  }
	};
	
	// That's not how node.js implements it but the exposed api is the same.
	exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
	  var id = nextImmediateId++;
	  var args = arguments.length < 2 ? false : slice.call(arguments, 1);
	
	  immediateIds[id] = true;
	
	  nextTick(function onNextTick() {
	    if (immediateIds[id]) {
	      // fn.call() is faster so we optimize for the common use-case
	      // @see http://jsperf.com/call-apply-segu
	      if (args) {
	        fn.apply(null, args);
	      } else {
	        fn.call(null);
	      }
	      // Prevent ids from leaking
	      exports.clearImmediate(id);
	    }
	  });
	
	  return id;
	};
	
	exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
	  delete immediateIds[id];
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3).setImmediate, __webpack_require__(3).clearImmediate))

/***/ },
/* 4 */
/***/ function(module, exports) {

	// shim for using process in browser
	
	var process = module.exports = {};
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = setTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    clearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        setTimeout(drainQueue, 0);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(6);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../node_modules/css-loader/index.js!./../node_modules/sass-loader/index.js!!./main.scss", function() {
				var newContent = require("!!./../node_modules/css-loader/index.js!./../node_modules/sass-loader/index.js!!./main.scss");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(7)();
	// imports
	
	
	// module
	exports.push([module.id, "html, body {\n  margin: 0;\n  padding: 0; }\n", ""]);
	
	// exports


/***/ },
/* 7 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	// css base code, injected by the css-loader
	module.exports = function() {
		var list = [];
	
		// return the list of modules as css string
		list.toString = function toString() {
			var result = [];
			for(var i = 0; i < this.length; i++) {
				var item = this[i];
				if(item[2]) {
					result.push("@media " + item[2] + "{" + item[1] + "}");
				} else {
					result.push(item[1]);
				}
			}
			return result.join("");
		};
	
		// import a list of modules into the list
		list.i = function(modules, mediaQuery) {
			if(typeof modules === "string")
				modules = [[null, modules, ""]];
			var alreadyImportedModules = {};
			for(var i = 0; i < this.length; i++) {
				var id = this[i][0];
				if(typeof id === "number")
					alreadyImportedModules[id] = true;
			}
			for(i = 0; i < modules.length; i++) {
				var item = modules[i];
				// skip already imported module
				// this implementation is not 100% perfect for weird media query combinations
				//  when a module is imported multiple times with different media queries.
				//  I hope this will never occur (Hey this way we have smaller bundles)
				if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
					if(mediaQuery && !item[2]) {
						item[2] = mediaQuery;
					} else if(mediaQuery) {
						item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
					}
					list.push(item);
				}
			}
		};
		return list;
	};


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var stylesInDom = {},
		memoize = function(fn) {
			var memo;
			return function () {
				if (typeof memo === "undefined") memo = fn.apply(this, arguments);
				return memo;
			};
		},
		isOldIE = memoize(function() {
			return /msie [6-9]\b/.test(window.navigator.userAgent.toLowerCase());
		}),
		getHeadElement = memoize(function () {
			return document.head || document.getElementsByTagName("head")[0];
		}),
		singletonElement = null,
		singletonCounter = 0,
		styleElementsInsertedAtTop = [];
	
	module.exports = function(list, options) {
		if(true) {
			if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
		}
	
		options = options || {};
		// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
		// tags it will allow on a page
		if (typeof options.singleton === "undefined") options.singleton = isOldIE();
	
		// By default, add <style> tags to the bottom of <head>.
		if (typeof options.insertAt === "undefined") options.insertAt = "bottom";
	
		var styles = listToStyles(list);
		addStylesToDom(styles, options);
	
		return function update(newList) {
			var mayRemove = [];
			for(var i = 0; i < styles.length; i++) {
				var item = styles[i];
				var domStyle = stylesInDom[item.id];
				domStyle.refs--;
				mayRemove.push(domStyle);
			}
			if(newList) {
				var newStyles = listToStyles(newList);
				addStylesToDom(newStyles, options);
			}
			for(var i = 0; i < mayRemove.length; i++) {
				var domStyle = mayRemove[i];
				if(domStyle.refs === 0) {
					for(var j = 0; j < domStyle.parts.length; j++)
						domStyle.parts[j]();
					delete stylesInDom[domStyle.id];
				}
			}
		};
	}
	
	function addStylesToDom(styles, options) {
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			if(domStyle) {
				domStyle.refs++;
				for(var j = 0; j < domStyle.parts.length; j++) {
					domStyle.parts[j](item.parts[j]);
				}
				for(; j < item.parts.length; j++) {
					domStyle.parts.push(addStyle(item.parts[j], options));
				}
			} else {
				var parts = [];
				for(var j = 0; j < item.parts.length; j++) {
					parts.push(addStyle(item.parts[j], options));
				}
				stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
			}
		}
	}
	
	function listToStyles(list) {
		var styles = [];
		var newStyles = {};
		for(var i = 0; i < list.length; i++) {
			var item = list[i];
			var id = item[0];
			var css = item[1];
			var media = item[2];
			var sourceMap = item[3];
			var part = {css: css, media: media, sourceMap: sourceMap};
			if(!newStyles[id])
				styles.push(newStyles[id] = {id: id, parts: [part]});
			else
				newStyles[id].parts.push(part);
		}
		return styles;
	}
	
	function insertStyleElement(options, styleElement) {
		var head = getHeadElement();
		var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];
		if (options.insertAt === "top") {
			if(!lastStyleElementInsertedAtTop) {
				head.insertBefore(styleElement, head.firstChild);
			} else if(lastStyleElementInsertedAtTop.nextSibling) {
				head.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
			} else {
				head.appendChild(styleElement);
			}
			styleElementsInsertedAtTop.push(styleElement);
		} else if (options.insertAt === "bottom") {
			head.appendChild(styleElement);
		} else {
			throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
		}
	}
	
	function removeStyleElement(styleElement) {
		styleElement.parentNode.removeChild(styleElement);
		var idx = styleElementsInsertedAtTop.indexOf(styleElement);
		if(idx >= 0) {
			styleElementsInsertedAtTop.splice(idx, 1);
		}
	}
	
	function createStyleElement(options) {
		var styleElement = document.createElement("style");
		styleElement.type = "text/css";
		insertStyleElement(options, styleElement);
		return styleElement;
	}
	
	function createLinkElement(options) {
		var linkElement = document.createElement("link");
		linkElement.rel = "stylesheet";
		insertStyleElement(options, linkElement);
		return linkElement;
	}
	
	function addStyle(obj, options) {
		var styleElement, update, remove;
	
		if (options.singleton) {
			var styleIndex = singletonCounter++;
			styleElement = singletonElement || (singletonElement = createStyleElement(options));
			update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
			remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
		} else if(obj.sourceMap &&
			typeof URL === "function" &&
			typeof URL.createObjectURL === "function" &&
			typeof URL.revokeObjectURL === "function" &&
			typeof Blob === "function" &&
			typeof btoa === "function") {
			styleElement = createLinkElement(options);
			update = updateLink.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
				if(styleElement.href)
					URL.revokeObjectURL(styleElement.href);
			};
		} else {
			styleElement = createStyleElement(options);
			update = applyToTag.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
			};
		}
	
		update(obj);
	
		return function updateStyle(newObj) {
			if(newObj) {
				if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
					return;
				update(obj = newObj);
			} else {
				remove();
			}
		};
	}
	
	var replaceText = (function () {
		var textStore = [];
	
		return function (index, replacement) {
			textStore[index] = replacement;
			return textStore.filter(Boolean).join('\n');
		};
	})();
	
	function applyToSingletonTag(styleElement, index, remove, obj) {
		var css = remove ? "" : obj.css;
	
		if (styleElement.styleSheet) {
			styleElement.styleSheet.cssText = replaceText(index, css);
		} else {
			var cssNode = document.createTextNode(css);
			var childNodes = styleElement.childNodes;
			if (childNodes[index]) styleElement.removeChild(childNodes[index]);
			if (childNodes.length) {
				styleElement.insertBefore(cssNode, childNodes[index]);
			} else {
				styleElement.appendChild(cssNode);
			}
		}
	}
	
	function applyToTag(styleElement, obj) {
		var css = obj.css;
		var media = obj.media;
	
		if(media) {
			styleElement.setAttribute("media", media)
		}
	
		if(styleElement.styleSheet) {
			styleElement.styleSheet.cssText = css;
		} else {
			while(styleElement.firstChild) {
				styleElement.removeChild(styleElement.firstChild);
			}
			styleElement.appendChild(document.createTextNode(css));
		}
	}
	
	function updateLink(linkElement, obj) {
		var css = obj.css;
		var sourceMap = obj.sourceMap;
	
		if(sourceMap) {
			// http://stackoverflow.com/a/26603875
			css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
		}
	
		var blob = new Blob([css], { type: "text/css" });
	
		var oldSrc = linkElement.href;
	
		linkElement.href = URL.createObjectURL(blob);
	
		if(oldSrc)
			URL.revokeObjectURL(oldSrc);
	}


/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgYTE5ODQ0NjIyMDI1ZTY0M2IxNDgiLCJ3ZWJwYWNrOi8vLy4vbWFpbi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9hZnJhbWUvZGlzdC9hZnJhbWUuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9+L25vZGUtbGlicy1icm93c2VyL34vdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL34vbm9kZS1saWJzLWJyb3dzZXIvfi9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3R5bGVzL21haW4uc2Nzcz9mZTcyIiwid2VicGFjazovLy8uL3N0eWxlcy9tYWluLnNjc3MiLCJ3ZWJwYWNrOi8vLy4vfi9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7OztBQ3BDQTs7QUFFQSx3Qjs7Ozs7Ozs7QUNKQSxxQkFBUSxDQUFSLEU7Ozs7Ozt5QkNBQSx5RUFBYSxTQUEyRCxtQkFBbUIsZ0RBQWdELGFBQWEsS0FBSyxNQUFNLGdDQUFnQyxTQUFTLHFDQUFxQyxTQUFTLG1DQUFtQyxPQUFPLEtBQUssT0FBTyxnQkFBZ0IsYUFBYSwwQkFBMEIsMEJBQTBCLGdCQUFnQixVQUFVLFVBQVUsMENBQTBDLDhCQUF3QixvQkFBb0IsOENBQThDLGtDQUFrQyxZQUFZLFlBQVksbUNBQW1DLGlCQUFpQixnQkFBZ0Isc0JBQXNCLG9CQUFvQiwwQ0FBMEMsWUFBWSxXQUFXLFlBQVksU0FBUyxHQUFHO0FBQzF5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsVUFBUyw2QkFBNkI7QUFDdEM7QUFDQTtBQUNBLFVBQVMsT0FBTztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUMsR0FBRztBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsNkJBQTRCLFVBQVU7O0FBRXRDLEVBQUMsR0FBRzs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQVksT0FBTztBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBLEVBQUMsRUFBRSxZQUFZOztBQUVmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUMsR0FBRztBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsUUFBTzs7QUFFUDs7QUFFQTs7QUFFQSxTQUFROztBQUVSOztBQUVBOztBQUVBOztBQUVBOztBQUVBLE1BQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsMEJBQXlCLHFEQUFxRDs7QUFFOUU7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxJQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbUJBQWtCLDhCQUE4Qjs7QUFFaEQ7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QkFBdUI7O0FBRTFDOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUJBQWtCLDRCQUE0Qjs7QUFFOUM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBa0IsK0JBQStCOztBQUVqRDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1CQUFrQiw0QkFBNEI7O0FBRTlDOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxNQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLE1BQUs7O0FBRUw7QUFDQTs7QUFFQSxNQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBa0IsK0JBQStCOztBQUVqRDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsc0JBQXFCLHNCQUFzQjs7QUFFM0M7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFrQiwrQkFBK0I7O0FBRWpEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEscUJBQW9CLHNCQUFzQjs7QUFFMUM7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1CQUFrQiwrQkFBK0I7O0FBRWpEOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBa0IsK0JBQStCOztBQUVqRDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1CQUFrQix1QkFBdUI7O0FBRXpDOztBQUVBOztBQUVBLG1CQUFrQiw0QkFBNEI7O0FBRTlDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFjLG1CQUFtQjs7QUFFakM7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsd0JBQXVCLHVCQUF1Qjs7QUFFOUM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsTUFBSzs7QUFFTDs7QUFFQTs7O0FBR0EsaUJBQWdCLFlBQVk7O0FBRTVCLGtCQUFpQixtQkFBbUI7O0FBRXBDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDBDQUF5QyxXQUFXOztBQUVwRDs7QUFFQTs7QUFFQSxPQUFNOztBQUVOOztBQUVBOztBQUVBOztBQUVBOztBQUVBLFlBQVc7QUFDWDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBeUMsV0FBVzs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDBDQUF5QyxXQUFXOztBQUVwRDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLE1BQUs7O0FBRUw7O0FBRUE7O0FBRUEsTUFBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBLGtCQUFpQixnQkFBZ0I7O0FBRWpDOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDRDQUEyQyxXQUFXOztBQUV0RDtBQUNBO0FBQ0E7O0FBRUEsbUJBQWtCLHlCQUF5Qjs7QUFFM0M7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxTQUFROztBQUVSOztBQUVBOztBQUVBLFVBQVM7O0FBRVQ7O0FBRUE7O0FBRUEsU0FBUTs7QUFFUjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxNQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBa0Isd0JBQXdCOztBQUUxQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFrQiwrQkFBK0I7O0FBRWpEOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBa0IsK0JBQStCOztBQUVqRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBa0IsK0JBQStCOztBQUVqRDs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUJBQWtCLCtCQUErQjs7QUFFakQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsc0JBQXFCLDZCQUE2Qjs7QUFFbEQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG9CQUFtQixpQ0FBaUM7O0FBRXBEOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxxQkFBb0Isc0JBQXNCOztBQUUxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFrQiwrQkFBK0I7O0FBRWpEOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBa0IsK0JBQStCOztBQUVqRDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1CQUFrQiwrQkFBK0I7O0FBRWpEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsT0FBTTs7QUFFTjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBa0IsK0JBQStCOztBQUVqRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsWUFBVzs7QUFFWDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLFFBQU87O0FBRVA7O0FBRUE7O0FBRUEsU0FBUTs7QUFFUjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBMkM7QUFDM0M7O0FBRUE7O0FBRUEsZ0RBQStDO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBa0IsK0JBQStCOztBQUVqRDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLG1CQUFrQiwrQkFBK0I7O0FBRWpEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsbUJBQWtCLCtCQUErQjs7QUFFakQ7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUJBQWtCLCtCQUErQjs7QUFFakQ7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBa0IsK0JBQStCOztBQUVqRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1CQUFrQiwrQkFBK0I7O0FBRWpEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUJBQWtCLCtCQUErQjs7QUFFakQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1CQUFrQiwrQkFBK0I7O0FBRWpEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsT0FBTTs7QUFFTjs7QUFFQSx1QkFBc0Isb0NBQW9DOztBQUUxRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsbUJBQWtCLCtCQUErQjs7QUFFakQ7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBa0IsK0JBQStCOztBQUVqRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxzQkFBcUIsNkJBQTZCOztBQUVsRDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUJBQWtCLCtCQUErQjs7QUFFakQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBaUIsK0JBQStCOztBQUVoRDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxrQkFBaUIsK0JBQStCOztBQUVoRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBaUIsdUJBQXVCOztBQUV4Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWlCLCtCQUErQjs7QUFFaEQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWlCLCtCQUErQjs7QUFFaEQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLG1DQUFrQyxPQUFPOztBQUV6Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLG1DQUFrQyxPQUFPOztBQUV6Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLG1DQUFrQyxPQUFPOztBQUV6Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxnQkFBZTs7QUFFZjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsRUFBQyxHQUFHO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSCxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQWtCLGtCQUFrQjs7QUFFcEM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxhQUFZO0FBQ1o7O0FBRUEsS0FBSTs7QUFFSjs7QUFFQTtBQUNBOztBQUVBLE1BQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSx1Q0FBc0M7O0FBRXRDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRTs7O0FBR0Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBQyxHQUFHO0FBQ0o7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxJQUFHOztBQUVILEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSTs7QUFFSjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxNQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLE1BQUs7O0FBRUw7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1CQUFrQixrQkFBa0I7O0FBRXBDO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSTs7QUFFSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUk7O0FBRUo7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFJOztBQUVKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUk7O0FBRUo7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUk7O0FBRUo7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSTs7QUFFSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUk7O0FBRUo7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLE1BQUs7O0FBRUw7O0FBRUE7O0FBRUEsS0FBSTs7QUFFSjs7QUFFQTs7QUFFQSxLQUFJOztBQUVKOztBQUVBLEtBQUk7O0FBRUo7O0FBRUE7O0FBRUEsS0FBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx1Q0FBc0MsT0FBTzs7QUFFN0M7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFDLEdBQUc7QUFDSix1QkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTs7QUFFQSxjQUFhOztBQUViOztBQUVBOztBQUVBOztBQUVBLEVBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsMENBQXlDLFNBQVM7O0FBRWxEOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHFEQUFvRCxtQkFBbUI7O0FBRXZFO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxnQkFBZTs7QUFFZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFvQzs7QUFFcEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQSxJQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEtBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsZ0NBQStCOztBQUUvQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxJQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBLHlEQUF3RDtBQUN4RCx5Q0FBd0M7QUFDeEMseUNBQXdDOztBQUV4Qzs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLGNBQWEsWUFBWTs7QUFFekI7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHdCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxNQUFLOztBQUVMOztBQUVBOztBQUVBLEtBQUk7O0FBRUo7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsMkJBQTBCO0FBQzFCLDJCQUEwQjtBQUMxQjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsSUFBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSwyQkFBMEI7QUFDMUIsMkJBQTBCO0FBQzFCLDJCQUEwQjtBQUMxQjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsbUVBQWtFOztBQUVsRTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSwyQkFBMEI7QUFDMUIsMkJBQTBCO0FBQzFCLDJCQUEwQjtBQUMxQiwyQkFBMEI7QUFDMUI7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLElBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLGlCQUFnQjs7QUFFaEI7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxLQUFJOztBQUVKOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxLQUFJOztBQUVKOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxnQkFBZTs7QUFFZjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsMkNBQTBDOztBQUUxQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxLQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEtBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQSxJQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBLElBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxLQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEtBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQSxJQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBLElBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLElBQUc7O0FBRUg7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLHVDQUFzQyxRQUFROztBQUU5Qzs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBcUMsUUFBUTs7QUFFN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLHVDQUFzQyxRQUFROztBQUU5Qzs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxLQUFJOztBQUVKOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsSUFBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsSUFBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsSUFBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGlGQUFnRjtBQUNoRixpRkFBZ0Y7QUFDaEYsaUZBQWdGO0FBQ2hGLGlGQUFnRjtBQUNoRixpRkFBZ0Y7QUFDaEYsaUZBQWdGO0FBQ2hGLGlGQUFnRjtBQUNoRixpRkFBZ0Y7O0FBRWhGO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsaUJBQWdCLGVBQWU7QUFDL0IsaUJBQWdCLGVBQWU7QUFDL0IsaUJBQWdCLGVBQWU7O0FBRS9COztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFD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QTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUEsZ0JBQWUsY0FBYztBQUM3QixnQkFBZSxjQUFjO0FBQzdCLGdCQUFlLGNBQWM7QUFDN0IsZ0JBQWUsY0FBYzs7QUFFN0I7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEseUNBQXdDOztBQUV4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWMsYUFBYSxhQUFhO0FBQ3hDLGVBQWMsYUFBYSxhQUFhO0FBQ3hDLGVBQWMsYUFBYSxjQUFjO0FBQ3pDLGVBQWMsYUFBYSxnQkFBZ0I7O0FBRTNDOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQWtCLGFBQWEsYUFBYTtBQUM1QyxlQUFjLGlCQUFpQixhQUFhO0FBQzVDLGVBQWMsYUFBYSxvQkFBb0I7QUFDL0MsZUFBYyxhQUFhLGNBQWM7O0FBRXpDOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQSxtQkFBa0IsUUFBUTs7QUFFMUI7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQU87O0FBRVA7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLE9BQU07O0FBRU47O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLE1BQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE9BQU07O0FBRU47O0FBRUE7QUFDQTtBQUNBOztBQUVBLE9BQU07O0FBRU47O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEtBQUk7O0FBRUo7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7Ozs7QUFJRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLElBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLElBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsSUFBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEtBQUk7O0FBRUo7QUFDQTs7QUFFQSxLQUFJOztBQUVKOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUEsd0NBQXVDLFFBQVE7O0FBRS9DOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLG1CQUFrQixPQUFPOztBQUV6Qjs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1CQUFrQixPQUFPOztBQUV6Qjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsb0JBQW1CLFFBQVE7O0FBRTNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7OztBQUdGOztBQUVBOztBQUVBLG1CQUFrQixPQUFPOztBQUV6Qjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0EsOENBQTZDOztBQUU3Qzs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsb0JBQW1CLFFBQVE7O0FBRTNCOztBQUVBOztBQUVBLE1BQUs7O0FBRUw7O0FBRUEsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxvQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsbUJBQWtCLGNBQWM7O0FBRWhDLHdCQUF1Qjs7QUFFdkI7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsZUFBYyxPQUFPOztBQUVyQjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxlQUFjLGNBQWM7O0FBRTVCOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLFdBQVU7O0FBRVY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsZUFBYyx3QkFBd0I7O0FBRXRDO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxnQkFBZSxrQkFBa0I7O0FBRWpDOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEVBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBQzs7QUFFRDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBa0MsRUFBRTs7QUFFcEM7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLHFDQUFvQzs7QUFFcEM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsZUFBYztBQUNkOztBQUVBOztBQUVBOztBQUVBLG1DQUFrQyxFQUFFOztBQUVwQzs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLHFDQUFvQzs7QUFFcEM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLE1BQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsT0FBTTs7QUFFTjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEtBQUk7O0FBRUo7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7O0FBRUEsc0JBQXFCOztBQUVyQjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFrQixjQUFjOztBQUVoQzs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsRUFBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxtQkFBa0IsY0FBYzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbUJBQWtCLGNBQWM7O0FBRWhDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLG1DQUFrQyxnQkFBZ0I7O0FBRWxEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW1CLFlBQVk7O0FBRS9COztBQUVBOztBQUVBLG9CQUFtQixZQUFZOztBQUUvQjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFlBQVc7QUFDWCxZQUFXO0FBQ1gsV0FBVTtBQUNWLGFBQVksZUFBZTtBQUMzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx5Q0FBd0MsT0FBTzs7QUFFL0M7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEtBQUk7O0FBRUo7QUFDQTs7QUFFQSxLQUFJOztBQUVKOztBQUVBOztBQUVBLElBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLHdDQUF1QyxPQUFPOztBQUU5Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHNDQUFxQyxrQ0FBa0M7O0FBRXZFOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxvQkFBbUIsc0JBQXNCOztBQUV6Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsMkJBQTBCLGdCQUFnQjs7QUFFMUM7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLG9CQUFtQixzQkFBc0I7O0FBRXpDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDJCQUEwQixrQkFBa0I7O0FBRTVDOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLDZDQUE0QyxPQUFPOztBQUVuRDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRix5QkFBd0I7O0FBRXhCOztBQUVBOztBQUVBOztBQUVBLHdDQUF1QyxPQUFPOztBQUU5Qzs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHdDQUF1QyxPQUFPOztBQUU5Qzs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDZDQUE0QyxPQUFPOztBQUVuRDs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBa0I7QUFDbEIsa0JBQWlCO0FBQ2pCLGlCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLCtDQUE4QztBQUM5QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsb0JBQW1CLDBCQUEwQjs7QUFFN0M7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsb0JBQW1CLDRCQUE0Qjs7QUFFL0M7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEscURBQW9ELFFBQVE7O0FBRTVEOztBQUVBOztBQUVBLG9EQUFtRCxRQUFROztBQUUzRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHNCQUFxQjs7QUFFckI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUEsc0NBQXFDLE9BQU87O0FBRTVDOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxzQ0FBcUMsT0FBTzs7QUFFNUM7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSx1Q0FBc0MsT0FBTzs7QUFFN0M7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsdUNBQXNDLE9BQU87O0FBRTdDOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLHVDQUFzQyxPQUFPOztBQUU3Qzs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLHVDQUFzQyxPQUFPOztBQUU3Qzs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBcUI7O0FBRXJCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQSxvQ0FBbUMsT0FBTzs7QUFFMUM7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxzQ0FBcUMsa0NBQWtDOztBQUV2RTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDhDQUE2QyxRQUFROztBQUVyRDtBQUNBOztBQUVBOztBQUVBLDJDQUEwQyxRQUFROztBQUVsRDtBQUNBOztBQUVBLG9EQUFtRCxRQUFROztBQUUzRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFF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QUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFtQjs7QUFFbkI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLElBQUc7O0FBRUgsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsNkNBQTRDLE9BQU87O0FBRW5EOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSw0Q0FBMkMsUUFBUTs7QUFFbkQ7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUk7O0FBRUo7O0FBRUE7O0FBRUEsd0NBQXVDLFFBQVE7O0FBRS9DOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHlDQUF3QyxRQUFROztBQUVoRDs7QUFFQTtBQUNBOztBQUVBLDhDQUE2QyxRQUFROztBQUVyRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFJOztBQUVKOztBQUVBLDRDQUEyQyxRQUFROztBQUVuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FB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QUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQSxtQkFBa0Isc0JBQXNCOztBQUV4Qzs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2Q0FBNEMsUUFBUTs7QUFFcEQ7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxtQkFBa0IsNEJBQTRCOztBQUU5Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQW9CLDBCQUEwQjs7QUFFOUM7O0FBRUEsdUJBQXNCLDBDQUEwQzs7QUFFaEU7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbURBQWtEOztBQUVsRDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSTtBQUNKOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUM7OztBQUdEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNB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R0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxZQUFXOztBQUVYOztBQUVBOztBQUVBLDJCQUEwQjtBQUMxQjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSw2Q0FBNEMsU0FBUzs7QUFFckQ7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxPQUFNOztBQUVOO0FBQ0E7O0FBRUE7O0FB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R0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0Esd0NBQXVDLFNBQVM7O0FBRWhEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRTs7O0FBR0Y7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQSxFQUFDOzs7QUFHRDs7QUFFQTtBQUNB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Yzs7QUFFbkM7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLElBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUNBQWtDOztBQUVsQzs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsbUJBQWtCLDJCQUEyQjs7QUFFN0M7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsbUJBQWtCLHFCQUFxQjs7QUFFdkM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxrREFBaUQ7O0FBRWpEO0FBQ0E7O0FBRUEsb0RBQW1EOztBQUVuRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxvQkFBbUIsY0FBYzs7QUFFakM7O0FBRUE7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLDZDQUE0QyxTQUFTOztBQUVyRDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsaURBQWdELFNBQVM7O0FBRXpEOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEdBQUU7OztBQUdGOztBQUVBOztBQUVBOztBQUVBLG9CQUFtQixjQUFjOztBQUVqQzs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxtQkFBa0IsY0FBYzs7QUFFaEM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxFQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUEsRUFBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxvQkFBbUIsaUNBQWlDOztBQUVwRDs7QUFFQTs7QUFFQTs7QUFFQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEVBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBQzs7QUFFRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFDOztBQUVEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFnQjs7QUFFaEI7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsbURBQWtEOztBQUVsRDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbURBQWtEOztBQUVsRDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxXQUFVOztBQUVWOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxtQkFBa0Isc0JBQXNCOztBQUV4Qzs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLE1BQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSx3Q0FBdUMsT0FBTzs7QUFFOUM7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsTUFBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQSxLQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxJQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxNQUFLOztBQUVMLEtBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQSxLQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLElBQUc7O0FBRUgsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVB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QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxJQUFHOztBQUVILEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXNDLFNBQVM7O0FBRS9DOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSCxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLCtDQUE4QyxPQUFPOztBQUVyRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLElBQUc7O0FBRUgsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxxQ0FBb0MsT0FBTzs7QUFFM0M7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEscUNBQW9DLE9BQU87O0FBRTNDO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxtQkFBa0IsaUJBQWlCOztBQUVuQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHFDQUFvQyxPQUFPOztBQUUzQztBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEscUNBQW9DLE9BQU87O0FBRTNDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxPQUFNOztBQUVOOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEtBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxxQkFBb0IsbUJBQW1COztBQUV2QztBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVB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QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUEsd0JBQXVCLGlCQUFpQjs7QUFFeEMsR0FBRTs7QUFFRjs7QUFFQSx3QkFBdUIsa0JBQWtCOztBQUV6Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSwyQ0FBMEM7O0FBRTFDOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsMkNBQTBDOztBQUUxQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDJDQUEwQztBQUMxQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDJDQUEwQztBQUMxQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFD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OztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsNENBQTJDOztBQUUzQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBLHdCQUF1QixrQkFBa0I7O0FBRXpDLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsT0FBTTs7QUFFTjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxPQUFNOztBQUVOOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNB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RUE7O0FBRUE7O0FBRUE7QUFDQSxvRkFBbUYsa0NBQWtDOztBQUVySDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwyREFBMEQsUUFBUTs7QUFFbEU7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEseUNBQXdDLE9BQU87O0FBRS9DO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxvREFBbUQ7QUFDbkQ7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSTs7O0FBR0osMkNBQTBDLE9BQU87O0FBRWpEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSw4QkFBNkI7QUFDN0I7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDtBQUNB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RUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxXQUFVLFFBQVE7O0FBRWxCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG9CQUFtQixPQUFPOztBQUUxQjtBQUNBOztBQUVBOztBQUVBLElBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsMkNBQTBDLE9BQU87O0FBRWpEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHNEQUFxRCxPQUFPOztBQUU1RDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGlEQUFnRCxPQUFPOztBQUV2RDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsTUFBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxJQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEtBQUk7O0FBRUo7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7OztBQUdBLElBQUc7O0FBRUg7O0FBRUEsaURBQWdEOztBQUVoRDs7QUFFQTs7QUFFQTs7QUFFQSxLQUFJOztBQUVKOztBQUVBOztBQUVBLElBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLFFBQU87O0FBRVA7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxPQUFNOztBQUVOOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLFFBQU87O0FBRVA7O0FBRUE7O0FBRUE7QUFDQSxxR0FBb0c7O0FBRXBHOztBQUVBLE1BQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFHOztBQUVIOztBQUVBLElBQUc7O0FBRUg7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFHOztBQUVIOztBQUVBLElBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLElBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQSxLQUFJOztBQUVKOztBQUVBLEtBQUk7O0FBRUo7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSwyQ0FBMEMsT0FBTzs7QUFFakQ7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxRQUFPOztBQUVQOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHdDQUF1QyxPQUFPOztBQUU5Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSwwQ0FBeUMsT0FBTzs7QUFFaEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxNQUFLOztBQUVMLEtBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsSUFBRzs7QUFFSDtBQUNBOztBQUVBLElBQUc7O0FBRUg7QUFDQTs7QUFFQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsb0JBQW1CLDJCQUEyQjs7QUFFOUM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsb0JBQW1CLDJCQUEyQjs7QUFFOUM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxnRUFBK0QsUUFBUTs7QUFFdkU7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDRCQUEyQjtBQUMzQiwwQkFBeUI7O0FBRXpCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSTs7QUFFSjtBQUNBOztBQUVBLEtBQUk7O0FBRUo7O0FBRUEsS0FBSTs7QUFFSjs7QUFFQSxLQUFJOztBQUVKOztBQUVBLEtBQUk7O0FBRUo7O0FBRUEsS0FBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUEsS0FBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx5Q0FBd0MsUUFBUTs7QUFFaEQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUc7O0FBRUg7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQSxJQUFHOztBQUVIOztBQUVBLElBQUc7O0FBRUg7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQSxJQUFHOztBQUVIOztBQUVBLElBQUc7O0FBRUg7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxREFBb0Q7O0FBRXBEOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxJQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxtRUFBa0U7O0FBRWxFOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSw4Q0FBNkM7QUFDN0M7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEseUNBQXdDLFFBQVE7O0FBRWhEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxzQkFBcUIsa0JBQWtCOztBQUV2Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGlEQUFnRCxRQUFROztBQUV4RDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGlEQUFnRCxRQUFROztBQUV4RDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsaURBQWdELFFBQVE7O0FBRXhEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx5Q0FBd0MsUUFBUTs7QUFFaEQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx5Q0FBd0MsUUFBUTs7QUFFaEQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLE9BQU07O0FBRU47O0FBRUEsT0FBTTs7QUFFTjs7QUFFQSxPQUFNOztBQUVOOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGlEQUFnRCxRQUFROztBQUV4RDs7QUFFQTs7QUFFQTs7QUFFQSxpREFBZ0QsUUFBUTs7QUFFeEQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLFFBQU87O0FBRVA7O0FBRUEsUUFBTzs7QUFFUDs7QUFFQSxRQUFPOztBQUVQOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsbUNBQWtDLFFBQVE7O0FBRTFDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSTs7QUFFSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSTs7QUFFSjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSTs7QUFFSjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSTs7QUFFSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQTs7QUFFQSxLQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUk7O0FBRUo7O0FBRUEsS0FBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsMENBQXlDLFFBQVE7O0FBRWpEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSTs7QUFFSjs7QUFFQTs7QUFFQSxJQUFHOztBQUVILHlDQUF3QyxRQUFROztBQUVoRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxPQUFNOztBQUVOOztBQUVBOztBQUVBLE1BQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsMENBQXlDLFFBQVE7O0FBRWpEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLHFCQUFvQixPQUFPOztBQUUzQjs7QUFFQTs7QUFFQSxPQUFNOztBQUVOOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHFCQUFvQixPQUFPOztBQUUzQjs7QUFFQTs7QUFFQTs7QUFFQSxRQUFPOztBQUVQOztBQUVBOztBQUVBLE9BQU07O0FBRU47O0FBRUEsNENBQTJDLFFBQVE7O0FBRW5EOztBQUVBOztBQUVBOztBQUVBOztBQUVBLFVBQVM7O0FBRVQ7O0FBRUE7O0FBRUEsU0FBUTs7QUFFUjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsSUFBRzs7QUFFSDtBQUNBOztBQUVBLElBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG9CQUFtQixPQUFPOztBQUUxQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsb0JBQW1CLE9BQU87O0FBRTFCOztBQUVBOztBQUVBLElBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxvQkFBbUIsT0FBTzs7QUFFMUI7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSTs7QUFFSjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLElBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLE1BQUs7O0FBRUw7O0FBRUE7O0FBRUEsS0FBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBLHdCQUF1QixrQkFBa0I7O0FBRXpDOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSwwQkFBeUI7O0FBRXpCOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHNDQUFxQyxPQUFPOztBQUU1Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUEsK0JBQThCOztBQUU5Qjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxzQ0FBcUMsT0FBTzs7QUFFNUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxJQUFHOztBQUVIOztBQUVBLGtEQUFpRCxPQUFPOztBQUV4RDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsOEJBQTZCO0FBQzdCLGtDQUFpQzs7QUFFakM7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQSxJQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxNQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBRzs7O0FBR0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEVBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBa0IsMkJBQTJCOztBQUU3QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSx5Q0FBd0MsUUFBUTs7QUFFaEQ7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1CQUFrQixrQkFBa0I7O0FBRXBDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBaUIsaUNBQWlDOztBQUVsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHdDQUF1QyxRQUFROztBQUUvQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBOztBQUVBLGlCQUFnQjs7QUFFaEI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx1QkFBc0Isa0JBQWtCOztBQUV4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLE1BQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSw4Q0FBNkMsUUFBUTs7QUFFckQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsMkNBQTBDLFFBQVE7O0FBRWxEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxPQUFNOztBQUVOO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx3Q0FBdUMsT0FBTzs7QUFFOUM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLDZDQUE0QyxPQUFPOztBQUVuRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGlEQUFnRCxPQUFPOztBQUV2RDs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEscUJBQW9CLG9CQUFvQjs7QUFFeEM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEtBQUk7O0FBRUo7O0FBRUE7QUFDQTs7QUFFQSxLQUFJOztBQUVKOztBQUVBO0FBQ0E7O0FBRUEsS0FBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG9CQUFtQjtBQUNuQjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNB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QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxpRUFBZ0U7O0FBRWhFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSTs7QUFFSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBLHVDQUFzQyxPQUFPOztBQUU3Qzs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHVDQUFzQyxPQUFPOztBQUU3QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLHFEQUFvRDs7QUFFcEQsa0NBQWlDO0FBQ2pDLG1DQUFrQztBQUNsQyw0QkFBMkI7QUFDM0Isd0JBQXVCO0FBQ3ZCLDJCQUEwQjtBQUMxQiwwQkFBeUI7O0FBRXpCLDZCQUE0QjtBQUM1Qix1QkFBc0I7O0FBRXRCLHNCQUFxQjs7QUFFckIsa0JBQWlCOztBQUVqQixvQ0FBbUM7O0FBRW5DLDhDQUE2Qzs7QUFFN0MsMkJBQTBCO0FBQzFCLG9HQUFtRztBQUNuRyxvR0FBbUc7O0FBRW5HLHlCQUF3Qjs7QUFFeEIsbUVBQWtFO0FBQ2xFLDBDQUF5QztBQUN6Qyx1REFBc0Q7O0FBRXRELGtDQUFpQzs7QUFFakMsTUFBSzs7QUFFTDs7QUFFQTs7QUFFQSxxREFBb0Q7O0FBRXBELHdCQUF1QjtBQUN2QiwyQkFBMEI7QUFDMUIsMkJBQTBCOztBQUUxQix5QkFBd0I7QUFDeEIsMkJBQTBCO0FBQzFCLDhCQUE2QjtBQUM3QiwyQkFBMEI7QUFDMUIsMEJBQXlCO0FBQ3pCLDZCQUE0Qjs7QUFFNUIsc0JBQXFCOztBQUVyQixrQkFBaUI7O0FBRWpCLDJDQUEwQzs7QUFFMUMsMkNBQTBDOztBQUUxQyxzRUFBcUU7O0FBRXJFLDBCQUF5Qjs7QUFFekIscURBQW9EO0FBQ3BELDZCQUE0Qjs7QUFFNUIsNEJBQTJCOztBQUUzQix5REFBd0Q7O0FBRXhELFFBQU8sT0FBTzs7QUFFZCxvQ0FBbUM7QUFDbkMsNkVBQTRFO0FBQzVFLHVEQUFzRDs7QUFFdEQsUUFBTzs7QUFFUCx1RkFBc0Y7O0FBRXRGLE9BQU07O0FBRU4sTUFBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQSxJQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSwrQkFBOEI7QUFDOUIsbUNBQWtDO0FBQ2xDLGlDQUFnQztBQUNoQywrQkFBOEI7O0FBRTlCOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7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QUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEseUJBQXdCOztBQUV4Qjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSwwQ0FBeUMsT0FBTzs7QUFFaEQ7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEscUNBQW9DLE9BQU87O0FBRTNDO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLG9CQUFtQixrQkFBa0I7O0FBRXJDO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7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QTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLHlDQUF3QztBQUN4QztBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQSxnQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxJQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEtBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQSx1QkFBc0I7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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBaUIsb0JBQW9COztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQWtCLHFCQUFxQjs7QUFFdkM7QUFDQSxvQ0FBbUM7QUFDbkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsa0JBQWlCLG9CQUFvQjs7QUFFckMsbUJBQWtCLHFCQUFxQjs7QUFFdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxjQUFhLGVBQWU7O0FBRTVCOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxlQUFjLG9CQUFvQjs7QUFFbEM7O0FBRUEsNkJBQTRCO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQSxjQUFhLGNBQWM7O0FBRTNCLGVBQWMsb0JBQW9COztBQUVsQztBQUNBOztBQUVBLHVCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxjQUFhLGVBQWU7O0FBRTVCOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwwRUFBeUU7QUFDekU7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUEsY0FBYSxlQUFlOztBQUU1Qjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSw0RkFBMkY7O0FBRTNGOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGVBQWMsZUFBZTs7QUFFN0I7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsdUNBQXNDLE9BQU87O0FBRTdDOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDZDQUE0QyxPQUFPOztBQUVuRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsb0NBQW1DLE9BQU87O0FBRTFDOztBQUVBOzs7QUFHQTs7QUFFQSxzREFBcUQsT0FBTzs7QUFFNUQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQSw0Q0FBMkMsT0FBTzs7QUFFbEQ7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLG9CQUFtQixXQUFXOztBQUU5Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW1CLFdBQVc7O0FBRTlCOztBQUVBOztBQUVBLE1BQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUJBQWtCLFdBQVc7O0FBRTdCLG9CQUFtQiwwQkFBMEI7O0FBRTdDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLGNBQWEsYUFBYTs7QUFFMUI7O0FBRUEsZUFBYyxhQUFhOztBQUUzQjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsY0FBYSxZQUFZOztBQUV6QixlQUFjLFlBQVk7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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QTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSwrR0FBOEcsZUFBZTs7QUFFN0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHFEQUFvRCxRQUFROztBQUU1RDtBQUNBOztBQUVBOztBQUVBOztBQUVBLHdEQUF1RDs7QUFFdkQ7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1EQUFrRCxRQUFROztBQUUxRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLElBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBOztBQUVBLEVBQUMsR0FBRztBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBQzs7QUFFRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFHOztBQUVIOztBQUVBOztBQUVBLElBQUc7O0FBRUg7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLE1BQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxFQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxxQ0FBb0M7QUFDcEM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSw2REFBNEQsc0JBQXNCOztBQUVsRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQSwrREFBOEQsc0JBQXNCOztBQUVwRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxJQUFHOztBQUVIOztBQUVBOztBQUVBLElBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLElBQUc7O0FBRUg7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQTs7QUFFQSxJQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxJQUFHOztBQUVIOztBQUVBOztBQUVBLElBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLElBQUc7O0FBRUg7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLElBQUc7O0FBRUg7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLElBQUc7O0FBRUg7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCLE9BQU8sV0FBVztBQUN6QztBQUNBOztBQUVBLElBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCLE9BQU8sV0FBVztBQUN6QztBQUNBOztBQUVBLElBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCLE9BQU8sV0FBVztBQUN6QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLElBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQSxJQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLElBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSTs7QUFFSjs7QUFFQSxLQUFJOztBQUVKOztBQUVBLEtBQUk7O0FBRUo7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxlQUFjLFFBQVE7QUFDdEI7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLElBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQSxJQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxpQkFBZ0IsT0FBTztBQUN2Qjs7QUFFQTs7QUFFQSxJQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVILEdBQUU7O0FBRUY7QUFDQTs7QUFFQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7O0FBRUEsRUFBQzs7QUFFRCxFQUFDLEdBQUc7QUFDSixvQkFBbUIsZ0JBQWdCLFVBQVUsVUFBVSwwQ0FBMEMsd0JBQXdCLG9CQUFvQiw4Q0FBOEMsa0NBQWtDLFlBQVksWUFBWSxtQ0FBbUMsaUJBQWlCLGdCQUFnQixzQkFBc0Isb0JBQW9CLDBDQUEwQyxZQUFZLFdBQVcsWUFBWSxTQUFTLEdBQUc7QUFDNWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEVBQUMsR0FBRztBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUMsRUFBRSxjQUFjO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQSxFQUFDLEVBQUUsMERBQTBEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQVksY0FBYyxRQUFRLGlCQUFpQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQSxFQUFDLEVBQUUsOEhBQThIO0FBQ2pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsRUFBQyxFQUFFLHlCQUF5QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBWSxjQUFjLFFBQVEsaUJBQWlCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCQUF3QjtBQUN4QjtBQUNBLElBQUcsNEJBQTRCO0FBQy9CO0FBQ0EsSUFBRyw0QkFBNEI7QUFDL0I7QUFDQSxJQUFHLDRCQUE0QjtBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUMsRUFBRSxpREFBaUQ7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBLEVBQUMsRUFBRSxvQkFBb0I7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFDLEdBQUc7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsTUFBSzs7QUFFTDs7QUFFQTs7QUFFQSxLQUFJOztBQUVKOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxJQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRixrQ0FBaUM7O0FBRWpDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLDJCQUEwQjtBQUMxQiwyQkFBMEI7QUFDMUI7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLDJCQUEwQjtBQUMxQiwyQkFBMEI7QUFDMUIsMkJBQTBCO0FBQzFCOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsbUVBQWtFOztBQUVsRTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEtBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQSxJQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBLElBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxLQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEtBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQSxJQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBLElBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxLQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUEsSUFBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLElBQUc7O0FBRUg7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGLGtDQUFpQzs7QUFFakM7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLG9CQUFtQixRQUFROztBQUUzQjs7QUFFQTs7QUFFQSxNQUFLOztBQUVMOztBQUVBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBQyxHQUFHO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUMsRUFBRSxtQ0FBbUM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Szs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxvREFBbUQsUUFBUTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEIsa0JBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSw0QkFBMkIseUNBQXlDO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0Esb0RBQW1ELGNBQWM7QUFDakUsUUFBTztBQUNQO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0Esb0RBQW1ELGFBQWE7QUFDaEUsUUFBTztBQUNQO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILEVBQUM7O0FBRUQ7QUFDQSx5QkFBd0I7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLFFBQVE7QUFDbkIsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEI7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxJQUFHO0FBQ0g7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWlDO0FBQ2pDO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF1QixRQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFpQztBQUNqQztBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLGNBQWE7QUFDYjtBQUNBO0FBQ0Esd0JBQXVCLGFBQWE7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1gsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUMsRUFBRSxnSEFBZ0g7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXVCLGlCQUFpQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDs7QUFFQTtBQUNBLG9CQUFtQixtQkFBbUI7QUFDdEM7QUFDQTs7QUFFQTtBQUNBLG9CQUFtQixtQkFBbUI7QUFDdEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQStCLFFBQVE7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsSUFBRztBQUNILEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsSUFBRztBQUNILEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsWUFBVyxRQUFRO0FBQ25CLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBOEIsa0JBQWtCLEVBQUU7QUFDbEQsb0JBQW1CLGlCQUFpQixFQUFFOztBQUV0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCLHdCQUF3QjtBQUM3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUEsRUFBQyxFQUFFLCtFQUErRTtBQUNsRjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCLFdBQVc7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUIscUJBQXFCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBLElBQUc7QUFDSCxFQUFDOztBQUVELEVBQUMsRUFBRSwrQ0FBK0M7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWSxPQUFPO0FBQ25CLGFBQVksT0FBTztBQUNuQixhQUFZLE1BQU07QUFDbEIsYUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXNDLGFBQWE7QUFDbkQ7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTJDLFFBQVE7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFtRCxvQ0FBb0MsRUFBRTtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBb0QsMkJBQTJCLEVBQUU7QUFDakY7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1QsUUFBTztBQUNQO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLDhCQUE4QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBOztBQUVBLGNBQWEsT0FBTztBQUNwQixjQUFhLE9BQU87QUFDcEIsYUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW1DLFNBQVM7QUFDNUM7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF3QyxRQUFRO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsNEJBQTJCLFFBQVE7O0FBRW5DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBLGtEQUFpRCxvQkFBb0IsRUFBRTtBQUN2RTtBQUNBLE1BQUs7QUFDTDtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0EsZ0JBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFxQixxQkFBcUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUFzQyxRQUFROztBQUU5QztBQUNBLDhCQUE2Qix3Q0FBd0M7QUFDckU7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF1QixRQUFRO0FBQy9CO0FBQ0EsMkJBQTBCLFFBQVE7QUFDbEM7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSxPQUFPO0FBQ3BCLGNBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUEyQixRQUFRO0FBQ25DOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsUUFBTzs7QUFFUDtBQUNBLE1BQUs7QUFDTDtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCQUE0QixRQUFRO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsUUFBTzs7QUFFUDtBQUNBLE1BQUs7QUFDTDtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsY0FBYSxPQUFPO0FBQ3BCLGNBQWEsT0FBTztBQUNwQixjQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBc0Isb0NBQW9DO0FBQzFEO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUErQixtQkFBbUI7QUFDbEQ7QUFDQTtBQUNBLGNBQWEsT0FBTztBQUNwQjtBQUNBLGNBQWEsY0FBYztBQUMzQjtBQUNBLGNBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQStCO0FBQy9CLGdDQUErQjtBQUMvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSxPQUFPO0FBQ3BCLGdCQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFvRCxjQUFjO0FBQ2xFO0FBQ0EsTUFBSztBQUNMO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLE9BQU87QUFDcEIsZ0JBQWUsY0FBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUFzQiw0QkFBNEI7QUFDbEQ7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLDRCQUEyQixRQUFRO0FBQ25DO0FBQ0E7QUFDQSxnQ0FBK0IsYUFBYTtBQUM1QztBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsK0JBQThCLFFBQVE7QUFDdEM7QUFDQTtBQUNBLGtDQUFpQyxhQUFhO0FBQzlDO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsYUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxrREFBaUQsYUFBYTs7QUFFOUQ7QUFDQSwrQkFBOEIsYUFBYTs7QUFFM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxNQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWEscUJBQXFCO0FBQ2xDO0FBQ0EsbUJBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQixPQUFPO0FBQzVCLG9CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXdCLFFBQVE7QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUIsT0FBTztBQUM1QixvQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUM7QUFDRDs7QUFFQSxFQUFDLEVBQUUsMkZBQTJGO0FBQzlGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsUUFBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBLFFBQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBd0QsY0FBYztBQUN0RTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQsRUFBQyxFQUFFLHlEQUF5RDtBQUM1RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFpQztBQUNqQyxzQkFBcUIsMkJBQTJCO0FBQ2hEO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsZ0NBQStCLG1DQUFtQztBQUNsRTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWdELE9BQU87QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0EsMkJBQTBCO0FBQzFCLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCQUE2QixRQUFROztBQUVyQztBQUNBLHFEQUFvRCxrQkFBa0I7O0FBRXRFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQWtDLGtCQUFrQjtBQUNwRDtBQUNBLFlBQVc7QUFDWCxVQUFTOztBQUVUO0FBQ0Esb0JBQW1CLE1BQU07QUFDekI7QUFDQSxpQ0FBZ0M7QUFDaEMsVUFBUztBQUNULFFBQU87QUFDUDtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCLDBCQUEwQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFxRCxvQ0FBb0MsRUFBRTtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixxQkFBcUI7QUFDeEMseUNBQXdDLFFBQVE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIscUJBQXFCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsNkJBQTRCLFFBQVE7QUFDcEM7QUFDQSx3QkFBdUIsUUFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxnQ0FBK0IsNkJBQTZCO0FBQzVEO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIscUJBQXFCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLHlCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF1QixRQUFRO0FBQy9CLCtCQUE4QixRQUFRO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVCx1QkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBLDJCQUEwQjtBQUMxQixNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEI7QUFDQSxnQkFBZSxRQUFRLFdBQVc7QUFDbEM7QUFDQSxnQkFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFvQyxnQkFBZ0I7QUFDcEQscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEI7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQSxnQkFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILEVBQUM7O0FBRUQsRUFBQyxFQUFFLDBDQUEwQztBQUM3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsT0FBTztBQUNwQixjQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWEsT0FBTztBQUNwQixjQUFhLE9BQU87QUFDcEIsY0FBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBNkIscUJBQXFCOztBQUVsRDtBQUNBO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQVksT0FBTztBQUNuQixhQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQVksT0FBTztBQUNuQixhQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFZLE9BQU87QUFDbkIsYUFBWSxNQUFNO0FBQ2xCLGFBQVksT0FBTztBQUNuQixhQUFZLE9BQU87QUFDbkIsYUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQVksT0FBTztBQUNuQixhQUFZLE9BQU87QUFDbkIsYUFBWSxPQUFPO0FBQ25CLGFBQVksT0FBTztBQUNuQixhQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBc0MsUUFBUTtBQUM5QztBQUNBLHNDQUFxQyxRQUFRO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFZLE9BQU87QUFDbkIsYUFBWSxLQUFLO0FBQ2pCLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUEyQjtBQUMzQjtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBLEVBQUMsRUFBRSw0REFBNEQ7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaURBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZLE9BQU87QUFDbkI7QUFDQSxhQUFZLE9BQU87QUFDbkIsYUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsRUFBRTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCLGNBQWM7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLE9BQU87QUFDcEI7QUFDQSxnQ0FBK0IsY0FBYzs7QUFFN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsT0FBTztBQUNwQixjQUFhLE9BQU87QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUIsY0FBYzs7QUFFbkM7QUFDQTtBQUNBO0FBQ0EsdUJBQXNCLGNBQWM7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUIsY0FBYzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLE9BQU87QUFDcEIsY0FBYSxRQUFRO0FBQ3JCLGdCQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0EsZ0NBQStCLHFDQUFxQztBQUNwRTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSxPQUFPO0FBQ3BCLGdCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0Esb0NBQW1DLGFBQWE7O0FBRWhELGdDQUErQix3Q0FBd0M7QUFDdkU7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQSxvQ0FBbUMsYUFBYTtBQUNoRCwyQkFBMEI7QUFDMUIsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxjQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMEM7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkVBQTBFLFFBQVE7O0FBRWxGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0EseUNBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLG9DQUFtQyx1QkFBdUI7QUFDMUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLGNBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixZQUFXLFFBQVE7QUFDbkIsYUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVLFFBQVE7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUMsRUFBRSw0Q0FBNEM7QUFDL0M7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQThCLGFBQWE7QUFDM0MsK0JBQThCLG1CQUFtQjtBQUNqRCwrQkFBOEIseUJBQXlCOztBQUV2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0EsWUFBVyxTQUFTO0FBQ3BCLFlBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBNkIsY0FBYztBQUMzQyw2Q0FBNEMsV0FBVztBQUN2RDtBQUNBLHdCQUF1QixtQkFBbUI7QUFDMUM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF1QixlQUFlO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZSxhQUFhO0FBQzVCLG1DQUFrQyxjQUFjO0FBQ2hEO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZSxhQUFhO0FBQzVCLG1DQUFrQyxjQUFjO0FBQ2hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsa0JBQWtCO0FBQ2pDO0FBQ0Esb0NBQW1DLGFBQWE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsY0FBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQixxQkFBcUI7O0FBRXZDO0FBQ0EsWUFBVywrQkFBK0I7O0FBRTFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEVBQUMsRUFBRSxxQ0FBcUM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFZLE9BQU87QUFDbkIsYUFBWSxNQUFNO0FBQ2xCO0FBQ0EsYUFBWSxPQUFPO0FBQ25CLGFBQVksT0FBTztBQUNuQixhQUFZLEtBQUs7QUFDakIsYUFBWSxLQUFLO0FBQ2pCLGFBQVksT0FBTztBQUNuQixhQUFZLE9BQU87QUFDbkIsYUFBWSxPQUFPO0FBQ25CLGFBQVksS0FBSztBQUNqQixhQUFZLE9BQU87QUFDbkIsYUFBWSxPQUFPO0FBQ25CLGFBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVCxRQUFPO0FBQ1A7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGtDQUFpQyxRQUFRO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBLGdCQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFpRCxRQUFRO0FBQ3pEO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBOEIsZUFBZTtBQUM3QztBQUNBLE1BQUs7O0FBRUw7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBMkIsUUFBUTtBQUNuQztBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWlDLFFBQVE7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBbUMsUUFBUTs7QUFFM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsS0FBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUFzQixjQUFjO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWdDLFFBQVE7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkNBQTBDLFFBQVE7QUFDbEQ7QUFDQSxZQUFXO0FBQ1g7QUFDQSxzQ0FBcUMsUUFBUTtBQUM3QztBQUNBLFlBQVc7QUFDWDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQSxJQUFHO0FBQ0gsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQSxFQUFDLEVBQUUsa0xBQWtMO0FBQ3JMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXFCLFFBQVE7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQW9CLFFBQVE7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUMsRUFBRSxtQkFBbUI7QUFDdEI7O0FBRUE7QUFDQSxTQUFRLDZIQUE2SDs7QUFFckk7QUFDQSxTQUFRLCtDQUErQztBQUN2RCxTQUFRLHNDQUFzQztBQUM5QyxTQUFRLG9GQUFvRjtBQUM1Rjs7QUFFQTtBQUNBO0FBQ0EsU0FBUSxxREFBcUQ7QUFDN0QsU0FBUSxnRUFBZ0U7QUFDeEUsU0FBUSw4RUFBOEU7QUFDdEY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBeUIsa0VBQWtFO0FBQzNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBeUIsZ0VBQWdFO0FBQ3pGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0NBQXFDLFFBQVE7O0FBRTdDO0FBQ0EsZ0JBQWUsUUFBUTs7QUFFdkI7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFtQyxRQUFRO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQSxFQUFDLEVBQUUsa0JBQWtCO0FBQ3JCOztBQUVBO0FBQ0EseUJBQXdCLFFBQVE7O0FBRWhDO0FBQ0EsbURBQWtELG9CQUFvQixFQUFFO0FBQ3hFLGtEQUFpRCxvQkFBb0IsRUFBRTtBQUN2RTs7QUFFQSxFQUFDLEVBQUUsd0NBQXdDO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsY0FBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsUUFBUTtBQUNuQjtBQUNBLFlBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUEsMkRBQTBELGlCQUFpQjs7QUFFM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBLCtCQUE4QixRQUFROztBQUV0QztBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQWtDLGNBQWM7QUFDaEQsc0NBQXFDLGNBQWM7QUFDbkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNEIsaURBQWlEO0FBQzdFO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFrQyxjQUFjO0FBQ2hEO0FBQ0EseUJBQXdCLDhCQUE4QjtBQUN0RDtBQUNBO0FBQ0E7O0FBRUEsRUFBQyxFQUFFLDBDQUEwQztBQUM3Qzs7QUFFQTtBQUNBLDJDQUEwQztBQUMxQyxtREFBa0Q7QUFDbEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLEVBQUU7O0FBRWI7QUFDQSxtQkFBa0I7QUFDbEIsK0VBQThFO0FBQzlFLE9BQU07O0FBRU47QUFDQSxtQkFBa0I7QUFDbEIsNkNBQTRDO0FBQzVDLE9BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFvQyxRQUFRO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFvRCxRQUFRO0FBQzVELGdEQUErQyxRQUFRO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixjQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSw0QkFBMkIsbUJBQW1CO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUMsRUFBRSxnQ0FBZ0M7QUFDbkM7QUFDQSwyQ0FBMEM7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWSxPQUFPO0FBQ25CLGFBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxtQkFBa0IsNkNBQTZDO0FBQy9EOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCLGNBQWM7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLE9BQU87QUFDcEIsY0FBYSxPQUFPO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCLGNBQWM7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBLHVCQUFzQjtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLGNBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTJCLG1CQUFtQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWEsbUJBQW1CLE9BQU8sNEJBQTRCO0FBQ25FOztBQUVBLEVBQUMsRUFBRSxpQkFBaUI7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZLE9BQU87QUFDbkIsYUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSx5QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUF5QixzQkFBc0I7QUFDL0MsNEJBQTJCLHVCQUF1QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdEQUErQyxVQUFVOztBQUV6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsSUFBRztBQUNILEVBQUM7O0FBRUQsRUFBQyxFQUFFLDBEQUEwRDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakIsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxnQ0FBK0IsY0FBYztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBQyxHQUFHO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBQyxFQUFFLHVnQkFBdWdCO0FBQzFnQjtBQUNBO0FBQ0E7O0FBRUEsd0NBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQsRUFBQyxFQUFFLHFFQUFxRTtBQUN4RTs7QUFFQTtBQUNBO0FBQ0EsZUFBYztBQUNkLHdCQUF1QjtBQUN2QjtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVELEVBQUMsRUFBRSwwQkFBMEI7QUFDN0I7QUFDQTtBQUNBOztBQUVBLGtEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRCxFQUFDLEVBQUUscUVBQXFFO0FBQ3hFO0FBQ0E7QUFDQTs7QUFFQSx5REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRCxFQUFDLEVBQUUscUVBQXFFO0FBQ3hFO0FBQ0E7QUFDQTs7QUFFQSxnREFBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVELEVBQUMsRUFBRSxxRUFBcUU7QUFDeEU7QUFDQTtBQUNBOztBQUVBLGtEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQsRUFBQyxFQUFFLHFFQUFxRTtBQUN4RTtBQUNBO0FBQ0E7O0FBRUEsdURBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQsRUFBQyxFQUFFLHFFQUFxRTtBQUN4RTtBQUNBO0FBQ0E7O0FBRUEsb0RBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRCxFQUFDLEVBQUUscUVBQXFFO0FBQ3hFO0FBQ0E7QUFDQTs7QUFFQSxpREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQsRUFBQyxFQUFFLHFFQUFxRTtBQUN4RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRCxFQUFDLEVBQUUsMEJBQTBCO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQSw2Q0FBNEM7QUFDNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVELEVBQUMsRUFBRSxxRUFBcUU7QUFDeEU7QUFDQTtBQUNBOztBQUVBLHFEQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQsRUFBQyxFQUFFLHFFQUFxRTtBQUN4RTtBQUNBO0FBQ0E7O0FBRUEsaURBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRCxFQUFDLEVBQUUscUVBQXFFO0FBQ3hFO0FBQ0E7QUFDQTs7QUFFQSxnREFBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVELEVBQUMsRUFBRSxxRUFBcUU7QUFDeEU7QUFDQTtBQUNBOztBQUVBLCtDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRCxFQUFDLEVBQUUscUVBQXFFO0FBQ3hFO0FBQ0E7QUFDQTs7QUFFQSxrREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQsRUFBQyxFQUFFLHFFQUFxRTtBQUN4RTtBQUNBO0FBQ0E7O0FBRUEsaURBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQsRUFBQyxFQUFFLHFFQUFxRTtBQUN4RTtBQUNBO0FBQ0E7O0FBRUEsaURBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVELEVBQUMsRUFBRSxxRUFBcUU7QUFDeEU7QUFDQTtBQUNBOztBQUVBLHVEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRCxFQUFDLEVBQUUscUVBQXFFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTzs7QUFFUDtBQUNBO0FBQ0EsUUFBTzs7QUFFUDtBQUNBO0FBQ0EsUUFBTzs7QUFFUDtBQUNBO0FBQ0EsUUFBTzs7QUFFUDtBQUNBO0FBQ0EsUUFBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBLFFBQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwrQ0FBOEMsUUFBUTs7QUFFdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTJDLFFBQVE7O0FBRW5EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFB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QTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDs7QUFFQTs7QUFFQSw2QkFBNEI7QUFDNUI7QUFDQSw4RUFBNkU7O0FBRTdFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFDLEdBQUc7QUFDSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxFQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQSwwQ0FBeUMsT0FBTztBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTRCLDhCQUE4QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0RBQXVEO0FBQ3ZEOztBQUVBLDhCQUE2QixtQkFBbUI7O0FBRWhEOztBQUVBOztBQUVBO0FBQ0E7QUFDQSIsImZpbGUiOiJidW5kbGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0ZXhwb3J0czoge30sXG4gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuIFx0XHRcdGxvYWRlZDogZmFsc2VcbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIHdlYnBhY2svYm9vdHN0cmFwIGExOTg0NDYyMjAyNWU2NDNiMTQ4XG4gKiovIiwiLy9BbGwgc2NyaXB0cyBzdGFydCBmcm9tIHNyYy9pbmRleC5qc1xuLy9QbGVhc2UgZG8gbm90IGFkZCBhbnl0aGluZyBoZXJlXG5pbXBvcnQgJy4vc3JjL2luZGV4JztcblxuaW1wb3J0ICcuL3N0eWxlcy9tYWluLnNjc3MnO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9tYWluLmpzXG4gKiovIiwicmVxdWlyZSgnYWZyYW1lJyk7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9pbmRleC5qc1xuICoqLyIsIihmdW5jdGlvbihmKXtpZih0eXBlb2YgZXhwb3J0cz09PVwib2JqZWN0XCImJnR5cGVvZiBtb2R1bGUhPT1cInVuZGVmaW5lZFwiKXttb2R1bGUuZXhwb3J0cz1mKCl9ZWxzZSBpZih0eXBlb2YgZGVmaW5lPT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kKXtkZWZpbmUoW10sZil9ZWxzZXt2YXIgZztpZih0eXBlb2Ygd2luZG93IT09XCJ1bmRlZmluZWRcIil7Zz13aW5kb3d9ZWxzZSBpZih0eXBlb2YgZ2xvYmFsIT09XCJ1bmRlZmluZWRcIil7Zz1nbG9iYWx9ZWxzZSBpZih0eXBlb2Ygc2VsZiE9PVwidW5kZWZpbmVkXCIpe2c9c2VsZn1lbHNle2c9dGhpc31nLkFGUkFNRSA9IGYoKX19KShmdW5jdGlvbigpe3ZhciBkZWZpbmUsbW9kdWxlLGV4cG9ydHM7cmV0dXJuIChmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pKHsxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0Jztcbi8vIEZvciBtb3JlIGluZm9ybWF0aW9uIGFib3V0IGJyb3dzZXIgZmllbGQsIGNoZWNrIG91dCB0aGUgYnJvd3NlciBmaWVsZCBhdCBodHRwczovL2dpdGh1Yi5jb20vc3Vic3RhY2svYnJvd3NlcmlmeS1oYW5kYm9vayNicm93c2VyLWZpZWxkLlxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAvLyBDcmVhdGUgYSA8bGluaz4gdGFnIHdpdGggb3B0aW9uYWwgZGF0YSBhdHRyaWJ1dGVzXG4gICAgY3JlYXRlTGluazogZnVuY3Rpb24oaHJlZiwgYXR0cmlidXRlcykge1xuICAgICAgICB2YXIgaGVhZCA9IGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcbiAgICAgICAgdmFyIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaW5rJyk7XG5cbiAgICAgICAgbGluay5ocmVmID0gaHJlZjtcbiAgICAgICAgbGluay5yZWwgPSAnc3R5bGVzaGVldCc7XG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIGlmICggISBhdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGF0dHJpYnV0ZXNba2V5XTtcbiAgICAgICAgICAgIGxpbmsuc2V0QXR0cmlidXRlKCdkYXRhLScgKyBrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGhlYWQuYXBwZW5kQ2hpbGQobGluayk7XG4gICAgfSxcbiAgICAvLyBDcmVhdGUgYSA8c3R5bGU+IHRhZyB3aXRoIG9wdGlvbmFsIGRhdGEgYXR0cmlidXRlc1xuICAgIGNyZWF0ZVN0eWxlOiBmdW5jdGlvbihjc3NUZXh0LCBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIHZhciBoZWFkID0gZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdLFxuICAgICAgICAgICAgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuXG4gICAgICAgIHN0eWxlLnR5cGUgPSAndGV4dC9jc3MnO1xuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICBpZiAoICEgYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBhdHRyaWJ1dGVzW2tleV07XG4gICAgICAgICAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoJ2RhdGEtJyArIGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAoc3R5bGUuc2hlZXQpIHsgLy8gZm9yIGpzZG9tIGFuZCBJRTkrXG4gICAgICAgICAgICBzdHlsZS5pbm5lckhUTUwgPSBjc3NUZXh0O1xuICAgICAgICAgICAgc3R5bGUuc2hlZXQuY3NzVGV4dCA9IGNzc1RleHQ7XG4gICAgICAgICAgICBoZWFkLmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgICAgICAgfSBlbHNlIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7IC8vIGZvciBJRTggYW5kIGJlbG93XG4gICAgICAgICAgICBoZWFkLmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgICAgICAgICAgIHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzc1RleHQ7XG4gICAgICAgIH0gZWxzZSB7IC8vIGZvciBDaHJvbWUsIEZpcmVmb3gsIGFuZCBTYWZhcmlcbiAgICAgICAgICAgIHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzc1RleHQpKTtcbiAgICAgICAgICAgIGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxufSx7fV0sMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gc2V0VGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgc2V0VGltZW91dChkcmFpblF1ZXVlLCAwKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxufSx7fV0sMzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cbi8qKlxuICogVGhpcyBpcyB0aGUgd2ViIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICpcbiAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBfZGVyZXFfKCcuL2RlYnVnJyk7XG5leHBvcnRzLmxvZyA9IGxvZztcbmV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5leHBvcnRzLnNhdmUgPSBzYXZlO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuZXhwb3J0cy5zdG9yYWdlID0gJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIGNocm9tZVxuICAgICAgICAgICAgICAgJiYgJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIGNocm9tZS5zdG9yYWdlXG4gICAgICAgICAgICAgICAgICA/IGNocm9tZS5zdG9yYWdlLmxvY2FsXG4gICAgICAgICAgICAgICAgICA6IGxvY2Fsc3RvcmFnZSgpO1xuXG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFtcbiAgJ2xpZ2h0c2VhZ3JlZW4nLFxuICAnZm9yZXN0Z3JlZW4nLFxuICAnZ29sZGVucm9kJyxcbiAgJ2RvZGdlcmJsdWUnLFxuICAnZGFya29yY2hpZCcsXG4gICdjcmltc29uJ1xuXTtcblxuLyoqXG4gKiBDdXJyZW50bHkgb25seSBXZWJLaXQtYmFzZWQgV2ViIEluc3BlY3RvcnMsIEZpcmVmb3ggPj0gdjMxLFxuICogYW5kIHRoZSBGaXJlYnVnIGV4dGVuc2lvbiAoYW55IEZpcmVmb3ggdmVyc2lvbikgYXJlIGtub3duXG4gKiB0byBzdXBwb3J0IFwiJWNcIiBDU1MgY3VzdG9taXphdGlvbnMuXG4gKlxuICogVE9ETzogYWRkIGEgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGUgdG8gZXhwbGljaXRseSBlbmFibGUvZGlzYWJsZSBjb2xvcnNcbiAqL1xuXG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG4gIC8vIGlzIHdlYmtpdD8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTY0NTk2MDYvMzc2NzczXG4gIHJldHVybiAoJ1dlYmtpdEFwcGVhcmFuY2UnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSkgfHxcbiAgICAvLyBpcyBmaXJlYnVnPyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zOTgxMjAvMzc2NzczXG4gICAgKHdpbmRvdy5jb25zb2xlICYmIChjb25zb2xlLmZpcmVidWcgfHwgKGNvbnNvbGUuZXhjZXB0aW9uICYmIGNvbnNvbGUudGFibGUpKSkgfHxcbiAgICAvLyBpcyBmaXJlZm94ID49IHYzMT9cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcbiAgICAobmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykgJiYgcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCkgPj0gMzEpO1xufVxuXG4vKipcbiAqIE1hcCAlaiB0byBgSlNPTi5zdHJpbmdpZnkoKWAsIHNpbmNlIG5vIFdlYiBJbnNwZWN0b3JzIGRvIHRoYXQgYnkgZGVmYXVsdC5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdHRlcnMuaiA9IGZ1bmN0aW9uKHYpIHtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xufTtcblxuXG4vKipcbiAqIENvbG9yaXplIGxvZyBhcmd1bWVudHMgaWYgZW5hYmxlZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoKSB7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICB2YXIgdXNlQ29sb3JzID0gdGhpcy51c2VDb2xvcnM7XG5cbiAgYXJnc1swXSA9ICh1c2VDb2xvcnMgPyAnJWMnIDogJycpXG4gICAgKyB0aGlzLm5hbWVzcGFjZVxuICAgICsgKHVzZUNvbG9ycyA/ICcgJWMnIDogJyAnKVxuICAgICsgYXJnc1swXVxuICAgICsgKHVzZUNvbG9ycyA/ICclYyAnIDogJyAnKVxuICAgICsgJysnICsgZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpO1xuXG4gIGlmICghdXNlQ29sb3JzKSByZXR1cm4gYXJncztcblxuICB2YXIgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG4gIGFyZ3MgPSBbYXJnc1swXSwgYywgJ2NvbG9yOiBpbmhlcml0J10uY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MsIDEpKTtcblxuICAvLyB0aGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuICAvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG4gIC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGFzdEMgPSAwO1xuICBhcmdzWzBdLnJlcGxhY2UoLyVbYS16JV0vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICBpZiAoJyUlJyA9PT0gbWF0Y2gpIHJldHVybjtcbiAgICBpbmRleCsrO1xuICAgIGlmICgnJWMnID09PSBtYXRjaCkge1xuICAgICAgLy8gd2Ugb25seSBhcmUgaW50ZXJlc3RlZCBpbiB0aGUgKmxhc3QqICVjXG4gICAgICAvLyAodGhlIHVzZXIgbWF5IGhhdmUgcHJvdmlkZWQgdGhlaXIgb3duKVxuICAgICAgbGFzdEMgPSBpbmRleDtcbiAgICB9XG4gIH0pO1xuXG4gIGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcbiAgcmV0dXJuIGFyZ3M7XG59XG5cbi8qKlxuICogSW52b2tlcyBgY29uc29sZS5sb2coKWAgd2hlbiBhdmFpbGFibGUuXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmxvZ2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gbG9nKCkge1xuICAvLyB0aGlzIGhhY2tlcnkgaXMgcmVxdWlyZWQgZm9yIElFOC85LCB3aGVyZVxuICAvLyB0aGUgYGNvbnNvbGUubG9nYCBmdW5jdGlvbiBkb2Vzbid0IGhhdmUgJ2FwcGx5J1xuICByZXR1cm4gJ29iamVjdCcgPT09IHR5cGVvZiBjb25zb2xlXG4gICAgJiYgY29uc29sZS5sb2dcbiAgICAmJiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlLmxvZywgY29uc29sZSwgYXJndW1lbnRzKTtcbn1cblxuLyoqXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG4gIHRyeSB7XG4gICAgaWYgKG51bGwgPT0gbmFtZXNwYWNlcykge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZyA9IG5hbWVzcGFjZXM7XG4gICAgfVxuICB9IGNhdGNoKGUpIHt9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9hZCgpIHtcbiAgdmFyIHI7XG4gIHRyeSB7XG4gICAgciA9IGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZztcbiAgfSBjYXRjaChlKSB7fVxuICByZXR1cm4gcjtcbn1cblxuLyoqXG4gKiBFbmFibGUgbmFtZXNwYWNlcyBsaXN0ZWQgaW4gYGxvY2FsU3RvcmFnZS5kZWJ1Z2AgaW5pdGlhbGx5LlxuICovXG5cbmV4cG9ydHMuZW5hYmxlKGxvYWQoKSk7XG5cbi8qKlxuICogTG9jYWxzdG9yYWdlIGF0dGVtcHRzIHRvIHJldHVybiB0aGUgbG9jYWxzdG9yYWdlLlxuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuICogd2hlbiBhIHVzZXIgZGlzYWJsZXMgY29va2llcy9sb2NhbHN0b3JhZ2VcbiAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG4gKlxuICogQHJldHVybiB7TG9jYWxTdG9yYWdlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCl7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHdpbmRvdy5sb2NhbFN0b3JhZ2U7XG4gIH0gY2F0Y2ggKGUpIHt9XG59XG5cbn0se1wiLi9kZWJ1Z1wiOjR9XSw0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBjb21tb24gbG9naWMgZm9yIGJvdGggdGhlIE5vZGUuanMgYW5kIHdlYiBicm93c2VyXG4gKiBpbXBsZW1lbnRhdGlvbnMgb2YgYGRlYnVnKClgLlxuICpcbiAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBkZWJ1ZztcbmV4cG9ydHMuY29lcmNlID0gY29lcmNlO1xuZXhwb3J0cy5kaXNhYmxlID0gZGlzYWJsZTtcbmV4cG9ydHMuZW5hYmxlID0gZW5hYmxlO1xuZXhwb3J0cy5lbmFibGVkID0gZW5hYmxlZDtcbmV4cG9ydHMuaHVtYW5pemUgPSBfZGVyZXFfKCdtcycpO1xuXG4vKipcbiAqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGRlYnVnIG1vZGUgbmFtZXMsIGFuZCBuYW1lcyB0byBza2lwLlxuICovXG5cbmV4cG9ydHMubmFtZXMgPSBbXTtcbmV4cG9ydHMuc2tpcHMgPSBbXTtcblxuLyoqXG4gKiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG4gKlxuICogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXJjYXNlZCBsZXR0ZXIsIGkuZS4gXCJuXCIuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzID0ge307XG5cbi8qKlxuICogUHJldmlvdXNseSBhc3NpZ25lZCBjb2xvci5cbiAqL1xuXG52YXIgcHJldkNvbG9yID0gMDtcblxuLyoqXG4gKiBQcmV2aW91cyBsb2cgdGltZXN0YW1wLlxuICovXG5cbnZhciBwcmV2VGltZTtcblxuLyoqXG4gKiBTZWxlY3QgYSBjb2xvci5cbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzZWxlY3RDb2xvcigpIHtcbiAgcmV0dXJuIGV4cG9ydHMuY29sb3JzW3ByZXZDb2xvcisrICUgZXhwb3J0cy5jb2xvcnMubGVuZ3RoXTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBkZWJ1Z2dlciB3aXRoIHRoZSBnaXZlbiBgbmFtZXNwYWNlYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGVidWcobmFtZXNwYWNlKSB7XG5cbiAgLy8gZGVmaW5lIHRoZSBgZGlzYWJsZWRgIHZlcnNpb25cbiAgZnVuY3Rpb24gZGlzYWJsZWQoKSB7XG4gIH1cbiAgZGlzYWJsZWQuZW5hYmxlZCA9IGZhbHNlO1xuXG4gIC8vIGRlZmluZSB0aGUgYGVuYWJsZWRgIHZlcnNpb25cbiAgZnVuY3Rpb24gZW5hYmxlZCgpIHtcblxuICAgIHZhciBzZWxmID0gZW5hYmxlZDtcblxuICAgIC8vIHNldCBgZGlmZmAgdGltZXN0YW1wXG4gICAgdmFyIGN1cnIgPSArbmV3IERhdGUoKTtcbiAgICB2YXIgbXMgPSBjdXJyIC0gKHByZXZUaW1lIHx8IGN1cnIpO1xuICAgIHNlbGYuZGlmZiA9IG1zO1xuICAgIHNlbGYucHJldiA9IHByZXZUaW1lO1xuICAgIHNlbGYuY3VyciA9IGN1cnI7XG4gICAgcHJldlRpbWUgPSBjdXJyO1xuXG4gICAgLy8gYWRkIHRoZSBgY29sb3JgIGlmIG5vdCBzZXRcbiAgICBpZiAobnVsbCA9PSBzZWxmLnVzZUNvbG9ycykgc2VsZi51c2VDb2xvcnMgPSBleHBvcnRzLnVzZUNvbG9ycygpO1xuICAgIGlmIChudWxsID09IHNlbGYuY29sb3IgJiYgc2VsZi51c2VDb2xvcnMpIHNlbGYuY29sb3IgPSBzZWxlY3RDb2xvcigpO1xuXG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXG4gICAgYXJnc1swXSA9IGV4cG9ydHMuY29lcmNlKGFyZ3NbMF0pO1xuXG4gICAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2YgYXJnc1swXSkge1xuICAgICAgLy8gYW55dGhpbmcgZWxzZSBsZXQncyBpbnNwZWN0IHdpdGggJW9cbiAgICAgIGFyZ3MgPSBbJyVvJ10uY29uY2F0KGFyZ3MpO1xuICAgIH1cblxuICAgIC8vIGFwcGx5IGFueSBgZm9ybWF0dGVyc2AgdHJhbnNmb3JtYXRpb25zXG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICBhcmdzWzBdID0gYXJnc1swXS5yZXBsYWNlKC8lKFthLXolXSkvZywgZnVuY3Rpb24obWF0Y2gsIGZvcm1hdCkge1xuICAgICAgLy8gaWYgd2UgZW5jb3VudGVyIGFuIGVzY2FwZWQgJSB0aGVuIGRvbid0IGluY3JlYXNlIHRoZSBhcnJheSBpbmRleFxuICAgICAgaWYgKG1hdGNoID09PSAnJSUnKSByZXR1cm4gbWF0Y2g7XG4gICAgICBpbmRleCsrO1xuICAgICAgdmFyIGZvcm1hdHRlciA9IGV4cG9ydHMuZm9ybWF0dGVyc1tmb3JtYXRdO1xuICAgICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBmb3JtYXR0ZXIpIHtcbiAgICAgICAgdmFyIHZhbCA9IGFyZ3NbaW5kZXhdO1xuICAgICAgICBtYXRjaCA9IGZvcm1hdHRlci5jYWxsKHNlbGYsIHZhbCk7XG5cbiAgICAgICAgLy8gbm93IHdlIG5lZWQgdG8gcmVtb3ZlIGBhcmdzW2luZGV4XWAgc2luY2UgaXQncyBpbmxpbmVkIGluIHRoZSBgZm9ybWF0YFxuICAgICAgICBhcmdzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIGluZGV4LS07XG4gICAgICB9XG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfSk7XG5cbiAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGV4cG9ydHMuZm9ybWF0QXJncykge1xuICAgICAgYXJncyA9IGV4cG9ydHMuZm9ybWF0QXJncy5hcHBseShzZWxmLCBhcmdzKTtcbiAgICB9XG4gICAgdmFyIGxvZ0ZuID0gZW5hYmxlZC5sb2cgfHwgZXhwb3J0cy5sb2cgfHwgY29uc29sZS5sb2cuYmluZChjb25zb2xlKTtcbiAgICBsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgfVxuICBlbmFibGVkLmVuYWJsZWQgPSB0cnVlO1xuXG4gIHZhciBmbiA9IGV4cG9ydHMuZW5hYmxlZChuYW1lc3BhY2UpID8gZW5hYmxlZCA6IGRpc2FibGVkO1xuXG4gIGZuLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcblxuICByZXR1cm4gZm47XG59XG5cbi8qKlxuICogRW5hYmxlcyBhIGRlYnVnIG1vZGUgYnkgbmFtZXNwYWNlcy4gVGhpcyBjYW4gaW5jbHVkZSBtb2Rlc1xuICogc2VwYXJhdGVkIGJ5IGEgY29sb24gYW5kIHdpbGRjYXJkcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcykge1xuICBleHBvcnRzLnNhdmUobmFtZXNwYWNlcyk7XG5cbiAgdmFyIHNwbGl0ID0gKG5hbWVzcGFjZXMgfHwgJycpLnNwbGl0KC9bXFxzLF0rLyk7XG4gIHZhciBsZW4gPSBzcGxpdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGlmICghc3BsaXRbaV0pIGNvbnRpbnVlOyAvLyBpZ25vcmUgZW1wdHkgc3RyaW5nc1xuICAgIG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9cXCovZywgJy4qPycpO1xuICAgIGlmIChuYW1lc3BhY2VzWzBdID09PSAnLScpIHtcbiAgICAgIGV4cG9ydHMuc2tpcHMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMuc3Vic3RyKDEpICsgJyQnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMubmFtZXMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMgKyAnJCcpKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gIGV4cG9ydHMuZW5hYmxlKCcnKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG1vZGUgbmFtZSBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVuYWJsZWQobmFtZSkge1xuICB2YXIgaSwgbGVuO1xuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLnNraXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGV4cG9ydHMuc2tpcHNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGV4cG9ydHMubmFtZXNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBDb2VyY2UgYHZhbGAuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gdmFsXG4gKiBAcmV0dXJuIHtNaXhlZH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSByZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuICByZXR1cm4gdmFsO1xufVxuXG59LHtcIm1zXCI6NX1dLDU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBIZWxwZXJzLlxuICovXG5cbnZhciBzID0gMTAwMDtcbnZhciBtID0gcyAqIDYwO1xudmFyIGggPSBtICogNjA7XG52YXIgZCA9IGggKiAyNDtcbnZhciB5ID0gZCAqIDM2NS4yNTtcblxuLyoqXG4gKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtTdHJpbmd8TnVtYmVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHZhbCwgb3B0aW9ucyl7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBpZiAoJ3N0cmluZycgPT0gdHlwZW9mIHZhbCkgcmV0dXJuIHBhcnNlKHZhbCk7XG4gIHJldHVybiBvcHRpb25zLmxvbmdcbiAgICA/IGxvbmcodmFsKVxuICAgIDogc2hvcnQodmFsKTtcbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICBzdHIgPSAnJyArIHN0cjtcbiAgaWYgKHN0ci5sZW5ndGggPiAxMDAwMCkgcmV0dXJuO1xuICB2YXIgbWF0Y2ggPSAvXigoPzpcXGQrKT9cXC4/XFxkKykgKihtaWxsaXNlY29uZHM/fG1zZWNzP3xtc3xzZWNvbmRzP3xzZWNzP3xzfG1pbnV0ZXM/fG1pbnM/fG18aG91cnM/fGhycz98aHxkYXlzP3xkfHllYXJzP3x5cnM/fHkpPyQvaS5leGVjKHN0cik7XG4gIGlmICghbWF0Y2gpIHJldHVybjtcbiAgdmFyIG4gPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgdmFyIHR5cGUgPSAobWF0Y2hbMl0gfHwgJ21zJykudG9Mb3dlckNhc2UoKTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAneWVhcnMnOlxuICAgIGNhc2UgJ3llYXInOlxuICAgIGNhc2UgJ3lycyc6XG4gICAgY2FzZSAneXInOlxuICAgIGNhc2UgJ3knOlxuICAgICAgcmV0dXJuIG4gKiB5O1xuICAgIGNhc2UgJ2RheXMnOlxuICAgIGNhc2UgJ2RheSc6XG4gICAgY2FzZSAnZCc6XG4gICAgICByZXR1cm4gbiAqIGQ7XG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2hvdXInOlxuICAgIGNhc2UgJ2hycyc6XG4gICAgY2FzZSAnaHInOlxuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIG4gKiBoO1xuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbWlucyc6XG4gICAgY2FzZSAnbWluJzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuICogbTtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdzZWNvbmQnOlxuICAgIGNhc2UgJ3NlY3MnOlxuICAgIGNhc2UgJ3NlYyc6XG4gICAgY2FzZSAncyc6XG4gICAgICByZXR1cm4gbiAqIHM7XG4gICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcbiAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgY2FzZSAnbXNlY3MnOlxuICAgIGNhc2UgJ21zZWMnOlxuICAgIGNhc2UgJ21zJzpcbiAgICAgIHJldHVybiBuO1xuICB9XG59XG5cbi8qKlxuICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2hvcnQobXMpIHtcbiAgaWYgKG1zID49IGQpIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG4gIGlmIChtcyA+PSBoKSByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuICBpZiAobXMgPj0gbSkgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcbiAgaWYgKG1zID49IHMpIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG4gIHJldHVybiBtcyArICdtcyc7XG59XG5cbi8qKlxuICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb25nKG1zKSB7XG4gIHJldHVybiBwbHVyYWwobXMsIGQsICdkYXknKVxuICAgIHx8IHBsdXJhbChtcywgaCwgJ2hvdXInKVxuICAgIHx8IHBsdXJhbChtcywgbSwgJ21pbnV0ZScpXG4gICAgfHwgcGx1cmFsKG1zLCBzLCAnc2Vjb25kJylcbiAgICB8fCBtcyArICcgbXMnO1xufVxuXG4vKipcbiAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuICovXG5cbmZ1bmN0aW9uIHBsdXJhbChtcywgbiwgbmFtZSkge1xuICBpZiAobXMgPCBuKSByZXR1cm47XG4gIGlmIChtcyA8IG4gKiAxLjUpIHJldHVybiBNYXRoLmZsb29yKG1zIC8gbikgKyAnICcgKyBuYW1lO1xuICByZXR1cm4gTWF0aC5jZWlsKG1zIC8gbikgKyAnICcgKyBuYW1lICsgJ3MnO1xufVxuXG59LHt9XSw2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcbnZhciBpc09iaiA9IF9kZXJlcV8oJ2lzLW9iaicpO1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwcm9wSXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuZnVuY3Rpb24gdG9PYmplY3QodmFsKSB7XG5cdGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdTb3VyY2VzIGNhbm5vdCBiZSBudWxsIG9yIHVuZGVmaW5lZCcpO1xuXHR9XG5cblx0cmV0dXJuIE9iamVjdCh2YWwpO1xufVxuXG5mdW5jdGlvbiBhc3NpZ25LZXkodG8sIGZyb20sIGtleSkge1xuXHR2YXIgdmFsID0gZnJvbVtrZXldO1xuXG5cdGlmICh2YWwgPT09IHVuZGVmaW5lZCB8fCB2YWwgPT09IG51bGwpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh0bywga2V5KSkge1xuXHRcdGlmICh0b1trZXldID09PSB1bmRlZmluZWQgfHwgdG9ba2V5XSA9PT0gbnVsbCkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgdW5kZWZpbmVkIG9yIG51bGwgdG8gb2JqZWN0ICgnICsga2V5ICsgJyknKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoIWhhc093blByb3BlcnR5LmNhbGwodG8sIGtleSkgfHwgIWlzT2JqKHZhbCkpIHtcblx0XHR0b1trZXldID0gdmFsO1xuXHR9IGVsc2Uge1xuXHRcdHRvW2tleV0gPSBhc3NpZ24oT2JqZWN0KHRvW2tleV0pLCBmcm9tW2tleV0pO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGFzc2lnbih0bywgZnJvbSkge1xuXHRpZiAodG8gPT09IGZyb20pIHtcblx0XHRyZXR1cm4gdG87XG5cdH1cblxuXHRmcm9tID0gT2JqZWN0KGZyb20pO1xuXG5cdGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG5cdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuXHRcdFx0YXNzaWduS2V5KHRvLCBmcm9tLCBrZXkpO1xuXHRcdH1cblx0fVxuXG5cdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG5cdFx0dmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGZyb20pO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzeW1ib2xzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAocHJvcElzRW51bWVyYWJsZS5jYWxsKGZyb20sIHN5bWJvbHNbaV0pKSB7XG5cdFx0XHRcdGFzc2lnbktleSh0bywgZnJvbSwgc3ltYm9sc1tpXSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRvO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRlZXBBc3NpZ24odGFyZ2V0KSB7XG5cdHRhcmdldCA9IHRvT2JqZWN0KHRhcmdldCk7XG5cblx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcblx0XHRhc3NpZ24odGFyZ2V0LCBhcmd1bWVudHNbc10pO1xuXHR9XG5cblx0cmV0dXJuIHRhcmdldDtcbn07XG5cbn0se1wiaXMtb2JqXCI6N31dLDc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoeCkge1xuXHR2YXIgdHlwZSA9IHR5cGVvZiB4O1xuXHRyZXR1cm4geCAhPT0gbnVsbCAmJiAodHlwZSA9PT0gJ29iamVjdCcgfHwgdHlwZSA9PT0gJ2Z1bmN0aW9uJyk7XG59O1xuXG59LHt9XSw4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qISAoQykgV2ViUmVmbGVjdGlvbiBNaXQgU3R5bGUgTGljZW5zZSAqL1xuKGZ1bmN0aW9uKHQsbixyLGkpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHN0KGUsdCl7Zm9yKHZhciBuPTAscj1lLmxlbmd0aDtuPHI7bisrKWd0KGVbbl0sdCl9ZnVuY3Rpb24gb3QoZSl7Zm9yKHZhciB0PTAsbj1lLmxlbmd0aCxyO3Q8bjt0Kyspcj1lW3RdLGl0KHIsd1thdChyKV0pfWZ1bmN0aW9uIHV0KGUpe3JldHVybiBmdW5jdGlvbih0KXtGKHQpJiYoZ3QodCxlKSxzdCh0LnF1ZXJ5U2VsZWN0b3JBbGwoRSksZSkpfX1mdW5jdGlvbiBhdChlKXt2YXIgdD1SLmNhbGwoZSxcImlzXCIpLG49ZS5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpLHI9eC5jYWxsKGIsdD9tK3QudG9VcHBlckNhc2UoKTp2K24pO3JldHVybiB0JiYtMTxyJiYhZnQobix0KT8tMTpyfWZ1bmN0aW9uIGZ0KGUsdCl7cmV0dXJuLTE8RS5pbmRleE9mKGUrJ1tpcz1cIicrdCsnXCJdJyl9ZnVuY3Rpb24gbHQoZSl7dmFyIHQ9ZS5jdXJyZW50VGFyZ2V0LG49ZS5hdHRyQ2hhbmdlLHI9ZS5hdHRyTmFtZSxpPWUudGFyZ2V0O1kmJighaXx8aT09PXQpJiZ0LmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayYmciE9PVwic3R5bGVcIiYmZS5wcmV2VmFsdWUhPT1lLm5ld1ZhbHVlJiZ0LmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhyLG49PT1lW2ZdP251bGw6ZS5wcmV2VmFsdWUsbj09PWVbY10/bnVsbDplLm5ld1ZhbHVlKX1mdW5jdGlvbiBjdChlKXt2YXIgdD11dChlKTtyZXR1cm4gZnVuY3Rpb24oZSl7JC5wdXNoKHQsZS50YXJnZXQpfX1mdW5jdGlvbiBodChlKXtHJiYoRz0hMSxlLmN1cnJlbnRUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihwLGh0KSksc3QoKGUudGFyZ2V0fHxuKS5xdWVyeVNlbGVjdG9yQWxsKEUpLGUuZGV0YWlsPT09dT91Om8pLGomJnZ0KCl9ZnVuY3Rpb24gcHQoZSx0KXt2YXIgbj10aGlzO1UuY2FsbChuLGUsdCksWi5jYWxsKG4se3RhcmdldDpufSl9ZnVuY3Rpb24gZHQoZSx0KXtQKGUsdCksbnQ/bnQub2JzZXJ2ZShlLFgpOihRJiYoZS5zZXRBdHRyaWJ1dGU9cHQsZVtzXT10dChlKSxlLmFkZEV2ZW50TGlzdGVuZXIoZCxaKSksZS5hZGRFdmVudExpc3RlbmVyKGgsbHQpKSxlLmNyZWF0ZWRDYWxsYmFjayYmWSYmKGUuY3JlYXRlZD0hMCxlLmNyZWF0ZWRDYWxsYmFjaygpLGUuY3JlYXRlZD0hMSl9ZnVuY3Rpb24gdnQoKXtmb3IodmFyIGUsdD0wLG49SS5sZW5ndGg7dDxuO3QrKyllPUlbdF0sUy5jb250YWlucyhlKXx8KG4tLSxJLnNwbGljZSh0LS0sMSksZ3QoZSx1KSl9ZnVuY3Rpb24gbXQoZSl7dGhyb3cgbmV3IEVycm9yKFwiQSBcIitlK1wiIHR5cGUgaXMgYWxyZWFkeSByZWdpc3RlcmVkXCIpfWZ1bmN0aW9uIGd0KGUsdCl7dmFyIG4scj1hdChlKTstMTxyJiYocnQoZSx3W3JdKSxyPTAsdD09PW8mJiFlW29dPyhlW3VdPSExLGVbb109ITAscj0xLGomJnguY2FsbChJLGUpPDAmJkkucHVzaChlKSk6dD09PXUmJiFlW3VdJiYoZVtvXT0hMSxlW3VdPSEwLHI9MSksciYmKG49ZVt0K1wiQ2FsbGJhY2tcIl0pJiZuLmNhbGwoZSkpfWlmKGkgaW4gbilyZXR1cm47dmFyIHM9XCJfX1wiK2krKE1hdGgucmFuZG9tKCkqMWU1Pj4wKSxvPVwiYXR0YWNoZWRcIix1PVwiZGV0YWNoZWRcIixhPVwiZXh0ZW5kc1wiLGY9XCJBRERJVElPTlwiLGw9XCJNT0RJRklDQVRJT05cIixjPVwiUkVNT1ZBTFwiLGg9XCJET01BdHRyTW9kaWZpZWRcIixwPVwiRE9NQ29udGVudExvYWRlZFwiLGQ9XCJET01TdWJ0cmVlTW9kaWZpZWRcIix2PVwiPFwiLG09XCI9XCIsZz0vXltBLVpdW0EtWjAtOV0qKD86LVtBLVowLTldKykrJC8seT1bXCJBTk5PVEFUSU9OLVhNTFwiLFwiQ09MT1ItUFJPRklMRVwiLFwiRk9OVC1GQUNFXCIsXCJGT05ULUZBQ0UtU1JDXCIsXCJGT05ULUZBQ0UtVVJJXCIsXCJGT05ULUZBQ0UtRk9STUFUXCIsXCJGT05ULUZBQ0UtTkFNRVwiLFwiTUlTU0lORy1HTFlQSFwiXSxiPVtdLHc9W10sRT1cIlwiLFM9bi5kb2N1bWVudEVsZW1lbnQseD1iLmluZGV4T2Z8fGZ1bmN0aW9uKGUpe2Zvcih2YXIgdD10aGlzLmxlbmd0aDt0LS0mJnRoaXNbdF0hPT1lOyk7cmV0dXJuIHR9LFQ9ci5wcm90b3R5cGUsTj1ULmhhc093blByb3BlcnR5LEM9VC5pc1Byb3RvdHlwZU9mLGs9ci5kZWZpbmVQcm9wZXJ0eSxMPXIuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLEE9ci5nZXRPd25Qcm9wZXJ0eU5hbWVzLE89ci5nZXRQcm90b3R5cGVPZixNPXIuc2V0UHJvdG90eXBlT2YsXz0hIXIuX19wcm90b19fLEQ9ci5jcmVhdGV8fGZ1bmN0aW9uIHl0KGUpe3JldHVybiBlPyh5dC5wcm90b3R5cGU9ZSxuZXcgeXQpOnRoaXN9LFA9TXx8KF8/ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS5fX3Byb3RvX189dCxlfTpBJiZMP2Z1bmN0aW9uKCl7ZnVuY3Rpb24gZShlLHQpe2Zvcih2YXIgbixyPUEodCksaT0wLHM9ci5sZW5ndGg7aTxzO2krKyluPXJbaV0sTi5jYWxsKGUsbil8fGsoZSxuLEwodCxuKSl9cmV0dXJuIGZ1bmN0aW9uKHQsbil7ZG8gZSh0LG4pO3doaWxlKChuPU8obikpJiYhQy5jYWxsKG4sdCkpO3JldHVybiB0fX0oKTpmdW5jdGlvbihlLHQpe2Zvcih2YXIgbiBpbiB0KWVbbl09dFtuXTtyZXR1cm4gZX0pLEg9dC5NdXRhdGlvbk9ic2VydmVyfHx0LldlYktpdE11dGF0aW9uT2JzZXJ2ZXIsQj0odC5IVE1MRWxlbWVudHx8dC5FbGVtZW50fHx0Lk5vZGUpLnByb3RvdHlwZSxqPSFDLmNhbGwoQixTKSxGPWo/ZnVuY3Rpb24oZSl7cmV0dXJuIGUubm9kZVR5cGU9PT0xfTpmdW5jdGlvbihlKXtyZXR1cm4gQy5jYWxsKEIsZSl9LEk9aiYmW10scT1CLmNsb25lTm9kZSxSPUIuZ2V0QXR0cmlidXRlLFU9Qi5zZXRBdHRyaWJ1dGUsej1CLnJlbW92ZUF0dHJpYnV0ZSxXPW4uY3JlYXRlRWxlbWVudCxYPUgmJnthdHRyaWJ1dGVzOiEwLGNoYXJhY3RlckRhdGE6ITAsYXR0cmlidXRlT2xkVmFsdWU6ITB9LFY9SHx8ZnVuY3Rpb24oZSl7UT0hMSxTLnJlbW92ZUV2ZW50TGlzdGVuZXIoaCxWKX0sJCxKPXQucmVxdWVzdEFuaW1hdGlvbkZyYW1lfHx0LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZXx8dC5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWV8fHQubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWV8fGZ1bmN0aW9uKGUpe3NldFRpbWVvdXQoZSwxMCl9LEs9ITEsUT0hMCxHPSEwLFk9ITAsWixldCx0dCxudCxydCxpdDtNfHxfPyhydD1mdW5jdGlvbihlLHQpe0MuY2FsbCh0LGUpfHxkdChlLHQpfSxpdD1kdCk6KHJ0PWZ1bmN0aW9uKGUsdCl7ZVtzXXx8KGVbc109cighMCksZHQoZSx0KSl9LGl0PXJ0KSxqPyhRPSExLGZ1bmN0aW9uKCl7dmFyIHQ9TChCLFwiYWRkRXZlbnRMaXN0ZW5lclwiKSxuPXQudmFsdWUscj1mdW5jdGlvbihlKXt2YXIgdD1uZXcgQ3VzdG9tRXZlbnQoaCx7YnViYmxlczohMH0pO3QuYXR0ck5hbWU9ZSx0LnByZXZWYWx1ZT1SLmNhbGwodGhpcyxlKSx0Lm5ld1ZhbHVlPW51bGwsdFtjXT10LmF0dHJDaGFuZ2U9Mix6LmNhbGwodGhpcyxlKSx0aGlzLmRpc3BhdGNoRXZlbnQodCl9LGk9ZnVuY3Rpb24odCxuKXt2YXIgcj10aGlzLmhhc0F0dHJpYnV0ZSh0KSxpPXImJlIuY2FsbCh0aGlzLHQpO2U9bmV3IEN1c3RvbUV2ZW50KGgse2J1YmJsZXM6ITB9KSxVLmNhbGwodGhpcyx0LG4pLGUuYXR0ck5hbWU9dCxlLnByZXZWYWx1ZT1yP2k6bnVsbCxlLm5ld1ZhbHVlPW4scj9lW2xdPWUuYXR0ckNoYW5nZT0xOmVbZl09ZS5hdHRyQ2hhbmdlPTAsdGhpcy5kaXNwYXRjaEV2ZW50KGUpfSxvPWZ1bmN0aW9uKGUpe3ZhciB0PWUuY3VycmVudFRhcmdldCxuPXRbc10scj1lLnByb3BlcnR5TmFtZSxpO24uaGFzT3duUHJvcGVydHkocikmJihuPW5bcl0saT1uZXcgQ3VzdG9tRXZlbnQoaCx7YnViYmxlczohMH0pLGkuYXR0ck5hbWU9bi5uYW1lLGkucHJldlZhbHVlPW4udmFsdWV8fG51bGwsaS5uZXdWYWx1ZT1uLnZhbHVlPXRbcl18fG51bGwsaS5wcmV2VmFsdWU9PW51bGw/aVtmXT1pLmF0dHJDaGFuZ2U9MDppW2xdPWkuYXR0ckNoYW5nZT0xLHQuZGlzcGF0Y2hFdmVudChpKSl9O3QudmFsdWU9ZnVuY3Rpb24oZSx0LHUpe2U9PT1oJiZ0aGlzLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayYmdGhpcy5zZXRBdHRyaWJ1dGUhPT1pJiYodGhpc1tzXT17Y2xhc3NOYW1lOntuYW1lOlwiY2xhc3NcIix2YWx1ZTp0aGlzLmNsYXNzTmFtZX19LHRoaXMuc2V0QXR0cmlidXRlPWksdGhpcy5yZW1vdmVBdHRyaWJ1dGU9cixuLmNhbGwodGhpcyxcInByb3BlcnR5Y2hhbmdlXCIsbykpLG4uY2FsbCh0aGlzLGUsdCx1KX0sayhCLFwiYWRkRXZlbnRMaXN0ZW5lclwiLHQpfSgpKTpIfHwoUy5hZGRFdmVudExpc3RlbmVyKGgsViksUy5zZXRBdHRyaWJ1dGUocywxKSxTLnJlbW92ZUF0dHJpYnV0ZShzKSxRJiYoWj1mdW5jdGlvbihlKXt2YXIgdD10aGlzLG4scixpO2lmKHQ9PT1lLnRhcmdldCl7bj10W3NdLHRbc109cj10dCh0KTtmb3IoaSBpbiByKXtpZighKGkgaW4gbikpcmV0dXJuIGV0KDAsdCxpLG5baV0scltpXSxmKTtpZihyW2ldIT09bltpXSlyZXR1cm4gZXQoMSx0LGksbltpXSxyW2ldLGwpfWZvcihpIGluIG4paWYoIShpIGluIHIpKXJldHVybiBldCgyLHQsaSxuW2ldLHJbaV0sYyl9fSxldD1mdW5jdGlvbihlLHQsbixyLGkscyl7dmFyIG89e2F0dHJDaGFuZ2U6ZSxjdXJyZW50VGFyZ2V0OnQsYXR0ck5hbWU6bixwcmV2VmFsdWU6cixuZXdWYWx1ZTppfTtvW3NdPWUsbHQobyl9LHR0PWZ1bmN0aW9uKGUpe2Zvcih2YXIgdCxuLHI9e30saT1lLmF0dHJpYnV0ZXMscz0wLG89aS5sZW5ndGg7czxvO3MrKyl0PWlbc10sbj10Lm5hbWUsbiE9PVwic2V0QXR0cmlidXRlXCImJihyW25dPXQudmFsdWUpO3JldHVybiByfSkpLG5baV09ZnVuY3Rpb24odCxyKXtjPXQudG9VcHBlckNhc2UoKSxLfHwoSz0hMCxIPyhudD1mdW5jdGlvbihlLHQpe2Z1bmN0aW9uIG4oZSx0KXtmb3IodmFyIG49MCxyPWUubGVuZ3RoO248cjt0KGVbbisrXSkpO31yZXR1cm4gbmV3IEgoZnVuY3Rpb24ocil7Zm9yKHZhciBpLHMsbyx1PTAsYT1yLmxlbmd0aDt1PGE7dSsrKWk9clt1XSxpLnR5cGU9PT1cImNoaWxkTGlzdFwiPyhuKGkuYWRkZWROb2RlcyxlKSxuKGkucmVtb3ZlZE5vZGVzLHQpKToocz1pLnRhcmdldCxZJiZzLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayYmaS5hdHRyaWJ1dGVOYW1lIT09XCJzdHlsZVwiJiYobz1SLmNhbGwocyxpLmF0dHJpYnV0ZU5hbWUpLG8hPT1pLm9sZFZhbHVlJiZzLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhpLmF0dHJpYnV0ZU5hbWUsaS5vbGRWYWx1ZSxvKSkpfSl9KHV0KG8pLHV0KHUpKSxudC5vYnNlcnZlKG4se2NoaWxkTGlzdDohMCxzdWJ0cmVlOiEwfSkpOigkPVtdLEooZnVuY3Rpb24gZCgpe3doaWxlKCQubGVuZ3RoKSQuc2hpZnQoKS5jYWxsKG51bGwsJC5zaGlmdCgpKTtKKGQpfSksbi5hZGRFdmVudExpc3RlbmVyKFwiRE9NTm9kZUluc2VydGVkXCIsY3QobykpLG4uYWRkRXZlbnRMaXN0ZW5lcihcIkRPTU5vZGVSZW1vdmVkXCIsY3QodSkpKSxuLmFkZEV2ZW50TGlzdGVuZXIocCxodCksbi5hZGRFdmVudExpc3RlbmVyKFwicmVhZHlzdGF0ZWNoYW5nZVwiLGh0KSxuLmNyZWF0ZUVsZW1lbnQ9ZnVuY3Rpb24oZSx0KXt2YXIgcj1XLmFwcGx5KG4sYXJndW1lbnRzKSxpPVwiXCIrZSxzPXguY2FsbChiLCh0P206dikrKHR8fGkpLnRvVXBwZXJDYXNlKCkpLG89LTE8cztyZXR1cm4gdCYmKHIuc2V0QXR0cmlidXRlKFwiaXNcIix0PXQudG9Mb3dlckNhc2UoKSksbyYmKG89ZnQoaS50b1VwcGVyQ2FzZSgpLHQpKSksWT0hbi5jcmVhdGVFbGVtZW50LmlubmVySFRNTEhlbHBlcixvJiZpdChyLHdbc10pLHJ9LEIuY2xvbmVOb2RlPWZ1bmN0aW9uKGUpe3ZhciB0PXEuY2FsbCh0aGlzLCEhZSksbj1hdCh0KTtyZXR1cm4tMTxuJiZpdCh0LHdbbl0pLGUmJm90KHQucXVlcnlTZWxlY3RvckFsbChFKSksdH0pLC0yPHguY2FsbChiLG0rYykreC5jYWxsKGIsditjKSYmbXQodCk7aWYoIWcudGVzdChjKXx8LTE8eC5jYWxsKHksYykpdGhyb3cgbmV3IEVycm9yKFwiVGhlIHR5cGUgXCIrdCtcIiBpcyBpbnZhbGlkXCIpO3ZhciBpPWZ1bmN0aW9uKCl7cmV0dXJuIGY/bi5jcmVhdGVFbGVtZW50KGwsYyk6bi5jcmVhdGVFbGVtZW50KGwpfSxzPXJ8fFQsZj1OLmNhbGwocyxhKSxsPWY/clthXS50b1VwcGVyQ2FzZSgpOmMsYyxoO3JldHVybiBmJiYtMTx4LmNhbGwoYix2K2wpJiZtdChsKSxoPWIucHVzaCgoZj9tOnYpK2MpLTEsRT1FLmNvbmNhdChFLmxlbmd0aD9cIixcIjpcIlwiLGY/bCsnW2lzPVwiJyt0LnRvTG93ZXJDYXNlKCkrJ1wiXSc6bCksaS5wcm90b3R5cGU9d1toXT1OLmNhbGwocyxcInByb3RvdHlwZVwiKT9zLnByb3RvdHlwZTpEKEIpLHN0KG4ucXVlcnlTZWxlY3RvckFsbChFKSxvKSxpfX0pKHdpbmRvdyxkb2N1bWVudCxPYmplY3QsXCJyZWdpc3RlckVsZW1lbnRcIik7XG59LHt9XSw5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG4ndXNlIHN0cmljdCc7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHByb3BJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5mdW5jdGlvbiB0b09iamVjdCh2YWwpIHtcblx0aWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5hc3NpZ24gY2Fubm90IGJlIGNhbGxlZCB3aXRoIG51bGwgb3IgdW5kZWZpbmVkJyk7XG5cdH1cblxuXHRyZXR1cm4gT2JqZWN0KHZhbCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcblx0dmFyIGZyb207XG5cdHZhciB0byA9IHRvT2JqZWN0KHRhcmdldCk7XG5cdHZhciBzeW1ib2xzO1xuXG5cdGZvciAodmFyIHMgPSAxOyBzIDwgYXJndW1lbnRzLmxlbmd0aDsgcysrKSB7XG5cdFx0ZnJvbSA9IE9iamVjdChhcmd1bWVudHNbc10pO1xuXG5cdFx0Zm9yICh2YXIga2V5IGluIGZyb20pIHtcblx0XHRcdGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGZyb20sIGtleSkpIHtcblx0XHRcdFx0dG9ba2V5XSA9IGZyb21ba2V5XTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuXHRcdFx0c3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZnJvbSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHByb3BJc0VudW1lcmFibGUuY2FsbChmcm9tLCBzeW1ib2xzW2ldKSkge1xuXHRcdFx0XHRcdHRvW3N5bWJvbHNbaV1dID0gZnJvbVtzeW1ib2xzW2ldXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0bztcbn07XG5cbn0se31dLDEwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbnZhciBwZXJmb3JtYW5jZSA9IGdsb2JhbC5wZXJmb3JtYW5jZSB8fCB7fTtcblxudmFyIHByZXNlbnQgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgbmFtZXMgPSBbJ25vdycsICd3ZWJraXROb3cnLCAnbXNOb3cnLCAnbW96Tm93JywgJ29Ob3cnXTtcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCkge1xuICAgIHZhciBuYW1lID0gbmFtZXMuc2hpZnQoKTtcbiAgICBpZiAobmFtZSBpbiBwZXJmb3JtYW5jZSkge1xuICAgICAgcmV0dXJuIHBlcmZvcm1hbmNlW25hbWVdLmJpbmQocGVyZm9ybWFuY2UpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBkYXRlTm93ID0gRGF0ZS5ub3cgfHwgZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7IH07XG4gIHZhciBuYXZpZ2F0aW9uU3RhcnQgPSAocGVyZm9ybWFuY2UudGltaW5nIHx8IHt9KS5uYXZpZ2F0aW9uU3RhcnQgfHwgZGF0ZU5vdygpO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBkYXRlTm93KCkgLSBuYXZpZ2F0aW9uU3RhcnQ7XG4gIH07XG59KCkpO1xuXG5wcmVzZW50LnBlcmZvcm1hbmNlTm93ID0gcGVyZm9ybWFuY2Uubm93O1xucHJlc2VudC5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICBwZXJmb3JtYW5jZS5ub3cgPSBwcmVzZW50LnBlcmZvcm1hbmNlTm93O1xufTtcbnByZXNlbnQuY29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gIHBlcmZvcm1hbmNlLm5vdyA9IHByZXNlbnQ7XG59O1xucHJlc2VudC5jb25mbGljdCgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHByZXNlbnQ7XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHt9XSwxMTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24ocm9vdCkge1xuXG5cdC8vIFN0b3JlIHNldFRpbWVvdXQgcmVmZXJlbmNlIHNvIHByb21pc2UtcG9seWZpbGwgd2lsbCBiZSB1bmFmZmVjdGVkIGJ5XG5cdC8vIG90aGVyIGNvZGUgbW9kaWZ5aW5nIHNldFRpbWVvdXQgKGxpa2Ugc2lub24udXNlRmFrZVRpbWVycygpKVxuXHR2YXIgc2V0VGltZW91dEZ1bmMgPSBzZXRUaW1lb3V0O1xuXG5cdC8vIFVzZSBwb2x5ZmlsbCBmb3Igc2V0SW1tZWRpYXRlIGZvciBwZXJmb3JtYW5jZSBnYWluc1xuXHR2YXIgYXNhcCA9ICh0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nICYmIHNldEltbWVkaWF0ZSkgfHxcblx0XHRmdW5jdGlvbihmbikgeyBzZXRUaW1lb3V0RnVuYyhmbiwgMSk7IH07XG5cblx0Ly8gUG9seWZpbGwgZm9yIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kXG5cdGZ1bmN0aW9uIGJpbmQoZm4sIHRoaXNBcmcpIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRmbi5hcHBseSh0aGlzQXJnLCBhcmd1bWVudHMpO1xuXHRcdH1cblx0fVxuXG5cdHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiIH07XG5cblx0ZnVuY3Rpb24gUHJvbWlzZShmbikge1xuXHRcdGlmICh0eXBlb2YgdGhpcyAhPT0gJ29iamVjdCcpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Byb21pc2VzIG11c3QgYmUgY29uc3RydWN0ZWQgdmlhIG5ldycpO1xuXHRcdGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBUeXBlRXJyb3IoJ25vdCBhIGZ1bmN0aW9uJyk7XG5cdFx0dGhpcy5fc3RhdGUgPSBudWxsO1xuXHRcdHRoaXMuX3ZhbHVlID0gbnVsbDtcblx0XHR0aGlzLl9kZWZlcnJlZHMgPSBbXVxuXG5cdFx0ZG9SZXNvbHZlKGZuLCBiaW5kKHJlc29sdmUsIHRoaXMpLCBiaW5kKHJlamVjdCwgdGhpcykpXG5cdH1cblxuXHRmdW5jdGlvbiBoYW5kbGUoZGVmZXJyZWQpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdGlmICh0aGlzLl9zdGF0ZSA9PT0gbnVsbCkge1xuXHRcdFx0dGhpcy5fZGVmZXJyZWRzLnB1c2goZGVmZXJyZWQpO1xuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXHRcdGFzYXAoZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY2IgPSBtZS5fc3RhdGUgPyBkZWZlcnJlZC5vbkZ1bGZpbGxlZCA6IGRlZmVycmVkLm9uUmVqZWN0ZWRcblx0XHRcdGlmIChjYiA9PT0gbnVsbCkge1xuXHRcdFx0XHQobWUuX3N0YXRlID8gZGVmZXJyZWQucmVzb2x2ZSA6IGRlZmVycmVkLnJlamVjdCkobWUuX3ZhbHVlKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHJldDtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHJldCA9IGNiKG1lLl92YWx1ZSk7XG5cdFx0XHR9XG5cdFx0XHRjYXRjaCAoZSkge1xuXHRcdFx0XHRkZWZlcnJlZC5yZWplY3QoZSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGRlZmVycmVkLnJlc29sdmUocmV0KTtcblx0XHR9KVxuXHR9XG5cblx0ZnVuY3Rpb24gcmVzb2x2ZShuZXdWYWx1ZSkge1xuXHRcdHRyeSB7IC8vUHJvbWlzZSBSZXNvbHV0aW9uIFByb2NlZHVyZTogaHR0cHM6Ly9naXRodWIuY29tL3Byb21pc2VzLWFwbHVzL3Byb21pc2VzLXNwZWMjdGhlLXByb21pc2UtcmVzb2x1dGlvbi1wcm9jZWR1cmVcblx0XHRcdGlmIChuZXdWYWx1ZSA9PT0gdGhpcykgdGhyb3cgbmV3IFR5cGVFcnJvcignQSBwcm9taXNlIGNhbm5vdCBiZSByZXNvbHZlZCB3aXRoIGl0c2VsZi4nKTtcblx0XHRcdGlmIChuZXdWYWx1ZSAmJiAodHlwZW9mIG5ld1ZhbHVlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgbmV3VmFsdWUgPT09ICdmdW5jdGlvbicpKSB7XG5cdFx0XHRcdHZhciB0aGVuID0gbmV3VmFsdWUudGhlbjtcblx0XHRcdFx0aWYgKHR5cGVvZiB0aGVuID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0ZG9SZXNvbHZlKGJpbmQodGhlbiwgbmV3VmFsdWUpLCBiaW5kKHJlc29sdmUsIHRoaXMpLCBiaW5kKHJlamVjdCwgdGhpcykpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5fc3RhdGUgPSB0cnVlO1xuXHRcdFx0dGhpcy5fdmFsdWUgPSBuZXdWYWx1ZTtcblx0XHRcdGZpbmFsZS5jYWxsKHRoaXMpO1xuXHRcdH0gY2F0Y2ggKGUpIHsgcmVqZWN0LmNhbGwodGhpcywgZSk7IH1cblx0fVxuXG5cdGZ1bmN0aW9uIHJlamVjdChuZXdWYWx1ZSkge1xuXHRcdHRoaXMuX3N0YXRlID0gZmFsc2U7XG5cdFx0dGhpcy5fdmFsdWUgPSBuZXdWYWx1ZTtcblx0XHRmaW5hbGUuY2FsbCh0aGlzKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGZpbmFsZSgpIHtcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fZGVmZXJyZWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRoYW5kbGUuY2FsbCh0aGlzLCB0aGlzLl9kZWZlcnJlZHNbaV0pO1xuXHRcdH1cblx0XHR0aGlzLl9kZWZlcnJlZHMgPSBudWxsO1xuXHR9XG5cblx0ZnVuY3Rpb24gSGFuZGxlcihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgcmVzb2x2ZSwgcmVqZWN0KXtcblx0XHR0aGlzLm9uRnVsZmlsbGVkID0gdHlwZW9mIG9uRnVsZmlsbGVkID09PSAnZnVuY3Rpb24nID8gb25GdWxmaWxsZWQgOiBudWxsO1xuXHRcdHRoaXMub25SZWplY3RlZCA9IHR5cGVvZiBvblJlamVjdGVkID09PSAnZnVuY3Rpb24nID8gb25SZWplY3RlZCA6IG51bGw7XG5cdFx0dGhpcy5yZXNvbHZlID0gcmVzb2x2ZTtcblx0XHR0aGlzLnJlamVjdCA9IHJlamVjdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBUYWtlIGEgcG90ZW50aWFsbHkgbWlzYmVoYXZpbmcgcmVzb2x2ZXIgZnVuY3Rpb24gYW5kIG1ha2Ugc3VyZVxuXHQgKiBvbkZ1bGZpbGxlZCBhbmQgb25SZWplY3RlZCBhcmUgb25seSBjYWxsZWQgb25jZS5cblx0ICpcblx0ICogTWFrZXMgbm8gZ3VhcmFudGVlcyBhYm91dCBhc3luY2hyb255LlxuXHQgKi9cblx0ZnVuY3Rpb24gZG9SZXNvbHZlKGZuLCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuXHRcdHZhciBkb25lID0gZmFsc2U7XG5cdFx0dHJ5IHtcblx0XHRcdGZuKGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0XHRpZiAoZG9uZSkgcmV0dXJuO1xuXHRcdFx0XHRkb25lID0gdHJ1ZTtcblx0XHRcdFx0b25GdWxmaWxsZWQodmFsdWUpO1xuXHRcdFx0fSwgZnVuY3Rpb24gKHJlYXNvbikge1xuXHRcdFx0XHRpZiAoZG9uZSkgcmV0dXJuO1xuXHRcdFx0XHRkb25lID0gdHJ1ZTtcblx0XHRcdFx0b25SZWplY3RlZChyZWFzb24pO1xuXHRcdFx0fSlcblx0XHR9IGNhdGNoIChleCkge1xuXHRcdFx0aWYgKGRvbmUpIHJldHVybjtcblx0XHRcdGRvbmUgPSB0cnVlO1xuXHRcdFx0b25SZWplY3RlZChleCk7XG5cdFx0fVxuXHR9XG5cblx0UHJvbWlzZS5wcm90b3R5cGVbJ2NhdGNoJ10gPSBmdW5jdGlvbiAob25SZWplY3RlZCkge1xuXHRcdHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3RlZCk7XG5cdH07XG5cblx0UHJvbWlzZS5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHRyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0XHRoYW5kbGUuY2FsbChtZSwgbmV3IEhhbmRsZXIob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIHJlc29sdmUsIHJlamVjdCkpO1xuXHRcdH0pXG5cdH07XG5cblx0UHJvbWlzZS5hbGwgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIGlzQXJyYXkoYXJndW1lbnRzWzBdKSA/IGFyZ3VtZW50c1swXSA6IGFyZ3VtZW50cyk7XG5cblx0XHRyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHRcdFx0aWYgKGFyZ3MubGVuZ3RoID09PSAwKSByZXR1cm4gcmVzb2x2ZShbXSk7XG5cdFx0XHR2YXIgcmVtYWluaW5nID0gYXJncy5sZW5ndGg7XG5cdFx0XHRmdW5jdGlvbiByZXMoaSwgdmFsKSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0aWYgKHZhbCAmJiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykpIHtcblx0XHRcdFx0XHRcdHZhciB0aGVuID0gdmFsLnRoZW47XG5cdFx0XHRcdFx0XHRpZiAodHlwZW9mIHRoZW4gPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHRcdFx0dGhlbi5jYWxsKHZhbCwgZnVuY3Rpb24gKHZhbCkgeyByZXMoaSwgdmFsKSB9LCByZWplY3QpO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGFyZ3NbaV0gPSB2YWw7XG5cdFx0XHRcdFx0aWYgKC0tcmVtYWluaW5nID09PSAwKSB7XG5cdFx0XHRcdFx0XHRyZXNvbHZlKGFyZ3MpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBjYXRjaCAoZXgpIHtcblx0XHRcdFx0XHRyZWplY3QoZXgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0cmVzKGksIGFyZ3NbaV0pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9O1xuXG5cdFByb21pc2UucmVzb2x2ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlLmNvbnN0cnVjdG9yID09PSBQcm9taXNlKSB7XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG5cdFx0XHRyZXNvbHZlKHZhbHVlKTtcblx0XHR9KTtcblx0fTtcblxuXHRQcm9taXNlLnJlamVjdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0XHRyZWplY3QodmFsdWUpO1xuXHRcdH0pO1xuXHR9O1xuXG5cdFByb21pc2UucmFjZSA9IGZ1bmN0aW9uICh2YWx1ZXMpIHtcblx0XHRyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHRcdFx0Zm9yKHZhciBpID0gMCwgbGVuID0gdmFsdWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdHZhbHVlc1tpXS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNldCB0aGUgaW1tZWRpYXRlIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgY2FsbGJhY2tzXG5cdCAqIEBwYXJhbSBmbiB7ZnVuY3Rpb259IEZ1bmN0aW9uIHRvIGV4ZWN1dGVcblx0ICogQHByaXZhdGVcblx0ICovXG5cdFByb21pc2UuX3NldEltbWVkaWF0ZUZuID0gZnVuY3Rpb24gX3NldEltbWVkaWF0ZUZuKGZuKSB7XG5cdFx0YXNhcCA9IGZuO1xuXHR9O1xuXG5cdGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuXHRcdG1vZHVsZS5leHBvcnRzID0gUHJvbWlzZTtcblx0fSBlbHNlIGlmICghcm9vdC5Qcm9taXNlKSB7XG5cdFx0cm9vdC5Qcm9taXNlID0gUHJvbWlzZTtcblx0fVxuXG59KSh0aGlzKTtcblxufSx7fV0sMTI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmFmID0gX2RlcmVxXygncmFmJyk7XG52YXIgbm93ID0gX2RlcmVxXygndGltZS1ub3cnKTtcblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gaW50ZXJ2YWw7XG5mdW5jdGlvbiBpbnRlcnZhbChkZWxheSwgZm4sIGN0eCkge1xuICB2YXIgc3RhcnQgPSBub3coKTtcbiAgdmFyIGRhdGEgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBkYXRhLmlkID0gcmFmKGxvb3ApO1xuXG4gIHJldHVybiBkYXRhO1xuXG4gIGZ1bmN0aW9uIGxvb3AoKSB7XG4gICAgZGF0YS5pZCA9IHJhZihsb29wKTtcblxuICAgIGlmICgobm93KCkgLSBzdGFydCkgPj0gZGVsYXkpIHtcbiAgICAgIGZuLmNhbGwoY3R4KTtcbiAgICAgIHN0YXJ0ID0gbm93KCk7XG4gICAgfVxuICB9XG59XG5cblxuZXhwb3J0cy5jbGVhciA9IGNsZWFySW50ZXJ2YWw7XG5mdW5jdGlvbiBjbGVhckludGVydmFsKGRhdGEpIHtcbiAgcmFmLmNhbmNlbChkYXRhLmlkKTtcbn1cblxufSx7XCJyYWZcIjoxMyxcInRpbWUtbm93XCI6MTR9XSwxMzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEV4cG9zZSBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKClgLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgfHwgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZVxuICB8fCB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gIHx8IGZhbGxiYWNrO1xuXG4vKipcbiAqIEZhbGxiYWNrIGltcGxlbWVudGF0aW9uLlxuICovXG5cbnZhciBwcmV2ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5mdW5jdGlvbiBmYWxsYmFjayhmbikge1xuICB2YXIgY3VyciA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICB2YXIgbXMgPSBNYXRoLm1heCgwLCAxNiAtIChjdXJyIC0gcHJldikpO1xuICB2YXIgcmVxID0gc2V0VGltZW91dChmbiwgbXMpO1xuICBwcmV2ID0gY3VycjtcbiAgcmV0dXJuIHJlcTtcbn1cblxuLyoqXG4gKiBDYW5jZWwuXG4gKi9cblxudmFyIGNhbmNlbCA9IHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZVxuICB8fCB3aW5kb3cud2Via2l0Q2FuY2VsQW5pbWF0aW9uRnJhbWVcbiAgfHwgd2luZG93Lm1vekNhbmNlbEFuaW1hdGlvbkZyYW1lXG4gIHx8IHdpbmRvdy5jbGVhclRpbWVvdXQ7XG5cbmV4cG9ydHMuY2FuY2VsID0gZnVuY3Rpb24oaWQpe1xuICBjYW5jZWwuY2FsbCh3aW5kb3csIGlkKTtcbn07XG5cbn0se31dLDE0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciBwZXJmID0gd2luZG93ICYmIHdpbmRvdy5wZXJmb3JtYW5jZTtcbiAgaWYgKHBlcmYgJiYgcGVyZi5ub3cpIHtcbiAgICByZXR1cm4gcGVyZi5ub3cuYmluZChwZXJmKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgfTtcbiAgfVxufSgpKTtcblxufSx7fV0sMTU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLypcblxuc3R5bGUtYXR0clxuPT09PVxuXG5WZXJ5IHNpbXBsZSBwYXJzaW5nIGFuZCBzdHJpbmdpZnlpbmcgb2Ygc3R5bGUgYXR0cmlidXRlcy5cblxuYHBhcnNlYFxuLS0tLVxuXG5Db252ZXJ0IGEgc3R5bGUgYXR0cmlidXRlIHN0cmluZyB0byBhbiBvYmplY3QuXG5cbi0gaW5wdXQ6IHN0cmluZyAoZWcuIGFueXRoaW5nIHlvdSBtaWdodCBzZWUgaW4gYSBzdHlsZSBhdHRyaWJ1dGUpXG4tIHJldHVybjogb2JqZWN0XG5cbiovXG5mdW5jdGlvbiBwYXJzZSAocmF3KSB7XG4gIHZhciB0cmltID0gZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMudHJpbSgpOyB9O1xuICB2YXIgb2JqID0ge307XG5cbiAgZ2V0S2V5VmFsdWVDaHVua3MocmF3KVxuICAgIC5tYXAodHJpbSlcbiAgICAuZmlsdGVyKEJvb2xlYW4pXG4gICAgLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIC8vIHNwbGl0IHdpdGggYC5pbmRleE9mYCByYXRoZXIgdGhhbiBgLnNwbGl0YCBiZWNhdXNlIHRoZSB2YWx1ZSBtYXkgYWxzbyBjb250YWluIGNvbG9ucy5cbiAgICAgIHZhciBwb3MgPSBpdGVtLmluZGV4T2YoJzonKTtcbiAgICAgIHZhciBrZXkgPSBpdGVtLnN1YnN0cigwLCBwb3MpLnRyaW0oKTtcbiAgICAgIHZhciB2YWwgPSBpdGVtLnN1YnN0cihwb3MgKyAxKS50cmltKCk7XG5cbiAgICAgIG9ialtrZXldID0gdmFsO1xuICAgIH0pO1xuXG4gIHJldHVybiBvYmo7XG59XG5cbi8qXG5cbmBnZXRLZXlWYWx1ZUNodW5rc2Bcbi0tLS1cblxuU3BsaXQgYSBzdHJpbmcgaW50byBjaHVua3MgbWF0Y2hpbmcgYDxrZXk+OiA8dmFsdWU+YFxuXG4tIGlucHV0OiBzdHJpbmdcbi0gcmV0dXJuOiBBcnJheTxzdHJpbmc+XG5cbiovXG5mdW5jdGlvbiBnZXRLZXlWYWx1ZUNodW5rcyAocmF3KSB7XG4gIHZhciBjaHVua3MgPSBbXTtcbiAgdmFyIG9mZnNldCA9IDA7XG4gIHZhciBzZXAgPSAnOyc7XG4gIHZhciBoYXNVbmNsb3NlZFVybCA9IC91cmxcXChbXlxcKV0rJC87XG4gIHZhciBjaHVuayA9ICcnO1xuICB2YXIgbmV4dFNwbGl0O1xuICB3aGlsZSAob2Zmc2V0IDwgcmF3Lmxlbmd0aCkge1xuICAgIG5leHRTcGxpdCA9IHJhdy5pbmRleE9mKHNlcCwgb2Zmc2V0KTtcbiAgICBpZiAobmV4dFNwbGl0ID09PSAtMSkgeyBuZXh0U3BsaXQgPSByYXcubGVuZ3RoOyB9XG5cbiAgICBjaHVuayArPSByYXcuc3Vic3RyaW5nKG9mZnNldCwgbmV4dFNwbGl0KTtcblxuICAgIC8vIGRhdGEgVVJJcyBjYW4gY29udGFpbiBzZW1pY29sb25zLCBzbyBtYWtlIHN1cmUgd2UgZ2V0IHRoZSB3aG9sZSB0aGluZ1xuICAgIGlmIChoYXNVbmNsb3NlZFVybC50ZXN0KGNodW5rKSkge1xuICAgICAgY2h1bmsgKz0gJzsnO1xuICAgICAgb2Zmc2V0ID0gbmV4dFNwbGl0ICsgMTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNodW5rcy5wdXNoKGNodW5rKTtcbiAgICBjaHVuayA9ICcnO1xuICAgIG9mZnNldCA9IG5leHRTcGxpdCArIDE7XG4gIH1cblxuICByZXR1cm4gY2h1bmtzO1xufVxuXG4vKlxuXG5gc3RyaW5naWZ5YFxuLS0tLVxuXG5Db252ZXJ0IGFuIG9iamVjdCBpbnRvIGFuIGF0dHJpYnV0ZSBzdHJpbmdcblxuLSBpbnB1dDogb2JqZWN0XG4tIHJldHVybjogc3RyaW5nXG5cbiovXG5mdW5jdGlvbiBzdHJpbmdpZnkgKG9iaikge1xuICByZXR1cm4gT2JqZWN0LmtleXMob2JqKVxuICAgIC5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIGtleSArICc6JyArIG9ialtrZXldO1xuICAgIH0pXG4gICAgLmpvaW4oJzsnKTtcbn1cblxuLypcblxuYG5vcm1hbGl6ZWBcbi0tLS1cblxuTm9ybWFsaXplIGFuIGF0dHJpYnV0ZSBzdHJpbmcgKGVnLiBjb2xsYXBzZSBkdXBsaWNhdGVzKVxuXG4tIGlucHV0OiBzdHJpbmdcbi0gcmV0dXJuOiBzdHJpbmdcblxuKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZSAoc3RyKSB7XG4gIHJldHVybiBzdHJpbmdpZnkocGFyc2Uoc3RyKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzLnBhcnNlID0gcGFyc2U7XG5tb2R1bGUuZXhwb3J0cy5zdHJpbmdpZnkgPSBzdHJpbmdpZnk7XG5tb2R1bGUuZXhwb3J0cy5ub3JtYWxpemUgPSBub3JtYWxpemU7XG5cbn0se31dLDE2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxyXG4gKiBAYXV0aG9yIGRtYXJjb3MgLyBodHRwczovL2dpdGh1Yi5jb20vZG1hcmNvc1xyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tXHJcbiAqL1xyXG5cclxuVEhSRUUuVlJDb250cm9scyA9IGZ1bmN0aW9uICggb2JqZWN0LCBvbkVycm9yICkge1xyXG5cclxuXHR2YXIgc2NvcGUgPSB0aGlzO1xyXG5cclxuXHR2YXIgdnJJbnB1dHMgPSBbXTtcclxuXHJcblx0ZnVuY3Rpb24gZ290VlJEZXZpY2VzKCBkZXZpY2VzICkge1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGRldmljZXMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0aWYgKCBkZXZpY2VzWyBpIF0gaW5zdGFuY2VvZiBQb3NpdGlvblNlbnNvclZSRGV2aWNlICkge1xyXG5cclxuXHRcdFx0XHR2cklucHV0cy5wdXNoKCBkZXZpY2VzWyBpIF0gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB2cklucHV0cy5sZW5ndGggPT09IDAgKSB7XHJcblxyXG5cdFx0XHRpZiAoIG9uRXJyb3IgKSBvbkVycm9yKCAnUG9zaXRpb25TZW5zb3JWUkRldmljZSBub3QgYXZhaWxhYmxlJyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRpZiAoIG5hdmlnYXRvci5nZXRWUkRldmljZXMgKSB7XHJcblxyXG5cdFx0bmF2aWdhdG9yLmdldFZSRGV2aWNlcygpLnRoZW4oIGdvdFZSRGV2aWNlcyApO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIHRoZSBSaWZ0IFNESyByZXR1cm5zIHRoZSBwb3NpdGlvbiBpbiBtZXRlcnNcclxuXHQvLyB0aGlzIHNjYWxlIGZhY3RvciBhbGxvd3MgdGhlIHVzZXIgdG8gZGVmaW5lIGhvdyBtZXRlcnNcclxuXHQvLyBhcmUgY29udmVydGVkIHRvIHNjZW5lIHVuaXRzLlxyXG5cclxuXHR0aGlzLnNjYWxlID0gMTtcclxuXHJcblx0dGhpcy51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdnJJbnB1dHMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIHZySW5wdXQgPSB2cklucHV0c1sgaSBdO1xyXG5cclxuXHRcdFx0dmFyIHN0YXRlID0gdnJJbnB1dC5nZXRTdGF0ZSgpO1xyXG5cclxuXHRcdFx0aWYgKCBzdGF0ZS5vcmllbnRhdGlvbiAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0b2JqZWN0LnF1YXRlcm5pb24uY29weSggc3RhdGUub3JpZW50YXRpb24gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggc3RhdGUucG9zaXRpb24gIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdG9iamVjdC5wb3NpdGlvbi5jb3B5KCBzdGF0ZS5wb3NpdGlvbiApLm11bHRpcGx5U2NhbGFyKCBzY29wZS5zY2FsZSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5yZXNldFNlbnNvciA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB2cklucHV0cy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgdnJJbnB1dCA9IHZySW5wdXRzWyBpIF07XHJcblxyXG5cdFx0XHRpZiAoIHZySW5wdXQucmVzZXRTZW5zb3IgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0dnJJbnB1dC5yZXNldFNlbnNvcigpO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggdnJJbnB1dC56ZXJvU2Vuc29yICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdHZySW5wdXQuemVyb1NlbnNvcigpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy56ZXJvU2Vuc29yID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZSQ29udHJvbHM6IC56ZXJvU2Vuc29yKCkgaXMgbm93IC5yZXNldFNlbnNvcigpLicgKTtcclxuXHRcdHRoaXMucmVzZXRTZW5zb3IoKTtcclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZySW5wdXRzID0gW107XHJcblxyXG5cdH07XHJcblxyXG59O1xyXG5cbn0se31dLDE3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxyXG4gKiBAYXV0aG9yIGRtYXJjb3MgLyBodHRwczovL2dpdGh1Yi5jb20vZG1hcmNvc1xyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tXHJcbiAqXHJcbiAqIFdlYlZSIFNwZWM6IGh0dHA6Ly9tb3p2ci5naXRodWIuaW8vd2VidnItc3BlYy93ZWJ2ci5odG1sXHJcbiAqXHJcbiAqIEZpcmVmb3g6IGh0dHA6Ly9tb3p2ci5jb20vZG93bmxvYWRzL1xyXG4gKiBDaHJvbWl1bTogaHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZvbGRlcnZpZXc/aWQ9MEJ6dWRMdDIyQnFHUmJXOVdUSE10T1dNek5qUSZ1c3A9c2hhcmluZyNsaXN0XHJcbiAqXHJcbiAqL1xyXG5cclxuVEhSRUUuVlJFZmZlY3QgPSBmdW5jdGlvbiAoIHJlbmRlcmVyLCBvbkVycm9yICkge1xyXG5cclxuXHR2YXIgdnJITUQ7XHJcblx0dmFyIGV5ZVRyYW5zbGF0aW9uTCwgZXllRk9WTDtcclxuXHR2YXIgZXllVHJhbnNsYXRpb25SLCBleWVGT1ZSO1xyXG5cclxuXHRmdW5jdGlvbiBnb3RWUkRldmljZXMoIGRldmljZXMgKSB7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZGV2aWNlcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGRldmljZXNbIGkgXSBpbnN0YW5jZW9mIEhNRFZSRGV2aWNlICkge1xyXG5cclxuXHRcdFx0XHR2ckhNRCA9IGRldmljZXNbIGkgXTtcclxuXHJcblx0XHRcdFx0YnJlYWs7IC8vIFdlIGtlZXAgdGhlIGZpcnN0IHdlIGVuY291bnRlclxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHZySE1EID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRpZiAoIG9uRXJyb3IgKSBvbkVycm9yKCAnSE1EIG5vdCBhdmFpbGFibGUnICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGlmICggbmF2aWdhdG9yLmdldFZSRGV2aWNlcyApIHtcclxuXHJcblx0XHRuYXZpZ2F0b3IuZ2V0VlJEZXZpY2VzKCkudGhlbiggZ290VlJEZXZpY2VzICk7XHJcblxyXG5cdH1cclxuXHJcblx0Ly9cclxuXHJcblx0dGhpcy5zY2FsZSA9IDE7XHJcblxyXG5cdHRoaXMuc2V0U2l6ZSA9IGZ1bmN0aW9uICggd2lkdGgsIGhlaWdodCApIHtcclxuXHJcblx0XHRyZW5kZXJlci5zZXRTaXplKCB3aWR0aCwgaGVpZ2h0ICk7XHJcblxyXG5cdH07XHJcblxyXG5cdC8vIGZ1bGxzY3JlZW5cclxuXHJcblx0dmFyIGlzRnVsbHNjcmVlbiA9IGZhbHNlO1xyXG5cclxuXHR2YXIgY2FudmFzID0gcmVuZGVyZXIuZG9tRWxlbWVudDtcclxuXHR2YXIgZnVsbHNjcmVlbmNoYW5nZSA9IGNhbnZhcy5tb3pSZXF1ZXN0RnVsbFNjcmVlbiA/ICdtb3pmdWxsc2NyZWVuY2hhbmdlJyA6ICd3ZWJraXRmdWxsc2NyZWVuY2hhbmdlJztcclxuXHJcblx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggZnVsbHNjcmVlbmNoYW5nZSwgZnVuY3Rpb24gKCBldmVudCApIHtcclxuXHJcblx0XHRpc0Z1bGxzY3JlZW4gPSBkb2N1bWVudC5tb3pGdWxsU2NyZWVuRWxlbWVudCB8fCBkb2N1bWVudC53ZWJraXRGdWxsc2NyZWVuRWxlbWVudDtcclxuXHJcblx0fSwgZmFsc2UgKTtcclxuXHJcblx0dGhpcy5zZXRGdWxsU2NyZWVuID0gZnVuY3Rpb24gKCBib29sZWFuICkge1xyXG5cclxuXHRcdGlmICggdnJITUQgPT09IHVuZGVmaW5lZCApIHJldHVybjtcclxuXHRcdGlmICggaXNGdWxsc2NyZWVuID09PSBib29sZWFuICkgcmV0dXJuO1xyXG5cclxuXHRcdGlmICggY2FudmFzLm1velJlcXVlc3RGdWxsU2NyZWVuICkge1xyXG5cclxuXHRcdFx0Y2FudmFzLm1velJlcXVlc3RGdWxsU2NyZWVuKCB7IHZyRGlzcGxheTogdnJITUQgfSApO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIGNhbnZhcy53ZWJraXRSZXF1ZXN0RnVsbHNjcmVlbiApIHtcclxuXHJcblx0XHRcdGNhbnZhcy53ZWJraXRSZXF1ZXN0RnVsbHNjcmVlbiggeyB2ckRpc3BsYXk6IHZySE1EIH0gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdC8vIHJlbmRlclxyXG5cclxuXHR2YXIgY2FtZXJhTCA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSgpO1xyXG5cdGNhbWVyYUwubGF5ZXJzLmVuYWJsZSggMSApO1xyXG5cclxuXHR2YXIgY2FtZXJhUiA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSgpO1xyXG5cdGNhbWVyYVIubGF5ZXJzLmVuYWJsZSggMiApO1xyXG5cclxuXHR0aGlzLnJlbmRlciA9IGZ1bmN0aW9uICggc2NlbmUsIGNhbWVyYSApIHtcclxuXHJcblx0XHRpZiAoIHZySE1EICkge1xyXG5cclxuXHRcdFx0dmFyIGV5ZVBhcmFtc0wgPSB2ckhNRC5nZXRFeWVQYXJhbWV0ZXJzKCAnbGVmdCcgKTtcclxuXHRcdFx0dmFyIGV5ZVBhcmFtc1IgPSB2ckhNRC5nZXRFeWVQYXJhbWV0ZXJzKCAncmlnaHQnICk7XHJcblxyXG5cdFx0XHRleWVUcmFuc2xhdGlvbkwgPSBleWVQYXJhbXNMLmV5ZVRyYW5zbGF0aW9uO1xyXG5cdFx0XHRleWVUcmFuc2xhdGlvblIgPSBleWVQYXJhbXNSLmV5ZVRyYW5zbGF0aW9uO1xyXG5cdFx0XHRleWVGT1ZMID0gZXllUGFyYW1zTC5yZWNvbW1lbmRlZEZpZWxkT2ZWaWV3O1xyXG5cdFx0XHRleWVGT1ZSID0gZXllUGFyYW1zUi5yZWNvbW1lbmRlZEZpZWxkT2ZWaWV3O1xyXG5cclxuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBzY2VuZSApICkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WUkVmZmVjdC5yZW5kZXIoKSBubyBsb25nZXIgc3VwcG9ydHMgYXJyYXlzLiBVc2Ugb2JqZWN0LmxheWVycyBpbnN0ZWFkLicgKTtcclxuXHRcdFx0XHRzY2VuZSA9IHNjZW5lWyAwIF07XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgc2l6ZSA9IHJlbmRlcmVyLmdldFNpemUoKTtcclxuXHJcblx0XHRcdHJlbmRlcmVyLnNldFNjaXNzb3JUZXN0KCB0cnVlICk7XHJcblx0XHRcdHJlbmRlcmVyLmNsZWFyKCk7XHJcblxyXG5cdFx0XHRpZiAoIGNhbWVyYS5wYXJlbnQgPT09IG51bGwgKSBjYW1lcmEudXBkYXRlTWF0cml4V29ybGQoKTtcclxuXHJcblx0XHRcdGNhbWVyYUwucHJvamVjdGlvbk1hdHJpeCA9IGZvdlRvUHJvamVjdGlvbiggZXllRk9WTCwgdHJ1ZSwgY2FtZXJhLm5lYXIsIGNhbWVyYS5mYXIgKTtcclxuXHRcdFx0Y2FtZXJhUi5wcm9qZWN0aW9uTWF0cml4ID0gZm92VG9Qcm9qZWN0aW9uKCBleWVGT1ZSLCB0cnVlLCBjYW1lcmEubmVhciwgY2FtZXJhLmZhciApO1xyXG5cclxuXHRcdFx0Y2FtZXJhLm1hdHJpeFdvcmxkLmRlY29tcG9zZSggY2FtZXJhTC5wb3NpdGlvbiwgY2FtZXJhTC5xdWF0ZXJuaW9uLCBjYW1lcmFMLnNjYWxlICk7XHJcblx0XHRcdGNhbWVyYS5tYXRyaXhXb3JsZC5kZWNvbXBvc2UoIGNhbWVyYVIucG9zaXRpb24sIGNhbWVyYVIucXVhdGVybmlvbiwgY2FtZXJhUi5zY2FsZSApO1xyXG5cclxuXHRcdFx0Y2FtZXJhTC50cmFuc2xhdGVYKCBleWVUcmFuc2xhdGlvbkwueCAqIHRoaXMuc2NhbGUgKTtcclxuXHRcdFx0Y2FtZXJhUi50cmFuc2xhdGVYKCBleWVUcmFuc2xhdGlvblIueCAqIHRoaXMuc2NhbGUgKTtcclxuXHJcblx0XHRcdC8vIHJlbmRlciBsZWZ0IGV5ZVxyXG5cdFx0XHRyZW5kZXJlci5zZXRWaWV3cG9ydCggMCwgMCwgc2l6ZS53aWR0aCAvIDIsIHNpemUuaGVpZ2h0ICk7XHJcblx0XHRcdHJlbmRlcmVyLnNldFNjaXNzb3IoIDAsIDAsIHNpemUud2lkdGggLyAyLCBzaXplLmhlaWdodCApO1xyXG5cdFx0XHRyZW5kZXJlci5yZW5kZXIoIHNjZW5lLCBjYW1lcmFMICk7XHJcblxyXG5cdFx0XHQvLyByZW5kZXIgcmlnaHQgZXllXHJcblx0XHRcdHJlbmRlcmVyLnNldFZpZXdwb3J0KCBzaXplLndpZHRoIC8gMiwgMCwgc2l6ZS53aWR0aCAvIDIsIHNpemUuaGVpZ2h0ICk7XHJcblx0XHRcdHJlbmRlcmVyLnNldFNjaXNzb3IoIHNpemUud2lkdGggLyAyLCAwLCBzaXplLndpZHRoIC8gMiwgc2l6ZS5oZWlnaHQgKTtcclxuXHRcdFx0cmVuZGVyZXIucmVuZGVyKCBzY2VuZSwgY2FtZXJhUiApO1xyXG5cclxuXHRcdFx0cmVuZGVyZXIuc2V0U2Npc3NvclRlc3QoIGZhbHNlICk7XHJcblxyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFJlZ3VsYXIgcmVuZGVyIG1vZGUgaWYgbm90IEhNRFxyXG5cclxuXHRcdHJlbmRlcmVyLnJlbmRlciggc2NlbmUsIGNhbWVyYSApO1xyXG5cclxuXHR9O1xyXG5cclxuXHQvL1xyXG5cclxuXHRmdW5jdGlvbiBmb3ZUb05EQ1NjYWxlT2Zmc2V0KCBmb3YgKSB7XHJcblxyXG5cdFx0dmFyIHB4c2NhbGUgPSAyLjAgLyAoIGZvdi5sZWZ0VGFuICsgZm92LnJpZ2h0VGFuICk7XHJcblx0XHR2YXIgcHhvZmZzZXQgPSAoIGZvdi5sZWZ0VGFuIC0gZm92LnJpZ2h0VGFuICkgKiBweHNjYWxlICogMC41O1xyXG5cdFx0dmFyIHB5c2NhbGUgPSAyLjAgLyAoIGZvdi51cFRhbiArIGZvdi5kb3duVGFuICk7XHJcblx0XHR2YXIgcHlvZmZzZXQgPSAoIGZvdi51cFRhbiAtIGZvdi5kb3duVGFuICkgKiBweXNjYWxlICogMC41O1xyXG5cdFx0cmV0dXJuIHsgc2NhbGU6IFsgcHhzY2FsZSwgcHlzY2FsZSBdLCBvZmZzZXQ6IFsgcHhvZmZzZXQsIHB5b2Zmc2V0IF0gfTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBmb3ZQb3J0VG9Qcm9qZWN0aW9uKCBmb3YsIHJpZ2h0SGFuZGVkLCB6TmVhciwgekZhciApIHtcclxuXHJcblx0XHRyaWdodEhhbmRlZCA9IHJpZ2h0SGFuZGVkID09PSB1bmRlZmluZWQgPyB0cnVlIDogcmlnaHRIYW5kZWQ7XHJcblx0XHR6TmVhciA9IHpOZWFyID09PSB1bmRlZmluZWQgPyAwLjAxIDogek5lYXI7XHJcblx0XHR6RmFyID0gekZhciA9PT0gdW5kZWZpbmVkID8gMTAwMDAuMCA6IHpGYXI7XHJcblxyXG5cdFx0dmFyIGhhbmRlZG5lc3NTY2FsZSA9IHJpZ2h0SGFuZGVkID8gLSAxLjAgOiAxLjA7XHJcblxyXG5cdFx0Ly8gc3RhcnQgd2l0aCBhbiBpZGVudGl0eSBtYXRyaXhcclxuXHRcdHZhciBtb2JqID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHRcdHZhciBtID0gbW9iai5lbGVtZW50cztcclxuXHJcblx0XHQvLyBhbmQgd2l0aCBzY2FsZS9vZmZzZXQgaW5mbyBmb3Igbm9ybWFsaXplZCBkZXZpY2UgY29vcmRzXHJcblx0XHR2YXIgc2NhbGVBbmRPZmZzZXQgPSBmb3ZUb05EQ1NjYWxlT2Zmc2V0KCBmb3YgKTtcclxuXHJcblx0XHQvLyBYIHJlc3VsdCwgbWFwIGNsaXAgZWRnZXMgdG8gWy13LCt3XVxyXG5cdFx0bVsgMCAqIDQgKyAwIF0gPSBzY2FsZUFuZE9mZnNldC5zY2FsZVsgMCBdO1xyXG5cdFx0bVsgMCAqIDQgKyAxIF0gPSAwLjA7XHJcblx0XHRtWyAwICogNCArIDIgXSA9IHNjYWxlQW5kT2Zmc2V0Lm9mZnNldFsgMCBdICogaGFuZGVkbmVzc1NjYWxlO1xyXG5cdFx0bVsgMCAqIDQgKyAzIF0gPSAwLjA7XHJcblxyXG5cdFx0Ly8gWSByZXN1bHQsIG1hcCBjbGlwIGVkZ2VzIHRvIFstdywrd11cclxuXHRcdC8vIFkgb2Zmc2V0IGlzIG5lZ2F0ZWQgYmVjYXVzZSB0aGlzIHByb2ogbWF0cml4IHRyYW5zZm9ybXMgZnJvbSB3b3JsZCBjb29yZHMgd2l0aCBZPXVwLFxyXG5cdFx0Ly8gYnV0IHRoZSBOREMgc2NhbGluZyBoYXMgWT1kb3duICh0aGFua3MgRDNEPylcclxuXHRcdG1bIDEgKiA0ICsgMCBdID0gMC4wO1xyXG5cdFx0bVsgMSAqIDQgKyAxIF0gPSBzY2FsZUFuZE9mZnNldC5zY2FsZVsgMSBdO1xyXG5cdFx0bVsgMSAqIDQgKyAyIF0gPSAtIHNjYWxlQW5kT2Zmc2V0Lm9mZnNldFsgMSBdICogaGFuZGVkbmVzc1NjYWxlO1xyXG5cdFx0bVsgMSAqIDQgKyAzIF0gPSAwLjA7XHJcblxyXG5cdFx0Ly8gWiByZXN1bHQgKHVwIHRvIHRoZSBhcHApXHJcblx0XHRtWyAyICogNCArIDAgXSA9IDAuMDtcclxuXHRcdG1bIDIgKiA0ICsgMSBdID0gMC4wO1xyXG5cdFx0bVsgMiAqIDQgKyAyIF0gPSB6RmFyIC8gKCB6TmVhciAtIHpGYXIgKSAqIC0gaGFuZGVkbmVzc1NjYWxlO1xyXG5cdFx0bVsgMiAqIDQgKyAzIF0gPSAoIHpGYXIgKiB6TmVhciApIC8gKCB6TmVhciAtIHpGYXIgKTtcclxuXHJcblx0XHQvLyBXIHJlc3VsdCAoPSBaIGluKVxyXG5cdFx0bVsgMyAqIDQgKyAwIF0gPSAwLjA7XHJcblx0XHRtWyAzICogNCArIDEgXSA9IDAuMDtcclxuXHRcdG1bIDMgKiA0ICsgMiBdID0gaGFuZGVkbmVzc1NjYWxlO1xyXG5cdFx0bVsgMyAqIDQgKyAzIF0gPSAwLjA7XHJcblxyXG5cdFx0bW9iai50cmFuc3Bvc2UoKTtcclxuXHJcblx0XHRyZXR1cm4gbW9iajtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBmb3ZUb1Byb2plY3Rpb24oIGZvdiwgcmlnaHRIYW5kZWQsIHpOZWFyLCB6RmFyICkge1xyXG5cclxuXHRcdHZhciBERUcyUkFEID0gTWF0aC5QSSAvIDE4MC4wO1xyXG5cclxuXHRcdHZhciBmb3ZQb3J0ID0ge1xyXG5cdFx0XHR1cFRhbjogTWF0aC50YW4oIGZvdi51cERlZ3JlZXMgKiBERUcyUkFEICksXHJcblx0XHRcdGRvd25UYW46IE1hdGgudGFuKCBmb3YuZG93bkRlZ3JlZXMgKiBERUcyUkFEICksXHJcblx0XHRcdGxlZnRUYW46IE1hdGgudGFuKCBmb3YubGVmdERlZ3JlZXMgKiBERUcyUkFEICksXHJcblx0XHRcdHJpZ2h0VGFuOiBNYXRoLnRhbiggZm92LnJpZ2h0RGVncmVlcyAqIERFRzJSQUQgKVxyXG5cdFx0fTtcclxuXHJcblx0XHRyZXR1cm4gZm92UG9ydFRvUHJvamVjdGlvbiggZm92UG9ydCwgcmlnaHRIYW5kZWQsIHpOZWFyLCB6RmFyICk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxufSx7fV0sMTg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLyoqXHJcbiogQGF1dGhvciBUaW0gS25pcCAvIGh0dHA6Ly93d3cuZmxvb3JwbGFubmVyLmNvbS8gLyB0aW0gYXQgZmxvb3JwbGFubmVyLmNvbVxyXG4qIEBhdXRob3IgVG9ueSBQYXJpc2kgLyBodHRwOi8vd3d3LnRvbnlwYXJpc2kuY29tL1xyXG4qL1xyXG5cclxuVEhSRUUuQ29sbGFkYUxvYWRlciA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dmFyIENPTExBREEgPSBudWxsO1xyXG5cdHZhciBzY2VuZSA9IG51bGw7XHJcblx0dmFyIHZpc3VhbFNjZW5lO1xyXG5cdHZhciBraW5lbWF0aWNzTW9kZWw7XHJcblxyXG5cdHZhciByZWFkeUNhbGxiYWNrRnVuYyA9IG51bGw7XHJcblxyXG5cdHZhciBzb3VyY2VzID0ge307XHJcblx0dmFyIGltYWdlcyA9IHt9O1xyXG5cdHZhciBhbmltYXRpb25zID0ge307XHJcblx0dmFyIGNvbnRyb2xsZXJzID0ge307XHJcblx0dmFyIGdlb21ldHJpZXMgPSB7fTtcclxuXHR2YXIgbWF0ZXJpYWxzID0ge307XHJcblx0dmFyIGVmZmVjdHMgPSB7fTtcclxuXHR2YXIgY2FtZXJhcyA9IHt9O1xyXG5cdHZhciBsaWdodHMgPSB7fTtcclxuXHJcblx0dmFyIGFuaW1EYXRhO1xyXG5cdHZhciBraW5lbWF0aWNzO1xyXG5cdHZhciB2aXN1YWxTY2VuZXM7XHJcblx0dmFyIGtpbmVtYXRpY3NNb2RlbHM7XHJcblx0dmFyIGJhc2VVcmw7XHJcblx0dmFyIG1vcnBocztcclxuXHR2YXIgc2tpbnM7XHJcblxyXG5cdHZhciBmbGlwX3V2ID0gdHJ1ZTtcclxuXHR2YXIgcHJlZmVycmVkU2hhZGluZyA9IFRIUkVFLlNtb290aFNoYWRpbmc7XHJcblxyXG5cdHZhciBvcHRpb25zID0ge1xyXG5cdFx0Ly8gRm9yY2UgR2VvbWV0cnkgdG8gYWx3YXlzIGJlIGNlbnRlcmVkIGF0IHRoZSBsb2NhbCBvcmlnaW4gb2YgdGhlXHJcblx0XHQvLyBjb250YWluaW5nIE1lc2guXHJcblx0XHRjZW50ZXJHZW9tZXRyeTogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQXhpcyBjb252ZXJzaW9uIGlzIGRvbmUgZm9yIGdlb21ldHJpZXMsIGFuaW1hdGlvbnMsIGFuZCBjb250cm9sbGVycy5cclxuXHRcdC8vIElmIHdlIGV2ZXIgcHVsbCBjYW1lcmFzIG9yIGxpZ2h0cyBvdXQgb2YgdGhlIENPTExBREEgZmlsZSwgdGhleSdsbFxyXG5cdFx0Ly8gbmVlZCBleHRyYSB3b3JrLlxyXG5cdFx0Y29udmVydFVwQXhpczogZmFsc2UsXHJcblxyXG5cdFx0c3ViZGl2aWRlRmFjZXM6IHRydWUsXHJcblxyXG5cdFx0dXBBeGlzOiAnWScsXHJcblxyXG5cdFx0Ly8gRm9yIHJlZmxlY3RpdmUgb3IgcmVmcmFjdGl2ZSBtYXRlcmlhbHMgd2UnbGwgdXNlIHRoaXMgY3ViZW1hcFxyXG5cdFx0ZGVmYXVsdEVudk1hcDogbnVsbFxyXG5cclxuXHR9O1xyXG5cclxuXHR2YXIgY29sbGFkYVVuaXQgPSAxLjA7XHJcblx0dmFyIGNvbGxhZGFVcCA9ICdZJztcclxuXHR2YXIgdXBDb252ZXJzaW9uID0gbnVsbDtcclxuXHJcblx0ZnVuY3Rpb24gbG9hZCAoIHVybCwgcmVhZHlDYWxsYmFjaywgcHJvZ3Jlc3NDYWxsYmFjaywgZmFpbENhbGxiYWNrICkge1xyXG5cclxuXHRcdHZhciBsZW5ndGggPSAwO1xyXG5cclxuXHRcdGlmICggZG9jdW1lbnQuaW1wbGVtZW50YXRpb24gJiYgZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlRG9jdW1lbnQgKSB7XHJcblxyXG5cdFx0XHR2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG5cclxuXHRcdFx0cmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcclxuXHJcblx0XHRcdFx0aWYgKCByZXF1ZXN0LnJlYWR5U3RhdGUgPT09IDQgKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCByZXF1ZXN0LnN0YXR1cyA9PT0gMCB8fCByZXF1ZXN0LnN0YXR1cyA9PT0gMjAwICkge1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCByZXF1ZXN0LnJlc3BvbnNlICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRyZWFkeUNhbGxiYWNrRnVuYyA9IHJlYWR5Q2FsbGJhY2s7XHJcblx0XHRcdFx0XHRcdFx0cGFyc2UoIHJlcXVlc3QucmVzcG9uc2UsIHVuZGVmaW5lZCwgdXJsICk7XHJcblxyXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRpZiAoIGZhaWxDYWxsYmFjayApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRmYWlsQ2FsbGJhY2soKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCBcIkNvbGxhZGFMb2FkZXI6IEVtcHR5IG9yIG5vbi1leGlzdGluZyBmaWxlIChcIiArIHVybCArIFwiKVwiICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHJlcXVlc3QucmVhZHlTdGF0ZSA9PT0gMyApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIHByb2dyZXNzQ2FsbGJhY2sgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIGxlbmd0aCA9PT0gMCApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0bGVuZ3RoID0gcmVxdWVzdC5nZXRSZXNwb25zZUhlYWRlciggXCJDb250ZW50LUxlbmd0aFwiICk7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRwcm9ncmVzc0NhbGxiYWNrKCB7IHRvdGFsOiBsZW5ndGgsIGxvYWRlZDogcmVxdWVzdC5yZXNwb25zZVRleHQubGVuZ3RoIH0gKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHRyZXF1ZXN0Lm9wZW4oIFwiR0VUXCIsIHVybCwgdHJ1ZSApO1xyXG5cdFx0XHRyZXF1ZXN0LnNlbmQoIG51bGwgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0YWxlcnQoIFwiRG9uJ3Qga25vdyBob3cgdG8gcGFyc2UgWE1MIVwiICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHBhcnNlKCB0ZXh0LCBjYWxsQmFjaywgdXJsICkge1xyXG5cclxuXHRcdENPTExBREEgPSBuZXcgRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKCB0ZXh0LCAndGV4dC94bWwnICk7XHJcblx0XHRjYWxsQmFjayA9IGNhbGxCYWNrIHx8IHJlYWR5Q2FsbGJhY2tGdW5jO1xyXG5cclxuXHRcdGlmICggdXJsICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHR2YXIgcGFydHMgPSB1cmwuc3BsaXQoICcvJyApO1xyXG5cdFx0XHRwYXJ0cy5wb3AoKTtcclxuXHRcdFx0YmFzZVVybCA9ICggcGFydHMubGVuZ3RoIDwgMSA/ICcuJyA6IHBhcnRzLmpvaW4oICcvJyApICkgKyAnLyc7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHBhcnNlQXNzZXQoKTtcclxuXHRcdHNldFVwQ29udmVyc2lvbigpO1xyXG5cdFx0aW1hZ2VzID0gcGFyc2VMaWIoIFwibGlicmFyeV9pbWFnZXMgaW1hZ2VcIiwgX0ltYWdlLCBcImltYWdlXCIgKTtcclxuXHRcdG1hdGVyaWFscyA9IHBhcnNlTGliKCBcImxpYnJhcnlfbWF0ZXJpYWxzIG1hdGVyaWFsXCIsIE1hdGVyaWFsLCBcIm1hdGVyaWFsXCIgKTtcclxuXHRcdGVmZmVjdHMgPSBwYXJzZUxpYiggXCJsaWJyYXJ5X2VmZmVjdHMgZWZmZWN0XCIsIEVmZmVjdCwgXCJlZmZlY3RcIiApO1xyXG5cdFx0Z2VvbWV0cmllcyA9IHBhcnNlTGliKCBcImxpYnJhcnlfZ2VvbWV0cmllcyBnZW9tZXRyeVwiLCBHZW9tZXRyeSwgXCJnZW9tZXRyeVwiICk7XHJcblx0XHRjYW1lcmFzID0gcGFyc2VMaWIoIFwibGlicmFyeV9jYW1lcmFzIGNhbWVyYVwiLCBDYW1lcmEsIFwiY2FtZXJhXCIgKTtcclxuXHRcdGxpZ2h0cyA9IHBhcnNlTGliKCBcImxpYnJhcnlfbGlnaHRzIGxpZ2h0XCIsIExpZ2h0LCBcImxpZ2h0XCIgKTtcclxuXHRcdGNvbnRyb2xsZXJzID0gcGFyc2VMaWIoIFwibGlicmFyeV9jb250cm9sbGVycyBjb250cm9sbGVyXCIsIENvbnRyb2xsZXIsIFwiY29udHJvbGxlclwiICk7XHJcblx0XHRhbmltYXRpb25zID0gcGFyc2VMaWIoIFwibGlicmFyeV9hbmltYXRpb25zIGFuaW1hdGlvblwiLCBBbmltYXRpb24sIFwiYW5pbWF0aW9uXCIgKTtcclxuXHRcdHZpc3VhbFNjZW5lcyA9IHBhcnNlTGliKCBcImxpYnJhcnlfdmlzdWFsX3NjZW5lcyB2aXN1YWxfc2NlbmVcIiwgVmlzdWFsU2NlbmUsIFwidmlzdWFsX3NjZW5lXCIgKTtcclxuXHRcdGtpbmVtYXRpY3NNb2RlbHMgPSBwYXJzZUxpYiggXCJsaWJyYXJ5X2tpbmVtYXRpY3NfbW9kZWxzIGtpbmVtYXRpY3NfbW9kZWxcIiwgS2luZW1hdGljc01vZGVsLCBcImtpbmVtYXRpY3NfbW9kZWxcIiApO1xyXG5cclxuXHRcdG1vcnBocyA9IFtdO1xyXG5cdFx0c2tpbnMgPSBbXTtcclxuXHJcblx0XHR2aXN1YWxTY2VuZSA9IHBhcnNlU2NlbmUoKTtcclxuXHRcdHNjZW5lID0gbmV3IFRIUkVFLkdyb3VwKCk7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdmlzdWFsU2NlbmUubm9kZXMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0c2NlbmUuYWRkKCBjcmVhdGVTY2VuZUdyYXBoKCB2aXN1YWxTY2VuZS5ub2Rlc1sgaSBdICkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gdW5pdCBjb252ZXJzaW9uXHJcblx0XHRzY2VuZS5zY2FsZS5tdWx0aXBseVNjYWxhciggY29sbGFkYVVuaXQgKTtcclxuXHJcblx0XHRjcmVhdGVBbmltYXRpb25zKCk7XHJcblxyXG5cdFx0a2luZW1hdGljc01vZGVsID0gcGFyc2VLaW5lbWF0aWNzTW9kZWwoKTtcclxuXHRcdGNyZWF0ZUtpbmVtYXRpY3MoKTtcclxuXHJcblx0XHR2YXIgcmVzdWx0ID0ge1xyXG5cclxuXHRcdFx0c2NlbmU6IHNjZW5lLFxyXG5cdFx0XHRtb3JwaHM6IG1vcnBocyxcclxuXHRcdFx0c2tpbnM6IHNraW5zLFxyXG5cdFx0XHRhbmltYXRpb25zOiBhbmltRGF0YSxcclxuXHRcdFx0a2luZW1hdGljczoga2luZW1hdGljcyxcclxuXHRcdFx0ZGFlOiB7XHJcblx0XHRcdFx0aW1hZ2VzOiBpbWFnZXMsXHJcblx0XHRcdFx0bWF0ZXJpYWxzOiBtYXRlcmlhbHMsXHJcblx0XHRcdFx0Y2FtZXJhczogY2FtZXJhcyxcclxuXHRcdFx0XHRsaWdodHM6IGxpZ2h0cyxcclxuXHRcdFx0XHRlZmZlY3RzOiBlZmZlY3RzLFxyXG5cdFx0XHRcdGdlb21ldHJpZXM6IGdlb21ldHJpZXMsXHJcblx0XHRcdFx0Y29udHJvbGxlcnM6IGNvbnRyb2xsZXJzLFxyXG5cdFx0XHRcdGFuaW1hdGlvbnM6IGFuaW1hdGlvbnMsXHJcblx0XHRcdFx0dmlzdWFsU2NlbmVzOiB2aXN1YWxTY2VuZXMsXHJcblx0XHRcdFx0dmlzdWFsU2NlbmU6IHZpc3VhbFNjZW5lLFxyXG5cdFx0XHRcdHNjZW5lOiB2aXN1YWxTY2VuZSxcclxuXHRcdFx0XHRraW5lbWF0aWNzTW9kZWxzOiBraW5lbWF0aWNzTW9kZWxzLFxyXG5cdFx0XHRcdGtpbmVtYXRpY3NNb2RlbDoga2luZW1hdGljc01vZGVsXHJcblx0XHRcdH1cclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdGlmICggY2FsbEJhY2sgKSB7XHJcblxyXG5cdFx0XHRjYWxsQmFjayggcmVzdWx0ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiByZXN1bHQ7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gc2V0UHJlZmVycmVkU2hhZGluZyAoIHNoYWRpbmcgKSB7XHJcblxyXG5cdFx0cHJlZmVycmVkU2hhZGluZyA9IHNoYWRpbmc7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gcGFyc2VBc3NldCAoKSB7XHJcblxyXG5cdFx0dmFyIGVsZW1lbnRzID0gQ09MTEFEQS5xdWVyeVNlbGVjdG9yQWxsKCdhc3NldCcpO1xyXG5cclxuXHRcdHZhciBlbGVtZW50ID0gZWxlbWVudHNbMF07XHJcblxyXG5cdFx0aWYgKCBlbGVtZW50ICYmIGVsZW1lbnQuY2hpbGROb2RlcyApIHtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBjaGlsZCA9IGVsZW1lbnQuY2hpbGROb2Rlc1sgaSBdO1xyXG5cclxuXHRcdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcclxuXHJcblx0XHRcdFx0XHRjYXNlICd1bml0JzpcclxuXHJcblx0XHRcdFx0XHRcdHZhciBtZXRlciA9IGNoaWxkLmdldEF0dHJpYnV0ZSggJ21ldGVyJyApO1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCBtZXRlciApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0Y29sbGFkYVVuaXQgPSBwYXJzZUZsb2F0KCBtZXRlciApO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSAndXBfYXhpcyc6XHJcblxyXG5cdFx0XHRcdFx0XHRjb2xsYWRhVXAgPSBjaGlsZC50ZXh0Q29udGVudC5jaGFyQXQoMCk7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHBhcnNlTGliICggcSwgY2xhc3NTcGVjLCBwcmVmaXggKSB7XHJcblxyXG5cdFx0dmFyIGVsZW1lbnRzID0gQ09MTEFEQS5xdWVyeVNlbGVjdG9yQWxsKHEpO1xyXG5cclxuXHRcdHZhciBsaWIgPSB7fTtcclxuXHJcblx0XHR2YXIgaSA9IDA7XHJcblxyXG5cdFx0dmFyIGVsZW1lbnRzTGVuZ3RoID0gZWxlbWVudHMubGVuZ3RoO1xyXG5cclxuXHRcdGZvciAoIHZhciBqID0gMDsgaiA8IGVsZW1lbnRzTGVuZ3RoOyBqICsrICkge1xyXG5cclxuXHRcdFx0dmFyIGVsZW1lbnQgPSBlbGVtZW50c1tqXTtcclxuXHRcdFx0dmFyIGRhZUVsZW1lbnQgPSAoIG5ldyBjbGFzc1NwZWMoKSApLnBhcnNlKCBlbGVtZW50ICk7XHJcblxyXG5cdFx0XHRpZiAoICFkYWVFbGVtZW50LmlkIHx8IGRhZUVsZW1lbnQuaWQubGVuZ3RoID09PSAwICkgZGFlRWxlbWVudC5pZCA9IHByZWZpeCArICggaSArKyApO1xyXG5cdFx0XHRsaWJbIGRhZUVsZW1lbnQuaWQgXSA9IGRhZUVsZW1lbnQ7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBsaWI7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gcGFyc2VTY2VuZSgpIHtcclxuXHJcblx0XHR2YXIgc2NlbmVFbGVtZW50ID0gQ09MTEFEQS5xdWVyeVNlbGVjdG9yQWxsKCdzY2VuZSBpbnN0YW5jZV92aXN1YWxfc2NlbmUnKVswXTtcclxuXHJcblx0XHRpZiAoIHNjZW5lRWxlbWVudCApIHtcclxuXHJcblx0XHRcdHZhciB1cmwgPSBzY2VuZUVsZW1lbnQuZ2V0QXR0cmlidXRlKCAndXJsJyApLnJlcGxhY2UoIC9eIy8sICcnICk7XHJcblx0XHRcdHJldHVybiB2aXN1YWxTY2VuZXNbIHVybC5sZW5ndGggPiAwID8gdXJsIDogJ3Zpc3VhbF9zY2VuZTAnIF07XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHJldHVybiBudWxsO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBwYXJzZUtpbmVtYXRpY3NNb2RlbCgpIHtcclxuXHJcblx0XHR2YXIga2luZW1hdGljc01vZGVsRWxlbWVudCA9IENPTExBREEucXVlcnlTZWxlY3RvckFsbCgnaW5zdGFuY2Vfa2luZW1hdGljc19tb2RlbCcpWzBdO1xyXG5cclxuXHRcdGlmICgga2luZW1hdGljc01vZGVsRWxlbWVudCApIHtcclxuXHJcblx0XHRcdHZhciB1cmwgPSBraW5lbWF0aWNzTW9kZWxFbGVtZW50LmdldEF0dHJpYnV0ZSggJ3VybCcgKS5yZXBsYWNlKC9eIy8sICcnKTtcclxuXHRcdFx0cmV0dXJuIGtpbmVtYXRpY3NNb2RlbHNbIHVybC5sZW5ndGggPiAwID8gdXJsIDogJ2tpbmVtYXRpY3NfbW9kZWwwJyBdO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gY3JlYXRlQW5pbWF0aW9ucygpIHtcclxuXHJcblx0XHRhbmltRGF0YSA9IFtdO1xyXG5cclxuXHRcdC8vIGZpbGwgaW4gdGhlIGtleXNcclxuXHRcdHJlY3Vyc2VIaWVyYXJjaHkoIHNjZW5lICk7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gcmVjdXJzZUhpZXJhcmNoeSggbm9kZSApIHtcclxuXHJcblx0XHR2YXIgbiA9IHZpc3VhbFNjZW5lLmdldENoaWxkQnlJZCggbm9kZS5jb2xsYWRhSWQsIHRydWUgKSxcclxuXHRcdFx0bmV3RGF0YSA9IG51bGw7XHJcblxyXG5cdFx0aWYgKCBuICYmIG4ua2V5cyApIHtcclxuXHJcblx0XHRcdG5ld0RhdGEgPSB7XHJcblx0XHRcdFx0ZnBzOiA2MCxcclxuXHRcdFx0XHRoaWVyYXJjaHk6IFsge1xyXG5cdFx0XHRcdFx0bm9kZTogbixcclxuXHRcdFx0XHRcdGtleXM6IG4ua2V5cyxcclxuXHRcdFx0XHRcdHNpZHM6IG4uc2lkc1xyXG5cdFx0XHRcdH0gXSxcclxuXHRcdFx0XHRub2RlOiBub2RlLFxyXG5cdFx0XHRcdG5hbWU6ICdhbmltYXRpb25fJyArIG5vZGUubmFtZSxcclxuXHRcdFx0XHRsZW5ndGg6IDBcclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdGFuaW1EYXRhLnB1c2gobmV3RGF0YSk7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gbi5rZXlzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRuZXdEYXRhLmxlbmd0aCA9IE1hdGgubWF4KCBuZXdEYXRhLmxlbmd0aCwgbi5rZXlzW2ldLnRpbWUgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0bmV3RGF0YSA9IHtcclxuXHRcdFx0XHRoaWVyYXJjaHk6IFsge1xyXG5cdFx0XHRcdFx0a2V5czogW10sXHJcblx0XHRcdFx0XHRzaWRzOiBbXVxyXG5cdFx0XHRcdH0gXVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIGQgPSByZWN1cnNlSGllcmFyY2h5KCBub2RlLmNoaWxkcmVuW2ldICk7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gZC5oaWVyYXJjaHkubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdG5ld0RhdGEuaGllcmFyY2h5LnB1c2goIHtcclxuXHRcdFx0XHRcdGtleXM6IFtdLFxyXG5cdFx0XHRcdFx0c2lkczogW11cclxuXHRcdFx0XHR9ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBuZXdEYXRhO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGNhbGNBbmltYXRpb25Cb3VuZHMgKCkge1xyXG5cclxuXHRcdHZhciBzdGFydCA9IDEwMDAwMDA7XHJcblx0XHR2YXIgZW5kID0gLXN0YXJ0O1xyXG5cdFx0dmFyIGZyYW1lcyA9IDA7XHJcblx0XHR2YXIgSUQ7XHJcblx0XHRmb3IgKCB2YXIgaWQgaW4gYW5pbWF0aW9ucyApIHtcclxuXHJcblx0XHRcdHZhciBhbmltYXRpb24gPSBhbmltYXRpb25zWyBpZCBdO1xyXG5cdFx0XHRJRCA9IElEIHx8IGFuaW1hdGlvbi5pZDtcclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgYW5pbWF0aW9uLnNhbXBsZXIubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgc2FtcGxlciA9IGFuaW1hdGlvbi5zYW1wbGVyWyBpIF07XHJcblxyXG5cdFx0XHRcdHNhbXBsZXIuY3JlYXRlKCk7XHJcblxyXG5cdFx0XHRcdHN0YXJ0ID0gTWF0aC5taW4oIHN0YXJ0LCBzYW1wbGVyLnN0YXJ0VGltZSApO1xyXG5cdFx0XHRcdGVuZCA9IE1hdGgubWF4KCBlbmQsIHNhbXBsZXIuZW5kVGltZSApO1xyXG5cdFx0XHRcdGZyYW1lcyA9IE1hdGgubWF4KCBmcmFtZXMsIHNhbXBsZXIuaW5wdXQubGVuZ3RoICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB7IHN0YXJ0OnN0YXJ0LCBlbmQ6ZW5kLCBmcmFtZXM6ZnJhbWVzLElEOklEIH07XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gY3JlYXRlTW9ycGggKCBnZW9tZXRyeSwgY3RybCApIHtcclxuXHJcblx0XHR2YXIgbW9ycGhDdHJsID0gY3RybCBpbnN0YW5jZW9mIEluc3RhbmNlQ29udHJvbGxlciA/IGNvbnRyb2xsZXJzWyBjdHJsLnVybCBdIDogY3RybDtcclxuXHJcblx0XHRpZiAoICFtb3JwaEN0cmwgfHwgIW1vcnBoQ3RybC5tb3JwaCApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUubG9nKFwiY291bGQgbm90IGZpbmQgbW9ycGggY29udHJvbGxlciFcIik7XHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG1vcnBoID0gbW9ycGhDdHJsLm1vcnBoO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IG1vcnBoLnRhcmdldHMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIHRhcmdldF9pZCA9IG1vcnBoLnRhcmdldHNbIGkgXTtcclxuXHRcdFx0dmFyIGRhZUdlb21ldHJ5ID0gZ2VvbWV0cmllc1sgdGFyZ2V0X2lkIF07XHJcblxyXG5cdFx0XHRpZiAoICFkYWVHZW9tZXRyeS5tZXNoIHx8XHJcblx0XHRcdFx0ICFkYWVHZW9tZXRyeS5tZXNoLnByaW1pdGl2ZXMgfHxcclxuXHRcdFx0XHQgIWRhZUdlb21ldHJ5Lm1lc2gucHJpbWl0aXZlcy5sZW5ndGggKSB7XHJcblx0XHRcdFx0IGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgdGFyZ2V0ID0gZGFlR2VvbWV0cnkubWVzaC5wcmltaXRpdmVzWyAwIF0uZ2VvbWV0cnk7XHJcblxyXG5cdFx0XHRpZiAoIHRhcmdldC52ZXJ0aWNlcy5sZW5ndGggPT09IGdlb21ldHJ5LnZlcnRpY2VzLmxlbmd0aCApIHtcclxuXHJcblx0XHRcdFx0Z2VvbWV0cnkubW9ycGhUYXJnZXRzLnB1c2goIHsgbmFtZTogXCJ0YXJnZXRfMVwiLCB2ZXJ0aWNlczogdGFyZ2V0LnZlcnRpY2VzIH0gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Z2VvbWV0cnkubW9ycGhUYXJnZXRzLnB1c2goIHsgbmFtZTogXCJ0YXJnZXRfWlwiLCB2ZXJ0aWNlczogZ2VvbWV0cnkudmVydGljZXMgfSApO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGNyZWF0ZVNraW4gKCBnZW9tZXRyeSwgY3RybCwgYXBwbHlCaW5kU2hhcGUgKSB7XHJcblxyXG5cdFx0dmFyIHNraW5DdHJsID0gY29udHJvbGxlcnNbIGN0cmwudXJsIF07XHJcblxyXG5cdFx0aWYgKCAhc2tpbkN0cmwgfHwgIXNraW5DdHJsLnNraW4gKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLmxvZyggXCJjb3VsZCBub3QgZmluZCBza2luIGNvbnRyb2xsZXIhXCIgKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoICFjdHJsLnNrZWxldG9uIHx8ICFjdHJsLnNrZWxldG9uLmxlbmd0aCApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUubG9nKCBcImNvdWxkIG5vdCBmaW5kIHRoZSBza2VsZXRvbiBmb3IgdGhlIHNraW4hXCIgKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgc2tpbiA9IHNraW5DdHJsLnNraW47XHJcblx0XHR2YXIgc2tlbGV0b24gPSB2aXN1YWxTY2VuZS5nZXRDaGlsZEJ5SWQoIGN0cmwuc2tlbGV0b25bIDAgXSApO1xyXG5cdFx0dmFyIGhpZXJhcmNoeSA9IFtdO1xyXG5cclxuXHRcdGFwcGx5QmluZFNoYXBlID0gYXBwbHlCaW5kU2hhcGUgIT09IHVuZGVmaW5lZCA/IGFwcGx5QmluZFNoYXBlIDogdHJ1ZTtcclxuXHJcblx0XHR2YXIgYm9uZXMgPSBbXTtcclxuXHRcdGdlb21ldHJ5LnNraW5XZWlnaHRzID0gW107XHJcblx0XHRnZW9tZXRyeS5za2luSW5kaWNlcyA9IFtdO1xyXG5cclxuXHRcdC8vY3JlYXRlQm9uZXMoIGdlb21ldHJ5LmJvbmVzLCBza2luLCBoaWVyYXJjaHksIHNrZWxldG9uLCBudWxsLCAtMSApO1xyXG5cdFx0Ly9jcmVhdGVXZWlnaHRzKCBza2luLCBnZW9tZXRyeS5ib25lcywgZ2VvbWV0cnkuc2tpbkluZGljZXMsIGdlb21ldHJ5LnNraW5XZWlnaHRzICk7XHJcblxyXG5cdFx0LypcclxuXHRcdGdlb21ldHJ5LmFuaW1hdGlvbiA9IHtcclxuXHRcdFx0bmFtZTogJ3Rha2VfMDAxJyxcclxuXHRcdFx0ZnBzOiAzMCxcclxuXHRcdFx0bGVuZ3RoOiAyLFxyXG5cdFx0XHRKSVQ6IHRydWUsXHJcblx0XHRcdGhpZXJhcmNoeTogaGllcmFyY2h5XHJcblx0XHR9O1xyXG5cdFx0Ki9cclxuXHJcblx0XHRpZiAoIGFwcGx5QmluZFNoYXBlICkge1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRnZW9tZXRyeS52ZXJ0aWNlc1sgaSBdLmFwcGx5TWF0cml4NCggc2tpbi5iaW5kU2hhcGVNYXRyaXggKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gc2V0dXBTa2VsZXRvbiAoIG5vZGUsIGJvbmVzLCBmcmFtZSwgcGFyZW50ICkge1xyXG5cclxuXHRcdG5vZGUud29ybGQgPSBub2RlLndvcmxkIHx8IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblx0XHRub2RlLmxvY2Fsd29ybGQgPSBub2RlLmxvY2Fsd29ybGQgfHwgbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHRcdG5vZGUud29ybGQuY29weSggbm9kZS5tYXRyaXggKTtcclxuXHRcdG5vZGUubG9jYWx3b3JsZC5jb3B5KCBub2RlLm1hdHJpeCApO1xyXG5cclxuXHRcdGlmICggbm9kZS5jaGFubmVscyAmJiBub2RlLmNoYW5uZWxzLmxlbmd0aCApIHtcclxuXHJcblx0XHRcdHZhciBjaGFubmVsID0gbm9kZS5jaGFubmVsc1sgMCBdO1xyXG5cdFx0XHR2YXIgbSA9IGNoYW5uZWwuc2FtcGxlci5vdXRwdXRbIGZyYW1lIF07XHJcblxyXG5cdFx0XHRpZiAoIG0gaW5zdGFuY2VvZiBUSFJFRS5NYXRyaXg0ICkge1xyXG5cclxuXHRcdFx0XHRub2RlLndvcmxkLmNvcHkoIG0gKTtcclxuXHRcdFx0XHRub2RlLmxvY2Fsd29ybGQuY29weShtKTtcclxuXHRcdFx0XHRpZiAoZnJhbWUgPT09IDApXHJcblx0XHRcdFx0XHRub2RlLm1hdHJpeC5jb3B5KG0pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggcGFyZW50ICkge1xyXG5cclxuXHRcdFx0bm9kZS53b3JsZC5tdWx0aXBseU1hdHJpY2VzKCBwYXJlbnQsIG5vZGUud29ybGQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ym9uZXMucHVzaCggbm9kZSApO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IG5vZGUubm9kZXMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0c2V0dXBTa2VsZXRvbiggbm9kZS5ub2Rlc1sgaSBdLCBib25lcywgZnJhbWUsIG5vZGUud29ybGQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gc2V0dXBTa2lubmluZ01hdHJpY2VzICggYm9uZXMsIHNraW4gKSB7XHJcblxyXG5cdFx0Ly8gRklYTUU6IHRoaXMgaXMgZHVtYi4uLlxyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGJvbmVzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciBib25lID0gYm9uZXNbIGkgXTtcclxuXHRcdFx0dmFyIGZvdW5kID0gLTE7XHJcblxyXG5cdFx0XHRpZiAoIGJvbmUudHlwZSAhPSAnSk9JTlQnICkgY29udGludWU7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCBza2luLmpvaW50cy5sZW5ndGg7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggYm9uZS5zaWQgPT09IHNraW4uam9pbnRzWyBqIF0gKSB7XHJcblxyXG5cdFx0XHRcdFx0Zm91bmQgPSBqO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggZm91bmQgPj0gMCApIHtcclxuXHJcblx0XHRcdFx0dmFyIGludiA9IHNraW4uaW52QmluZE1hdHJpY2VzWyBmb3VuZCBdO1xyXG5cclxuXHRcdFx0XHRib25lLmludkJpbmRNYXRyaXggPSBpbnY7XHJcblx0XHRcdFx0Ym9uZS5za2lubmluZ01hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblx0XHRcdFx0Ym9uZS5za2lubmluZ01hdHJpeC5tdWx0aXBseU1hdHJpY2VzKGJvbmUud29ybGQsIGludik7IC8vIChJQk1pICogSk1pKVxyXG5cdFx0XHRcdGJvbmUuYW5pbWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHJcblx0XHRcdFx0Ym9uZS5hbmltYXRyaXguY29weShib25lLmxvY2Fsd29ybGQpO1xyXG5cdFx0XHRcdGJvbmUud2VpZ2h0cyA9IFtdO1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCBza2luLndlaWdodHMubGVuZ3RoOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHRcdGZvciAodmFyIGsgPSAwOyBrIDwgc2tpbi53ZWlnaHRzWyBqIF0ubGVuZ3RoOyBrICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dmFyIHcgPSBza2luLndlaWdodHNbIGogXVsgayBdO1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCB3LmpvaW50ID09PSBmb3VuZCApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0Ym9uZS53ZWlnaHRzLnB1c2goIHcgKTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggXCJDb2xsYWRhTG9hZGVyOiBDb3VsZCBub3QgZmluZCBqb2ludCAnXCIgKyBib25lLnNpZCArIFwiJy5cIiApO1xyXG5cclxuXHRcdFx0XHRib25lLnNraW5uaW5nTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHRcdFx0XHRib25lLndlaWdodHMgPSBbXTtcclxuXHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHQvL1dhbGsgdGhlIENvbGxhZGEgdHJlZSBhbmQgZmxhdHRlbiB0aGUgYm9uZXMgaW50byBhIGxpc3QsIGV4dHJhY3QgdGhlIHBvc2l0aW9uLCBxdWF0IGFuZCBzY2FsZSBmcm9tIHRoZSBtYXRyaXhcclxuXHRmdW5jdGlvbiBmbGF0dGVuU2tlbGV0b24oc2tlbGV0b24pIHtcclxuXHJcblx0XHR2YXIgbGlzdCA9IFtdO1xyXG5cdFx0dmFyIHdhbGsgPSBmdW5jdGlvbihwYXJlbnRpZCwgbm9kZSwgbGlzdCkge1xyXG5cclxuXHRcdFx0dmFyIGJvbmUgPSB7fTtcclxuXHRcdFx0Ym9uZS5uYW1lID0gbm9kZS5zaWQ7XHJcblx0XHRcdGJvbmUucGFyZW50ID0gcGFyZW50aWQ7XHJcblx0XHRcdGJvbmUubWF0cml4ID0gbm9kZS5tYXRyaXg7XHJcblx0XHRcdHZhciBkYXRhID0gWyBuZXcgVEhSRUUuVmVjdG9yMygpLG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCksbmV3IFRIUkVFLlZlY3RvcjMoKSBdO1xyXG5cdFx0XHRib25lLm1hdHJpeC5kZWNvbXBvc2UoZGF0YVswXSwgZGF0YVsxXSwgZGF0YVsyXSk7XHJcblxyXG5cdFx0XHRib25lLnBvcyA9IFsgZGF0YVswXS54LGRhdGFbMF0ueSxkYXRhWzBdLnogXTtcclxuXHJcblx0XHRcdGJvbmUuc2NsID0gWyBkYXRhWzJdLngsZGF0YVsyXS55LGRhdGFbMl0ueiBdO1xyXG5cdFx0XHRib25lLnJvdHEgPSBbIGRhdGFbMV0ueCxkYXRhWzFdLnksZGF0YVsxXS56LGRhdGFbMV0udyBdO1xyXG5cdFx0XHRsaXN0LnB1c2goYm9uZSk7XHJcblxyXG5cdFx0XHRmb3IgKHZhciBpIGluIG5vZGUubm9kZXMpIHtcclxuXHJcblx0XHRcdFx0d2Fsayhub2RlLnNpZCwgbm9kZS5ub2Rlc1tpXSwgbGlzdCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHR3YWxrKC0xLCBza2VsZXRvbiwgbGlzdCk7XHJcblx0XHRyZXR1cm4gbGlzdDtcclxuXHJcblx0fVxyXG5cclxuXHQvL01vdmUgdGhlIHZlcnRpY2VzIGludG8gdGhlIHBvc2UgdGhhdCBpcyBwcm9wZXIgZm9yIHRoZSBzdGFydCBvZiB0aGUgYW5pbWF0aW9uXHJcblx0ZnVuY3Rpb24gc2tpblRvQmluZFBvc2UoZ2VvbWV0cnksc2tlbGV0b24sc2tpbkNvbnRyb2xsZXIpIHtcclxuXHJcblx0XHR2YXIgYm9uZXMgPSBbXTtcclxuXHRcdHNldHVwU2tlbGV0b24oIHNrZWxldG9uLCBib25lcywgLTEgKTtcclxuXHRcdHNldHVwU2tpbm5pbmdNYXRyaWNlcyggYm9uZXMsIHNraW5Db250cm9sbGVyLnNraW4gKTtcclxuXHRcdHZhciB2ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdHZhciBza2lubmVkID0gW107XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBnZW9tZXRyeS52ZXJ0aWNlcy5sZW5ndGg7IGkgKyspIHtcclxuXHJcblx0XHRcdHNraW5uZWQucHVzaChuZXcgVEhSRUUuVmVjdG9yMygpKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBib25lcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGJvbmVzWyBpIF0udHlwZSAhPSAnSk9JTlQnICkgY29udGludWU7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCBib25lc1sgaSBdLndlaWdodHMubGVuZ3RoOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgdyA9IGJvbmVzWyBpIF0ud2VpZ2h0c1sgaiBdO1xyXG5cdFx0XHRcdHZhciB2aWR4ID0gdy5pbmRleDtcclxuXHRcdFx0XHR2YXIgd2VpZ2h0ID0gdy53ZWlnaHQ7XHJcblxyXG5cdFx0XHRcdHZhciBvID0gZ2VvbWV0cnkudmVydGljZXNbdmlkeF07XHJcblx0XHRcdFx0dmFyIHMgPSBza2lubmVkW3ZpZHhdO1xyXG5cclxuXHRcdFx0XHR2LnggPSBvLng7XHJcblx0XHRcdFx0di55ID0gby55O1xyXG5cdFx0XHRcdHYueiA9IG8uejtcclxuXHJcblx0XHRcdFx0di5hcHBseU1hdHJpeDQoIGJvbmVzW2ldLnNraW5uaW5nTWF0cml4ICk7XHJcblxyXG5cdFx0XHRcdHMueCArPSAodi54ICogd2VpZ2h0KTtcclxuXHRcdFx0XHRzLnkgKz0gKHYueSAqIHdlaWdodCk7XHJcblx0XHRcdFx0cy56ICs9ICh2LnogKiB3ZWlnaHQpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoOyBpICsrKSB7XHJcblxyXG5cdFx0XHRnZW9tZXRyeS52ZXJ0aWNlc1tpXSA9IHNraW5uZWRbaV07XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGFwcGx5U2tpbiAoIGdlb21ldHJ5LCBpbnN0YW5jZUN0cmwsIGZyYW1lICkge1xyXG5cclxuXHRcdHZhciBza2luQ29udHJvbGxlciA9IGNvbnRyb2xsZXJzWyBpbnN0YW5jZUN0cmwudXJsIF07XHJcblxyXG5cdFx0ZnJhbWUgPSBmcmFtZSAhPT0gdW5kZWZpbmVkID8gZnJhbWUgOiA0MDtcclxuXHJcblx0XHRpZiAoICFza2luQ29udHJvbGxlciB8fCAhc2tpbkNvbnRyb2xsZXIuc2tpbiApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUubG9nKCAnQ29sbGFkYUxvYWRlcjogQ291bGQgbm90IGZpbmQgc2tpbiBjb250cm9sbGVyLicgKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoICFpbnN0YW5jZUN0cmwuc2tlbGV0b24gfHwgIWluc3RhbmNlQ3RybC5za2VsZXRvbi5sZW5ndGggKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLmxvZyggJ0NvbGxhZGFMb2FkZXI6IENvdWxkIG5vdCBmaW5kIHRoZSBza2VsZXRvbiBmb3IgdGhlIHNraW4uICcgKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgYW5pbWF0aW9uQm91bmRzID0gY2FsY0FuaW1hdGlvbkJvdW5kcygpO1xyXG5cdFx0dmFyIHNrZWxldG9uID0gdmlzdWFsU2NlbmUuZ2V0Q2hpbGRCeUlkKCBpbnN0YW5jZUN0cmwuc2tlbGV0b25bMF0sIHRydWUgKSB8fCB2aXN1YWxTY2VuZS5nZXRDaGlsZEJ5U2lkKCBpbnN0YW5jZUN0cmwuc2tlbGV0b25bMF0sIHRydWUgKTtcclxuXHJcblx0XHQvL2ZsYXR0ZW4gdGhlIHNrZWxldG9uIGludG8gYSBsaXN0IG9mIGJvbmVzXHJcblx0XHR2YXIgYm9uZWxpc3QgPSBmbGF0dGVuU2tlbGV0b24oc2tlbGV0b24pO1xyXG5cdFx0dmFyIGpvaW50cyA9IHNraW5Db250cm9sbGVyLnNraW4uam9pbnRzO1xyXG5cclxuXHRcdC8vc29ydCB0aGF0IGxpc3Qgc28gdGhhdCB0aGUgb3JkZXIgcmVmbGVjdHMgdGhlIG9yZGVyIGluIHRoZSBqb2ludCBsaXN0XHJcblx0XHR2YXIgc29ydGVkYm9uZXMgPSBbXTtcclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgam9pbnRzLmxlbmd0aDsgaSArKykge1xyXG5cclxuXHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBib25lbGlzdC5sZW5ndGg7IGogKyspIHtcclxuXHJcblx0XHRcdFx0aWYgKGJvbmVsaXN0W2pdLm5hbWUgPT09IGpvaW50c1tpXSkge1xyXG5cclxuXHRcdFx0XHRcdHNvcnRlZGJvbmVzW2ldID0gYm9uZWxpc3Rbal07XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly9ob29rIHVwIHRoZSBwYXJlbnRzIGJ5IGluZGV4IGluc3RlYWQgb2YgbmFtZVxyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzb3J0ZWRib25lcy5sZW5ndGg7IGkgKyspIHtcclxuXHJcblx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgc29ydGVkYm9uZXMubGVuZ3RoOyBqICsrKSB7XHJcblxyXG5cdFx0XHRcdGlmIChzb3J0ZWRib25lc1tpXS5wYXJlbnQgPT09IHNvcnRlZGJvbmVzW2pdLm5hbWUpIHtcclxuXHJcblx0XHRcdFx0XHRzb3J0ZWRib25lc1tpXS5wYXJlbnQgPSBqO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHJcblx0XHR2YXIgaSwgaiwgdywgdmlkeCwgd2VpZ2h0O1xyXG5cdFx0dmFyIHYgPSBuZXcgVEhSRUUuVmVjdG9yMygpLCBvLCBzO1xyXG5cclxuXHRcdC8vIG1vdmUgdmVydGljZXMgdG8gYmluZCBzaGFwZVxyXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBnZW9tZXRyeS52ZXJ0aWNlcy5sZW5ndGg7IGkgKysgKSB7XHJcblx0XHRcdGdlb21ldHJ5LnZlcnRpY2VzW2ldLmFwcGx5TWF0cml4NCggc2tpbkNvbnRyb2xsZXIuc2tpbi5iaW5kU2hhcGVNYXRyaXggKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgc2tpbkluZGljZXMgPSBbXTtcclxuXHRcdHZhciBza2luV2VpZ2h0cyA9IFtdO1xyXG5cdFx0dmFyIHdlaWdodHMgPSBza2luQ29udHJvbGxlci5za2luLndlaWdodHM7XHJcblxyXG5cdFx0Ly8gaG9vayB1cCB0aGUgc2tpbiB3ZWlnaHRzXHJcblx0XHQvLyBUT0RPIC0gdGhpcyBtaWdodCBiZSBhIGdvb2QgcGxhY2UgdG8gY2hvb3NlIGdyZWF0ZXN0IDQgd2VpZ2h0c1xyXG5cdFx0Zm9yICggdmFyIGkgPTA7IGkgPCB3ZWlnaHRzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciBpbmRpY2llcyA9IG5ldyBUSFJFRS5WZWN0b3I0KHdlaWdodHNbaV1bMF0gPyB3ZWlnaHRzW2ldWzBdLmpvaW50IDogMCx3ZWlnaHRzW2ldWzFdID8gd2VpZ2h0c1tpXVsxXS5qb2ludCA6IDAsd2VpZ2h0c1tpXVsyXSA/IHdlaWdodHNbaV1bMl0uam9pbnQgOiAwLHdlaWdodHNbaV1bM10gPyB3ZWlnaHRzW2ldWzNdLmpvaW50IDogMCk7XHJcblx0XHRcdHZhciB3ZWlnaHQgPSBuZXcgVEhSRUUuVmVjdG9yNCh3ZWlnaHRzW2ldWzBdID8gd2VpZ2h0c1tpXVswXS53ZWlnaHQgOiAwLHdlaWdodHNbaV1bMV0gPyB3ZWlnaHRzW2ldWzFdLndlaWdodCA6IDAsd2VpZ2h0c1tpXVsyXSA/IHdlaWdodHNbaV1bMl0ud2VpZ2h0IDogMCx3ZWlnaHRzW2ldWzNdID8gd2VpZ2h0c1tpXVszXS53ZWlnaHQgOiAwKTtcclxuXHJcblx0XHRcdHNraW5JbmRpY2VzLnB1c2goaW5kaWNpZXMpO1xyXG5cdFx0XHRza2luV2VpZ2h0cy5wdXNoKHdlaWdodCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGdlb21ldHJ5LnNraW5JbmRpY2VzID0gc2tpbkluZGljZXM7XHJcblx0XHRnZW9tZXRyeS5za2luV2VpZ2h0cyA9IHNraW5XZWlnaHRzO1xyXG5cdFx0Z2VvbWV0cnkuYm9uZXMgPSBzb3J0ZWRib25lcztcclxuXHRcdC8vIHByb2Nlc3MgYW5pbWF0aW9uLCBvciBzaW1wbHkgcG9zZSB0aGUgcmlnIGlmIG5vIGFuaW1hdGlvblxyXG5cclxuXHRcdC8vY3JlYXRlIGFuIGFuaW1hdGlvbiBmb3IgdGhlIGFuaW1hdGVkIGJvbmVzXHJcblx0XHQvL05PVEU6IHRoaXMgaGFzIG5vIGVmZmVjdCB3aGVuIHVzaW5nIG1vcnBodGFyZ2V0c1xyXG5cdFx0dmFyIGFuaW1hdGlvbmRhdGEgPSB7IFwibmFtZVwiOmFuaW1hdGlvbkJvdW5kcy5JRCxcImZwc1wiOjMwLFwibGVuZ3RoXCI6YW5pbWF0aW9uQm91bmRzLmZyYW1lcyAvIDMwLFwiaGllcmFyY2h5XCI6W10gfTtcclxuXHJcblx0XHRmb3IgKHZhciBqID0gMDsgaiA8IHNvcnRlZGJvbmVzLmxlbmd0aDsgaiArKykge1xyXG5cclxuXHRcdFx0YW5pbWF0aW9uZGF0YS5oaWVyYXJjaHkucHVzaCh7IHBhcmVudDpzb3J0ZWRib25lc1tqXS5wYXJlbnQsIG5hbWU6c29ydGVkYm9uZXNbal0ubmFtZSwga2V5czpbXSB9KTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc29sZS5sb2coICdDb2xsYWRhTG9hZGVyOicsIGFuaW1hdGlvbkJvdW5kcy5JRCArICcgaGFzICcgKyBzb3J0ZWRib25lcy5sZW5ndGggKyAnIGJvbmVzLicgKTtcclxuXHJcblxyXG5cclxuXHRcdHNraW5Ub0JpbmRQb3NlKGdlb21ldHJ5LCBza2VsZXRvbiwgc2tpbkNvbnRyb2xsZXIpO1xyXG5cclxuXHJcblx0XHRmb3IgKCBmcmFtZSA9IDA7IGZyYW1lIDwgYW5pbWF0aW9uQm91bmRzLmZyYW1lczsgZnJhbWUgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgYm9uZXMgPSBbXTtcclxuXHRcdFx0dmFyIHNraW5uZWQgPSBbXTtcclxuXHRcdFx0Ly8gcHJvY2VzcyB0aGUgZnJhbWUgYW5kIHNldHVwIHRoZSByaWcgd2l0aCBhIGZyZXNoXHJcblx0XHRcdC8vIHRyYW5zZm9ybSwgcG9zc2libHkgZnJvbSB0aGUgYm9uZSdzIGFuaW1hdGlvbiBjaGFubmVsKHMpXHJcblxyXG5cdFx0XHRzZXR1cFNrZWxldG9uKCBza2VsZXRvbiwgYm9uZXMsIGZyYW1lICk7XHJcblx0XHRcdHNldHVwU2tpbm5pbmdNYXRyaWNlcyggYm9uZXMsIHNraW5Db250cm9sbGVyLnNraW4gKTtcclxuXHJcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYm9uZXMubGVuZ3RoOyBpICsrKSB7XHJcblxyXG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgYW5pbWF0aW9uZGF0YS5oaWVyYXJjaHkubGVuZ3RoOyBqICsrKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKGFuaW1hdGlvbmRhdGEuaGllcmFyY2h5W2pdLm5hbWUgPT09IGJvbmVzW2ldLnNpZCkge1xyXG5cclxuXHRcdFx0XHRcdFx0dmFyIGtleSA9IHt9O1xyXG5cdFx0XHRcdFx0XHRrZXkudGltZSA9IChmcmFtZSAvIDMwKTtcclxuXHRcdFx0XHRcdFx0a2V5Lm1hdHJpeCA9IGJvbmVzW2ldLmFuaW1hdHJpeDtcclxuXHJcblx0XHRcdFx0XHRcdGlmIChmcmFtZSA9PT0gMClcclxuXHRcdFx0XHRcdFx0XHRib25lc1tpXS5tYXRyaXggPSBrZXkubWF0cml4O1xyXG5cclxuXHRcdFx0XHRcdFx0dmFyIGRhdGEgPSBbIG5ldyBUSFJFRS5WZWN0b3IzKCksbmV3IFRIUkVFLlF1YXRlcm5pb24oKSxuZXcgVEhSRUUuVmVjdG9yMygpIF07XHJcblx0XHRcdFx0XHRcdGtleS5tYXRyaXguZGVjb21wb3NlKGRhdGFbMF0sIGRhdGFbMV0sIGRhdGFbMl0pO1xyXG5cclxuXHRcdFx0XHRcdFx0a2V5LnBvcyA9IFsgZGF0YVswXS54LGRhdGFbMF0ueSxkYXRhWzBdLnogXTtcclxuXHJcblx0XHRcdFx0XHRcdGtleS5zY2wgPSBbIGRhdGFbMl0ueCxkYXRhWzJdLnksZGF0YVsyXS56IF07XHJcblx0XHRcdFx0XHRcdGtleS5yb3QgPSBkYXRhWzFdO1xyXG5cclxuXHRcdFx0XHRcdFx0YW5pbWF0aW9uZGF0YS5oaWVyYXJjaHlbal0ua2V5cy5wdXNoKGtleSk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRnZW9tZXRyeS5hbmltYXRpb24gPSBhbmltYXRpb25kYXRhO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBjcmVhdGVLaW5lbWF0aWNzKCkge1xyXG5cclxuXHRcdGlmICgga2luZW1hdGljc01vZGVsICYmIGtpbmVtYXRpY3NNb2RlbC5qb2ludHMubGVuZ3RoID09PSAwICkge1xyXG5cdFx0XHRraW5lbWF0aWNzID0gdW5kZWZpbmVkO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGpvaW50TWFwID0ge307XHJcblxyXG5cdFx0dmFyIF9hZGRUb01hcCA9IGZ1bmN0aW9uKCBqb2ludEluZGV4LCBwYXJlbnRWaXN1YWxFbGVtZW50ICkge1xyXG5cclxuXHRcdFx0dmFyIHBhcmVudFZpc3VhbEVsZW1lbnRJZCA9IHBhcmVudFZpc3VhbEVsZW1lbnQuZ2V0QXR0cmlidXRlKCAnaWQnICk7XHJcblx0XHRcdHZhciBjb2xsYWRhTm9kZSA9IHZpc3VhbFNjZW5lLmdldENoaWxkQnlJZCggcGFyZW50VmlzdWFsRWxlbWVudElkLCB0cnVlICk7XHJcblx0XHRcdHZhciBqb2ludCA9IGtpbmVtYXRpY3NNb2RlbC5qb2ludHNbIGpvaW50SW5kZXggXTtcclxuXHJcblx0XHRcdHNjZW5lLnRyYXZlcnNlKGZ1bmN0aW9uKCBub2RlICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIG5vZGUuY29sbGFkYUlkID09IHBhcmVudFZpc3VhbEVsZW1lbnRJZCApIHtcclxuXHJcblx0XHRcdFx0XHRqb2ludE1hcFsgam9pbnRJbmRleCBdID0ge1xyXG5cdFx0XHRcdFx0XHRub2RlOiBub2RlLFxyXG5cdFx0XHRcdFx0XHR0cmFuc2Zvcm1zOiBjb2xsYWRhTm9kZS50cmFuc2Zvcm1zLFxyXG5cdFx0XHRcdFx0XHRqb2ludDogam9pbnQsXHJcblx0XHRcdFx0XHRcdHBvc2l0aW9uOiBqb2ludC56ZXJvUG9zaXRpb25cclxuXHRcdFx0XHRcdH07XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdFx0a2luZW1hdGljcyA9IHtcclxuXHJcblx0XHRcdGpvaW50czoga2luZW1hdGljc01vZGVsICYmIGtpbmVtYXRpY3NNb2RlbC5qb2ludHMsXHJcblxyXG5cdFx0XHRnZXRKb2ludFZhbHVlOiBmdW5jdGlvbiggam9pbnRJbmRleCApIHtcclxuXHJcblx0XHRcdFx0dmFyIGpvaW50RGF0YSA9IGpvaW50TWFwWyBqb2ludEluZGV4IF07XHJcblxyXG5cdFx0XHRcdGlmICggam9pbnREYXRhICkge1xyXG5cclxuXHRcdFx0XHRcdHJldHVybiBqb2ludERhdGEucG9zaXRpb247XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0Y29uc29sZS5sb2coICdnZXRKb2ludFZhbHVlOiBqb2ludCAnICsgam9pbnRJbmRleCArICcgZG9lc25cXCd0IGV4aXN0JyApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0c2V0Sm9pbnRWYWx1ZTogZnVuY3Rpb24oIGpvaW50SW5kZXgsIHZhbHVlICkge1xyXG5cclxuXHRcdFx0XHR2YXIgam9pbnREYXRhID0gam9pbnRNYXBbIGpvaW50SW5kZXggXTtcclxuXHJcblx0XHRcdFx0aWYgKCBqb2ludERhdGEgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIGpvaW50ID0gam9pbnREYXRhLmpvaW50O1xyXG5cclxuXHRcdFx0XHRcdGlmICggdmFsdWUgPiBqb2ludC5saW1pdHMubWF4IHx8IHZhbHVlIDwgam9pbnQubGltaXRzLm1pbiApIHtcclxuXHJcblx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKCAnc2V0Sm9pbnRWYWx1ZTogam9pbnQgJyArIGpvaW50SW5kZXggKyAnIHZhbHVlICcgKyB2YWx1ZSArICcgb3V0c2lkZSBvZiBsaW1pdHMgKG1pbjogJyArIGpvaW50LmxpbWl0cy5taW4gKyAnLCBtYXg6ICcgKyBqb2ludC5saW1pdHMubWF4ICsgJyknICk7XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggam9pbnQuc3RhdGljICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Y29uc29sZS5sb2coICdzZXRKb2ludFZhbHVlOiBqb2ludCAnICsgam9pbnRJbmRleCArICcgaXMgc3RhdGljJyApO1xyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHR2YXIgdGhyZWVqc05vZGUgPSBqb2ludERhdGEubm9kZTtcclxuXHRcdFx0XHRcdFx0dmFyIGF4aXMgPSBqb2ludC5heGlzO1xyXG5cdFx0XHRcdFx0XHR2YXIgdHJhbnNmb3JtcyA9IGpvaW50RGF0YS50cmFuc2Zvcm1zO1xyXG5cclxuXHRcdFx0XHRcdFx0dmFyIG1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblxyXG5cdFx0XHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgdHJhbnNmb3Jtcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHZhciB0cmFuc2Zvcm0gPSB0cmFuc2Zvcm1zWyBpIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdC8vIGtpbmRhIGdoZXR0byBqb2ludCBkZXRlY3Rpb25cclxuXHRcdFx0XHRcdFx0XHRpZiAoIHRyYW5zZm9ybS5zaWQgJiYgdHJhbnNmb3JtLnNpZC5pbmRleE9mKCAnam9pbnQnICsgam9pbnRJbmRleCApICE9PSAtMSApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHQvLyBhcHBseSBhY3R1YWwgam9pbnQgdmFsdWUgaGVyZVxyXG5cdFx0XHRcdFx0XHRcdFx0c3dpdGNoICggam9pbnQudHlwZSApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgJ3Jldm9sdXRlJzpcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0bWF0cml4Lm11bHRpcGx5KCBtMS5tYWtlUm90YXRpb25BeGlzKCBheGlzLCBUSFJFRS5NYXRoLmRlZ1RvUmFkKHZhbHVlKSApICk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XHRjYXNlICdwcmlzbWF0aWMnOlxyXG5cclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRtYXRyaXgubXVsdGlwbHkoIG0xLm1ha2VUcmFuc2xhdGlvbihheGlzLnggKiB2YWx1ZSwgYXhpcy55ICogdmFsdWUsIGF4aXMueiAqIHZhbHVlICkgKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRcdGRlZmF1bHQ6XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ3NldEpvaW50VmFsdWU6IHVua25vd24gam9pbnQgdHlwZTogJyArIGpvaW50LnR5cGUgKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0dmFyIG0xID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRzd2l0Y2ggKCB0cmFuc2Zvcm0udHlwZSApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgJ21hdHJpeCc6XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG1hdHJpeC5tdWx0aXBseSggdHJhbnNmb3JtLm9iaiApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgJ3RyYW5zbGF0ZSc6XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG1hdHJpeC5tdWx0aXBseSggbTEubWFrZVRyYW5zbGF0aW9uKCB0cmFuc2Zvcm0ub2JqLngsIHRyYW5zZm9ybS5vYmoueSwgdHJhbnNmb3JtLm9iai56ICkgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XHRjYXNlICdyb3RhdGUnOlxyXG5cclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRtYXRyaXgubXVsdGlwbHkoIG0xLm1ha2VSb3RhdGlvbkF4aXMoIHRyYW5zZm9ybS5vYmosIHRyYW5zZm9ybS5hbmdsZSApICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdC8vIGFwcGx5IHRoZSBtYXRyaXggdG8gdGhlIHRocmVlanMgbm9kZVxyXG5cdFx0XHRcdFx0XHR2YXIgZWxlbWVudHNGbG9hdDMyQXJyID0gbWF0cml4LmVsZW1lbnRzO1xyXG5cdFx0XHRcdFx0XHR2YXIgZWxlbWVudHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggZWxlbWVudHNGbG9hdDMyQXJyICk7XHJcblxyXG5cdFx0XHRcdFx0XHR2YXIgZWxlbWVudHNSb3dNYWpvciA9IFtcclxuXHRcdFx0XHRcdFx0XHRlbGVtZW50c1sgMCBdLFxyXG5cdFx0XHRcdFx0XHRcdGVsZW1lbnRzWyA0IF0sXHJcblx0XHRcdFx0XHRcdFx0ZWxlbWVudHNbIDggXSxcclxuXHRcdFx0XHRcdFx0XHRlbGVtZW50c1sgMTIgXSxcclxuXHRcdFx0XHRcdFx0XHRlbGVtZW50c1sgMSBdLFxyXG5cdFx0XHRcdFx0XHRcdGVsZW1lbnRzWyA1IF0sXHJcblx0XHRcdFx0XHRcdFx0ZWxlbWVudHNbIDkgXSxcclxuXHRcdFx0XHRcdFx0XHRlbGVtZW50c1sgMTMgXSxcclxuXHRcdFx0XHRcdFx0XHRlbGVtZW50c1sgMiBdLFxyXG5cdFx0XHRcdFx0XHRcdGVsZW1lbnRzWyA2IF0sXHJcblx0XHRcdFx0XHRcdFx0ZWxlbWVudHNbIDEwIF0sXHJcblx0XHRcdFx0XHRcdFx0ZWxlbWVudHNbIDE0IF0sXHJcblx0XHRcdFx0XHRcdFx0ZWxlbWVudHNbIDMgXSxcclxuXHRcdFx0XHRcdFx0XHRlbGVtZW50c1sgNyBdLFxyXG5cdFx0XHRcdFx0XHRcdGVsZW1lbnRzWyAxMSBdLFxyXG5cdFx0XHRcdFx0XHRcdGVsZW1lbnRzWyAxNSBdXHJcblx0XHRcdFx0XHRcdF07XHJcblxyXG5cdFx0XHRcdFx0XHR0aHJlZWpzTm9kZS5tYXRyaXguc2V0LmFwcGx5KCB0aHJlZWpzTm9kZS5tYXRyaXgsIGVsZW1lbnRzUm93TWFqb3IgKTtcclxuXHRcdFx0XHRcdFx0dGhyZWVqc05vZGUubWF0cml4LmRlY29tcG9zZSggdGhyZWVqc05vZGUucG9zaXRpb24sIHRocmVlanNOb2RlLnF1YXRlcm5pb24sIHRocmVlanNOb2RlLnNjYWxlICk7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0Y29uc29sZS5sb2coICdzZXRKb2ludFZhbHVlOiBqb2ludCAnICsgam9pbnRJbmRleCArICcgZG9lc25cXCd0IGV4aXN0JyApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHR2YXIgZWxlbWVudCA9IENPTExBREEucXVlcnlTZWxlY3Rvcignc2NlbmUgaW5zdGFuY2Vfa2luZW1hdGljc19zY2VuZScpO1xyXG5cclxuXHRcdGlmICggZWxlbWVudCApIHtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBjaGlsZCA9IGVsZW1lbnQuY2hpbGROb2Rlc1sgaSBdO1xyXG5cclxuXHRcdFx0XHRpZiAoIGNoaWxkLm5vZGVUeXBlICE9IDEgKSBjb250aW51ZTtcclxuXHJcblx0XHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSAnYmluZF9qb2ludF9heGlzJzpcclxuXHJcblx0XHRcdFx0XHRcdHZhciB2aXN1YWxUYXJnZXQgPSBjaGlsZC5nZXRBdHRyaWJ1dGUoICd0YXJnZXQnICkuc3BsaXQoICcvJyApLnBvcCgpO1xyXG5cdFx0XHRcdFx0XHR2YXIgYXhpcyA9IGNoaWxkLnF1ZXJ5U2VsZWN0b3IoJ2F4aXMgcGFyYW0nKS50ZXh0Q29udGVudDtcclxuXHRcdFx0XHRcdFx0dmFyIGpvaW50SW5kZXggPSBwYXJzZUludCggYXhpcy5zcGxpdCggJ2pvaW50JyApLnBvcCgpLnNwbGl0KCAnLicgKVswXSApO1xyXG5cdFx0XHRcdFx0XHR2YXIgdmlzdWFsVGFyZ2V0RWxlbWVudCA9IENPTExBREEucXVlcnlTZWxlY3RvciggJ1tzaWQ9XCInICsgdmlzdWFsVGFyZ2V0ICsgJ1wiXScgKTtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggdmlzdWFsVGFyZ2V0RWxlbWVudCApIHtcclxuXHRcdFx0XHRcdFx0XHR2YXIgcGFyZW50VmlzdWFsRWxlbWVudCA9IHZpc3VhbFRhcmdldEVsZW1lbnQucGFyZW50RWxlbWVudDtcclxuXHRcdFx0XHRcdFx0XHRfYWRkVG9NYXAoam9pbnRJbmRleCwgcGFyZW50VmlzdWFsRWxlbWVudCk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGRlZmF1bHQ6XHJcblxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGNyZWF0ZVNjZW5lR3JhcGggKCBub2RlLCBwYXJlbnQgKSB7XHJcblxyXG5cdFx0dmFyIG9iaiA9IG5ldyBUSFJFRS5PYmplY3QzRCgpO1xyXG5cdFx0dmFyIHNraW5uZWQgPSBmYWxzZTtcclxuXHRcdHZhciBza2luQ29udHJvbGxlcjtcclxuXHRcdHZhciBtb3JwaENvbnRyb2xsZXI7XHJcblx0XHR2YXIgaSwgajtcclxuXHJcblx0XHQvLyBGSVhNRTogY29udHJvbGxlcnNcclxuXHJcblx0XHRmb3IgKCBpID0gMDsgaSA8IG5vZGUuY29udHJvbGxlcnMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIGNvbnRyb2xsZXIgPSBjb250cm9sbGVyc1sgbm9kZS5jb250cm9sbGVyc1sgaSBdLnVybCBdO1xyXG5cclxuXHRcdFx0c3dpdGNoICggY29udHJvbGxlci50eXBlICkge1xyXG5cclxuXHRcdFx0XHRjYXNlICdza2luJzpcclxuXHJcblx0XHRcdFx0XHRpZiAoIGdlb21ldHJpZXNbIGNvbnRyb2xsZXIuc2tpbi5zb3VyY2UgXSApIHtcclxuXHJcblx0XHRcdFx0XHRcdHZhciBpbnN0X2dlb20gPSBuZXcgSW5zdGFuY2VHZW9tZXRyeSgpO1xyXG5cclxuXHRcdFx0XHRcdFx0aW5zdF9nZW9tLnVybCA9IGNvbnRyb2xsZXIuc2tpbi5zb3VyY2U7XHJcblx0XHRcdFx0XHRcdGluc3RfZ2VvbS5pbnN0YW5jZV9tYXRlcmlhbCA9IG5vZGUuY29udHJvbGxlcnNbIGkgXS5pbnN0YW5jZV9tYXRlcmlhbDtcclxuXHJcblx0XHRcdFx0XHRcdG5vZGUuZ2VvbWV0cmllcy5wdXNoKCBpbnN0X2dlb20gKTtcclxuXHRcdFx0XHRcdFx0c2tpbm5lZCA9IHRydWU7XHJcblx0XHRcdFx0XHRcdHNraW5Db250cm9sbGVyID0gbm9kZS5jb250cm9sbGVyc1sgaSBdO1xyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIGNvbnRyb2xsZXJzWyBjb250cm9sbGVyLnNraW4uc291cmNlIF0gKSB7XHJcblxyXG5cdFx0XHRcdFx0XHQvLyB1cmdoOiBjb250cm9sbGVyIGNhbiBiZSBjaGFpbmVkXHJcblx0XHRcdFx0XHRcdC8vIGhhbmRsZSB0aGUgbW9zdCBiYXNpYyBjYXNlLi4uXHJcblxyXG5cdFx0XHRcdFx0XHR2YXIgc2Vjb25kID0gY29udHJvbGxlcnNbIGNvbnRyb2xsZXIuc2tpbi5zb3VyY2UgXTtcclxuXHRcdFx0XHRcdFx0bW9ycGhDb250cm9sbGVyID0gc2Vjb25kO1xyXG5cdFx0XHRcdFx0Ly9cdHNraW5Db250cm9sbGVyID0gbm9kZS5jb250cm9sbGVyc1tpXTtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggc2Vjb25kLm1vcnBoICYmIGdlb21ldHJpZXNbIHNlY29uZC5tb3JwaC5zb3VyY2UgXSApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0dmFyIGluc3RfZ2VvbSA9IG5ldyBJbnN0YW5jZUdlb21ldHJ5KCk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGluc3RfZ2VvbS51cmwgPSBzZWNvbmQubW9ycGguc291cmNlO1xyXG5cdFx0XHRcdFx0XHRcdGluc3RfZ2VvbS5pbnN0YW5jZV9tYXRlcmlhbCA9IG5vZGUuY29udHJvbGxlcnNbIGkgXS5pbnN0YW5jZV9tYXRlcmlhbDtcclxuXHJcblx0XHRcdFx0XHRcdFx0bm9kZS5nZW9tZXRyaWVzLnB1c2goIGluc3RfZ2VvbSApO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnbW9ycGgnOlxyXG5cclxuXHRcdFx0XHRcdGlmICggZ2VvbWV0cmllc1sgY29udHJvbGxlci5tb3JwaC5zb3VyY2UgXSApIHtcclxuXHJcblx0XHRcdFx0XHRcdHZhciBpbnN0X2dlb20gPSBuZXcgSW5zdGFuY2VHZW9tZXRyeSgpO1xyXG5cclxuXHRcdFx0XHRcdFx0aW5zdF9nZW9tLnVybCA9IGNvbnRyb2xsZXIubW9ycGguc291cmNlO1xyXG5cdFx0XHRcdFx0XHRpbnN0X2dlb20uaW5zdGFuY2VfbWF0ZXJpYWwgPSBub2RlLmNvbnRyb2xsZXJzWyBpIF0uaW5zdGFuY2VfbWF0ZXJpYWw7XHJcblxyXG5cdFx0XHRcdFx0XHRub2RlLmdlb21ldHJpZXMucHVzaCggaW5zdF9nZW9tICk7XHJcblx0XHRcdFx0XHRcdG1vcnBoQ29udHJvbGxlciA9IG5vZGUuY29udHJvbGxlcnNbIGkgXTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Y29uc29sZS5sb2coICdDb2xsYWRhTG9hZGVyOiBNb3JwaC1jb250cm9sbGVyIHBhcnRpYWxseSBzdXBwb3J0ZWQuJyApO1xyXG5cclxuXHRcdFx0XHRkZWZhdWx0OlxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGdlb21ldHJpZXNcclxuXHJcblx0XHR2YXIgZG91YmxlX3NpZGVkX21hdGVyaWFscyA9IHt9O1xyXG5cclxuXHRcdGZvciAoIGkgPSAwOyBpIDwgbm9kZS5nZW9tZXRyaWVzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciBpbnN0YW5jZV9nZW9tZXRyeSA9IG5vZGUuZ2VvbWV0cmllc1tpXTtcclxuXHRcdFx0dmFyIGluc3RhbmNlX21hdGVyaWFscyA9IGluc3RhbmNlX2dlb21ldHJ5Lmluc3RhbmNlX21hdGVyaWFsO1xyXG5cdFx0XHR2YXIgZ2VvbWV0cnkgPSBnZW9tZXRyaWVzWyBpbnN0YW5jZV9nZW9tZXRyeS51cmwgXTtcclxuXHRcdFx0dmFyIHVzZWRfbWF0ZXJpYWxzID0ge307XHJcblx0XHRcdHZhciB1c2VkX21hdGVyaWFsc19hcnJheSA9IFtdO1xyXG5cdFx0XHR2YXIgbnVtX21hdGVyaWFscyA9IDA7XHJcblx0XHRcdHZhciBmaXJzdF9tYXRlcmlhbDtcclxuXHJcblx0XHRcdGlmICggZ2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggIWdlb21ldHJ5Lm1lc2ggfHwgIWdlb21ldHJ5Lm1lc2gucHJpbWl0aXZlcyApXHJcblx0XHRcdFx0XHRjb250aW51ZTtcclxuXHJcblx0XHRcdFx0aWYgKCBvYmoubmFtZS5sZW5ndGggPT09IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0b2JqLm5hbWUgPSBnZW9tZXRyeS5pZDtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBjb2xsZWN0IHVzZWQgZnggZm9yIHRoaXMgZ2VvbWV0cnktaW5zdGFuY2VcclxuXHJcblx0XHRcdFx0aWYgKCBpbnN0YW5jZV9tYXRlcmlhbHMgKSB7XHJcblxyXG5cdFx0XHRcdFx0Zm9yICggaiA9IDA7IGogPCBpbnN0YW5jZV9tYXRlcmlhbHMubGVuZ3RoOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dmFyIGluc3RhbmNlX21hdGVyaWFsID0gaW5zdGFuY2VfbWF0ZXJpYWxzWyBqIF07XHJcblx0XHRcdFx0XHRcdHZhciBtYXQgPSBtYXRlcmlhbHNbIGluc3RhbmNlX21hdGVyaWFsLnRhcmdldCBdO1xyXG5cdFx0XHRcdFx0XHR2YXIgZWZmZWN0X2lkID0gbWF0Lmluc3RhbmNlX2VmZmVjdC51cmw7XHJcblx0XHRcdFx0XHRcdHZhciBzaGFkZXIgPSBlZmZlY3RzWyBlZmZlY3RfaWQgXS5zaGFkZXI7XHJcblx0XHRcdFx0XHRcdHZhciBtYXRlcmlhbDNqcyA9IHNoYWRlci5tYXRlcmlhbDtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggZ2VvbWV0cnkuZG91YmxlU2lkZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGlmICggISggaW5zdGFuY2VfbWF0ZXJpYWwuc3ltYm9sIGluIGRvdWJsZV9zaWRlZF9tYXRlcmlhbHMgKSApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHR2YXIgX2NvcGllZF9tYXRlcmlhbCA9IG1hdGVyaWFsM2pzLmNsb25lKCk7XHJcblx0XHRcdFx0XHRcdFx0XHRfY29waWVkX21hdGVyaWFsLnNpZGUgPSBUSFJFRS5Eb3VibGVTaWRlO1xyXG5cdFx0XHRcdFx0XHRcdFx0ZG91YmxlX3NpZGVkX21hdGVyaWFsc1sgaW5zdGFuY2VfbWF0ZXJpYWwuc3ltYm9sIF0gPSBfY29waWVkX21hdGVyaWFsO1xyXG5cclxuXHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRcdG1hdGVyaWFsM2pzID0gZG91YmxlX3NpZGVkX21hdGVyaWFsc1sgaW5zdGFuY2VfbWF0ZXJpYWwuc3ltYm9sIF07XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRtYXRlcmlhbDNqcy5vcGFjaXR5ID0gIW1hdGVyaWFsM2pzLm9wYWNpdHkgPyAxIDogbWF0ZXJpYWwzanMub3BhY2l0eTtcclxuXHRcdFx0XHRcdFx0dXNlZF9tYXRlcmlhbHNbIGluc3RhbmNlX21hdGVyaWFsLnN5bWJvbCBdID0gbnVtX21hdGVyaWFscztcclxuXHRcdFx0XHRcdFx0dXNlZF9tYXRlcmlhbHNfYXJyYXkucHVzaCggbWF0ZXJpYWwzanMgKTtcclxuXHRcdFx0XHRcdFx0Zmlyc3RfbWF0ZXJpYWwgPSBtYXRlcmlhbDNqcztcclxuXHRcdFx0XHRcdFx0Zmlyc3RfbWF0ZXJpYWwubmFtZSA9IG1hdC5uYW1lID09PSBudWxsIHx8IG1hdC5uYW1lID09PSAnJyA/IG1hdC5pZCA6IG1hdC5uYW1lO1xyXG5cdFx0XHRcdFx0XHRudW1fbWF0ZXJpYWxzICsrO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR2YXIgbWVzaDtcclxuXHRcdFx0XHR2YXIgbWF0ZXJpYWwgPSBmaXJzdF9tYXRlcmlhbCB8fCBuZXcgVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbCggeyBjb2xvcjogMHhkZGRkZGQsIHNpZGU6IGdlb21ldHJ5LmRvdWJsZVNpZGVkID8gVEhSRUUuRG91YmxlU2lkZSA6IFRIUkVFLkZyb250U2lkZSB9ICk7XHJcblx0XHRcdFx0dmFyIGdlb20gPSBnZW9tZXRyeS5tZXNoLmdlb21ldHJ5M2pzO1xyXG5cclxuXHRcdFx0XHRpZiAoIG51bV9tYXRlcmlhbHMgPiAxICkge1xyXG5cclxuXHRcdFx0XHRcdG1hdGVyaWFsID0gbmV3IFRIUkVFLk11bHRpTWF0ZXJpYWwoIHVzZWRfbWF0ZXJpYWxzX2FycmF5ICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCBza2luQ29udHJvbGxlciAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHJcblx0XHRcdFx0XHRhcHBseVNraW4oIGdlb20sIHNraW5Db250cm9sbGVyICk7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBnZW9tLm1vcnBoVGFyZ2V0cy5sZW5ndGggPiAwICkge1xyXG5cclxuXHRcdFx0XHRcdFx0bWF0ZXJpYWwubW9ycGhUYXJnZXRzID0gdHJ1ZTtcclxuXHRcdFx0XHRcdFx0bWF0ZXJpYWwuc2tpbm5pbmcgPSBmYWxzZTtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0bWF0ZXJpYWwubW9ycGhUYXJnZXRzID0gZmFsc2U7XHJcblx0XHRcdFx0XHRcdG1hdGVyaWFsLnNraW5uaW5nID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cclxuXHRcdFx0XHRcdG1lc2ggPSBuZXcgVEhSRUUuU2tpbm5lZE1lc2goIGdlb20sIG1hdGVyaWFsLCBmYWxzZSApO1xyXG5cclxuXHJcblx0XHRcdFx0XHQvL21lc2guc2tlbGV0b24gPSBza2luQ29udHJvbGxlci5za2VsZXRvbjtcclxuXHRcdFx0XHRcdC8vbWVzaC5za2luQ29udHJvbGxlciA9IGNvbnRyb2xsZXJzWyBza2luQ29udHJvbGxlci51cmwgXTtcclxuXHRcdFx0XHRcdC8vbWVzaC5za2luSW5zdGFuY2VDb250cm9sbGVyID0gc2tpbkNvbnRyb2xsZXI7XHJcblx0XHRcdFx0XHRtZXNoLm5hbWUgPSAnc2tpbl8nICsgc2tpbnMubGVuZ3RoO1xyXG5cclxuXHJcblxyXG5cdFx0XHRcdFx0Ly9tZXNoLmFuaW1hdGlvbkhhbmRsZS5zZXRLZXkoMCk7XHJcblx0XHRcdFx0XHRza2lucy5wdXNoKCBtZXNoICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1vcnBoQ29udHJvbGxlciAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdGNyZWF0ZU1vcnBoKCBnZW9tLCBtb3JwaENvbnRyb2xsZXIgKTtcclxuXHJcblx0XHRcdFx0XHRtYXRlcmlhbC5tb3JwaFRhcmdldHMgPSB0cnVlO1xyXG5cclxuXHRcdFx0XHRcdG1lc2ggPSBuZXcgVEhSRUUuTWVzaCggZ2VvbSwgbWF0ZXJpYWwgKTtcclxuXHRcdFx0XHRcdG1lc2gubmFtZSA9ICdtb3JwaF8nICsgbW9ycGhzLmxlbmd0aDtcclxuXHJcblx0XHRcdFx0XHRtb3JwaHMucHVzaCggbWVzaCApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdGlmICggZ2VvbS5pc0xpbmVTdHJpcCA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdFx0XHRcdG1lc2ggPSBuZXcgVEhSRUUuTGluZSggZ2VvbSApO1xyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRtZXNoID0gbmV3IFRIUkVFLk1lc2goIGdlb20sIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdG9iai5hZGQobWVzaCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoIGkgPSAwOyBpIDwgbm9kZS5jYW1lcmFzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciBpbnN0YW5jZV9jYW1lcmEgPSBub2RlLmNhbWVyYXNbaV07XHJcblx0XHRcdHZhciBjcGFyYW1zID0gY2FtZXJhc1tpbnN0YW5jZV9jYW1lcmEudXJsXTtcclxuXHJcblx0XHRcdHZhciBjYW0gPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoY3BhcmFtcy55Zm92LCBwYXJzZUZsb2F0KGNwYXJhbXMuYXNwZWN0X3JhdGlvKSxcclxuXHRcdFx0XHRcdHBhcnNlRmxvYXQoY3BhcmFtcy56bmVhciksIHBhcnNlRmxvYXQoY3BhcmFtcy56ZmFyKSk7XHJcblxyXG5cdFx0XHRvYmouYWRkKGNhbSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBub2RlLmxpZ2h0cy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgbGlnaHQgPSBudWxsO1xyXG5cdFx0XHR2YXIgaW5zdGFuY2VfbGlnaHQgPSBub2RlLmxpZ2h0c1tpXTtcclxuXHRcdFx0dmFyIGxwYXJhbXMgPSBsaWdodHNbaW5zdGFuY2VfbGlnaHQudXJsXTtcclxuXHJcblx0XHRcdGlmICggbHBhcmFtcyAmJiBscGFyYW1zLnRlY2huaXF1ZSApIHtcclxuXHJcblx0XHRcdFx0dmFyIGNvbG9yID0gbHBhcmFtcy5jb2xvci5nZXRIZXgoKTtcclxuXHRcdFx0XHR2YXIgaW50ZW5zaXR5ID0gbHBhcmFtcy5pbnRlbnNpdHk7XHJcblx0XHRcdFx0dmFyIGRpc3RhbmNlID0gbHBhcmFtcy5kaXN0YW5jZTtcclxuXHRcdFx0XHR2YXIgYW5nbGUgPSBscGFyYW1zLmZhbGxvZmZfYW5nbGU7XHJcblx0XHRcdFx0dmFyIGV4cG9uZW50OyAvLyBJbnRlbnRpb25hbGx5IHVuZGVmaW5lZCwgZG9uJ3Qga25vdyB3aGF0IHRoaXMgaXMgeWV0XHJcblxyXG5cdFx0XHRcdHN3aXRjaCAoIGxwYXJhbXMudGVjaG5pcXVlICkge1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgJ2RpcmVjdGlvbmFsJzpcclxuXHJcblx0XHRcdFx0XHRcdGxpZ2h0ID0gbmV3IFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQoIGNvbG9yLCBpbnRlbnNpdHksIGRpc3RhbmNlICk7XHJcblx0XHRcdFx0XHRcdGxpZ2h0LnBvc2l0aW9uLnNldCgwLCAwLCAxKTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSAncG9pbnQnOlxyXG5cclxuXHRcdFx0XHRcdFx0bGlnaHQgPSBuZXcgVEhSRUUuUG9pbnRMaWdodCggY29sb3IsIGludGVuc2l0eSwgZGlzdGFuY2UgKTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSAnc3BvdCc6XHJcblxyXG5cdFx0XHRcdFx0XHRsaWdodCA9IG5ldyBUSFJFRS5TcG90TGlnaHQoIGNvbG9yLCBpbnRlbnNpdHksIGRpc3RhbmNlLCBhbmdsZSwgZXhwb25lbnQgKTtcclxuXHRcdFx0XHRcdFx0bGlnaHQucG9zaXRpb24uc2V0KDAsIDAsIDEpO1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlICdhbWJpZW50JzpcclxuXHJcblx0XHRcdFx0XHRcdGxpZ2h0ID0gbmV3IFRIUkVFLkFtYmllbnRMaWdodCggY29sb3IgKTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChsaWdodCkge1xyXG5cdFx0XHRcdG9iai5hZGQobGlnaHQpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0b2JqLm5hbWUgPSBub2RlLm5hbWUgfHwgbm9kZS5pZCB8fCBcIlwiO1xyXG5cdFx0b2JqLmNvbGxhZGFJZCA9IG5vZGUuaWQgfHwgXCJcIjtcclxuXHRcdG9iai5sYXllciA9IG5vZGUubGF5ZXIgfHwgXCJcIjtcclxuXHRcdG9iai5tYXRyaXggPSBub2RlLm1hdHJpeDtcclxuXHRcdG9iai5tYXRyaXguZGVjb21wb3NlKCBvYmoucG9zaXRpb24sIG9iai5xdWF0ZXJuaW9uLCBvYmouc2NhbGUgKTtcclxuXHJcblx0XHRpZiAoIG9wdGlvbnMuY2VudGVyR2VvbWV0cnkgJiYgb2JqLmdlb21ldHJ5ICkge1xyXG5cclxuXHRcdFx0dmFyIGRlbHRhID0gb2JqLmdlb21ldHJ5LmNlbnRlcigpO1xyXG5cdFx0XHRkZWx0YS5tdWx0aXBseSggb2JqLnNjYWxlICk7XHJcblx0XHRcdGRlbHRhLmFwcGx5UXVhdGVybmlvbiggb2JqLnF1YXRlcm5pb24gKTtcclxuXHJcblx0XHRcdG9iai5wb3NpdGlvbi5zdWIoIGRlbHRhICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoIGkgPSAwOyBpIDwgbm9kZS5ub2Rlcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRvYmouYWRkKCBjcmVhdGVTY2VuZUdyYXBoKCBub2RlLm5vZGVzW2ldLCBub2RlICkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG9iajtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBnZXRKb2ludElkKCBza2luLCBpZCApIHtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBza2luLmpvaW50cy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHNraW4uam9pbnRzWyBpIF0gPT09IGlkICkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gaTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gZ2V0TGlicmFyeU5vZGUoIGlkICkge1xyXG5cclxuXHRcdHZhciBub2RlcyA9IENPTExBREEucXVlcnlTZWxlY3RvckFsbCgnbGlicmFyeV9ub2RlcyBub2RlJyk7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgYXR0T2JqID0gbm9kZXNbaV0uYXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2lkJyk7XHJcblxyXG5cdFx0XHRpZiAoIGF0dE9iaiAmJiBhdHRPYmoudmFsdWUgPT09IGlkICkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gbm9kZXNbaV07XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB1bmRlZmluZWQ7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gZ2V0Q2hhbm5lbHNGb3JOb2RlICggbm9kZSApIHtcclxuXHJcblx0XHR2YXIgY2hhbm5lbHMgPSBbXTtcclxuXHRcdHZhciBzdGFydFRpbWUgPSAxMDAwMDAwO1xyXG5cdFx0dmFyIGVuZFRpbWUgPSAtMTAwMDAwMDtcclxuXHJcblx0XHRmb3IgKCB2YXIgaWQgaW4gYW5pbWF0aW9ucyApIHtcclxuXHJcblx0XHRcdHZhciBhbmltYXRpb24gPSBhbmltYXRpb25zW2lkXTtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGFuaW1hdGlvbi5jaGFubmVsLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0dmFyIGNoYW5uZWwgPSBhbmltYXRpb24uY2hhbm5lbFtpXTtcclxuXHRcdFx0XHR2YXIgc2FtcGxlciA9IGFuaW1hdGlvbi5zYW1wbGVyW2ldO1xyXG5cdFx0XHRcdHZhciBpZCA9IGNoYW5uZWwudGFyZ2V0LnNwbGl0KCcvJylbMF07XHJcblxyXG5cdFx0XHRcdGlmICggaWQgPT0gbm9kZS5pZCApIHtcclxuXHJcblx0XHRcdFx0XHRzYW1wbGVyLmNyZWF0ZSgpO1xyXG5cdFx0XHRcdFx0Y2hhbm5lbC5zYW1wbGVyID0gc2FtcGxlcjtcclxuXHRcdFx0XHRcdHN0YXJ0VGltZSA9IE1hdGgubWluKHN0YXJ0VGltZSwgc2FtcGxlci5zdGFydFRpbWUpO1xyXG5cdFx0XHRcdFx0ZW5kVGltZSA9IE1hdGgubWF4KGVuZFRpbWUsIHNhbXBsZXIuZW5kVGltZSk7XHJcblx0XHRcdFx0XHRjaGFubmVscy5wdXNoKGNoYW5uZWwpO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggY2hhbm5lbHMubGVuZ3RoICkge1xyXG5cclxuXHRcdFx0bm9kZS5zdGFydFRpbWUgPSBzdGFydFRpbWU7XHJcblx0XHRcdG5vZGUuZW5kVGltZSA9IGVuZFRpbWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBjaGFubmVscztcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBjYWxjRnJhbWVEdXJhdGlvbiggbm9kZSApIHtcclxuXHJcblx0XHR2YXIgbWluVCA9IDEwMDAwMDAwO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IG5vZGUuY2hhbm5lbHMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIHNhbXBsZXIgPSBub2RlLmNoYW5uZWxzW2ldLnNhbXBsZXI7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCBzYW1wbGVyLmlucHV0Lmxlbmd0aCAtIDE7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdHZhciB0MCA9IHNhbXBsZXIuaW5wdXRbIGogXTtcclxuXHRcdFx0XHR2YXIgdDEgPSBzYW1wbGVyLmlucHV0WyBqICsgMSBdO1xyXG5cdFx0XHRcdG1pblQgPSBNYXRoLm1pbiggbWluVCwgdDEgLSB0MCApO1xyXG5cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBtaW5UO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGNhbGNNYXRyaXhBdCggbm9kZSwgdCApIHtcclxuXHJcblx0XHR2YXIgYW5pbWF0ZWQgPSB7fTtcclxuXHJcblx0XHR2YXIgaSwgajtcclxuXHJcblx0XHRmb3IgKCBpID0gMDsgaSA8IG5vZGUuY2hhbm5lbHMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIGNoYW5uZWwgPSBub2RlLmNoYW5uZWxzWyBpIF07XHJcblx0XHRcdGFuaW1hdGVkWyBjaGFubmVsLnNpZCBdID0gY2hhbm5lbDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblxyXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBub2RlLnRyYW5zZm9ybXMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIHRyYW5zZm9ybSA9IG5vZGUudHJhbnNmb3Jtc1sgaSBdO1xyXG5cdFx0XHR2YXIgY2hhbm5lbCA9IGFuaW1hdGVkWyB0cmFuc2Zvcm0uc2lkIF07XHJcblxyXG5cdFx0XHRpZiAoIGNoYW5uZWwgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0dmFyIHNhbXBsZXIgPSBjaGFubmVsLnNhbXBsZXI7XHJcblx0XHRcdFx0dmFyIHZhbHVlO1xyXG5cclxuXHRcdFx0XHRmb3IgKCBqID0gMDsgaiA8IHNhbXBsZXIuaW5wdXQubGVuZ3RoIC0gMTsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIHNhbXBsZXIuaW5wdXRbIGogKyAxIF0gPiB0ICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dmFsdWUgPSBzYW1wbGVyLm91dHB1dFsgaiBdO1xyXG5cdFx0XHRcdFx0XHQvL2NvbnNvbGUubG9nKHZhbHVlLmZsYXR0ZW4pXHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCB2YWx1ZSBpbnN0YW5jZW9mIFRIUkVFLk1hdHJpeDQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRtYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggbWF0cml4LCB2YWx1ZSApO1xyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHQvLyBGSVhNRTogaGFuZGxlIG90aGVyIHR5cGVzXHJcblxyXG5cdFx0XHRcdFx0XHRtYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggbWF0cml4LCB0cmFuc2Zvcm0ubWF0cml4ICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdG1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBtYXRyaXgsIHRyYW5zZm9ybS5tYXRyaXggKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0bWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIG1hdHJpeCwgdHJhbnNmb3JtLm1hdHJpeCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbWF0cml4O1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGJha2VBbmltYXRpb25zICggbm9kZSApIHtcclxuXHJcblx0XHRpZiAoIG5vZGUuY2hhbm5lbHMgJiYgbm9kZS5jaGFubmVscy5sZW5ndGggKSB7XHJcblxyXG5cdFx0XHR2YXIga2V5cyA9IFtdLFxyXG5cdFx0XHRcdHNpZHMgPSBbXTtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBub2RlLmNoYW5uZWxzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgY2hhbm5lbCA9IG5vZGUuY2hhbm5lbHNbaV0sXHJcblx0XHRcdFx0XHRmdWxsU2lkID0gY2hhbm5lbC5mdWxsU2lkLFxyXG5cdFx0XHRcdFx0c2FtcGxlciA9IGNoYW5uZWwuc2FtcGxlcixcclxuXHRcdFx0XHRcdGlucHV0ID0gc2FtcGxlci5pbnB1dCxcclxuXHRcdFx0XHRcdHRyYW5zZm9ybSA9IG5vZGUuZ2V0VHJhbnNmb3JtQnlTaWQoIGNoYW5uZWwuc2lkICksXHJcblx0XHRcdFx0XHRtZW1iZXI7XHJcblxyXG5cdFx0XHRcdGlmICggY2hhbm5lbC5hcnJJbmRpY2VzICkge1xyXG5cclxuXHRcdFx0XHRcdG1lbWJlciA9IFtdO1xyXG5cclxuXHRcdFx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSBjaGFubmVsLmFyckluZGljZXMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRtZW1iZXJbIGogXSA9IGdldENvbnZlcnRlZEluZGV4KCBjaGFubmVsLmFyckluZGljZXNbIGogXSApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRtZW1iZXIgPSBnZXRDb252ZXJ0ZWRNZW1iZXIoIGNoYW5uZWwubWVtYmVyICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCB0cmFuc2Zvcm0gKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBzaWRzLmluZGV4T2YoIGZ1bGxTaWQgKSA9PT0gLTEgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRzaWRzLnB1c2goIGZ1bGxTaWQgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IGlucHV0Lmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dmFyIHRpbWUgPSBpbnB1dFtqXSxcclxuXHRcdFx0XHRcdFx0XHRkYXRhID0gc2FtcGxlci5nZXREYXRhKCB0cmFuc2Zvcm0udHlwZSwgaiwgbWVtYmVyICksXHJcblx0XHRcdFx0XHRcdFx0a2V5ID0gZmluZEtleSgga2V5cywgdGltZSApO1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCAha2V5ICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRrZXkgPSBuZXcgS2V5KCB0aW1lICk7XHJcblx0XHRcdFx0XHRcdFx0dmFyIHRpbWVOZHggPSBmaW5kVGltZU5keCgga2V5cywgdGltZSApO1xyXG5cdFx0XHRcdFx0XHRcdGtleXMuc3BsaWNlKCB0aW1lTmR4ID09PSAtMSA/IGtleXMubGVuZ3RoIDogdGltZU5keCwgMCwga2V5ICk7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRrZXkuYWRkVGFyZ2V0KCBmdWxsU2lkLCB0cmFuc2Zvcm0sIG1lbWJlciwgZGF0YSApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRjb25zb2xlLmxvZyggJ0NvdWxkIG5vdCBmaW5kIHRyYW5zZm9ybSBcIicgKyBjaGFubmVsLnNpZCArICdcIiBpbiBub2RlICcgKyBub2RlLmlkICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIHBvc3QgcHJvY2Vzc1xyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBzaWRzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0dmFyIHNpZCA9IHNpZHNbIGkgXTtcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGogPSAwOyBqIDwga2V5cy5sZW5ndGg7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIGtleSA9IGtleXNbIGogXTtcclxuXHJcblx0XHRcdFx0XHRpZiAoICFrZXkuaGFzVGFyZ2V0KCBzaWQgKSApIHtcclxuXHJcblx0XHRcdFx0XHRcdGludGVycG9sYXRlS2V5cygga2V5cywga2V5LCBqLCBzaWQgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdG5vZGUua2V5cyA9IGtleXM7XHJcblx0XHRcdG5vZGUuc2lkcyA9IHNpZHM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGZpbmRLZXkgKCBrZXlzLCB0aW1lKSB7XHJcblxyXG5cdFx0dmFyIHJldFZhbCA9IG51bGw7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IGtleXMubGVuZ3RoOyBpIDwgaWwgJiYgcmV0VmFsID09PSBudWxsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIGtleSA9IGtleXNbaV07XHJcblxyXG5cdFx0XHRpZiAoIGtleS50aW1lID09PSB0aW1lICkge1xyXG5cclxuXHRcdFx0XHRyZXRWYWwgPSBrZXk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBrZXkudGltZSA+IHRpbWUgKSB7XHJcblxyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcmV0VmFsO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGZpbmRUaW1lTmR4ICgga2V5cywgdGltZSkge1xyXG5cclxuXHRcdHZhciBuZHggPSAtMTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0ga2V5cy5sZW5ndGg7IGkgPCBpbCAmJiBuZHggPT09IC0xOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIGtleSA9IGtleXNbaV07XHJcblxyXG5cdFx0XHRpZiAoIGtleS50aW1lID49IHRpbWUgKSB7XHJcblxyXG5cdFx0XHRcdG5keCA9IGk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBuZHg7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gaW50ZXJwb2xhdGVLZXlzICgga2V5cywga2V5LCBuZHgsIGZ1bGxTaWQgKSB7XHJcblxyXG5cdFx0dmFyIHByZXZLZXkgPSBnZXRQcmV2S2V5V2l0aCgga2V5cywgZnVsbFNpZCwgbmR4ID8gbmR4IC0gMSA6IDAgKSxcclxuXHRcdFx0bmV4dEtleSA9IGdldE5leHRLZXlXaXRoKCBrZXlzLCBmdWxsU2lkLCBuZHggKyAxICk7XHJcblxyXG5cdFx0aWYgKCBwcmV2S2V5ICYmIG5leHRLZXkgKSB7XHJcblxyXG5cdFx0XHR2YXIgc2NhbGUgPSAoa2V5LnRpbWUgLSBwcmV2S2V5LnRpbWUpIC8gKG5leHRLZXkudGltZSAtIHByZXZLZXkudGltZSksXHJcblx0XHRcdFx0cHJldlRhcmdldCA9IHByZXZLZXkuZ2V0VGFyZ2V0KCBmdWxsU2lkICksXHJcblx0XHRcdFx0bmV4dERhdGEgPSBuZXh0S2V5LmdldFRhcmdldCggZnVsbFNpZCApLmRhdGEsXHJcblx0XHRcdFx0cHJldkRhdGEgPSBwcmV2VGFyZ2V0LmRhdGEsXHJcblx0XHRcdFx0ZGF0YTtcclxuXHJcblx0XHRcdGlmICggcHJldlRhcmdldC50eXBlID09PSAnbWF0cml4JyApIHtcclxuXHJcblx0XHRcdFx0ZGF0YSA9IHByZXZEYXRhO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggcHJldkRhdGEubGVuZ3RoICkge1xyXG5cclxuXHRcdFx0XHRkYXRhID0gW107XHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHByZXZEYXRhLmxlbmd0aDsgKysgaSApIHtcclxuXHJcblx0XHRcdFx0XHRkYXRhWyBpIF0gPSBwcmV2RGF0YVsgaSBdICsgKCBuZXh0RGF0YVsgaSBdIC0gcHJldkRhdGFbIGkgXSApICogc2NhbGU7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGRhdGEgPSBwcmV2RGF0YSArICggbmV4dERhdGEgLSBwcmV2RGF0YSApICogc2NhbGU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRrZXkuYWRkVGFyZ2V0KCBmdWxsU2lkLCBwcmV2VGFyZ2V0LnRyYW5zZm9ybSwgcHJldlRhcmdldC5tZW1iZXIsIGRhdGEgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gR2V0IG5leHQga2V5IHdpdGggZ2l2ZW4gc2lkXHJcblxyXG5cdGZ1bmN0aW9uIGdldE5leHRLZXlXaXRoKCBrZXlzLCBmdWxsU2lkLCBuZHggKSB7XHJcblxyXG5cdFx0Zm9yICggOyBuZHggPCBrZXlzLmxlbmd0aDsgbmR4ICsrICkge1xyXG5cclxuXHRcdFx0dmFyIGtleSA9IGtleXNbIG5keCBdO1xyXG5cclxuXHRcdFx0aWYgKCBrZXkuaGFzVGFyZ2V0KCBmdWxsU2lkICkgKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiBrZXk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBudWxsO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIEdldCBwcmV2aW91cyBrZXkgd2l0aCBnaXZlbiBzaWRcclxuXHJcblx0ZnVuY3Rpb24gZ2V0UHJldktleVdpdGgoIGtleXMsIGZ1bGxTaWQsIG5keCApIHtcclxuXHJcblx0XHRuZHggPSBuZHggPj0gMCA/IG5keCA6IG5keCArIGtleXMubGVuZ3RoO1xyXG5cclxuXHRcdGZvciAoIDsgbmR4ID49IDA7IG5keCAtLSApIHtcclxuXHJcblx0XHRcdHZhciBrZXkgPSBrZXlzWyBuZHggXTtcclxuXHJcblx0XHRcdGlmICgga2V5Lmhhc1RhcmdldCggZnVsbFNpZCApICkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4ga2V5O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBfSW1hZ2UoKSB7XHJcblxyXG5cdFx0dGhpcy5pZCA9IFwiXCI7XHJcblx0XHR0aGlzLmluaXRfZnJvbSA9IFwiXCI7XHJcblxyXG5cdH1cclxuXHJcblx0X0ltYWdlLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcclxuXHJcblx0XHR0aGlzLmlkID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2lkJyk7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciBjaGlsZCA9IGVsZW1lbnQuY2hpbGROb2Rlc1sgaSBdO1xyXG5cclxuXHRcdFx0aWYgKCBjaGlsZC5ub2RlTmFtZSA9PT0gJ2luaXRfZnJvbScgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuaW5pdF9mcm9tID0gY2hpbGQudGV4dENvbnRlbnQ7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBDb250cm9sbGVyKCkge1xyXG5cclxuXHRcdHRoaXMuaWQgPSBcIlwiO1xyXG5cdFx0dGhpcy5uYW1lID0gXCJcIjtcclxuXHRcdHRoaXMudHlwZSA9IFwiXCI7XHJcblx0XHR0aGlzLnNraW4gPSBudWxsO1xyXG5cdFx0dGhpcy5tb3JwaCA9IG51bGw7XHJcblxyXG5cdH1cclxuXHJcblx0Q29udHJvbGxlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiggZWxlbWVudCApIHtcclxuXHJcblx0XHR0aGlzLmlkID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2lkJyk7XHJcblx0XHR0aGlzLm5hbWUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnbmFtZScpO1xyXG5cdFx0dGhpcy50eXBlID0gXCJub25lXCI7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciBjaGlsZCA9IGVsZW1lbnQuY2hpbGROb2Rlc1sgaSBdO1xyXG5cclxuXHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ3NraW4nOlxyXG5cclxuXHRcdFx0XHRcdHRoaXMuc2tpbiA9IChuZXcgU2tpbigpKS5wYXJzZShjaGlsZCk7XHJcblx0XHRcdFx0XHR0aGlzLnR5cGUgPSBjaGlsZC5ub2RlTmFtZTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICdtb3JwaCc6XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5tb3JwaCA9IChuZXcgTW9ycGgoKSkucGFyc2UoY2hpbGQpO1xyXG5cdFx0XHRcdFx0dGhpcy50eXBlID0gY2hpbGQubm9kZU5hbWU7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0ZGVmYXVsdDpcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBNb3JwaCgpIHtcclxuXHJcblx0XHR0aGlzLm1ldGhvZCA9IG51bGw7XHJcblx0XHR0aGlzLnNvdXJjZSA9IG51bGw7XHJcblx0XHR0aGlzLnRhcmdldHMgPSBudWxsO1xyXG5cdFx0dGhpcy53ZWlnaHRzID0gbnVsbDtcclxuXHJcblx0fVxyXG5cclxuXHRNb3JwaC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiggZWxlbWVudCApIHtcclxuXHJcblx0XHR2YXIgc291cmNlcyA9IHt9O1xyXG5cdFx0dmFyIGlucHV0cyA9IFtdO1xyXG5cdFx0dmFyIGk7XHJcblxyXG5cdFx0dGhpcy5tZXRob2QgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSggJ21ldGhvZCcgKTtcclxuXHRcdHRoaXMuc291cmNlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoICdzb3VyY2UnICkucmVwbGFjZSggL14jLywgJycgKTtcclxuXHJcblx0XHRmb3IgKCBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgY2hpbGQgPSBlbGVtZW50LmNoaWxkTm9kZXNbIGkgXTtcclxuXHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPSAxICkgY29udGludWU7XHJcblxyXG5cdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcclxuXHJcblx0XHRcdFx0Y2FzZSAnc291cmNlJzpcclxuXHJcblx0XHRcdFx0XHR2YXIgc291cmNlID0gKCBuZXcgU291cmNlKCkgKS5wYXJzZSggY2hpbGQgKTtcclxuXHRcdFx0XHRcdHNvdXJjZXNbIHNvdXJjZS5pZCBdID0gc291cmNlO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ3RhcmdldHMnOlxyXG5cclxuXHRcdFx0XHRcdGlucHV0cyA9IHRoaXMucGFyc2VJbnB1dHMoIGNoaWxkICk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0ZGVmYXVsdDpcclxuXHJcblx0XHRcdFx0XHRjb25zb2xlLmxvZyggY2hpbGQubm9kZU5hbWUgKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKCBpID0gMDsgaSA8IGlucHV0cy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgaW5wdXQgPSBpbnB1dHNbIGkgXTtcclxuXHRcdFx0dmFyIHNvdXJjZSA9IHNvdXJjZXNbIGlucHV0LnNvdXJjZSBdO1xyXG5cclxuXHRcdFx0c3dpdGNoICggaW5wdXQuc2VtYW50aWMgKSB7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ01PUlBIX1RBUkdFVCc6XHJcblxyXG5cdFx0XHRcdFx0dGhpcy50YXJnZXRzID0gc291cmNlLnJlYWQoKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICdNT1JQSF9XRUlHSFQnOlxyXG5cclxuXHRcdFx0XHRcdHRoaXMud2VpZ2h0cyA9IHNvdXJjZS5yZWFkKCk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0ZGVmYXVsdDpcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9O1xyXG5cclxuXHRNb3JwaC5wcm90b3R5cGUucGFyc2VJbnB1dHMgPSBmdW5jdGlvbihlbGVtZW50KSB7XHJcblxyXG5cdFx0dmFyIGlucHV0cyA9IFtdO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgY2hpbGQgPSBlbGVtZW50LmNoaWxkTm9kZXNbaV07XHJcblx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT0gMSkgY29udGludWU7XHJcblxyXG5cdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcclxuXHJcblx0XHRcdFx0Y2FzZSAnaW5wdXQnOlxyXG5cclxuXHRcdFx0XHRcdGlucHV0cy5wdXNoKCAobmV3IElucHV0KCkpLnBhcnNlKGNoaWxkKSApO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGRlZmF1bHQ6XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBpbnB1dHM7XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIFNraW4oKSB7XHJcblxyXG5cdFx0dGhpcy5zb3VyY2UgPSBcIlwiO1xyXG5cdFx0dGhpcy5iaW5kU2hhcGVNYXRyaXggPSBudWxsO1xyXG5cdFx0dGhpcy5pbnZCaW5kTWF0cmljZXMgPSBbXTtcclxuXHRcdHRoaXMuam9pbnRzID0gW107XHJcblx0XHR0aGlzLndlaWdodHMgPSBbXTtcclxuXHJcblx0fVxyXG5cclxuXHRTa2luLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xyXG5cclxuXHRcdHZhciBzb3VyY2VzID0ge307XHJcblx0XHR2YXIgam9pbnRzLCB3ZWlnaHRzO1xyXG5cclxuXHRcdHRoaXMuc291cmNlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoICdzb3VyY2UnICkucmVwbGFjZSggL14jLywgJycgKTtcclxuXHRcdHRoaXMuaW52QmluZE1hdHJpY2VzID0gW107XHJcblx0XHR0aGlzLmpvaW50cyA9IFtdO1xyXG5cdFx0dGhpcy53ZWlnaHRzID0gW107XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciBjaGlsZCA9IGVsZW1lbnQuY2hpbGROb2Rlc1tpXTtcclxuXHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPSAxICkgY29udGludWU7XHJcblxyXG5cdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcclxuXHJcblx0XHRcdFx0Y2FzZSAnYmluZF9zaGFwZV9tYXRyaXgnOlxyXG5cclxuXHRcdFx0XHRcdHZhciBmID0gX2Zsb2F0cyhjaGlsZC50ZXh0Q29udGVudCk7XHJcblx0XHRcdFx0XHR0aGlzLmJpbmRTaGFwZU1hdHJpeCA9IGdldENvbnZlcnRlZE1hdDQoIGYgKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICdzb3VyY2UnOlxyXG5cclxuXHRcdFx0XHRcdHZhciBzcmMgPSBuZXcgU291cmNlKCkucGFyc2UoY2hpbGQpO1xyXG5cdFx0XHRcdFx0c291cmNlc1sgc3JjLmlkIF0gPSBzcmM7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnam9pbnRzJzpcclxuXHJcblx0XHRcdFx0XHRqb2ludHMgPSBjaGlsZDtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICd2ZXJ0ZXhfd2VpZ2h0cyc6XHJcblxyXG5cdFx0XHRcdFx0d2VpZ2h0cyA9IGNoaWxkO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGRlZmF1bHQ6XHJcblxyXG5cdFx0XHRcdFx0Y29uc29sZS5sb2coIGNoaWxkLm5vZGVOYW1lICk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnBhcnNlSm9pbnRzKCBqb2ludHMsIHNvdXJjZXMgKTtcclxuXHRcdHRoaXMucGFyc2VXZWlnaHRzKCB3ZWlnaHRzLCBzb3VyY2VzICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH07XHJcblxyXG5cdFNraW4ucHJvdG90eXBlLnBhcnNlSm9pbnRzID0gZnVuY3Rpb24gKCBlbGVtZW50LCBzb3VyY2VzICkge1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgY2hpbGQgPSBlbGVtZW50LmNoaWxkTm9kZXNbIGkgXTtcclxuXHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPSAxICkgY29udGludWU7XHJcblxyXG5cdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcclxuXHJcblx0XHRcdFx0Y2FzZSAnaW5wdXQnOlxyXG5cclxuXHRcdFx0XHRcdHZhciBpbnB1dCA9ICggbmV3IElucHV0KCkgKS5wYXJzZSggY2hpbGQgKTtcclxuXHRcdFx0XHRcdHZhciBzb3VyY2UgPSBzb3VyY2VzWyBpbnB1dC5zb3VyY2UgXTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGlucHV0LnNlbWFudGljID09PSAnSk9JTlQnICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dGhpcy5qb2ludHMgPSBzb3VyY2UucmVhZCgpO1xyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIGlucHV0LnNlbWFudGljID09PSAnSU5WX0JJTkRfTUFUUklYJyApIHtcclxuXHJcblx0XHRcdFx0XHRcdHRoaXMuaW52QmluZE1hdHJpY2VzID0gc291cmNlLnJlYWQoKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGRlZmF1bHQ6XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0U2tpbi5wcm90b3R5cGUucGFyc2VXZWlnaHRzID0gZnVuY3Rpb24gKCBlbGVtZW50LCBzb3VyY2VzICkge1xyXG5cclxuXHRcdHZhciB2LCB2Y291bnQsIGlucHV0cyA9IFtdO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgY2hpbGQgPSBlbGVtZW50LmNoaWxkTm9kZXNbIGkgXTtcclxuXHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPSAxICkgY29udGludWU7XHJcblxyXG5cdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcclxuXHJcblx0XHRcdFx0Y2FzZSAnaW5wdXQnOlxyXG5cclxuXHRcdFx0XHRcdGlucHV0cy5wdXNoKCAoIG5ldyBJbnB1dCgpICkucGFyc2UoIGNoaWxkICkgKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICd2JzpcclxuXHJcblx0XHRcdFx0XHR2ID0gX2ludHMoIGNoaWxkLnRleHRDb250ZW50ICk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAndmNvdW50JzpcclxuXHJcblx0XHRcdFx0XHR2Y291bnQgPSBfaW50cyggY2hpbGQudGV4dENvbnRlbnQgKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRkZWZhdWx0OlxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBpbmRleCA9IDA7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdmNvdW50Lmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciBudW1Cb25lcyA9IHZjb3VudFtpXTtcclxuXHRcdFx0dmFyIHZlcnRleF93ZWlnaHRzID0gW107XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCBudW1Cb25lczsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0dmFyIGluZmx1ZW5jZSA9IHt9O1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgayA9IDA7IGsgPCBpbnB1dHMubGVuZ3RoOyBrICsrICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciBpbnB1dCA9IGlucHV0c1sgayBdO1xyXG5cdFx0XHRcdFx0dmFyIHZhbHVlID0gdlsgaW5kZXggKyBpbnB1dC5vZmZzZXQgXTtcclxuXHJcblx0XHRcdFx0XHRzd2l0Y2ggKCBpbnB1dC5zZW1hbnRpYyApIHtcclxuXHJcblx0XHRcdFx0XHRcdGNhc2UgJ0pPSU5UJzpcclxuXHJcblx0XHRcdFx0XHRcdFx0aW5mbHVlbmNlLmpvaW50ID0gdmFsdWU7Ly90aGlzLmpvaW50c1t2YWx1ZV07XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0XHRjYXNlICdXRUlHSFQnOlxyXG5cclxuXHRcdFx0XHRcdFx0XHRpbmZsdWVuY2Uud2VpZ2h0ID0gc291cmNlc1sgaW5wdXQuc291cmNlIF0uZGF0YVsgdmFsdWUgXTtcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRcdGRlZmF1bHQ6XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHZlcnRleF93ZWlnaHRzLnB1c2goIGluZmx1ZW5jZSApO1xyXG5cdFx0XHRcdGluZGV4ICs9IGlucHV0cy5sZW5ndGg7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZvciAoIHZhciBqID0gMDsgaiA8IHZlcnRleF93ZWlnaHRzLmxlbmd0aDsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0dmVydGV4X3dlaWdodHNbIGogXS5pbmRleCA9IGk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLndlaWdodHMucHVzaCggdmVydGV4X3dlaWdodHMgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIFZpc3VhbFNjZW5lICgpIHtcclxuXHJcblx0XHR0aGlzLmlkID0gXCJcIjtcclxuXHRcdHRoaXMubmFtZSA9IFwiXCI7XHJcblx0XHR0aGlzLm5vZGVzID0gW107XHJcblx0XHR0aGlzLnNjZW5lID0gbmV3IFRIUkVFLkdyb3VwKCk7XHJcblxyXG5cdH1cclxuXHJcblx0VmlzdWFsU2NlbmUucHJvdG90eXBlLmdldENoaWxkQnlJZCA9IGZ1bmN0aW9uKCBpZCwgcmVjdXJzaXZlICkge1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMubm9kZXMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIG5vZGUgPSB0aGlzLm5vZGVzWyBpIF0uZ2V0Q2hpbGRCeUlkKCBpZCwgcmVjdXJzaXZlICk7XHJcblxyXG5cdFx0XHRpZiAoIG5vZGUgKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiBub2RlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHJcblx0fTtcclxuXHJcblx0VmlzdWFsU2NlbmUucHJvdG90eXBlLmdldENoaWxkQnlTaWQgPSBmdW5jdGlvbiggc2lkLCByZWN1cnNpdmUgKSB7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5ub2Rlcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgbm9kZSA9IHRoaXMubm9kZXNbIGkgXS5nZXRDaGlsZEJ5U2lkKCBzaWQsIHJlY3Vyc2l2ZSApO1xyXG5cclxuXHRcdFx0aWYgKCBub2RlICkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gbm9kZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG51bGw7XHJcblxyXG5cdH07XHJcblxyXG5cdFZpc3VhbFNjZW5lLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xyXG5cclxuXHRcdHRoaXMuaWQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSggJ2lkJyApO1xyXG5cdFx0dGhpcy5uYW1lID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoICduYW1lJyApO1xyXG5cdFx0dGhpcy5ub2RlcyA9IFtdO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgY2hpbGQgPSBlbGVtZW50LmNoaWxkTm9kZXNbIGkgXTtcclxuXHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPSAxICkgY29udGludWU7XHJcblxyXG5cdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcclxuXHJcblx0XHRcdFx0Y2FzZSAnbm9kZSc6XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5ub2Rlcy5wdXNoKCAoIG5ldyBOb2RlKCkgKS5wYXJzZSggY2hpbGQgKSApO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGRlZmF1bHQ6XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIE5vZGUoKSB7XHJcblxyXG5cdFx0dGhpcy5pZCA9IFwiXCI7XHJcblx0XHR0aGlzLm5hbWUgPSBcIlwiO1xyXG5cdFx0dGhpcy5zaWQgPSBcIlwiO1xyXG5cdFx0dGhpcy5ub2RlcyA9IFtdO1xyXG5cdFx0dGhpcy5jb250cm9sbGVycyA9IFtdO1xyXG5cdFx0dGhpcy50cmFuc2Zvcm1zID0gW107XHJcblx0XHR0aGlzLmdlb21ldHJpZXMgPSBbXTtcclxuXHRcdHRoaXMuY2hhbm5lbHMgPSBbXTtcclxuXHRcdHRoaXMubWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHJcblx0fVxyXG5cclxuXHROb2RlLnByb3RvdHlwZS5nZXRDaGFubmVsRm9yVHJhbnNmb3JtID0gZnVuY3Rpb24oIHRyYW5zZm9ybVNpZCApIHtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmNoYW5uZWxzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciBjaGFubmVsID0gdGhpcy5jaGFubmVsc1tpXTtcclxuXHRcdFx0dmFyIHBhcnRzID0gY2hhbm5lbC50YXJnZXQuc3BsaXQoJy8nKTtcclxuXHRcdFx0dmFyIGlkID0gcGFydHMuc2hpZnQoKTtcclxuXHRcdFx0dmFyIHNpZCA9IHBhcnRzLnNoaWZ0KCk7XHJcblx0XHRcdHZhciBkb3RTeW50YXggPSAoc2lkLmluZGV4T2YoXCIuXCIpID49IDApO1xyXG5cdFx0XHR2YXIgYXJyU3ludGF4ID0gKHNpZC5pbmRleE9mKFwiKFwiKSA+PSAwKTtcclxuXHRcdFx0dmFyIGFyckluZGljZXM7XHJcblx0XHRcdHZhciBtZW1iZXI7XHJcblxyXG5cdFx0XHRpZiAoIGRvdFN5bnRheCApIHtcclxuXHJcblx0XHRcdFx0cGFydHMgPSBzaWQuc3BsaXQoXCIuXCIpO1xyXG5cdFx0XHRcdHNpZCA9IHBhcnRzLnNoaWZ0KCk7XHJcblx0XHRcdFx0bWVtYmVyID0gcGFydHMuc2hpZnQoKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIGFyclN5bnRheCApIHtcclxuXHJcblx0XHRcdFx0YXJySW5kaWNlcyA9IHNpZC5zcGxpdChcIihcIik7XHJcblx0XHRcdFx0c2lkID0gYXJySW5kaWNlcy5zaGlmdCgpO1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCBhcnJJbmRpY2VzLmxlbmd0aDsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0XHRhcnJJbmRpY2VzWyBqIF0gPSBwYXJzZUludCggYXJySW5kaWNlc1sgaiBdLnJlcGxhY2UoIC9cXCkvLCAnJyApICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggc2lkID09PSB0cmFuc2Zvcm1TaWQgKSB7XHJcblxyXG5cdFx0XHRcdGNoYW5uZWwuaW5mbyA9IHsgc2lkOiBzaWQsIGRvdFN5bnRheDogZG90U3ludGF4LCBhcnJTeW50YXg6IGFyclN5bnRheCwgYXJySW5kaWNlczogYXJySW5kaWNlcyB9O1xyXG5cdFx0XHRcdHJldHVybiBjaGFubmVsO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHJcblx0fTtcclxuXHJcblx0Tm9kZS5wcm90b3R5cGUuZ2V0Q2hpbGRCeUlkID0gZnVuY3Rpb24gKCBpZCwgcmVjdXJzaXZlICkge1xyXG5cclxuXHRcdGlmICggdGhpcy5pZCA9PT0gaWQgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCByZWN1cnNpdmUgKSB7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLm5vZGVzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0dmFyIG4gPSB0aGlzLm5vZGVzWyBpIF0uZ2V0Q2hpbGRCeUlkKCBpZCwgcmVjdXJzaXZlICk7XHJcblxyXG5cdFx0XHRcdGlmICggbiApIHtcclxuXHJcblx0XHRcdFx0XHRyZXR1cm4gbjtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHJcblx0fTtcclxuXHJcblx0Tm9kZS5wcm90b3R5cGUuZ2V0Q2hpbGRCeVNpZCA9IGZ1bmN0aW9uICggc2lkLCByZWN1cnNpdmUgKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLnNpZCA9PT0gc2lkICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggcmVjdXJzaXZlICkge1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5ub2Rlcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBuID0gdGhpcy5ub2Rlc1sgaSBdLmdldENoaWxkQnlTaWQoIHNpZCwgcmVjdXJzaXZlICk7XHJcblxyXG5cdFx0XHRcdGlmICggbiApIHtcclxuXHJcblx0XHRcdFx0XHRyZXR1cm4gbjtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBudWxsO1xyXG5cclxuXHR9O1xyXG5cclxuXHROb2RlLnByb3RvdHlwZS5nZXRUcmFuc2Zvcm1CeVNpZCA9IGZ1bmN0aW9uICggc2lkICkge1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMudHJhbnNmb3Jtcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMudHJhbnNmb3Jtc1sgaSBdLnNpZCA9PT0gc2lkICkgcmV0dXJuIHRoaXMudHJhbnNmb3Jtc1sgaSBdO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHJcblx0fTtcclxuXHJcblx0Tm9kZS5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiggZWxlbWVudCApIHtcclxuXHJcblx0XHR2YXIgdXJsO1xyXG5cclxuXHRcdHRoaXMuaWQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnaWQnKTtcclxuXHRcdHRoaXMuc2lkID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3NpZCcpO1xyXG5cdFx0dGhpcy5uYW1lID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ25hbWUnKTtcclxuXHRcdHRoaXMudHlwZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCd0eXBlJyk7XHJcblx0XHR0aGlzLmxheWVyID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2xheWVyJyk7XHJcblxyXG5cdFx0dGhpcy50eXBlID0gdGhpcy50eXBlID09PSAnSk9JTlQnID8gdGhpcy50eXBlIDogJ05PREUnO1xyXG5cclxuXHRcdHRoaXMubm9kZXMgPSBbXTtcclxuXHRcdHRoaXMudHJhbnNmb3JtcyA9IFtdO1xyXG5cdFx0dGhpcy5nZW9tZXRyaWVzID0gW107XHJcblx0XHR0aGlzLmNhbWVyYXMgPSBbXTtcclxuXHRcdHRoaXMubGlnaHRzID0gW107XHJcblx0XHR0aGlzLmNvbnRyb2xsZXJzID0gW107XHJcblx0XHR0aGlzLm1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciBjaGlsZCA9IGVsZW1lbnQuY2hpbGROb2Rlc1sgaSBdO1xyXG5cdFx0XHRpZiAoIGNoaWxkLm5vZGVUeXBlICE9IDEgKSBjb250aW51ZTtcclxuXHJcblx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xyXG5cclxuXHRcdFx0XHRjYXNlICdub2RlJzpcclxuXHJcblx0XHRcdFx0XHR0aGlzLm5vZGVzLnB1c2goICggbmV3IE5vZGUoKSApLnBhcnNlKCBjaGlsZCApICk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnaW5zdGFuY2VfY2FtZXJhJzpcclxuXHJcblx0XHRcdFx0XHR0aGlzLmNhbWVyYXMucHVzaCggKCBuZXcgSW5zdGFuY2VDYW1lcmEoKSApLnBhcnNlKCBjaGlsZCApICk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnaW5zdGFuY2VfY29udHJvbGxlcic6XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5jb250cm9sbGVycy5wdXNoKCAoIG5ldyBJbnN0YW5jZUNvbnRyb2xsZXIoKSApLnBhcnNlKCBjaGlsZCApICk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnaW5zdGFuY2VfZ2VvbWV0cnknOlxyXG5cclxuXHRcdFx0XHRcdHRoaXMuZ2VvbWV0cmllcy5wdXNoKCAoIG5ldyBJbnN0YW5jZUdlb21ldHJ5KCkgKS5wYXJzZSggY2hpbGQgKSApO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ2luc3RhbmNlX2xpZ2h0JzpcclxuXHJcblx0XHRcdFx0XHR0aGlzLmxpZ2h0cy5wdXNoKCAoIG5ldyBJbnN0YW5jZUxpZ2h0KCkgKS5wYXJzZSggY2hpbGQgKSApO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ2luc3RhbmNlX25vZGUnOlxyXG5cclxuXHRcdFx0XHRcdHVybCA9IGNoaWxkLmdldEF0dHJpYnV0ZSggJ3VybCcgKS5yZXBsYWNlKCAvXiMvLCAnJyApO1xyXG5cdFx0XHRcdFx0dmFyIGlOb2RlID0gZ2V0TGlicmFyeU5vZGUoIHVybCApO1xyXG5cclxuXHRcdFx0XHRcdGlmICggaU5vZGUgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR0aGlzLm5vZGVzLnB1c2goICggbmV3IE5vZGUoKSApLnBhcnNlKCBpTm9kZSApKSA7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICdyb3RhdGUnOlxyXG5cdFx0XHRcdGNhc2UgJ3RyYW5zbGF0ZSc6XHJcblx0XHRcdFx0Y2FzZSAnc2NhbGUnOlxyXG5cdFx0XHRcdGNhc2UgJ21hdHJpeCc6XHJcblx0XHRcdFx0Y2FzZSAnbG9va2F0JzpcclxuXHRcdFx0XHRjYXNlICdza2V3JzpcclxuXHJcblx0XHRcdFx0XHR0aGlzLnRyYW5zZm9ybXMucHVzaCggKCBuZXcgVHJhbnNmb3JtKCkgKS5wYXJzZSggY2hpbGQgKSApO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ2V4dHJhJzpcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRkZWZhdWx0OlxyXG5cclxuXHRcdFx0XHRcdGNvbnNvbGUubG9nKCBjaGlsZC5ub2RlTmFtZSApO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuY2hhbm5lbHMgPSBnZXRDaGFubmVsc0Zvck5vZGUoIHRoaXMgKTtcclxuXHRcdGJha2VBbmltYXRpb25zKCB0aGlzICk7XHJcblxyXG5cdFx0dGhpcy51cGRhdGVNYXRyaXgoKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fTtcclxuXHJcblx0Tm9kZS5wcm90b3R5cGUudXBkYXRlTWF0cml4ID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMubWF0cml4LmlkZW50aXR5KCk7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy50cmFuc2Zvcm1zLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdHRoaXMudHJhbnNmb3Jtc1sgaSBdLmFwcGx5KCB0aGlzLm1hdHJpeCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gVHJhbnNmb3JtICgpIHtcclxuXHJcblx0XHR0aGlzLnNpZCA9IFwiXCI7XHJcblx0XHR0aGlzLnR5cGUgPSBcIlwiO1xyXG5cdFx0dGhpcy5kYXRhID0gW107XHJcblx0XHR0aGlzLm9iaiA9IG51bGw7XHJcblxyXG5cdH1cclxuXHJcblx0VHJhbnNmb3JtLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uICggZWxlbWVudCApIHtcclxuXHJcblx0XHR0aGlzLnNpZCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCAnc2lkJyApO1xyXG5cdFx0dGhpcy50eXBlID0gZWxlbWVudC5ub2RlTmFtZTtcclxuXHRcdHRoaXMuZGF0YSA9IF9mbG9hdHMoIGVsZW1lbnQudGV4dENvbnRlbnQgKTtcclxuXHRcdHRoaXMuY29udmVydCgpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9O1xyXG5cclxuXHRUcmFuc2Zvcm0ucHJvdG90eXBlLmNvbnZlcnQgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0c3dpdGNoICggdGhpcy50eXBlICkge1xyXG5cclxuXHRcdFx0Y2FzZSAnbWF0cml4JzpcclxuXHJcblx0XHRcdFx0dGhpcy5vYmogPSBnZXRDb252ZXJ0ZWRNYXQ0KCB0aGlzLmRhdGEgKTtcclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGNhc2UgJ3JvdGF0ZSc6XHJcblxyXG5cdFx0XHRcdHRoaXMuYW5nbGUgPSBUSFJFRS5NYXRoLmRlZ1RvUmFkKCB0aGlzLmRhdGFbM10gKTtcclxuXHJcblx0XHRcdGNhc2UgJ3RyYW5zbGF0ZSc6XHJcblxyXG5cdFx0XHRcdGZpeENvb3JkcyggdGhpcy5kYXRhLCAtMSApO1xyXG5cdFx0XHRcdHRoaXMub2JqID0gbmV3IFRIUkVFLlZlY3RvcjMoIHRoaXMuZGF0YVsgMCBdLCB0aGlzLmRhdGFbIDEgXSwgdGhpcy5kYXRhWyAyIF0gKTtcclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGNhc2UgJ3NjYWxlJzpcclxuXHJcblx0XHRcdFx0Zml4Q29vcmRzKCB0aGlzLmRhdGEsIDEgKTtcclxuXHRcdFx0XHR0aGlzLm9iaiA9IG5ldyBUSFJFRS5WZWN0b3IzKCB0aGlzLmRhdGFbIDAgXSwgdGhpcy5kYXRhWyAxIF0sIHRoaXMuZGF0YVsgMiBdICk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRkZWZhdWx0OlxyXG5cdFx0XHRcdGNvbnNvbGUubG9nKCAnQ2FuIG5vdCBjb252ZXJ0IFRyYW5zZm9ybSBvZiB0eXBlICcgKyB0aGlzLnR5cGUgKTtcclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdFRyYW5zZm9ybS5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIG0xID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBtYXRyaXggKSB7XHJcblxyXG5cdFx0XHRzd2l0Y2ggKCB0aGlzLnR5cGUgKSB7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ21hdHJpeCc6XHJcblxyXG5cdFx0XHRcdFx0bWF0cml4Lm11bHRpcGx5KCB0aGlzLm9iaiApO1xyXG5cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICd0cmFuc2xhdGUnOlxyXG5cclxuXHRcdFx0XHRcdG1hdHJpeC5tdWx0aXBseSggbTEubWFrZVRyYW5zbGF0aW9uKCB0aGlzLm9iai54LCB0aGlzLm9iai55LCB0aGlzLm9iai56ICkgKTtcclxuXHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAncm90YXRlJzpcclxuXHJcblx0XHRcdFx0XHRtYXRyaXgubXVsdGlwbHkoIG0xLm1ha2VSb3RhdGlvbkF4aXMoIHRoaXMub2JqLCB0aGlzLmFuZ2xlICkgKTtcclxuXHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnc2NhbGUnOlxyXG5cclxuXHRcdFx0XHRcdG1hdHJpeC5zY2FsZSggdGhpcy5vYmogKTtcclxuXHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCk7XHJcblxyXG5cdFRyYW5zZm9ybS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCBkYXRhLCBtZW1iZXIgKSB7XHJcblxyXG5cdFx0dmFyIG1lbWJlcnMgPSBbICdYJywgJ1knLCAnWicsICdBTkdMRScgXTtcclxuXHJcblx0XHRzd2l0Y2ggKCB0aGlzLnR5cGUgKSB7XHJcblxyXG5cdFx0XHRjYXNlICdtYXRyaXgnOlxyXG5cclxuXHRcdFx0XHRpZiAoICEgbWVtYmVyICkge1xyXG5cclxuXHRcdFx0XHRcdHRoaXMub2JqLmNvcHkoIGRhdGEgKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggbWVtYmVyLmxlbmd0aCA9PT0gMSApIHtcclxuXHJcblx0XHRcdFx0XHRzd2l0Y2ggKCBtZW1iZXJbIDAgXSApIHtcclxuXHJcblx0XHRcdFx0XHRcdGNhc2UgMDpcclxuXHJcblx0XHRcdFx0XHRcdFx0dGhpcy5vYmoubjExID0gZGF0YVsgMCBdO1xyXG5cdFx0XHRcdFx0XHRcdHRoaXMub2JqLm4yMSA9IGRhdGFbIDEgXTtcclxuXHRcdFx0XHRcdFx0XHR0aGlzLm9iai5uMzEgPSBkYXRhWyAyIF07XHJcblx0XHRcdFx0XHRcdFx0dGhpcy5vYmoubjQxID0gZGF0YVsgMyBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRcdGNhc2UgMTpcclxuXHJcblx0XHRcdFx0XHRcdFx0dGhpcy5vYmoubjEyID0gZGF0YVsgMCBdO1xyXG5cdFx0XHRcdFx0XHRcdHRoaXMub2JqLm4yMiA9IGRhdGFbIDEgXTtcclxuXHRcdFx0XHRcdFx0XHR0aGlzLm9iai5uMzIgPSBkYXRhWyAyIF07XHJcblx0XHRcdFx0XHRcdFx0dGhpcy5vYmoubjQyID0gZGF0YVsgMyBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRcdGNhc2UgMjpcclxuXHJcblx0XHRcdFx0XHRcdFx0dGhpcy5vYmoubjEzID0gZGF0YVsgMCBdO1xyXG5cdFx0XHRcdFx0XHRcdHRoaXMub2JqLm4yMyA9IGRhdGFbIDEgXTtcclxuXHRcdFx0XHRcdFx0XHR0aGlzLm9iai5uMzMgPSBkYXRhWyAyIF07XHJcblx0XHRcdFx0XHRcdFx0dGhpcy5vYmoubjQzID0gZGF0YVsgMyBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRcdGNhc2UgMzpcclxuXHJcblx0XHRcdFx0XHRcdFx0dGhpcy5vYmoubjE0ID0gZGF0YVsgMCBdO1xyXG5cdFx0XHRcdFx0XHRcdHRoaXMub2JqLm4yNCA9IGRhdGFbIDEgXTtcclxuXHRcdFx0XHRcdFx0XHR0aGlzLm9iai5uMzQgPSBkYXRhWyAyIF07XHJcblx0XHRcdFx0XHRcdFx0dGhpcy5vYmoubjQ0ID0gZGF0YVsgMyBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1lbWJlci5sZW5ndGggPT09IDIgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIHByb3BOYW1lID0gJ24nICsgKCBtZW1iZXJbIDAgXSArIDEgKSArICggbWVtYmVyWyAxIF0gKyAxICk7XHJcblx0XHRcdFx0XHR0aGlzLm9ialsgcHJvcE5hbWUgXSA9IGRhdGE7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0Y29uc29sZS5sb2coJ0luY29ycmVjdCBhZGRyZXNzaW5nIG9mIG1hdHJpeCBpbiB0cmFuc2Zvcm0uJyk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRjYXNlICd0cmFuc2xhdGUnOlxyXG5cdFx0XHRjYXNlICdzY2FsZSc6XHJcblxyXG5cdFx0XHRcdGlmICggT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKCBtZW1iZXIgKSA9PT0gJ1tvYmplY3QgQXJyYXldJyApIHtcclxuXHJcblx0XHRcdFx0XHRtZW1iZXIgPSBtZW1iZXJzWyBtZW1iZXJbIDAgXSBdO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHN3aXRjaCAoIG1lbWJlciApIHtcclxuXHJcblx0XHRcdFx0XHRjYXNlICdYJzpcclxuXHJcblx0XHRcdFx0XHRcdHRoaXMub2JqLnggPSBkYXRhO1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlICdZJzpcclxuXHJcblx0XHRcdFx0XHRcdHRoaXMub2JqLnkgPSBkYXRhO1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlICdaJzpcclxuXHJcblx0XHRcdFx0XHRcdHRoaXMub2JqLnogPSBkYXRhO1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRkZWZhdWx0OlxyXG5cclxuXHRcdFx0XHRcdFx0dGhpcy5vYmoueCA9IGRhdGFbIDAgXTtcclxuXHRcdFx0XHRcdFx0dGhpcy5vYmoueSA9IGRhdGFbIDEgXTtcclxuXHRcdFx0XHRcdFx0dGhpcy5vYmoueiA9IGRhdGFbIDIgXTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRjYXNlICdyb3RhdGUnOlxyXG5cclxuXHRcdFx0XHRpZiAoIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCggbWVtYmVyICkgPT09ICdbb2JqZWN0IEFycmF5XScgKSB7XHJcblxyXG5cdFx0XHRcdFx0bWVtYmVyID0gbWVtYmVyc1sgbWVtYmVyWyAwIF0gXTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRzd2l0Y2ggKCBtZW1iZXIgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSAnWCc6XHJcblxyXG5cdFx0XHRcdFx0XHR0aGlzLm9iai54ID0gZGF0YTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSAnWSc6XHJcblxyXG5cdFx0XHRcdFx0XHR0aGlzLm9iai55ID0gZGF0YTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSAnWic6XHJcblxyXG5cdFx0XHRcdFx0XHR0aGlzLm9iai56ID0gZGF0YTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSAnQU5HTEUnOlxyXG5cclxuXHRcdFx0XHRcdFx0dGhpcy5hbmdsZSA9IFRIUkVFLk1hdGguZGVnVG9SYWQoIGRhdGEgKTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0ZGVmYXVsdDpcclxuXHJcblx0XHRcdFx0XHRcdHRoaXMub2JqLnggPSBkYXRhWyAwIF07XHJcblx0XHRcdFx0XHRcdHRoaXMub2JqLnkgPSBkYXRhWyAxIF07XHJcblx0XHRcdFx0XHRcdHRoaXMub2JqLnogPSBkYXRhWyAyIF07XHJcblx0XHRcdFx0XHRcdHRoaXMuYW5nbGUgPSBUSFJFRS5NYXRoLmRlZ1RvUmFkKCBkYXRhWyAzIF0gKTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIEluc3RhbmNlQ29udHJvbGxlcigpIHtcclxuXHJcblx0XHR0aGlzLnVybCA9IFwiXCI7XHJcblx0XHR0aGlzLnNrZWxldG9uID0gW107XHJcblx0XHR0aGlzLmluc3RhbmNlX21hdGVyaWFsID0gW107XHJcblxyXG5cdH1cclxuXHJcblx0SW5zdGFuY2VDb250cm9sbGVyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uICggZWxlbWVudCApIHtcclxuXHJcblx0XHR0aGlzLnVybCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCd1cmwnKS5yZXBsYWNlKC9eIy8sICcnKTtcclxuXHRcdHRoaXMuc2tlbGV0b24gPSBbXTtcclxuXHRcdHRoaXMuaW5zdGFuY2VfbWF0ZXJpYWwgPSBbXTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBlbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIGNoaWxkID0gZWxlbWVudC5jaGlsZE5vZGVzWyBpIF07XHJcblx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT09IDEgKSBjb250aW51ZTtcclxuXHJcblx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xyXG5cclxuXHRcdFx0XHRjYXNlICdza2VsZXRvbic6XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5za2VsZXRvbi5wdXNoKCBjaGlsZC50ZXh0Q29udGVudC5yZXBsYWNlKC9eIy8sICcnKSApO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ2JpbmRfbWF0ZXJpYWwnOlxyXG5cclxuXHRcdFx0XHRcdHZhciBpbnN0YW5jZXMgPSBjaGlsZC5xdWVyeVNlbGVjdG9yQWxsKCdpbnN0YW5jZV9tYXRlcmlhbCcpO1xyXG5cclxuXHRcdFx0XHRcdGZvciAoIHZhciBqID0gMDsgaiA8IGluc3RhbmNlcy5sZW5ndGg7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR2YXIgaW5zdGFuY2UgPSBpbnN0YW5jZXNbal07XHJcblx0XHRcdFx0XHRcdHRoaXMuaW5zdGFuY2VfbWF0ZXJpYWwucHVzaCggKG5ldyBJbnN0YW5jZU1hdGVyaWFsKCkpLnBhcnNlKGluc3RhbmNlKSApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ2V4dHJhJzpcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRkZWZhdWx0OlxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIEluc3RhbmNlTWF0ZXJpYWwgKCkge1xyXG5cclxuXHRcdHRoaXMuc3ltYm9sID0gXCJcIjtcclxuXHRcdHRoaXMudGFyZ2V0ID0gXCJcIjtcclxuXHJcblx0fVxyXG5cclxuXHRJbnN0YW5jZU1hdGVyaWFsLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uICggZWxlbWVudCApIHtcclxuXHJcblx0XHR0aGlzLnN5bWJvbCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdzeW1ib2wnKTtcclxuXHRcdHRoaXMudGFyZ2V0ID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3RhcmdldCcpLnJlcGxhY2UoL14jLywgJycpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIEluc3RhbmNlR2VvbWV0cnkoKSB7XHJcblxyXG5cdFx0dGhpcy51cmwgPSBcIlwiO1xyXG5cdFx0dGhpcy5pbnN0YW5jZV9tYXRlcmlhbCA9IFtdO1xyXG5cclxuXHR9XHJcblxyXG5cdEluc3RhbmNlR2VvbWV0cnkucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKCBlbGVtZW50ICkge1xyXG5cclxuXHRcdHRoaXMudXJsID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3VybCcpLnJlcGxhY2UoL14jLywgJycpO1xyXG5cdFx0dGhpcy5pbnN0YW5jZV9tYXRlcmlhbCA9IFtdO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgY2hpbGQgPSBlbGVtZW50LmNoaWxkTm9kZXNbaV07XHJcblx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT0gMSApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0aWYgKCBjaGlsZC5ub2RlTmFtZSA9PT0gJ2JpbmRfbWF0ZXJpYWwnICkge1xyXG5cclxuXHRcdFx0XHR2YXIgaW5zdGFuY2VzID0gY2hpbGQucXVlcnlTZWxlY3RvckFsbCgnaW5zdGFuY2VfbWF0ZXJpYWwnKTtcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGogPSAwOyBqIDwgaW5zdGFuY2VzLmxlbmd0aDsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgaW5zdGFuY2UgPSBpbnN0YW5jZXNbal07XHJcblx0XHRcdFx0XHR0aGlzLmluc3RhbmNlX21hdGVyaWFsLnB1c2goIChuZXcgSW5zdGFuY2VNYXRlcmlhbCgpKS5wYXJzZShpbnN0YW5jZSkgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIEdlb21ldHJ5KCkge1xyXG5cclxuXHRcdHRoaXMuaWQgPSBcIlwiO1xyXG5cdFx0dGhpcy5tZXNoID0gbnVsbDtcclxuXHJcblx0fVxyXG5cclxuXHRHZW9tZXRyeS5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoIGVsZW1lbnQgKSB7XHJcblxyXG5cdFx0dGhpcy5pZCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdpZCcpO1xyXG5cclxuXHRcdGV4dHJhY3REb3VibGVTaWRlZCggdGhpcywgZWxlbWVudCApO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgY2hpbGQgPSBlbGVtZW50LmNoaWxkTm9kZXNbaV07XHJcblxyXG5cdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcclxuXHJcblx0XHRcdFx0Y2FzZSAnbWVzaCc6XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5tZXNoID0gKG5ldyBNZXNoKHRoaXMpKS5wYXJzZShjaGlsZCk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnZXh0cmEnOlxyXG5cclxuXHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nKCBjaGlsZCApO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGRlZmF1bHQ6XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBNZXNoKCBnZW9tZXRyeSApIHtcclxuXHJcblx0XHR0aGlzLmdlb21ldHJ5ID0gZ2VvbWV0cnkuaWQ7XHJcblx0XHR0aGlzLnByaW1pdGl2ZXMgPSBbXTtcclxuXHRcdHRoaXMudmVydGljZXMgPSBudWxsO1xyXG5cdFx0dGhpcy5nZW9tZXRyeTNqcyA9IG51bGw7XHJcblxyXG5cdH1cclxuXHJcblx0TWVzaC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoIGVsZW1lbnQgKSB7XHJcblxyXG5cdFx0dGhpcy5wcmltaXRpdmVzID0gW107XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciBjaGlsZCA9IGVsZW1lbnQuY2hpbGROb2Rlc1sgaSBdO1xyXG5cclxuXHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ3NvdXJjZSc6XHJcblxyXG5cdFx0XHRcdFx0X3NvdXJjZSggY2hpbGQgKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICd2ZXJ0aWNlcyc6XHJcblxyXG5cdFx0XHRcdFx0dGhpcy52ZXJ0aWNlcyA9ICggbmV3IFZlcnRpY2VzKCkgKS5wYXJzZSggY2hpbGQgKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICdsaW5lc3RyaXBzJzpcclxuXHJcblx0XHRcdFx0XHR0aGlzLnByaW1pdGl2ZXMucHVzaCggKCBuZXcgTGluZVN0cmlwcygpLnBhcnNlKCBjaGlsZCApICkgKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICd0cmlhbmdsZXMnOlxyXG5cclxuXHRcdFx0XHRcdHRoaXMucHJpbWl0aXZlcy5wdXNoKCAoIG5ldyBUcmlhbmdsZXMoKS5wYXJzZSggY2hpbGQgKSApICk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAncG9seWdvbnMnOlxyXG5cclxuXHRcdFx0XHRcdHRoaXMucHJpbWl0aXZlcy5wdXNoKCAoIG5ldyBQb2x5Z29ucygpLnBhcnNlKCBjaGlsZCApICkgKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICdwb2x5bGlzdCc6XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5wcmltaXRpdmVzLnB1c2goICggbmV3IFBvbHlsaXN0KCkucGFyc2UoIGNoaWxkICkgKSApO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGRlZmF1bHQ6XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5nZW9tZXRyeTNqcyA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xyXG5cclxuXHRcdGlmICggdGhpcy52ZXJ0aWNlcyA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdC8vIFRPRE8gKG1yZG9vYik6IFN0dWR5IGNhc2Ugd2hlbiB0aGlzIGlzIG51bGwgKGNhcnJpZXIuZGFlKVxyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciB2ZXJ0ZXhEYXRhID0gc291cmNlc1sgdGhpcy52ZXJ0aWNlcy5pbnB1dFsnUE9TSVRJT04nXS5zb3VyY2UgXS5kYXRhO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHZlcnRleERhdGEubGVuZ3RoOyBpICs9IDMgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmdlb21ldHJ5M2pzLnZlcnRpY2VzLnB1c2goIGdldENvbnZlcnRlZFZlYzMoIHZlcnRleERhdGEsIGkgKS5jbG9uZSgpICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMucHJpbWl0aXZlcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgcHJpbWl0aXZlID0gdGhpcy5wcmltaXRpdmVzWyBpIF07XHJcblx0XHRcdHByaW1pdGl2ZS5zZXRWZXJ0aWNlcyggdGhpcy52ZXJ0aWNlcyApO1xyXG5cdFx0XHR0aGlzLmhhbmRsZVByaW1pdGl2ZSggcHJpbWl0aXZlLCB0aGlzLmdlb21ldHJ5M2pzICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdGhpcy5nZW9tZXRyeTNqcy5jYWxjTm9ybWFscyApIHtcclxuXHJcblx0XHRcdHRoaXMuZ2VvbWV0cnkzanMuY29tcHV0ZVZlcnRleE5vcm1hbHMoKTtcclxuXHRcdFx0ZGVsZXRlIHRoaXMuZ2VvbWV0cnkzanMuY2FsY05vcm1hbHM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9O1xyXG5cclxuXHRNZXNoLnByb3RvdHlwZS5oYW5kbGVQcmltaXRpdmUgPSBmdW5jdGlvbiAoIHByaW1pdGl2ZSwgZ2VvbSApIHtcclxuXHJcblx0XHRpZiAoIHByaW1pdGl2ZSBpbnN0YW5jZW9mIExpbmVTdHJpcHMgKSB7XHJcblxyXG5cdFx0XHQvLyBUT0RPOiBIYW5kbGUgaW5kaWNlcy4gTWF5YmUgZWFzaWVyIHdpdGggQnVmZmVyR2VvbWV0cnk/XHJcblxyXG5cdFx0XHRnZW9tLmlzTGluZVN0cmlwID0gdHJ1ZTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgaiwgaywgcExpc3QgPSBwcmltaXRpdmUucCwgaW5wdXRzID0gcHJpbWl0aXZlLmlucHV0cztcclxuXHRcdHZhciBpbnB1dCwgaW5kZXgsIGlkeDMyO1xyXG5cdFx0dmFyIHNvdXJjZSwgbnVtUGFyYW1zO1xyXG5cdFx0dmFyIHZjSW5kZXggPSAwLCB2Y291bnQgPSAzLCBtYXhPZmZzZXQgPSAwO1xyXG5cdFx0dmFyIHRleHR1cmVfc2V0cyA9IFtdO1xyXG5cclxuXHRcdGZvciAoIGogPSAwOyBqIDwgaW5wdXRzLmxlbmd0aDsgaiArKyApIHtcclxuXHJcblx0XHRcdGlucHV0ID0gaW5wdXRzWyBqIF07XHJcblxyXG5cdFx0XHR2YXIgb2Zmc2V0ID0gaW5wdXQub2Zmc2V0ICsgMTtcclxuXHRcdFx0bWF4T2Zmc2V0ID0gKG1heE9mZnNldCA8IG9mZnNldCkgPyBvZmZzZXQgOiBtYXhPZmZzZXQ7XHJcblxyXG5cdFx0XHRzd2l0Y2ggKCBpbnB1dC5zZW1hbnRpYyApIHtcclxuXHJcblx0XHRcdFx0Y2FzZSAnVEVYQ09PUkQnOlxyXG5cdFx0XHRcdFx0dGV4dHVyZV9zZXRzLnB1c2goIGlucHV0LnNldCApO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoIHZhciBwQ291bnQgPSAwOyBwQ291bnQgPCBwTGlzdC5sZW5ndGg7ICsrIHBDb3VudCApIHtcclxuXHJcblx0XHRcdHZhciBwID0gcExpc3RbIHBDb3VudCBdLCBpID0gMDtcclxuXHJcblx0XHRcdHdoaWxlICggaSA8IHAubGVuZ3RoICkge1xyXG5cclxuXHRcdFx0XHR2YXIgdnMgPSBbXTtcclxuXHRcdFx0XHR2YXIgbnMgPSBbXTtcclxuXHRcdFx0XHR2YXIgdHMgPSBudWxsO1xyXG5cdFx0XHRcdHZhciBjcyA9IFtdO1xyXG5cclxuXHRcdFx0XHRpZiAoIHByaW1pdGl2ZS52Y291bnQgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmNvdW50ID0gcHJpbWl0aXZlLnZjb3VudC5sZW5ndGggPyBwcmltaXRpdmUudmNvdW50WyB2Y0luZGV4ICsrIF0gOiBwcmltaXRpdmUudmNvdW50O1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdHZjb3VudCA9IHAubGVuZ3RoIC8gbWF4T2Zmc2V0O1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cclxuXHRcdFx0XHRmb3IgKCBqID0gMDsgaiA8IHZjb3VudDsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0XHRmb3IgKCBrID0gMDsgayA8IGlucHV0cy5sZW5ndGg7IGsgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRpbnB1dCA9IGlucHV0c1sgayBdO1xyXG5cdFx0XHRcdFx0XHRzb3VyY2UgPSBzb3VyY2VzWyBpbnB1dC5zb3VyY2UgXTtcclxuXHJcblx0XHRcdFx0XHRcdGluZGV4ID0gcFsgaSArICggaiAqIG1heE9mZnNldCApICsgaW5wdXQub2Zmc2V0IF07XHJcblx0XHRcdFx0XHRcdG51bVBhcmFtcyA9IHNvdXJjZS5hY2Nlc3Nvci5wYXJhbXMubGVuZ3RoO1xyXG5cdFx0XHRcdFx0XHRpZHgzMiA9IGluZGV4ICogbnVtUGFyYW1zO1xyXG5cclxuXHRcdFx0XHRcdFx0c3dpdGNoICggaW5wdXQuc2VtYW50aWMgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGNhc2UgJ1ZFUlRFWCc6XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0dnMucHVzaCggaW5kZXggKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRcdFx0Y2FzZSAnTk9STUFMJzpcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRucy5wdXNoKCBnZXRDb252ZXJ0ZWRWZWMzKCBzb3VyY2UuZGF0YSwgaWR4MzIgKSApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjYXNlICdURVhDT09SRCc6XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0dHMgPSB0cyB8fCB7IH07XHJcblx0XHRcdFx0XHRcdFx0XHRpZiAoIHRzWyBpbnB1dC5zZXQgXSA9PT0gdW5kZWZpbmVkICkgdHNbIGlucHV0LnNldCBdID0gW107XHJcblx0XHRcdFx0XHRcdFx0XHQvLyBpbnZlcnQgdGhlIFZcclxuXHRcdFx0XHRcdFx0XHRcdHRzWyBpbnB1dC5zZXQgXS5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMiggc291cmNlLmRhdGFbIGlkeDMyIF0sIHNvdXJjZS5kYXRhWyBpZHgzMiArIDEgXSApICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGNhc2UgJ0NPTE9SJzpcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRjcy5wdXNoKCBuZXcgVEhSRUUuQ29sb3IoKS5zZXRSR0IoIHNvdXJjZS5kYXRhWyBpZHgzMiBdLCBzb3VyY2UuZGF0YVsgaWR4MzIgKyAxIF0sIHNvdXJjZS5kYXRhWyBpZHgzMiArIDIgXSApICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGRlZmF1bHQ6XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggbnMubGVuZ3RoID09PSAwICkge1xyXG5cclxuXHRcdFx0XHRcdC8vIGNoZWNrIHRoZSB2ZXJ0aWNlcyBpbnB1dHNcclxuXHRcdFx0XHRcdGlucHV0ID0gdGhpcy52ZXJ0aWNlcy5pbnB1dC5OT1JNQUw7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBpbnB1dCApIHtcclxuXHJcblx0XHRcdFx0XHRcdHNvdXJjZSA9IHNvdXJjZXNbIGlucHV0LnNvdXJjZSBdO1xyXG5cdFx0XHRcdFx0XHRudW1QYXJhbXMgPSBzb3VyY2UuYWNjZXNzb3IucGFyYW1zLmxlbmd0aDtcclxuXHJcblx0XHRcdFx0XHRcdGZvciAoIHZhciBuZHggPSAwLCBsZW4gPSB2cy5sZW5ndGg7IG5keCA8IGxlbjsgbmR4ICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRucy5wdXNoKCBnZXRDb252ZXJ0ZWRWZWMzKCBzb3VyY2UuZGF0YSwgdnNbIG5keCBdICogbnVtUGFyYW1zICkgKTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0Z2VvbS5jYWxjTm9ybWFscyA9IHRydWU7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggIXRzICkge1xyXG5cclxuXHRcdFx0XHRcdHRzID0geyB9O1xyXG5cdFx0XHRcdFx0Ly8gY2hlY2sgdGhlIHZlcnRpY2VzIGlucHV0c1xyXG5cdFx0XHRcdFx0aW5wdXQgPSB0aGlzLnZlcnRpY2VzLmlucHV0LlRFWENPT1JEO1xyXG5cclxuXHRcdFx0XHRcdGlmICggaW5wdXQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR0ZXh0dXJlX3NldHMucHVzaCggaW5wdXQuc2V0ICk7XHJcblx0XHRcdFx0XHRcdHNvdXJjZSA9IHNvdXJjZXNbIGlucHV0LnNvdXJjZSBdO1xyXG5cdFx0XHRcdFx0XHRudW1QYXJhbXMgPSBzb3VyY2UuYWNjZXNzb3IucGFyYW1zLmxlbmd0aDtcclxuXHJcblx0XHRcdFx0XHRcdGZvciAoIHZhciBuZHggPSAwLCBsZW4gPSB2cy5sZW5ndGg7IG5keCA8IGxlbjsgbmR4ICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRpZHgzMiA9IHZzWyBuZHggXSAqIG51bVBhcmFtcztcclxuXHRcdFx0XHRcdFx0XHRpZiAoIHRzWyBpbnB1dC5zZXQgXSA9PT0gdW5kZWZpbmVkICkgdHNbIGlucHV0LnNldCBdID0gWyBdO1xyXG5cdFx0XHRcdFx0XHRcdC8vIGludmVydCB0aGUgVlxyXG5cdFx0XHRcdFx0XHRcdHRzWyBpbnB1dC5zZXQgXS5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMiggc291cmNlLmRhdGFbIGlkeDMyIF0sIDEuMCAtIHNvdXJjZS5kYXRhWyBpZHgzMiArIDEgXSApICk7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggY3MubGVuZ3RoID09PSAwICkge1xyXG5cclxuXHRcdFx0XHRcdC8vIGNoZWNrIHRoZSB2ZXJ0aWNlcyBpbnB1dHNcclxuXHRcdFx0XHRcdGlucHV0ID0gdGhpcy52ZXJ0aWNlcy5pbnB1dC5DT0xPUjtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGlucHV0ICkge1xyXG5cclxuXHRcdFx0XHRcdFx0c291cmNlID0gc291cmNlc1sgaW5wdXQuc291cmNlIF07XHJcblx0XHRcdFx0XHRcdG51bVBhcmFtcyA9IHNvdXJjZS5hY2Nlc3Nvci5wYXJhbXMubGVuZ3RoO1xyXG5cclxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIG5keCA9IDAsIGxlbiA9IHZzLmxlbmd0aDsgbmR4IDwgbGVuOyBuZHggKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGlkeDMyID0gdnNbIG5keCBdICogbnVtUGFyYW1zO1xyXG5cdFx0XHRcdFx0XHRcdGNzLnB1c2goIG5ldyBUSFJFRS5Db2xvcigpLnNldFJHQiggc291cmNlLmRhdGFbIGlkeDMyIF0sIHNvdXJjZS5kYXRhWyBpZHgzMiArIDEgXSwgc291cmNlLmRhdGFbIGlkeDMyICsgMiBdICkgKTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dmFyIGZhY2UgPSBudWxsLCBmYWNlcyA9IFtdLCB1diwgdXZBcnI7XHJcblxyXG5cdFx0XHRcdGlmICggdmNvdW50ID09PSAzICkge1xyXG5cclxuXHRcdFx0XHRcdGZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggdnNbMF0sIHZzWzFdLCB2c1syXSwgbnMsIGNzLmxlbmd0aCA/IGNzIDogbmV3IFRIUkVFLkNvbG9yKCkgKSApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2UgaWYgKCB2Y291bnQgPT09IDQgKSB7XHJcblxyXG5cdFx0XHRcdFx0ZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCB2c1swXSwgdnNbMV0sIHZzWzNdLCBucy5sZW5ndGggPyBbIG5zWzBdLmNsb25lKCksIG5zWzFdLmNsb25lKCksIG5zWzNdLmNsb25lKCkgXSA6IFtdLCBjcy5sZW5ndGggPyBbIGNzWzBdLCBjc1sxXSwgY3NbM10gXSA6IG5ldyBUSFJFRS5Db2xvcigpICkgKTtcclxuXHJcblx0XHRcdFx0XHRmYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIHZzWzFdLCB2c1syXSwgdnNbM10sIG5zLmxlbmd0aCA/IFsgbnNbMV0uY2xvbmUoKSwgbnNbMl0uY2xvbmUoKSwgbnNbM10uY2xvbmUoKSBdIDogW10sIGNzLmxlbmd0aCA/IFsgY3NbMV0sIGNzWzJdLCBjc1szXSBdIDogbmV3IFRIUkVFLkNvbG9yKCkgKSApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2UgaWYgKCB2Y291bnQgPiA0ICYmIG9wdGlvbnMuc3ViZGl2aWRlRmFjZXMgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIGNsciA9IGNzLmxlbmd0aCA/IGNzIDogbmV3IFRIUkVFLkNvbG9yKCksXHJcblx0XHRcdFx0XHRcdHZlYzEsIHZlYzIsIHZlYzMsIHYxLCB2Miwgbm9ybTtcclxuXHJcblx0XHRcdFx0XHQvLyBzdWJkaXZpZGUgaW50byBtdWx0aXBsZSBGYWNlM3NcclxuXHJcblx0XHRcdFx0XHRmb3IgKCBrID0gMTsgayA8IHZjb3VudCAtIDE7ICkge1xyXG5cclxuXHRcdFx0XHRcdFx0ZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCB2c1swXSwgdnNba10sIHZzW2sgKyAxXSwgbnMubGVuZ3RoID8gWyBuc1swXS5jbG9uZSgpLCBuc1trICsrXS5jbG9uZSgpLCBuc1trXS5jbG9uZSgpIF0gOiBbXSwgY2xyICkgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCBmYWNlcy5sZW5ndGggKSB7XHJcblxyXG5cdFx0XHRcdFx0Zm9yICggdmFyIG5keCA9IDAsIGxlbiA9IGZhY2VzLmxlbmd0aDsgbmR4IDwgbGVuOyBuZHggKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRmYWNlID0gZmFjZXNbbmR4XTtcclxuXHRcdFx0XHRcdFx0ZmFjZS5kYWVNYXRlcmlhbCA9IHByaW1pdGl2ZS5tYXRlcmlhbDtcclxuXHRcdFx0XHRcdFx0Z2VvbS5mYWNlcy5wdXNoKCBmYWNlICk7XHJcblxyXG5cdFx0XHRcdFx0XHRmb3IgKCBrID0gMDsgayA8IHRleHR1cmVfc2V0cy5sZW5ndGg7IGsgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHV2ID0gdHNbIHRleHR1cmVfc2V0c1trXSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRpZiAoIHZjb3VudCA+IDQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0Ly8gR3JhYiB0aGUgcmlnaHQgVVZzIGZvciB0aGUgdmVydGljZXMgaW4gdGhpcyBmYWNlXHJcblx0XHRcdFx0XHRcdFx0XHR1dkFyciA9IFsgdXZbMF0sIHV2W25keCArIDFdLCB1dltuZHggKyAyXSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCB2Y291bnQgPT09IDQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBuZHggPT09IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XHR1dkFyciA9IFsgdXZbMF0sIHV2WzFdLCB1dlszXSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XHR1dkFyciA9IFsgdXZbMV0uY2xvbmUoKSwgdXZbMl0sIHV2WzNdLmNsb25lKCkgXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0dXZBcnIgPSBbIHV2WzBdLCB1dlsxXSwgdXZbMl0gXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0XHRpZiAoIGdlb20uZmFjZVZlcnRleFV2c1trXSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdGdlb20uZmFjZVZlcnRleFV2c1trXSA9IFtdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRcdGdlb20uZmFjZVZlcnRleFV2c1trXS5wdXNoKCB1dkFyciApO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRjb25zb2xlLmxvZyggJ2Ryb3BwZWQgZmFjZSB3aXRoIHZjb3VudCAnICsgdmNvdW50ICsgJyBmb3IgZ2VvbWV0cnkgd2l0aCBpZDogJyArIGdlb20uaWQgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpICs9IG1heE9mZnNldCAqIHZjb3VudDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIFBvbHlnb25zICgpIHtcclxuXHJcblx0XHR0aGlzLm1hdGVyaWFsID0gXCJcIjtcclxuXHRcdHRoaXMuY291bnQgPSAwO1xyXG5cdFx0dGhpcy5pbnB1dHMgPSBbXTtcclxuXHRcdHRoaXMudmNvdW50ID0gbnVsbDtcclxuXHRcdHRoaXMucCA9IFtdO1xyXG5cdFx0dGhpcy5nZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xyXG5cclxuXHR9XHJcblxyXG5cdFBvbHlnb25zLnByb3RvdHlwZS5zZXRWZXJ0aWNlcyA9IGZ1bmN0aW9uICggdmVydGljZXMgKSB7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5pbnB1dHMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0aWYgKCB0aGlzLmlucHV0c1sgaSBdLnNvdXJjZSA9PT0gdmVydGljZXMuaWQgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuaW5wdXRzWyBpIF0uc291cmNlID0gdmVydGljZXMuaW5wdXRbICdQT1NJVElPTicgXS5zb3VyY2U7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHRQb2x5Z29ucy5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoIGVsZW1lbnQgKSB7XHJcblxyXG5cdFx0dGhpcy5tYXRlcmlhbCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCAnbWF0ZXJpYWwnICk7XHJcblx0XHR0aGlzLmNvdW50ID0gX2F0dHJfYXNfaW50KCBlbGVtZW50LCAnY291bnQnLCAwICk7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciBjaGlsZCA9IGVsZW1lbnQuY2hpbGROb2Rlc1sgaSBdO1xyXG5cclxuXHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ2lucHV0JzpcclxuXHJcblx0XHRcdFx0XHR0aGlzLmlucHV0cy5wdXNoKCAoIG5ldyBJbnB1dCgpICkucGFyc2UoIGVsZW1lbnQuY2hpbGROb2Rlc1sgaSBdICkgKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICd2Y291bnQnOlxyXG5cclxuXHRcdFx0XHRcdHRoaXMudmNvdW50ID0gX2ludHMoIGNoaWxkLnRleHRDb250ZW50ICk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAncCc6XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5wLnB1c2goIF9pbnRzKCBjaGlsZC50ZXh0Q29udGVudCApICk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAncGgnOlxyXG5cclxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ3BvbHlnb24gaG9sZXMgbm90IHlldCBzdXBwb3J0ZWQhJyApO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGRlZmF1bHQ6XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIFBvbHlsaXN0ICgpIHtcclxuXHJcblx0XHRQb2x5Z29ucy5jYWxsKCB0aGlzICk7XHJcblxyXG5cdFx0dGhpcy52Y291bnQgPSBbXTtcclxuXHJcblx0fVxyXG5cclxuXHRQb2x5bGlzdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBQb2x5Z29ucy5wcm90b3R5cGUgKTtcclxuXHRQb2x5bGlzdC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQb2x5bGlzdDtcclxuXHJcblx0ZnVuY3Rpb24gTGluZVN0cmlwcygpIHtcclxuXHJcblx0XHRQb2x5Z29ucy5jYWxsKCB0aGlzICk7XHJcblxyXG5cdFx0dGhpcy52Y291bnQgPSAxO1xyXG5cclxuXHR9XHJcblxyXG5cdExpbmVTdHJpcHMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggUG9seWdvbnMucHJvdG90eXBlICk7XHJcblx0TGluZVN0cmlwcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMaW5lU3RyaXBzO1xyXG5cclxuXHRmdW5jdGlvbiBUcmlhbmdsZXMgKCkge1xyXG5cclxuXHRcdFBvbHlnb25zLmNhbGwoIHRoaXMgKTtcclxuXHJcblx0XHR0aGlzLnZjb3VudCA9IDM7XHJcblxyXG5cdH1cclxuXHJcblx0VHJpYW5nbGVzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFBvbHlnb25zLnByb3RvdHlwZSApO1xyXG5cdFRyaWFuZ2xlcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUcmlhbmdsZXM7XHJcblxyXG5cdGZ1bmN0aW9uIEFjY2Vzc29yKCkge1xyXG5cclxuXHRcdHRoaXMuc291cmNlID0gXCJcIjtcclxuXHRcdHRoaXMuY291bnQgPSAwO1xyXG5cdFx0dGhpcy5zdHJpZGUgPSAwO1xyXG5cdFx0dGhpcy5wYXJhbXMgPSBbXTtcclxuXHJcblx0fVxyXG5cclxuXHRBY2Nlc3Nvci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoIGVsZW1lbnQgKSB7XHJcblxyXG5cdFx0dGhpcy5wYXJhbXMgPSBbXTtcclxuXHRcdHRoaXMuc291cmNlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoICdzb3VyY2UnICk7XHJcblx0XHR0aGlzLmNvdW50ID0gX2F0dHJfYXNfaW50KCBlbGVtZW50LCAnY291bnQnLCAwICk7XHJcblx0XHR0aGlzLnN0cmlkZSA9IF9hdHRyX2FzX2ludCggZWxlbWVudCwgJ3N0cmlkZScsIDAgKTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBlbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIGNoaWxkID0gZWxlbWVudC5jaGlsZE5vZGVzWyBpIF07XHJcblxyXG5cdFx0XHRpZiAoIGNoaWxkLm5vZGVOYW1lID09PSAncGFyYW0nICkge1xyXG5cclxuXHRcdFx0XHR2YXIgcGFyYW0gPSB7fTtcclxuXHRcdFx0XHRwYXJhbVsgJ25hbWUnIF0gPSBjaGlsZC5nZXRBdHRyaWJ1dGUoICduYW1lJyApO1xyXG5cdFx0XHRcdHBhcmFtWyAndHlwZScgXSA9IGNoaWxkLmdldEF0dHJpYnV0ZSggJ3R5cGUnICk7XHJcblx0XHRcdFx0dGhpcy5wYXJhbXMucHVzaCggcGFyYW0gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIFZlcnRpY2VzKCkge1xyXG5cclxuXHRcdHRoaXMuaW5wdXQgPSB7fTtcclxuXHJcblx0fVxyXG5cclxuXHRWZXJ0aWNlcy5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoIGVsZW1lbnQgKSB7XHJcblxyXG5cdFx0dGhpcy5pZCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdpZCcpO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGVsZW1lbnQuY2hpbGROb2Rlc1tpXS5ub2RlTmFtZSA9PT0gJ2lucHV0JyApIHtcclxuXHJcblx0XHRcdFx0dmFyIGlucHV0ID0gKCBuZXcgSW5wdXQoKSApLnBhcnNlKCBlbGVtZW50LmNoaWxkTm9kZXNbIGkgXSApO1xyXG5cdFx0XHRcdHRoaXMuaW5wdXRbIGlucHV0LnNlbWFudGljIF0gPSBpbnB1dDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIElucHV0ICgpIHtcclxuXHJcblx0XHR0aGlzLnNlbWFudGljID0gXCJcIjtcclxuXHRcdHRoaXMub2Zmc2V0ID0gMDtcclxuXHRcdHRoaXMuc291cmNlID0gXCJcIjtcclxuXHRcdHRoaXMuc2V0ID0gMDtcclxuXHJcblx0fVxyXG5cclxuXHRJbnB1dC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoIGVsZW1lbnQgKSB7XHJcblxyXG5cdFx0dGhpcy5zZW1hbnRpYyA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdzZW1hbnRpYycpO1xyXG5cdFx0dGhpcy5zb3VyY2UgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnc291cmNlJykucmVwbGFjZSgvXiMvLCAnJyk7XHJcblx0XHR0aGlzLnNldCA9IF9hdHRyX2FzX2ludChlbGVtZW50LCAnc2V0JywgLTEpO1xyXG5cdFx0dGhpcy5vZmZzZXQgPSBfYXR0cl9hc19pbnQoZWxlbWVudCwgJ29mZnNldCcsIDApO1xyXG5cclxuXHRcdGlmICggdGhpcy5zZW1hbnRpYyA9PT0gJ1RFWENPT1JEJyAmJiB0aGlzLnNldCA8IDAgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnNldCA9IDA7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBTb3VyY2UgKCBpZCApIHtcclxuXHJcblx0XHR0aGlzLmlkID0gaWQ7XHJcblx0XHR0aGlzLnR5cGUgPSBudWxsO1xyXG5cclxuXHR9XHJcblxyXG5cdFNvdXJjZS5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoIGVsZW1lbnQgKSB7XHJcblxyXG5cdFx0dGhpcy5pZCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCAnaWQnICk7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciBjaGlsZCA9IGVsZW1lbnQuY2hpbGROb2Rlc1tpXTtcclxuXHJcblx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xyXG5cclxuXHRcdFx0XHRjYXNlICdib29sX2FycmF5JzpcclxuXHJcblx0XHRcdFx0XHR0aGlzLmRhdGEgPSBfYm9vbHMoIGNoaWxkLnRleHRDb250ZW50ICk7XHJcblx0XHRcdFx0XHR0aGlzLnR5cGUgPSBjaGlsZC5ub2RlTmFtZTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICdmbG9hdF9hcnJheSc6XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5kYXRhID0gX2Zsb2F0cyggY2hpbGQudGV4dENvbnRlbnQgKTtcclxuXHRcdFx0XHRcdHRoaXMudHlwZSA9IGNoaWxkLm5vZGVOYW1lO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ2ludF9hcnJheSc6XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5kYXRhID0gX2ludHMoIGNoaWxkLnRleHRDb250ZW50ICk7XHJcblx0XHRcdFx0XHR0aGlzLnR5cGUgPSBjaGlsZC5ub2RlTmFtZTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICdJRFJFRl9hcnJheSc6XHJcblx0XHRcdFx0Y2FzZSAnTmFtZV9hcnJheSc6XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5kYXRhID0gX3N0cmluZ3MoIGNoaWxkLnRleHRDb250ZW50ICk7XHJcblx0XHRcdFx0XHR0aGlzLnR5cGUgPSBjaGlsZC5ub2RlTmFtZTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICd0ZWNobmlxdWVfY29tbW9uJzpcclxuXHJcblx0XHRcdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCBjaGlsZC5jaGlsZE5vZGVzLmxlbmd0aDsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggY2hpbGQuY2hpbGROb2Rlc1sgaiBdLm5vZGVOYW1lID09PSAnYWNjZXNzb3InICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHR0aGlzLmFjY2Vzc29yID0gKCBuZXcgQWNjZXNzb3IoKSApLnBhcnNlKCBjaGlsZC5jaGlsZE5vZGVzWyBqIF0gKTtcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRkZWZhdWx0OlxyXG5cdFx0XHRcdFx0Ly8gY29uc29sZS5sb2coY2hpbGQubm9kZU5hbWUpO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9O1xyXG5cclxuXHRTb3VyY2UucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xyXG5cclxuXHRcdC8vZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmFjY2Vzc29yLnBhcmFtcy5sZW5ndGg7IGkrKykge1xyXG5cclxuXHRcdHZhciBwYXJhbSA9IHRoaXMuYWNjZXNzb3IucGFyYW1zWyAwIF07XHJcblxyXG5cdFx0XHQvL2NvbnNvbGUubG9nKHBhcmFtLm5hbWUgKyBcIiBcIiArIHBhcmFtLnR5cGUpO1xyXG5cclxuXHRcdHN3aXRjaCAoIHBhcmFtLnR5cGUgKSB7XHJcblxyXG5cdFx0XHRjYXNlICdJRFJFRic6XHJcblx0XHRcdGNhc2UgJ05hbWUnOiBjYXNlICduYW1lJzpcclxuXHRcdFx0Y2FzZSAnZmxvYXQnOlxyXG5cclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5kYXRhO1xyXG5cclxuXHRcdFx0Y2FzZSAnZmxvYXQ0eDQnOlxyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCB0aGlzLmRhdGEubGVuZ3RoOyBqICs9IDE2ICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciBzID0gdGhpcy5kYXRhLnNsaWNlKCBqLCBqICsgMTYgKTtcclxuXHRcdFx0XHRcdHZhciBtID0gZ2V0Q29udmVydGVkTWF0NCggcyApO1xyXG5cdFx0XHRcdFx0cmVzdWx0LnB1c2goIG0gKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0ZGVmYXVsdDpcclxuXHJcblx0XHRcdFx0Y29uc29sZS5sb2coICdDb2xsYWRhTG9hZGVyOiBTb3VyY2U6IFJlYWQgZG9udCBrbm93IGhvdyB0byByZWFkICcgKyBwYXJhbS50eXBlICsgJy4nICk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vfVxyXG5cclxuXHRcdHJldHVybiByZXN1bHQ7XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIE1hdGVyaWFsICgpIHtcclxuXHJcblx0XHR0aGlzLmlkID0gXCJcIjtcclxuXHRcdHRoaXMubmFtZSA9IFwiXCI7XHJcblx0XHR0aGlzLmluc3RhbmNlX2VmZmVjdCA9IG51bGw7XHJcblxyXG5cdH1cclxuXHJcblx0TWF0ZXJpYWwucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKCBlbGVtZW50ICkge1xyXG5cclxuXHRcdHRoaXMuaWQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSggJ2lkJyApO1xyXG5cdFx0dGhpcy5uYW1lID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoICduYW1lJyApO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGVsZW1lbnQuY2hpbGROb2Rlc1sgaSBdLm5vZGVOYW1lID09PSAnaW5zdGFuY2VfZWZmZWN0JyApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5pbnN0YW5jZV9lZmZlY3QgPSAoIG5ldyBJbnN0YW5jZUVmZmVjdCgpICkucGFyc2UoIGVsZW1lbnQuY2hpbGROb2Rlc1sgaSBdICk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBDb2xvck9yVGV4dHVyZSAoKSB7XHJcblxyXG5cdFx0dGhpcy5jb2xvciA9IG5ldyBUSFJFRS5Db2xvcigpO1xyXG5cdFx0dGhpcy5jb2xvci5zZXRSR0IoIE1hdGgucmFuZG9tKCksIE1hdGgucmFuZG9tKCksIE1hdGgucmFuZG9tKCkgKTtcclxuXHRcdHRoaXMuY29sb3IuYSA9IDEuMDtcclxuXHJcblx0XHR0aGlzLnRleHR1cmUgPSBudWxsO1xyXG5cdFx0dGhpcy50ZXhjb29yZCA9IG51bGw7XHJcblx0XHR0aGlzLnRleE9wdHMgPSBudWxsO1xyXG5cclxuXHR9XHJcblxyXG5cdENvbG9yT3JUZXh0dXJlLnByb3RvdHlwZS5pc0NvbG9yID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiAoIHRoaXMudGV4dHVyZSA9PT0gbnVsbCApO1xyXG5cclxuXHR9O1xyXG5cclxuXHRDb2xvck9yVGV4dHVyZS5wcm90b3R5cGUuaXNUZXh0dXJlID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiAoIHRoaXMudGV4dHVyZSAhPSBudWxsICk7XHJcblxyXG5cdH07XHJcblxyXG5cdENvbG9yT3JUZXh0dXJlLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uICggZWxlbWVudCApIHtcclxuXHJcblx0XHRpZiAoZWxlbWVudC5ub2RlTmFtZSA9PT0gJ3RyYW5zcGFyZW50Jykge1xyXG5cclxuXHRcdFx0dGhpcy5vcGFxdWUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnb3BhcXVlJyk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgY2hpbGQgPSBlbGVtZW50LmNoaWxkTm9kZXNbIGkgXTtcclxuXHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPSAxICkgY29udGludWU7XHJcblxyXG5cdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcclxuXHJcblx0XHRcdFx0Y2FzZSAnY29sb3InOlxyXG5cclxuXHRcdFx0XHRcdHZhciByZ2JhID0gX2Zsb2F0cyggY2hpbGQudGV4dENvbnRlbnQgKTtcclxuXHRcdFx0XHRcdHRoaXMuY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoKTtcclxuXHRcdFx0XHRcdHRoaXMuY29sb3Iuc2V0UkdCKCByZ2JhWzBdLCByZ2JhWzFdLCByZ2JhWzJdICk7XHJcblx0XHRcdFx0XHR0aGlzLmNvbG9yLmEgPSByZ2JhWzNdO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ3RleHR1cmUnOlxyXG5cclxuXHRcdFx0XHRcdHRoaXMudGV4dHVyZSA9IGNoaWxkLmdldEF0dHJpYnV0ZSgndGV4dHVyZScpO1xyXG5cdFx0XHRcdFx0dGhpcy50ZXhjb29yZCA9IGNoaWxkLmdldEF0dHJpYnV0ZSgndGV4Y29vcmQnKTtcclxuXHRcdFx0XHRcdC8vIERlZmF1bHRzIGZyb206XHJcblx0XHRcdFx0XHQvLyBodHRwczovL2NvbGxhZGEub3JnL21lZGlhd2lraS9pbmRleC5waHAvTWF5YV90ZXh0dXJlX3BsYWNlbWVudF9NQVlBX2V4dGVuc2lvblxyXG5cdFx0XHRcdFx0dGhpcy50ZXhPcHRzID0ge1xyXG5cdFx0XHRcdFx0XHRvZmZzZXRVOiAwLFxyXG5cdFx0XHRcdFx0XHRvZmZzZXRWOiAwLFxyXG5cdFx0XHRcdFx0XHRyZXBlYXRVOiAxLFxyXG5cdFx0XHRcdFx0XHRyZXBlYXRWOiAxLFxyXG5cdFx0XHRcdFx0XHR3cmFwVTogMSxcclxuXHRcdFx0XHRcdFx0d3JhcFY6IDFcclxuXHRcdFx0XHRcdH07XHJcblx0XHRcdFx0XHR0aGlzLnBhcnNlVGV4dHVyZSggY2hpbGQgKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRkZWZhdWx0OlxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9O1xyXG5cclxuXHRDb2xvck9yVGV4dHVyZS5wcm90b3R5cGUucGFyc2VUZXh0dXJlID0gZnVuY3Rpb24gKCBlbGVtZW50ICkge1xyXG5cclxuXHRcdGlmICggISBlbGVtZW50LmNoaWxkTm9kZXMgKSByZXR1cm4gdGhpcztcclxuXHJcblx0XHQvLyBUaGlzIHNob3VsZCBiZSBzdXBwb3J0ZWQgYnkgTWF5YSwgM2RzTWF4LCBhbmQgTW90aW9uQnVpbGRlclxyXG5cclxuXHRcdGlmICggZWxlbWVudC5jaGlsZE5vZGVzWzFdICYmIGVsZW1lbnQuY2hpbGROb2Rlc1sxXS5ub2RlTmFtZSA9PT0gJ2V4dHJhJyApIHtcclxuXHJcblx0XHRcdGVsZW1lbnQgPSBlbGVtZW50LmNoaWxkTm9kZXNbMV07XHJcblxyXG5cdFx0XHRpZiAoIGVsZW1lbnQuY2hpbGROb2Rlc1sxXSAmJiBlbGVtZW50LmNoaWxkTm9kZXNbMV0ubm9kZU5hbWUgPT09ICd0ZWNobmlxdWUnICkge1xyXG5cclxuXHRcdFx0XHRlbGVtZW50ID0gZWxlbWVudC5jaGlsZE5vZGVzWzFdO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBlbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIGNoaWxkID0gZWxlbWVudC5jaGlsZE5vZGVzWyBpIF07XHJcblxyXG5cdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcclxuXHJcblx0XHRcdFx0Y2FzZSAnb2Zmc2V0VSc6XHJcblx0XHRcdFx0Y2FzZSAnb2Zmc2V0Vic6XHJcblx0XHRcdFx0Y2FzZSAncmVwZWF0VSc6XHJcblx0XHRcdFx0Y2FzZSAncmVwZWF0Vic6XHJcblxyXG5cdFx0XHRcdFx0dGhpcy50ZXhPcHRzWyBjaGlsZC5ub2RlTmFtZSBdID0gcGFyc2VGbG9hdCggY2hpbGQudGV4dENvbnRlbnQgKTtcclxuXHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnd3JhcFUnOlxyXG5cdFx0XHRcdGNhc2UgJ3dyYXBWJzpcclxuXHJcblx0XHRcdFx0XHQvLyBzb21lIGRhZSBoYXZlIGEgdmFsdWUgb2YgdHJ1ZSB3aGljaCBiZWNvbWVzIE5hTiB2aWEgcGFyc2VJbnRcclxuXHJcblx0XHRcdFx0XHRpZiAoIGNoaWxkLnRleHRDb250ZW50LnRvVXBwZXJDYXNlKCkgPT09ICdUUlVFJyApIHtcclxuXHJcblx0XHRcdFx0XHRcdHRoaXMudGV4T3B0c1sgY2hpbGQubm9kZU5hbWUgXSA9IDE7XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdHRoaXMudGV4T3B0c1sgY2hpbGQubm9kZU5hbWUgXSA9IHBhcnNlSW50KCBjaGlsZC50ZXh0Q29udGVudCApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRkZWZhdWx0OlxyXG5cclxuXHRcdFx0XHRcdHRoaXMudGV4T3B0c1sgY2hpbGQubm9kZU5hbWUgXSA9IGNoaWxkLnRleHRDb250ZW50O1xyXG5cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gU2hhZGVyICggdHlwZSwgZWZmZWN0ICkge1xyXG5cclxuXHRcdHRoaXMudHlwZSA9IHR5cGU7XHJcblx0XHR0aGlzLmVmZmVjdCA9IGVmZmVjdDtcclxuXHRcdHRoaXMubWF0ZXJpYWwgPSBudWxsO1xyXG5cclxuXHR9XHJcblxyXG5cdFNoYWRlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoIGVsZW1lbnQgKSB7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciBjaGlsZCA9IGVsZW1lbnQuY2hpbGROb2Rlc1sgaSBdO1xyXG5cdFx0XHRpZiAoIGNoaWxkLm5vZGVUeXBlICE9IDEgKSBjb250aW51ZTtcclxuXHJcblx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xyXG5cclxuXHRcdFx0XHRjYXNlICdlbWlzc2lvbic6XHJcblx0XHRcdFx0Y2FzZSAnZGlmZnVzZSc6XHJcblx0XHRcdFx0Y2FzZSAnc3BlY3VsYXInOlxyXG5cdFx0XHRcdGNhc2UgJ3RyYW5zcGFyZW50JzpcclxuXHJcblx0XHRcdFx0XHR0aGlzWyBjaGlsZC5ub2RlTmFtZSBdID0gKCBuZXcgQ29sb3JPclRleHR1cmUoKSApLnBhcnNlKCBjaGlsZCApO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ2J1bXAnOlxyXG5cclxuXHRcdFx0XHRcdC8vIElmICdidW1wdHlwZScgaXMgJ2hlaWdodGZpZWxkJywgY3JlYXRlIGEgJ2J1bXAnIHByb3BlcnR5XHJcblx0XHRcdFx0XHQvLyBFbHNlIGlmICdidW1wdHlwZScgaXMgJ25vcm1hbG1hcCcsIGNyZWF0ZSBhICdub3JtYWwnIHByb3BlcnR5XHJcblx0XHRcdFx0XHQvLyAoRGVmYXVsdCB0byAnYnVtcCcpXHJcblx0XHRcdFx0XHR2YXIgYnVtcFR5cGUgPSBjaGlsZC5nZXRBdHRyaWJ1dGUoICdidW1wdHlwZScgKTtcclxuXHRcdFx0XHRcdGlmICggYnVtcFR5cGUgKSB7XHJcblx0XHRcdFx0XHRcdGlmICggYnVtcFR5cGUudG9Mb3dlckNhc2UoKSA9PT0gXCJoZWlnaHRmaWVsZFwiICkge1xyXG5cdFx0XHRcdFx0XHRcdHRoaXNbICdidW1wJyBdID0gKCBuZXcgQ29sb3JPclRleHR1cmUoKSApLnBhcnNlKCBjaGlsZCApO1xyXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBidW1wVHlwZS50b0xvd2VyQ2FzZSgpID09PSBcIm5vcm1hbG1hcFwiICkge1xyXG5cdFx0XHRcdFx0XHRcdHRoaXNbICdub3JtYWwnIF0gPSAoIG5ldyBDb2xvck9yVGV4dHVyZSgpICkucGFyc2UoIGNoaWxkICk7XHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvciggXCJTaGFkZXIucHJvdG90eXBlLnBhcnNlOiBJbnZhbGlkIHZhbHVlIGZvciBhdHRyaWJ1dGUgJ2J1bXB0eXBlJyAoXCIgKyBidW1wVHlwZSArIFwiKSAtIHZhbGlkIGJ1bXB0eXBlcyBhcmUgJ0hFSUdIVEZJRUxEJyBhbmQgJ05PUk1BTE1BUCcgLSBkZWZhdWx0aW5nIHRvICdIRUlHSFRGSUVMRCdcIiApO1xyXG5cdFx0XHRcdFx0XHRcdHRoaXNbICdidW1wJyBdID0gKCBuZXcgQ29sb3JPclRleHR1cmUoKSApLnBhcnNlKCBjaGlsZCApO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oIFwiU2hhZGVyLnByb3RvdHlwZS5wYXJzZTogQXR0cmlidXRlICdidW1wdHlwZScgbWlzc2luZyBmcm9tIGJ1bXAgbm9kZSAtIGRlZmF1bHRpbmcgdG8gJ0hFSUdIVEZJRUxEJ1wiICk7XHJcblx0XHRcdFx0XHRcdHRoaXNbICdidW1wJyBdID0gKCBuZXcgQ29sb3JPclRleHR1cmUoKSApLnBhcnNlKCBjaGlsZCApO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICdzaGluaW5lc3MnOlxyXG5cdFx0XHRcdGNhc2UgJ3JlZmxlY3Rpdml0eSc6XHJcblx0XHRcdFx0Y2FzZSAnaW5kZXhfb2ZfcmVmcmFjdGlvbic6XHJcblx0XHRcdFx0Y2FzZSAndHJhbnNwYXJlbmN5JzpcclxuXHJcblx0XHRcdFx0XHR2YXIgZiA9IGNoaWxkLnF1ZXJ5U2VsZWN0b3JBbGwoJ2Zsb2F0Jyk7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBmLmxlbmd0aCA+IDAgKVxyXG5cdFx0XHRcdFx0XHR0aGlzWyBjaGlsZC5ub2RlTmFtZSBdID0gcGFyc2VGbG9hdCggZlsgMCBdLnRleHRDb250ZW50ICk7XHJcblxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGRlZmF1bHQ6XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5jcmVhdGUoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9O1xyXG5cclxuXHRTaGFkZXIucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdHZhciBwcm9wcyA9IHt9O1xyXG5cclxuXHRcdHZhciB0cmFuc3BhcmVudCA9IGZhbHNlO1xyXG5cclxuXHRcdGlmICh0aGlzWyd0cmFuc3BhcmVuY3knXSAhPT0gdW5kZWZpbmVkICYmIHRoaXNbJ3RyYW5zcGFyZW50J10gIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHQvLyBjb252ZXJ0IHRyYW5zcGFyZW50IGNvbG9yIFJCRyB0byBhdmVyYWdlIHZhbHVlXHJcblx0XHRcdHZhciB0cmFuc3BhcmVudENvbG9yID0gdGhpc1sndHJhbnNwYXJlbnQnXTtcclxuXHRcdFx0dmFyIHRyYW5zcGFyZW5jeUxldmVsID0gKHRoaXMudHJhbnNwYXJlbnQuY29sb3IuciArIHRoaXMudHJhbnNwYXJlbnQuY29sb3IuZyArIHRoaXMudHJhbnNwYXJlbnQuY29sb3IuYikgLyAzICogdGhpcy50cmFuc3BhcmVuY3k7XHJcblxyXG5cdFx0XHRpZiAodHJhbnNwYXJlbmN5TGV2ZWwgPiAwKSB7XHJcblx0XHRcdFx0dHJhbnNwYXJlbnQgPSB0cnVlO1xyXG5cdFx0XHRcdHByb3BzWyAndHJhbnNwYXJlbnQnIF0gPSB0cnVlO1xyXG5cdFx0XHRcdHByb3BzWyAnb3BhY2l0eScgXSA9IDEgLSB0cmFuc3BhcmVuY3lMZXZlbDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGtleXMgPSB7XHJcblx0XHRcdCdkaWZmdXNlJzonbWFwJyxcclxuXHRcdFx0J2FtYmllbnQnOidsaWdodE1hcCcsXHJcblx0XHRcdCdzcGVjdWxhcic6J3NwZWN1bGFyTWFwJyxcclxuXHRcdFx0J2VtaXNzaW9uJzonZW1pc3Npb25NYXAnLFxyXG5cdFx0XHQnYnVtcCc6J2J1bXBNYXAnLFxyXG5cdFx0XHQnbm9ybWFsJzonbm9ybWFsTWFwJ1xyXG5cdFx0XHR9O1xyXG5cclxuXHRcdGZvciAoIHZhciBwcm9wIGluIHRoaXMgKSB7XHJcblxyXG5cdFx0XHRzd2l0Y2ggKCBwcm9wICkge1xyXG5cclxuXHRcdFx0XHRjYXNlICdhbWJpZW50JzpcclxuXHRcdFx0XHRjYXNlICdlbWlzc2lvbic6XHJcblx0XHRcdFx0Y2FzZSAnZGlmZnVzZSc6XHJcblx0XHRcdFx0Y2FzZSAnc3BlY3VsYXInOlxyXG5cdFx0XHRcdGNhc2UgJ2J1bXAnOlxyXG5cdFx0XHRcdGNhc2UgJ25vcm1hbCc6XHJcblxyXG5cdFx0XHRcdFx0dmFyIGNvdCA9IHRoaXNbIHByb3AgXTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGNvdCBpbnN0YW5jZW9mIENvbG9yT3JUZXh0dXJlICkge1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCBjb3QuaXNUZXh0dXJlKCkgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHZhciBzYW1wbGVySWQgPSBjb3QudGV4dHVyZTtcclxuXHRcdFx0XHRcdFx0XHR2YXIgc3VyZmFjZUlkID0gdGhpcy5lZmZlY3Quc2FtcGxlcltzYW1wbGVySWRdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRpZiAoIHN1cmZhY2VJZCAhPT0gdW5kZWZpbmVkICYmIHN1cmZhY2VJZC5zb3VyY2UgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHR2YXIgc3VyZmFjZSA9IHRoaXMuZWZmZWN0LnN1cmZhY2Vbc3VyZmFjZUlkLnNvdXJjZV07XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBzdXJmYWNlICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgaW1hZ2UgPSBpbWFnZXNbIHN1cmZhY2UuaW5pdF9mcm9tIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGltYWdlICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdFx0XHR2YXIgdXJsID0gYmFzZVVybCArIGltYWdlLmluaXRfZnJvbTtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0dmFyIHRleHR1cmU7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0dmFyIGxvYWRlciA9IFRIUkVFLkxvYWRlci5IYW5kbGVycy5nZXQoIHVybCApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGxvYWRlciAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0ZXh0dXJlID0gbG9hZGVyLmxvYWQoIHVybCApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRleHR1cmUgPSBuZXcgVEhSRUUuVGV4dHVyZSgpO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGxvYWRUZXh0dXJlSW1hZ2UoIHRleHR1cmUsIHVybCApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRleHR1cmUud3JhcFMgPSBjb3QudGV4T3B0cy53cmFwVSA/IFRIUkVFLlJlcGVhdFdyYXBwaW5nIDogVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZztcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0ZXh0dXJlLndyYXBUID0gY290LnRleE9wdHMud3JhcFYgPyBUSFJFRS5SZXBlYXRXcmFwcGluZyA6IFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmc7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGV4dHVyZS5vZmZzZXQueCA9IGNvdC50ZXhPcHRzLm9mZnNldFU7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGV4dHVyZS5vZmZzZXQueSA9IGNvdC50ZXhPcHRzLm9mZnNldFY7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGV4dHVyZS5yZXBlYXQueCA9IGNvdC50ZXhPcHRzLnJlcGVhdFU7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGV4dHVyZS5yZXBlYXQueSA9IGNvdC50ZXhPcHRzLnJlcGVhdFY7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0cHJvcHNba2V5c1twcm9wXV0gPSB0ZXh0dXJlO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBUZXh0dXJlIHdpdGggYmFrZWQgbGlnaHRpbmc/XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKHByb3AgPT09ICdlbWlzc2lvbicpIHByb3BzWydlbWlzc2l2ZSddID0gMHhmZmZmZmY7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBwcm9wID09PSAnZGlmZnVzZScgfHwgIXRyYW5zcGFyZW50ICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRpZiAoIHByb3AgPT09ICdlbWlzc2lvbicgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0cHJvcHNbICdlbWlzc2l2ZScgXSA9IGNvdC5jb2xvci5nZXRIZXgoKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRwcm9wc1sgcHJvcCBdID0gY290LmNvbG9yLmdldEhleCgpO1xyXG5cclxuXHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICdzaGluaW5lc3MnOlxyXG5cclxuXHRcdFx0XHRcdHByb3BzWyBwcm9wIF0gPSB0aGlzWyBwcm9wIF07XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAncmVmbGVjdGl2aXR5JzpcclxuXHJcblx0XHRcdFx0XHRwcm9wc1sgcHJvcCBdID0gdGhpc1sgcHJvcCBdO1xyXG5cdFx0XHRcdFx0aWYgKCBwcm9wc1sgcHJvcCBdID4gMC4wICkgcHJvcHNbJ2Vudk1hcCddID0gb3B0aW9ucy5kZWZhdWx0RW52TWFwO1xyXG5cdFx0XHRcdFx0cHJvcHNbJ2NvbWJpbmUnXSA9IFRIUkVFLk1peE9wZXJhdGlvbjtcdC8vbWl4IHJlZ3VsYXIgc2hhZGluZyB3aXRoIHJlZmxlY3RpdmUgY29tcG9uZW50XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnaW5kZXhfb2ZfcmVmcmFjdGlvbic6XHJcblxyXG5cdFx0XHRcdFx0cHJvcHNbICdyZWZyYWN0aW9uUmF0aW8nIF0gPSB0aGlzWyBwcm9wIF07IC8vVE9ETzogXCJpbmRleF9vZl9yZWZyYWN0aW9uXCIgYmVjb21lcyBcInJlZnJhY3Rpb25SYXRpb1wiIGluIHNoYWRlciwgYnV0IEknbSBub3Qgc3VyZSBpZiB0aGUgdHdvIGFyZSBhY3R1YWxseSBjb21wYXJhYmxlXHJcblx0XHRcdFx0XHRpZiAoIHRoaXNbIHByb3AgXSAhPT0gMS4wICkgcHJvcHNbJ2Vudk1hcCddID0gb3B0aW9ucy5kZWZhdWx0RW52TWFwO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ3RyYW5zcGFyZW5jeSc6XHJcblx0XHRcdFx0XHQvLyBnZXRzIGZpZ3VyZWQgb3V0IHVwIHRvcFxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGRlZmF1bHQ6XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cHJvcHNbICdzaGFkaW5nJyBdID0gcHJlZmVycmVkU2hhZGluZztcclxuXHRcdHByb3BzWyAnc2lkZScgXSA9IHRoaXMuZWZmZWN0LmRvdWJsZVNpZGVkID8gVEhSRUUuRG91YmxlU2lkZSA6IFRIUkVFLkZyb250U2lkZTtcclxuXHJcblx0XHRpZiAoIHByb3BzLmRpZmZ1c2UgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHByb3BzLmNvbG9yID0gcHJvcHMuZGlmZnVzZTtcclxuXHRcdFx0ZGVsZXRlIHByb3BzLmRpZmZ1c2U7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHN3aXRjaCAoIHRoaXMudHlwZSApIHtcclxuXHJcblx0XHRcdGNhc2UgJ2NvbnN0YW50JzpcclxuXHJcblx0XHRcdFx0aWYgKHByb3BzLmVtaXNzaXZlICE9IHVuZGVmaW5lZCkgcHJvcHMuY29sb3IgPSBwcm9wcy5lbWlzc2l2ZTtcclxuXHRcdFx0XHR0aGlzLm1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKCBwcm9wcyApO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0Y2FzZSAncGhvbmcnOlxyXG5cdFx0XHRjYXNlICdibGlubic6XHJcblxyXG5cdFx0XHRcdHRoaXMubWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwoIHByb3BzICk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRjYXNlICdsYW1iZXJ0JzpcclxuXHRcdFx0ZGVmYXVsdDpcclxuXHJcblx0XHRcdFx0dGhpcy5tYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsKCBwcm9wcyApO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5tYXRlcmlhbDtcclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gU3VyZmFjZSAoIGVmZmVjdCApIHtcclxuXHJcblx0XHR0aGlzLmVmZmVjdCA9IGVmZmVjdDtcclxuXHRcdHRoaXMuaW5pdF9mcm9tID0gbnVsbDtcclxuXHRcdHRoaXMuZm9ybWF0ID0gbnVsbDtcclxuXHJcblx0fVxyXG5cclxuXHRTdXJmYWNlLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uICggZWxlbWVudCApIHtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBlbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIGNoaWxkID0gZWxlbWVudC5jaGlsZE5vZGVzWyBpIF07XHJcblx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT0gMSApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ2luaXRfZnJvbSc6XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5pbml0X2Zyb20gPSBjaGlsZC50ZXh0Q29udGVudDtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICdmb3JtYXQnOlxyXG5cclxuXHRcdFx0XHRcdHRoaXMuZm9ybWF0ID0gY2hpbGQudGV4dENvbnRlbnQ7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0ZGVmYXVsdDpcclxuXHJcblx0XHRcdFx0XHRjb25zb2xlLmxvZyggXCJ1bmhhbmRsZWQgU3VyZmFjZSBwcm9wOiBcIiArIGNoaWxkLm5vZGVOYW1lICk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIFNhbXBsZXIyRCAoIGVmZmVjdCApIHtcclxuXHJcblx0XHR0aGlzLmVmZmVjdCA9IGVmZmVjdDtcclxuXHRcdHRoaXMuc291cmNlID0gbnVsbDtcclxuXHRcdHRoaXMud3JhcF9zID0gbnVsbDtcclxuXHRcdHRoaXMud3JhcF90ID0gbnVsbDtcclxuXHRcdHRoaXMubWluZmlsdGVyID0gbnVsbDtcclxuXHRcdHRoaXMubWFnZmlsdGVyID0gbnVsbDtcclxuXHRcdHRoaXMubWlwZmlsdGVyID0gbnVsbDtcclxuXHJcblx0fVxyXG5cclxuXHRTYW1wbGVyMkQucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKCBlbGVtZW50ICkge1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgY2hpbGQgPSBlbGVtZW50LmNoaWxkTm9kZXNbIGkgXTtcclxuXHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPSAxICkgY29udGludWU7XHJcblxyXG5cdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcclxuXHJcblx0XHRcdFx0Y2FzZSAnc291cmNlJzpcclxuXHJcblx0XHRcdFx0XHR0aGlzLnNvdXJjZSA9IGNoaWxkLnRleHRDb250ZW50O1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ21pbmZpbHRlcic6XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5taW5maWx0ZXIgPSBjaGlsZC50ZXh0Q29udGVudDtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICdtYWdmaWx0ZXInOlxyXG5cclxuXHRcdFx0XHRcdHRoaXMubWFnZmlsdGVyID0gY2hpbGQudGV4dENvbnRlbnQ7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnbWlwZmlsdGVyJzpcclxuXHJcblx0XHRcdFx0XHR0aGlzLm1pcGZpbHRlciA9IGNoaWxkLnRleHRDb250ZW50O1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ3dyYXBfcyc6XHJcblxyXG5cdFx0XHRcdFx0dGhpcy53cmFwX3MgPSBjaGlsZC50ZXh0Q29udGVudDtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICd3cmFwX3QnOlxyXG5cclxuXHRcdFx0XHRcdHRoaXMud3JhcF90ID0gY2hpbGQudGV4dENvbnRlbnQ7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0ZGVmYXVsdDpcclxuXHJcblx0XHRcdFx0XHRjb25zb2xlLmxvZyggXCJ1bmhhbmRsZWQgU2FtcGxlcjJEIHByb3A6IFwiICsgY2hpbGQubm9kZU5hbWUgKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gRWZmZWN0ICgpIHtcclxuXHJcblx0XHR0aGlzLmlkID0gXCJcIjtcclxuXHRcdHRoaXMubmFtZSA9IFwiXCI7XHJcblx0XHR0aGlzLnNoYWRlciA9IG51bGw7XHJcblx0XHR0aGlzLnN1cmZhY2UgPSB7fTtcclxuXHRcdHRoaXMuc2FtcGxlciA9IHt9O1xyXG5cclxuXHR9XHJcblxyXG5cdEVmZmVjdC5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdGlmICggdGhpcy5zaGFkZXIgPT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdEVmZmVjdC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoIGVsZW1lbnQgKSB7XHJcblxyXG5cdFx0dGhpcy5pZCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCAnaWQnICk7XHJcblx0XHR0aGlzLm5hbWUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSggJ25hbWUnICk7XHJcblxyXG5cdFx0ZXh0cmFjdERvdWJsZVNpZGVkKCB0aGlzLCBlbGVtZW50ICk7XHJcblxyXG5cdFx0dGhpcy5zaGFkZXIgPSBudWxsO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgY2hpbGQgPSBlbGVtZW50LmNoaWxkTm9kZXNbIGkgXTtcclxuXHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPSAxICkgY29udGludWU7XHJcblxyXG5cdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcclxuXHJcblx0XHRcdFx0Y2FzZSAncHJvZmlsZV9DT01NT04nOlxyXG5cclxuXHRcdFx0XHRcdHRoaXMucGFyc2VUZWNobmlxdWUoIHRoaXMucGFyc2VQcm9maWxlQ09NTU9OKCBjaGlsZCApICk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0ZGVmYXVsdDpcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fTtcclxuXHJcblx0RWZmZWN0LnByb3RvdHlwZS5wYXJzZU5ld3BhcmFtID0gZnVuY3Rpb24gKCBlbGVtZW50ICkge1xyXG5cclxuXHRcdHZhciBzaWQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSggJ3NpZCcgKTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBlbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIGNoaWxkID0gZWxlbWVudC5jaGlsZE5vZGVzWyBpIF07XHJcblx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT0gMSApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ3N1cmZhY2UnOlxyXG5cclxuXHRcdFx0XHRcdHRoaXMuc3VyZmFjZVtzaWRdID0gKCBuZXcgU3VyZmFjZSggdGhpcyApICkucGFyc2UoIGNoaWxkICk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnc2FtcGxlcjJEJzpcclxuXHJcblx0XHRcdFx0XHR0aGlzLnNhbXBsZXJbc2lkXSA9ICggbmV3IFNhbXBsZXIyRCggdGhpcyApICkucGFyc2UoIGNoaWxkICk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnZXh0cmEnOlxyXG5cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRkZWZhdWx0OlxyXG5cclxuXHRcdFx0XHRcdGNvbnNvbGUubG9nKCBjaGlsZC5ub2RlTmFtZSApO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHRFZmZlY3QucHJvdG90eXBlLnBhcnNlUHJvZmlsZUNPTU1PTiA9IGZ1bmN0aW9uICggZWxlbWVudCApIHtcclxuXHJcblx0XHR2YXIgdGVjaG5pcXVlO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgY2hpbGQgPSBlbGVtZW50LmNoaWxkTm9kZXNbIGkgXTtcclxuXHJcblx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT0gMSApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ3Byb2ZpbGVfQ09NTU9OJzpcclxuXHJcblx0XHRcdFx0XHR0aGlzLnBhcnNlUHJvZmlsZUNPTU1PTiggY2hpbGQgKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICd0ZWNobmlxdWUnOlxyXG5cclxuXHRcdFx0XHRcdHRlY2huaXF1ZSA9IGNoaWxkO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ25ld3BhcmFtJzpcclxuXHJcblx0XHRcdFx0XHR0aGlzLnBhcnNlTmV3cGFyYW0oIGNoaWxkICk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnaW1hZ2UnOlxyXG5cclxuXHRcdFx0XHRcdHZhciBfaW1hZ2UgPSAoIG5ldyBfSW1hZ2UoKSApLnBhcnNlKCBjaGlsZCApO1xyXG5cdFx0XHRcdFx0aW1hZ2VzWyBfaW1hZ2UuaWQgXSA9IF9pbWFnZTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICdleHRyYSc6XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0ZGVmYXVsdDpcclxuXHJcblx0XHRcdFx0XHRjb25zb2xlLmxvZyggY2hpbGQubm9kZU5hbWUgKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGVjaG5pcXVlO1xyXG5cclxuXHR9O1xyXG5cclxuXHRFZmZlY3QucHJvdG90eXBlLnBhcnNlVGVjaG5pcXVlID0gZnVuY3Rpb24gKCBlbGVtZW50ICkge1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgY2hpbGQgPSBlbGVtZW50LmNoaWxkTm9kZXNbaV07XHJcblx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT0gMSApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ2NvbnN0YW50JzpcclxuXHRcdFx0XHRjYXNlICdsYW1iZXJ0JzpcclxuXHRcdFx0XHRjYXNlICdibGlubic6XHJcblx0XHRcdFx0Y2FzZSAncGhvbmcnOlxyXG5cclxuXHRcdFx0XHRcdHRoaXMuc2hhZGVyID0gKCBuZXcgU2hhZGVyKCBjaGlsZC5ub2RlTmFtZSwgdGhpcyApICkucGFyc2UoIGNoaWxkICk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRjYXNlICdleHRyYSc6XHJcblx0XHRcdFx0XHR0aGlzLnBhcnNlRXh0cmEoY2hpbGQpO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0ZGVmYXVsdDpcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0RWZmZWN0LnByb3RvdHlwZS5wYXJzZUV4dHJhID0gZnVuY3Rpb24gKCBlbGVtZW50ICkge1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgY2hpbGQgPSBlbGVtZW50LmNoaWxkTm9kZXNbaV07XHJcblx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT0gMSApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ3RlY2huaXF1ZSc6XHJcblx0XHRcdFx0XHR0aGlzLnBhcnNlRXh0cmFUZWNobmlxdWUoIGNoaWxkICk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRkZWZhdWx0OlxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHRFZmZlY3QucHJvdG90eXBlLnBhcnNlRXh0cmFUZWNobmlxdWUgPSBmdW5jdGlvbiAoIGVsZW1lbnQgKSB7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciBjaGlsZCA9IGVsZW1lbnQuY2hpbGROb2Rlc1tpXTtcclxuXHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPSAxICkgY29udGludWU7XHJcblxyXG5cdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcclxuXHJcblx0XHRcdFx0Y2FzZSAnYnVtcCc6XHJcblx0XHRcdFx0XHR0aGlzLnNoYWRlci5wYXJzZSggZWxlbWVudCApO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0ZGVmYXVsdDpcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gSW5zdGFuY2VFZmZlY3QgKCkge1xyXG5cclxuXHRcdHRoaXMudXJsID0gXCJcIjtcclxuXHJcblx0fVxyXG5cclxuXHRJbnN0YW5jZUVmZmVjdC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoIGVsZW1lbnQgKSB7XHJcblxyXG5cdFx0dGhpcy51cmwgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSggJ3VybCcgKS5yZXBsYWNlKCAvXiMvLCAnJyApO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIEFuaW1hdGlvbigpIHtcclxuXHJcblx0XHR0aGlzLmlkID0gXCJcIjtcclxuXHRcdHRoaXMubmFtZSA9IFwiXCI7XHJcblx0XHR0aGlzLnNvdXJjZSA9IHt9O1xyXG5cdFx0dGhpcy5zYW1wbGVyID0gW107XHJcblx0XHR0aGlzLmNoYW5uZWwgPSBbXTtcclxuXHJcblx0fVxyXG5cclxuXHRBbmltYXRpb24ucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKCBlbGVtZW50ICkge1xyXG5cclxuXHRcdHRoaXMuaWQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSggJ2lkJyApO1xyXG5cdFx0dGhpcy5uYW1lID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoICduYW1lJyApO1xyXG5cdFx0dGhpcy5zb3VyY2UgPSB7fTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBlbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIGNoaWxkID0gZWxlbWVudC5jaGlsZE5vZGVzWyBpIF07XHJcblxyXG5cdFx0XHRpZiAoIGNoaWxkLm5vZGVUeXBlICE9IDEgKSBjb250aW51ZTtcclxuXHJcblx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xyXG5cclxuXHRcdFx0XHRjYXNlICdhbmltYXRpb24nOlxyXG5cclxuXHRcdFx0XHRcdHZhciBhbmltID0gKCBuZXcgQW5pbWF0aW9uKCkgKS5wYXJzZSggY2hpbGQgKTtcclxuXHJcblx0XHRcdFx0XHRmb3IgKCB2YXIgc3JjIGluIGFuaW0uc291cmNlICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dGhpcy5zb3VyY2VbIHNyYyBdID0gYW5pbS5zb3VyY2VbIHNyYyBdO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCBhbmltLmNoYW5uZWwubGVuZ3RoOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dGhpcy5jaGFubmVsLnB1c2goIGFuaW0uY2hhbm5lbFsgaiBdICk7XHJcblx0XHRcdFx0XHRcdHRoaXMuc2FtcGxlci5wdXNoKCBhbmltLnNhbXBsZXJbIGogXSApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnc291cmNlJzpcclxuXHJcblx0XHRcdFx0XHR2YXIgc3JjID0gKCBuZXcgU291cmNlKCkgKS5wYXJzZSggY2hpbGQgKTtcclxuXHRcdFx0XHRcdHRoaXMuc291cmNlWyBzcmMuaWQgXSA9IHNyYztcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICdzYW1wbGVyJzpcclxuXHJcblx0XHRcdFx0XHR0aGlzLnNhbXBsZXIucHVzaCggKCBuZXcgU2FtcGxlciggdGhpcyApICkucGFyc2UoIGNoaWxkICkgKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICdjaGFubmVsJzpcclxuXHJcblx0XHRcdFx0XHR0aGlzLmNoYW5uZWwucHVzaCggKCBuZXcgQ2hhbm5lbCggdGhpcyApICkucGFyc2UoIGNoaWxkICkgKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRkZWZhdWx0OlxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBDaGFubmVsKCBhbmltYXRpb24gKSB7XHJcblxyXG5cdFx0dGhpcy5hbmltYXRpb24gPSBhbmltYXRpb247XHJcblx0XHR0aGlzLnNvdXJjZSA9IFwiXCI7XHJcblx0XHR0aGlzLnRhcmdldCA9IFwiXCI7XHJcblx0XHR0aGlzLmZ1bGxTaWQgPSBudWxsO1xyXG5cdFx0dGhpcy5zaWQgPSBudWxsO1xyXG5cdFx0dGhpcy5kb3RTeW50YXggPSBudWxsO1xyXG5cdFx0dGhpcy5hcnJTeW50YXggPSBudWxsO1xyXG5cdFx0dGhpcy5hcnJJbmRpY2VzID0gbnVsbDtcclxuXHRcdHRoaXMubWVtYmVyID0gbnVsbDtcclxuXHJcblx0fVxyXG5cclxuXHRDaGFubmVsLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uICggZWxlbWVudCApIHtcclxuXHJcblx0XHR0aGlzLnNvdXJjZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCAnc291cmNlJyApLnJlcGxhY2UoIC9eIy8sICcnICk7XHJcblx0XHR0aGlzLnRhcmdldCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCAndGFyZ2V0JyApO1xyXG5cclxuXHRcdHZhciBwYXJ0cyA9IHRoaXMudGFyZ2V0LnNwbGl0KCAnLycgKTtcclxuXHJcblx0XHR2YXIgaWQgPSBwYXJ0cy5zaGlmdCgpO1xyXG5cdFx0dmFyIHNpZCA9IHBhcnRzLnNoaWZ0KCk7XHJcblxyXG5cdFx0dmFyIGRvdFN5bnRheCA9ICggc2lkLmluZGV4T2YoXCIuXCIpID49IDAgKTtcclxuXHRcdHZhciBhcnJTeW50YXggPSAoIHNpZC5pbmRleE9mKFwiKFwiKSA+PSAwICk7XHJcblxyXG5cdFx0aWYgKCBkb3RTeW50YXggKSB7XHJcblxyXG5cdFx0XHRwYXJ0cyA9IHNpZC5zcGxpdChcIi5cIik7XHJcblx0XHRcdHRoaXMuc2lkID0gcGFydHMuc2hpZnQoKTtcclxuXHRcdFx0dGhpcy5tZW1iZXIgPSBwYXJ0cy5zaGlmdCgpO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIGFyclN5bnRheCApIHtcclxuXHJcblx0XHRcdHZhciBhcnJJbmRpY2VzID0gc2lkLnNwbGl0KFwiKFwiKTtcclxuXHRcdFx0dGhpcy5zaWQgPSBhcnJJbmRpY2VzLnNoaWZ0KCk7XHJcblxyXG5cdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGFyckluZGljZXMubGVuZ3RoOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHRhcnJJbmRpY2VzW2pdID0gcGFyc2VJbnQoIGFyckluZGljZXNbal0ucmVwbGFjZSgvXFwpLywgJycpICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmFyckluZGljZXMgPSBhcnJJbmRpY2VzO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHR0aGlzLnNpZCA9IHNpZDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5mdWxsU2lkID0gc2lkO1xyXG5cdFx0dGhpcy5kb3RTeW50YXggPSBkb3RTeW50YXg7XHJcblx0XHR0aGlzLmFyclN5bnRheCA9IGFyclN5bnRheDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gU2FtcGxlciAoIGFuaW1hdGlvbiApIHtcclxuXHJcblx0XHR0aGlzLmlkID0gXCJcIjtcclxuXHRcdHRoaXMuYW5pbWF0aW9uID0gYW5pbWF0aW9uO1xyXG5cdFx0dGhpcy5pbnB1dHMgPSBbXTtcclxuXHRcdHRoaXMuaW5wdXQgPSBudWxsO1xyXG5cdFx0dGhpcy5vdXRwdXQgPSBudWxsO1xyXG5cdFx0dGhpcy5zdHJpZGVPdXQgPSBudWxsO1xyXG5cdFx0dGhpcy5pbnRlcnBvbGF0aW9uID0gbnVsbDtcclxuXHRcdHRoaXMuc3RhcnRUaW1lID0gbnVsbDtcclxuXHRcdHRoaXMuZW5kVGltZSA9IG51bGw7XHJcblx0XHR0aGlzLmR1cmF0aW9uID0gMDtcclxuXHJcblx0fVxyXG5cclxuXHRTYW1wbGVyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uICggZWxlbWVudCApIHtcclxuXHJcblx0XHR0aGlzLmlkID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoICdpZCcgKTtcclxuXHRcdHRoaXMuaW5wdXRzID0gW107XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciBjaGlsZCA9IGVsZW1lbnQuY2hpbGROb2Rlc1sgaSBdO1xyXG5cdFx0XHRpZiAoIGNoaWxkLm5vZGVUeXBlICE9IDEgKSBjb250aW51ZTtcclxuXHJcblx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xyXG5cclxuXHRcdFx0XHRjYXNlICdpbnB1dCc6XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5pbnB1dHMucHVzaCggKG5ldyBJbnB1dCgpKS5wYXJzZSggY2hpbGQgKSApO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGRlZmF1bHQ6XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH07XHJcblxyXG5cdFNhbXBsZXIucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmlucHV0cy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgaW5wdXQgPSB0aGlzLmlucHV0c1sgaSBdO1xyXG5cdFx0XHR2YXIgc291cmNlID0gdGhpcy5hbmltYXRpb24uc291cmNlWyBpbnB1dC5zb3VyY2UgXTtcclxuXHJcblx0XHRcdHN3aXRjaCAoIGlucHV0LnNlbWFudGljICkge1xyXG5cclxuXHRcdFx0XHRjYXNlICdJTlBVVCc6XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5pbnB1dCA9IHNvdXJjZS5yZWFkKCk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnT1VUUFVUJzpcclxuXHJcblx0XHRcdFx0XHR0aGlzLm91dHB1dCA9IHNvdXJjZS5yZWFkKCk7XHJcblx0XHRcdFx0XHR0aGlzLnN0cmlkZU91dCA9IHNvdXJjZS5hY2Nlc3Nvci5zdHJpZGU7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnSU5URVJQT0xBVElPTic6XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5pbnRlcnBvbGF0aW9uID0gc291cmNlLnJlYWQoKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICdJTl9UQU5HRU5UJzpcclxuXHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnT1VUX1RBTkdFTlQnOlxyXG5cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRkZWZhdWx0OlxyXG5cclxuXHRcdFx0XHRcdGNvbnNvbGUubG9nKGlucHV0LnNlbWFudGljKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnN0YXJ0VGltZSA9IDA7XHJcblx0XHR0aGlzLmVuZFRpbWUgPSAwO1xyXG5cdFx0dGhpcy5kdXJhdGlvbiA9IDA7XHJcblxyXG5cdFx0aWYgKCB0aGlzLmlucHV0Lmxlbmd0aCApIHtcclxuXHJcblx0XHRcdHRoaXMuc3RhcnRUaW1lID0gMTAwMDAwMDAwO1xyXG5cdFx0XHR0aGlzLmVuZFRpbWUgPSAtMTAwMDAwMDAwO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5pbnB1dC5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuc3RhcnRUaW1lID0gTWF0aC5taW4oIHRoaXMuc3RhcnRUaW1lLCB0aGlzLmlucHV0WyBpIF0gKTtcclxuXHRcdFx0XHR0aGlzLmVuZFRpbWUgPSBNYXRoLm1heCggdGhpcy5lbmRUaW1lLCB0aGlzLmlucHV0WyBpIF0gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuZHVyYXRpb24gPSB0aGlzLmVuZFRpbWUgLSB0aGlzLnN0YXJ0VGltZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdFNhbXBsZXIucHJvdG90eXBlLmdldERhdGEgPSBmdW5jdGlvbiAoIHR5cGUsIG5keCwgbWVtYmVyICkge1xyXG5cclxuXHRcdHZhciBkYXRhO1xyXG5cclxuXHRcdGlmICggdHlwZSA9PT0gJ21hdHJpeCcgJiYgdGhpcy5zdHJpZGVPdXQgPT09IDE2ICkge1xyXG5cclxuXHRcdFx0ZGF0YSA9IHRoaXMub3V0cHV0WyBuZHggXTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCB0aGlzLnN0cmlkZU91dCA+IDEgKSB7XHJcblxyXG5cdFx0XHRkYXRhID0gW107XHJcblx0XHRcdG5keCAqPSB0aGlzLnN0cmlkZU91dDtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMuc3RyaWRlT3V0OyArKyBpICkge1xyXG5cclxuXHRcdFx0XHRkYXRhWyBpIF0gPSB0aGlzLm91dHB1dFsgbmR4ICsgaSBdO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCB0aGlzLnN0cmlkZU91dCA9PT0gMyApIHtcclxuXHJcblx0XHRcdFx0c3dpdGNoICggdHlwZSApIHtcclxuXHJcblx0XHRcdFx0XHRjYXNlICdyb3RhdGUnOlxyXG5cdFx0XHRcdFx0Y2FzZSAndHJhbnNsYXRlJzpcclxuXHJcblx0XHRcdFx0XHRcdGZpeENvb3JkcyggZGF0YSwgLTEgKTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSAnc2NhbGUnOlxyXG5cclxuXHRcdFx0XHRcdFx0Zml4Q29vcmRzKCBkYXRhLCAxICk7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCB0aGlzLnN0cmlkZU91dCA9PT0gNCAmJiB0eXBlID09PSAnbWF0cml4JyApIHtcclxuXHJcblx0XHRcdFx0Zml4Q29vcmRzKCBkYXRhLCAtMSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRkYXRhID0gdGhpcy5vdXRwdXRbIG5keCBdO1xyXG5cclxuXHRcdFx0aWYgKCBtZW1iZXIgJiYgdHlwZSA9PT0gJ3RyYW5zbGF0ZScgKSB7XHJcblx0XHRcdFx0ZGF0YSA9IGdldENvbnZlcnRlZFRyYW5zbGF0aW9uKCBtZW1iZXIsIGRhdGEgKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZGF0YTtcclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gS2V5ICggdGltZSApIHtcclxuXHJcblx0XHR0aGlzLnRhcmdldHMgPSBbXTtcclxuXHRcdHRoaXMudGltZSA9IHRpbWU7XHJcblxyXG5cdH1cclxuXHJcblx0S2V5LnByb3RvdHlwZS5hZGRUYXJnZXQgPSBmdW5jdGlvbiAoIGZ1bGxTaWQsIHRyYW5zZm9ybSwgbWVtYmVyLCBkYXRhICkge1xyXG5cclxuXHRcdHRoaXMudGFyZ2V0cy5wdXNoKCB7XHJcblx0XHRcdHNpZDogZnVsbFNpZCxcclxuXHRcdFx0bWVtYmVyOiBtZW1iZXIsXHJcblx0XHRcdHRyYW5zZm9ybTogdHJhbnNmb3JtLFxyXG5cdFx0XHRkYXRhOiBkYXRhXHJcblx0XHR9ICk7XHJcblxyXG5cdH07XHJcblxyXG5cdEtleS5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiAoIG9wdF9zaWQgKSB7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy50YXJnZXRzLmxlbmd0aDsgKysgaSApIHtcclxuXHJcblx0XHRcdHZhciB0YXJnZXQgPSB0aGlzLnRhcmdldHNbIGkgXTtcclxuXHJcblx0XHRcdGlmICggIW9wdF9zaWQgfHwgdGFyZ2V0LnNpZCA9PT0gb3B0X3NpZCApIHtcclxuXHJcblx0XHRcdFx0dGFyZ2V0LnRyYW5zZm9ybS51cGRhdGUoIHRhcmdldC5kYXRhLCB0YXJnZXQubWVtYmVyICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHRLZXkucHJvdG90eXBlLmdldFRhcmdldCA9IGZ1bmN0aW9uICggZnVsbFNpZCApIHtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLnRhcmdldHMubGVuZ3RoOyArKyBpICkge1xyXG5cclxuXHRcdFx0aWYgKCB0aGlzLnRhcmdldHNbIGkgXS5zaWQgPT09IGZ1bGxTaWQgKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiB0aGlzLnRhcmdldHNbIGkgXTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG51bGw7XHJcblxyXG5cdH07XHJcblxyXG5cdEtleS5wcm90b3R5cGUuaGFzVGFyZ2V0ID0gZnVuY3Rpb24gKCBmdWxsU2lkICkge1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMudGFyZ2V0cy5sZW5ndGg7ICsrIGkgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMudGFyZ2V0c1sgaSBdLnNpZCA9PT0gZnVsbFNpZCApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHJcblx0fTtcclxuXHJcblx0Ly8gVE9ETzogQ3VycmVudGx5IG9ubHkgZG9pbmcgbGluZWFyIGludGVycG9sYXRpb24uIFNob3VsZCBzdXBwb3J0IGZ1bGwgQ09MTEFEQSBzcGVjLlxyXG5cdEtleS5wcm90b3R5cGUuaW50ZXJwb2xhdGUgPSBmdW5jdGlvbiAoIG5leHRLZXksIHRpbWUgKSB7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy50YXJnZXRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgdGFyZ2V0ID0gdGhpcy50YXJnZXRzWyBpIF0sXHJcblx0XHRcdFx0bmV4dFRhcmdldCA9IG5leHRLZXkuZ2V0VGFyZ2V0KCB0YXJnZXQuc2lkICksXHJcblx0XHRcdFx0ZGF0YTtcclxuXHJcblx0XHRcdGlmICggdGFyZ2V0LnRyYW5zZm9ybS50eXBlICE9PSAnbWF0cml4JyAmJiBuZXh0VGFyZ2V0ICkge1xyXG5cclxuXHRcdFx0XHR2YXIgc2NhbGUgPSAoIHRpbWUgLSB0aGlzLnRpbWUgKSAvICggbmV4dEtleS50aW1lIC0gdGhpcy50aW1lICksXHJcblx0XHRcdFx0XHRuZXh0RGF0YSA9IG5leHRUYXJnZXQuZGF0YSxcclxuXHRcdFx0XHRcdHByZXZEYXRhID0gdGFyZ2V0LmRhdGE7XHJcblxyXG5cdFx0XHRcdGlmICggc2NhbGUgPCAwICkgc2NhbGUgPSAwO1xyXG5cdFx0XHRcdGlmICggc2NhbGUgPiAxICkgc2NhbGUgPSAxO1xyXG5cclxuXHRcdFx0XHRpZiAoIHByZXZEYXRhLmxlbmd0aCApIHtcclxuXHJcblx0XHRcdFx0XHRkYXRhID0gW107XHJcblxyXG5cdFx0XHRcdFx0Zm9yICggdmFyIGogPSAwOyBqIDwgcHJldkRhdGEubGVuZ3RoOyArKyBqICkge1xyXG5cclxuXHRcdFx0XHRcdFx0ZGF0YVsgaiBdID0gcHJldkRhdGFbIGogXSArICggbmV4dERhdGFbIGogXSAtIHByZXZEYXRhWyBqIF0gKSAqIHNjYWxlO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRkYXRhID0gcHJldkRhdGEgKyAoIG5leHREYXRhIC0gcHJldkRhdGEgKSAqIHNjYWxlO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRkYXRhID0gdGFyZ2V0LmRhdGE7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0YXJnZXQudHJhbnNmb3JtLnVwZGF0ZSggZGF0YSwgdGFyZ2V0Lm1lbWJlciApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0Ly8gQ2FtZXJhXHJcblx0ZnVuY3Rpb24gQ2FtZXJhKCkge1xyXG5cclxuXHRcdHRoaXMuaWQgPSBcIlwiO1xyXG5cdFx0dGhpcy5uYW1lID0gXCJcIjtcclxuXHRcdHRoaXMudGVjaG5pcXVlID0gXCJcIjtcclxuXHJcblx0fVxyXG5cclxuXHRDYW1lcmEucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKCBlbGVtZW50ICkge1xyXG5cclxuXHRcdHRoaXMuaWQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSggJ2lkJyApO1xyXG5cdFx0dGhpcy5uYW1lID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoICduYW1lJyApO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgY2hpbGQgPSBlbGVtZW50LmNoaWxkTm9kZXNbIGkgXTtcclxuXHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPSAxICkgY29udGludWU7XHJcblxyXG5cdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcclxuXHJcblx0XHRcdFx0Y2FzZSAnb3B0aWNzJzpcclxuXHJcblx0XHRcdFx0XHR0aGlzLnBhcnNlT3B0aWNzKCBjaGlsZCApO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGRlZmF1bHQ6XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH07XHJcblxyXG5cdENhbWVyYS5wcm90b3R5cGUucGFyc2VPcHRpY3MgPSBmdW5jdGlvbiAoIGVsZW1lbnQgKSB7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdGlmICggZWxlbWVudC5jaGlsZE5vZGVzWyBpIF0ubm9kZU5hbWUgPT09ICd0ZWNobmlxdWVfY29tbW9uJyApIHtcclxuXHJcblx0XHRcdFx0dmFyIHRlY2huaXF1ZSA9IGVsZW1lbnQuY2hpbGROb2Rlc1sgaSBdO1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCB0ZWNobmlxdWUuY2hpbGROb2Rlcy5sZW5ndGg7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0dGhpcy50ZWNobmlxdWUgPSB0ZWNobmlxdWUuY2hpbGROb2Rlc1sgaiBdLm5vZGVOYW1lO1xyXG5cclxuXHRcdFx0XHRcdGlmICggdGhpcy50ZWNobmlxdWUgPT09ICdwZXJzcGVjdGl2ZScgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR2YXIgcGVyc3BlY3RpdmUgPSB0ZWNobmlxdWUuY2hpbGROb2Rlc1sgaiBdO1xyXG5cclxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGsgPSAwOyBrIDwgcGVyc3BlY3RpdmUuY2hpbGROb2Rlcy5sZW5ndGg7IGsgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHZhciBwYXJhbSA9IHBlcnNwZWN0aXZlLmNoaWxkTm9kZXNbIGsgXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0c3dpdGNoICggcGFyYW0ubm9kZU5hbWUgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSAneWZvdic6XHJcblx0XHRcdFx0XHRcdFx0XHRcdHRoaXMueWZvdiA9IHBhcmFtLnRleHRDb250ZW50O1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0XHRcdGNhc2UgJ3hmb3YnOlxyXG5cdFx0XHRcdFx0XHRcdFx0XHR0aGlzLnhmb3YgPSBwYXJhbS50ZXh0Q29udGVudDtcclxuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdFx0XHRjYXNlICd6bmVhcic6XHJcblx0XHRcdFx0XHRcdFx0XHRcdHRoaXMuem5lYXIgPSBwYXJhbS50ZXh0Q29udGVudDtcclxuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdFx0XHRjYXNlICd6ZmFyJzpcclxuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy56ZmFyID0gcGFyYW0udGV4dENvbnRlbnQ7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSAnYXNwZWN0X3JhdGlvJzpcclxuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5hc3BlY3RfcmF0aW8gPSBwYXJhbS50ZXh0Q29udGVudDtcclxuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCB0aGlzLnRlY2huaXF1ZSA9PT0gJ29ydGhvZ3JhcGhpYycgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR2YXIgb3J0aG9ncmFwaGljID0gdGVjaG5pcXVlLmNoaWxkTm9kZXNbIGogXTtcclxuXHJcblx0XHRcdFx0XHRcdGZvciAoIHZhciBrID0gMDsgayA8IG9ydGhvZ3JhcGhpYy5jaGlsZE5vZGVzLmxlbmd0aDsgayArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0dmFyIHBhcmFtID0gb3J0aG9ncmFwaGljLmNoaWxkTm9kZXNbIGsgXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0c3dpdGNoICggcGFyYW0ubm9kZU5hbWUgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSAneG1hZyc6XHJcblx0XHRcdFx0XHRcdFx0XHRcdHRoaXMueG1hZyA9IHBhcmFtLnRleHRDb250ZW50O1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0XHRcdGNhc2UgJ3ltYWcnOlxyXG5cdFx0XHRcdFx0XHRcdFx0XHR0aGlzLnltYWcgPSBwYXJhbS50ZXh0Q29udGVudDtcclxuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdFx0XHRjYXNlICd6bmVhcic6XHJcblx0XHRcdFx0XHRcdFx0XHRcdHRoaXMuem5lYXIgPSBwYXJhbS50ZXh0Q29udGVudDtcclxuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdFx0XHRjYXNlICd6ZmFyJzpcclxuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy56ZmFyID0gcGFyYW0udGV4dENvbnRlbnQ7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSAnYXNwZWN0X3JhdGlvJzpcclxuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5hc3BlY3RfcmF0aW8gPSBwYXJhbS50ZXh0Q29udGVudDtcclxuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIEluc3RhbmNlQ2FtZXJhKCkge1xyXG5cclxuXHRcdHRoaXMudXJsID0gXCJcIjtcclxuXHJcblx0fVxyXG5cclxuXHRJbnN0YW5jZUNhbWVyYS5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoIGVsZW1lbnQgKSB7XHJcblxyXG5cdFx0dGhpcy51cmwgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgndXJsJykucmVwbGFjZSgvXiMvLCAnJyk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH07XHJcblxyXG5cdC8vIExpZ2h0XHJcblxyXG5cdGZ1bmN0aW9uIExpZ2h0KCkge1xyXG5cclxuXHRcdHRoaXMuaWQgPSBcIlwiO1xyXG5cdFx0dGhpcy5uYW1lID0gXCJcIjtcclxuXHRcdHRoaXMudGVjaG5pcXVlID0gXCJcIjtcclxuXHJcblx0fVxyXG5cclxuXHRMaWdodC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoIGVsZW1lbnQgKSB7XHJcblxyXG5cdFx0dGhpcy5pZCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCAnaWQnICk7XHJcblx0XHR0aGlzLm5hbWUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSggJ25hbWUnICk7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciBjaGlsZCA9IGVsZW1lbnQuY2hpbGROb2Rlc1sgaSBdO1xyXG5cdFx0XHRpZiAoIGNoaWxkLm5vZGVUeXBlICE9IDEgKSBjb250aW51ZTtcclxuXHJcblx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xyXG5cclxuXHRcdFx0XHRjYXNlICd0ZWNobmlxdWVfY29tbW9uJzpcclxuXHJcblx0XHRcdFx0XHR0aGlzLnBhcnNlQ29tbW9uKCBjaGlsZCApO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ3RlY2huaXF1ZSc6XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5wYXJzZVRlY2huaXF1ZSggY2hpbGQgKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRkZWZhdWx0OlxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9O1xyXG5cclxuXHRMaWdodC5wcm90b3R5cGUucGFyc2VDb21tb24gPSBmdW5jdGlvbiAoIGVsZW1lbnQgKSB7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdHN3aXRjaCAoIGVsZW1lbnQuY2hpbGROb2Rlc1sgaSBdLm5vZGVOYW1lICkge1xyXG5cclxuXHRcdFx0XHRjYXNlICdkaXJlY3Rpb25hbCc6XHJcblx0XHRcdFx0Y2FzZSAncG9pbnQnOlxyXG5cdFx0XHRcdGNhc2UgJ3Nwb3QnOlxyXG5cdFx0XHRcdGNhc2UgJ2FtYmllbnQnOlxyXG5cclxuXHRcdFx0XHRcdHRoaXMudGVjaG5pcXVlID0gZWxlbWVudC5jaGlsZE5vZGVzWyBpIF0ubm9kZU5hbWU7XHJcblxyXG5cdFx0XHRcdFx0dmFyIGxpZ2h0ID0gZWxlbWVudC5jaGlsZE5vZGVzWyBpIF07XHJcblxyXG5cdFx0XHRcdFx0Zm9yICggdmFyIGogPSAwOyBqIDwgbGlnaHQuY2hpbGROb2Rlcy5sZW5ndGg7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR2YXIgY2hpbGQgPSBsaWdodC5jaGlsZE5vZGVzW2pdO1xyXG5cclxuXHRcdFx0XHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGNhc2UgJ2NvbG9yJzpcclxuXHJcblx0XHRcdFx0XHRcdFx0XHR2YXIgcmdiYSA9IF9mbG9hdHMoIGNoaWxkLnRleHRDb250ZW50ICk7XHJcblx0XHRcdFx0XHRcdFx0XHR0aGlzLmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKDApO1xyXG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5jb2xvci5zZXRSR0IoIHJnYmFbMF0sIHJnYmFbMV0sIHJnYmFbMl0gKTtcclxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuY29sb3IuYSA9IHJnYmFbM107XHJcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRcdFx0Y2FzZSAnZmFsbG9mZl9hbmdsZSc6XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5mYWxsb2ZmX2FuZ2xlID0gcGFyc2VGbG9hdCggY2hpbGQudGV4dENvbnRlbnQgKTtcclxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjYXNlICdxdWFkcmF0aWNfYXR0ZW51YXRpb24nOlxyXG5cdFx0XHRcdFx0XHRcdFx0dmFyIGYgPSBwYXJzZUZsb2F0KCBjaGlsZC50ZXh0Q29udGVudCApO1xyXG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5kaXN0YW5jZSA9IGYgPyBNYXRoLnNxcnQoIDEgLyBmICkgOiAwO1xyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fTtcclxuXHJcblx0TGlnaHQucHJvdG90eXBlLnBhcnNlVGVjaG5pcXVlID0gZnVuY3Rpb24gKCBlbGVtZW50ICkge1xyXG5cclxuXHRcdHRoaXMucHJvZmlsZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCAncHJvZmlsZScgKTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBlbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIGNoaWxkID0gZWxlbWVudC5jaGlsZE5vZGVzWyBpIF07XHJcblxyXG5cdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcclxuXHJcblx0XHRcdFx0Y2FzZSAnaW50ZW5zaXR5JzpcclxuXHJcblx0XHRcdFx0XHR0aGlzLmludGVuc2l0eSA9IHBhcnNlRmxvYXQoY2hpbGQudGV4dENvbnRlbnQpO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBJbnN0YW5jZUxpZ2h0KCkge1xyXG5cclxuXHRcdHRoaXMudXJsID0gXCJcIjtcclxuXHJcblx0fVxyXG5cclxuXHRJbnN0YW5jZUxpZ2h0LnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uICggZWxlbWVudCApIHtcclxuXHJcblx0XHR0aGlzLnVybCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCd1cmwnKS5yZXBsYWNlKC9eIy8sICcnKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gS2luZW1hdGljc01vZGVsKCApIHtcclxuXHJcblx0XHR0aGlzLmlkID0gJyc7XHJcblx0XHR0aGlzLm5hbWUgPSAnJztcclxuXHRcdHRoaXMuam9pbnRzID0gW107XHJcblx0XHR0aGlzLmxpbmtzID0gW107XHJcblxyXG5cdH1cclxuXHJcblx0S2luZW1hdGljc01vZGVsLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xyXG5cclxuXHRcdHRoaXMuaWQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnaWQnKTtcclxuXHRcdHRoaXMubmFtZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCduYW1lJyk7XHJcblx0XHR0aGlzLmpvaW50cyA9IFtdO1xyXG5cdFx0dGhpcy5saW5rcyA9IFtdO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciBjaGlsZCA9IGVsZW1lbnQuY2hpbGROb2Rlc1sgaSBdO1xyXG5cdFx0XHRpZiAoIGNoaWxkLm5vZGVUeXBlICE9IDEgKSBjb250aW51ZTtcclxuXHJcblx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xyXG5cclxuXHRcdFx0XHRjYXNlICd0ZWNobmlxdWVfY29tbW9uJzpcclxuXHJcblx0XHRcdFx0XHR0aGlzLnBhcnNlQ29tbW9uKGNoaWxkKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRkZWZhdWx0OlxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9O1xyXG5cclxuXHRLaW5lbWF0aWNzTW9kZWwucHJvdG90eXBlLnBhcnNlQ29tbW9uID0gZnVuY3Rpb24oIGVsZW1lbnQgKSB7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIGNoaWxkID0gZWxlbWVudC5jaGlsZE5vZGVzWyBpIF07XHJcblx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT0gMSApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0c3dpdGNoICggZWxlbWVudC5jaGlsZE5vZGVzWyBpIF0ubm9kZU5hbWUgKSB7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ2pvaW50JzpcclxuXHRcdFx0XHRcdHRoaXMuam9pbnRzLnB1c2goIChuZXcgSm9pbnQoKSkucGFyc2UoY2hpbGQpICk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnbGluayc6XHJcblx0XHRcdFx0XHR0aGlzLmxpbmtzLnB1c2goIChuZXcgTGluaygpKS5wYXJzZShjaGlsZCkgKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRkZWZhdWx0OlxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBKb2ludCggKSB7XHJcblxyXG5cdFx0dGhpcy5zaWQgPSAnJztcclxuXHRcdHRoaXMubmFtZSA9ICcnO1xyXG5cdFx0dGhpcy5heGlzID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdHRoaXMubGltaXRzID0ge1xyXG5cdFx0XHRtaW46IDAsXHJcblx0XHRcdG1heDogMFxyXG5cdFx0fTtcclxuXHRcdHRoaXMudHlwZSA9ICcnO1xyXG5cdFx0dGhpcy5zdGF0aWMgPSBmYWxzZTtcclxuXHRcdHRoaXMuemVyb1Bvc2l0aW9uID0gMC4wO1xyXG5cdFx0dGhpcy5taWRkbGVQb3NpdGlvbiA9IDAuMDtcclxuXHJcblx0fVxyXG5cclxuXHRKb2ludC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiggZWxlbWVudCApIHtcclxuXHJcblx0XHR0aGlzLnNpZCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdzaWQnKTtcclxuXHRcdHRoaXMubmFtZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCduYW1lJyk7XHJcblx0XHR0aGlzLmF4aXMgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0dGhpcy5saW1pdHMgPSB7XHJcblx0XHRcdG1pbjogMCxcclxuXHRcdFx0bWF4OiAwXHJcblx0XHR9O1xyXG5cdFx0dGhpcy50eXBlID0gJyc7XHJcblx0XHR0aGlzLnN0YXRpYyA9IGZhbHNlO1xyXG5cdFx0dGhpcy56ZXJvUG9zaXRpb24gPSAwLjA7XHJcblx0XHR0aGlzLm1pZGRsZVBvc2l0aW9uID0gMC4wO1xyXG5cclxuXHRcdHZhciBheGlzRWxlbWVudCA9IGVsZW1lbnQucXVlcnlTZWxlY3RvcignYXhpcycpO1xyXG5cdFx0dmFyIF9heGlzID0gX2Zsb2F0cyhheGlzRWxlbWVudC50ZXh0Q29udGVudCk7XHJcblx0XHR0aGlzLmF4aXMgPSBnZXRDb252ZXJ0ZWRWZWMzKF9heGlzLCAwKTtcclxuXHJcblx0XHR2YXIgbWluID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yKCdsaW1pdHMgbWluJykgPyBwYXJzZUZsb2F0KGVsZW1lbnQucXVlcnlTZWxlY3RvcignbGltaXRzIG1pbicpLnRleHRDb250ZW50KSA6IC0zNjA7XHJcblx0XHR2YXIgbWF4ID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yKCdsaW1pdHMgbWF4JykgPyBwYXJzZUZsb2F0KGVsZW1lbnQucXVlcnlTZWxlY3RvcignbGltaXRzIG1heCcpLnRleHRDb250ZW50KSA6IDM2MDtcclxuXHJcblx0XHR0aGlzLmxpbWl0cyA9IHtcclxuXHRcdFx0bWluOiBtaW4sXHJcblx0XHRcdG1heDogbWF4XHJcblx0XHR9O1xyXG5cclxuXHRcdHZhciBqb2ludFR5cGVzID0gWyAncHJpc21hdGljJywgJ3Jldm9sdXRlJyBdO1xyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBqb2ludFR5cGVzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciB0eXBlID0gam9pbnRUeXBlc1sgaSBdO1xyXG5cclxuXHRcdFx0dmFyIGpvaW50RWxlbWVudCA9IGVsZW1lbnQucXVlcnlTZWxlY3Rvcih0eXBlKTtcclxuXHJcblx0XHRcdGlmICggam9pbnRFbGVtZW50ICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLnR5cGUgPSB0eXBlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBpZiB0aGUgbWluIGlzIGVxdWFsIHRvIG9yIHNvbWVob3cgZ3JlYXRlciB0aGFuIHRoZSBtYXgsIGNvbnNpZGVyIHRoZSBqb2ludCBzdGF0aWNcclxuXHRcdGlmICggdGhpcy5saW1pdHMubWluID49IHRoaXMubGltaXRzLm1heCApIHtcclxuXHJcblx0XHRcdHRoaXMuc3RhdGljID0gdHJ1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5taWRkbGVQb3NpdGlvbiA9ICh0aGlzLmxpbWl0cy5taW4gKyB0aGlzLmxpbWl0cy5tYXgpIC8gMi4wO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIExpbmsoICkge1xyXG5cclxuXHRcdHRoaXMuc2lkID0gJyc7XHJcblx0XHR0aGlzLm5hbWUgPSAnJztcclxuXHRcdHRoaXMudHJhbnNmb3JtcyA9IFtdO1xyXG5cdFx0dGhpcy5hdHRhY2htZW50cyA9IFtdO1xyXG5cclxuXHR9XHJcblxyXG5cdExpbmsucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24oIGVsZW1lbnQgKSB7XHJcblxyXG5cdFx0dGhpcy5zaWQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnc2lkJyk7XHJcblx0XHR0aGlzLm5hbWUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnbmFtZScpO1xyXG5cdFx0dGhpcy50cmFuc2Zvcm1zID0gW107XHJcblx0XHR0aGlzLmF0dGFjaG1lbnRzID0gW107XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIGNoaWxkID0gZWxlbWVudC5jaGlsZE5vZGVzWyBpIF07XHJcblx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT0gMSApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ2F0dGFjaG1lbnRfZnVsbCc6XHJcblx0XHRcdFx0XHR0aGlzLmF0dGFjaG1lbnRzLnB1c2goIChuZXcgQXR0YWNobWVudCgpKS5wYXJzZShjaGlsZCkgKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICdyb3RhdGUnOlxyXG5cdFx0XHRcdGNhc2UgJ3RyYW5zbGF0ZSc6XHJcblx0XHRcdFx0Y2FzZSAnbWF0cml4JzpcclxuXHJcblx0XHRcdFx0XHR0aGlzLnRyYW5zZm9ybXMucHVzaCggKG5ldyBUcmFuc2Zvcm0oKSkucGFyc2UoY2hpbGQpICk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0ZGVmYXVsdDpcclxuXHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIEF0dGFjaG1lbnQoICkge1xyXG5cclxuXHRcdHRoaXMuam9pbnQgPSAnJztcclxuXHRcdHRoaXMudHJhbnNmb3JtcyA9IFtdO1xyXG5cdFx0dGhpcy5saW5rcyA9IFtdO1xyXG5cclxuXHR9XHJcblxyXG5cdEF0dGFjaG1lbnQucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24oIGVsZW1lbnQgKSB7XHJcblxyXG5cdFx0dGhpcy5qb2ludCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdqb2ludCcpLnNwbGl0KCcvJykucG9wKCk7XHJcblx0XHR0aGlzLmxpbmtzID0gW107XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIGNoaWxkID0gZWxlbWVudC5jaGlsZE5vZGVzWyBpIF07XHJcblx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT0gMSApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ2xpbmsnOlxyXG5cdFx0XHRcdFx0dGhpcy5saW5rcy5wdXNoKCAobmV3IExpbmsoKSkucGFyc2UoY2hpbGQpICk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAncm90YXRlJzpcclxuXHRcdFx0XHRjYXNlICd0cmFuc2xhdGUnOlxyXG5cdFx0XHRcdGNhc2UgJ21hdHJpeCc6XHJcblxyXG5cdFx0XHRcdFx0dGhpcy50cmFuc2Zvcm1zLnB1c2goIChuZXcgVHJhbnNmb3JtKCkpLnBhcnNlKGNoaWxkKSApO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGRlZmF1bHQ6XHJcblxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBfc291cmNlKCBlbGVtZW50ICkge1xyXG5cclxuXHRcdHZhciBpZCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCAnaWQnICk7XHJcblxyXG5cdFx0aWYgKCBzb3VyY2VzWyBpZCBdICE9IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHJldHVybiBzb3VyY2VzWyBpZCBdO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRzb3VyY2VzWyBpZCBdID0gKCBuZXcgU291cmNlKGlkICkpLnBhcnNlKCBlbGVtZW50ICk7XHJcblx0XHRyZXR1cm4gc291cmNlc1sgaWQgXTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBfbnNSZXNvbHZlciggbnNQcmVmaXggKSB7XHJcblxyXG5cdFx0aWYgKCBuc1ByZWZpeCA9PT0gXCJkYWVcIiApIHtcclxuXHJcblx0XHRcdHJldHVybiBcImh0dHA6Ly93d3cuY29sbGFkYS5vcmcvMjAwNS8xMS9DT0xMQURBU2NoZW1hXCI7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBudWxsO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIF9ib29scyggc3RyICkge1xyXG5cclxuXHRcdHZhciByYXcgPSBfc3RyaW5ncyggc3RyICk7XHJcblx0XHR2YXIgZGF0YSA9IFtdO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHJhdy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0ZGF0YS5wdXNoKCAocmF3W2ldID09PSAndHJ1ZScgfHwgcmF3W2ldID09PSAnMScpID8gdHJ1ZSA6IGZhbHNlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBkYXRhO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIF9mbG9hdHMoIHN0ciApIHtcclxuXHJcblx0XHR2YXIgcmF3ID0gX3N0cmluZ3Moc3RyKTtcclxuXHRcdHZhciBkYXRhID0gW107XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gcmF3Lmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRkYXRhLnB1c2goIHBhcnNlRmxvYXQoIHJhd1sgaSBdICkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGRhdGE7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gX2ludHMoIHN0ciApIHtcclxuXHJcblx0XHR2YXIgcmF3ID0gX3N0cmluZ3MoIHN0ciApO1xyXG5cdFx0dmFyIGRhdGEgPSBbXTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSByYXcubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdGRhdGEucHVzaCggcGFyc2VJbnQoIHJhd1sgaSBdLCAxMCApICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBkYXRhO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIF9zdHJpbmdzKCBzdHIgKSB7XHJcblxyXG5cdFx0cmV0dXJuICggc3RyLmxlbmd0aCA+IDAgKSA/IF90cmltU3RyaW5nKCBzdHIgKS5zcGxpdCggL1xccysvICkgOiBbXTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBfdHJpbVN0cmluZyggc3RyICkge1xyXG5cclxuXHRcdHJldHVybiBzdHIucmVwbGFjZSggL15cXHMrLywgXCJcIiApLnJlcGxhY2UoIC9cXHMrJC8sIFwiXCIgKTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBfYXR0cl9hc19mbG9hdCggZWxlbWVudCwgbmFtZSwgZGVmYXVsdFZhbHVlICkge1xyXG5cclxuXHRcdGlmICggZWxlbWVudC5oYXNBdHRyaWJ1dGUoIG5hbWUgKSApIHtcclxuXHJcblx0XHRcdHJldHVybiBwYXJzZUZsb2F0KCBlbGVtZW50LmdldEF0dHJpYnV0ZSggbmFtZSApICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHJldHVybiBkZWZhdWx0VmFsdWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIF9hdHRyX2FzX2ludCggZWxlbWVudCwgbmFtZSwgZGVmYXVsdFZhbHVlICkge1xyXG5cclxuXHRcdGlmICggZWxlbWVudC5oYXNBdHRyaWJ1dGUoIG5hbWUgKSApIHtcclxuXHJcblx0XHRcdHJldHVybiBwYXJzZUludCggZWxlbWVudC5nZXRBdHRyaWJ1dGUoIG5hbWUgKSwgMTApIDtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0cmV0dXJuIGRlZmF1bHRWYWx1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gX2F0dHJfYXNfc3RyaW5nKCBlbGVtZW50LCBuYW1lLCBkZWZhdWx0VmFsdWUgKSB7XHJcblxyXG5cdFx0aWYgKCBlbGVtZW50Lmhhc0F0dHJpYnV0ZSggbmFtZSApICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCBuYW1lICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHJldHVybiBkZWZhdWx0VmFsdWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIF9mb3JtYXRfZmxvYXQoIGYsIG51bSApIHtcclxuXHJcblx0XHRpZiAoIGYgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHZhciBzID0gJzAuJztcclxuXHJcblx0XHRcdHdoaWxlICggcy5sZW5ndGggPCBudW0gKyAyICkge1xyXG5cclxuXHRcdFx0XHRzICs9ICcwJztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBzO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRudW0gPSBudW0gfHwgMjtcclxuXHJcblx0XHR2YXIgcGFydHMgPSBmLnRvU3RyaW5nKCkuc3BsaXQoICcuJyApO1xyXG5cdFx0cGFydHNbIDEgXSA9IHBhcnRzLmxlbmd0aCA+IDEgPyBwYXJ0c1sgMSBdLnN1YnN0ciggMCwgbnVtICkgOiBcIjBcIjtcclxuXHJcblx0XHR3aGlsZSAoIHBhcnRzWyAxIF0ubGVuZ3RoIDwgbnVtICkge1xyXG5cclxuXHRcdFx0cGFydHNbIDEgXSArPSAnMCc7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBwYXJ0cy5qb2luKCAnLicgKTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBsb2FkVGV4dHVyZUltYWdlICggdGV4dHVyZSwgdXJsICkge1xyXG5cclxuXHRcdHZhciBsb2FkZXIgPSBuZXcgVEhSRUUuSW1hZ2VMb2FkZXIoKTtcclxuXHJcblx0XHRsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIGltYWdlICkge1xyXG5cclxuXHRcdFx0dGV4dHVyZS5pbWFnZSA9IGltYWdlO1xyXG5cdFx0XHR0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHR9ICk7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gZXh0cmFjdERvdWJsZVNpZGVkKCBvYmosIGVsZW1lbnQgKSB7XHJcblxyXG5cdFx0b2JqLmRvdWJsZVNpZGVkID0gZmFsc2U7XHJcblxyXG5cdFx0dmFyIG5vZGUgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2V4dHJhIGRvdWJsZV9zaWRlZCcpWzBdO1xyXG5cclxuXHRcdGlmICggbm9kZSApIHtcclxuXHJcblx0XHRcdGlmICggbm9kZSAmJiBwYXJzZUludCggbm9kZS50ZXh0Q29udGVudCwgMTAgKSA9PT0gMSApIHtcclxuXHJcblx0XHRcdFx0b2JqLmRvdWJsZVNpZGVkID0gdHJ1ZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gVXAgYXhpcyBjb252ZXJzaW9uXHJcblxyXG5cdGZ1bmN0aW9uIHNldFVwQ29udmVyc2lvbigpIHtcclxuXHJcblx0XHRpZiAoIG9wdGlvbnMuY29udmVydFVwQXhpcyAhPT0gdHJ1ZSB8fCBjb2xsYWRhVXAgPT09IG9wdGlvbnMudXBBeGlzICkge1xyXG5cclxuXHRcdFx0dXBDb252ZXJzaW9uID0gbnVsbDtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0c3dpdGNoICggY29sbGFkYVVwICkge1xyXG5cclxuXHRcdFx0XHRjYXNlICdYJzpcclxuXHJcblx0XHRcdFx0XHR1cENvbnZlcnNpb24gPSBvcHRpb25zLnVwQXhpcyA9PT0gJ1knID8gJ1h0b1knIDogJ1h0b1onO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ1knOlxyXG5cclxuXHRcdFx0XHRcdHVwQ29udmVyc2lvbiA9IG9wdGlvbnMudXBBeGlzID09PSAnWCcgPyAnWXRvWCcgOiAnWXRvWic7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnWic6XHJcblxyXG5cdFx0XHRcdFx0dXBDb252ZXJzaW9uID0gb3B0aW9ucy51cEF4aXMgPT09ICdYJyA/ICdadG9YJyA6ICdadG9ZJztcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBmaXhDb29yZHMoIGRhdGEsIHNpZ24gKSB7XHJcblxyXG5cdFx0aWYgKCBvcHRpb25zLmNvbnZlcnRVcEF4aXMgIT09IHRydWUgfHwgY29sbGFkYVVwID09PSBvcHRpb25zLnVwQXhpcyApIHtcclxuXHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0c3dpdGNoICggdXBDb252ZXJzaW9uICkge1xyXG5cclxuXHRcdFx0Y2FzZSAnWHRvWSc6XHJcblxyXG5cdFx0XHRcdHZhciB0bXAgPSBkYXRhWyAwIF07XHJcblx0XHRcdFx0ZGF0YVsgMCBdID0gc2lnbiAqIGRhdGFbIDEgXTtcclxuXHRcdFx0XHRkYXRhWyAxIF0gPSB0bXA7XHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRjYXNlICdYdG9aJzpcclxuXHJcblx0XHRcdFx0dmFyIHRtcCA9IGRhdGFbIDIgXTtcclxuXHRcdFx0XHRkYXRhWyAyIF0gPSBkYXRhWyAxIF07XHJcblx0XHRcdFx0ZGF0YVsgMSBdID0gZGF0YVsgMCBdO1xyXG5cdFx0XHRcdGRhdGFbIDAgXSA9IHRtcDtcclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGNhc2UgJ1l0b1gnOlxyXG5cclxuXHRcdFx0XHR2YXIgdG1wID0gZGF0YVsgMCBdO1xyXG5cdFx0XHRcdGRhdGFbIDAgXSA9IGRhdGFbIDEgXTtcclxuXHRcdFx0XHRkYXRhWyAxIF0gPSBzaWduICogdG1wO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0Y2FzZSAnWXRvWic6XHJcblxyXG5cdFx0XHRcdHZhciB0bXAgPSBkYXRhWyAxIF07XHJcblx0XHRcdFx0ZGF0YVsgMSBdID0gc2lnbiAqIGRhdGFbIDIgXTtcclxuXHRcdFx0XHRkYXRhWyAyIF0gPSB0bXA7XHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRjYXNlICdadG9YJzpcclxuXHJcblx0XHRcdFx0dmFyIHRtcCA9IGRhdGFbIDAgXTtcclxuXHRcdFx0XHRkYXRhWyAwIF0gPSBkYXRhWyAxIF07XHJcblx0XHRcdFx0ZGF0YVsgMSBdID0gZGF0YVsgMiBdO1xyXG5cdFx0XHRcdGRhdGFbIDIgXSA9IHRtcDtcclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGNhc2UgJ1p0b1knOlxyXG5cclxuXHRcdFx0XHR2YXIgdG1wID0gZGF0YVsgMSBdO1xyXG5cdFx0XHRcdGRhdGFbIDEgXSA9IGRhdGFbIDIgXTtcclxuXHRcdFx0XHRkYXRhWyAyIF0gPSBzaWduICogdG1wO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBnZXRDb252ZXJ0ZWRUcmFuc2xhdGlvbiggYXhpcywgZGF0YSApIHtcclxuXHJcblx0XHRpZiAoIG9wdGlvbnMuY29udmVydFVwQXhpcyAhPT0gdHJ1ZSB8fCBjb2xsYWRhVXAgPT09IG9wdGlvbnMudXBBeGlzICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIGRhdGE7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHN3aXRjaCAoIGF4aXMgKSB7XHJcblx0XHRcdGNhc2UgJ1gnOlxyXG5cdFx0XHRcdGRhdGEgPSB1cENvbnZlcnNpb24gPT09ICdYdG9ZJyA/IGRhdGEgKiAtMSA6IGRhdGE7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdGNhc2UgJ1knOlxyXG5cdFx0XHRcdGRhdGEgPSB1cENvbnZlcnNpb24gPT09ICdZdG9aJyB8fCB1cENvbnZlcnNpb24gPT09ICdZdG9YJyA/IGRhdGEgKiAtMSA6IGRhdGE7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdGNhc2UgJ1onOlxyXG5cdFx0XHRcdGRhdGEgPSB1cENvbnZlcnNpb24gPT09ICdadG9ZJyA/IGRhdGEgKiAtMSA6IGRhdGEgO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRkZWZhdWx0OlxyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBkYXRhO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gZ2V0Q29udmVydGVkVmVjMyggZGF0YSwgb2Zmc2V0ICkge1xyXG5cclxuXHRcdHZhciBhcnIgPSBbIGRhdGFbIG9mZnNldCBdLCBkYXRhWyBvZmZzZXQgKyAxIF0sIGRhdGFbIG9mZnNldCArIDIgXSBdO1xyXG5cdFx0Zml4Q29vcmRzKCBhcnIsIC0xICk7XHJcblx0XHRyZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjMoIGFyclsgMCBdLCBhcnJbIDEgXSwgYXJyWyAyIF0gKTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBnZXRDb252ZXJ0ZWRNYXQ0KCBkYXRhICkge1xyXG5cclxuXHRcdGlmICggb3B0aW9ucy5jb252ZXJ0VXBBeGlzICkge1xyXG5cclxuXHRcdFx0Ly8gRmlyc3QgZml4IHJvdGF0aW9uIGFuZCBzY2FsZVxyXG5cclxuXHRcdFx0Ly8gQ29sdW1ucyBmaXJzdFxyXG5cdFx0XHR2YXIgYXJyID0gWyBkYXRhWyAwIF0sIGRhdGFbIDQgXSwgZGF0YVsgOCBdIF07XHJcblx0XHRcdGZpeENvb3JkcyggYXJyLCAtMSApO1xyXG5cdFx0XHRkYXRhWyAwIF0gPSBhcnJbIDAgXTtcclxuXHRcdFx0ZGF0YVsgNCBdID0gYXJyWyAxIF07XHJcblx0XHRcdGRhdGFbIDggXSA9IGFyclsgMiBdO1xyXG5cdFx0XHRhcnIgPSBbIGRhdGFbIDEgXSwgZGF0YVsgNSBdLCBkYXRhWyA5IF0gXTtcclxuXHRcdFx0Zml4Q29vcmRzKCBhcnIsIC0xICk7XHJcblx0XHRcdGRhdGFbIDEgXSA9IGFyclsgMCBdO1xyXG5cdFx0XHRkYXRhWyA1IF0gPSBhcnJbIDEgXTtcclxuXHRcdFx0ZGF0YVsgOSBdID0gYXJyWyAyIF07XHJcblx0XHRcdGFyciA9IFsgZGF0YVsgMiBdLCBkYXRhWyA2IF0sIGRhdGFbIDEwIF0gXTtcclxuXHRcdFx0Zml4Q29vcmRzKCBhcnIsIC0xICk7XHJcblx0XHRcdGRhdGFbIDIgXSA9IGFyclsgMCBdO1xyXG5cdFx0XHRkYXRhWyA2IF0gPSBhcnJbIDEgXTtcclxuXHRcdFx0ZGF0YVsgMTAgXSA9IGFyclsgMiBdO1xyXG5cdFx0XHQvLyBSb3dzIHNlY29uZFxyXG5cdFx0XHRhcnIgPSBbIGRhdGFbIDAgXSwgZGF0YVsgMSBdLCBkYXRhWyAyIF0gXTtcclxuXHRcdFx0Zml4Q29vcmRzKCBhcnIsIC0xICk7XHJcblx0XHRcdGRhdGFbIDAgXSA9IGFyclsgMCBdO1xyXG5cdFx0XHRkYXRhWyAxIF0gPSBhcnJbIDEgXTtcclxuXHRcdFx0ZGF0YVsgMiBdID0gYXJyWyAyIF07XHJcblx0XHRcdGFyciA9IFsgZGF0YVsgNCBdLCBkYXRhWyA1IF0sIGRhdGFbIDYgXSBdO1xyXG5cdFx0XHRmaXhDb29yZHMoIGFyciwgLTEgKTtcclxuXHRcdFx0ZGF0YVsgNCBdID0gYXJyWyAwIF07XHJcblx0XHRcdGRhdGFbIDUgXSA9IGFyclsgMSBdO1xyXG5cdFx0XHRkYXRhWyA2IF0gPSBhcnJbIDIgXTtcclxuXHRcdFx0YXJyID0gWyBkYXRhWyA4IF0sIGRhdGFbIDkgXSwgZGF0YVsgMTAgXSBdO1xyXG5cdFx0XHRmaXhDb29yZHMoIGFyciwgLTEgKTtcclxuXHRcdFx0ZGF0YVsgOCBdID0gYXJyWyAwIF07XHJcblx0XHRcdGRhdGFbIDkgXSA9IGFyclsgMSBdO1xyXG5cdFx0XHRkYXRhWyAxMCBdID0gYXJyWyAyIF07XHJcblxyXG5cdFx0XHQvLyBOb3cgZml4IHRyYW5zbGF0aW9uXHJcblx0XHRcdGFyciA9IFsgZGF0YVsgMyBdLCBkYXRhWyA3IF0sIGRhdGFbIDExIF0gXTtcclxuXHRcdFx0Zml4Q29vcmRzKCBhcnIsIC0xICk7XHJcblx0XHRcdGRhdGFbIDMgXSA9IGFyclsgMCBdO1xyXG5cdFx0XHRkYXRhWyA3IF0gPSBhcnJbIDEgXTtcclxuXHRcdFx0ZGF0YVsgMTEgXSA9IGFyclsgMiBdO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbmV3IFRIUkVFLk1hdHJpeDQoKS5zZXQoXHJcblx0XHRcdGRhdGFbMF0sIGRhdGFbMV0sIGRhdGFbMl0sIGRhdGFbM10sXHJcblx0XHRcdGRhdGFbNF0sIGRhdGFbNV0sIGRhdGFbNl0sIGRhdGFbN10sXHJcblx0XHRcdGRhdGFbOF0sIGRhdGFbOV0sIGRhdGFbMTBdLCBkYXRhWzExXSxcclxuXHRcdFx0ZGF0YVsxMl0sIGRhdGFbMTNdLCBkYXRhWzE0XSwgZGF0YVsxNV1cclxuXHRcdFx0KTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBnZXRDb252ZXJ0ZWRJbmRleCggaW5kZXggKSB7XHJcblxyXG5cdFx0aWYgKCBpbmRleCA+IC0xICYmIGluZGV4IDwgMyApIHtcclxuXHJcblx0XHRcdHZhciBtZW1iZXJzID0gWyAnWCcsICdZJywgJ1onIF0sXHJcblx0XHRcdFx0aW5kaWNlcyA9IHsgWDogMCwgWTogMSwgWjogMiB9O1xyXG5cclxuXHRcdFx0aW5kZXggPSBnZXRDb252ZXJ0ZWRNZW1iZXIoIG1lbWJlcnNbIGluZGV4IF0gKTtcclxuXHRcdFx0aW5kZXggPSBpbmRpY2VzWyBpbmRleCBdO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gaW5kZXg7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gZ2V0Q29udmVydGVkTWVtYmVyKCBtZW1iZXIgKSB7XHJcblxyXG5cdFx0aWYgKCBvcHRpb25zLmNvbnZlcnRVcEF4aXMgKSB7XHJcblxyXG5cdFx0XHRzd2l0Y2ggKCBtZW1iZXIgKSB7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ1gnOlxyXG5cclxuXHRcdFx0XHRcdHN3aXRjaCAoIHVwQ29udmVyc2lvbiApIHtcclxuXHJcblx0XHRcdFx0XHRcdGNhc2UgJ1h0b1knOlxyXG5cdFx0XHRcdFx0XHRjYXNlICdYdG9aJzpcclxuXHRcdFx0XHRcdFx0Y2FzZSAnWXRvWCc6XHJcblxyXG5cdFx0XHRcdFx0XHRcdG1lbWJlciA9ICdZJztcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRcdGNhc2UgJ1p0b1gnOlxyXG5cclxuXHRcdFx0XHRcdFx0XHRtZW1iZXIgPSAnWic7XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICdZJzpcclxuXHJcblx0XHRcdFx0XHRzd2l0Y2ggKCB1cENvbnZlcnNpb24gKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRjYXNlICdYdG9ZJzpcclxuXHRcdFx0XHRcdFx0Y2FzZSAnWXRvWCc6XHJcblx0XHRcdFx0XHRcdGNhc2UgJ1p0b1gnOlxyXG5cclxuXHRcdFx0XHRcdFx0XHRtZW1iZXIgPSAnWCc7XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0XHRjYXNlICdYdG9aJzpcclxuXHRcdFx0XHRcdFx0Y2FzZSAnWXRvWic6XHJcblx0XHRcdFx0XHRcdGNhc2UgJ1p0b1knOlxyXG5cclxuXHRcdFx0XHRcdFx0XHRtZW1iZXIgPSAnWic7XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICdaJzpcclxuXHJcblx0XHRcdFx0XHRzd2l0Y2ggKCB1cENvbnZlcnNpb24gKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRjYXNlICdYdG9aJzpcclxuXHJcblx0XHRcdFx0XHRcdFx0bWVtYmVyID0gJ1gnO1xyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdFx0Y2FzZSAnWXRvWic6XHJcblx0XHRcdFx0XHRcdGNhc2UgJ1p0b1gnOlxyXG5cdFx0XHRcdFx0XHRjYXNlICdadG9ZJzpcclxuXHJcblx0XHRcdFx0XHRcdFx0bWVtYmVyID0gJ1knO1xyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG1lbWJlcjtcclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4ge1xyXG5cclxuXHRcdGxvYWQ6IGxvYWQsXHJcblx0XHRwYXJzZTogcGFyc2UsXHJcblx0XHRzZXRQcmVmZXJyZWRTaGFkaW5nOiBzZXRQcmVmZXJyZWRTaGFkaW5nLFxyXG5cdFx0YXBwbHlTa2luOiBhcHBseVNraW4sXHJcblx0XHRnZW9tZXRyaWVzIDogZ2VvbWV0cmllcyxcclxuXHRcdG9wdGlvbnM6IG9wdGlvbnNcclxuXHJcblx0fTtcclxuXHJcbn07XHJcblxufSx7fV0sMTk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLyoqXHJcbiAqIExvYWRzIGEgV2F2ZWZyb250IC5tdGwgZmlsZSBzcGVjaWZ5aW5nIG1hdGVyaWFsc1xyXG4gKlxyXG4gKiBAYXV0aG9yIGFuZ2VseHVhbmNoYW5nXHJcbiAqL1xyXG5cclxuVEhSRUUuTVRMTG9hZGVyID0gZnVuY3Rpb24oIG1hbmFnZXIgKSB7XHJcblxyXG5cdHRoaXMubWFuYWdlciA9ICggbWFuYWdlciAhPT0gdW5kZWZpbmVkICkgPyBtYW5hZ2VyIDogVEhSRUUuRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xyXG5cclxufTtcclxuXHJcblRIUkVFLk1UTExvYWRlci5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5NVExMb2FkZXIsXHJcblxyXG5cdGxvYWQ6IGZ1bmN0aW9uICggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XHJcblxyXG5cdFx0dmFyIHNjb3BlID0gdGhpcztcclxuXHJcblx0XHR2YXIgbG9hZGVyID0gbmV3IFRIUkVFLlhIUkxvYWRlciggdGhpcy5tYW5hZ2VyICk7XHJcblx0XHRsb2FkZXIuc2V0UGF0aCggdGhpcy5wYXRoICk7XHJcblx0XHRsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIHRleHQgKSB7XHJcblxyXG5cdFx0XHRvbkxvYWQoIHNjb3BlLnBhcnNlKCB0ZXh0ICkgKTtcclxuXHJcblx0XHR9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldFBhdGg6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdFx0dGhpcy5wYXRoID0gdmFsdWU7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldEJhc2VVcmw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcclxuXHJcblx0XHQvLyBUT0RPOiBNZXJnZSB3aXRoIHNldFBhdGgoKT8gT3IgcmVuYW1lIHRvIHNldFRleHR1cmVQYXRoP1xyXG5cclxuXHRcdHRoaXMuYmFzZVVybCA9IHZhbHVlO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRDcm9zc09yaWdpbjogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0XHR0aGlzLmNyb3NzT3JpZ2luID0gdmFsdWU7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldE1hdGVyaWFsT3B0aW9uczogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0XHR0aGlzLm1hdGVyaWFsT3B0aW9ucyA9IHZhbHVlO1xyXG5cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBQYXJzZXMgbG9hZGVkIE1UTCBmaWxlXHJcblx0ICogQHBhcmFtIHRleHQgLSBDb250ZW50IG9mIE1UTCBmaWxlXHJcblx0ICogQHJldHVybiB7VEhSRUUuTVRMTG9hZGVyLk1hdGVyaWFsQ3JlYXRvcn1cclxuXHQgKi9cclxuXHRwYXJzZTogZnVuY3Rpb24gKCB0ZXh0ICkge1xyXG5cclxuXHRcdHZhciBsaW5lcyA9IHRleHQuc3BsaXQoIFwiXFxuXCIgKTtcclxuXHRcdHZhciBpbmZvID0ge307XHJcblx0XHR2YXIgZGVsaW1pdGVyX3BhdHRlcm4gPSAvXFxzKy87XHJcblx0XHR2YXIgbWF0ZXJpYWxzSW5mbyA9IHt9O1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciBsaW5lID0gbGluZXNbIGkgXTtcclxuXHRcdFx0bGluZSA9IGxpbmUudHJpbSgpO1xyXG5cclxuXHRcdFx0aWYgKCBsaW5lLmxlbmd0aCA9PT0gMCB8fCBsaW5lLmNoYXJBdCggMCApID09PSAnIycgKSB7XHJcblxyXG5cdFx0XHRcdC8vIEJsYW5rIGxpbmUgb3IgY29tbWVudCBpZ25vcmVcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBwb3MgPSBsaW5lLmluZGV4T2YoICcgJyApO1xyXG5cclxuXHRcdFx0dmFyIGtleSA9ICggcG9zID49IDAgKSA/IGxpbmUuc3Vic3RyaW5nKCAwLCBwb3MgKSA6IGxpbmU7XHJcblx0XHRcdGtleSA9IGtleS50b0xvd2VyQ2FzZSgpO1xyXG5cclxuXHRcdFx0dmFyIHZhbHVlID0gKCBwb3MgPj0gMCApID8gbGluZS5zdWJzdHJpbmcoIHBvcyArIDEgKSA6IFwiXCI7XHJcblx0XHRcdHZhbHVlID0gdmFsdWUudHJpbSgpO1xyXG5cclxuXHRcdFx0aWYgKCBrZXkgPT09IFwibmV3bXRsXCIgKSB7XHJcblxyXG5cdFx0XHRcdC8vIE5ldyBtYXRlcmlhbFxyXG5cclxuXHRcdFx0XHRpbmZvID0geyBuYW1lOiB2YWx1ZSB9O1xyXG5cdFx0XHRcdG1hdGVyaWFsc0luZm9bIHZhbHVlIF0gPSBpbmZvO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggaW5mbyApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBrZXkgPT09IFwia2FcIiB8fCBrZXkgPT09IFwia2RcIiB8fCBrZXkgPT09IFwia3NcIiApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgc3MgPSB2YWx1ZS5zcGxpdCggZGVsaW1pdGVyX3BhdHRlcm4sIDMgKTtcclxuXHRcdFx0XHRcdGluZm9bIGtleSBdID0gWyBwYXJzZUZsb2F0KCBzc1sgMCBdICksIHBhcnNlRmxvYXQoIHNzWyAxIF0gKSwgcGFyc2VGbG9hdCggc3NbIDIgXSApIF07XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0aW5mb1sga2V5IF0gPSB2YWx1ZTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgbWF0ZXJpYWxDcmVhdG9yID0gbmV3IFRIUkVFLk1UTExvYWRlci5NYXRlcmlhbENyZWF0b3IoIHRoaXMuYmFzZVVybCwgdGhpcy5tYXRlcmlhbE9wdGlvbnMgKTtcclxuXHRcdG1hdGVyaWFsQ3JlYXRvci5zZXRDcm9zc09yaWdpbiggdGhpcy5jcm9zc09yaWdpbiApO1xyXG5cdFx0bWF0ZXJpYWxDcmVhdG9yLnNldE1hbmFnZXIoIHRoaXMubWFuYWdlciApO1xyXG5cdFx0bWF0ZXJpYWxDcmVhdG9yLnNldE1hdGVyaWFscyggbWF0ZXJpYWxzSW5mbyApO1xyXG5cdFx0cmV0dXJuIG1hdGVyaWFsQ3JlYXRvcjtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGUgYSBuZXcgVEhSRUUtTVRMTG9hZGVyLk1hdGVyaWFsQ3JlYXRvclxyXG4gKiBAcGFyYW0gYmFzZVVybCAtIFVybCByZWxhdGl2ZSB0byB3aGljaCB0ZXh0dXJlcyBhcmUgbG9hZGVkXHJcbiAqIEBwYXJhbSBvcHRpb25zIC0gU2V0IG9mIG9wdGlvbnMgb24gaG93IHRvIGNvbnN0cnVjdCB0aGUgbWF0ZXJpYWxzXHJcbiAqICAgICAgICAgICAgICAgICAgc2lkZTogV2hpY2ggc2lkZSB0byBhcHBseSB0aGUgbWF0ZXJpYWxcclxuICogICAgICAgICAgICAgICAgICAgICAgICBUSFJFRS5Gcm9udFNpZGUgKGRlZmF1bHQpLCBUSFJFRS5CYWNrU2lkZSwgVEhSRUUuRG91YmxlU2lkZVxyXG4gKiAgICAgICAgICAgICAgICAgIHdyYXA6IFdoYXQgdHlwZSBvZiB3cmFwcGluZyB0byBhcHBseSBmb3IgdGV4dHVyZXNcclxuICogICAgICAgICAgICAgICAgICAgICAgICBUSFJFRS5SZXBlYXRXcmFwcGluZyAoZGVmYXVsdCksIFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmcsIFRIUkVFLk1pcnJvcmVkUmVwZWF0V3JhcHBpbmdcclxuICogICAgICAgICAgICAgICAgICBub3JtYWxpemVSR0I6IFJHQnMgbmVlZCB0byBiZSBub3JtYWxpemVkIHRvIDAtMSBmcm9tIDAtMjU1XHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0OiBmYWxzZSwgYXNzdW1lZCB0byBiZSBhbHJlYWR5IG5vcm1hbGl6ZWRcclxuICogICAgICAgICAgICAgICAgICBpZ25vcmVaZXJvUkdCczogSWdub3JlIHZhbHVlcyBvZiBSR0JzIChLYSxLZCxLcykgdGhhdCBhcmUgYWxsIDAnc1xyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0OiBmYWxzZVxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcblxyXG5USFJFRS5NVExMb2FkZXIuTWF0ZXJpYWxDcmVhdG9yID0gZnVuY3Rpb24oIGJhc2VVcmwsIG9wdGlvbnMgKSB7XHJcblxyXG5cdHRoaXMuYmFzZVVybCA9IGJhc2VVcmw7XHJcblx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcclxuXHR0aGlzLm1hdGVyaWFsc0luZm8gPSB7fTtcclxuXHR0aGlzLm1hdGVyaWFscyA9IHt9O1xyXG5cdHRoaXMubWF0ZXJpYWxzQXJyYXkgPSBbXTtcclxuXHR0aGlzLm5hbWVMb29rdXAgPSB7fTtcclxuXHJcblx0dGhpcy5zaWRlID0gKCB0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLnNpZGUgKSA/IHRoaXMub3B0aW9ucy5zaWRlIDogVEhSRUUuRnJvbnRTaWRlO1xyXG5cdHRoaXMud3JhcCA9ICggdGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy53cmFwICkgPyB0aGlzLm9wdGlvbnMud3JhcCA6IFRIUkVFLlJlcGVhdFdyYXBwaW5nO1xyXG5cclxufTtcclxuXHJcblRIUkVFLk1UTExvYWRlci5NYXRlcmlhbENyZWF0b3IucHJvdG90eXBlID0ge1xyXG5cclxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuTVRMTG9hZGVyLk1hdGVyaWFsQ3JlYXRvcixcclxuXHJcblx0c2V0Q3Jvc3NPcmlnaW46IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdFx0dGhpcy5jcm9zc09yaWdpbiA9IHZhbHVlO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRNYW5hZ2VyOiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdHRoaXMubWFuYWdlciA9IHZhbHVlO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRNYXRlcmlhbHM6IGZ1bmN0aW9uKCBtYXRlcmlhbHNJbmZvICkge1xyXG5cclxuXHRcdHRoaXMubWF0ZXJpYWxzSW5mbyA9IHRoaXMuY29udmVydCggbWF0ZXJpYWxzSW5mbyApO1xyXG5cdFx0dGhpcy5tYXRlcmlhbHMgPSB7fTtcclxuXHRcdHRoaXMubWF0ZXJpYWxzQXJyYXkgPSBbXTtcclxuXHRcdHRoaXMubmFtZUxvb2t1cCA9IHt9O1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb252ZXJ0OiBmdW5jdGlvbiggbWF0ZXJpYWxzSW5mbyApIHtcclxuXHJcblx0XHRpZiAoICEgdGhpcy5vcHRpb25zICkgcmV0dXJuIG1hdGVyaWFsc0luZm87XHJcblxyXG5cdFx0dmFyIGNvbnZlcnRlZCA9IHt9O1xyXG5cclxuXHRcdGZvciAoIHZhciBtbiBpbiBtYXRlcmlhbHNJbmZvICkge1xyXG5cclxuXHRcdFx0Ly8gQ29udmVydCBtYXRlcmlhbHMgaW5mbyBpbnRvIG5vcm1hbGl6ZWQgZm9ybSBiYXNlZCBvbiBvcHRpb25zXHJcblxyXG5cdFx0XHR2YXIgbWF0ID0gbWF0ZXJpYWxzSW5mb1sgbW4gXTtcclxuXHJcblx0XHRcdHZhciBjb3ZtYXQgPSB7fTtcclxuXHJcblx0XHRcdGNvbnZlcnRlZFsgbW4gXSA9IGNvdm1hdDtcclxuXHJcblx0XHRcdGZvciAoIHZhciBwcm9wIGluIG1hdCApIHtcclxuXHJcblx0XHRcdFx0dmFyIHNhdmUgPSB0cnVlO1xyXG5cdFx0XHRcdHZhciB2YWx1ZSA9IG1hdFsgcHJvcCBdO1xyXG5cdFx0XHRcdHZhciBscHJvcCA9IHByb3AudG9Mb3dlckNhc2UoKTtcclxuXHJcblx0XHRcdFx0c3dpdGNoICggbHByb3AgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSAna2QnOlxyXG5cdFx0XHRcdFx0Y2FzZSAna2EnOlxyXG5cdFx0XHRcdFx0Y2FzZSAna3MnOlxyXG5cclxuXHRcdFx0XHRcdFx0Ly8gRGlmZnVzZSBjb2xvciAoY29sb3IgdW5kZXIgd2hpdGUgbGlnaHQpIHVzaW5nIFJHQiB2YWx1ZXNcclxuXHJcblx0XHRcdFx0XHRcdGlmICggdGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5ub3JtYWxpemVSR0IgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHZhbHVlID0gWyB2YWx1ZVsgMCBdIC8gMjU1LCB2YWx1ZVsgMSBdIC8gMjU1LCB2YWx1ZVsgMiBdIC8gMjU1IF07XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMuaWdub3JlWmVyb1JHQnMgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGlmICggdmFsdWVbIDAgXSA9PT0gMCAmJiB2YWx1ZVsgMSBdID09PSAwICYmIHZhbHVlWyAxIF0gPT09IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0Ly8gaWdub3JlXHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0c2F2ZSA9IGZhbHNlO1xyXG5cclxuXHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRkZWZhdWx0OlxyXG5cclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIHNhdmUgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y292bWF0WyBscHJvcCBdID0gdmFsdWU7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGNvbnZlcnRlZDtcclxuXHJcblx0fSxcclxuXHJcblx0cHJlbG9hZDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdGZvciAoIHZhciBtbiBpbiB0aGlzLm1hdGVyaWFsc0luZm8gKSB7XHJcblxyXG5cdFx0XHR0aGlzLmNyZWF0ZSggbW4gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldEluZGV4OiBmdW5jdGlvbiggbWF0ZXJpYWxOYW1lICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLm5hbWVMb29rdXBbIG1hdGVyaWFsTmFtZSBdO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXRBc0FycmF5OiBmdW5jdGlvbigpIHtcclxuXHJcblx0XHR2YXIgaW5kZXggPSAwO1xyXG5cclxuXHRcdGZvciAoIHZhciBtbiBpbiB0aGlzLm1hdGVyaWFsc0luZm8gKSB7XHJcblxyXG5cdFx0XHR0aGlzLm1hdGVyaWFsc0FycmF5WyBpbmRleCBdID0gdGhpcy5jcmVhdGUoIG1uICk7XHJcblx0XHRcdHRoaXMubmFtZUxvb2t1cFsgbW4gXSA9IGluZGV4O1xyXG5cdFx0XHRpbmRleCArKztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMubWF0ZXJpYWxzQXJyYXk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNyZWF0ZTogZnVuY3Rpb24gKCBtYXRlcmlhbE5hbWUgKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLm1hdGVyaWFsc1sgbWF0ZXJpYWxOYW1lIF0gPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHRoaXMuY3JlYXRlTWF0ZXJpYWxfKCBtYXRlcmlhbE5hbWUgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMubWF0ZXJpYWxzWyBtYXRlcmlhbE5hbWUgXTtcclxuXHJcblx0fSxcclxuXHJcblx0Y3JlYXRlTWF0ZXJpYWxfOiBmdW5jdGlvbiAoIG1hdGVyaWFsTmFtZSApIHtcclxuXHJcblx0XHQvLyBDcmVhdGUgbWF0ZXJpYWxcclxuXHJcblx0XHR2YXIgbWF0ID0gdGhpcy5tYXRlcmlhbHNJbmZvWyBtYXRlcmlhbE5hbWUgXTtcclxuXHRcdHZhciBwYXJhbXMgPSB7XHJcblxyXG5cdFx0XHRuYW1lOiBtYXRlcmlhbE5hbWUsXHJcblx0XHRcdHNpZGU6IHRoaXMuc2lkZVxyXG5cclxuXHRcdH07XHJcblxyXG5cdFx0Zm9yICggdmFyIHByb3AgaW4gbWF0ICkge1xyXG5cclxuXHRcdFx0dmFyIHZhbHVlID0gbWF0WyBwcm9wIF07XHJcblxyXG5cdFx0XHRpZiAoIHZhbHVlID09PSAnJyApIHtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0c3dpdGNoICggcHJvcC50b0xvd2VyQ2FzZSgpICkge1xyXG5cclxuXHRcdFx0XHQvLyBOcyBpcyBtYXRlcmlhbCBzcGVjdWxhciBleHBvbmVudFxyXG5cclxuXHRcdFx0XHRjYXNlICdrZCc6XHJcblxyXG5cdFx0XHRcdFx0Ly8gRGlmZnVzZSBjb2xvciAoY29sb3IgdW5kZXIgd2hpdGUgbGlnaHQpIHVzaW5nIFJHQiB2YWx1ZXNcclxuXHJcblx0XHRcdFx0XHRwYXJhbXNbICdjb2xvcicgXSA9IG5ldyBUSFJFRS5Db2xvcigpLmZyb21BcnJheSggdmFsdWUgKTtcclxuXHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAna3MnOlxyXG5cclxuXHRcdFx0XHRcdC8vIFNwZWN1bGFyIGNvbG9yIChjb2xvciB3aGVuIGxpZ2h0IGlzIHJlZmxlY3RlZCBmcm9tIHNoaW55IHN1cmZhY2UpIHVzaW5nIFJHQiB2YWx1ZXNcclxuXHRcdFx0XHRcdHBhcmFtc1sgJ3NwZWN1bGFyJyBdID0gbmV3IFRIUkVFLkNvbG9yKCkuZnJvbUFycmF5KCB2YWx1ZSApO1xyXG5cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICdtYXBfa2QnOlxyXG5cclxuXHRcdFx0XHRcdC8vIERpZmZ1c2UgdGV4dHVyZSBtYXBcclxuXHJcblx0XHRcdFx0XHRwYXJhbXNbICdtYXAnIF0gPSB0aGlzLmxvYWRUZXh0dXJlKCB0aGlzLmJhc2VVcmwgKyB2YWx1ZSApO1xyXG5cdFx0XHRcdFx0cGFyYW1zWyAnbWFwJyBdLndyYXBTID0gdGhpcy53cmFwO1xyXG5cdFx0XHRcdFx0cGFyYW1zWyAnbWFwJyBdLndyYXBUID0gdGhpcy53cmFwO1xyXG5cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICducyc6XHJcblxyXG5cdFx0XHRcdFx0Ly8gVGhlIHNwZWN1bGFyIGV4cG9uZW50IChkZWZpbmVzIHRoZSBmb2N1cyBvZiB0aGUgc3BlY3VsYXIgaGlnaGxpZ2h0KVxyXG5cdFx0XHRcdFx0Ly8gQSBoaWdoIGV4cG9uZW50IHJlc3VsdHMgaW4gYSB0aWdodCwgY29uY2VudHJhdGVkIGhpZ2hsaWdodC4gTnMgdmFsdWVzIG5vcm1hbGx5IHJhbmdlIGZyb20gMCB0byAxMDAwLlxyXG5cclxuXHRcdFx0XHRcdHBhcmFtc1sgJ3NoaW5pbmVzcycgXSA9IHBhcnNlRmxvYXQoIHZhbHVlICk7XHJcblxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ2QnOlxyXG5cclxuXHRcdFx0XHRcdGlmICggdmFsdWUgPCAxICkge1xyXG5cclxuXHRcdFx0XHRcdFx0cGFyYW1zWyAnb3BhY2l0eScgXSA9IHZhbHVlO1xyXG5cdFx0XHRcdFx0XHRwYXJhbXNbICd0cmFuc3BhcmVudCcgXSA9IHRydWU7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICdUcic6XHJcblxyXG5cdFx0XHRcdFx0aWYgKCB2YWx1ZSA+IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRwYXJhbXNbICdvcGFjaXR5JyBdID0gMSAtIHZhbHVlO1xyXG5cdFx0XHRcdFx0XHRwYXJhbXNbICd0cmFuc3BhcmVudCcgXSA9IHRydWU7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICdtYXBfYnVtcCc6XHJcblx0XHRcdFx0Y2FzZSAnYnVtcCc6XHJcblxyXG5cdFx0XHRcdFx0Ly8gQnVtcCB0ZXh0dXJlIG1hcFxyXG5cclxuXHRcdFx0XHRcdGlmICggcGFyYW1zWyAnYnVtcE1hcCcgXSApIGJyZWFrOyAvLyBBdm9pZCBsb2FkaW5nIHR3aWNlLlxyXG5cclxuXHRcdFx0XHRcdHBhcmFtc1sgJ2J1bXBNYXAnIF0gPSB0aGlzLmxvYWRUZXh0dXJlKCB0aGlzLmJhc2VVcmwgKyB2YWx1ZSApO1xyXG5cdFx0XHRcdFx0cGFyYW1zWyAnYnVtcE1hcCcgXS53cmFwUyA9IHRoaXMud3JhcDtcclxuXHRcdFx0XHRcdHBhcmFtc1sgJ2J1bXBNYXAnIF0ud3JhcFQgPSB0aGlzLndyYXA7XHJcblxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGRlZmF1bHQ6XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5tYXRlcmlhbHNbIG1hdGVyaWFsTmFtZSBdID0gbmV3IFRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsKCBwYXJhbXMgKTtcclxuXHRcdHJldHVybiB0aGlzLm1hdGVyaWFsc1sgbWF0ZXJpYWxOYW1lIF07XHJcblxyXG5cdH0sXHJcblxyXG5cclxuXHRsb2FkVGV4dHVyZTogZnVuY3Rpb24gKCB1cmwsIG1hcHBpbmcsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcclxuXHJcblx0XHR2YXIgdGV4dHVyZTtcclxuXHRcdHZhciBsb2FkZXIgPSBUSFJFRS5Mb2FkZXIuSGFuZGxlcnMuZ2V0KCB1cmwgKTtcclxuXHRcdHZhciBtYW5hZ2VyID0gKCB0aGlzLm1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gdGhpcy5tYW5hZ2VyIDogVEhSRUUuRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xyXG5cclxuXHRcdGlmICggbG9hZGVyID09PSBudWxsICkge1xyXG5cclxuXHRcdFx0bG9hZGVyID0gbmV3IFRIUkVFLlRleHR1cmVMb2FkZXIoIG1hbmFnZXIgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBsb2FkZXIuc2V0Q3Jvc3NPcmlnaW4gKSBsb2FkZXIuc2V0Q3Jvc3NPcmlnaW4oIHRoaXMuY3Jvc3NPcmlnaW4gKTtcclxuXHRcdHRleHR1cmUgPSBsb2FkZXIubG9hZCggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcclxuXHJcblx0XHRpZiAoIG1hcHBpbmcgIT09IHVuZGVmaW5lZCApIHRleHR1cmUubWFwcGluZyA9IG1hcHBpbmc7XHJcblxyXG5cdFx0cmV0dXJuIHRleHR1cmU7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmFwcGx5KCBUSFJFRS5NVExMb2FkZXIucHJvdG90eXBlICk7XHJcblxufSx7fV0sMjA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuT0JKTG9hZGVyID0gZnVuY3Rpb24gKCBtYW5hZ2VyICkge1xyXG5cclxuXHR0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IFRIUkVFLkRlZmF1bHRMb2FkaW5nTWFuYWdlcjtcclxuXHJcblx0dGhpcy5tYXRlcmlhbHMgPSBudWxsO1xyXG5cclxufTtcclxuXHJcblRIUkVFLk9CSkxvYWRlci5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5PQkpMb2FkZXIsXHJcblxyXG5cdGxvYWQ6IGZ1bmN0aW9uICggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XHJcblxyXG5cdFx0dmFyIHNjb3BlID0gdGhpcztcclxuXHJcblx0XHR2YXIgbG9hZGVyID0gbmV3IFRIUkVFLlhIUkxvYWRlciggc2NvcGUubWFuYWdlciApO1xyXG5cdFx0bG9hZGVyLnNldFBhdGgoIHRoaXMucGF0aCApO1xyXG5cdFx0bG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCB0ZXh0ICkge1xyXG5cclxuXHRcdFx0b25Mb2FkKCBzY29wZS5wYXJzZSggdGV4dCApICk7XHJcblxyXG5cdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRQYXRoOiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdHRoaXMucGF0aCA9IHZhbHVlO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRNYXRlcmlhbHM6IGZ1bmN0aW9uICggbWF0ZXJpYWxzICkge1xyXG5cclxuXHRcdHRoaXMubWF0ZXJpYWxzID0gbWF0ZXJpYWxzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRwYXJzZTogZnVuY3Rpb24gKCB0ZXh0ICkge1xyXG5cclxuXHRcdGNvbnNvbGUudGltZSggJ09CSkxvYWRlcicgKTtcclxuXHJcblx0XHR2YXIgb2JqZWN0cyA9IFtdO1xyXG5cdFx0dmFyIG9iamVjdDtcclxuXHRcdHZhciBmb3VuZE9iamVjdHMgPSBmYWxzZTtcclxuXHRcdHZhciB2ZXJ0aWNlcyA9IFtdO1xyXG5cdFx0dmFyIG5vcm1hbHMgPSBbXTtcclxuXHRcdHZhciB1dnMgPSBbXTtcclxuXHJcblx0XHRmdW5jdGlvbiBhZGRPYmplY3QoIG5hbWUgKSB7XHJcblxyXG5cdFx0XHR2YXIgZ2VvbWV0cnkgPSB7XHJcblx0XHRcdFx0dmVydGljZXM6IFtdLFxyXG5cdFx0XHRcdG5vcm1hbHM6IFtdLFxyXG5cdFx0XHRcdHV2czogW11cclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdHZhciBtYXRlcmlhbCA9IHtcclxuXHRcdFx0XHRuYW1lOiAnJyxcclxuXHRcdFx0XHRzbW9vdGg6IHRydWVcclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdG9iamVjdCA9IHtcclxuXHRcdFx0XHRuYW1lOiBuYW1lLFxyXG5cdFx0XHRcdGdlb21ldHJ5OiBnZW9tZXRyeSxcclxuXHRcdFx0XHRtYXRlcmlhbDogbWF0ZXJpYWxcclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdG9iamVjdHMucHVzaCggb2JqZWN0ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIHBhcnNlVmVydGV4SW5kZXgoIHZhbHVlICkge1xyXG5cclxuXHRcdFx0dmFyIGluZGV4ID0gcGFyc2VJbnQoIHZhbHVlICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gKCBpbmRleCA+PSAwID8gaW5kZXggLSAxIDogaW5kZXggKyB2ZXJ0aWNlcy5sZW5ndGggLyAzICkgKiAzO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBwYXJzZU5vcm1hbEluZGV4KCB2YWx1ZSApIHtcclxuXHJcblx0XHRcdHZhciBpbmRleCA9IHBhcnNlSW50KCB2YWx1ZSApO1xyXG5cclxuXHRcdFx0cmV0dXJuICggaW5kZXggPj0gMCA/IGluZGV4IC0gMSA6IGluZGV4ICsgbm9ybWFscy5sZW5ndGggLyAzICkgKiAzO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBwYXJzZVVWSW5kZXgoIHZhbHVlICkge1xyXG5cclxuXHRcdFx0dmFyIGluZGV4ID0gcGFyc2VJbnQoIHZhbHVlICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gKCBpbmRleCA+PSAwID8gaW5kZXggLSAxIDogaW5kZXggKyB1dnMubGVuZ3RoIC8gMiApICogMjtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gYWRkVmVydGV4KCBhLCBiLCBjICkge1xyXG5cclxuXHRcdFx0b2JqZWN0Lmdlb21ldHJ5LnZlcnRpY2VzLnB1c2goXHJcblx0XHRcdFx0dmVydGljZXNbIGEgXSwgdmVydGljZXNbIGEgKyAxIF0sIHZlcnRpY2VzWyBhICsgMiBdLFxyXG5cdFx0XHRcdHZlcnRpY2VzWyBiIF0sIHZlcnRpY2VzWyBiICsgMSBdLCB2ZXJ0aWNlc1sgYiArIDIgXSxcclxuXHRcdFx0XHR2ZXJ0aWNlc1sgYyBdLCB2ZXJ0aWNlc1sgYyArIDEgXSwgdmVydGljZXNbIGMgKyAyIF1cclxuXHRcdFx0KTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gYWRkTm9ybWFsKCBhLCBiLCBjICkge1xyXG5cclxuXHRcdFx0b2JqZWN0Lmdlb21ldHJ5Lm5vcm1hbHMucHVzaChcclxuXHRcdFx0XHRub3JtYWxzWyBhIF0sIG5vcm1hbHNbIGEgKyAxIF0sIG5vcm1hbHNbIGEgKyAyIF0sXHJcblx0XHRcdFx0bm9ybWFsc1sgYiBdLCBub3JtYWxzWyBiICsgMSBdLCBub3JtYWxzWyBiICsgMiBdLFxyXG5cdFx0XHRcdG5vcm1hbHNbIGMgXSwgbm9ybWFsc1sgYyArIDEgXSwgbm9ybWFsc1sgYyArIDIgXVxyXG5cdFx0XHQpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBhZGRVViggYSwgYiwgYyApIHtcclxuXHJcblx0XHRcdG9iamVjdC5nZW9tZXRyeS51dnMucHVzaChcclxuXHRcdFx0XHR1dnNbIGEgXSwgdXZzWyBhICsgMSBdLFxyXG5cdFx0XHRcdHV2c1sgYiBdLCB1dnNbIGIgKyAxIF0sXHJcblx0XHRcdFx0dXZzWyBjIF0sIHV2c1sgYyArIDEgXVxyXG5cdFx0XHQpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBhZGRGYWNlKCBhLCBiLCBjLCBkLCAgdWEsIHViLCB1YywgdWQsIG5hLCBuYiwgbmMsIG5kICkge1xyXG5cclxuXHRcdFx0dmFyIGlhID0gcGFyc2VWZXJ0ZXhJbmRleCggYSApO1xyXG5cdFx0XHR2YXIgaWIgPSBwYXJzZVZlcnRleEluZGV4KCBiICk7XHJcblx0XHRcdHZhciBpYyA9IHBhcnNlVmVydGV4SW5kZXgoIGMgKTtcclxuXHRcdFx0dmFyIGlkO1xyXG5cclxuXHRcdFx0aWYgKCBkID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGFkZFZlcnRleCggaWEsIGliLCBpYyApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0aWQgPSBwYXJzZVZlcnRleEluZGV4KCBkICk7XHJcblxyXG5cdFx0XHRcdGFkZFZlcnRleCggaWEsIGliLCBpZCApO1xyXG5cdFx0XHRcdGFkZFZlcnRleCggaWIsIGljLCBpZCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCB1YSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRpYSA9IHBhcnNlVVZJbmRleCggdWEgKTtcclxuXHRcdFx0XHRpYiA9IHBhcnNlVVZJbmRleCggdWIgKTtcclxuXHRcdFx0XHRpYyA9IHBhcnNlVVZJbmRleCggdWMgKTtcclxuXHJcblx0XHRcdFx0aWYgKCBkID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0YWRkVVYoIGlhLCBpYiwgaWMgKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRpZCA9IHBhcnNlVVZJbmRleCggdWQgKTtcclxuXHJcblx0XHRcdFx0XHRhZGRVViggaWEsIGliLCBpZCApO1xyXG5cdFx0XHRcdFx0YWRkVVYoIGliLCBpYywgaWQgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBuYSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRpYSA9IHBhcnNlTm9ybWFsSW5kZXgoIG5hICk7XHJcblx0XHRcdFx0aWIgPSBwYXJzZU5vcm1hbEluZGV4KCBuYiApO1xyXG5cdFx0XHRcdGljID0gcGFyc2VOb3JtYWxJbmRleCggbmMgKTtcclxuXHJcblx0XHRcdFx0aWYgKCBkID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0YWRkTm9ybWFsKCBpYSwgaWIsIGljICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0aWQgPSBwYXJzZU5vcm1hbEluZGV4KCBuZCApO1xyXG5cclxuXHRcdFx0XHRcdGFkZE5vcm1hbCggaWEsIGliLCBpZCApO1xyXG5cdFx0XHRcdFx0YWRkTm9ybWFsKCBpYiwgaWMsIGlkICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0YWRkT2JqZWN0KCAnJyApO1xyXG5cclxuXHRcdC8vIHYgZmxvYXQgZmxvYXQgZmxvYXRcclxuXHRcdHZhciB2ZXJ0ZXhfcGF0dGVybiA9IC9edlxccysoW1xcZHxcXC58XFwrfFxcLXxlfEVdKylcXHMrKFtcXGR8XFwufFxcK3xcXC18ZXxFXSspXFxzKyhbXFxkfFxcLnxcXCt8XFwtfGV8RV0rKS87XHJcblxyXG5cdFx0Ly8gdm4gZmxvYXQgZmxvYXQgZmxvYXRcclxuXHRcdHZhciBub3JtYWxfcGF0dGVybiA9IC9edm5cXHMrKFtcXGR8XFwufFxcK3xcXC18ZXxFXSspXFxzKyhbXFxkfFxcLnxcXCt8XFwtfGV8RV0rKVxccysoW1xcZHxcXC58XFwrfFxcLXxlfEVdKykvO1xyXG5cclxuXHRcdC8vIHZ0IGZsb2F0IGZsb2F0XHJcblx0XHR2YXIgdXZfcGF0dGVybiA9IC9ednRcXHMrKFtcXGR8XFwufFxcK3xcXC18ZXxFXSspXFxzKyhbXFxkfFxcLnxcXCt8XFwtfGV8RV0rKS87XHJcblxyXG5cdFx0Ly8gZiB2ZXJ0ZXggdmVydGV4IHZlcnRleCAuLi5cclxuXHRcdHZhciBmYWNlX3BhdHRlcm4xID0gL15mXFxzKygtP1xcZCspXFxzKygtP1xcZCspXFxzKygtP1xcZCspKD86XFxzKygtP1xcZCspKT8vO1xyXG5cclxuXHRcdC8vIGYgdmVydGV4L3V2IHZlcnRleC91diB2ZXJ0ZXgvdXYgLi4uXHJcblx0XHR2YXIgZmFjZV9wYXR0ZXJuMiA9IC9eZlxccysoKC0/XFxkKylcXC8oLT9cXGQrKSlcXHMrKCgtP1xcZCspXFwvKC0/XFxkKykpXFxzKygoLT9cXGQrKVxcLygtP1xcZCspKSg/OlxccysoKC0/XFxkKylcXC8oLT9cXGQrKSkpPy87XHJcblxyXG5cdFx0Ly8gZiB2ZXJ0ZXgvdXYvbm9ybWFsIHZlcnRleC91di9ub3JtYWwgdmVydGV4L3V2L25vcm1hbCAuLi5cclxuXHRcdHZhciBmYWNlX3BhdHRlcm4zID0gL15mXFxzKygoLT9cXGQrKVxcLygtP1xcZCspXFwvKC0/XFxkKykpXFxzKygoLT9cXGQrKVxcLygtP1xcZCspXFwvKC0/XFxkKykpXFxzKygoLT9cXGQrKVxcLygtP1xcZCspXFwvKC0/XFxkKykpKD86XFxzKygoLT9cXGQrKVxcLygtP1xcZCspXFwvKC0/XFxkKykpKT8vO1xyXG5cclxuXHRcdC8vIGYgdmVydGV4Ly9ub3JtYWwgdmVydGV4Ly9ub3JtYWwgdmVydGV4Ly9ub3JtYWwgLi4uXHJcblx0XHR2YXIgZmFjZV9wYXR0ZXJuNCA9IC9eZlxccysoKC0/XFxkKylcXC9cXC8oLT9cXGQrKSlcXHMrKCgtP1xcZCspXFwvXFwvKC0/XFxkKykpXFxzKygoLT9cXGQrKVxcL1xcLygtP1xcZCspKSg/OlxccysoKC0/XFxkKylcXC9cXC8oLT9cXGQrKSkpPy87XHJcblxyXG5cdFx0dmFyIG9iamVjdF9wYXR0ZXJuID0gL15bb2ddXFxzKyguKykvO1xyXG5cclxuXHRcdHZhciBzbW9vdGhpbmdfcGF0dGVybiA9IC9ec1xccysoWzAxXXxvbnxvZmYpLztcclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdHZhciBsaW5lcyA9IHRleHQuc3BsaXQoICdcXG4nICk7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIGxpbmUgPSBsaW5lc1sgaSBdO1xyXG5cdFx0XHRsaW5lID0gbGluZS50cmltKCk7XHJcblxyXG5cdFx0XHR2YXIgcmVzdWx0O1xyXG5cclxuXHRcdFx0aWYgKCBsaW5lLmxlbmd0aCA9PT0gMCB8fCBsaW5lLmNoYXJBdCggMCApID09PSAnIycgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggKCByZXN1bHQgPSB2ZXJ0ZXhfcGF0dGVybi5leGVjKCBsaW5lICkgKSAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0Ly8gW1widiAxLjAgMi4wIDMuMFwiLCBcIjEuMFwiLCBcIjIuMFwiLCBcIjMuMFwiXVxyXG5cclxuXHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKFxyXG5cdFx0XHRcdFx0cGFyc2VGbG9hdCggcmVzdWx0WyAxIF0gKSxcclxuXHRcdFx0XHRcdHBhcnNlRmxvYXQoIHJlc3VsdFsgMiBdICksXHJcblx0XHRcdFx0XHRwYXJzZUZsb2F0KCByZXN1bHRbIDMgXSApXHJcblx0XHRcdFx0KTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoICggcmVzdWx0ID0gbm9ybWFsX3BhdHRlcm4uZXhlYyggbGluZSApICkgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdC8vIFtcInZuIDEuMCAyLjAgMy4wXCIsIFwiMS4wXCIsIFwiMi4wXCIsIFwiMy4wXCJdXHJcblxyXG5cdFx0XHRcdG5vcm1hbHMucHVzaChcclxuXHRcdFx0XHRcdHBhcnNlRmxvYXQoIHJlc3VsdFsgMSBdICksXHJcblx0XHRcdFx0XHRwYXJzZUZsb2F0KCByZXN1bHRbIDIgXSApLFxyXG5cdFx0XHRcdFx0cGFyc2VGbG9hdCggcmVzdWx0WyAzIF0gKVxyXG5cdFx0XHRcdCk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCAoIHJlc3VsdCA9IHV2X3BhdHRlcm4uZXhlYyggbGluZSApICkgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdC8vIFtcInZ0IDAuMSAwLjJcIiwgXCIwLjFcIiwgXCIwLjJcIl1cclxuXHJcblx0XHRcdFx0dXZzLnB1c2goXHJcblx0XHRcdFx0XHRwYXJzZUZsb2F0KCByZXN1bHRbIDEgXSApLFxyXG5cdFx0XHRcdFx0cGFyc2VGbG9hdCggcmVzdWx0WyAyIF0gKVxyXG5cdFx0XHRcdCk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCAoIHJlc3VsdCA9IGZhY2VfcGF0dGVybjEuZXhlYyggbGluZSApICkgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdC8vIFtcImYgMSAyIDNcIiwgXCIxXCIsIFwiMlwiLCBcIjNcIiwgdW5kZWZpbmVkXVxyXG5cclxuXHRcdFx0XHRhZGRGYWNlKFxyXG5cdFx0XHRcdFx0cmVzdWx0WyAxIF0sIHJlc3VsdFsgMiBdLCByZXN1bHRbIDMgXSwgcmVzdWx0WyA0IF1cclxuXHRcdFx0XHQpO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggKCByZXN1bHQgPSBmYWNlX3BhdHRlcm4yLmV4ZWMoIGxpbmUgKSApICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHQvLyBbXCJmIDEvMSAyLzIgMy8zXCIsIFwiIDEvMVwiLCBcIjFcIiwgXCIxXCIsIFwiIDIvMlwiLCBcIjJcIiwgXCIyXCIsIFwiIDMvM1wiLCBcIjNcIiwgXCIzXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWRdXHJcblxyXG5cdFx0XHRcdGFkZEZhY2UoXHJcblx0XHRcdFx0XHRyZXN1bHRbIDIgXSwgcmVzdWx0WyA1IF0sIHJlc3VsdFsgOCBdLCByZXN1bHRbIDExIF0sXHJcblx0XHRcdFx0XHRyZXN1bHRbIDMgXSwgcmVzdWx0WyA2IF0sIHJlc3VsdFsgOSBdLCByZXN1bHRbIDEyIF1cclxuXHRcdFx0XHQpO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggKCByZXN1bHQgPSBmYWNlX3BhdHRlcm4zLmV4ZWMoIGxpbmUgKSApICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHQvLyBbXCJmIDEvMS8xIDIvMi8yIDMvMy8zXCIsIFwiIDEvMS8xXCIsIFwiMVwiLCBcIjFcIiwgXCIxXCIsIFwiIDIvMi8yXCIsIFwiMlwiLCBcIjJcIiwgXCIyXCIsIFwiIDMvMy8zXCIsIFwiM1wiLCBcIjNcIiwgXCIzXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZF1cclxuXHJcblx0XHRcdFx0YWRkRmFjZShcclxuXHRcdFx0XHRcdHJlc3VsdFsgMiBdLCByZXN1bHRbIDYgXSwgcmVzdWx0WyAxMCBdLCByZXN1bHRbIDE0IF0sXHJcblx0XHRcdFx0XHRyZXN1bHRbIDMgXSwgcmVzdWx0WyA3IF0sIHJlc3VsdFsgMTEgXSwgcmVzdWx0WyAxNSBdLFxyXG5cdFx0XHRcdFx0cmVzdWx0WyA0IF0sIHJlc3VsdFsgOCBdLCByZXN1bHRbIDEyIF0sIHJlc3VsdFsgMTYgXVxyXG5cdFx0XHRcdCk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCAoIHJlc3VsdCA9IGZhY2VfcGF0dGVybjQuZXhlYyggbGluZSApICkgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdC8vIFtcImYgMS8vMSAyLy8yIDMvLzNcIiwgXCIgMS8vMVwiLCBcIjFcIiwgXCIxXCIsIFwiIDIvLzJcIiwgXCIyXCIsIFwiMlwiLCBcIiAzLy8zXCIsIFwiM1wiLCBcIjNcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZF1cclxuXHJcblx0XHRcdFx0YWRkRmFjZShcclxuXHRcdFx0XHRcdHJlc3VsdFsgMiBdLCByZXN1bHRbIDUgXSwgcmVzdWx0WyA4IF0sIHJlc3VsdFsgMTEgXSxcclxuXHRcdFx0XHRcdHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCxcclxuXHRcdFx0XHRcdHJlc3VsdFsgMyBdLCByZXN1bHRbIDYgXSwgcmVzdWx0WyA5IF0sIHJlc3VsdFsgMTIgXVxyXG5cdFx0XHRcdCk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCAoIHJlc3VsdCA9IG9iamVjdF9wYXR0ZXJuLmV4ZWMoIGxpbmUgKSApICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHQvLyBvIG9iamVjdF9uYW1lXHJcblx0XHRcdFx0Ly8gb3JcclxuXHRcdFx0XHQvLyBnIGdyb3VwX25hbWVcclxuXHJcblx0XHRcdFx0dmFyIG5hbWUgPSByZXN1bHRbIDEgXS50cmltKCk7XHJcblxyXG5cdFx0XHRcdGlmICggZm91bmRPYmplY3RzID09PSBmYWxzZSApIHtcclxuXHJcblx0XHRcdFx0XHRmb3VuZE9iamVjdHMgPSB0cnVlO1xyXG5cdFx0XHRcdFx0b2JqZWN0Lm5hbWUgPSBuYW1lO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdGFkZE9iamVjdCggbmFtZSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCAvXnVzZW10bCAvLnRlc3QoIGxpbmUgKSApIHtcclxuXHJcblx0XHRcdFx0Ly8gbWF0ZXJpYWxcclxuXHJcblx0XHRcdFx0b2JqZWN0Lm1hdGVyaWFsLm5hbWUgPSBsaW5lLnN1YnN0cmluZyggNyApLnRyaW0oKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIC9ebXRsbGliIC8udGVzdCggbGluZSApICkge1xyXG5cclxuXHRcdFx0XHQvLyBtdGwgZmlsZVxyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggKCByZXN1bHQgPSBzbW9vdGhpbmdfcGF0dGVybi5leGVjKCBsaW5lICkgKSAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0Ly8gc21vb3RoIHNoYWRpbmdcclxuXHJcblx0XHRcdFx0b2JqZWN0Lm1hdGVyaWFsLnNtb290aCA9IHJlc3VsdFsgMSBdID09PSBcIjFcIiB8fCByZXN1bHRbIDEgXSA9PT0gXCJvblwiO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBcIlVuZXhwZWN0ZWQgbGluZTogXCIgKyBsaW5lICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBjb250YWluZXIgPSBuZXcgVEhSRUUuR3JvdXAoKTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBvYmplY3RzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRvYmplY3QgPSBvYmplY3RzWyBpIF07XHJcblx0XHRcdHZhciBnZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeTtcclxuXHJcblx0XHRcdHZhciBidWZmZXJnZW9tZXRyeSA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpO1xyXG5cclxuXHRcdFx0YnVmZmVyZ2VvbWV0cnkuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgRmxvYXQzMkFycmF5KCBnZW9tZXRyeS52ZXJ0aWNlcyApLCAzICkgKTtcclxuXHJcblx0XHRcdGlmICggZ2VvbWV0cnkubm9ybWFscy5sZW5ndGggPiAwICkge1xyXG5cclxuXHRcdFx0XHRidWZmZXJnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgRmxvYXQzMkFycmF5KCBnZW9tZXRyeS5ub3JtYWxzICksIDMgKSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0YnVmZmVyZ2VvbWV0cnkuY29tcHV0ZVZlcnRleE5vcm1hbHMoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggZ2VvbWV0cnkudXZzLmxlbmd0aCA+IDAgKSB7XHJcblxyXG5cdFx0XHRcdGJ1ZmZlcmdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ3V2JywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IEZsb2F0MzJBcnJheSggZ2VvbWV0cnkudXZzICksIDIgKSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIG1hdGVyaWFsO1xyXG5cclxuXHRcdFx0aWYgKCB0aGlzLm1hdGVyaWFscyAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0bWF0ZXJpYWwgPSB0aGlzLm1hdGVyaWFscy5jcmVhdGUoIG9iamVjdC5tYXRlcmlhbC5uYW1lICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoICFtYXRlcmlhbCApIHtcclxuXHJcblx0XHRcdFx0bWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwoKTtcclxuXHRcdFx0XHRtYXRlcmlhbC5uYW1lID0gb2JqZWN0Lm1hdGVyaWFsLm5hbWU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRtYXRlcmlhbC5zaGFkaW5nID0gb2JqZWN0Lm1hdGVyaWFsLnNtb290aCA/IFRIUkVFLlNtb290aFNoYWRpbmcgOiBUSFJFRS5GbGF0U2hhZGluZztcclxuXHJcblx0XHRcdHZhciBtZXNoID0gbmV3IFRIUkVFLk1lc2goIGJ1ZmZlcmdlb21ldHJ5LCBtYXRlcmlhbCApO1xyXG5cdFx0XHRtZXNoLm5hbWUgPSBvYmplY3QubmFtZTtcclxuXHJcblx0XHRcdGNvbnRhaW5lci5hZGQoIG1lc2ggKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc29sZS50aW1lRW5kKCAnT0JKTG9hZGVyJyApO1xyXG5cclxuXHRcdHJldHVybiBjb250YWluZXI7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxufSx7fV0sMjE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIHNlbGYgPSBzZWxmIHx8IHt9Oy8vIEZpbGU6c3JjL1RocmVlLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG52YXIgVEhSRUUgPSB7IFJFVklTSU9OOiAnNzQnIH07XHJcblxyXG4vL1xyXG5cclxuaWYgKCB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgKSB7XHJcblxyXG5cdGRlZmluZSggJ3RocmVlJywgVEhSRUUgKTtcclxuXHJcbn0gZWxzZSBpZiAoICd1bmRlZmluZWQnICE9PSB0eXBlb2YgZXhwb3J0cyAmJiAndW5kZWZpbmVkJyAhPT0gdHlwZW9mIG1vZHVsZSApIHtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBUSFJFRTtcclxuXHJcbn1cclxuXHJcbi8vXHJcblxyXG5pZiAoIE51bWJlci5FUFNJTE9OID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdE51bWJlci5FUFNJTE9OID0gTWF0aC5wb3coIDIsIC0gNTIgKTtcclxuXHJcbn1cclxuXHJcbi8vXHJcblxyXG5pZiAoIE1hdGguc2lnbiA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHQvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL3NpZ25cclxuXHJcblx0TWF0aC5zaWduID0gZnVuY3Rpb24gKCB4ICkge1xyXG5cclxuXHRcdHJldHVybiAoIHggPCAwICkgPyAtIDEgOiAoIHggPiAwICkgPyAxIDogKyB4O1xyXG5cclxuXHR9O1xyXG5cclxufVxyXG5cclxuaWYgKCBGdW5jdGlvbi5wcm90b3R5cGUubmFtZSA9PT0gdW5kZWZpbmVkICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHQvLyBNaXNzaW5nIGluIElFOS0xMS5cclxuXHQvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9GdW5jdGlvbi9uYW1lXHJcblxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggRnVuY3Rpb24ucHJvdG90eXBlLCAnbmFtZScsIHtcclxuXHJcblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzLnRvU3RyaW5nKCkubWF0Y2goIC9eXFxzKmZ1bmN0aW9uXFxzKihcXFMqKVxccypcXCgvIClbIDEgXTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0gKTtcclxuXHJcbn1cclxuXHJcbmlmICggT2JqZWN0LmFzc2lnbiA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHQvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvYXNzaWduXHJcblxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggT2JqZWN0LCAnYXNzaWduJywge1xyXG5cclxuXHRcdHdyaXRhYmxlOiB0cnVlLFxyXG5cdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxyXG5cclxuXHRcdHZhbHVlOiBmdW5jdGlvbiAoIHRhcmdldCApIHtcclxuXHJcblx0XHRcdCd1c2Ugc3RyaWN0JztcclxuXHJcblx0XHRcdGlmICggdGFyZ2V0ID09PSB1bmRlZmluZWQgfHwgdGFyZ2V0ID09PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCBcIkNhbm5vdCBjb252ZXJ0IGZpcnN0IGFyZ3VtZW50IHRvIG9iamVjdFwiICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgdG8gPSBPYmplY3QoIHRhcmdldCApO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcclxuXHJcblx0XHRcdFx0dmFyIG5leHRTb3VyY2UgPSBhcmd1bWVudHNbIGkgXTtcclxuXHJcblx0XHRcdFx0aWYgKCBuZXh0U291cmNlID09PSB1bmRlZmluZWQgfHwgbmV4dFNvdXJjZSA9PT0gbnVsbCApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0XHRuZXh0U291cmNlID0gT2JqZWN0KCBuZXh0U291cmNlICk7XHJcblxyXG5cdFx0XHRcdHZhciBrZXlzQXJyYXkgPSBPYmplY3Qua2V5cyggbmV4dFNvdXJjZSApO1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgbmV4dEluZGV4ID0gMCwgbGVuID0ga2V5c0FycmF5Lmxlbmd0aDsgbmV4dEluZGV4ICE9PSBsZW47ICsrIG5leHRJbmRleCApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgbmV4dEtleSA9IGtleXNBcnJheVsgbmV4dEluZGV4IF07XHJcblx0XHRcdFx0XHR2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoIG5leHRTb3VyY2UsIG5leHRLZXkgKTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGRlc2MgIT09IHVuZGVmaW5lZCAmJiBkZXNjLmVudW1lcmFibGUgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR0b1sgbmV4dEtleSBdID0gbmV4dFNvdXJjZVsgbmV4dEtleSBdO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHRvO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSApO1xyXG5cclxufVxyXG5cclxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL01vdXNlRXZlbnQuYnV0dG9uXHJcblxyXG5USFJFRS5NT1VTRSA9IHsgTEVGVDogMCwgTUlERExFOiAxLCBSSUdIVDogMiB9O1xyXG5cclxuLy8gR0wgU1RBVEUgQ09OU1RBTlRTXHJcblxyXG5USFJFRS5DdWxsRmFjZU5vbmUgPSAwO1xyXG5USFJFRS5DdWxsRmFjZUJhY2sgPSAxO1xyXG5USFJFRS5DdWxsRmFjZUZyb250ID0gMjtcclxuVEhSRUUuQ3VsbEZhY2VGcm9udEJhY2sgPSAzO1xyXG5cclxuVEhSRUUuRnJvbnRGYWNlRGlyZWN0aW9uQ1cgPSAwO1xyXG5USFJFRS5Gcm9udEZhY2VEaXJlY3Rpb25DQ1cgPSAxO1xyXG5cclxuLy8gU0hBRE9XSU5HIFRZUEVTXHJcblxyXG5USFJFRS5CYXNpY1NoYWRvd01hcCA9IDA7XHJcblRIUkVFLlBDRlNoYWRvd01hcCA9IDE7XHJcblRIUkVFLlBDRlNvZnRTaGFkb3dNYXAgPSAyO1xyXG5cclxuLy8gTUFURVJJQUwgQ09OU1RBTlRTXHJcblxyXG4vLyBzaWRlXHJcblxyXG5USFJFRS5Gcm9udFNpZGUgPSAwO1xyXG5USFJFRS5CYWNrU2lkZSA9IDE7XHJcblRIUkVFLkRvdWJsZVNpZGUgPSAyO1xyXG5cclxuLy8gc2hhZGluZ1xyXG5cclxuVEhSRUUuRmxhdFNoYWRpbmcgPSAxO1xyXG5USFJFRS5TbW9vdGhTaGFkaW5nID0gMjtcclxuXHJcbi8vIGNvbG9yc1xyXG5cclxuVEhSRUUuTm9Db2xvcnMgPSAwO1xyXG5USFJFRS5GYWNlQ29sb3JzID0gMTtcclxuVEhSRUUuVmVydGV4Q29sb3JzID0gMjtcclxuXHJcbi8vIGJsZW5kaW5nIG1vZGVzXHJcblxyXG5USFJFRS5Ob0JsZW5kaW5nID0gMDtcclxuVEhSRUUuTm9ybWFsQmxlbmRpbmcgPSAxO1xyXG5USFJFRS5BZGRpdGl2ZUJsZW5kaW5nID0gMjtcclxuVEhSRUUuU3VidHJhY3RpdmVCbGVuZGluZyA9IDM7XHJcblRIUkVFLk11bHRpcGx5QmxlbmRpbmcgPSA0O1xyXG5USFJFRS5DdXN0b21CbGVuZGluZyA9IDU7XHJcblxyXG4vLyBjdXN0b20gYmxlbmRpbmcgZXF1YXRpb25zXHJcbi8vIChudW1iZXJzIHN0YXJ0IGZyb20gMTAwIG5vdCB0byBjbGFzaCB3aXRoIG90aGVyXHJcbi8vIG1hcHBpbmdzIHRvIE9wZW5HTCBjb25zdGFudHMgZGVmaW5lZCBpbiBUZXh0dXJlLmpzKVxyXG5cclxuVEhSRUUuQWRkRXF1YXRpb24gPSAxMDA7XHJcblRIUkVFLlN1YnRyYWN0RXF1YXRpb24gPSAxMDE7XHJcblRIUkVFLlJldmVyc2VTdWJ0cmFjdEVxdWF0aW9uID0gMTAyO1xyXG5USFJFRS5NaW5FcXVhdGlvbiA9IDEwMztcclxuVEhSRUUuTWF4RXF1YXRpb24gPSAxMDQ7XHJcblxyXG4vLyBjdXN0b20gYmxlbmRpbmcgZGVzdGluYXRpb24gZmFjdG9yc1xyXG5cclxuVEhSRUUuWmVyb0ZhY3RvciA9IDIwMDtcclxuVEhSRUUuT25lRmFjdG9yID0gMjAxO1xyXG5USFJFRS5TcmNDb2xvckZhY3RvciA9IDIwMjtcclxuVEhSRUUuT25lTWludXNTcmNDb2xvckZhY3RvciA9IDIwMztcclxuVEhSRUUuU3JjQWxwaGFGYWN0b3IgPSAyMDQ7XHJcblRIUkVFLk9uZU1pbnVzU3JjQWxwaGFGYWN0b3IgPSAyMDU7XHJcblRIUkVFLkRzdEFscGhhRmFjdG9yID0gMjA2O1xyXG5USFJFRS5PbmVNaW51c0RzdEFscGhhRmFjdG9yID0gMjA3O1xyXG5cclxuLy8gY3VzdG9tIGJsZW5kaW5nIHNvdXJjZSBmYWN0b3JzXHJcblxyXG4vL1RIUkVFLlplcm9GYWN0b3IgPSAyMDA7XHJcbi8vVEhSRUUuT25lRmFjdG9yID0gMjAxO1xyXG4vL1RIUkVFLlNyY0FscGhhRmFjdG9yID0gMjA0O1xyXG4vL1RIUkVFLk9uZU1pbnVzU3JjQWxwaGFGYWN0b3IgPSAyMDU7XHJcbi8vVEhSRUUuRHN0QWxwaGFGYWN0b3IgPSAyMDY7XHJcbi8vVEhSRUUuT25lTWludXNEc3RBbHBoYUZhY3RvciA9IDIwNztcclxuVEhSRUUuRHN0Q29sb3JGYWN0b3IgPSAyMDg7XHJcblRIUkVFLk9uZU1pbnVzRHN0Q29sb3JGYWN0b3IgPSAyMDk7XHJcblRIUkVFLlNyY0FscGhhU2F0dXJhdGVGYWN0b3IgPSAyMTA7XHJcblxyXG4vLyBkZXB0aCBtb2Rlc1xyXG5cclxuVEhSRUUuTmV2ZXJEZXB0aCA9IDA7XHJcblRIUkVFLkFsd2F5c0RlcHRoID0gMTtcclxuVEhSRUUuTGVzc0RlcHRoID0gMjtcclxuVEhSRUUuTGVzc0VxdWFsRGVwdGggPSAzO1xyXG5USFJFRS5FcXVhbERlcHRoID0gNDtcclxuVEhSRUUuR3JlYXRlckVxdWFsRGVwdGggPSA1O1xyXG5USFJFRS5HcmVhdGVyRGVwdGggPSA2O1xyXG5USFJFRS5Ob3RFcXVhbERlcHRoID0gNztcclxuXHJcblxyXG4vLyBURVhUVVJFIENPTlNUQU5UU1xyXG5cclxuVEhSRUUuTXVsdGlwbHlPcGVyYXRpb24gPSAwO1xyXG5USFJFRS5NaXhPcGVyYXRpb24gPSAxO1xyXG5USFJFRS5BZGRPcGVyYXRpb24gPSAyO1xyXG5cclxuLy8gTWFwcGluZyBtb2Rlc1xyXG5cclxuVEhSRUUuVVZNYXBwaW5nID0gMzAwO1xyXG5cclxuVEhSRUUuQ3ViZVJlZmxlY3Rpb25NYXBwaW5nID0gMzAxO1xyXG5USFJFRS5DdWJlUmVmcmFjdGlvbk1hcHBpbmcgPSAzMDI7XHJcblxyXG5USFJFRS5FcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZyA9IDMwMztcclxuVEhSRUUuRXF1aXJlY3Rhbmd1bGFyUmVmcmFjdGlvbk1hcHBpbmcgPSAzMDQ7XHJcblxyXG5USFJFRS5TcGhlcmljYWxSZWZsZWN0aW9uTWFwcGluZyA9IDMwNTtcclxuXHJcbi8vIFdyYXBwaW5nIG1vZGVzXHJcblxyXG5USFJFRS5SZXBlYXRXcmFwcGluZyA9IDEwMDA7XHJcblRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmcgPSAxMDAxO1xyXG5USFJFRS5NaXJyb3JlZFJlcGVhdFdyYXBwaW5nID0gMTAwMjtcclxuXHJcbi8vIEZpbHRlcnNcclxuXHJcblRIUkVFLk5lYXJlc3RGaWx0ZXIgPSAxMDAzO1xyXG5USFJFRS5OZWFyZXN0TWlwTWFwTmVhcmVzdEZpbHRlciA9IDEwMDQ7XHJcblRIUkVFLk5lYXJlc3RNaXBNYXBMaW5lYXJGaWx0ZXIgPSAxMDA1O1xyXG5USFJFRS5MaW5lYXJGaWx0ZXIgPSAxMDA2O1xyXG5USFJFRS5MaW5lYXJNaXBNYXBOZWFyZXN0RmlsdGVyID0gMTAwNztcclxuVEhSRUUuTGluZWFyTWlwTWFwTGluZWFyRmlsdGVyID0gMTAwODtcclxuXHJcbi8vIERhdGEgdHlwZXNcclxuXHJcblRIUkVFLlVuc2lnbmVkQnl0ZVR5cGUgPSAxMDA5O1xyXG5USFJFRS5CeXRlVHlwZSA9IDEwMTA7XHJcblRIUkVFLlNob3J0VHlwZSA9IDEwMTE7XHJcblRIUkVFLlVuc2lnbmVkU2hvcnRUeXBlID0gMTAxMjtcclxuVEhSRUUuSW50VHlwZSA9IDEwMTM7XHJcblRIUkVFLlVuc2lnbmVkSW50VHlwZSA9IDEwMTQ7XHJcblRIUkVFLkZsb2F0VHlwZSA9IDEwMTU7XHJcblRIUkVFLkhhbGZGbG9hdFR5cGUgPSAxMDI1O1xyXG5cclxuLy8gUGl4ZWwgdHlwZXNcclxuXHJcbi8vVEhSRUUuVW5zaWduZWRCeXRlVHlwZSA9IDEwMDk7XHJcblRIUkVFLlVuc2lnbmVkU2hvcnQ0NDQ0VHlwZSA9IDEwMTY7XHJcblRIUkVFLlVuc2lnbmVkU2hvcnQ1NTUxVHlwZSA9IDEwMTc7XHJcblRIUkVFLlVuc2lnbmVkU2hvcnQ1NjVUeXBlID0gMTAxODtcclxuXHJcbi8vIFBpeGVsIGZvcm1hdHNcclxuXHJcblRIUkVFLkFscGhhRm9ybWF0ID0gMTAxOTtcclxuVEhSRUUuUkdCRm9ybWF0ID0gMTAyMDtcclxuVEhSRUUuUkdCQUZvcm1hdCA9IDEwMjE7XHJcblRIUkVFLkx1bWluYW5jZUZvcm1hdCA9IDEwMjI7XHJcblRIUkVFLkx1bWluYW5jZUFscGhhRm9ybWF0ID0gMTAyMztcclxuLy8gVEhSRUUuUkdCRUZvcm1hdCBoYW5kbGVkIGFzIFRIUkVFLlJHQkFGb3JtYXQgaW4gc2hhZGVyc1xyXG5USFJFRS5SR0JFRm9ybWF0ID0gVEhSRUUuUkdCQUZvcm1hdDsgLy8xMDI0O1xyXG5cclxuLy8gRERTIC8gU1QzQyBDb21wcmVzc2VkIHRleHR1cmUgZm9ybWF0c1xyXG5cclxuVEhSRUUuUkdCX1MzVENfRFhUMV9Gb3JtYXQgPSAyMDAxO1xyXG5USFJFRS5SR0JBX1MzVENfRFhUMV9Gb3JtYXQgPSAyMDAyO1xyXG5USFJFRS5SR0JBX1MzVENfRFhUM19Gb3JtYXQgPSAyMDAzO1xyXG5USFJFRS5SR0JBX1MzVENfRFhUNV9Gb3JtYXQgPSAyMDA0O1xyXG5cclxuXHJcbi8vIFBWUlRDIGNvbXByZXNzZWQgdGV4dHVyZSBmb3JtYXRzXHJcblxyXG5USFJFRS5SR0JfUFZSVENfNEJQUFYxX0Zvcm1hdCA9IDIxMDA7XHJcblRIUkVFLlJHQl9QVlJUQ18yQlBQVjFfRm9ybWF0ID0gMjEwMTtcclxuVEhSRUUuUkdCQV9QVlJUQ180QlBQVjFfRm9ybWF0ID0gMjEwMjtcclxuVEhSRUUuUkdCQV9QVlJUQ18yQlBQVjFfRm9ybWF0ID0gMjEwMztcclxuXHJcbi8vIEVUQyBjb21wcmVzc2VkIHRleHR1cmUgZm9ybWF0c1xyXG5cclxuVEhSRUUuUkdCX0VUQzFfRm9ybWF0ID0gMjE1MTtcclxuXHJcbi8vIExvb3Agc3R5bGVzIGZvciBBbmltYXRpb25BY3Rpb25cclxuXHJcblRIUkVFLkxvb3BPbmNlID0gMjIwMDtcclxuVEhSRUUuTG9vcFJlcGVhdCA9IDIyMDE7XHJcblRIUkVFLkxvb3BQaW5nUG9uZyA9IDIyMDI7XHJcblxyXG4vLyBJbnRlcnBvbGF0aW9uXHJcblxyXG5USFJFRS5JbnRlcnBvbGF0ZURpc2NyZXRlID0gMjMwMDtcclxuVEhSRUUuSW50ZXJwb2xhdGVMaW5lYXIgPSAyMzAxO1xyXG5USFJFRS5JbnRlcnBvbGF0ZVNtb290aCA9IDIzMDI7XHJcblxyXG4vLyBJbnRlcnBvbGFudCBlbmRpbmcgbW9kZXNcclxuXHJcblRIUkVFLlplcm9DdXJ2YXR1cmVFbmRpbmcgPSAyNDAwO1xyXG5USFJFRS5aZXJvU2xvcGVFbmRpbmcgPSAyNDAxO1xyXG5USFJFRS5XcmFwQXJvdW5kRW5kaW5nID0gMjQwMjtcclxuXHJcbi8vIFRyaWFuZ2xlIERyYXcgbW9kZXNcclxuXHJcblRIUkVFLlRyaWFuZ2xlc0RyYXdNb2RlID0gMDtcclxuVEhSRUUuVHJpYW5nbGVTdHJpcERyYXdNb2RlID0gMTtcclxuVEhSRUUuVHJpYW5nbGVGYW5EcmF3TW9kZSA9IDI7XHJcblxyXG4vLyBGaWxlOnNyYy9tYXRoL0NvbG9yLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5Db2xvciA9IGZ1bmN0aW9uICggY29sb3IgKSB7XHJcblxyXG5cdGlmICggYXJndW1lbnRzLmxlbmd0aCA9PT0gMyApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5mcm9tQXJyYXkoIGFyZ3VtZW50cyApO1xyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiB0aGlzLnNldCggY29sb3IgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Db2xvci5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5Db2xvcixcclxuXHJcblx0cjogMSwgZzogMSwgYjogMSxcclxuXHJcblx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdGlmICggdmFsdWUgaW5zdGFuY2VvZiBUSFJFRS5Db2xvciApIHtcclxuXHJcblx0XHRcdHRoaXMuY29weSggdmFsdWUgKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICkge1xyXG5cclxuXHRcdFx0dGhpcy5zZXRIZXgoIHZhbHVlICk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyApIHtcclxuXHJcblx0XHRcdHRoaXMuc2V0U3R5bGUoIHZhbHVlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xyXG5cclxuXHRcdHRoaXMuciA9IHNjYWxhcjtcclxuXHRcdHRoaXMuZyA9IHNjYWxhcjtcclxuXHRcdHRoaXMuYiA9IHNjYWxhcjtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0SGV4OiBmdW5jdGlvbiAoIGhleCApIHtcclxuXHJcblx0XHRoZXggPSBNYXRoLmZsb29yKCBoZXggKTtcclxuXHJcblx0XHR0aGlzLnIgPSAoIGhleCA+PiAxNiAmIDI1NSApIC8gMjU1O1xyXG5cdFx0dGhpcy5nID0gKCBoZXggPj4gOCAmIDI1NSApIC8gMjU1O1xyXG5cdFx0dGhpcy5iID0gKCBoZXggJiAyNTUgKSAvIDI1NTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0UkdCOiBmdW5jdGlvbiAoIHIsIGcsIGIgKSB7XHJcblxyXG5cdFx0dGhpcy5yID0gcjtcclxuXHRcdHRoaXMuZyA9IGc7XHJcblx0XHR0aGlzLmIgPSBiO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRIU0w6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRmdW5jdGlvbiBodWUycmdiKCBwLCBxLCB0ICkge1xyXG5cclxuXHRcdFx0aWYgKCB0IDwgMCApIHQgKz0gMTtcclxuXHRcdFx0aWYgKCB0ID4gMSApIHQgLT0gMTtcclxuXHRcdFx0aWYgKCB0IDwgMSAvIDYgKSByZXR1cm4gcCArICggcSAtIHAgKSAqIDYgKiB0O1xyXG5cdFx0XHRpZiAoIHQgPCAxIC8gMiApIHJldHVybiBxO1xyXG5cdFx0XHRpZiAoIHQgPCAyIC8gMyApIHJldHVybiBwICsgKCBxIC0gcCApICogNiAqICggMiAvIDMgLSB0ICk7XHJcblx0XHRcdHJldHVybiBwO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBoLCBzLCBsICkge1xyXG5cclxuXHRcdFx0Ly8gaCxzLGwgcmFuZ2VzIGFyZSBpbiAwLjAgLSAxLjBcclxuXHRcdFx0aCA9IFRIUkVFLk1hdGguZXVjbGlkZWFuTW9kdWxvKCBoLCAxICk7XHJcblx0XHRcdHMgPSBUSFJFRS5NYXRoLmNsYW1wKCBzLCAwLCAxICk7XHJcblx0XHRcdGwgPSBUSFJFRS5NYXRoLmNsYW1wKCBsLCAwLCAxICk7XHJcblxyXG5cdFx0XHRpZiAoIHMgPT09IDAgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuciA9IHRoaXMuZyA9IHRoaXMuYiA9IGw7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHR2YXIgcCA9IGwgPD0gMC41ID8gbCAqICggMSArIHMgKSA6IGwgKyBzIC0gKCBsICogcyApO1xyXG5cdFx0XHRcdHZhciBxID0gKCAyICogbCApIC0gcDtcclxuXHJcblx0XHRcdFx0dGhpcy5yID0gaHVlMnJnYiggcSwgcCwgaCArIDEgLyAzICk7XHJcblx0XHRcdFx0dGhpcy5nID0gaHVlMnJnYiggcSwgcCwgaCApO1xyXG5cdFx0XHRcdHRoaXMuYiA9IGh1ZTJyZ2IoIHEsIHAsIGggLSAxIC8gMyApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRzZXRTdHlsZTogZnVuY3Rpb24gKCBzdHlsZSApIHtcclxuXHJcblx0XHRmdW5jdGlvbiBoYW5kbGVBbHBoYSggc3RyaW5nICkge1xyXG5cclxuXHRcdFx0aWYgKCBzdHJpbmcgPT09IHVuZGVmaW5lZCApIHJldHVybjtcclxuXHJcblx0XHRcdGlmICggcGFyc2VGbG9hdCggc3RyaW5nICkgPCAxICkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Db2xvcjogQWxwaGEgY29tcG9uZW50IG9mICcgKyBzdHlsZSArICcgd2lsbCBiZSBpZ25vcmVkLicgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cclxuXHRcdHZhciBtO1xyXG5cclxuXHRcdGlmICggbSA9IC9eKCg/OnJnYnxoc2wpYT8pXFwoXFxzKihbXlxcKV0qKVxcKS8uZXhlYyggc3R5bGUgKSApIHtcclxuXHJcblx0XHRcdC8vIHJnYiAvIGhzbFxyXG5cclxuXHRcdFx0dmFyIGNvbG9yO1xyXG5cdFx0XHR2YXIgbmFtZSA9IG1bIDEgXTtcclxuXHRcdFx0dmFyIGNvbXBvbmVudHMgPSBtWyAyIF07XHJcblxyXG5cdFx0XHRzd2l0Y2ggKCBuYW1lICkge1xyXG5cclxuXHRcdFx0XHRjYXNlICdyZ2InOlxyXG5cdFx0XHRcdGNhc2UgJ3JnYmEnOlxyXG5cclxuXHRcdFx0XHRcdGlmICggY29sb3IgPSAvXihcXGQrKVxccyosXFxzKihcXGQrKVxccyosXFxzKihcXGQrKVxccyooLFxccyooWzAtOV0qXFwuP1swLTldKylcXHMqKT8kLy5leGVjKCBjb21wb25lbnRzICkgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHQvLyByZ2IoMjU1LDAsMCkgcmdiYSgyNTUsMCwwLDAuNSlcclxuXHRcdFx0XHRcdFx0dGhpcy5yID0gTWF0aC5taW4oIDI1NSwgcGFyc2VJbnQoIGNvbG9yWyAxIF0sIDEwICkgKSAvIDI1NTtcclxuXHRcdFx0XHRcdFx0dGhpcy5nID0gTWF0aC5taW4oIDI1NSwgcGFyc2VJbnQoIGNvbG9yWyAyIF0sIDEwICkgKSAvIDI1NTtcclxuXHRcdFx0XHRcdFx0dGhpcy5iID0gTWF0aC5taW4oIDI1NSwgcGFyc2VJbnQoIGNvbG9yWyAzIF0sIDEwICkgKSAvIDI1NTtcclxuXHJcblx0XHRcdFx0XHRcdGhhbmRsZUFscGhhKCBjb2xvclsgNSBdICk7XHJcblxyXG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBjb2xvciA9IC9eKFxcZCspXFwlXFxzKixcXHMqKFxcZCspXFwlXFxzKixcXHMqKFxcZCspXFwlXFxzKigsXFxzKihbMC05XSpcXC4/WzAtOV0rKVxccyopPyQvLmV4ZWMoIGNvbXBvbmVudHMgKSApIHtcclxuXHJcblx0XHRcdFx0XHRcdC8vIHJnYigxMDAlLDAlLDAlKSByZ2JhKDEwMCUsMCUsMCUsMC41KVxyXG5cdFx0XHRcdFx0XHR0aGlzLnIgPSBNYXRoLm1pbiggMTAwLCBwYXJzZUludCggY29sb3JbIDEgXSwgMTAgKSApIC8gMTAwO1xyXG5cdFx0XHRcdFx0XHR0aGlzLmcgPSBNYXRoLm1pbiggMTAwLCBwYXJzZUludCggY29sb3JbIDIgXSwgMTAgKSApIC8gMTAwO1xyXG5cdFx0XHRcdFx0XHR0aGlzLmIgPSBNYXRoLm1pbiggMTAwLCBwYXJzZUludCggY29sb3JbIDMgXSwgMTAgKSApIC8gMTAwO1xyXG5cclxuXHRcdFx0XHRcdFx0aGFuZGxlQWxwaGEoIGNvbG9yWyA1IF0gKTtcclxuXHJcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnaHNsJzpcclxuXHRcdFx0XHRjYXNlICdoc2xhJzpcclxuXHJcblx0XHRcdFx0XHRpZiAoIGNvbG9yID0gL14oWzAtOV0qXFwuP1swLTldKylcXHMqLFxccyooXFxkKylcXCVcXHMqLFxccyooXFxkKylcXCVcXHMqKCxcXHMqKFswLTldKlxcLj9bMC05XSspXFxzKik/JC8uZXhlYyggY29tcG9uZW50cyApICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Ly8gaHNsKDEyMCw1MCUsNTAlKSBoc2xhKDEyMCw1MCUsNTAlLDAuNSlcclxuXHRcdFx0XHRcdFx0dmFyIGggPSBwYXJzZUZsb2F0KCBjb2xvclsgMSBdICkgLyAzNjA7XHJcblx0XHRcdFx0XHRcdHZhciBzID0gcGFyc2VJbnQoIGNvbG9yWyAyIF0sIDEwICkgLyAxMDA7XHJcblx0XHRcdFx0XHRcdHZhciBsID0gcGFyc2VJbnQoIGNvbG9yWyAzIF0sIDEwICkgLyAxMDA7XHJcblxyXG5cdFx0XHRcdFx0XHRoYW5kbGVBbHBoYSggY29sb3JbIDUgXSApO1xyXG5cclxuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMuc2V0SFNMKCBoLCBzLCBsICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG0gPSAvXlxcIyhbQS1GYS1mMC05XSspJC8uZXhlYyggc3R5bGUgKSApIHtcclxuXHJcblx0XHRcdC8vIGhleCBjb2xvclxyXG5cclxuXHRcdFx0dmFyIGhleCA9IG1bIDEgXTtcclxuXHRcdFx0dmFyIHNpemUgPSBoZXgubGVuZ3RoO1xyXG5cclxuXHRcdFx0aWYgKCBzaXplID09PSAzICkge1xyXG5cclxuXHRcdFx0XHQvLyAjZmYwXHJcblx0XHRcdFx0dGhpcy5yID0gcGFyc2VJbnQoIGhleC5jaGFyQXQoIDAgKSArIGhleC5jaGFyQXQoIDAgKSwgMTYgKSAvIDI1NTtcclxuXHRcdFx0XHR0aGlzLmcgPSBwYXJzZUludCggaGV4LmNoYXJBdCggMSApICsgaGV4LmNoYXJBdCggMSApLCAxNiApIC8gMjU1O1xyXG5cdFx0XHRcdHRoaXMuYiA9IHBhcnNlSW50KCBoZXguY2hhckF0KCAyICkgKyBoZXguY2hhckF0KCAyICksIDE2ICkgLyAyNTU7XHJcblxyXG5cdFx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggc2l6ZSA9PT0gNiApIHtcclxuXHJcblx0XHRcdFx0Ly8gI2ZmMDAwMFxyXG5cdFx0XHRcdHRoaXMuciA9IHBhcnNlSW50KCBoZXguY2hhckF0KCAwICkgKyBoZXguY2hhckF0KCAxICksIDE2ICkgLyAyNTU7XHJcblx0XHRcdFx0dGhpcy5nID0gcGFyc2VJbnQoIGhleC5jaGFyQXQoIDIgKSArIGhleC5jaGFyQXQoIDMgKSwgMTYgKSAvIDI1NTtcclxuXHRcdFx0XHR0aGlzLmIgPSBwYXJzZUludCggaGV4LmNoYXJBdCggNCApICsgaGV4LmNoYXJBdCggNSApLCAxNiApIC8gMjU1O1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBzdHlsZSAmJiBzdHlsZS5sZW5ndGggPiAwICkge1xyXG5cclxuXHRcdFx0Ly8gY29sb3Iga2V5d29yZHNcclxuXHRcdFx0dmFyIGhleCA9IFRIUkVFLkNvbG9yS2V5d29yZHNbIHN0eWxlIF07XHJcblxyXG5cdFx0XHRpZiAoIGhleCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHQvLyByZWRcclxuXHRcdFx0XHR0aGlzLnNldEhleCggaGV4ICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHQvLyB1bmtub3duIGNvbG9yXHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQ29sb3I6IFVua25vd24gY29sb3IgJyArIHN0eWxlICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5yLCB0aGlzLmcsIHRoaXMuYiApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb3B5OiBmdW5jdGlvbiAoIGNvbG9yICkge1xyXG5cclxuXHRcdHRoaXMuciA9IGNvbG9yLnI7XHJcblx0XHR0aGlzLmcgPSBjb2xvci5nO1xyXG5cdFx0dGhpcy5iID0gY29sb3IuYjtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y29weUdhbW1hVG9MaW5lYXI6IGZ1bmN0aW9uICggY29sb3IsIGdhbW1hRmFjdG9yICkge1xyXG5cclxuXHRcdGlmICggZ2FtbWFGYWN0b3IgPT09IHVuZGVmaW5lZCApIGdhbW1hRmFjdG9yID0gMi4wO1xyXG5cclxuXHRcdHRoaXMuciA9IE1hdGgucG93KCBjb2xvci5yLCBnYW1tYUZhY3RvciApO1xyXG5cdFx0dGhpcy5nID0gTWF0aC5wb3coIGNvbG9yLmcsIGdhbW1hRmFjdG9yICk7XHJcblx0XHR0aGlzLmIgPSBNYXRoLnBvdyggY29sb3IuYiwgZ2FtbWFGYWN0b3IgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y29weUxpbmVhclRvR2FtbWE6IGZ1bmN0aW9uICggY29sb3IsIGdhbW1hRmFjdG9yICkge1xyXG5cclxuXHRcdGlmICggZ2FtbWFGYWN0b3IgPT09IHVuZGVmaW5lZCApIGdhbW1hRmFjdG9yID0gMi4wO1xyXG5cclxuXHRcdHZhciBzYWZlSW52ZXJzZSA9ICggZ2FtbWFGYWN0b3IgPiAwICkgPyAoIDEuMCAvIGdhbW1hRmFjdG9yICkgOiAxLjA7XHJcblxyXG5cdFx0dGhpcy5yID0gTWF0aC5wb3coIGNvbG9yLnIsIHNhZmVJbnZlcnNlICk7XHJcblx0XHR0aGlzLmcgPSBNYXRoLnBvdyggY29sb3IuZywgc2FmZUludmVyc2UgKTtcclxuXHRcdHRoaXMuYiA9IE1hdGgucG93KCBjb2xvci5iLCBzYWZlSW52ZXJzZSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb252ZXJ0R2FtbWFUb0xpbmVhcjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciByID0gdGhpcy5yLCBnID0gdGhpcy5nLCBiID0gdGhpcy5iO1xyXG5cclxuXHRcdHRoaXMuciA9IHIgKiByO1xyXG5cdFx0dGhpcy5nID0gZyAqIGc7XHJcblx0XHR0aGlzLmIgPSBiICogYjtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y29udmVydExpbmVhclRvR2FtbWE6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLnIgPSBNYXRoLnNxcnQoIHRoaXMuciApO1xyXG5cdFx0dGhpcy5nID0gTWF0aC5zcXJ0KCB0aGlzLmcgKTtcclxuXHRcdHRoaXMuYiA9IE1hdGguc3FydCggdGhpcy5iICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldEhleDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiAoIHRoaXMuciAqIDI1NSApIDw8IDE2IF4gKCB0aGlzLmcgKiAyNTUgKSA8PCA4IF4gKCB0aGlzLmIgKiAyNTUgKSA8PCAwO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXRIZXhTdHJpbmc6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gKCAnMDAwMDAwJyArIHRoaXMuZ2V0SGV4KCkudG9TdHJpbmcoIDE2ICkgKS5zbGljZSggLSA2ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldEhTTDogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHQvLyBoLHMsbCByYW5nZXMgYXJlIGluIDAuMCAtIDEuMFxyXG5cclxuXHRcdHZhciBoc2wgPSBvcHRpb25hbFRhcmdldCB8fCB7IGg6IDAsIHM6IDAsIGw6IDAgfTtcclxuXHJcblx0XHR2YXIgciA9IHRoaXMuciwgZyA9IHRoaXMuZywgYiA9IHRoaXMuYjtcclxuXHJcblx0XHR2YXIgbWF4ID0gTWF0aC5tYXgoIHIsIGcsIGIgKTtcclxuXHRcdHZhciBtaW4gPSBNYXRoLm1pbiggciwgZywgYiApO1xyXG5cclxuXHRcdHZhciBodWUsIHNhdHVyYXRpb247XHJcblx0XHR2YXIgbGlnaHRuZXNzID0gKCBtaW4gKyBtYXggKSAvIDIuMDtcclxuXHJcblx0XHRpZiAoIG1pbiA9PT0gbWF4ICkge1xyXG5cclxuXHRcdFx0aHVlID0gMDtcclxuXHRcdFx0c2F0dXJhdGlvbiA9IDA7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHZhciBkZWx0YSA9IG1heCAtIG1pbjtcclxuXHJcblx0XHRcdHNhdHVyYXRpb24gPSBsaWdodG5lc3MgPD0gMC41ID8gZGVsdGEgLyAoIG1heCArIG1pbiApIDogZGVsdGEgLyAoIDIgLSBtYXggLSBtaW4gKTtcclxuXHJcblx0XHRcdHN3aXRjaCAoIG1heCApIHtcclxuXHJcblx0XHRcdFx0Y2FzZSByOiBodWUgPSAoIGcgLSBiICkgLyBkZWx0YSArICggZyA8IGIgPyA2IDogMCApOyBicmVhaztcclxuXHRcdFx0XHRjYXNlIGc6IGh1ZSA9ICggYiAtIHIgKSAvIGRlbHRhICsgMjsgYnJlYWs7XHJcblx0XHRcdFx0Y2FzZSBiOiBodWUgPSAoIHIgLSBnICkgLyBkZWx0YSArIDQ7IGJyZWFrO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aHVlIC89IDY7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGhzbC5oID0gaHVlO1xyXG5cdFx0aHNsLnMgPSBzYXR1cmF0aW9uO1xyXG5cdFx0aHNsLmwgPSBsaWdodG5lc3M7XHJcblxyXG5cdFx0cmV0dXJuIGhzbDtcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0U3R5bGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gJ3JnYignICsgKCAoIHRoaXMuciAqIDI1NSApIHwgMCApICsgJywnICsgKCAoIHRoaXMuZyAqIDI1NSApIHwgMCApICsgJywnICsgKCAoIHRoaXMuYiAqIDI1NSApIHwgMCApICsgJyknO1xyXG5cclxuXHR9LFxyXG5cclxuXHRvZmZzZXRIU0w6IGZ1bmN0aW9uICggaCwgcywgbCApIHtcclxuXHJcblx0XHR2YXIgaHNsID0gdGhpcy5nZXRIU0woKTtcclxuXHJcblx0XHRoc2wuaCArPSBoOyBoc2wucyArPSBzOyBoc2wubCArPSBsO1xyXG5cclxuXHRcdHRoaXMuc2V0SFNMKCBoc2wuaCwgaHNsLnMsIGhzbC5sICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFkZDogZnVuY3Rpb24gKCBjb2xvciApIHtcclxuXHJcblx0XHR0aGlzLnIgKz0gY29sb3IucjtcclxuXHRcdHRoaXMuZyArPSBjb2xvci5nO1xyXG5cdFx0dGhpcy5iICs9IGNvbG9yLmI7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFkZENvbG9yczogZnVuY3Rpb24gKCBjb2xvcjEsIGNvbG9yMiApIHtcclxuXHJcblx0XHR0aGlzLnIgPSBjb2xvcjEuciArIGNvbG9yMi5yO1xyXG5cdFx0dGhpcy5nID0gY29sb3IxLmcgKyBjb2xvcjIuZztcclxuXHRcdHRoaXMuYiA9IGNvbG9yMS5iICsgY29sb3IyLmI7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFkZFNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xyXG5cclxuXHRcdHRoaXMuciArPSBzO1xyXG5cdFx0dGhpcy5nICs9IHM7XHJcblx0XHR0aGlzLmIgKz0gcztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bXVsdGlwbHk6IGZ1bmN0aW9uICggY29sb3IgKSB7XHJcblxyXG5cdFx0dGhpcy5yICo9IGNvbG9yLnI7XHJcblx0XHR0aGlzLmcgKj0gY29sb3IuZztcclxuXHRcdHRoaXMuYiAqPSBjb2xvci5iO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtdWx0aXBseVNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xyXG5cclxuXHRcdHRoaXMuciAqPSBzO1xyXG5cdFx0dGhpcy5nICo9IHM7XHJcblx0XHR0aGlzLmIgKj0gcztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bGVycDogZnVuY3Rpb24gKCBjb2xvciwgYWxwaGEgKSB7XHJcblxyXG5cdFx0dGhpcy5yICs9ICggY29sb3IuciAtIHRoaXMuciApICogYWxwaGE7XHJcblx0XHR0aGlzLmcgKz0gKCBjb2xvci5nIC0gdGhpcy5nICkgKiBhbHBoYTtcclxuXHRcdHRoaXMuYiArPSAoIGNvbG9yLmIgLSB0aGlzLmIgKSAqIGFscGhhO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRlcXVhbHM6IGZ1bmN0aW9uICggYyApIHtcclxuXHJcblx0XHRyZXR1cm4gKCBjLnIgPT09IHRoaXMuciApICYmICggYy5nID09PSB0aGlzLmcgKSAmJiAoIGMuYiA9PT0gdGhpcy5iICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGZyb21BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xyXG5cclxuXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xyXG5cclxuXHRcdHRoaXMuciA9IGFycmF5WyBvZmZzZXQgXTtcclxuXHRcdHRoaXMuZyA9IGFycmF5WyBvZmZzZXQgKyAxIF07XHJcblx0XHR0aGlzLmIgPSBhcnJheVsgb2Zmc2V0ICsgMiBdO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHR0b0FycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0aWYgKCBhcnJheSA9PT0gdW5kZWZpbmVkICkgYXJyYXkgPSBbXTtcclxuXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xyXG5cclxuXHRcdGFycmF5WyBvZmZzZXQgXSA9IHRoaXMucjtcclxuXHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLmc7XHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgMiBdID0gdGhpcy5iO1xyXG5cclxuXHRcdHJldHVybiBhcnJheTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcblRIUkVFLkNvbG9yS2V5d29yZHMgPSB7ICdhbGljZWJsdWUnOiAweEYwRjhGRiwgJ2FudGlxdWV3aGl0ZSc6IDB4RkFFQkQ3LCAnYXF1YSc6IDB4MDBGRkZGLCAnYXF1YW1hcmluZSc6IDB4N0ZGRkQ0LCAnYXp1cmUnOiAweEYwRkZGRixcclxuJ2JlaWdlJzogMHhGNUY1REMsICdiaXNxdWUnOiAweEZGRTRDNCwgJ2JsYWNrJzogMHgwMDAwMDAsICdibGFuY2hlZGFsbW9uZCc6IDB4RkZFQkNELCAnYmx1ZSc6IDB4MDAwMEZGLCAnYmx1ZXZpb2xldCc6IDB4OEEyQkUyLFxyXG4nYnJvd24nOiAweEE1MkEyQSwgJ2J1cmx5d29vZCc6IDB4REVCODg3LCAnY2FkZXRibHVlJzogMHg1RjlFQTAsICdjaGFydHJldXNlJzogMHg3RkZGMDAsICdjaG9jb2xhdGUnOiAweEQyNjkxRSwgJ2NvcmFsJzogMHhGRjdGNTAsXHJcbidjb3JuZmxvd2VyYmx1ZSc6IDB4NjQ5NUVELCAnY29ybnNpbGsnOiAweEZGRjhEQywgJ2NyaW1zb24nOiAweERDMTQzQywgJ2N5YW4nOiAweDAwRkZGRiwgJ2RhcmtibHVlJzogMHgwMDAwOEIsICdkYXJrY3lhbic6IDB4MDA4QjhCLFxyXG4nZGFya2dvbGRlbnJvZCc6IDB4Qjg4NjBCLCAnZGFya2dyYXknOiAweEE5QTlBOSwgJ2RhcmtncmVlbic6IDB4MDA2NDAwLCAnZGFya2dyZXknOiAweEE5QTlBOSwgJ2RhcmtraGFraSc6IDB4QkRCNzZCLCAnZGFya21hZ2VudGEnOiAweDhCMDA4QixcclxuJ2RhcmtvbGl2ZWdyZWVuJzogMHg1NTZCMkYsICdkYXJrb3JhbmdlJzogMHhGRjhDMDAsICdkYXJrb3JjaGlkJzogMHg5OTMyQ0MsICdkYXJrcmVkJzogMHg4QjAwMDAsICdkYXJrc2FsbW9uJzogMHhFOTk2N0EsICdkYXJrc2VhZ3JlZW4nOiAweDhGQkM4RixcclxuJ2RhcmtzbGF0ZWJsdWUnOiAweDQ4M0Q4QiwgJ2RhcmtzbGF0ZWdyYXknOiAweDJGNEY0RiwgJ2RhcmtzbGF0ZWdyZXknOiAweDJGNEY0RiwgJ2Rhcmt0dXJxdW9pc2UnOiAweDAwQ0VEMSwgJ2Rhcmt2aW9sZXQnOiAweDk0MDBEMyxcclxuJ2RlZXBwaW5rJzogMHhGRjE0OTMsICdkZWVwc2t5Ymx1ZSc6IDB4MDBCRkZGLCAnZGltZ3JheSc6IDB4Njk2OTY5LCAnZGltZ3JleSc6IDB4Njk2OTY5LCAnZG9kZ2VyYmx1ZSc6IDB4MUU5MEZGLCAnZmlyZWJyaWNrJzogMHhCMjIyMjIsXHJcbidmbG9yYWx3aGl0ZSc6IDB4RkZGQUYwLCAnZm9yZXN0Z3JlZW4nOiAweDIyOEIyMiwgJ2Z1Y2hzaWEnOiAweEZGMDBGRiwgJ2dhaW5zYm9ybyc6IDB4RENEQ0RDLCAnZ2hvc3R3aGl0ZSc6IDB4RjhGOEZGLCAnZ29sZCc6IDB4RkZENzAwLFxyXG4nZ29sZGVucm9kJzogMHhEQUE1MjAsICdncmF5JzogMHg4MDgwODAsICdncmVlbic6IDB4MDA4MDAwLCAnZ3JlZW55ZWxsb3cnOiAweEFERkYyRiwgJ2dyZXknOiAweDgwODA4MCwgJ2hvbmV5ZGV3JzogMHhGMEZGRjAsICdob3RwaW5rJzogMHhGRjY5QjQsXHJcbidpbmRpYW5yZWQnOiAweENENUM1QywgJ2luZGlnbyc6IDB4NEIwMDgyLCAnaXZvcnknOiAweEZGRkZGMCwgJ2toYWtpJzogMHhGMEU2OEMsICdsYXZlbmRlcic6IDB4RTZFNkZBLCAnbGF2ZW5kZXJibHVzaCc6IDB4RkZGMEY1LCAnbGF3bmdyZWVuJzogMHg3Q0ZDMDAsXHJcbidsZW1vbmNoaWZmb24nOiAweEZGRkFDRCwgJ2xpZ2h0Ymx1ZSc6IDB4QUREOEU2LCAnbGlnaHRjb3JhbCc6IDB4RjA4MDgwLCAnbGlnaHRjeWFuJzogMHhFMEZGRkYsICdsaWdodGdvbGRlbnJvZHllbGxvdyc6IDB4RkFGQUQyLCAnbGlnaHRncmF5JzogMHhEM0QzRDMsXHJcbidsaWdodGdyZWVuJzogMHg5MEVFOTAsICdsaWdodGdyZXknOiAweEQzRDNEMywgJ2xpZ2h0cGluayc6IDB4RkZCNkMxLCAnbGlnaHRzYWxtb24nOiAweEZGQTA3QSwgJ2xpZ2h0c2VhZ3JlZW4nOiAweDIwQjJBQSwgJ2xpZ2h0c2t5Ymx1ZSc6IDB4ODdDRUZBLFxyXG4nbGlnaHRzbGF0ZWdyYXknOiAweDc3ODg5OSwgJ2xpZ2h0c2xhdGVncmV5JzogMHg3Nzg4OTksICdsaWdodHN0ZWVsYmx1ZSc6IDB4QjBDNERFLCAnbGlnaHR5ZWxsb3cnOiAweEZGRkZFMCwgJ2xpbWUnOiAweDAwRkYwMCwgJ2xpbWVncmVlbic6IDB4MzJDRDMyLFxyXG4nbGluZW4nOiAweEZBRjBFNiwgJ21hZ2VudGEnOiAweEZGMDBGRiwgJ21hcm9vbic6IDB4ODAwMDAwLCAnbWVkaXVtYXF1YW1hcmluZSc6IDB4NjZDREFBLCAnbWVkaXVtYmx1ZSc6IDB4MDAwMENELCAnbWVkaXVtb3JjaGlkJzogMHhCQTU1RDMsXHJcbidtZWRpdW1wdXJwbGUnOiAweDkzNzBEQiwgJ21lZGl1bXNlYWdyZWVuJzogMHgzQ0IzNzEsICdtZWRpdW1zbGF0ZWJsdWUnOiAweDdCNjhFRSwgJ21lZGl1bXNwcmluZ2dyZWVuJzogMHgwMEZBOUEsICdtZWRpdW10dXJxdW9pc2UnOiAweDQ4RDFDQyxcclxuJ21lZGl1bXZpb2xldHJlZCc6IDB4QzcxNTg1LCAnbWlkbmlnaHRibHVlJzogMHgxOTE5NzAsICdtaW50Y3JlYW0nOiAweEY1RkZGQSwgJ21pc3R5cm9zZSc6IDB4RkZFNEUxLCAnbW9jY2FzaW4nOiAweEZGRTRCNSwgJ25hdmFqb3doaXRlJzogMHhGRkRFQUQsXHJcbiduYXZ5JzogMHgwMDAwODAsICdvbGRsYWNlJzogMHhGREY1RTYsICdvbGl2ZSc6IDB4ODA4MDAwLCAnb2xpdmVkcmFiJzogMHg2QjhFMjMsICdvcmFuZ2UnOiAweEZGQTUwMCwgJ29yYW5nZXJlZCc6IDB4RkY0NTAwLCAnb3JjaGlkJzogMHhEQTcwRDYsXHJcbidwYWxlZ29sZGVucm9kJzogMHhFRUU4QUEsICdwYWxlZ3JlZW4nOiAweDk4RkI5OCwgJ3BhbGV0dXJxdW9pc2UnOiAweEFGRUVFRSwgJ3BhbGV2aW9sZXRyZWQnOiAweERCNzA5MywgJ3BhcGF5YXdoaXAnOiAweEZGRUZENSwgJ3BlYWNocHVmZic6IDB4RkZEQUI5LFxyXG4ncGVydSc6IDB4Q0Q4NTNGLCAncGluayc6IDB4RkZDMENCLCAncGx1bSc6IDB4RERBMERELCAncG93ZGVyYmx1ZSc6IDB4QjBFMEU2LCAncHVycGxlJzogMHg4MDAwODAsICdyZWQnOiAweEZGMDAwMCwgJ3Jvc3licm93bic6IDB4QkM4RjhGLFxyXG4ncm95YWxibHVlJzogMHg0MTY5RTEsICdzYWRkbGVicm93bic6IDB4OEI0NTEzLCAnc2FsbW9uJzogMHhGQTgwNzIsICdzYW5keWJyb3duJzogMHhGNEE0NjAsICdzZWFncmVlbic6IDB4MkU4QjU3LCAnc2Vhc2hlbGwnOiAweEZGRjVFRSxcclxuJ3NpZW5uYSc6IDB4QTA1MjJELCAnc2lsdmVyJzogMHhDMEMwQzAsICdza3libHVlJzogMHg4N0NFRUIsICdzbGF0ZWJsdWUnOiAweDZBNUFDRCwgJ3NsYXRlZ3JheSc6IDB4NzA4MDkwLCAnc2xhdGVncmV5JzogMHg3MDgwOTAsICdzbm93JzogMHhGRkZBRkEsXHJcbidzcHJpbmdncmVlbic6IDB4MDBGRjdGLCAnc3RlZWxibHVlJzogMHg0NjgyQjQsICd0YW4nOiAweEQyQjQ4QywgJ3RlYWwnOiAweDAwODA4MCwgJ3RoaXN0bGUnOiAweEQ4QkZEOCwgJ3RvbWF0byc6IDB4RkY2MzQ3LCAndHVycXVvaXNlJzogMHg0MEUwRDAsXHJcbid2aW9sZXQnOiAweEVFODJFRSwgJ3doZWF0JzogMHhGNURFQjMsICd3aGl0ZSc6IDB4RkZGRkZGLCAnd2hpdGVzbW9rZSc6IDB4RjVGNUY1LCAneWVsbG93JzogMHhGRkZGMDAsICd5ZWxsb3dncmVlbic6IDB4OUFDRDMyIH07XHJcblxyXG4vLyBGaWxlOnNyYy9tYXRoL1F1YXRlcm5pb24uanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcclxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pb1xyXG4gKi9cclxuXHJcblRIUkVFLlF1YXRlcm5pb24gPSBmdW5jdGlvbiAoIHgsIHksIHosIHcgKSB7XHJcblxyXG5cdHRoaXMuX3ggPSB4IHx8IDA7XHJcblx0dGhpcy5feSA9IHkgfHwgMDtcclxuXHR0aGlzLl96ID0geiB8fCAwO1xyXG5cdHRoaXMuX3cgPSAoIHcgIT09IHVuZGVmaW5lZCApID8gdyA6IDE7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUXVhdGVybmlvbi5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5RdWF0ZXJuaW9uLFxyXG5cclxuXHRnZXQgeCAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX3g7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldCB4ICggdmFsdWUgKSB7XHJcblxyXG5cdFx0dGhpcy5feCA9IHZhbHVlO1xyXG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldCB5ICgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5feTtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0IHkgKCB2YWx1ZSApIHtcclxuXHJcblx0XHR0aGlzLl95ID0gdmFsdWU7XHJcblx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0IHogKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLl96O1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXQgeiAoIHZhbHVlICkge1xyXG5cclxuXHRcdHRoaXMuX3ogPSB2YWx1ZTtcclxuXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXQgdyAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX3c7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldCB3ICggdmFsdWUgKSB7XHJcblxyXG5cdFx0dGhpcy5fdyA9IHZhbHVlO1xyXG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldDogZnVuY3Rpb24gKCB4LCB5LCB6LCB3ICkge1xyXG5cclxuXHRcdHRoaXMuX3ggPSB4O1xyXG5cdFx0dGhpcy5feSA9IHk7XHJcblx0XHR0aGlzLl96ID0gejtcclxuXHRcdHRoaXMuX3cgPSB3O1xyXG5cclxuXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5feCwgdGhpcy5feSwgdGhpcy5feiwgdGhpcy5fdyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb3B5OiBmdW5jdGlvbiAoIHF1YXRlcm5pb24gKSB7XHJcblxyXG5cdFx0dGhpcy5feCA9IHF1YXRlcm5pb24ueDtcclxuXHRcdHRoaXMuX3kgPSBxdWF0ZXJuaW9uLnk7XHJcblx0XHR0aGlzLl96ID0gcXVhdGVybmlvbi56O1xyXG5cdFx0dGhpcy5fdyA9IHF1YXRlcm5pb24udztcclxuXHJcblx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0RnJvbUV1bGVyOiBmdW5jdGlvbiAoIGV1bGVyLCB1cGRhdGUgKSB7XHJcblxyXG5cdFx0aWYgKCBldWxlciBpbnN0YW5jZW9mIFRIUkVFLkV1bGVyID09PSBmYWxzZSApIHtcclxuXHJcblx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RIUkVFLlF1YXRlcm5pb246IC5zZXRGcm9tRXVsZXIoKSBub3cgZXhwZWN0cyBhIEV1bGVyIHJvdGF0aW9uIHJhdGhlciB0aGFuIGEgVmVjdG9yMyBhbmQgb3JkZXIuJyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBodHRwOi8vd3d3Lm1hdGh3b3Jrcy5jb20vbWF0bGFiY2VudHJhbC9maWxlZXhjaGFuZ2UvXHJcblx0XHQvLyBcdDIwNjk2LWZ1bmN0aW9uLXRvLWNvbnZlcnQtYmV0d2Vlbi1kY20tZXVsZXItYW5nbGVzLXF1YXRlcm5pb25zLWFuZC1ldWxlci12ZWN0b3JzL1xyXG5cdFx0Ly9cdGNvbnRlbnQvU3BpbkNhbGMubVxyXG5cclxuXHRcdHZhciBjMSA9IE1hdGguY29zKCBldWxlci5feCAvIDIgKTtcclxuXHRcdHZhciBjMiA9IE1hdGguY29zKCBldWxlci5feSAvIDIgKTtcclxuXHRcdHZhciBjMyA9IE1hdGguY29zKCBldWxlci5feiAvIDIgKTtcclxuXHRcdHZhciBzMSA9IE1hdGguc2luKCBldWxlci5feCAvIDIgKTtcclxuXHRcdHZhciBzMiA9IE1hdGguc2luKCBldWxlci5feSAvIDIgKTtcclxuXHRcdHZhciBzMyA9IE1hdGguc2luKCBldWxlci5feiAvIDIgKTtcclxuXHJcblx0XHR2YXIgb3JkZXIgPSBldWxlci5vcmRlcjtcclxuXHJcblx0XHRpZiAoIG9yZGVyID09PSAnWFlaJyApIHtcclxuXHJcblx0XHRcdHRoaXMuX3ggPSBzMSAqIGMyICogYzMgKyBjMSAqIHMyICogczM7XHJcblx0XHRcdHRoaXMuX3kgPSBjMSAqIHMyICogYzMgLSBzMSAqIGMyICogczM7XHJcblx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgKyBzMSAqIHMyICogYzM7XHJcblx0XHRcdHRoaXMuX3cgPSBjMSAqIGMyICogYzMgLSBzMSAqIHMyICogczM7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdZWFonICkge1xyXG5cclxuXHRcdFx0dGhpcy5feCA9IHMxICogYzIgKiBjMyArIGMxICogczIgKiBzMztcclxuXHRcdFx0dGhpcy5feSA9IGMxICogczIgKiBjMyAtIHMxICogYzIgKiBzMztcclxuXHRcdFx0dGhpcy5feiA9IGMxICogYzIgKiBzMyAtIHMxICogczIgKiBjMztcclxuXHRcdFx0dGhpcy5fdyA9IGMxICogYzIgKiBjMyArIHMxICogczIgKiBzMztcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1pYWScgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl94ID0gczEgKiBjMiAqIGMzIC0gYzEgKiBzMiAqIHMzO1xyXG5cdFx0XHR0aGlzLl95ID0gYzEgKiBzMiAqIGMzICsgczEgKiBjMiAqIHMzO1xyXG5cdFx0XHR0aGlzLl96ID0gYzEgKiBjMiAqIHMzICsgczEgKiBzMiAqIGMzO1xyXG5cdFx0XHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzIC0gczEgKiBzMiAqIHMzO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWllYJyApIHtcclxuXHJcblx0XHRcdHRoaXMuX3ggPSBzMSAqIGMyICogYzMgLSBjMSAqIHMyICogczM7XHJcblx0XHRcdHRoaXMuX3kgPSBjMSAqIHMyICogYzMgKyBzMSAqIGMyICogczM7XHJcblx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgLSBzMSAqIHMyICogYzM7XHJcblx0XHRcdHRoaXMuX3cgPSBjMSAqIGMyICogYzMgKyBzMSAqIHMyICogczM7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdZWlgnICkge1xyXG5cclxuXHRcdFx0dGhpcy5feCA9IHMxICogYzIgKiBjMyArIGMxICogczIgKiBzMztcclxuXHRcdFx0dGhpcy5feSA9IGMxICogczIgKiBjMyArIHMxICogYzIgKiBzMztcclxuXHRcdFx0dGhpcy5feiA9IGMxICogYzIgKiBzMyAtIHMxICogczIgKiBjMztcclxuXHRcdFx0dGhpcy5fdyA9IGMxICogYzIgKiBjMyAtIHMxICogczIgKiBzMztcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1haWScgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl94ID0gczEgKiBjMiAqIGMzIC0gYzEgKiBzMiAqIHMzO1xyXG5cdFx0XHR0aGlzLl95ID0gYzEgKiBzMiAqIGMzIC0gczEgKiBjMiAqIHMzO1xyXG5cdFx0XHR0aGlzLl96ID0gYzEgKiBjMiAqIHMzICsgczEgKiBzMiAqIGMzO1xyXG5cdFx0XHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzICsgczEgKiBzMiAqIHMzO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHVwZGF0ZSAhPT0gZmFsc2UgKSB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0RnJvbUF4aXNBbmdsZTogZnVuY3Rpb24gKCBheGlzLCBhbmdsZSApIHtcclxuXHJcblx0XHQvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9nZW9tZXRyeS9yb3RhdGlvbnMvY29udmVyc2lvbnMvYW5nbGVUb1F1YXRlcm5pb24vaW5kZXguaHRtXHJcblxyXG5cdFx0Ly8gYXNzdW1lcyBheGlzIGlzIG5vcm1hbGl6ZWRcclxuXHJcblx0XHR2YXIgaGFsZkFuZ2xlID0gYW5nbGUgLyAyLCBzID0gTWF0aC5zaW4oIGhhbGZBbmdsZSApO1xyXG5cclxuXHRcdHRoaXMuX3ggPSBheGlzLnggKiBzO1xyXG5cdFx0dGhpcy5feSA9IGF4aXMueSAqIHM7XHJcblx0XHR0aGlzLl96ID0gYXhpcy56ICogcztcclxuXHRcdHRoaXMuX3cgPSBNYXRoLmNvcyggaGFsZkFuZ2xlICk7XHJcblxyXG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldEZyb21Sb3RhdGlvbk1hdHJpeDogZnVuY3Rpb24gKCBtICkge1xyXG5cclxuXHRcdC8vIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2dlb21ldHJ5L3JvdGF0aW9ucy9jb252ZXJzaW9ucy9tYXRyaXhUb1F1YXRlcm5pb24vaW5kZXguaHRtXHJcblxyXG5cdFx0Ly8gYXNzdW1lcyB0aGUgdXBwZXIgM3gzIG9mIG0gaXMgYSBwdXJlIHJvdGF0aW9uIG1hdHJpeCAoaS5lLCB1bnNjYWxlZClcclxuXHJcblx0XHR2YXIgdGUgPSBtLmVsZW1lbnRzLFxyXG5cclxuXHRcdFx0bTExID0gdGVbIDAgXSwgbTEyID0gdGVbIDQgXSwgbTEzID0gdGVbIDggXSxcclxuXHRcdFx0bTIxID0gdGVbIDEgXSwgbTIyID0gdGVbIDUgXSwgbTIzID0gdGVbIDkgXSxcclxuXHRcdFx0bTMxID0gdGVbIDIgXSwgbTMyID0gdGVbIDYgXSwgbTMzID0gdGVbIDEwIF0sXHJcblxyXG5cdFx0XHR0cmFjZSA9IG0xMSArIG0yMiArIG0zMyxcclxuXHRcdFx0cztcclxuXHJcblx0XHRpZiAoIHRyYWNlID4gMCApIHtcclxuXHJcblx0XHRcdHMgPSAwLjUgLyBNYXRoLnNxcnQoIHRyYWNlICsgMS4wICk7XHJcblxyXG5cdFx0XHR0aGlzLl93ID0gMC4yNSAvIHM7XHJcblx0XHRcdHRoaXMuX3ggPSAoIG0zMiAtIG0yMyApICogcztcclxuXHRcdFx0dGhpcy5feSA9ICggbTEzIC0gbTMxICkgKiBzO1xyXG5cdFx0XHR0aGlzLl96ID0gKCBtMjEgLSBtMTIgKSAqIHM7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggbTExID4gbTIyICYmIG0xMSA+IG0zMyApIHtcclxuXHJcblx0XHRcdHMgPSAyLjAgKiBNYXRoLnNxcnQoIDEuMCArIG0xMSAtIG0yMiAtIG0zMyApO1xyXG5cclxuXHRcdFx0dGhpcy5fdyA9ICggbTMyIC0gbTIzICkgLyBzO1xyXG5cdFx0XHR0aGlzLl94ID0gMC4yNSAqIHM7XHJcblx0XHRcdHRoaXMuX3kgPSAoIG0xMiArIG0yMSApIC8gcztcclxuXHRcdFx0dGhpcy5feiA9ICggbTEzICsgbTMxICkgLyBzO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG0yMiA+IG0zMyApIHtcclxuXHJcblx0XHRcdHMgPSAyLjAgKiBNYXRoLnNxcnQoIDEuMCArIG0yMiAtIG0xMSAtIG0zMyApO1xyXG5cclxuXHRcdFx0dGhpcy5fdyA9ICggbTEzIC0gbTMxICkgLyBzO1xyXG5cdFx0XHR0aGlzLl94ID0gKCBtMTIgKyBtMjEgKSAvIHM7XHJcblx0XHRcdHRoaXMuX3kgPSAwLjI1ICogcztcclxuXHRcdFx0dGhpcy5feiA9ICggbTIzICsgbTMyICkgLyBzO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRzID0gMi4wICogTWF0aC5zcXJ0KCAxLjAgKyBtMzMgLSBtMTEgLSBtMjIgKTtcclxuXHJcblx0XHRcdHRoaXMuX3cgPSAoIG0yMSAtIG0xMiApIC8gcztcclxuXHRcdFx0dGhpcy5feCA9ICggbTEzICsgbTMxICkgLyBzO1xyXG5cdFx0XHR0aGlzLl95ID0gKCBtMjMgKyBtMzIgKSAvIHM7XHJcblx0XHRcdHRoaXMuX3ogPSAwLjI1ICogcztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldEZyb21Vbml0VmVjdG9yczogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdC8vIGh0dHA6Ly9sb2xlbmdpbmUubmV0L2Jsb2cvMjAxNC8wMi8yNC9xdWF0ZXJuaW9uLWZyb20tdHdvLXZlY3RvcnMtZmluYWxcclxuXHJcblx0XHQvLyBhc3N1bWVzIGRpcmVjdGlvbiB2ZWN0b3JzIHZGcm9tIGFuZCB2VG8gYXJlIG5vcm1hbGl6ZWRcclxuXHJcblx0XHR2YXIgdjEsIHI7XHJcblxyXG5cdFx0dmFyIEVQUyA9IDAuMDAwMDAxO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIHZGcm9tLCB2VG8gKSB7XHJcblxyXG5cdFx0XHRpZiAoIHYxID09PSB1bmRlZmluZWQgKSB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0XHRyID0gdkZyb20uZG90KCB2VG8gKSArIDE7XHJcblxyXG5cdFx0XHRpZiAoIHIgPCBFUFMgKSB7XHJcblxyXG5cdFx0XHRcdHIgPSAwO1xyXG5cclxuXHRcdFx0XHRpZiAoIE1hdGguYWJzKCB2RnJvbS54ICkgPiBNYXRoLmFicyggdkZyb20ueiApICkge1xyXG5cclxuXHRcdFx0XHRcdHYxLnNldCggLSB2RnJvbS55LCB2RnJvbS54LCAwICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0djEuc2V0KCAwLCAtIHZGcm9tLnosIHZGcm9tLnkgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0djEuY3Jvc3NWZWN0b3JzKCB2RnJvbSwgdlRvICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLl94ID0gdjEueDtcclxuXHRcdFx0dGhpcy5feSA9IHYxLnk7XHJcblx0XHRcdHRoaXMuX3ogPSB2MS56O1xyXG5cdFx0XHR0aGlzLl93ID0gcjtcclxuXHJcblx0XHRcdHRoaXMubm9ybWFsaXplKCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGludmVyc2U6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLmNvbmp1Z2F0ZSgpLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb25qdWdhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLl94ICo9IC0gMTtcclxuXHRcdHRoaXMuX3kgKj0gLSAxO1xyXG5cdFx0dGhpcy5feiAqPSAtIDE7XHJcblxyXG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRvdDogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLl94ICogdi5feCArIHRoaXMuX3kgKiB2Ll95ICsgdGhpcy5feiAqIHYuX3ogKyB0aGlzLl93ICogdi5fdztcclxuXHJcblx0fSxcclxuXHJcblx0bGVuZ3RoU3E6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5feCAqIHRoaXMuX3ggKyB0aGlzLl95ICogdGhpcy5feSArIHRoaXMuX3ogKiB0aGlzLl96ICsgdGhpcy5fdyAqIHRoaXMuX3c7XHJcblxyXG5cdH0sXHJcblxyXG5cdGxlbmd0aDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMuX3ggKiB0aGlzLl94ICsgdGhpcy5feSAqIHRoaXMuX3kgKyB0aGlzLl96ICogdGhpcy5feiArIHRoaXMuX3cgKiB0aGlzLl93ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdG5vcm1hbGl6ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBsID0gdGhpcy5sZW5ndGgoKTtcclxuXHJcblx0XHRpZiAoIGwgPT09IDAgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl94ID0gMDtcclxuXHRcdFx0dGhpcy5feSA9IDA7XHJcblx0XHRcdHRoaXMuX3ogPSAwO1xyXG5cdFx0XHR0aGlzLl93ID0gMTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0bCA9IDEgLyBsO1xyXG5cclxuXHRcdFx0dGhpcy5feCA9IHRoaXMuX3ggKiBsO1xyXG5cdFx0XHR0aGlzLl95ID0gdGhpcy5feSAqIGw7XHJcblx0XHRcdHRoaXMuX3ogPSB0aGlzLl96ICogbDtcclxuXHRcdFx0dGhpcy5fdyA9IHRoaXMuX3cgKiBsO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bXVsdGlwbHk6IGZ1bmN0aW9uICggcSwgcCApIHtcclxuXHJcblx0XHRpZiAoIHAgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlF1YXRlcm5pb246IC5tdWx0aXBseSgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLm11bHRpcGx5UXVhdGVybmlvbnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlRdWF0ZXJuaW9ucyggcSwgcCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseVF1YXRlcm5pb25zKCB0aGlzLCBxICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdG11bHRpcGx5UXVhdGVybmlvbnM6IGZ1bmN0aW9uICggYSwgYiApIHtcclxuXHJcblx0XHQvLyBmcm9tIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2FsZ2VicmEvcmVhbE5vcm1lZEFsZ2VicmEvcXVhdGVybmlvbnMvY29kZS9pbmRleC5odG1cclxuXHJcblx0XHR2YXIgcWF4ID0gYS5feCwgcWF5ID0gYS5feSwgcWF6ID0gYS5feiwgcWF3ID0gYS5fdztcclxuXHRcdHZhciBxYnggPSBiLl94LCBxYnkgPSBiLl95LCBxYnogPSBiLl96LCBxYncgPSBiLl93O1xyXG5cclxuXHRcdHRoaXMuX3ggPSBxYXggKiBxYncgKyBxYXcgKiBxYnggKyBxYXkgKiBxYnogLSBxYXogKiBxYnk7XHJcblx0XHR0aGlzLl95ID0gcWF5ICogcWJ3ICsgcWF3ICogcWJ5ICsgcWF6ICogcWJ4IC0gcWF4ICogcWJ6O1xyXG5cdFx0dGhpcy5feiA9IHFheiAqIHFidyArIHFhdyAqIHFieiArIHFheCAqIHFieSAtIHFheSAqIHFieDtcclxuXHRcdHRoaXMuX3cgPSBxYXcgKiBxYncgLSBxYXggKiBxYnggLSBxYXkgKiBxYnkgLSBxYXogKiBxYno7XHJcblxyXG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNsZXJwOiBmdW5jdGlvbiAoIHFiLCB0ICkge1xyXG5cclxuXHRcdGlmICggdCA9PT0gMCApIHJldHVybiB0aGlzO1xyXG5cdFx0aWYgKCB0ID09PSAxICkgcmV0dXJuIHRoaXMuY29weSggcWIgKTtcclxuXHJcblx0XHR2YXIgeCA9IHRoaXMuX3gsIHkgPSB0aGlzLl95LCB6ID0gdGhpcy5feiwgdyA9IHRoaXMuX3c7XHJcblxyXG5cdFx0Ly8gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvYWxnZWJyYS9yZWFsTm9ybWVkQWxnZWJyYS9xdWF0ZXJuaW9ucy9zbGVycC9cclxuXHJcblx0XHR2YXIgY29zSGFsZlRoZXRhID0gdyAqIHFiLl93ICsgeCAqIHFiLl94ICsgeSAqIHFiLl95ICsgeiAqIHFiLl96O1xyXG5cclxuXHRcdGlmICggY29zSGFsZlRoZXRhIDwgMCApIHtcclxuXHJcblx0XHRcdHRoaXMuX3cgPSAtIHFiLl93O1xyXG5cdFx0XHR0aGlzLl94ID0gLSBxYi5feDtcclxuXHRcdFx0dGhpcy5feSA9IC0gcWIuX3k7XHJcblx0XHRcdHRoaXMuX3ogPSAtIHFiLl96O1xyXG5cclxuXHRcdFx0Y29zSGFsZlRoZXRhID0gLSBjb3NIYWxmVGhldGE7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHRoaXMuY29weSggcWIgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBjb3NIYWxmVGhldGEgPj0gMS4wICkge1xyXG5cclxuXHRcdFx0dGhpcy5fdyA9IHc7XHJcblx0XHRcdHRoaXMuX3ggPSB4O1xyXG5cdFx0XHR0aGlzLl95ID0geTtcclxuXHRcdFx0dGhpcy5feiA9IHo7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHNpbkhhbGZUaGV0YSA9IE1hdGguc3FydCggMS4wIC0gY29zSGFsZlRoZXRhICogY29zSGFsZlRoZXRhICk7XHJcblxyXG5cdFx0aWYgKCBNYXRoLmFicyggc2luSGFsZlRoZXRhICkgPCAwLjAwMSApIHtcclxuXHJcblx0XHRcdHRoaXMuX3cgPSAwLjUgKiAoIHcgKyB0aGlzLl93ICk7XHJcblx0XHRcdHRoaXMuX3ggPSAwLjUgKiAoIHggKyB0aGlzLl94ICk7XHJcblx0XHRcdHRoaXMuX3kgPSAwLjUgKiAoIHkgKyB0aGlzLl95ICk7XHJcblx0XHRcdHRoaXMuX3ogPSAwLjUgKiAoIHogKyB0aGlzLl96ICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGhhbGZUaGV0YSA9IE1hdGguYXRhbjIoIHNpbkhhbGZUaGV0YSwgY29zSGFsZlRoZXRhICk7XHJcblx0XHR2YXIgcmF0aW9BID0gTWF0aC5zaW4oICggMSAtIHQgKSAqIGhhbGZUaGV0YSApIC8gc2luSGFsZlRoZXRhLFxyXG5cdFx0cmF0aW9CID0gTWF0aC5zaW4oIHQgKiBoYWxmVGhldGEgKSAvIHNpbkhhbGZUaGV0YTtcclxuXHJcblx0XHR0aGlzLl93ID0gKCB3ICogcmF0aW9BICsgdGhpcy5fdyAqIHJhdGlvQiApO1xyXG5cdFx0dGhpcy5feCA9ICggeCAqIHJhdGlvQSArIHRoaXMuX3ggKiByYXRpb0IgKTtcclxuXHRcdHRoaXMuX3kgPSAoIHkgKiByYXRpb0EgKyB0aGlzLl95ICogcmF0aW9CICk7XHJcblx0XHR0aGlzLl96ID0gKCB6ICogcmF0aW9BICsgdGhpcy5feiAqIHJhdGlvQiApO1xyXG5cclxuXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRlcXVhbHM6IGZ1bmN0aW9uICggcXVhdGVybmlvbiApIHtcclxuXHJcblx0XHRyZXR1cm4gKCBxdWF0ZXJuaW9uLl94ID09PSB0aGlzLl94ICkgJiYgKCBxdWF0ZXJuaW9uLl95ID09PSB0aGlzLl95ICkgJiYgKCBxdWF0ZXJuaW9uLl96ID09PSB0aGlzLl96ICkgJiYgKCBxdWF0ZXJuaW9uLl93ID09PSB0aGlzLl93ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGZyb21BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xyXG5cclxuXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xyXG5cclxuXHRcdHRoaXMuX3ggPSBhcnJheVsgb2Zmc2V0IF07XHJcblx0XHR0aGlzLl95ID0gYXJyYXlbIG9mZnNldCArIDEgXTtcclxuXHRcdHRoaXMuX3ogPSBhcnJheVsgb2Zmc2V0ICsgMiBdO1xyXG5cdFx0dGhpcy5fdyA9IGFycmF5WyBvZmZzZXQgKyAzIF07XHJcblxyXG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHRvQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcclxuXHJcblx0XHRpZiAoIGFycmF5ID09PSB1bmRlZmluZWQgKSBhcnJheSA9IFtdO1xyXG5cdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XHJcblxyXG5cdFx0YXJyYXlbIG9mZnNldCBdID0gdGhpcy5feDtcclxuXHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLl95O1xyXG5cdFx0YXJyYXlbIG9mZnNldCArIDIgXSA9IHRoaXMuX3o7XHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgMyBdID0gdGhpcy5fdztcclxuXHJcblx0XHRyZXR1cm4gYXJyYXk7XHJcblxyXG5cdH0sXHJcblxyXG5cdG9uQ2hhbmdlOiBmdW5jdGlvbiAoIGNhbGxiYWNrICkge1xyXG5cclxuXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjayA9IGNhbGxiYWNrO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRvbkNoYW5nZUNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7fVxyXG5cclxufTtcclxuXHJcbk9iamVjdC5hc3NpZ24oIFRIUkVFLlF1YXRlcm5pb24sIHtcclxuXHJcblx0c2xlcnA6IGZ1bmN0aW9uKCBxYSwgcWIsIHFtLCB0ICkge1xyXG5cclxuXHRcdHJldHVybiBxbS5jb3B5KCBxYSApLnNsZXJwKCBxYiwgdCApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzbGVycEZsYXQ6IGZ1bmN0aW9uKFxyXG5cdFx0XHRkc3QsIGRzdE9mZnNldCwgc3JjMCwgc3JjT2Zmc2V0MCwgc3JjMSwgc3JjT2Zmc2V0MSwgdCApIHtcclxuXHJcblx0XHQvLyBmdXp6LWZyZWUsIGFycmF5LWJhc2VkIFF1YXRlcm5pb24gU0xFUlAgb3BlcmF0aW9uXHJcblxyXG5cdFx0dmFyIHgwID0gc3JjMFsgc3JjT2Zmc2V0MCArIDAgXSxcclxuXHRcdFx0eTAgPSBzcmMwWyBzcmNPZmZzZXQwICsgMSBdLFxyXG5cdFx0XHR6MCA9IHNyYzBbIHNyY09mZnNldDAgKyAyIF0sXHJcblx0XHRcdHcwID0gc3JjMFsgc3JjT2Zmc2V0MCArIDMgXSxcclxuXHJcblx0XHRcdHgxID0gc3JjMVsgc3JjT2Zmc2V0MSArIDAgXSxcclxuXHRcdFx0eTEgPSBzcmMxWyBzcmNPZmZzZXQxICsgMSBdLFxyXG5cdFx0XHR6MSA9IHNyYzFbIHNyY09mZnNldDEgKyAyIF0sXHJcblx0XHRcdHcxID0gc3JjMVsgc3JjT2Zmc2V0MSArIDMgXTtcclxuXHJcblx0XHRpZiAoIHcwICE9PSB3MSB8fCB4MCAhPT0geDEgfHwgeTAgIT09IHkxIHx8IHowICE9PSB6MSApIHtcclxuXHJcblx0XHRcdHZhciBzID0gMSAtIHQsXHJcblxyXG5cdFx0XHRcdGNvcyA9IHgwICogeDEgKyB5MCAqIHkxICsgejAgKiB6MSArIHcwICogdzEsXHJcblxyXG5cdFx0XHRcdGRpciA9ICggY29zID49IDAgPyAxIDogLSAxICksXHJcblx0XHRcdFx0c3FyU2luID0gMSAtIGNvcyAqIGNvcztcclxuXHJcblx0XHRcdC8vIFNraXAgdGhlIFNsZXJwIGZvciB0aW55IHN0ZXBzIHRvIGF2b2lkIG51bWVyaWMgcHJvYmxlbXM6XHJcblx0XHRcdGlmICggc3FyU2luID4gTnVtYmVyLkVQU0lMT04gKSB7XHJcblxyXG5cdFx0XHRcdHZhciBzaW4gPSBNYXRoLnNxcnQoIHNxclNpbiApLFxyXG5cdFx0XHRcdFx0bGVuID0gTWF0aC5hdGFuMiggc2luLCBjb3MgKiBkaXIgKTtcclxuXHJcblx0XHRcdFx0cyA9IE1hdGguc2luKCBzICogbGVuICkgLyBzaW47XHJcblx0XHRcdFx0dCA9IE1hdGguc2luKCB0ICogbGVuICkgLyBzaW47XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgdERpciA9IHQgKiBkaXI7XHJcblxyXG5cdFx0XHR4MCA9IHgwICogcyArIHgxICogdERpcjtcclxuXHRcdFx0eTAgPSB5MCAqIHMgKyB5MSAqIHREaXI7XHJcblx0XHRcdHowID0gejAgKiBzICsgejEgKiB0RGlyO1xyXG5cdFx0XHR3MCA9IHcwICogcyArIHcxICogdERpcjtcclxuXHJcblx0XHRcdC8vIE5vcm1hbGl6ZSBpbiBjYXNlIHdlIGp1c3QgZGlkIGEgbGVycDpcclxuXHRcdFx0aWYgKCBzID09PSAxIC0gdCApIHtcclxuXHJcblx0XHRcdFx0dmFyIGYgPSAxIC8gTWF0aC5zcXJ0KCB4MCAqIHgwICsgeTAgKiB5MCArIHowICogejAgKyB3MCAqIHcwICk7XHJcblxyXG5cdFx0XHRcdHgwICo9IGY7XHJcblx0XHRcdFx0eTAgKj0gZjtcclxuXHRcdFx0XHR6MCAqPSBmO1xyXG5cdFx0XHRcdHcwICo9IGY7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGRzdFsgZHN0T2Zmc2V0IF0gPSB4MDtcclxuXHRcdGRzdFsgZHN0T2Zmc2V0ICsgMSBdID0geTA7XHJcblx0XHRkc3RbIGRzdE9mZnNldCArIDIgXSA9IHowO1xyXG5cdFx0ZHN0WyBkc3RPZmZzZXQgKyAzIF0gPSB3MDtcclxuXHJcblx0fVxyXG5cclxufSApO1xyXG5cclxuLy8gRmlsZTpzcmMvbWF0aC9WZWN0b3IyLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBwaGlsb2diIC8gaHR0cDovL2Jsb2cudGhlaml0Lm9yZy9cclxuICogQGF1dGhvciBlZ3JhZXRoZXIgLyBodHRwOi8vZWdyYWV0aGVyLmNvbS9cclxuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xyXG4gKi9cclxuXHJcblRIUkVFLlZlY3RvcjIgPSBmdW5jdGlvbiAoIHgsIHkgKSB7XHJcblxyXG5cdHRoaXMueCA9IHggfHwgMDtcclxuXHR0aGlzLnkgPSB5IHx8IDA7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuVmVjdG9yMi5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5WZWN0b3IyLFxyXG5cclxuXHRnZXQgd2lkdGgoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMueDtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0IHdpZHRoKCB2YWx1ZSApIHtcclxuXHJcblx0XHR0aGlzLnggPSB2YWx1ZTtcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0IGhlaWdodCgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy55O1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXQgaGVpZ2h0KCB2YWx1ZSApIHtcclxuXHJcblx0XHR0aGlzLnkgPSB2YWx1ZTtcclxuXHJcblx0fSxcclxuXHJcblx0Ly9cclxuXHJcblx0c2V0OiBmdW5jdGlvbiAoIHgsIHkgKSB7XHJcblxyXG5cdFx0dGhpcy54ID0geDtcclxuXHRcdHRoaXMueSA9IHk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldFNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gc2NhbGFyO1xyXG5cdFx0dGhpcy55ID0gc2NhbGFyO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRYOiBmdW5jdGlvbiAoIHggKSB7XHJcblxyXG5cdFx0dGhpcy54ID0geDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0WTogZnVuY3Rpb24gKCB5ICkge1xyXG5cclxuXHRcdHRoaXMueSA9IHk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldENvbXBvbmVudDogZnVuY3Rpb24gKCBpbmRleCwgdmFsdWUgKSB7XHJcblxyXG5cdFx0c3dpdGNoICggaW5kZXggKSB7XHJcblxyXG5cdFx0XHRjYXNlIDA6IHRoaXMueCA9IHZhbHVlOyBicmVhaztcclxuXHRcdFx0Y2FzZSAxOiB0aGlzLnkgPSB2YWx1ZTsgYnJlYWs7XHJcblx0XHRcdGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvciggJ2luZGV4IGlzIG91dCBvZiByYW5nZTogJyArIGluZGV4ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHRnZXRDb21wb25lbnQ6IGZ1bmN0aW9uICggaW5kZXggKSB7XHJcblxyXG5cdFx0c3dpdGNoICggaW5kZXggKSB7XHJcblxyXG5cdFx0XHRjYXNlIDA6IHJldHVybiB0aGlzLng7XHJcblx0XHRcdGNhc2UgMTogcmV0dXJuIHRoaXMueTtcclxuXHRcdFx0ZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCAnaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAnICsgaW5kZXggKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLngsIHRoaXMueSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb3B5OiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gdi54O1xyXG5cdFx0dGhpcy55ID0gdi55O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRhZGQ6IGZ1bmN0aW9uICggdiwgdyApIHtcclxuXHJcblx0XHRpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjI6IC5hZGQoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5hZGRWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XHJcblx0XHRcdHJldHVybiB0aGlzLmFkZFZlY3RvcnMoIHYsIHcgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy54ICs9IHYueDtcclxuXHRcdHRoaXMueSArPSB2Lnk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFkZFNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xyXG5cclxuXHRcdHRoaXMueCArPSBzO1xyXG5cdFx0dGhpcy55ICs9IHM7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFkZFZlY3RvcnM6IGZ1bmN0aW9uICggYSwgYiApIHtcclxuXHJcblx0XHR0aGlzLnggPSBhLnggKyBiLng7XHJcblx0XHR0aGlzLnkgPSBhLnkgKyBiLnk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFkZFNjYWxlZFZlY3RvcjogZnVuY3Rpb24gKCB2LCBzICkge1xyXG5cclxuXHRcdHRoaXMueCArPSB2LnggKiBzO1xyXG5cdFx0dGhpcy55ICs9IHYueSAqIHM7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHN1YjogZnVuY3Rpb24gKCB2LCB3ICkge1xyXG5cclxuXHRcdGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMjogLnN1YigpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLnN1YlZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMuc3ViVmVjdG9ycyggdiwgdyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnggLT0gdi54O1xyXG5cdFx0dGhpcy55IC09IHYueTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c3ViU2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XHJcblxyXG5cdFx0dGhpcy54IC09IHM7XHJcblx0XHR0aGlzLnkgLT0gcztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c3ViVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xyXG5cclxuXHRcdHRoaXMueCA9IGEueCAtIGIueDtcclxuXHRcdHRoaXMueSA9IGEueSAtIGIueTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bXVsdGlwbHk6IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHR0aGlzLnggKj0gdi54O1xyXG5cdFx0dGhpcy55ICo9IHYueTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bXVsdGlwbHlTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xyXG5cclxuXHRcdGlmICggaXNGaW5pdGUoIHNjYWxhciApICkge1xyXG5cclxuXHRcdFx0dGhpcy54ICo9IHNjYWxhcjtcclxuXHRcdFx0dGhpcy55ICo9IHNjYWxhcjtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0dGhpcy54ID0gMDtcclxuXHRcdFx0dGhpcy55ID0gMDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRpdmlkZTogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHRoaXMueCAvPSB2Lng7XHJcblx0XHR0aGlzLnkgLz0gdi55O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRkaXZpZGVTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLm11bHRpcGx5U2NhbGFyKCAxIC8gc2NhbGFyICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdG1pbjogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHRoaXMueCA9IE1hdGgubWluKCB0aGlzLngsIHYueCApO1xyXG5cdFx0dGhpcy55ID0gTWF0aC5taW4oIHRoaXMueSwgdi55ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG1heDogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHRoaXMueCA9IE1hdGgubWF4KCB0aGlzLngsIHYueCApO1xyXG5cdFx0dGhpcy55ID0gTWF0aC5tYXgoIHRoaXMueSwgdi55ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNsYW1wOiBmdW5jdGlvbiAoIG1pbiwgbWF4ICkge1xyXG5cclxuXHRcdC8vIFRoaXMgZnVuY3Rpb24gYXNzdW1lcyBtaW4gPCBtYXgsIGlmIHRoaXMgYXNzdW1wdGlvbiBpc24ndCB0cnVlIGl0IHdpbGwgbm90IG9wZXJhdGUgY29ycmVjdGx5XHJcblxyXG5cdFx0dGhpcy54ID0gTWF0aC5tYXgoIG1pbi54LCBNYXRoLm1pbiggbWF4LngsIHRoaXMueCApICk7XHJcblx0XHR0aGlzLnkgPSBNYXRoLm1heCggbWluLnksIE1hdGgubWluKCBtYXgueSwgdGhpcy55ICkgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y2xhbXBTY2FsYXI6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgbWluLCBtYXg7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGNsYW1wU2NhbGFyKCBtaW5WYWwsIG1heFZhbCApIHtcclxuXHJcblx0XHRcdGlmICggbWluID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdG1pbiA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XHJcblx0XHRcdFx0bWF4ID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdG1pbi5zZXQoIG1pblZhbCwgbWluVmFsICk7XHJcblx0XHRcdG1heC5zZXQoIG1heFZhbCwgbWF4VmFsICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy5jbGFtcCggbWluLCBtYXggKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGNsYW1wTGVuZ3RoOiBmdW5jdGlvbiAoIG1pbiwgbWF4ICkge1xyXG5cclxuXHRcdHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCgpO1xyXG5cclxuXHRcdHRoaXMubXVsdGlwbHlTY2FsYXIoIE1hdGgubWF4KCBtaW4sIE1hdGgubWluKCBtYXgsIGxlbmd0aCApICkgLyBsZW5ndGggKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Zmxvb3I6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLnggPSBNYXRoLmZsb29yKCB0aGlzLnggKTtcclxuXHRcdHRoaXMueSA9IE1hdGguZmxvb3IoIHRoaXMueSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjZWlsOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gTWF0aC5jZWlsKCB0aGlzLnggKTtcclxuXHRcdHRoaXMueSA9IE1hdGguY2VpbCggdGhpcy55ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHJvdW5kOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gTWF0aC5yb3VuZCggdGhpcy54ICk7XHJcblx0XHR0aGlzLnkgPSBNYXRoLnJvdW5kKCB0aGlzLnkgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0cm91bmRUb1plcm86IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLnggPSAoIHRoaXMueCA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy54ICkgOiBNYXRoLmZsb29yKCB0aGlzLnggKTtcclxuXHRcdHRoaXMueSA9ICggdGhpcy55IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnkgKSA6IE1hdGguZmxvb3IoIHRoaXMueSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRuZWdhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLnggPSAtIHRoaXMueDtcclxuXHRcdHRoaXMueSA9IC0gdGhpcy55O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRkb3Q6IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy54ICogdi54ICsgdGhpcy55ICogdi55O1xyXG5cclxuXHR9LFxyXG5cclxuXHRsZW5ndGhTcTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGxlbmd0aDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRsZW5ndGhNYW5oYXR0YW46IGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdHJldHVybiBNYXRoLmFicyggdGhpcy54ICkgKyBNYXRoLmFicyggdGhpcy55ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdG5vcm1hbGl6ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmRpdmlkZVNjYWxhciggdGhpcy5sZW5ndGgoKSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRhbmdsZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdC8vIGNvbXB1dGVzIHRoZSBhbmdsZSBpbiByYWRpYW5zIHdpdGggcmVzcGVjdCB0byB0aGUgcG9zaXRpdmUgeC1heGlzXHJcblxyXG5cdFx0dmFyIGFuZ2xlID0gTWF0aC5hdGFuMiggdGhpcy55LCB0aGlzLnggKTtcclxuXHJcblx0XHRpZiAoIGFuZ2xlIDwgMCApIGFuZ2xlICs9IDIgKiBNYXRoLlBJO1xyXG5cclxuXHRcdHJldHVybiBhbmdsZTtcclxuXHJcblx0fSxcclxuXHJcblx0ZGlzdGFuY2VUbzogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMuZGlzdGFuY2VUb1NxdWFyZWQoIHYgKSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRkaXN0YW5jZVRvU3F1YXJlZDogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHZhciBkeCA9IHRoaXMueCAtIHYueCwgZHkgPSB0aGlzLnkgLSB2Lnk7XHJcblx0XHRyZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldExlbmd0aDogZnVuY3Rpb24gKCBsZW5ndGggKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoIGxlbmd0aCAvIHRoaXMubGVuZ3RoKCkgKTtcclxuXHJcblx0fSxcclxuXHJcblx0bGVycDogZnVuY3Rpb24gKCB2LCBhbHBoYSApIHtcclxuXHJcblx0XHR0aGlzLnggKz0gKCB2LnggLSB0aGlzLnggKSAqIGFscGhhO1xyXG5cdFx0dGhpcy55ICs9ICggdi55IC0gdGhpcy55ICkgKiBhbHBoYTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bGVycFZlY3RvcnM6IGZ1bmN0aW9uICggdjEsIHYyLCBhbHBoYSApIHtcclxuXHJcblx0XHR0aGlzLnN1YlZlY3RvcnMoIHYyLCB2MSApLm11bHRpcGx5U2NhbGFyKCBhbHBoYSApLmFkZCggdjEgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZXF1YWxzOiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG5cdFx0cmV0dXJuICggKCB2LnggPT09IHRoaXMueCApICYmICggdi55ID09PSB0aGlzLnkgKSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRmcm9tQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcclxuXHJcblx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcclxuXHJcblx0XHR0aGlzLnggPSBhcnJheVsgb2Zmc2V0IF07XHJcblx0XHR0aGlzLnkgPSBhcnJheVsgb2Zmc2V0ICsgMSBdO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHR0b0FycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0aWYgKCBhcnJheSA9PT0gdW5kZWZpbmVkICkgYXJyYXkgPSBbXTtcclxuXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xyXG5cclxuXHRcdGFycmF5WyBvZmZzZXQgXSA9IHRoaXMueDtcclxuXHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLnk7XHJcblxyXG5cdFx0cmV0dXJuIGFycmF5O1xyXG5cclxuXHR9LFxyXG5cclxuXHRmcm9tQXR0cmlidXRlOiBmdW5jdGlvbiAoIGF0dHJpYnV0ZSwgaW5kZXgsIG9mZnNldCApIHtcclxuXHJcblx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcclxuXHJcblx0XHRpbmRleCA9IGluZGV4ICogYXR0cmlidXRlLml0ZW1TaXplICsgb2Zmc2V0O1xyXG5cclxuXHRcdHRoaXMueCA9IGF0dHJpYnV0ZS5hcnJheVsgaW5kZXggXTtcclxuXHRcdHRoaXMueSA9IGF0dHJpYnV0ZS5hcnJheVsgaW5kZXggKyAxIF07XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHJvdGF0ZUFyb3VuZDogZnVuY3Rpb24gKCBjZW50ZXIsIGFuZ2xlICkge1xyXG5cclxuXHRcdHZhciBjID0gTWF0aC5jb3MoIGFuZ2xlICksIHMgPSBNYXRoLnNpbiggYW5nbGUgKTtcclxuXHJcblx0XHR2YXIgeCA9IHRoaXMueCAtIGNlbnRlci54O1xyXG5cdFx0dmFyIHkgPSB0aGlzLnkgLSBjZW50ZXIueTtcclxuXHJcblx0XHR0aGlzLnggPSB4ICogYyAtIHkgKiBzICsgY2VudGVyLng7XHJcblx0XHR0aGlzLnkgPSB4ICogcyArIHkgKiBjICsgY2VudGVyLnk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9tYXRoL1ZlY3RvcjMuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yICpraWxlIC8gaHR0cDovL2tpbGUuc3RyYXZhZ2FuemEub3JnL1xyXG4gKiBAYXV0aG9yIHBoaWxvZ2IgLyBodHRwOi8vYmxvZy50aGVqaXQub3JnL1xyXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xyXG4gKiBAYXV0aG9yIGVncmFldGhlciAvIGh0dHA6Ly9lZ3JhZXRoZXIuY29tL1xyXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcclxuICovXHJcblxyXG5USFJFRS5WZWN0b3IzID0gZnVuY3Rpb24gKCB4LCB5LCB6ICkge1xyXG5cclxuXHR0aGlzLnggPSB4IHx8IDA7XHJcblx0dGhpcy55ID0geSB8fCAwO1xyXG5cdHRoaXMueiA9IHogfHwgMDtcclxuXHJcbn07XHJcblxyXG5USFJFRS5WZWN0b3IzLnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLlZlY3RvcjMsXHJcblxyXG5cdHNldDogZnVuY3Rpb24gKCB4LCB5LCB6ICkge1xyXG5cclxuXHRcdHRoaXMueCA9IHg7XHJcblx0XHR0aGlzLnkgPSB5O1xyXG5cdFx0dGhpcy56ID0gejtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0U2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcclxuXHJcblx0XHR0aGlzLnggPSBzY2FsYXI7XHJcblx0XHR0aGlzLnkgPSBzY2FsYXI7XHJcblx0XHR0aGlzLnogPSBzY2FsYXI7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldFg6IGZ1bmN0aW9uICggeCApIHtcclxuXHJcblx0XHR0aGlzLnggPSB4O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRZOiBmdW5jdGlvbiAoIHkgKSB7XHJcblxyXG5cdFx0dGhpcy55ID0geTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0WjogZnVuY3Rpb24gKCB6ICkge1xyXG5cclxuXHRcdHRoaXMueiA9IHo7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldENvbXBvbmVudDogZnVuY3Rpb24gKCBpbmRleCwgdmFsdWUgKSB7XHJcblxyXG5cdFx0c3dpdGNoICggaW5kZXggKSB7XHJcblxyXG5cdFx0XHRjYXNlIDA6IHRoaXMueCA9IHZhbHVlOyBicmVhaztcclxuXHRcdFx0Y2FzZSAxOiB0aGlzLnkgPSB2YWx1ZTsgYnJlYWs7XHJcblx0XHRcdGNhc2UgMjogdGhpcy56ID0gdmFsdWU7IGJyZWFrO1xyXG5cdFx0XHRkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0Z2V0Q29tcG9uZW50OiBmdW5jdGlvbiAoIGluZGV4ICkge1xyXG5cclxuXHRcdHN3aXRjaCAoIGluZGV4ICkge1xyXG5cclxuXHRcdFx0Y2FzZSAwOiByZXR1cm4gdGhpcy54O1xyXG5cdFx0XHRjYXNlIDE6IHJldHVybiB0aGlzLnk7XHJcblx0XHRcdGNhc2UgMjogcmV0dXJuIHRoaXMuejtcclxuXHRcdFx0ZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCAnaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAnICsgaW5kZXggKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLngsIHRoaXMueSwgdGhpcy56ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvcHk6IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHR0aGlzLnggPSB2Lng7XHJcblx0XHR0aGlzLnkgPSB2Lnk7XHJcblx0XHR0aGlzLnogPSB2Lno7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFkZDogZnVuY3Rpb24gKCB2LCB3ICkge1xyXG5cclxuXHRcdGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLmFkZCgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLmFkZFZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMuYWRkVmVjdG9ycyggdiwgdyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnggKz0gdi54O1xyXG5cdFx0dGhpcy55ICs9IHYueTtcclxuXHRcdHRoaXMueiArPSB2Lno7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFkZFNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xyXG5cclxuXHRcdHRoaXMueCArPSBzO1xyXG5cdFx0dGhpcy55ICs9IHM7XHJcblx0XHR0aGlzLnogKz0gcztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0YWRkVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xyXG5cclxuXHRcdHRoaXMueCA9IGEueCArIGIueDtcclxuXHRcdHRoaXMueSA9IGEueSArIGIueTtcclxuXHRcdHRoaXMueiA9IGEueiArIGIuejtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0YWRkU2NhbGVkVmVjdG9yOiBmdW5jdGlvbiAoIHYsIHMgKSB7XHJcblxyXG5cdFx0dGhpcy54ICs9IHYueCAqIHM7XHJcblx0XHR0aGlzLnkgKz0gdi55ICogcztcclxuXHRcdHRoaXMueiArPSB2LnogKiBzO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzdWI6IGZ1bmN0aW9uICggdiwgdyApIHtcclxuXHJcblx0XHRpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjM6IC5zdWIoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5zdWJWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XHJcblx0XHRcdHJldHVybiB0aGlzLnN1YlZlY3RvcnMoIHYsIHcgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy54IC09IHYueDtcclxuXHRcdHRoaXMueSAtPSB2Lnk7XHJcblx0XHR0aGlzLnogLT0gdi56O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzdWJTY2FsYXI6IGZ1bmN0aW9uICggcyApIHtcclxuXHJcblx0XHR0aGlzLnggLT0gcztcclxuXHRcdHRoaXMueSAtPSBzO1xyXG5cdFx0dGhpcy56IC09IHM7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHN1YlZlY3RvcnM6IGZ1bmN0aW9uICggYSwgYiApIHtcclxuXHJcblx0XHR0aGlzLnggPSBhLnggLSBiLng7XHJcblx0XHR0aGlzLnkgPSBhLnkgLSBiLnk7XHJcblx0XHR0aGlzLnogPSBhLnogLSBiLno7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG11bHRpcGx5OiBmdW5jdGlvbiAoIHYsIHcgKSB7XHJcblxyXG5cdFx0aWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IzOiAubXVsdGlwbHkoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5tdWx0aXBseVZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlWZWN0b3JzKCB2LCB3ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMueCAqPSB2Lng7XHJcblx0XHR0aGlzLnkgKj0gdi55O1xyXG5cdFx0dGhpcy56ICo9IHYuejtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bXVsdGlwbHlTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xyXG5cclxuXHRcdGlmICggaXNGaW5pdGUoIHNjYWxhciApICkge1xyXG5cclxuXHRcdFx0dGhpcy54ICo9IHNjYWxhcjtcclxuXHRcdFx0dGhpcy55ICo9IHNjYWxhcjtcclxuXHRcdFx0dGhpcy56ICo9IHNjYWxhcjtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0dGhpcy54ID0gMDtcclxuXHRcdFx0dGhpcy55ID0gMDtcclxuXHRcdFx0dGhpcy56ID0gMDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG11bHRpcGx5VmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xyXG5cclxuXHRcdHRoaXMueCA9IGEueCAqIGIueDtcclxuXHRcdHRoaXMueSA9IGEueSAqIGIueTtcclxuXHRcdHRoaXMueiA9IGEueiAqIGIuejtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0YXBwbHlFdWxlcjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBxdWF0ZXJuaW9uO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiBhcHBseUV1bGVyKCBldWxlciApIHtcclxuXHJcblx0XHRcdGlmICggZXVsZXIgaW5zdGFuY2VvZiBUSFJFRS5FdWxlciA9PT0gZmFsc2UgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5WZWN0b3IzOiAuYXBwbHlFdWxlcigpIG5vdyBleHBlY3RzIGFuIEV1bGVyIHJvdGF0aW9uIHJhdGhlciB0aGFuIGEgVmVjdG9yMyBhbmQgb3JkZXIuJyApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBxdWF0ZXJuaW9uID09PSB1bmRlZmluZWQgKSBxdWF0ZXJuaW9uID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcclxuXHJcblx0XHRcdHRoaXMuYXBwbHlRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uLnNldEZyb21FdWxlciggZXVsZXIgKSApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRhcHBseUF4aXNBbmdsZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBxdWF0ZXJuaW9uO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiBhcHBseUF4aXNBbmdsZSggYXhpcywgYW5nbGUgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHF1YXRlcm5pb24gPT09IHVuZGVmaW5lZCApIHF1YXRlcm5pb24gPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xyXG5cclxuXHRcdFx0dGhpcy5hcHBseVF1YXRlcm5pb24oIHF1YXRlcm5pb24uc2V0RnJvbUF4aXNBbmdsZSggYXhpcywgYW5nbGUgKSApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRhcHBseU1hdHJpeDM6IGZ1bmN0aW9uICggbSApIHtcclxuXHJcblx0XHR2YXIgeCA9IHRoaXMueDtcclxuXHRcdHZhciB5ID0gdGhpcy55O1xyXG5cdFx0dmFyIHogPSB0aGlzLno7XHJcblxyXG5cdFx0dmFyIGUgPSBtLmVsZW1lbnRzO1xyXG5cclxuXHRcdHRoaXMueCA9IGVbIDAgXSAqIHggKyBlWyAzIF0gKiB5ICsgZVsgNiBdICogejtcclxuXHRcdHRoaXMueSA9IGVbIDEgXSAqIHggKyBlWyA0IF0gKiB5ICsgZVsgNyBdICogejtcclxuXHRcdHRoaXMueiA9IGVbIDIgXSAqIHggKyBlWyA1IF0gKiB5ICsgZVsgOCBdICogejtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0YXBwbHlNYXRyaXg0OiBmdW5jdGlvbiAoIG0gKSB7XHJcblxyXG5cdFx0Ly8gaW5wdXQ6IFRIUkVFLk1hdHJpeDQgYWZmaW5lIG1hdHJpeFxyXG5cclxuXHRcdHZhciB4ID0gdGhpcy54LCB5ID0gdGhpcy55LCB6ID0gdGhpcy56O1xyXG5cclxuXHRcdHZhciBlID0gbS5lbGVtZW50cztcclxuXHJcblx0XHR0aGlzLnggPSBlWyAwIF0gKiB4ICsgZVsgNCBdICogeSArIGVbIDggXSAgKiB6ICsgZVsgMTIgXTtcclxuXHRcdHRoaXMueSA9IGVbIDEgXSAqIHggKyBlWyA1IF0gKiB5ICsgZVsgOSBdICAqIHogKyBlWyAxMyBdO1xyXG5cdFx0dGhpcy56ID0gZVsgMiBdICogeCArIGVbIDYgXSAqIHkgKyBlWyAxMCBdICogeiArIGVbIDE0IF07XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFwcGx5UHJvamVjdGlvbjogZnVuY3Rpb24gKCBtICkge1xyXG5cclxuXHRcdC8vIGlucHV0OiBUSFJFRS5NYXRyaXg0IHByb2plY3Rpb24gbWF0cml4XHJcblxyXG5cdFx0dmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLno7XHJcblxyXG5cdFx0dmFyIGUgPSBtLmVsZW1lbnRzO1xyXG5cdFx0dmFyIGQgPSAxIC8gKCBlWyAzIF0gKiB4ICsgZVsgNyBdICogeSArIGVbIDExIF0gKiB6ICsgZVsgMTUgXSApOyAvLyBwZXJzcGVjdGl2ZSBkaXZpZGVcclxuXHJcblx0XHR0aGlzLnggPSAoIGVbIDAgXSAqIHggKyBlWyA0IF0gKiB5ICsgZVsgOCBdICAqIHogKyBlWyAxMiBdICkgKiBkO1xyXG5cdFx0dGhpcy55ID0gKCBlWyAxIF0gKiB4ICsgZVsgNSBdICogeSArIGVbIDkgXSAgKiB6ICsgZVsgMTMgXSApICogZDtcclxuXHRcdHRoaXMueiA9ICggZVsgMiBdICogeCArIGVbIDYgXSAqIHkgKyBlWyAxMCBdICogeiArIGVbIDE0IF0gKSAqIGQ7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFwcGx5UXVhdGVybmlvbjogZnVuY3Rpb24gKCBxICkge1xyXG5cclxuXHRcdHZhciB4ID0gdGhpcy54O1xyXG5cdFx0dmFyIHkgPSB0aGlzLnk7XHJcblx0XHR2YXIgeiA9IHRoaXMuejtcclxuXHJcblx0XHR2YXIgcXggPSBxLng7XHJcblx0XHR2YXIgcXkgPSBxLnk7XHJcblx0XHR2YXIgcXogPSBxLno7XHJcblx0XHR2YXIgcXcgPSBxLnc7XHJcblxyXG5cdFx0Ly8gY2FsY3VsYXRlIHF1YXQgKiB2ZWN0b3JcclxuXHJcblx0XHR2YXIgaXggPSAgcXcgKiB4ICsgcXkgKiB6IC0gcXogKiB5O1xyXG5cdFx0dmFyIGl5ID0gIHF3ICogeSArIHF6ICogeCAtIHF4ICogejtcclxuXHRcdHZhciBpeiA9ICBxdyAqIHogKyBxeCAqIHkgLSBxeSAqIHg7XHJcblx0XHR2YXIgaXcgPSAtIHF4ICogeCAtIHF5ICogeSAtIHF6ICogejtcclxuXHJcblx0XHQvLyBjYWxjdWxhdGUgcmVzdWx0ICogaW52ZXJzZSBxdWF0XHJcblxyXG5cdFx0dGhpcy54ID0gaXggKiBxdyArIGl3ICogLSBxeCArIGl5ICogLSBxeiAtIGl6ICogLSBxeTtcclxuXHRcdHRoaXMueSA9IGl5ICogcXcgKyBpdyAqIC0gcXkgKyBpeiAqIC0gcXggLSBpeCAqIC0gcXo7XHJcblx0XHR0aGlzLnogPSBpeiAqIHF3ICsgaXcgKiAtIHF6ICsgaXggKiAtIHF5IC0gaXkgKiAtIHF4O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRwcm9qZWN0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIG1hdHJpeDtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gcHJvamVjdCggY2FtZXJhICkge1xyXG5cclxuXHRcdFx0aWYgKCBtYXRyaXggPT09IHVuZGVmaW5lZCApIG1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblxyXG5cdFx0XHRtYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggY2FtZXJhLnByb2plY3Rpb25NYXRyaXgsIG1hdHJpeC5nZXRJbnZlcnNlKCBjYW1lcmEubWF0cml4V29ybGQgKSApO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5hcHBseVByb2plY3Rpb24oIG1hdHJpeCApO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0dW5wcm9qZWN0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIG1hdHJpeDtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gdW5wcm9qZWN0KCBjYW1lcmEgKSB7XHJcblxyXG5cdFx0XHRpZiAoIG1hdHJpeCA9PT0gdW5kZWZpbmVkICkgbWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHJcblx0XHRcdG1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBjYW1lcmEubWF0cml4V29ybGQsIG1hdHJpeC5nZXRJbnZlcnNlKCBjYW1lcmEucHJvamVjdGlvbk1hdHJpeCApICk7XHJcblx0XHRcdHJldHVybiB0aGlzLmFwcGx5UHJvamVjdGlvbiggbWF0cml4ICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHR0cmFuc2Zvcm1EaXJlY3Rpb246IGZ1bmN0aW9uICggbSApIHtcclxuXHJcblx0XHQvLyBpbnB1dDogVEhSRUUuTWF0cml4NCBhZmZpbmUgbWF0cml4XHJcblx0XHQvLyB2ZWN0b3IgaW50ZXJwcmV0ZWQgYXMgYSBkaXJlY3Rpb25cclxuXHJcblx0XHR2YXIgeCA9IHRoaXMueCwgeSA9IHRoaXMueSwgeiA9IHRoaXMuejtcclxuXHJcblx0XHR2YXIgZSA9IG0uZWxlbWVudHM7XHJcblxyXG5cdFx0dGhpcy54ID0gZVsgMCBdICogeCArIGVbIDQgXSAqIHkgKyBlWyA4IF0gICogejtcclxuXHRcdHRoaXMueSA9IGVbIDEgXSAqIHggKyBlWyA1IF0gKiB5ICsgZVsgOSBdICAqIHo7XHJcblx0XHR0aGlzLnogPSBlWyAyIF0gKiB4ICsgZVsgNiBdICogeSArIGVbIDEwIF0gKiB6O1xyXG5cclxuXHRcdHRoaXMubm9ybWFsaXplKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRpdmlkZTogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHRoaXMueCAvPSB2Lng7XHJcblx0XHR0aGlzLnkgLz0gdi55O1xyXG5cdFx0dGhpcy56IC89IHYuejtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZGl2aWRlU2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseVNjYWxhciggMSAvIHNjYWxhciApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtaW46IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHR0aGlzLnggPSBNYXRoLm1pbiggdGhpcy54LCB2LnggKTtcclxuXHRcdHRoaXMueSA9IE1hdGgubWluKCB0aGlzLnksIHYueSApO1xyXG5cdFx0dGhpcy56ID0gTWF0aC5taW4oIHRoaXMueiwgdi56ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG1heDogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHRoaXMueCA9IE1hdGgubWF4KCB0aGlzLngsIHYueCApO1xyXG5cdFx0dGhpcy55ID0gTWF0aC5tYXgoIHRoaXMueSwgdi55ICk7XHJcblx0XHR0aGlzLnogPSBNYXRoLm1heCggdGhpcy56LCB2LnogKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y2xhbXA6IGZ1bmN0aW9uICggbWluLCBtYXggKSB7XHJcblxyXG5cdFx0Ly8gVGhpcyBmdW5jdGlvbiBhc3N1bWVzIG1pbiA8IG1heCwgaWYgdGhpcyBhc3N1bXB0aW9uIGlzbid0IHRydWUgaXQgd2lsbCBub3Qgb3BlcmF0ZSBjb3JyZWN0bHlcclxuXHJcblx0XHR0aGlzLnggPSBNYXRoLm1heCggbWluLngsIE1hdGgubWluKCBtYXgueCwgdGhpcy54ICkgKTtcclxuXHRcdHRoaXMueSA9IE1hdGgubWF4KCBtaW4ueSwgTWF0aC5taW4oIG1heC55LCB0aGlzLnkgKSApO1xyXG5cdFx0dGhpcy56ID0gTWF0aC5tYXgoIG1pbi56LCBNYXRoLm1pbiggbWF4LnosIHRoaXMueiApICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNsYW1wU2NhbGFyOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIG1pbiwgbWF4O1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiBjbGFtcFNjYWxhciggbWluVmFsLCBtYXhWYWwgKSB7XHJcblxyXG5cdFx0XHRpZiAoIG1pbiA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRtaW4gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0XHRcdG1heCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRtaW4uc2V0KCBtaW5WYWwsIG1pblZhbCwgbWluVmFsICk7XHJcblx0XHRcdG1heC5zZXQoIG1heFZhbCwgbWF4VmFsLCBtYXhWYWwgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzLmNsYW1wKCBtaW4sIG1heCApO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0Y2xhbXBMZW5ndGg6IGZ1bmN0aW9uICggbWluLCBtYXggKSB7XHJcblxyXG5cdFx0dmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoKCk7XHJcblxyXG5cdFx0dGhpcy5tdWx0aXBseVNjYWxhciggTWF0aC5tYXgoIG1pbiwgTWF0aC5taW4oIG1heCwgbGVuZ3RoICkgKSAvIGxlbmd0aCApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRmbG9vcjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMueCA9IE1hdGguZmxvb3IoIHRoaXMueCApO1xyXG5cdFx0dGhpcy55ID0gTWF0aC5mbG9vciggdGhpcy55ICk7XHJcblx0XHR0aGlzLnogPSBNYXRoLmZsb29yKCB0aGlzLnogKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y2VpbDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMueCA9IE1hdGguY2VpbCggdGhpcy54ICk7XHJcblx0XHR0aGlzLnkgPSBNYXRoLmNlaWwoIHRoaXMueSApO1xyXG5cdFx0dGhpcy56ID0gTWF0aC5jZWlsKCB0aGlzLnogKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0cm91bmQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLnggPSBNYXRoLnJvdW5kKCB0aGlzLnggKTtcclxuXHRcdHRoaXMueSA9IE1hdGgucm91bmQoIHRoaXMueSApO1xyXG5cdFx0dGhpcy56ID0gTWF0aC5yb3VuZCggdGhpcy56ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHJvdW5kVG9aZXJvOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gKCB0aGlzLnggPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMueCApIDogTWF0aC5mbG9vciggdGhpcy54ICk7XHJcblx0XHR0aGlzLnkgPSAoIHRoaXMueSA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy55ICkgOiBNYXRoLmZsb29yKCB0aGlzLnkgKTtcclxuXHRcdHRoaXMueiA9ICggdGhpcy56IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnogKSA6IE1hdGguZmxvb3IoIHRoaXMueiApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRuZWdhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLnggPSAtIHRoaXMueDtcclxuXHRcdHRoaXMueSA9IC0gdGhpcy55O1xyXG5cdFx0dGhpcy56ID0gLSB0aGlzLno7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRvdDogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnggKiB2LnggKyB0aGlzLnkgKiB2LnkgKyB0aGlzLnogKiB2Lno7XHJcblxyXG5cdH0sXHJcblxyXG5cdGxlbmd0aFNxOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMuejtcclxuXHJcblx0fSxcclxuXHJcblx0bGVuZ3RoOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIE1hdGguc3FydCggdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGxlbmd0aE1hbmhhdHRhbjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBNYXRoLmFicyggdGhpcy54ICkgKyBNYXRoLmFicyggdGhpcy55ICkgKyBNYXRoLmFicyggdGhpcy56ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdG5vcm1hbGl6ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmRpdmlkZVNjYWxhciggdGhpcy5sZW5ndGgoKSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRMZW5ndGg6IGZ1bmN0aW9uICggbGVuZ3RoICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLm11bHRpcGx5U2NhbGFyKCBsZW5ndGggLyB0aGlzLmxlbmd0aCgpICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGxlcnA6IGZ1bmN0aW9uICggdiwgYWxwaGEgKSB7XHJcblxyXG5cdFx0dGhpcy54ICs9ICggdi54IC0gdGhpcy54ICkgKiBhbHBoYTtcclxuXHRcdHRoaXMueSArPSAoIHYueSAtIHRoaXMueSApICogYWxwaGE7XHJcblx0XHR0aGlzLnogKz0gKCB2LnogLSB0aGlzLnogKSAqIGFscGhhO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRsZXJwVmVjdG9yczogZnVuY3Rpb24gKCB2MSwgdjIsIGFscGhhICkge1xyXG5cclxuXHRcdHRoaXMuc3ViVmVjdG9ycyggdjIsIHYxICkubXVsdGlwbHlTY2FsYXIoIGFscGhhICkuYWRkKCB2MSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjcm9zczogZnVuY3Rpb24gKCB2LCB3ICkge1xyXG5cclxuXHRcdGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLmNyb3NzKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuY3Jvc3NWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XHJcblx0XHRcdHJldHVybiB0aGlzLmNyb3NzVmVjdG9ycyggdiwgdyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgeCA9IHRoaXMueCwgeSA9IHRoaXMueSwgeiA9IHRoaXMuejtcclxuXHJcblx0XHR0aGlzLnggPSB5ICogdi56IC0geiAqIHYueTtcclxuXHRcdHRoaXMueSA9IHogKiB2LnggLSB4ICogdi56O1xyXG5cdFx0dGhpcy56ID0geCAqIHYueSAtIHkgKiB2Lng7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNyb3NzVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xyXG5cclxuXHRcdHZhciBheCA9IGEueCwgYXkgPSBhLnksIGF6ID0gYS56O1xyXG5cdFx0dmFyIGJ4ID0gYi54LCBieSA9IGIueSwgYnogPSBiLno7XHJcblxyXG5cdFx0dGhpcy54ID0gYXkgKiBieiAtIGF6ICogYnk7XHJcblx0XHR0aGlzLnkgPSBheiAqIGJ4IC0gYXggKiBiejtcclxuXHRcdHRoaXMueiA9IGF4ICogYnkgLSBheSAqIGJ4O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRwcm9qZWN0T25WZWN0b3I6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdjEsIGRvdDtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gcHJvamVjdE9uVmVjdG9yKCB2ZWN0b3IgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHYxID09PSB1bmRlZmluZWQgKSB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0XHR2MS5jb3B5KCB2ZWN0b3IgKS5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRcdGRvdCA9IHRoaXMuZG90KCB2MSApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuY29weSggdjEgKS5tdWx0aXBseVNjYWxhciggZG90ICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRwcm9qZWN0T25QbGFuZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB2MTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gcHJvamVjdE9uUGxhbmUoIHBsYW5lTm9ybWFsICkge1xyXG5cclxuXHRcdFx0aWYgKCB2MSA9PT0gdW5kZWZpbmVkICkgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdFx0djEuY29weSggdGhpcyApLnByb2plY3RPblZlY3RvciggcGxhbmVOb3JtYWwgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzLnN1YiggdjEgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0oKSxcclxuXHJcblx0cmVmbGVjdDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdC8vIHJlZmxlY3QgaW5jaWRlbnQgdmVjdG9yIG9mZiBwbGFuZSBvcnRob2dvbmFsIHRvIG5vcm1hbFxyXG5cdFx0Ly8gbm9ybWFsIGlzIGFzc3VtZWQgdG8gaGF2ZSB1bml0IGxlbmd0aFxyXG5cclxuXHRcdHZhciB2MTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gcmVmbGVjdCggbm9ybWFsICkge1xyXG5cclxuXHRcdFx0aWYgKCB2MSA9PT0gdW5kZWZpbmVkICkgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuc3ViKCB2MS5jb3B5KCBub3JtYWwgKS5tdWx0aXBseVNjYWxhciggMiAqIHRoaXMuZG90KCBub3JtYWwgKSApICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9KCksXHJcblxyXG5cdGFuZ2xlVG86IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHR2YXIgdGhldGEgPSB0aGlzLmRvdCggdiApIC8gKCBNYXRoLnNxcnQoIHRoaXMubGVuZ3RoU3EoKSAqIHYubGVuZ3RoU3EoKSApICk7XHJcblxyXG5cdFx0Ly8gY2xhbXAsIHRvIGhhbmRsZSBudW1lcmljYWwgcHJvYmxlbXNcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5hY29zKCBUSFJFRS5NYXRoLmNsYW1wKCB0aGV0YSwgLSAxLCAxICkgKTtcclxuXHJcblx0fSxcclxuXHJcblx0ZGlzdGFuY2VUbzogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMuZGlzdGFuY2VUb1NxdWFyZWQoIHYgKSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRkaXN0YW5jZVRvU3F1YXJlZDogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHZhciBkeCA9IHRoaXMueCAtIHYueDtcclxuXHRcdHZhciBkeSA9IHRoaXMueSAtIHYueTtcclxuXHRcdHZhciBkeiA9IHRoaXMueiAtIHYuejtcclxuXHJcblx0XHRyZXR1cm4gZHggKiBkeCArIGR5ICogZHkgKyBkeiAqIGR6O1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRGcm9tTWF0cml4UG9zaXRpb246IGZ1bmN0aW9uICggbSApIHtcclxuXHJcblx0XHR0aGlzLnggPSBtLmVsZW1lbnRzWyAxMiBdO1xyXG5cdFx0dGhpcy55ID0gbS5lbGVtZW50c1sgMTMgXTtcclxuXHRcdHRoaXMueiA9IG0uZWxlbWVudHNbIDE0IF07XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldEZyb21NYXRyaXhTY2FsZTogZnVuY3Rpb24gKCBtICkge1xyXG5cclxuXHRcdHZhciBzeCA9IHRoaXMuc2V0KCBtLmVsZW1lbnRzWyAwIF0sIG0uZWxlbWVudHNbIDEgXSwgbS5lbGVtZW50c1sgMiBdICkubGVuZ3RoKCk7XHJcblx0XHR2YXIgc3kgPSB0aGlzLnNldCggbS5lbGVtZW50c1sgNCBdLCBtLmVsZW1lbnRzWyA1IF0sIG0uZWxlbWVudHNbIDYgXSApLmxlbmd0aCgpO1xyXG5cdFx0dmFyIHN6ID0gdGhpcy5zZXQoIG0uZWxlbWVudHNbIDggXSwgbS5lbGVtZW50c1sgOSBdLCBtLmVsZW1lbnRzWyAxMCBdICkubGVuZ3RoKCk7XHJcblxyXG5cdFx0dGhpcy54ID0gc3g7XHJcblx0XHR0aGlzLnkgPSBzeTtcclxuXHRcdHRoaXMueiA9IHN6O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRGcm9tTWF0cml4Q29sdW1uOiBmdW5jdGlvbiAoIGluZGV4LCBtYXRyaXggKSB7XHJcblxyXG5cdFx0dmFyIG9mZnNldCA9IGluZGV4ICogNDtcclxuXHJcblx0XHR2YXIgbWUgPSBtYXRyaXguZWxlbWVudHM7XHJcblxyXG5cdFx0dGhpcy54ID0gbWVbIG9mZnNldCBdO1xyXG5cdFx0dGhpcy55ID0gbWVbIG9mZnNldCArIDEgXTtcclxuXHRcdHRoaXMueiA9IG1lWyBvZmZzZXQgKyAyIF07XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGVxdWFsczogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHJldHVybiAoICggdi54ID09PSB0aGlzLnggKSAmJiAoIHYueSA9PT0gdGhpcy55ICkgJiYgKCB2LnogPT09IHRoaXMueiApICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGZyb21BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xyXG5cclxuXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xyXG5cclxuXHRcdHRoaXMueCA9IGFycmF5WyBvZmZzZXQgXTtcclxuXHRcdHRoaXMueSA9IGFycmF5WyBvZmZzZXQgKyAxIF07XHJcblx0XHR0aGlzLnogPSBhcnJheVsgb2Zmc2V0ICsgMiBdO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHR0b0FycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0aWYgKCBhcnJheSA9PT0gdW5kZWZpbmVkICkgYXJyYXkgPSBbXTtcclxuXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xyXG5cclxuXHRcdGFycmF5WyBvZmZzZXQgXSA9IHRoaXMueDtcclxuXHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLnk7XHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgMiBdID0gdGhpcy56O1xyXG5cclxuXHRcdHJldHVybiBhcnJheTtcclxuXHJcblx0fSxcclxuXHJcblx0ZnJvbUF0dHJpYnV0ZTogZnVuY3Rpb24gKCBhdHRyaWJ1dGUsIGluZGV4LCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XHJcblxyXG5cdFx0aW5kZXggPSBpbmRleCAqIGF0dHJpYnV0ZS5pdGVtU2l6ZSArIG9mZnNldDtcclxuXHJcblx0XHR0aGlzLnggPSBhdHRyaWJ1dGUuYXJyYXlbIGluZGV4IF07XHJcblx0XHR0aGlzLnkgPSBhdHRyaWJ1dGUuYXJyYXlbIGluZGV4ICsgMSBdO1xyXG5cdFx0dGhpcy56ID0gYXR0cmlidXRlLmFycmF5WyBpbmRleCArIDIgXTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL21hdGgvVmVjdG9yNC5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3Igc3VwZXJlZ2diZXJ0IC8gaHR0cDovL3d3dy5wYXVsYnJ1bnQuY28udWsvXHJcbiAqIEBhdXRob3IgcGhpbG9nYiAvIGh0dHA6Ly9ibG9nLnRoZWppdC5vcmcvXHJcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXHJcbiAqIEBhdXRob3IgZWdyYWV0aGVyIC8gaHR0cDovL2VncmFldGhlci5jb20vXHJcbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxyXG4gKi9cclxuXHJcblRIUkVFLlZlY3RvcjQgPSBmdW5jdGlvbiAoIHgsIHksIHosIHcgKSB7XHJcblxyXG5cdHRoaXMueCA9IHggfHwgMDtcclxuXHR0aGlzLnkgPSB5IHx8IDA7XHJcblx0dGhpcy56ID0geiB8fCAwO1xyXG5cdHRoaXMudyA9ICggdyAhPT0gdW5kZWZpbmVkICkgPyB3IDogMTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5WZWN0b3I0LnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLlZlY3RvcjQsXHJcblxyXG5cdHNldDogZnVuY3Rpb24gKCB4LCB5LCB6LCB3ICkge1xyXG5cclxuXHRcdHRoaXMueCA9IHg7XHJcblx0XHR0aGlzLnkgPSB5O1xyXG5cdFx0dGhpcy56ID0gejtcclxuXHRcdHRoaXMudyA9IHc7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldFNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gc2NhbGFyO1xyXG5cdFx0dGhpcy55ID0gc2NhbGFyO1xyXG5cdFx0dGhpcy56ID0gc2NhbGFyO1xyXG5cdFx0dGhpcy53ID0gc2NhbGFyO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRYOiBmdW5jdGlvbiAoIHggKSB7XHJcblxyXG5cdFx0dGhpcy54ID0geDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0WTogZnVuY3Rpb24gKCB5ICkge1xyXG5cclxuXHRcdHRoaXMueSA9IHk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldFo6IGZ1bmN0aW9uICggeiApIHtcclxuXHJcblx0XHR0aGlzLnogPSB6O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRXOiBmdW5jdGlvbiAoIHcgKSB7XHJcblxyXG5cdFx0dGhpcy53ID0gdztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0Q29tcG9uZW50OiBmdW5jdGlvbiAoIGluZGV4LCB2YWx1ZSApIHtcclxuXHJcblx0XHRzd2l0Y2ggKCBpbmRleCApIHtcclxuXHJcblx0XHRcdGNhc2UgMDogdGhpcy54ID0gdmFsdWU7IGJyZWFrO1xyXG5cdFx0XHRjYXNlIDE6IHRoaXMueSA9IHZhbHVlOyBicmVhaztcclxuXHRcdFx0Y2FzZSAyOiB0aGlzLnogPSB2YWx1ZTsgYnJlYWs7XHJcblx0XHRcdGNhc2UgMzogdGhpcy53ID0gdmFsdWU7IGJyZWFrO1xyXG5cdFx0XHRkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0Z2V0Q29tcG9uZW50OiBmdW5jdGlvbiAoIGluZGV4ICkge1xyXG5cclxuXHRcdHN3aXRjaCAoIGluZGV4ICkge1xyXG5cclxuXHRcdFx0Y2FzZSAwOiByZXR1cm4gdGhpcy54O1xyXG5cdFx0XHRjYXNlIDE6IHJldHVybiB0aGlzLnk7XHJcblx0XHRcdGNhc2UgMjogcmV0dXJuIHRoaXMuejtcclxuXHRcdFx0Y2FzZSAzOiByZXR1cm4gdGhpcy53O1xyXG5cdFx0XHRkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMueCwgdGhpcy55LCB0aGlzLnosIHRoaXMudyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb3B5OiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gdi54O1xyXG5cdFx0dGhpcy55ID0gdi55O1xyXG5cdFx0dGhpcy56ID0gdi56O1xyXG5cdFx0dGhpcy53ID0gKCB2LncgIT09IHVuZGVmaW5lZCApID8gdi53IDogMTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0YWRkOiBmdW5jdGlvbiAoIHYsIHcgKSB7XHJcblxyXG5cdFx0aWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3I0OiAuYWRkKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuYWRkVmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyApO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5hZGRWZWN0b3JzKCB2LCB3ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMueCArPSB2Lng7XHJcblx0XHR0aGlzLnkgKz0gdi55O1xyXG5cdFx0dGhpcy56ICs9IHYuejtcclxuXHRcdHRoaXMudyArPSB2Lnc7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFkZFNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xyXG5cclxuXHRcdHRoaXMueCArPSBzO1xyXG5cdFx0dGhpcy55ICs9IHM7XHJcblx0XHR0aGlzLnogKz0gcztcclxuXHRcdHRoaXMudyArPSBzO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRhZGRWZWN0b3JzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gYS54ICsgYi54O1xyXG5cdFx0dGhpcy55ID0gYS55ICsgYi55O1xyXG5cdFx0dGhpcy56ID0gYS56ICsgYi56O1xyXG5cdFx0dGhpcy53ID0gYS53ICsgYi53O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRhZGRTY2FsZWRWZWN0b3I6IGZ1bmN0aW9uICggdiwgcyApIHtcclxuXHJcblx0XHR0aGlzLnggKz0gdi54ICogcztcclxuXHRcdHRoaXMueSArPSB2LnkgKiBzO1xyXG5cdFx0dGhpcy56ICs9IHYueiAqIHM7XHJcblx0XHR0aGlzLncgKz0gdi53ICogcztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c3ViOiBmdW5jdGlvbiAoIHYsIHcgKSB7XHJcblxyXG5cdFx0aWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3I0OiAuc3ViKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuc3ViVmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyApO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5zdWJWZWN0b3JzKCB2LCB3ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMueCAtPSB2Lng7XHJcblx0XHR0aGlzLnkgLT0gdi55O1xyXG5cdFx0dGhpcy56IC09IHYuejtcclxuXHRcdHRoaXMudyAtPSB2Lnc7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHN1YlNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xyXG5cclxuXHRcdHRoaXMueCAtPSBzO1xyXG5cdFx0dGhpcy55IC09IHM7XHJcblx0XHR0aGlzLnogLT0gcztcclxuXHRcdHRoaXMudyAtPSBzO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzdWJWZWN0b3JzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gYS54IC0gYi54O1xyXG5cdFx0dGhpcy55ID0gYS55IC0gYi55O1xyXG5cdFx0dGhpcy56ID0gYS56IC0gYi56O1xyXG5cdFx0dGhpcy53ID0gYS53IC0gYi53O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtdWx0aXBseVNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XHJcblxyXG5cdFx0aWYgKCBpc0Zpbml0ZSggc2NhbGFyICkgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnggKj0gc2NhbGFyO1xyXG5cdFx0XHR0aGlzLnkgKj0gc2NhbGFyO1xyXG5cdFx0XHR0aGlzLnogKj0gc2NhbGFyO1xyXG5cdFx0XHR0aGlzLncgKj0gc2NhbGFyO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHR0aGlzLnggPSAwO1xyXG5cdFx0XHR0aGlzLnkgPSAwO1xyXG5cdFx0XHR0aGlzLnogPSAwO1xyXG5cdFx0XHR0aGlzLncgPSAwO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0YXBwbHlNYXRyaXg0OiBmdW5jdGlvbiAoIG0gKSB7XHJcblxyXG5cdFx0dmFyIHggPSB0aGlzLng7XHJcblx0XHR2YXIgeSA9IHRoaXMueTtcclxuXHRcdHZhciB6ID0gdGhpcy56O1xyXG5cdFx0dmFyIHcgPSB0aGlzLnc7XHJcblxyXG5cdFx0dmFyIGUgPSBtLmVsZW1lbnRzO1xyXG5cclxuXHRcdHRoaXMueCA9IGVbIDAgXSAqIHggKyBlWyA0IF0gKiB5ICsgZVsgOCBdICogeiArIGVbIDEyIF0gKiB3O1xyXG5cdFx0dGhpcy55ID0gZVsgMSBdICogeCArIGVbIDUgXSAqIHkgKyBlWyA5IF0gKiB6ICsgZVsgMTMgXSAqIHc7XHJcblx0XHR0aGlzLnogPSBlWyAyIF0gKiB4ICsgZVsgNiBdICogeSArIGVbIDEwIF0gKiB6ICsgZVsgMTQgXSAqIHc7XHJcblx0XHR0aGlzLncgPSBlWyAzIF0gKiB4ICsgZVsgNyBdICogeSArIGVbIDExIF0gKiB6ICsgZVsgMTUgXSAqIHc7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRpdmlkZVNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoIDEgLyBzY2FsYXIgKTtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0QXhpc0FuZ2xlRnJvbVF1YXRlcm5pb246IGZ1bmN0aW9uICggcSApIHtcclxuXHJcblx0XHQvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9nZW9tZXRyeS9yb3RhdGlvbnMvY29udmVyc2lvbnMvcXVhdGVybmlvblRvQW5nbGUvaW5kZXguaHRtXHJcblxyXG5cdFx0Ly8gcSBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWRcclxuXHJcblx0XHR0aGlzLncgPSAyICogTWF0aC5hY29zKCBxLncgKTtcclxuXHJcblx0XHR2YXIgcyA9IE1hdGguc3FydCggMSAtIHEudyAqIHEudyApO1xyXG5cclxuXHRcdGlmICggcyA8IDAuMDAwMSApIHtcclxuXHJcblx0XHRcdCB0aGlzLnggPSAxO1xyXG5cdFx0XHQgdGhpcy55ID0gMDtcclxuXHRcdFx0IHRoaXMueiA9IDA7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdCB0aGlzLnggPSBxLnggLyBzO1xyXG5cdFx0XHQgdGhpcy55ID0gcS55IC8gcztcclxuXHRcdFx0IHRoaXMueiA9IHEueiAvIHM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRBeGlzQW5nbGVGcm9tUm90YXRpb25NYXRyaXg6IGZ1bmN0aW9uICggbSApIHtcclxuXHJcblx0XHQvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9nZW9tZXRyeS9yb3RhdGlvbnMvY29udmVyc2lvbnMvbWF0cml4VG9BbmdsZS9pbmRleC5odG1cclxuXHJcblx0XHQvLyBhc3N1bWVzIHRoZSB1cHBlciAzeDMgb2YgbSBpcyBhIHB1cmUgcm90YXRpb24gbWF0cml4IChpLmUsIHVuc2NhbGVkKVxyXG5cclxuXHRcdHZhciBhbmdsZSwgeCwgeSwgeixcdFx0Ly8gdmFyaWFibGVzIGZvciByZXN1bHRcclxuXHRcdFx0ZXBzaWxvbiA9IDAuMDEsXHRcdC8vIG1hcmdpbiB0byBhbGxvdyBmb3Igcm91bmRpbmcgZXJyb3JzXHJcblx0XHRcdGVwc2lsb24yID0gMC4xLFx0XHQvLyBtYXJnaW4gdG8gZGlzdGluZ3Vpc2ggYmV0d2VlbiAwIGFuZCAxODAgZGVncmVlc1xyXG5cclxuXHRcdFx0dGUgPSBtLmVsZW1lbnRzLFxyXG5cclxuXHRcdFx0bTExID0gdGVbIDAgXSwgbTEyID0gdGVbIDQgXSwgbTEzID0gdGVbIDggXSxcclxuXHRcdFx0bTIxID0gdGVbIDEgXSwgbTIyID0gdGVbIDUgXSwgbTIzID0gdGVbIDkgXSxcclxuXHRcdFx0bTMxID0gdGVbIDIgXSwgbTMyID0gdGVbIDYgXSwgbTMzID0gdGVbIDEwIF07XHJcblxyXG5cdFx0aWYgKCAoIE1hdGguYWJzKCBtMTIgLSBtMjEgKSA8IGVwc2lsb24gKVxyXG5cdFx0ICAgJiYgKCBNYXRoLmFicyggbTEzIC0gbTMxICkgPCBlcHNpbG9uIClcclxuXHRcdCAgICYmICggTWF0aC5hYnMoIG0yMyAtIG0zMiApIDwgZXBzaWxvbiApICkge1xyXG5cclxuXHRcdFx0Ly8gc2luZ3VsYXJpdHkgZm91bmRcclxuXHRcdFx0Ly8gZmlyc3QgY2hlY2sgZm9yIGlkZW50aXR5IG1hdHJpeCB3aGljaCBtdXN0IGhhdmUgKzEgZm9yIGFsbCB0ZXJtc1xyXG5cdFx0XHQvLyBpbiBsZWFkaW5nIGRpYWdvbmFsIGFuZCB6ZXJvIGluIG90aGVyIHRlcm1zXHJcblxyXG5cdFx0XHRpZiAoICggTWF0aC5hYnMoIG0xMiArIG0yMSApIDwgZXBzaWxvbjIgKVxyXG5cdFx0XHQgICAmJiAoIE1hdGguYWJzKCBtMTMgKyBtMzEgKSA8IGVwc2lsb24yIClcclxuXHRcdFx0ICAgJiYgKCBNYXRoLmFicyggbTIzICsgbTMyICkgPCBlcHNpbG9uMiApXHJcblx0XHRcdCAgICYmICggTWF0aC5hYnMoIG0xMSArIG0yMiArIG0zMyAtIDMgKSA8IGVwc2lsb24yICkgKSB7XHJcblxyXG5cdFx0XHRcdC8vIHRoaXMgc2luZ3VsYXJpdHkgaXMgaWRlbnRpdHkgbWF0cml4IHNvIGFuZ2xlID0gMFxyXG5cclxuXHRcdFx0XHR0aGlzLnNldCggMSwgMCwgMCwgMCApO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gdGhpczsgLy8gemVybyBhbmdsZSwgYXJiaXRyYXJ5IGF4aXNcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIG90aGVyd2lzZSB0aGlzIHNpbmd1bGFyaXR5IGlzIGFuZ2xlID0gMTgwXHJcblxyXG5cdFx0XHRhbmdsZSA9IE1hdGguUEk7XHJcblxyXG5cdFx0XHR2YXIgeHggPSAoIG0xMSArIDEgKSAvIDI7XHJcblx0XHRcdHZhciB5eSA9ICggbTIyICsgMSApIC8gMjtcclxuXHRcdFx0dmFyIHp6ID0gKCBtMzMgKyAxICkgLyAyO1xyXG5cdFx0XHR2YXIgeHkgPSAoIG0xMiArIG0yMSApIC8gNDtcclxuXHRcdFx0dmFyIHh6ID0gKCBtMTMgKyBtMzEgKSAvIDQ7XHJcblx0XHRcdHZhciB5eiA9ICggbTIzICsgbTMyICkgLyA0O1xyXG5cclxuXHRcdFx0aWYgKCAoIHh4ID4geXkgKSAmJiAoIHh4ID4genogKSApIHtcclxuXHJcblx0XHRcdFx0Ly8gbTExIGlzIHRoZSBsYXJnZXN0IGRpYWdvbmFsIHRlcm1cclxuXHJcblx0XHRcdFx0aWYgKCB4eCA8IGVwc2lsb24gKSB7XHJcblxyXG5cdFx0XHRcdFx0eCA9IDA7XHJcblx0XHRcdFx0XHR5ID0gMC43MDcxMDY3ODE7XHJcblx0XHRcdFx0XHR6ID0gMC43MDcxMDY3ODE7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0eCA9IE1hdGguc3FydCggeHggKTtcclxuXHRcdFx0XHRcdHkgPSB4eSAvIHg7XHJcblx0XHRcdFx0XHR6ID0geHogLyB4O1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCB5eSA+IHp6ICkge1xyXG5cclxuXHRcdFx0XHQvLyBtMjIgaXMgdGhlIGxhcmdlc3QgZGlhZ29uYWwgdGVybVxyXG5cclxuXHRcdFx0XHRpZiAoIHl5IDwgZXBzaWxvbiApIHtcclxuXHJcblx0XHRcdFx0XHR4ID0gMC43MDcxMDY3ODE7XHJcblx0XHRcdFx0XHR5ID0gMDtcclxuXHRcdFx0XHRcdHogPSAwLjcwNzEwNjc4MTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHR5ID0gTWF0aC5zcXJ0KCB5eSApO1xyXG5cdFx0XHRcdFx0eCA9IHh5IC8geTtcclxuXHRcdFx0XHRcdHogPSB5eiAvIHk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdC8vIG0zMyBpcyB0aGUgbGFyZ2VzdCBkaWFnb25hbCB0ZXJtIHNvIGJhc2UgcmVzdWx0IG9uIHRoaXNcclxuXHJcblx0XHRcdFx0aWYgKCB6eiA8IGVwc2lsb24gKSB7XHJcblxyXG5cdFx0XHRcdFx0eCA9IDAuNzA3MTA2NzgxO1xyXG5cdFx0XHRcdFx0eSA9IDAuNzA3MTA2NzgxO1xyXG5cdFx0XHRcdFx0eiA9IDA7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0eiA9IE1hdGguc3FydCggenogKTtcclxuXHRcdFx0XHRcdHggPSB4eiAvIHo7XHJcblx0XHRcdFx0XHR5ID0geXogLyB6O1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLnNldCggeCwgeSwgeiwgYW5nbGUgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzOyAvLyByZXR1cm4gMTgwIGRlZyByb3RhdGlvblxyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBhcyB3ZSBoYXZlIHJlYWNoZWQgaGVyZSB0aGVyZSBhcmUgbm8gc2luZ3VsYXJpdGllcyBzbyB3ZSBjYW4gaGFuZGxlIG5vcm1hbGx5XHJcblxyXG5cdFx0dmFyIHMgPSBNYXRoLnNxcnQoICggbTMyIC0gbTIzICkgKiAoIG0zMiAtIG0yMyApXHJcblx0XHRcdFx0XHRcdCAgKyAoIG0xMyAtIG0zMSApICogKCBtMTMgLSBtMzEgKVxyXG5cdFx0XHRcdFx0XHQgICsgKCBtMjEgLSBtMTIgKSAqICggbTIxIC0gbTEyICkgKTsgLy8gdXNlZCB0byBub3JtYWxpemVcclxuXHJcblx0XHRpZiAoIE1hdGguYWJzKCBzICkgPCAwLjAwMSApIHMgPSAxO1xyXG5cclxuXHRcdC8vIHByZXZlbnQgZGl2aWRlIGJ5IHplcm8sIHNob3VsZCBub3QgaGFwcGVuIGlmIG1hdHJpeCBpcyBvcnRob2dvbmFsIGFuZCBzaG91bGQgYmVcclxuXHRcdC8vIGNhdWdodCBieSBzaW5ndWxhcml0eSB0ZXN0IGFib3ZlLCBidXQgSSd2ZSBsZWZ0IGl0IGluIGp1c3QgaW4gY2FzZVxyXG5cclxuXHRcdHRoaXMueCA9ICggbTMyIC0gbTIzICkgLyBzO1xyXG5cdFx0dGhpcy55ID0gKCBtMTMgLSBtMzEgKSAvIHM7XHJcblx0XHR0aGlzLnogPSAoIG0yMSAtIG0xMiApIC8gcztcclxuXHRcdHRoaXMudyA9IE1hdGguYWNvcyggKCBtMTEgKyBtMjIgKyBtMzMgLSAxICkgLyAyICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG1pbjogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHRoaXMueCA9IE1hdGgubWluKCB0aGlzLngsIHYueCApO1xyXG5cdFx0dGhpcy55ID0gTWF0aC5taW4oIHRoaXMueSwgdi55ICk7XHJcblx0XHR0aGlzLnogPSBNYXRoLm1pbiggdGhpcy56LCB2LnogKTtcclxuXHRcdHRoaXMudyA9IE1hdGgubWluKCB0aGlzLncsIHYudyApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtYXg6IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHR0aGlzLnggPSBNYXRoLm1heCggdGhpcy54LCB2LnggKTtcclxuXHRcdHRoaXMueSA9IE1hdGgubWF4KCB0aGlzLnksIHYueSApO1xyXG5cdFx0dGhpcy56ID0gTWF0aC5tYXgoIHRoaXMueiwgdi56ICk7XHJcblx0XHR0aGlzLncgPSBNYXRoLm1heCggdGhpcy53LCB2LncgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y2xhbXA6IGZ1bmN0aW9uICggbWluLCBtYXggKSB7XHJcblxyXG5cdFx0Ly8gVGhpcyBmdW5jdGlvbiBhc3N1bWVzIG1pbiA8IG1heCwgaWYgdGhpcyBhc3N1bXB0aW9uIGlzbid0IHRydWUgaXQgd2lsbCBub3Qgb3BlcmF0ZSBjb3JyZWN0bHlcclxuXHJcblx0XHR0aGlzLnggPSBNYXRoLm1heCggbWluLngsIE1hdGgubWluKCBtYXgueCwgdGhpcy54ICkgKTtcclxuXHRcdHRoaXMueSA9IE1hdGgubWF4KCBtaW4ueSwgTWF0aC5taW4oIG1heC55LCB0aGlzLnkgKSApO1xyXG5cdFx0dGhpcy56ID0gTWF0aC5tYXgoIG1pbi56LCBNYXRoLm1pbiggbWF4LnosIHRoaXMueiApICk7XHJcblx0XHR0aGlzLncgPSBNYXRoLm1heCggbWluLncsIE1hdGgubWluKCBtYXgudywgdGhpcy53ICkgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y2xhbXBTY2FsYXI6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgbWluLCBtYXg7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGNsYW1wU2NhbGFyKCBtaW5WYWwsIG1heFZhbCApIHtcclxuXHJcblx0XHRcdGlmICggbWluID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdG1pbiA9IG5ldyBUSFJFRS5WZWN0b3I0KCk7XHJcblx0XHRcdFx0bWF4ID0gbmV3IFRIUkVFLlZlY3RvcjQoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdG1pbi5zZXQoIG1pblZhbCwgbWluVmFsLCBtaW5WYWwsIG1pblZhbCApO1xyXG5cdFx0XHRtYXguc2V0KCBtYXhWYWwsIG1heFZhbCwgbWF4VmFsLCBtYXhWYWwgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzLmNsYW1wKCBtaW4sIG1heCApO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0Zmxvb3I6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLnggPSBNYXRoLmZsb29yKCB0aGlzLnggKTtcclxuXHRcdHRoaXMueSA9IE1hdGguZmxvb3IoIHRoaXMueSApO1xyXG5cdFx0dGhpcy56ID0gTWF0aC5mbG9vciggdGhpcy56ICk7XHJcblx0XHR0aGlzLncgPSBNYXRoLmZsb29yKCB0aGlzLncgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y2VpbDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMueCA9IE1hdGguY2VpbCggdGhpcy54ICk7XHJcblx0XHR0aGlzLnkgPSBNYXRoLmNlaWwoIHRoaXMueSApO1xyXG5cdFx0dGhpcy56ID0gTWF0aC5jZWlsKCB0aGlzLnogKTtcclxuXHRcdHRoaXMudyA9IE1hdGguY2VpbCggdGhpcy53ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHJvdW5kOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gTWF0aC5yb3VuZCggdGhpcy54ICk7XHJcblx0XHR0aGlzLnkgPSBNYXRoLnJvdW5kKCB0aGlzLnkgKTtcclxuXHRcdHRoaXMueiA9IE1hdGgucm91bmQoIHRoaXMueiApO1xyXG5cdFx0dGhpcy53ID0gTWF0aC5yb3VuZCggdGhpcy53ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHJvdW5kVG9aZXJvOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gKCB0aGlzLnggPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMueCApIDogTWF0aC5mbG9vciggdGhpcy54ICk7XHJcblx0XHR0aGlzLnkgPSAoIHRoaXMueSA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy55ICkgOiBNYXRoLmZsb29yKCB0aGlzLnkgKTtcclxuXHRcdHRoaXMueiA9ICggdGhpcy56IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnogKSA6IE1hdGguZmxvb3IoIHRoaXMueiApO1xyXG5cdFx0dGhpcy53ID0gKCB0aGlzLncgPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMudyApIDogTWF0aC5mbG9vciggdGhpcy53ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG5lZ2F0ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMueCA9IC0gdGhpcy54O1xyXG5cdFx0dGhpcy55ID0gLSB0aGlzLnk7XHJcblx0XHR0aGlzLnogPSAtIHRoaXMuejtcclxuXHRcdHRoaXMudyA9IC0gdGhpcy53O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRkb3Q6IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy54ICogdi54ICsgdGhpcy55ICogdi55ICsgdGhpcy56ICogdi56ICsgdGhpcy53ICogdi53O1xyXG5cclxuXHR9LFxyXG5cclxuXHRsZW5ndGhTcTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLnogKyB0aGlzLncgKiB0aGlzLnc7XHJcblxyXG5cdH0sXHJcblxyXG5cdGxlbmd0aDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMueiArIHRoaXMudyAqIHRoaXMudyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRsZW5ndGhNYW5oYXR0YW46IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5hYnMoIHRoaXMueCApICsgTWF0aC5hYnMoIHRoaXMueSApICsgTWF0aC5hYnMoIHRoaXMueiApICsgTWF0aC5hYnMoIHRoaXMudyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRub3JtYWxpemU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIoIHRoaXMubGVuZ3RoKCkgKTtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0TGVuZ3RoOiBmdW5jdGlvbiAoIGxlbmd0aCApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseVNjYWxhciggbGVuZ3RoIC8gdGhpcy5sZW5ndGgoKSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRsZXJwOiBmdW5jdGlvbiAoIHYsIGFscGhhICkge1xyXG5cclxuXHRcdHRoaXMueCArPSAoIHYueCAtIHRoaXMueCApICogYWxwaGE7XHJcblx0XHR0aGlzLnkgKz0gKCB2LnkgLSB0aGlzLnkgKSAqIGFscGhhO1xyXG5cdFx0dGhpcy56ICs9ICggdi56IC0gdGhpcy56ICkgKiBhbHBoYTtcclxuXHRcdHRoaXMudyArPSAoIHYudyAtIHRoaXMudyApICogYWxwaGE7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGxlcnBWZWN0b3JzOiBmdW5jdGlvbiAoIHYxLCB2MiwgYWxwaGEgKSB7XHJcblxyXG5cdFx0dGhpcy5zdWJWZWN0b3JzKCB2MiwgdjEgKS5tdWx0aXBseVNjYWxhciggYWxwaGEgKS5hZGQoIHYxICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGVxdWFsczogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHJldHVybiAoICggdi54ID09PSB0aGlzLnggKSAmJiAoIHYueSA9PT0gdGhpcy55ICkgJiYgKCB2LnogPT09IHRoaXMueiApICYmICggdi53ID09PSB0aGlzLncgKSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRmcm9tQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcclxuXHJcblx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcclxuXHJcblx0XHR0aGlzLnggPSBhcnJheVsgb2Zmc2V0IF07XHJcblx0XHR0aGlzLnkgPSBhcnJheVsgb2Zmc2V0ICsgMSBdO1xyXG5cdFx0dGhpcy56ID0gYXJyYXlbIG9mZnNldCArIDIgXTtcclxuXHRcdHRoaXMudyA9IGFycmF5WyBvZmZzZXQgKyAzIF07XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHRvQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcclxuXHJcblx0XHRpZiAoIGFycmF5ID09PSB1bmRlZmluZWQgKSBhcnJheSA9IFtdO1xyXG5cdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XHJcblxyXG5cdFx0YXJyYXlbIG9mZnNldCBdID0gdGhpcy54O1xyXG5cdFx0YXJyYXlbIG9mZnNldCArIDEgXSA9IHRoaXMueTtcclxuXHRcdGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0aGlzLno7XHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgMyBdID0gdGhpcy53O1xyXG5cclxuXHRcdHJldHVybiBhcnJheTtcclxuXHJcblx0fSxcclxuXHJcblx0ZnJvbUF0dHJpYnV0ZTogZnVuY3Rpb24gKCBhdHRyaWJ1dGUsIGluZGV4LCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XHJcblxyXG5cdFx0aW5kZXggPSBpbmRleCAqIGF0dHJpYnV0ZS5pdGVtU2l6ZSArIG9mZnNldDtcclxuXHJcblx0XHR0aGlzLnggPSBhdHRyaWJ1dGUuYXJyYXlbIGluZGV4IF07XHJcblx0XHR0aGlzLnkgPSBhdHRyaWJ1dGUuYXJyYXlbIGluZGV4ICsgMSBdO1xyXG5cdFx0dGhpcy56ID0gYXR0cmlidXRlLmFycmF5WyBpbmRleCArIDIgXTtcclxuXHRcdHRoaXMudyA9IGF0dHJpYnV0ZS5hcnJheVsgaW5kZXggKyAzIF07XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9tYXRoL0V1bGVyLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XHJcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cclxuICovXHJcblxyXG5USFJFRS5FdWxlciA9IGZ1bmN0aW9uICggeCwgeSwgeiwgb3JkZXIgKSB7XHJcblxyXG5cdHRoaXMuX3ggPSB4IHx8IDA7XHJcblx0dGhpcy5feSA9IHkgfHwgMDtcclxuXHR0aGlzLl96ID0geiB8fCAwO1xyXG5cdHRoaXMuX29yZGVyID0gb3JkZXIgfHwgVEhSRUUuRXVsZXIuRGVmYXVsdE9yZGVyO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkV1bGVyLlJvdGF0aW9uT3JkZXJzID0gWyAnWFlaJywgJ1laWCcsICdaWFknLCAnWFpZJywgJ1lYWicsICdaWVgnIF07XHJcblxyXG5USFJFRS5FdWxlci5EZWZhdWx0T3JkZXIgPSAnWFlaJztcclxuXHJcblRIUkVFLkV1bGVyLnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLkV1bGVyLFxyXG5cclxuXHRnZXQgeCAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX3g7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldCB4ICggdmFsdWUgKSB7XHJcblxyXG5cdFx0dGhpcy5feCA9IHZhbHVlO1xyXG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldCB5ICgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5feTtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0IHkgKCB2YWx1ZSApIHtcclxuXHJcblx0XHR0aGlzLl95ID0gdmFsdWU7XHJcblx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0IHogKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLl96O1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXQgeiAoIHZhbHVlICkge1xyXG5cclxuXHRcdHRoaXMuX3ogPSB2YWx1ZTtcclxuXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXQgb3JkZXIgKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLl9vcmRlcjtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0IG9yZGVyICggdmFsdWUgKSB7XHJcblxyXG5cdFx0dGhpcy5fb3JkZXIgPSB2YWx1ZTtcclxuXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXQ6IGZ1bmN0aW9uICggeCwgeSwgeiwgb3JkZXIgKSB7XHJcblxyXG5cdFx0dGhpcy5feCA9IHg7XHJcblx0XHR0aGlzLl95ID0geTtcclxuXHRcdHRoaXMuX3ogPSB6O1xyXG5cdFx0dGhpcy5fb3JkZXIgPSBvcmRlciB8fCB0aGlzLl9vcmRlcjtcclxuXHJcblx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMuX3gsIHRoaXMuX3ksIHRoaXMuX3osIHRoaXMuX29yZGVyICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvcHk6IGZ1bmN0aW9uICggZXVsZXIgKSB7XHJcblxyXG5cdFx0dGhpcy5feCA9IGV1bGVyLl94O1xyXG5cdFx0dGhpcy5feSA9IGV1bGVyLl95O1xyXG5cdFx0dGhpcy5feiA9IGV1bGVyLl96O1xyXG5cdFx0dGhpcy5fb3JkZXIgPSBldWxlci5fb3JkZXI7XHJcblxyXG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldEZyb21Sb3RhdGlvbk1hdHJpeDogZnVuY3Rpb24gKCBtLCBvcmRlciwgdXBkYXRlICkge1xyXG5cclxuXHRcdHZhciBjbGFtcCA9IFRIUkVFLk1hdGguY2xhbXA7XHJcblxyXG5cdFx0Ly8gYXNzdW1lcyB0aGUgdXBwZXIgM3gzIG9mIG0gaXMgYSBwdXJlIHJvdGF0aW9uIG1hdHJpeCAoaS5lLCB1bnNjYWxlZClcclxuXHJcblx0XHR2YXIgdGUgPSBtLmVsZW1lbnRzO1xyXG5cdFx0dmFyIG0xMSA9IHRlWyAwIF0sIG0xMiA9IHRlWyA0IF0sIG0xMyA9IHRlWyA4IF07XHJcblx0XHR2YXIgbTIxID0gdGVbIDEgXSwgbTIyID0gdGVbIDUgXSwgbTIzID0gdGVbIDkgXTtcclxuXHRcdHZhciBtMzEgPSB0ZVsgMiBdLCBtMzIgPSB0ZVsgNiBdLCBtMzMgPSB0ZVsgMTAgXTtcclxuXHJcblx0XHRvcmRlciA9IG9yZGVyIHx8IHRoaXMuX29yZGVyO1xyXG5cclxuXHRcdGlmICggb3JkZXIgPT09ICdYWVonICkge1xyXG5cclxuXHRcdFx0dGhpcy5feSA9IE1hdGguYXNpbiggY2xhbXAoIG0xMywgLSAxLCAxICkgKTtcclxuXHJcblx0XHRcdGlmICggTWF0aC5hYnMoIG0xMyApIDwgMC45OTk5OSApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXRhbjIoIC0gbTIzLCBtMzMgKTtcclxuXHRcdFx0XHR0aGlzLl96ID0gTWF0aC5hdGFuMiggLSBtMTIsIG0xMSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXRhbjIoIG0zMiwgbTIyICk7XHJcblx0XHRcdFx0dGhpcy5feiA9IDA7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdZWFonICkge1xyXG5cclxuXHRcdFx0dGhpcy5feCA9IE1hdGguYXNpbiggLSBjbGFtcCggbTIzLCAtIDEsIDEgKSApO1xyXG5cclxuXHRcdFx0aWYgKCBNYXRoLmFicyggbTIzICkgPCAwLjk5OTk5ICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLl95ID0gTWF0aC5hdGFuMiggbTEzLCBtMzMgKTtcclxuXHRcdFx0XHR0aGlzLl96ID0gTWF0aC5hdGFuMiggbTIxLCBtMjIgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuX3kgPSBNYXRoLmF0YW4yKCAtIG0zMSwgbTExICk7XHJcblx0XHRcdFx0dGhpcy5feiA9IDA7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdaWFknICkge1xyXG5cclxuXHRcdFx0dGhpcy5feCA9IE1hdGguYXNpbiggY2xhbXAoIG0zMiwgLSAxLCAxICkgKTtcclxuXHJcblx0XHRcdGlmICggTWF0aC5hYnMoIG0zMiApIDwgMC45OTk5OSApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXRhbjIoIC0gbTMxLCBtMzMgKTtcclxuXHRcdFx0XHR0aGlzLl96ID0gTWF0aC5hdGFuMiggLSBtMTIsIG0yMiApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0dGhpcy5feSA9IDA7XHJcblx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXRhbjIoIG0yMSwgbTExICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdaWVgnICkge1xyXG5cclxuXHRcdFx0dGhpcy5feSA9IE1hdGguYXNpbiggLSBjbGFtcCggbTMxLCAtIDEsIDEgKSApO1xyXG5cclxuXHRcdFx0aWYgKCBNYXRoLmFicyggbTMxICkgPCAwLjk5OTk5ICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hdGFuMiggbTMyLCBtMzMgKTtcclxuXHRcdFx0XHR0aGlzLl96ID0gTWF0aC5hdGFuMiggbTIxLCBtMTEgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuX3ggPSAwO1xyXG5cdFx0XHRcdHRoaXMuX3ogPSBNYXRoLmF0YW4yKCAtIG0xMiwgbTIyICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdZWlgnICkge1xyXG5cclxuXHRcdFx0dGhpcy5feiA9IE1hdGguYXNpbiggY2xhbXAoIG0yMSwgLSAxLCAxICkgKTtcclxuXHJcblx0XHRcdGlmICggTWF0aC5hYnMoIG0yMSApIDwgMC45OTk5OSApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXRhbjIoIC0gbTIzLCBtMjIgKTtcclxuXHRcdFx0XHR0aGlzLl95ID0gTWF0aC5hdGFuMiggLSBtMzEsIG0xMSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0dGhpcy5feCA9IDA7XHJcblx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXRhbjIoIG0xMywgbTMzICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdYWlknICkge1xyXG5cclxuXHRcdFx0dGhpcy5feiA9IE1hdGguYXNpbiggLSBjbGFtcCggbTEyLCAtIDEsIDEgKSApO1xyXG5cclxuXHRcdFx0aWYgKCBNYXRoLmFicyggbTEyICkgPCAwLjk5OTk5ICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hdGFuMiggbTMyLCBtMjIgKTtcclxuXHRcdFx0XHR0aGlzLl95ID0gTWF0aC5hdGFuMiggbTEzLCBtMTEgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuX3ggPSBNYXRoLmF0YW4yKCAtIG0yMywgbTMzICk7XHJcblx0XHRcdFx0dGhpcy5feSA9IDA7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkV1bGVyOiAuc2V0RnJvbVJvdGF0aW9uTWF0cml4KCkgZ2l2ZW4gdW5zdXBwb3J0ZWQgb3JkZXI6ICcgKyBvcmRlciApXHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX29yZGVyID0gb3JkZXI7XHJcblxyXG5cdFx0aWYgKCB1cGRhdGUgIT09IGZhbHNlICkgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldEZyb21RdWF0ZXJuaW9uOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIG1hdHJpeDtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBxLCBvcmRlciwgdXBkYXRlICkge1xyXG5cclxuXHRcdFx0aWYgKCBtYXRyaXggPT09IHVuZGVmaW5lZCApIG1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblx0XHRcdG1hdHJpeC5tYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbiggcSApO1xyXG5cdFx0XHR0aGlzLnNldEZyb21Sb3RhdGlvbk1hdHJpeCggbWF0cml4LCBvcmRlciwgdXBkYXRlICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdHNldEZyb21WZWN0b3IzOiBmdW5jdGlvbiAoIHYsIG9yZGVyICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnNldCggdi54LCB2LnksIHYueiwgb3JkZXIgfHwgdGhpcy5fb3JkZXIgKTtcclxuXHJcblx0fSxcclxuXHJcblx0cmVvcmRlcjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdC8vIFdBUk5JTkc6IHRoaXMgZGlzY2FyZHMgcmV2b2x1dGlvbiBpbmZvcm1hdGlvbiAtYmhvdXN0b25cclxuXHJcblx0XHR2YXIgcSA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggbmV3T3JkZXIgKSB7XHJcblxyXG5cdFx0XHRxLnNldEZyb21FdWxlciggdGhpcyApO1xyXG5cdFx0XHR0aGlzLnNldEZyb21RdWF0ZXJuaW9uKCBxLCBuZXdPcmRlciApO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0ZXF1YWxzOiBmdW5jdGlvbiAoIGV1bGVyICkge1xyXG5cclxuXHRcdHJldHVybiAoIGV1bGVyLl94ID09PSB0aGlzLl94ICkgJiYgKCBldWxlci5feSA9PT0gdGhpcy5feSApICYmICggZXVsZXIuX3ogPT09IHRoaXMuX3ogKSAmJiAoIGV1bGVyLl9vcmRlciA9PT0gdGhpcy5fb3JkZXIgKTtcclxuXHJcblx0fSxcclxuXHJcblx0ZnJvbUFycmF5OiBmdW5jdGlvbiAoIGFycmF5ICkge1xyXG5cclxuXHRcdHRoaXMuX3ggPSBhcnJheVsgMCBdO1xyXG5cdFx0dGhpcy5feSA9IGFycmF5WyAxIF07XHJcblx0XHR0aGlzLl96ID0gYXJyYXlbIDIgXTtcclxuXHRcdGlmICggYXJyYXlbIDMgXSAhPT0gdW5kZWZpbmVkICkgdGhpcy5fb3JkZXIgPSBhcnJheVsgMyBdO1xyXG5cclxuXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHR0b0FycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0aWYgKCBhcnJheSA9PT0gdW5kZWZpbmVkICkgYXJyYXkgPSBbXTtcclxuXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xyXG5cclxuXHRcdGFycmF5WyBvZmZzZXQgXSA9IHRoaXMuX3g7XHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGhpcy5feTtcclxuXHRcdGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0aGlzLl96O1xyXG5cdFx0YXJyYXlbIG9mZnNldCArIDMgXSA9IHRoaXMuX29yZGVyO1xyXG5cclxuXHRcdHJldHVybiBhcnJheTtcclxuXHJcblx0fSxcclxuXHJcblx0dG9WZWN0b3IzOiBmdW5jdGlvbiAoIG9wdGlvbmFsUmVzdWx0ICkge1xyXG5cclxuXHRcdGlmICggb3B0aW9uYWxSZXN1bHQgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gb3B0aW9uYWxSZXN1bHQuc2V0KCB0aGlzLl94LCB0aGlzLl95LCB0aGlzLl96ICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMyggdGhpcy5feCwgdGhpcy5feSwgdGhpcy5feiApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0b25DaGFuZ2U6IGZ1bmN0aW9uICggY2FsbGJhY2sgKSB7XHJcblxyXG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrID0gY2FsbGJhY2s7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG9uQ2hhbmdlQ2FsbGJhY2s6IGZ1bmN0aW9uICgpIHt9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbWF0aC9MaW5lMy5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cclxuICovXHJcblxyXG5USFJFRS5MaW5lMyA9IGZ1bmN0aW9uICggc3RhcnQsIGVuZCApIHtcclxuXHJcblx0dGhpcy5zdGFydCA9ICggc3RhcnQgIT09IHVuZGVmaW5lZCApID8gc3RhcnQgOiBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdHRoaXMuZW5kID0gKCBlbmQgIT09IHVuZGVmaW5lZCApID8gZW5kIDogbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5MaW5lMy5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5MaW5lMyxcclxuXHJcblx0c2V0OiBmdW5jdGlvbiAoIHN0YXJ0LCBlbmQgKSB7XHJcblxyXG5cdFx0dGhpcy5zdGFydC5jb3B5KCBzdGFydCApO1xyXG5cdFx0dGhpcy5lbmQuY29weSggZW5kICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb3B5OiBmdW5jdGlvbiAoIGxpbmUgKSB7XHJcblxyXG5cdFx0dGhpcy5zdGFydC5jb3B5KCBsaW5lLnN0YXJ0ICk7XHJcblx0XHR0aGlzLmVuZC5jb3B5KCBsaW5lLmVuZCApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjZW50ZXI6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHRyZXR1cm4gcmVzdWx0LmFkZFZlY3RvcnMoIHRoaXMuc3RhcnQsIHRoaXMuZW5kICkubXVsdGlwbHlTY2FsYXIoIDAuNSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRkZWx0YTogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdHJldHVybiByZXN1bHQuc3ViVmVjdG9ycyggdGhpcy5lbmQsIHRoaXMuc3RhcnQgKTtcclxuXHJcblx0fSxcclxuXHJcblx0ZGlzdGFuY2VTcTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnN0YXJ0LmRpc3RhbmNlVG9TcXVhcmVkKCB0aGlzLmVuZCApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRkaXN0YW5jZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnN0YXJ0LmRpc3RhbmNlVG8oIHRoaXMuZW5kICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGF0OiBmdW5jdGlvbiAoIHQsIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmRlbHRhKCByZXN1bHQgKS5tdWx0aXBseVNjYWxhciggdCApLmFkZCggdGhpcy5zdGFydCApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjbG9zZXN0UG9pbnRUb1BvaW50UGFyYW1ldGVyOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHN0YXJ0UCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHR2YXIgc3RhcnRFbmQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIHBvaW50LCBjbGFtcFRvTGluZSApIHtcclxuXHJcblx0XHRcdHN0YXJ0UC5zdWJWZWN0b3JzKCBwb2ludCwgdGhpcy5zdGFydCApO1xyXG5cdFx0XHRzdGFydEVuZC5zdWJWZWN0b3JzKCB0aGlzLmVuZCwgdGhpcy5zdGFydCApO1xyXG5cclxuXHRcdFx0dmFyIHN0YXJ0RW5kMiA9IHN0YXJ0RW5kLmRvdCggc3RhcnRFbmQgKTtcclxuXHRcdFx0dmFyIHN0YXJ0RW5kX3N0YXJ0UCA9IHN0YXJ0RW5kLmRvdCggc3RhcnRQICk7XHJcblxyXG5cdFx0XHR2YXIgdCA9IHN0YXJ0RW5kX3N0YXJ0UCAvIHN0YXJ0RW5kMjtcclxuXHJcblx0XHRcdGlmICggY2xhbXBUb0xpbmUgKSB7XHJcblxyXG5cdFx0XHRcdHQgPSBUSFJFRS5NYXRoLmNsYW1wKCB0LCAwLCAxICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gdDtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGNsb3Nlc3RQb2ludFRvUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQsIGNsYW1wVG9MaW5lLCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHR2YXIgdCA9IHRoaXMuY2xvc2VzdFBvaW50VG9Qb2ludFBhcmFtZXRlciggcG9pbnQsIGNsYW1wVG9MaW5lICk7XHJcblxyXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZGVsdGEoIHJlc3VsdCApLm11bHRpcGx5U2NhbGFyKCB0ICkuYWRkKCB0aGlzLnN0YXJ0ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFwcGx5TWF0cml4NDogZnVuY3Rpb24gKCBtYXRyaXggKSB7XHJcblxyXG5cdFx0dGhpcy5zdGFydC5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1xyXG5cdFx0dGhpcy5lbmQuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZXF1YWxzOiBmdW5jdGlvbiAoIGxpbmUgKSB7XHJcblxyXG5cdFx0cmV0dXJuIGxpbmUuc3RhcnQuZXF1YWxzKCB0aGlzLnN0YXJ0ICkgJiYgbGluZS5lbmQuZXF1YWxzKCB0aGlzLmVuZCApO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbWF0aC9Cb3gyLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pb1xyXG4gKi9cclxuXHJcblRIUkVFLkJveDIgPSBmdW5jdGlvbiAoIG1pbiwgbWF4ICkge1xyXG5cclxuXHR0aGlzLm1pbiA9ICggbWluICE9PSB1bmRlZmluZWQgKSA/IG1pbiA6IG5ldyBUSFJFRS5WZWN0b3IyKCArIEluZmluaXR5LCArIEluZmluaXR5ICk7XHJcblx0dGhpcy5tYXggPSAoIG1heCAhPT0gdW5kZWZpbmVkICkgPyBtYXggOiBuZXcgVEhSRUUuVmVjdG9yMiggLSBJbmZpbml0eSwgLSBJbmZpbml0eSApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkJveDIucHJvdG90eXBlID0ge1xyXG5cclxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuQm94MixcclxuXHJcblx0c2V0OiBmdW5jdGlvbiAoIG1pbiwgbWF4ICkge1xyXG5cclxuXHRcdHRoaXMubWluLmNvcHkoIG1pbiApO1xyXG5cdFx0dGhpcy5tYXguY29weSggbWF4ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldEZyb21Qb2ludHM6IGZ1bmN0aW9uICggcG9pbnRzICkge1xyXG5cclxuXHRcdHRoaXMubWFrZUVtcHR5KCk7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHRoaXMuZXhwYW5kQnlQb2ludCggcG9pbnRzWyBpIF0gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldEZyb21DZW50ZXJBbmRTaXplOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBjZW50ZXIsIHNpemUgKSB7XHJcblxyXG5cdFx0XHR2YXIgaGFsZlNpemUgPSB2MS5jb3B5KCBzaXplICkubXVsdGlwbHlTY2FsYXIoIDAuNSApO1xyXG5cdFx0XHR0aGlzLm1pbi5jb3B5KCBjZW50ZXIgKS5zdWIoIGhhbGZTaXplICk7XHJcblx0XHRcdHRoaXMubWF4LmNvcHkoIGNlbnRlciApLmFkZCggaGFsZlNpemUgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvcHk6IGZ1bmN0aW9uICggYm94ICkge1xyXG5cclxuXHRcdHRoaXMubWluLmNvcHkoIGJveC5taW4gKTtcclxuXHRcdHRoaXMubWF4LmNvcHkoIGJveC5tYXggKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bWFrZUVtcHR5OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy5taW4ueCA9IHRoaXMubWluLnkgPSArIEluZmluaXR5O1xyXG5cdFx0dGhpcy5tYXgueCA9IHRoaXMubWF4LnkgPSAtIEluZmluaXR5O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRpc0VtcHR5OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0Ly8gdGhpcyBpcyBhIG1vcmUgcm9idXN0IGNoZWNrIGZvciBlbXB0eSB0aGFuICggdm9sdW1lIDw9IDAgKSBiZWNhdXNlIHZvbHVtZSBjYW4gZ2V0IHBvc2l0aXZlIHdpdGggdHdvIG5lZ2F0aXZlIGF4ZXNcclxuXHJcblx0XHRyZXR1cm4gKCB0aGlzLm1heC54IDwgdGhpcy5taW4ueCApIHx8ICggdGhpcy5tYXgueSA8IHRoaXMubWluLnkgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y2VudGVyOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMigpO1xyXG5cdFx0cmV0dXJuIHJlc3VsdC5hZGRWZWN0b3JzKCB0aGlzLm1pbiwgdGhpcy5tYXggKS5tdWx0aXBseVNjYWxhciggMC41ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNpemU6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IyKCk7XHJcblx0XHRyZXR1cm4gcmVzdWx0LnN1YlZlY3RvcnMoIHRoaXMubWF4LCB0aGlzLm1pbiApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRleHBhbmRCeVBvaW50OiBmdW5jdGlvbiAoIHBvaW50ICkge1xyXG5cclxuXHRcdHRoaXMubWluLm1pbiggcG9pbnQgKTtcclxuXHRcdHRoaXMubWF4Lm1heCggcG9pbnQgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZXhwYW5kQnlWZWN0b3I6IGZ1bmN0aW9uICggdmVjdG9yICkge1xyXG5cclxuXHRcdHRoaXMubWluLnN1YiggdmVjdG9yICk7XHJcblx0XHR0aGlzLm1heC5hZGQoIHZlY3RvciApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRleHBhbmRCeVNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XHJcblxyXG5cdFx0dGhpcy5taW4uYWRkU2NhbGFyKCAtIHNjYWxhciApO1xyXG5cdFx0dGhpcy5tYXguYWRkU2NhbGFyKCBzY2FsYXIgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y29udGFpbnNQb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcclxuXHJcblx0XHRpZiAoIHBvaW50LnggPCB0aGlzLm1pbi54IHx8IHBvaW50LnggPiB0aGlzLm1heC54IHx8XHJcblx0XHQgICAgIHBvaW50LnkgPCB0aGlzLm1pbi55IHx8IHBvaW50LnkgPiB0aGlzLm1heC55ICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHJcblx0fSxcclxuXHJcblx0Y29udGFpbnNCb3g6IGZ1bmN0aW9uICggYm94ICkge1xyXG5cclxuXHRcdGlmICggKCB0aGlzLm1pbi54IDw9IGJveC5taW4ueCApICYmICggYm94Lm1heC54IDw9IHRoaXMubWF4LnggKSAmJlxyXG5cdFx0ICAgICAoIHRoaXMubWluLnkgPD0gYm94Lm1pbi55ICkgJiYgKCBib3gubWF4LnkgPD0gdGhpcy5tYXgueSApICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0UGFyYW1ldGVyOiBmdW5jdGlvbiAoIHBvaW50LCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHQvLyBUaGlzIGNhbiBwb3RlbnRpYWxseSBoYXZlIGEgZGl2aWRlIGJ5IHplcm8gaWYgdGhlIGJveFxyXG5cdFx0Ly8gaGFzIGEgc2l6ZSBkaW1lbnNpb24gb2YgMC5cclxuXHJcblx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjIoKTtcclxuXHJcblx0XHRyZXR1cm4gcmVzdWx0LnNldChcclxuXHRcdFx0KCBwb2ludC54IC0gdGhpcy5taW4ueCApIC8gKCB0aGlzLm1heC54IC0gdGhpcy5taW4ueCApLFxyXG5cdFx0XHQoIHBvaW50LnkgLSB0aGlzLm1pbi55ICkgLyAoIHRoaXMubWF4LnkgLSB0aGlzLm1pbi55IClcclxuXHRcdCk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGludGVyc2VjdHNCb3g6IGZ1bmN0aW9uICggYm94ICkge1xyXG5cclxuXHRcdC8vIHVzaW5nIDYgc3BsaXR0aW5nIHBsYW5lcyB0byBydWxlIG91dCBpbnRlcnNlY3Rpb25zLlxyXG5cclxuXHRcdGlmICggYm94Lm1heC54IDwgdGhpcy5taW4ueCB8fCBib3gubWluLnggPiB0aGlzLm1heC54IHx8XHJcblx0XHQgICAgIGJveC5tYXgueSA8IHRoaXMubWluLnkgfHwgYm94Lm1pbi55ID4gdGhpcy5tYXgueSApIHtcclxuXHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNsYW1wUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMigpO1xyXG5cdFx0cmV0dXJuIHJlc3VsdC5jb3B5KCBwb2ludCApLmNsYW1wKCB0aGlzLm1pbiwgdGhpcy5tYXggKTtcclxuXHJcblx0fSxcclxuXHJcblx0ZGlzdGFuY2VUb1BvaW50OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBwb2ludCApIHtcclxuXHJcblx0XHRcdHZhciBjbGFtcGVkUG9pbnQgPSB2MS5jb3B5KCBwb2ludCApLmNsYW1wKCB0aGlzLm1pbiwgdGhpcy5tYXggKTtcclxuXHRcdFx0cmV0dXJuIGNsYW1wZWRQb2ludC5zdWIoIHBvaW50ICkubGVuZ3RoKCk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRpbnRlcnNlY3Q6IGZ1bmN0aW9uICggYm94ICkge1xyXG5cclxuXHRcdHRoaXMubWluLm1heCggYm94Lm1pbiApO1xyXG5cdFx0dGhpcy5tYXgubWluKCBib3gubWF4ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHVuaW9uOiBmdW5jdGlvbiAoIGJveCApIHtcclxuXHJcblx0XHR0aGlzLm1pbi5taW4oIGJveC5taW4gKTtcclxuXHRcdHRoaXMubWF4Lm1heCggYm94Lm1heCApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHR0cmFuc2xhdGU6IGZ1bmN0aW9uICggb2Zmc2V0ICkge1xyXG5cclxuXHRcdHRoaXMubWluLmFkZCggb2Zmc2V0ICk7XHJcblx0XHR0aGlzLm1heC5hZGQoIG9mZnNldCApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRlcXVhbHM6IGZ1bmN0aW9uICggYm94ICkge1xyXG5cclxuXHRcdHJldHVybiBib3gubWluLmVxdWFscyggdGhpcy5taW4gKSAmJiBib3gubWF4LmVxdWFscyggdGhpcy5tYXggKTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL21hdGgvQm94My5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cclxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XHJcbiAqL1xyXG5cclxuVEhSRUUuQm94MyA9IGZ1bmN0aW9uICggbWluLCBtYXggKSB7XHJcblxyXG5cdHRoaXMubWluID0gKCBtaW4gIT09IHVuZGVmaW5lZCApID8gbWluIDogbmV3IFRIUkVFLlZlY3RvcjMoICsgSW5maW5pdHksICsgSW5maW5pdHksICsgSW5maW5pdHkgKTtcclxuXHR0aGlzLm1heCA9ICggbWF4ICE9PSB1bmRlZmluZWQgKSA/IG1heCA6IG5ldyBUSFJFRS5WZWN0b3IzKCAtIEluZmluaXR5LCAtIEluZmluaXR5LCAtIEluZmluaXR5ICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQm94My5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5Cb3gzLFxyXG5cclxuXHRzZXQ6IGZ1bmN0aW9uICggbWluLCBtYXggKSB7XHJcblxyXG5cdFx0dGhpcy5taW4uY29weSggbWluICk7XHJcblx0XHR0aGlzLm1heC5jb3B5KCBtYXggKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0RnJvbUFycmF5OiBmdW5jdGlvbiAoIGFycmF5ICkge1xyXG5cclxuXHRcdHRoaXMubWFrZUVtcHR5KCk7XHJcblxyXG5cdFx0dmFyIG1pblggPSArIEluZmluaXR5O1xyXG5cdFx0dmFyIG1pblkgPSArIEluZmluaXR5O1xyXG5cdFx0dmFyIG1pblogPSArIEluZmluaXR5O1xyXG5cclxuXHRcdHZhciBtYXhYID0gLSBJbmZpbml0eTtcclxuXHRcdHZhciBtYXhZID0gLSBJbmZpbml0eTtcclxuXHRcdHZhciBtYXhaID0gLSBJbmZpbml0eTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gYXJyYXkubGVuZ3RoOyBpIDwgaWw7IGkgKz0gMyApIHtcclxuXHJcblx0XHRcdHZhciB4ID0gYXJyYXlbIGkgXTtcclxuXHRcdFx0dmFyIHkgPSBhcnJheVsgaSArIDEgXTtcclxuXHRcdFx0dmFyIHogPSBhcnJheVsgaSArIDIgXTtcclxuXHJcblx0XHRcdGlmICggeCA8IG1pblggKSBtaW5YID0geDtcclxuXHRcdFx0aWYgKCB5IDwgbWluWSApIG1pblkgPSB5O1xyXG5cdFx0XHRpZiAoIHogPCBtaW5aICkgbWluWiA9IHo7XHJcblxyXG5cdFx0XHRpZiAoIHggPiBtYXhYICkgbWF4WCA9IHg7XHJcblx0XHRcdGlmICggeSA+IG1heFkgKSBtYXhZID0geTtcclxuXHRcdFx0aWYgKCB6ID4gbWF4WiApIG1heFogPSB6O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLm1pbi5zZXQoIG1pblgsIG1pblksIG1pblogKTtcclxuXHRcdHRoaXMubWF4LnNldCggbWF4WCwgbWF4WSwgbWF4WiApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRGcm9tUG9pbnRzOiBmdW5jdGlvbiAoIHBvaW50cyApIHtcclxuXHJcblx0XHR0aGlzLm1ha2VFbXB0eSgpO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmV4cGFuZEJ5UG9pbnQoIHBvaW50c1sgaSBdICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRGcm9tQ2VudGVyQW5kU2l6ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggY2VudGVyLCBzaXplICkge1xyXG5cclxuXHRcdFx0dmFyIGhhbGZTaXplID0gdjEuY29weSggc2l6ZSApLm11bHRpcGx5U2NhbGFyKCAwLjUgKTtcclxuXHJcblx0XHRcdHRoaXMubWluLmNvcHkoIGNlbnRlciApLnN1YiggaGFsZlNpemUgKTtcclxuXHRcdFx0dGhpcy5tYXguY29weSggY2VudGVyICkuYWRkKCBoYWxmU2l6ZSApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRzZXRGcm9tT2JqZWN0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0Ly8gQ29tcHV0ZXMgdGhlIHdvcmxkLWF4aXMtYWxpZ25lZCBib3VuZGluZyBib3ggb2YgYW4gb2JqZWN0IChpbmNsdWRpbmcgaXRzIGNoaWxkcmVuKSxcclxuXHRcdC8vIGFjY291bnRpbmcgZm9yIGJvdGggdGhlIG9iamVjdCdzLCBhbmQgY2hpbGRyZW4ncywgd29ybGQgdHJhbnNmb3Jtc1xyXG5cclxuXHRcdHZhciBib3g7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggb2JqZWN0ICkge1xyXG5cclxuXHRcdFx0aWYgKCBib3ggPT09IHVuZGVmaW5lZCApIGJveCA9IG5ldyBUSFJFRS5Cb3gzKCk7XHJcblxyXG5cdFx0XHR2YXIgc2NvcGUgPSB0aGlzO1xyXG5cclxuXHRcdFx0dGhpcy5tYWtlRW1wdHkoKTtcclxuXHJcblx0XHRcdG9iamVjdC51cGRhdGVNYXRyaXhXb3JsZCggdHJ1ZSApO1xyXG5cclxuXHRcdFx0b2JqZWN0LnRyYXZlcnNlKCBmdW5jdGlvbiAoIG5vZGUgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBnZW9tZXRyeSA9IG5vZGUuZ2VvbWV0cnk7XHJcblxyXG5cdFx0XHRcdGlmICggZ2VvbWV0cnkgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nQm94ID09PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Z2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nQm94KCk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGJveC5jb3B5KCBnZW9tZXRyeS5ib3VuZGluZ0JveCApO1xyXG5cdFx0XHRcdFx0Ym94LmFwcGx5TWF0cml4NCggbm9kZS5tYXRyaXhXb3JsZCApO1xyXG5cdFx0XHRcdFx0c2NvcGUudW5pb24oIGJveCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9ICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb3B5OiBmdW5jdGlvbiAoIGJveCApIHtcclxuXHJcblx0XHR0aGlzLm1pbi5jb3B5KCBib3gubWluICk7XHJcblx0XHR0aGlzLm1heC5jb3B5KCBib3gubWF4ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG1ha2VFbXB0eTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMubWluLnggPSB0aGlzLm1pbi55ID0gdGhpcy5taW4ueiA9ICsgSW5maW5pdHk7XHJcblx0XHR0aGlzLm1heC54ID0gdGhpcy5tYXgueSA9IHRoaXMubWF4LnogPSAtIEluZmluaXR5O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRpc0VtcHR5OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0Ly8gdGhpcyBpcyBhIG1vcmUgcm9idXN0IGNoZWNrIGZvciBlbXB0eSB0aGFuICggdm9sdW1lIDw9IDAgKSBiZWNhdXNlIHZvbHVtZSBjYW4gZ2V0IHBvc2l0aXZlIHdpdGggdHdvIG5lZ2F0aXZlIGF4ZXNcclxuXHJcblx0XHRyZXR1cm4gKCB0aGlzLm1heC54IDwgdGhpcy5taW4ueCApIHx8ICggdGhpcy5tYXgueSA8IHRoaXMubWluLnkgKSB8fCAoIHRoaXMubWF4LnogPCB0aGlzLm1pbi56ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNlbnRlcjogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdHJldHVybiByZXN1bHQuYWRkVmVjdG9ycyggdGhpcy5taW4sIHRoaXMubWF4ICkubXVsdGlwbHlTY2FsYXIoIDAuNSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzaXplOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0cmV0dXJuIHJlc3VsdC5zdWJWZWN0b3JzKCB0aGlzLm1heCwgdGhpcy5taW4gKTtcclxuXHJcblx0fSxcclxuXHJcblx0ZXhwYW5kQnlQb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcclxuXHJcblx0XHR0aGlzLm1pbi5taW4oIHBvaW50ICk7XHJcblx0XHR0aGlzLm1heC5tYXgoIHBvaW50ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGV4cGFuZEJ5VmVjdG9yOiBmdW5jdGlvbiAoIHZlY3RvciApIHtcclxuXHJcblx0XHR0aGlzLm1pbi5zdWIoIHZlY3RvciApO1xyXG5cdFx0dGhpcy5tYXguYWRkKCB2ZWN0b3IgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZXhwYW5kQnlTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xyXG5cclxuXHRcdHRoaXMubWluLmFkZFNjYWxhciggLSBzY2FsYXIgKTtcclxuXHRcdHRoaXMubWF4LmFkZFNjYWxhciggc2NhbGFyICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XHJcblxyXG5cdFx0aWYgKCBwb2ludC54IDwgdGhpcy5taW4ueCB8fCBwb2ludC54ID4gdGhpcy5tYXgueCB8fFxyXG5cdFx0XHRcdCBwb2ludC55IDwgdGhpcy5taW4ueSB8fCBwb2ludC55ID4gdGhpcy5tYXgueSB8fFxyXG5cdFx0XHRcdCBwb2ludC56IDwgdGhpcy5taW4ueiB8fCBwb2ludC56ID4gdGhpcy5tYXgueiApIHtcclxuXHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvbnRhaW5zQm94OiBmdW5jdGlvbiAoIGJveCApIHtcclxuXHJcblx0XHRpZiAoICggdGhpcy5taW4ueCA8PSBib3gubWluLnggKSAmJiAoIGJveC5tYXgueCA8PSB0aGlzLm1heC54ICkgJiZcclxuXHRcdFx0ICggdGhpcy5taW4ueSA8PSBib3gubWluLnkgKSAmJiAoIGJveC5tYXgueSA8PSB0aGlzLm1heC55ICkgJiZcclxuXHRcdFx0ICggdGhpcy5taW4ueiA8PSBib3gubWluLnogKSAmJiAoIGJveC5tYXgueiA8PSB0aGlzLm1heC56ICkgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXRQYXJhbWV0ZXI6IGZ1bmN0aW9uICggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdC8vIFRoaXMgY2FuIHBvdGVudGlhbGx5IGhhdmUgYSBkaXZpZGUgYnkgemVybyBpZiB0aGUgYm94XHJcblx0XHQvLyBoYXMgYSBzaXplIGRpbWVuc2lvbiBvZiAwLlxyXG5cclxuXHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdHJldHVybiByZXN1bHQuc2V0KFxyXG5cdFx0XHQoIHBvaW50LnggLSB0aGlzLm1pbi54ICkgLyAoIHRoaXMubWF4LnggLSB0aGlzLm1pbi54ICksXHJcblx0XHRcdCggcG9pbnQueSAtIHRoaXMubWluLnkgKSAvICggdGhpcy5tYXgueSAtIHRoaXMubWluLnkgKSxcclxuXHRcdFx0KCBwb2ludC56IC0gdGhpcy5taW4ueiApIC8gKCB0aGlzLm1heC56IC0gdGhpcy5taW4ueiApXHJcblx0XHQpO1xyXG5cclxuXHR9LFxyXG5cclxuXHRpbnRlcnNlY3RzQm94OiBmdW5jdGlvbiAoIGJveCApIHtcclxuXHJcblx0XHQvLyB1c2luZyA2IHNwbGl0dGluZyBwbGFuZXMgdG8gcnVsZSBvdXQgaW50ZXJzZWN0aW9ucy5cclxuXHJcblx0XHRpZiAoIGJveC5tYXgueCA8IHRoaXMubWluLnggfHwgYm94Lm1pbi54ID4gdGhpcy5tYXgueCB8fFxyXG5cdFx0XHRcdCBib3gubWF4LnkgPCB0aGlzLm1pbi55IHx8IGJveC5taW4ueSA+IHRoaXMubWF4LnkgfHxcclxuXHRcdFx0XHQgYm94Lm1heC56IDwgdGhpcy5taW4ueiB8fCBib3gubWluLnogPiB0aGlzLm1heC56ICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHJcblx0fSxcclxuXHJcblx0aW50ZXJzZWN0c1NwaGVyZTogKCBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIGNsb3Nlc3RQb2ludDtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gaW50ZXJzZWN0c1NwaGVyZSggc3BoZXJlICkge1xyXG5cclxuXHRcdFx0aWYgKCBjbG9zZXN0UG9pbnQgPT09IHVuZGVmaW5lZCApIGNsb3Nlc3RQb2ludCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0XHQvLyBGaW5kIHRoZSBwb2ludCBvbiB0aGUgQUFCQiBjbG9zZXN0IHRvIHRoZSBzcGhlcmUgY2VudGVyLlxyXG5cdFx0XHR0aGlzLmNsYW1wUG9pbnQoIHNwaGVyZS5jZW50ZXIsIGNsb3Nlc3RQb2ludCApO1xyXG5cclxuXHRcdFx0Ly8gSWYgdGhhdCBwb2ludCBpcyBpbnNpZGUgdGhlIHNwaGVyZSwgdGhlIEFBQkIgYW5kIHNwaGVyZSBpbnRlcnNlY3QuXHJcblx0XHRcdHJldHVybiBjbG9zZXN0UG9pbnQuZGlzdGFuY2VUb1NxdWFyZWQoIHNwaGVyZS5jZW50ZXIgKSA8PSAoIHNwaGVyZS5yYWRpdXMgKiBzcGhlcmUucmFkaXVzICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSApKCksXHJcblxyXG5cdGludGVyc2VjdHNQbGFuZTogZnVuY3Rpb24gKCBwbGFuZSApIHtcclxuXHJcblx0XHQvLyBXZSBjb21wdXRlIHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIGRvdCBwcm9kdWN0IHZhbHVlcy4gSWYgdGhvc2UgdmFsdWVzXHJcblx0XHQvLyBhcmUgb24gdGhlIHNhbWUgc2lkZSAoYmFjayBvciBmcm9udCkgb2YgdGhlIHBsYW5lLCB0aGVuIHRoZXJlIGlzIG5vIGludGVyc2VjdGlvbi5cclxuXHJcblx0XHR2YXIgbWluLCBtYXg7XHJcblxyXG5cdFx0aWYgKCBwbGFuZS5ub3JtYWwueCA+IDAgKSB7XHJcblxyXG5cdFx0XHRtaW4gPSBwbGFuZS5ub3JtYWwueCAqIHRoaXMubWluLng7XHJcblx0XHRcdG1heCA9IHBsYW5lLm5vcm1hbC54ICogdGhpcy5tYXgueDtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0bWluID0gcGxhbmUubm9ybWFsLnggKiB0aGlzLm1heC54O1xyXG5cdFx0XHRtYXggPSBwbGFuZS5ub3JtYWwueCAqIHRoaXMubWluLng7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggcGxhbmUubm9ybWFsLnkgPiAwICkge1xyXG5cclxuXHRcdFx0bWluICs9IHBsYW5lLm5vcm1hbC55ICogdGhpcy5taW4ueTtcclxuXHRcdFx0bWF4ICs9IHBsYW5lLm5vcm1hbC55ICogdGhpcy5tYXgueTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0bWluICs9IHBsYW5lLm5vcm1hbC55ICogdGhpcy5tYXgueTtcclxuXHRcdFx0bWF4ICs9IHBsYW5lLm5vcm1hbC55ICogdGhpcy5taW4ueTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBwbGFuZS5ub3JtYWwueiA+IDAgKSB7XHJcblxyXG5cdFx0XHRtaW4gKz0gcGxhbmUubm9ybWFsLnogKiB0aGlzLm1pbi56O1xyXG5cdFx0XHRtYXggKz0gcGxhbmUubm9ybWFsLnogKiB0aGlzLm1heC56O1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRtaW4gKz0gcGxhbmUubm9ybWFsLnogKiB0aGlzLm1heC56O1xyXG5cdFx0XHRtYXggKz0gcGxhbmUubm9ybWFsLnogKiB0aGlzLm1pbi56O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gKCBtaW4gPD0gcGxhbmUuY29uc3RhbnQgJiYgbWF4ID49IHBsYW5lLmNvbnN0YW50ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNsYW1wUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0cmV0dXJuIHJlc3VsdC5jb3B5KCBwb2ludCApLmNsYW1wKCB0aGlzLm1pbiwgdGhpcy5tYXggKTtcclxuXHJcblx0fSxcclxuXHJcblx0ZGlzdGFuY2VUb1BvaW50OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBwb2ludCApIHtcclxuXHJcblx0XHRcdHZhciBjbGFtcGVkUG9pbnQgPSB2MS5jb3B5KCBwb2ludCApLmNsYW1wKCB0aGlzLm1pbiwgdGhpcy5tYXggKTtcclxuXHRcdFx0cmV0dXJuIGNsYW1wZWRQb2ludC5zdWIoIHBvaW50ICkubGVuZ3RoKCk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRnZXRCb3VuZGluZ1NwaGVyZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlNwaGVyZSgpO1xyXG5cclxuXHRcdFx0cmVzdWx0LmNlbnRlciA9IHRoaXMuY2VudGVyKCk7XHJcblx0XHRcdHJlc3VsdC5yYWRpdXMgPSB0aGlzLnNpemUoIHYxICkubGVuZ3RoKCkgKiAwLjU7XHJcblxyXG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0aW50ZXJzZWN0OiBmdW5jdGlvbiAoIGJveCApIHtcclxuXHJcblx0XHR0aGlzLm1pbi5tYXgoIGJveC5taW4gKTtcclxuXHRcdHRoaXMubWF4Lm1pbiggYm94Lm1heCApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHR1bmlvbjogZnVuY3Rpb24gKCBib3ggKSB7XHJcblxyXG5cdFx0dGhpcy5taW4ubWluKCBib3gubWluICk7XHJcblx0XHR0aGlzLm1heC5tYXgoIGJveC5tYXggKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0YXBwbHlNYXRyaXg0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHBvaW50cyA9IFtcclxuXHRcdFx0bmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHRcdFx0bmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHRcdFx0bmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHRcdFx0bmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHRcdFx0bmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHRcdFx0bmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHRcdFx0bmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHRcdFx0bmV3IFRIUkVFLlZlY3RvcjMoKVxyXG5cdFx0XTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBtYXRyaXggKSB7XHJcblxyXG5cdFx0XHQvLyBOT1RFOiBJIGFtIHVzaW5nIGEgYmluYXJ5IHBhdHRlcm4gdG8gc3BlY2lmeSBhbGwgMl4zIGNvbWJpbmF0aW9ucyBiZWxvd1xyXG5cdFx0XHRwb2ludHNbIDAgXS5zZXQoIHRoaXMubWluLngsIHRoaXMubWluLnksIHRoaXMubWluLnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAwMDBcclxuXHRcdFx0cG9pbnRzWyAxIF0uc2V0KCB0aGlzLm1pbi54LCB0aGlzLm1pbi55LCB0aGlzLm1heC56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMDAxXHJcblx0XHRcdHBvaW50c1sgMiBdLnNldCggdGhpcy5taW4ueCwgdGhpcy5tYXgueSwgdGhpcy5taW4ueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDAxMFxyXG5cdFx0XHRwb2ludHNbIDMgXS5zZXQoIHRoaXMubWluLngsIHRoaXMubWF4LnksIHRoaXMubWF4LnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAwMTFcclxuXHRcdFx0cG9pbnRzWyA0IF0uc2V0KCB0aGlzLm1heC54LCB0aGlzLm1pbi55LCB0aGlzLm1pbi56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMTAwXHJcblx0XHRcdHBvaW50c1sgNSBdLnNldCggdGhpcy5tYXgueCwgdGhpcy5taW4ueSwgdGhpcy5tYXgueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDEwMVxyXG5cdFx0XHRwb2ludHNbIDYgXS5zZXQoIHRoaXMubWF4LngsIHRoaXMubWF4LnksIHRoaXMubWluLnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAxMTBcclxuXHRcdFx0cG9pbnRzWyA3IF0uc2V0KCB0aGlzLm1heC54LCB0aGlzLm1heC55LCB0aGlzLm1heC56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcdC8vIDExMVxyXG5cclxuXHRcdFx0dGhpcy5tYWtlRW1wdHkoKTtcclxuXHRcdFx0dGhpcy5zZXRGcm9tUG9pbnRzKCBwb2ludHMgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0dHJhbnNsYXRlOiBmdW5jdGlvbiAoIG9mZnNldCApIHtcclxuXHJcblx0XHR0aGlzLm1pbi5hZGQoIG9mZnNldCApO1xyXG5cdFx0dGhpcy5tYXguYWRkKCBvZmZzZXQgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZXF1YWxzOiBmdW5jdGlvbiAoIGJveCApIHtcclxuXHJcblx0XHRyZXR1cm4gYm94Lm1pbi5lcXVhbHMoIHRoaXMubWluICkgJiYgYm94Lm1heC5lcXVhbHMoIHRoaXMubWF4ICk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9tYXRoL01hdHJpeDMuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcclxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pb1xyXG4gKi9cclxuXHJcblRIUkVFLk1hdHJpeDMgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHRoaXMuZWxlbWVudHMgPSBuZXcgRmxvYXQzMkFycmF5KCBbXHJcblxyXG5cdFx0MSwgMCwgMCxcclxuXHRcdDAsIDEsIDAsXHJcblx0XHQwLCAwLCAxXHJcblxyXG5cdF0gKTtcclxuXHJcblx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID4gMCApIHtcclxuXHJcblx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuTWF0cml4MzogdGhlIGNvbnN0cnVjdG9yIG5vIGxvbmdlciByZWFkcyBhcmd1bWVudHMuIHVzZSAuc2V0KCkgaW5zdGVhZC4nICk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5NYXRyaXgzLnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLk1hdHJpeDMsXHJcblxyXG5cdHNldDogZnVuY3Rpb24gKCBuMTEsIG4xMiwgbjEzLCBuMjEsIG4yMiwgbjIzLCBuMzEsIG4zMiwgbjMzICkge1xyXG5cclxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG5cdFx0dGVbIDAgXSA9IG4xMTsgdGVbIDMgXSA9IG4xMjsgdGVbIDYgXSA9IG4xMztcclxuXHRcdHRlWyAxIF0gPSBuMjE7IHRlWyA0IF0gPSBuMjI7IHRlWyA3IF0gPSBuMjM7XHJcblx0XHR0ZVsgMiBdID0gbjMxOyB0ZVsgNSBdID0gbjMyOyB0ZVsgOCBdID0gbjMzO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRpZGVudGl0eTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMuc2V0KFxyXG5cclxuXHRcdFx0MSwgMCwgMCxcclxuXHRcdFx0MCwgMSwgMCxcclxuXHRcdFx0MCwgMCwgMVxyXG5cclxuXHRcdCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuZnJvbUFycmF5KCB0aGlzLmVsZW1lbnRzICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvcHk6IGZ1bmN0aW9uICggbSApIHtcclxuXHJcblx0XHR2YXIgbWUgPSBtLmVsZW1lbnRzO1xyXG5cclxuXHRcdHRoaXMuc2V0KFxyXG5cclxuXHRcdFx0bWVbIDAgXSwgbWVbIDMgXSwgbWVbIDYgXSxcclxuXHRcdFx0bWVbIDEgXSwgbWVbIDQgXSwgbWVbIDcgXSxcclxuXHRcdFx0bWVbIDIgXSwgbWVbIDUgXSwgbWVbIDggXVxyXG5cclxuXHRcdCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFwcGx5VG9WZWN0b3IzQXJyYXk6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdjE7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCwgbGVuZ3RoICkge1xyXG5cclxuXHRcdFx0aWYgKCB2MSA9PT0gdW5kZWZpbmVkICkgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcclxuXHRcdFx0aWYgKCBsZW5ndGggPT09IHVuZGVmaW5lZCApIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMCwgaiA9IG9mZnNldDsgaSA8IGxlbmd0aDsgaSArPSAzLCBqICs9IDMgKSB7XHJcblxyXG5cdFx0XHRcdHYxLmZyb21BcnJheSggYXJyYXksIGogKTtcclxuXHRcdFx0XHR2MS5hcHBseU1hdHJpeDMoIHRoaXMgKTtcclxuXHRcdFx0XHR2MS50b0FycmF5KCBhcnJheSwgaiApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIGFycmF5O1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0YXBwbHlUb0J1ZmZlcjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB2MTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gYXBwbHlUb0J1ZmZlciggYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCApIHtcclxuXHJcblx0XHRcdGlmICggdjEgPT09IHVuZGVmaW5lZCApIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XHJcblx0XHRcdGlmICggbGVuZ3RoID09PSB1bmRlZmluZWQgKSBsZW5ndGggPSBidWZmZXIubGVuZ3RoIC8gYnVmZmVyLml0ZW1TaXplO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBqID0gb2Zmc2V0OyBpIDwgbGVuZ3RoOyBpICsrLCBqICsrICkge1xyXG5cclxuXHRcdFx0XHR2MS54ID0gYnVmZmVyLmdldFgoIGogKTtcclxuXHRcdFx0XHR2MS55ID0gYnVmZmVyLmdldFkoIGogKTtcclxuXHRcdFx0XHR2MS56ID0gYnVmZmVyLmdldFooIGogKTtcclxuXHJcblx0XHRcdFx0djEuYXBwbHlNYXRyaXgzKCB0aGlzICk7XHJcblxyXG5cdFx0XHRcdGJ1ZmZlci5zZXRYWVooIHYxLngsIHYxLnksIHYxLnogKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBidWZmZXI7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRtdWx0aXBseVNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xyXG5cclxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG5cdFx0dGVbIDAgXSAqPSBzOyB0ZVsgMyBdICo9IHM7IHRlWyA2IF0gKj0gcztcclxuXHRcdHRlWyAxIF0gKj0gczsgdGVbIDQgXSAqPSBzOyB0ZVsgNyBdICo9IHM7XHJcblx0XHR0ZVsgMiBdICo9IHM7IHRlWyA1IF0gKj0gczsgdGVbIDggXSAqPSBzO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRkZXRlcm1pbmFudDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG5cdFx0dmFyIGEgPSB0ZVsgMCBdLCBiID0gdGVbIDEgXSwgYyA9IHRlWyAyIF0sXHJcblx0XHRcdGQgPSB0ZVsgMyBdLCBlID0gdGVbIDQgXSwgZiA9IHRlWyA1IF0sXHJcblx0XHRcdGcgPSB0ZVsgNiBdLCBoID0gdGVbIDcgXSwgaSA9IHRlWyA4IF07XHJcblxyXG5cdFx0cmV0dXJuIGEgKiBlICogaSAtIGEgKiBmICogaCAtIGIgKiBkICogaSArIGIgKiBmICogZyArIGMgKiBkICogaCAtIGMgKiBlICogZztcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0SW52ZXJzZTogZnVuY3Rpb24gKCBtYXRyaXgsIHRocm93T25EZWdlbmVyYXRlICkge1xyXG5cclxuXHRcdC8vIGlucHV0OiBUSFJFRS5NYXRyaXg0XHJcblx0XHQvLyAoIGJhc2VkIG9uIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC93ZWJnbC1tanMvIClcclxuXHJcblx0XHR2YXIgbWUgPSBtYXRyaXguZWxlbWVudHM7XHJcblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuXHRcdHRlWyAwIF0gPSAgIG1lWyAxMCBdICogbWVbIDUgXSAtIG1lWyA2IF0gKiBtZVsgOSBdO1xyXG5cdFx0dGVbIDEgXSA9IC0gbWVbIDEwIF0gKiBtZVsgMSBdICsgbWVbIDIgXSAqIG1lWyA5IF07XHJcblx0XHR0ZVsgMiBdID0gICBtZVsgNiBdICogbWVbIDEgXSAtIG1lWyAyIF0gKiBtZVsgNSBdO1xyXG5cdFx0dGVbIDMgXSA9IC0gbWVbIDEwIF0gKiBtZVsgNCBdICsgbWVbIDYgXSAqIG1lWyA4IF07XHJcblx0XHR0ZVsgNCBdID0gICBtZVsgMTAgXSAqIG1lWyAwIF0gLSBtZVsgMiBdICogbWVbIDggXTtcclxuXHRcdHRlWyA1IF0gPSAtIG1lWyA2IF0gKiBtZVsgMCBdICsgbWVbIDIgXSAqIG1lWyA0IF07XHJcblx0XHR0ZVsgNiBdID0gICBtZVsgOSBdICogbWVbIDQgXSAtIG1lWyA1IF0gKiBtZVsgOCBdO1xyXG5cdFx0dGVbIDcgXSA9IC0gbWVbIDkgXSAqIG1lWyAwIF0gKyBtZVsgMSBdICogbWVbIDggXTtcclxuXHRcdHRlWyA4IF0gPSAgIG1lWyA1IF0gKiBtZVsgMCBdIC0gbWVbIDEgXSAqIG1lWyA0IF07XHJcblxyXG5cdFx0dmFyIGRldCA9IG1lWyAwIF0gKiB0ZVsgMCBdICsgbWVbIDEgXSAqIHRlWyAzIF0gKyBtZVsgMiBdICogdGVbIDYgXTtcclxuXHJcblx0XHQvLyBubyBpbnZlcnNlXHJcblxyXG5cdFx0aWYgKCBkZXQgPT09IDAgKSB7XHJcblxyXG5cdFx0XHR2YXIgbXNnID0gXCJUSFJFRS5NYXRyaXgzLmdldEludmVyc2UoKTogY2FuJ3QgaW52ZXJ0IG1hdHJpeCwgZGV0ZXJtaW5hbnQgaXMgMFwiO1xyXG5cclxuXHRcdFx0aWYgKCB0aHJvd09uRGVnZW5lcmF0ZSB8fCBmYWxzZSApIHtcclxuXHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBtc2cgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggbXNnICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmlkZW50aXR5KCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5tdWx0aXBseVNjYWxhciggMS4wIC8gZGV0ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHRyYW5zcG9zZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB0bXAsIG0gPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuXHRcdHRtcCA9IG1bIDEgXTsgbVsgMSBdID0gbVsgMyBdOyBtWyAzIF0gPSB0bXA7XHJcblx0XHR0bXAgPSBtWyAyIF07IG1bIDIgXSA9IG1bIDYgXTsgbVsgNiBdID0gdG1wO1xyXG5cdFx0dG1wID0gbVsgNSBdOyBtWyA1IF0gPSBtWyA3IF07IG1bIDcgXSA9IHRtcDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZmxhdHRlblRvQXJyYXlPZmZzZXQ6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcclxuXHJcblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuXHRcdGFycmF5WyBvZmZzZXQgXSA9IHRlWyAwIF07XHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGVbIDEgXTtcclxuXHRcdGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0ZVsgMiBdO1xyXG5cclxuXHRcdGFycmF5WyBvZmZzZXQgKyAzIF0gPSB0ZVsgMyBdO1xyXG5cdFx0YXJyYXlbIG9mZnNldCArIDQgXSA9IHRlWyA0IF07XHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgNSBdID0gdGVbIDUgXTtcclxuXHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgNiBdID0gdGVbIDYgXTtcclxuXHRcdGFycmF5WyBvZmZzZXQgKyA3IF0gPSB0ZVsgNyBdO1xyXG5cdFx0YXJyYXlbIG9mZnNldCArIDggXSAgPSB0ZVsgOCBdO1xyXG5cclxuXHRcdHJldHVybiBhcnJheTtcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0Tm9ybWFsTWF0cml4OiBmdW5jdGlvbiAoIG0gKSB7XHJcblxyXG5cdFx0Ly8gaW5wdXQ6IFRIUkVFLk1hdHJpeDRcclxuXHJcblx0XHR0aGlzLmdldEludmVyc2UoIG0gKS50cmFuc3Bvc2UoKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0dHJhbnNwb3NlSW50b0FycmF5OiBmdW5jdGlvbiAoIHIgKSB7XHJcblxyXG5cdFx0dmFyIG0gPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuXHRcdHJbIDAgXSA9IG1bIDAgXTtcclxuXHRcdHJbIDEgXSA9IG1bIDMgXTtcclxuXHRcdHJbIDIgXSA9IG1bIDYgXTtcclxuXHRcdHJbIDMgXSA9IG1bIDEgXTtcclxuXHRcdHJbIDQgXSA9IG1bIDQgXTtcclxuXHRcdHJbIDUgXSA9IG1bIDcgXTtcclxuXHRcdHJbIDYgXSA9IG1bIDIgXTtcclxuXHRcdHJbIDcgXSA9IG1bIDUgXTtcclxuXHRcdHJbIDggXSA9IG1bIDggXTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZnJvbUFycmF5OiBmdW5jdGlvbiAoIGFycmF5ICkge1xyXG5cclxuXHRcdHRoaXMuZWxlbWVudHMuc2V0KCBhcnJheSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHR0b0FycmF5OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcblx0XHRyZXR1cm4gW1xyXG5cdFx0XHR0ZVsgMCBdLCB0ZVsgMSBdLCB0ZVsgMiBdLFxyXG5cdFx0XHR0ZVsgMyBdLCB0ZVsgNCBdLCB0ZVsgNSBdLFxyXG5cdFx0XHR0ZVsgNiBdLCB0ZVsgNyBdLCB0ZVsgOCBdXHJcblx0XHRdO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbWF0aC9NYXRyaXg0LmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBzdXBlcmVnZ2JlcnQgLyBodHRwOi8vd3d3LnBhdWxicnVudC5jby51ay9cclxuICogQGF1dGhvciBwaGlsb2diIC8gaHR0cDovL2Jsb2cudGhlaml0Lm9yZy9cclxuICogQGF1dGhvciBqb3JkaV9yb3MgLyBodHRwOi8vcGxhdHRzb2Z0LmNvbVxyXG4gKiBAYXV0aG9yIEQxcGxvMWQgLyBodHRwOi8vZ2l0aHViLmNvbS9EMXBsbzFkXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXHJcbiAqIEBhdXRob3IgdGlta25pcCAvIGh0dHA6Ly93d3cuZmxvb3JwbGFubmVyLmNvbS9cclxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pb1xyXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcclxuICovXHJcblxyXG5USFJFRS5NYXRyaXg0ID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR0aGlzLmVsZW1lbnRzID0gbmV3IEZsb2F0MzJBcnJheSggW1xyXG5cclxuXHRcdDEsIDAsIDAsIDAsXHJcblx0XHQwLCAxLCAwLCAwLFxyXG5cdFx0MCwgMCwgMSwgMCxcclxuXHRcdDAsIDAsIDAsIDFcclxuXHJcblx0XSApO1xyXG5cclxuXHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPiAwICkge1xyXG5cclxuXHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5NYXRyaXg0OiB0aGUgY29uc3RydWN0b3Igbm8gbG9uZ2VyIHJlYWRzIGFyZ3VtZW50cy4gdXNlIC5zZXQoKSBpbnN0ZWFkLicgKTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcblRIUkVFLk1hdHJpeDQucHJvdG90eXBlID0ge1xyXG5cclxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuTWF0cml4NCxcclxuXHJcblx0c2V0OiBmdW5jdGlvbiAoIG4xMSwgbjEyLCBuMTMsIG4xNCwgbjIxLCBuMjIsIG4yMywgbjI0LCBuMzEsIG4zMiwgbjMzLCBuMzQsIG40MSwgbjQyLCBuNDMsIG40NCApIHtcclxuXHJcblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuXHRcdHRlWyAwIF0gPSBuMTE7IHRlWyA0IF0gPSBuMTI7IHRlWyA4IF0gPSBuMTM7IHRlWyAxMiBdID0gbjE0O1xyXG5cdFx0dGVbIDEgXSA9IG4yMTsgdGVbIDUgXSA9IG4yMjsgdGVbIDkgXSA9IG4yMzsgdGVbIDEzIF0gPSBuMjQ7XHJcblx0XHR0ZVsgMiBdID0gbjMxOyB0ZVsgNiBdID0gbjMyOyB0ZVsgMTAgXSA9IG4zMzsgdGVbIDE0IF0gPSBuMzQ7XHJcblx0XHR0ZVsgMyBdID0gbjQxOyB0ZVsgNyBdID0gbjQyOyB0ZVsgMTEgXSA9IG40MzsgdGVbIDE1IF0gPSBuNDQ7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGlkZW50aXR5OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy5zZXQoXHJcblxyXG5cdFx0XHQxLCAwLCAwLCAwLFxyXG5cdFx0XHQwLCAxLCAwLCAwLFxyXG5cdFx0XHQwLCAwLCAxLCAwLFxyXG5cdFx0XHQwLCAwLCAwLCAxXHJcblxyXG5cdFx0KTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IFRIUkVFLk1hdHJpeDQoKS5mcm9tQXJyYXkoIHRoaXMuZWxlbWVudHMgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y29weTogZnVuY3Rpb24gKCBtICkge1xyXG5cclxuXHRcdHRoaXMuZWxlbWVudHMuc2V0KCBtLmVsZW1lbnRzICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvcHlQb3NpdGlvbjogZnVuY3Rpb24gKCBtICkge1xyXG5cclxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblx0XHR2YXIgbWUgPSBtLmVsZW1lbnRzO1xyXG5cclxuXHRcdHRlWyAxMiBdID0gbWVbIDEyIF07XHJcblx0XHR0ZVsgMTMgXSA9IG1lWyAxMyBdO1xyXG5cdFx0dGVbIDE0IF0gPSBtZVsgMTQgXTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZXh0cmFjdEJhc2lzOiBmdW5jdGlvbiAoIHhBeGlzLCB5QXhpcywgekF4aXMgKSB7XHJcblxyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcblx0XHR4QXhpcy5zZXQoIHRlWyAwIF0sIHRlWyAxIF0sIHRlWyAyIF0gKTtcclxuXHRcdHlBeGlzLnNldCggdGVbIDQgXSwgdGVbIDUgXSwgdGVbIDYgXSApO1xyXG5cdFx0ekF4aXMuc2V0KCB0ZVsgOCBdLCB0ZVsgOSBdLCB0ZVsgMTAgXSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtYWtlQmFzaXM6IGZ1bmN0aW9uICggeEF4aXMsIHlBeGlzLCB6QXhpcyApIHtcclxuXHJcblx0XHR0aGlzLnNldChcclxuXHRcdFx0eEF4aXMueCwgeUF4aXMueCwgekF4aXMueCwgMCxcclxuXHRcdFx0eEF4aXMueSwgeUF4aXMueSwgekF4aXMueSwgMCxcclxuXHRcdFx0eEF4aXMueiwgeUF4aXMueiwgekF4aXMueiwgMCxcclxuXHRcdFx0MCwgICAgICAgMCwgICAgICAgMCwgICAgICAgMVxyXG5cdFx0KTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZXh0cmFjdFJvdGF0aW9uOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHYxO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIG0gKSB7XHJcblxyXG5cdFx0XHRpZiAoIHYxID09PSB1bmRlZmluZWQgKSB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cdFx0XHR2YXIgbWUgPSBtLmVsZW1lbnRzO1xyXG5cclxuXHRcdFx0dmFyIHNjYWxlWCA9IDEgLyB2MS5zZXQoIG1lWyAwIF0sIG1lWyAxIF0sIG1lWyAyIF0gKS5sZW5ndGgoKTtcclxuXHRcdFx0dmFyIHNjYWxlWSA9IDEgLyB2MS5zZXQoIG1lWyA0IF0sIG1lWyA1IF0sIG1lWyA2IF0gKS5sZW5ndGgoKTtcclxuXHRcdFx0dmFyIHNjYWxlWiA9IDEgLyB2MS5zZXQoIG1lWyA4IF0sIG1lWyA5IF0sIG1lWyAxMCBdICkubGVuZ3RoKCk7XHJcblxyXG5cdFx0XHR0ZVsgMCBdID0gbWVbIDAgXSAqIHNjYWxlWDtcclxuXHRcdFx0dGVbIDEgXSA9IG1lWyAxIF0gKiBzY2FsZVg7XHJcblx0XHRcdHRlWyAyIF0gPSBtZVsgMiBdICogc2NhbGVYO1xyXG5cclxuXHRcdFx0dGVbIDQgXSA9IG1lWyA0IF0gKiBzY2FsZVk7XHJcblx0XHRcdHRlWyA1IF0gPSBtZVsgNSBdICogc2NhbGVZO1xyXG5cdFx0XHR0ZVsgNiBdID0gbWVbIDYgXSAqIHNjYWxlWTtcclxuXHJcblx0XHRcdHRlWyA4IF0gPSBtZVsgOCBdICogc2NhbGVaO1xyXG5cdFx0XHR0ZVsgOSBdID0gbWVbIDkgXSAqIHNjYWxlWjtcclxuXHRcdFx0dGVbIDEwIF0gPSBtZVsgMTAgXSAqIHNjYWxlWjtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0bWFrZVJvdGF0aW9uRnJvbUV1bGVyOiBmdW5jdGlvbiAoIGV1bGVyICkge1xyXG5cclxuXHRcdGlmICggZXVsZXIgaW5zdGFuY2VvZiBUSFJFRS5FdWxlciA9PT0gZmFsc2UgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuTWF0cml4OiAubWFrZVJvdGF0aW9uRnJvbUV1bGVyKCkgbm93IGV4cGVjdHMgYSBFdWxlciByb3RhdGlvbiByYXRoZXIgdGhhbiBhIFZlY3RvcjMgYW5kIG9yZGVyLicgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcblx0XHR2YXIgeCA9IGV1bGVyLngsIHkgPSBldWxlci55LCB6ID0gZXVsZXIuejtcclxuXHRcdHZhciBhID0gTWF0aC5jb3MoIHggKSwgYiA9IE1hdGguc2luKCB4ICk7XHJcblx0XHR2YXIgYyA9IE1hdGguY29zKCB5ICksIGQgPSBNYXRoLnNpbiggeSApO1xyXG5cdFx0dmFyIGUgPSBNYXRoLmNvcyggeiApLCBmID0gTWF0aC5zaW4oIHogKTtcclxuXHJcblx0XHRpZiAoIGV1bGVyLm9yZGVyID09PSAnWFlaJyApIHtcclxuXHJcblx0XHRcdHZhciBhZSA9IGEgKiBlLCBhZiA9IGEgKiBmLCBiZSA9IGIgKiBlLCBiZiA9IGIgKiBmO1xyXG5cclxuXHRcdFx0dGVbIDAgXSA9IGMgKiBlO1xyXG5cdFx0XHR0ZVsgNCBdID0gLSBjICogZjtcclxuXHRcdFx0dGVbIDggXSA9IGQ7XHJcblxyXG5cdFx0XHR0ZVsgMSBdID0gYWYgKyBiZSAqIGQ7XHJcblx0XHRcdHRlWyA1IF0gPSBhZSAtIGJmICogZDtcclxuXHRcdFx0dGVbIDkgXSA9IC0gYiAqIGM7XHJcblxyXG5cdFx0XHR0ZVsgMiBdID0gYmYgLSBhZSAqIGQ7XHJcblx0XHRcdHRlWyA2IF0gPSBiZSArIGFmICogZDtcclxuXHRcdFx0dGVbIDEwIF0gPSBhICogYztcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1lYWicgKSB7XHJcblxyXG5cdFx0XHR2YXIgY2UgPSBjICogZSwgY2YgPSBjICogZiwgZGUgPSBkICogZSwgZGYgPSBkICogZjtcclxuXHJcblx0XHRcdHRlWyAwIF0gPSBjZSArIGRmICogYjtcclxuXHRcdFx0dGVbIDQgXSA9IGRlICogYiAtIGNmO1xyXG5cdFx0XHR0ZVsgOCBdID0gYSAqIGQ7XHJcblxyXG5cdFx0XHR0ZVsgMSBdID0gYSAqIGY7XHJcblx0XHRcdHRlWyA1IF0gPSBhICogZTtcclxuXHRcdFx0dGVbIDkgXSA9IC0gYjtcclxuXHJcblx0XHRcdHRlWyAyIF0gPSBjZiAqIGIgLSBkZTtcclxuXHRcdFx0dGVbIDYgXSA9IGRmICsgY2UgKiBiO1xyXG5cdFx0XHR0ZVsgMTAgXSA9IGEgKiBjO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIGV1bGVyLm9yZGVyID09PSAnWlhZJyApIHtcclxuXHJcblx0XHRcdHZhciBjZSA9IGMgKiBlLCBjZiA9IGMgKiBmLCBkZSA9IGQgKiBlLCBkZiA9IGQgKiBmO1xyXG5cclxuXHRcdFx0dGVbIDAgXSA9IGNlIC0gZGYgKiBiO1xyXG5cdFx0XHR0ZVsgNCBdID0gLSBhICogZjtcclxuXHRcdFx0dGVbIDggXSA9IGRlICsgY2YgKiBiO1xyXG5cclxuXHRcdFx0dGVbIDEgXSA9IGNmICsgZGUgKiBiO1xyXG5cdFx0XHR0ZVsgNSBdID0gYSAqIGU7XHJcblx0XHRcdHRlWyA5IF0gPSBkZiAtIGNlICogYjtcclxuXHJcblx0XHRcdHRlWyAyIF0gPSAtIGEgKiBkO1xyXG5cdFx0XHR0ZVsgNiBdID0gYjtcclxuXHRcdFx0dGVbIDEwIF0gPSBhICogYztcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1pZWCcgKSB7XHJcblxyXG5cdFx0XHR2YXIgYWUgPSBhICogZSwgYWYgPSBhICogZiwgYmUgPSBiICogZSwgYmYgPSBiICogZjtcclxuXHJcblx0XHRcdHRlWyAwIF0gPSBjICogZTtcclxuXHRcdFx0dGVbIDQgXSA9IGJlICogZCAtIGFmO1xyXG5cdFx0XHR0ZVsgOCBdID0gYWUgKiBkICsgYmY7XHJcblxyXG5cdFx0XHR0ZVsgMSBdID0gYyAqIGY7XHJcblx0XHRcdHRlWyA1IF0gPSBiZiAqIGQgKyBhZTtcclxuXHRcdFx0dGVbIDkgXSA9IGFmICogZCAtIGJlO1xyXG5cclxuXHRcdFx0dGVbIDIgXSA9IC0gZDtcclxuXHRcdFx0dGVbIDYgXSA9IGIgKiBjO1xyXG5cdFx0XHR0ZVsgMTAgXSA9IGEgKiBjO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIGV1bGVyLm9yZGVyID09PSAnWVpYJyApIHtcclxuXHJcblx0XHRcdHZhciBhYyA9IGEgKiBjLCBhZCA9IGEgKiBkLCBiYyA9IGIgKiBjLCBiZCA9IGIgKiBkO1xyXG5cclxuXHRcdFx0dGVbIDAgXSA9IGMgKiBlO1xyXG5cdFx0XHR0ZVsgNCBdID0gYmQgLSBhYyAqIGY7XHJcblx0XHRcdHRlWyA4IF0gPSBiYyAqIGYgKyBhZDtcclxuXHJcblx0XHRcdHRlWyAxIF0gPSBmO1xyXG5cdFx0XHR0ZVsgNSBdID0gYSAqIGU7XHJcblx0XHRcdHRlWyA5IF0gPSAtIGIgKiBlO1xyXG5cclxuXHRcdFx0dGVbIDIgXSA9IC0gZCAqIGU7XHJcblx0XHRcdHRlWyA2IF0gPSBhZCAqIGYgKyBiYztcclxuXHRcdFx0dGVbIDEwIF0gPSBhYyAtIGJkICogZjtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1haWScgKSB7XHJcblxyXG5cdFx0XHR2YXIgYWMgPSBhICogYywgYWQgPSBhICogZCwgYmMgPSBiICogYywgYmQgPSBiICogZDtcclxuXHJcblx0XHRcdHRlWyAwIF0gPSBjICogZTtcclxuXHRcdFx0dGVbIDQgXSA9IC0gZjtcclxuXHRcdFx0dGVbIDggXSA9IGQgKiBlO1xyXG5cclxuXHRcdFx0dGVbIDEgXSA9IGFjICogZiArIGJkO1xyXG5cdFx0XHR0ZVsgNSBdID0gYSAqIGU7XHJcblx0XHRcdHRlWyA5IF0gPSBhZCAqIGYgLSBiYztcclxuXHJcblx0XHRcdHRlWyAyIF0gPSBiYyAqIGYgLSBhZDtcclxuXHRcdFx0dGVbIDYgXSA9IGIgKiBlO1xyXG5cdFx0XHR0ZVsgMTAgXSA9IGJkICogZiArIGFjO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBsYXN0IGNvbHVtblxyXG5cdFx0dGVbIDMgXSA9IDA7XHJcblx0XHR0ZVsgNyBdID0gMDtcclxuXHRcdHRlWyAxMSBdID0gMDtcclxuXHJcblx0XHQvLyBib3R0b20gcm93XHJcblx0XHR0ZVsgMTIgXSA9IDA7XHJcblx0XHR0ZVsgMTMgXSA9IDA7XHJcblx0XHR0ZVsgMTQgXSA9IDA7XHJcblx0XHR0ZVsgMTUgXSA9IDE7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uOiBmdW5jdGlvbiAoIHEgKSB7XHJcblxyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcblx0XHR2YXIgeCA9IHEueCwgeSA9IHEueSwgeiA9IHEueiwgdyA9IHEudztcclxuXHRcdHZhciB4MiA9IHggKyB4LCB5MiA9IHkgKyB5LCB6MiA9IHogKyB6O1xyXG5cdFx0dmFyIHh4ID0geCAqIHgyLCB4eSA9IHggKiB5MiwgeHogPSB4ICogejI7XHJcblx0XHR2YXIgeXkgPSB5ICogeTIsIHl6ID0geSAqIHoyLCB6eiA9IHogKiB6MjtcclxuXHRcdHZhciB3eCA9IHcgKiB4Miwgd3kgPSB3ICogeTIsIHd6ID0gdyAqIHoyO1xyXG5cclxuXHRcdHRlWyAwIF0gPSAxIC0gKCB5eSArIHp6ICk7XHJcblx0XHR0ZVsgNCBdID0geHkgLSB3ejtcclxuXHRcdHRlWyA4IF0gPSB4eiArIHd5O1xyXG5cclxuXHRcdHRlWyAxIF0gPSB4eSArIHd6O1xyXG5cdFx0dGVbIDUgXSA9IDEgLSAoIHh4ICsgenogKTtcclxuXHRcdHRlWyA5IF0gPSB5eiAtIHd4O1xyXG5cclxuXHRcdHRlWyAyIF0gPSB4eiAtIHd5O1xyXG5cdFx0dGVbIDYgXSA9IHl6ICsgd3g7XHJcblx0XHR0ZVsgMTAgXSA9IDEgLSAoIHh4ICsgeXkgKTtcclxuXHJcblx0XHQvLyBsYXN0IGNvbHVtblxyXG5cdFx0dGVbIDMgXSA9IDA7XHJcblx0XHR0ZVsgNyBdID0gMDtcclxuXHRcdHRlWyAxMSBdID0gMDtcclxuXHJcblx0XHQvLyBib3R0b20gcm93XHJcblx0XHR0ZVsgMTIgXSA9IDA7XHJcblx0XHR0ZVsgMTMgXSA9IDA7XHJcblx0XHR0ZVsgMTQgXSA9IDA7XHJcblx0XHR0ZVsgMTUgXSA9IDE7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGxvb2tBdDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB4LCB5LCB6O1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIGV5ZSwgdGFyZ2V0LCB1cCApIHtcclxuXHJcblx0XHRcdGlmICggeCA9PT0gdW5kZWZpbmVkICkgeCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHRcdGlmICggeSA9PT0gdW5kZWZpbmVkICkgeSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHRcdGlmICggeiA9PT0gdW5kZWZpbmVkICkgeiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuXHRcdFx0ei5zdWJWZWN0b3JzKCBleWUsIHRhcmdldCApLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdFx0aWYgKCB6Lmxlbmd0aFNxKCkgPT09IDAgKSB7XHJcblxyXG5cdFx0XHRcdHoueiA9IDE7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR4LmNyb3NzVmVjdG9ycyggdXAsIHogKS5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRcdGlmICggeC5sZW5ndGhTcSgpID09PSAwICkge1xyXG5cclxuXHRcdFx0XHR6LnggKz0gMC4wMDAxO1xyXG5cdFx0XHRcdHguY3Jvc3NWZWN0b3JzKCB1cCwgeiApLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0eS5jcm9zc1ZlY3RvcnMoIHosIHggKTtcclxuXHJcblxyXG5cdFx0XHR0ZVsgMCBdID0geC54OyB0ZVsgNCBdID0geS54OyB0ZVsgOCBdID0gei54O1xyXG5cdFx0XHR0ZVsgMSBdID0geC55OyB0ZVsgNSBdID0geS55OyB0ZVsgOSBdID0gei55O1xyXG5cdFx0XHR0ZVsgMiBdID0geC56OyB0ZVsgNiBdID0geS56OyB0ZVsgMTAgXSA9IHouejtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0bXVsdGlwbHk6IGZ1bmN0aW9uICggbSwgbiApIHtcclxuXHJcblx0XHRpZiAoIG4gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC5tdWx0aXBseSgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLm11bHRpcGx5TWF0cmljZXMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlNYXRyaWNlcyggbSwgbiApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseU1hdHJpY2VzKCB0aGlzLCBtICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdG11bHRpcGx5TWF0cmljZXM6IGZ1bmN0aW9uICggYSwgYiApIHtcclxuXHJcblx0XHR2YXIgYWUgPSBhLmVsZW1lbnRzO1xyXG5cdFx0dmFyIGJlID0gYi5lbGVtZW50cztcclxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG5cdFx0dmFyIGExMSA9IGFlWyAwIF0sIGExMiA9IGFlWyA0IF0sIGExMyA9IGFlWyA4IF0sIGExNCA9IGFlWyAxMiBdO1xyXG5cdFx0dmFyIGEyMSA9IGFlWyAxIF0sIGEyMiA9IGFlWyA1IF0sIGEyMyA9IGFlWyA5IF0sIGEyNCA9IGFlWyAxMyBdO1xyXG5cdFx0dmFyIGEzMSA9IGFlWyAyIF0sIGEzMiA9IGFlWyA2IF0sIGEzMyA9IGFlWyAxMCBdLCBhMzQgPSBhZVsgMTQgXTtcclxuXHRcdHZhciBhNDEgPSBhZVsgMyBdLCBhNDIgPSBhZVsgNyBdLCBhNDMgPSBhZVsgMTEgXSwgYTQ0ID0gYWVbIDE1IF07XHJcblxyXG5cdFx0dmFyIGIxMSA9IGJlWyAwIF0sIGIxMiA9IGJlWyA0IF0sIGIxMyA9IGJlWyA4IF0sIGIxNCA9IGJlWyAxMiBdO1xyXG5cdFx0dmFyIGIyMSA9IGJlWyAxIF0sIGIyMiA9IGJlWyA1IF0sIGIyMyA9IGJlWyA5IF0sIGIyNCA9IGJlWyAxMyBdO1xyXG5cdFx0dmFyIGIzMSA9IGJlWyAyIF0sIGIzMiA9IGJlWyA2IF0sIGIzMyA9IGJlWyAxMCBdLCBiMzQgPSBiZVsgMTQgXTtcclxuXHRcdHZhciBiNDEgPSBiZVsgMyBdLCBiNDIgPSBiZVsgNyBdLCBiNDMgPSBiZVsgMTEgXSwgYjQ0ID0gYmVbIDE1IF07XHJcblxyXG5cdFx0dGVbIDAgXSA9IGExMSAqIGIxMSArIGExMiAqIGIyMSArIGExMyAqIGIzMSArIGExNCAqIGI0MTtcclxuXHRcdHRlWyA0IF0gPSBhMTEgKiBiMTIgKyBhMTIgKiBiMjIgKyBhMTMgKiBiMzIgKyBhMTQgKiBiNDI7XHJcblx0XHR0ZVsgOCBdID0gYTExICogYjEzICsgYTEyICogYjIzICsgYTEzICogYjMzICsgYTE0ICogYjQzO1xyXG5cdFx0dGVbIDEyIF0gPSBhMTEgKiBiMTQgKyBhMTIgKiBiMjQgKyBhMTMgKiBiMzQgKyBhMTQgKiBiNDQ7XHJcblxyXG5cdFx0dGVbIDEgXSA9IGEyMSAqIGIxMSArIGEyMiAqIGIyMSArIGEyMyAqIGIzMSArIGEyNCAqIGI0MTtcclxuXHRcdHRlWyA1IF0gPSBhMjEgKiBiMTIgKyBhMjIgKiBiMjIgKyBhMjMgKiBiMzIgKyBhMjQgKiBiNDI7XHJcblx0XHR0ZVsgOSBdID0gYTIxICogYjEzICsgYTIyICogYjIzICsgYTIzICogYjMzICsgYTI0ICogYjQzO1xyXG5cdFx0dGVbIDEzIF0gPSBhMjEgKiBiMTQgKyBhMjIgKiBiMjQgKyBhMjMgKiBiMzQgKyBhMjQgKiBiNDQ7XHJcblxyXG5cdFx0dGVbIDIgXSA9IGEzMSAqIGIxMSArIGEzMiAqIGIyMSArIGEzMyAqIGIzMSArIGEzNCAqIGI0MTtcclxuXHRcdHRlWyA2IF0gPSBhMzEgKiBiMTIgKyBhMzIgKiBiMjIgKyBhMzMgKiBiMzIgKyBhMzQgKiBiNDI7XHJcblx0XHR0ZVsgMTAgXSA9IGEzMSAqIGIxMyArIGEzMiAqIGIyMyArIGEzMyAqIGIzMyArIGEzNCAqIGI0MztcclxuXHRcdHRlWyAxNCBdID0gYTMxICogYjE0ICsgYTMyICogYjI0ICsgYTMzICogYjM0ICsgYTM0ICogYjQ0O1xyXG5cclxuXHRcdHRlWyAzIF0gPSBhNDEgKiBiMTEgKyBhNDIgKiBiMjEgKyBhNDMgKiBiMzEgKyBhNDQgKiBiNDE7XHJcblx0XHR0ZVsgNyBdID0gYTQxICogYjEyICsgYTQyICogYjIyICsgYTQzICogYjMyICsgYTQ0ICogYjQyO1xyXG5cdFx0dGVbIDExIF0gPSBhNDEgKiBiMTMgKyBhNDIgKiBiMjMgKyBhNDMgKiBiMzMgKyBhNDQgKiBiNDM7XHJcblx0XHR0ZVsgMTUgXSA9IGE0MSAqIGIxNCArIGE0MiAqIGIyNCArIGE0MyAqIGIzNCArIGE0NCAqIGI0NDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bXVsdGlwbHlUb0FycmF5OiBmdW5jdGlvbiAoIGEsIGIsIHIgKSB7XHJcblxyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcblx0XHR0aGlzLm11bHRpcGx5TWF0cmljZXMoIGEsIGIgKTtcclxuXHJcblx0XHRyWyAwIF0gPSB0ZVsgMCBdOyByWyAxIF0gPSB0ZVsgMSBdOyByWyAyIF0gPSB0ZVsgMiBdOyByWyAzIF0gPSB0ZVsgMyBdO1xyXG5cdFx0clsgNCBdID0gdGVbIDQgXTsgclsgNSBdID0gdGVbIDUgXTsgclsgNiBdID0gdGVbIDYgXTsgclsgNyBdID0gdGVbIDcgXTtcclxuXHRcdHJbIDggXSAgPSB0ZVsgOCBdOyByWyA5IF0gID0gdGVbIDkgXTsgclsgMTAgXSA9IHRlWyAxMCBdOyByWyAxMSBdID0gdGVbIDExIF07XHJcblx0XHRyWyAxMiBdID0gdGVbIDEyIF07IHJbIDEzIF0gPSB0ZVsgMTMgXTsgclsgMTQgXSA9IHRlWyAxNCBdOyByWyAxNSBdID0gdGVbIDE1IF07XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG11bHRpcGx5U2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XHJcblxyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcblx0XHR0ZVsgMCBdICo9IHM7IHRlWyA0IF0gKj0gczsgdGVbIDggXSAqPSBzOyB0ZVsgMTIgXSAqPSBzO1xyXG5cdFx0dGVbIDEgXSAqPSBzOyB0ZVsgNSBdICo9IHM7IHRlWyA5IF0gKj0gczsgdGVbIDEzIF0gKj0gcztcclxuXHRcdHRlWyAyIF0gKj0gczsgdGVbIDYgXSAqPSBzOyB0ZVsgMTAgXSAqPSBzOyB0ZVsgMTQgXSAqPSBzO1xyXG5cdFx0dGVbIDMgXSAqPSBzOyB0ZVsgNyBdICo9IHM7IHRlWyAxMSBdICo9IHM7IHRlWyAxNSBdICo9IHM7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFwcGx5VG9WZWN0b3IzQXJyYXk6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdjE7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCwgbGVuZ3RoICkge1xyXG5cclxuXHRcdFx0aWYgKCB2MSA9PT0gdW5kZWZpbmVkICkgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcclxuXHRcdFx0aWYgKCBsZW5ndGggPT09IHVuZGVmaW5lZCApIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMCwgaiA9IG9mZnNldDsgaSA8IGxlbmd0aDsgaSArPSAzLCBqICs9IDMgKSB7XHJcblxyXG5cdFx0XHRcdHYxLmZyb21BcnJheSggYXJyYXksIGogKTtcclxuXHRcdFx0XHR2MS5hcHBseU1hdHJpeDQoIHRoaXMgKTtcclxuXHRcdFx0XHR2MS50b0FycmF5KCBhcnJheSwgaiApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIGFycmF5O1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0YXBwbHlUb0J1ZmZlcjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB2MTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gYXBwbHlUb0J1ZmZlciggYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCApIHtcclxuXHJcblx0XHRcdGlmICggdjEgPT09IHVuZGVmaW5lZCApIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XHJcblx0XHRcdGlmICggbGVuZ3RoID09PSB1bmRlZmluZWQgKSBsZW5ndGggPSBidWZmZXIubGVuZ3RoIC8gYnVmZmVyLml0ZW1TaXplO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBqID0gb2Zmc2V0OyBpIDwgbGVuZ3RoOyBpICsrLCBqICsrICkge1xyXG5cclxuXHRcdFx0XHR2MS54ID0gYnVmZmVyLmdldFgoIGogKTtcclxuXHRcdFx0XHR2MS55ID0gYnVmZmVyLmdldFkoIGogKTtcclxuXHRcdFx0XHR2MS56ID0gYnVmZmVyLmdldFooIGogKTtcclxuXHJcblx0XHRcdFx0djEuYXBwbHlNYXRyaXg0KCB0aGlzICk7XHJcblxyXG5cdFx0XHRcdGJ1ZmZlci5zZXRYWVooIHYxLngsIHYxLnksIHYxLnogKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBidWZmZXI7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRkZXRlcm1pbmFudDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG5cdFx0dmFyIG4xMSA9IHRlWyAwIF0sIG4xMiA9IHRlWyA0IF0sIG4xMyA9IHRlWyA4IF0sIG4xNCA9IHRlWyAxMiBdO1xyXG5cdFx0dmFyIG4yMSA9IHRlWyAxIF0sIG4yMiA9IHRlWyA1IF0sIG4yMyA9IHRlWyA5IF0sIG4yNCA9IHRlWyAxMyBdO1xyXG5cdFx0dmFyIG4zMSA9IHRlWyAyIF0sIG4zMiA9IHRlWyA2IF0sIG4zMyA9IHRlWyAxMCBdLCBuMzQgPSB0ZVsgMTQgXTtcclxuXHRcdHZhciBuNDEgPSB0ZVsgMyBdLCBuNDIgPSB0ZVsgNyBdLCBuNDMgPSB0ZVsgMTEgXSwgbjQ0ID0gdGVbIDE1IF07XHJcblxyXG5cdFx0Ly9UT0RPOiBtYWtlIHRoaXMgbW9yZSBlZmZpY2llbnRcclxuXHRcdC8vKCBiYXNlZCBvbiBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9hbGdlYnJhL21hdHJpeC9mdW5jdGlvbnMvaW52ZXJzZS9mb3VyRC9pbmRleC5odG0gKVxyXG5cclxuXHRcdHJldHVybiAoXHJcblx0XHRcdG40MSAqIChcclxuXHRcdFx0XHQrIG4xNCAqIG4yMyAqIG4zMlxyXG5cdFx0XHRcdCAtIG4xMyAqIG4yNCAqIG4zMlxyXG5cdFx0XHRcdCAtIG4xNCAqIG4yMiAqIG4zM1xyXG5cdFx0XHRcdCArIG4xMiAqIG4yNCAqIG4zM1xyXG5cdFx0XHRcdCArIG4xMyAqIG4yMiAqIG4zNFxyXG5cdFx0XHRcdCAtIG4xMiAqIG4yMyAqIG4zNFxyXG5cdFx0XHQpICtcclxuXHRcdFx0bjQyICogKFxyXG5cdFx0XHRcdCsgbjExICogbjIzICogbjM0XHJcblx0XHRcdFx0IC0gbjExICogbjI0ICogbjMzXHJcblx0XHRcdFx0ICsgbjE0ICogbjIxICogbjMzXHJcblx0XHRcdFx0IC0gbjEzICogbjIxICogbjM0XHJcblx0XHRcdFx0ICsgbjEzICogbjI0ICogbjMxXHJcblx0XHRcdFx0IC0gbjE0ICogbjIzICogbjMxXHJcblx0XHRcdCkgK1xyXG5cdFx0XHRuNDMgKiAoXHJcblx0XHRcdFx0KyBuMTEgKiBuMjQgKiBuMzJcclxuXHRcdFx0XHQgLSBuMTEgKiBuMjIgKiBuMzRcclxuXHRcdFx0XHQgLSBuMTQgKiBuMjEgKiBuMzJcclxuXHRcdFx0XHQgKyBuMTIgKiBuMjEgKiBuMzRcclxuXHRcdFx0XHQgKyBuMTQgKiBuMjIgKiBuMzFcclxuXHRcdFx0XHQgLSBuMTIgKiBuMjQgKiBuMzFcclxuXHRcdFx0KSArXHJcblx0XHRcdG40NCAqIChcclxuXHRcdFx0XHQtIG4xMyAqIG4yMiAqIG4zMVxyXG5cdFx0XHRcdCAtIG4xMSAqIG4yMyAqIG4zMlxyXG5cdFx0XHRcdCArIG4xMSAqIG4yMiAqIG4zM1xyXG5cdFx0XHRcdCArIG4xMyAqIG4yMSAqIG4zMlxyXG5cdFx0XHRcdCAtIG4xMiAqIG4yMSAqIG4zM1xyXG5cdFx0XHRcdCArIG4xMiAqIG4yMyAqIG4zMVxyXG5cdFx0XHQpXHJcblxyXG5cdFx0KTtcclxuXHJcblx0fSxcclxuXHJcblx0dHJhbnNwb3NlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHRcdHZhciB0bXA7XHJcblxyXG5cdFx0dG1wID0gdGVbIDEgXTsgdGVbIDEgXSA9IHRlWyA0IF07IHRlWyA0IF0gPSB0bXA7XHJcblx0XHR0bXAgPSB0ZVsgMiBdOyB0ZVsgMiBdID0gdGVbIDggXTsgdGVbIDggXSA9IHRtcDtcclxuXHRcdHRtcCA9IHRlWyA2IF07IHRlWyA2IF0gPSB0ZVsgOSBdOyB0ZVsgOSBdID0gdG1wO1xyXG5cclxuXHRcdHRtcCA9IHRlWyAzIF07IHRlWyAzIF0gPSB0ZVsgMTIgXTsgdGVbIDEyIF0gPSB0bXA7XHJcblx0XHR0bXAgPSB0ZVsgNyBdOyB0ZVsgNyBdID0gdGVbIDEzIF07IHRlWyAxMyBdID0gdG1wO1xyXG5cdFx0dG1wID0gdGVbIDExIF07IHRlWyAxMSBdID0gdGVbIDE0IF07IHRlWyAxNCBdID0gdG1wO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRmbGF0dGVuVG9BcnJheU9mZnNldDogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xyXG5cclxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG5cdFx0YXJyYXlbIG9mZnNldCBdID0gdGVbIDAgXTtcclxuXHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0ZVsgMSBdO1xyXG5cdFx0YXJyYXlbIG9mZnNldCArIDIgXSA9IHRlWyAyIF07XHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgMyBdID0gdGVbIDMgXTtcclxuXHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgNCBdID0gdGVbIDQgXTtcclxuXHRcdGFycmF5WyBvZmZzZXQgKyA1IF0gPSB0ZVsgNSBdO1xyXG5cdFx0YXJyYXlbIG9mZnNldCArIDYgXSA9IHRlWyA2IF07XHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgNyBdID0gdGVbIDcgXTtcclxuXHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgOCBdICA9IHRlWyA4IF07XHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgOSBdICA9IHRlWyA5IF07XHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgMTAgXSA9IHRlWyAxMCBdO1xyXG5cdFx0YXJyYXlbIG9mZnNldCArIDExIF0gPSB0ZVsgMTEgXTtcclxuXHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgMTIgXSA9IHRlWyAxMiBdO1xyXG5cdFx0YXJyYXlbIG9mZnNldCArIDEzIF0gPSB0ZVsgMTMgXTtcclxuXHRcdGFycmF5WyBvZmZzZXQgKyAxNCBdID0gdGVbIDE0IF07XHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgMTUgXSA9IHRlWyAxNSBdO1xyXG5cclxuXHRcdHJldHVybiBhcnJheTtcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0UG9zaXRpb246IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdjE7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdGlmICggdjEgPT09IHVuZGVmaW5lZCApIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLmdldFBvc2l0aW9uKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFZlY3RvcjMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBtYXRyaXggKSBpbnN0ZWFkLicgKTtcclxuXHJcblx0XHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblx0XHRcdHJldHVybiB2MS5zZXQoIHRlWyAxMiBdLCB0ZVsgMTMgXSwgdGVbIDE0IF0gKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdHNldFBvc2l0aW9uOiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcblx0XHR0ZVsgMTIgXSA9IHYueDtcclxuXHRcdHRlWyAxMyBdID0gdi55O1xyXG5cdFx0dGVbIDE0IF0gPSB2Lno7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldEludmVyc2U6IGZ1bmN0aW9uICggbSwgdGhyb3dPbkludmVydGlibGUgKSB7XHJcblxyXG5cdFx0Ly8gYmFzZWQgb24gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvYWxnZWJyYS9tYXRyaXgvZnVuY3Rpb25zL2ludmVyc2UvZm91ckQvaW5kZXguaHRtXHJcblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cdFx0dmFyIG1lID0gbS5lbGVtZW50cztcclxuXHJcblx0XHR2YXIgbjExID0gbWVbIDAgXSwgbjEyID0gbWVbIDQgXSwgbjEzID0gbWVbIDggXSwgbjE0ID0gbWVbIDEyIF07XHJcblx0XHR2YXIgbjIxID0gbWVbIDEgXSwgbjIyID0gbWVbIDUgXSwgbjIzID0gbWVbIDkgXSwgbjI0ID0gbWVbIDEzIF07XHJcblx0XHR2YXIgbjMxID0gbWVbIDIgXSwgbjMyID0gbWVbIDYgXSwgbjMzID0gbWVbIDEwIF0sIG4zNCA9IG1lWyAxNCBdO1xyXG5cdFx0dmFyIG40MSA9IG1lWyAzIF0sIG40MiA9IG1lWyA3IF0sIG40MyA9IG1lWyAxMSBdLCBuNDQgPSBtZVsgMTUgXTtcclxuXHJcblx0XHR0ZVsgMCBdID0gbjIzICogbjM0ICogbjQyIC0gbjI0ICogbjMzICogbjQyICsgbjI0ICogbjMyICogbjQzIC0gbjIyICogbjM0ICogbjQzIC0gbjIzICogbjMyICogbjQ0ICsgbjIyICogbjMzICogbjQ0O1xyXG5cdFx0dGVbIDQgXSA9IG4xNCAqIG4zMyAqIG40MiAtIG4xMyAqIG4zNCAqIG40MiAtIG4xNCAqIG4zMiAqIG40MyArIG4xMiAqIG4zNCAqIG40MyArIG4xMyAqIG4zMiAqIG40NCAtIG4xMiAqIG4zMyAqIG40NDtcclxuXHRcdHRlWyA4IF0gPSBuMTMgKiBuMjQgKiBuNDIgLSBuMTQgKiBuMjMgKiBuNDIgKyBuMTQgKiBuMjIgKiBuNDMgLSBuMTIgKiBuMjQgKiBuNDMgLSBuMTMgKiBuMjIgKiBuNDQgKyBuMTIgKiBuMjMgKiBuNDQ7XHJcblx0XHR0ZVsgMTIgXSA9IG4xNCAqIG4yMyAqIG4zMiAtIG4xMyAqIG4yNCAqIG4zMiAtIG4xNCAqIG4yMiAqIG4zMyArIG4xMiAqIG4yNCAqIG4zMyArIG4xMyAqIG4yMiAqIG4zNCAtIG4xMiAqIG4yMyAqIG4zNDtcclxuXHRcdHRlWyAxIF0gPSBuMjQgKiBuMzMgKiBuNDEgLSBuMjMgKiBuMzQgKiBuNDEgLSBuMjQgKiBuMzEgKiBuNDMgKyBuMjEgKiBuMzQgKiBuNDMgKyBuMjMgKiBuMzEgKiBuNDQgLSBuMjEgKiBuMzMgKiBuNDQ7XHJcblx0XHR0ZVsgNSBdID0gbjEzICogbjM0ICogbjQxIC0gbjE0ICogbjMzICogbjQxICsgbjE0ICogbjMxICogbjQzIC0gbjExICogbjM0ICogbjQzIC0gbjEzICogbjMxICogbjQ0ICsgbjExICogbjMzICogbjQ0O1xyXG5cdFx0dGVbIDkgXSA9IG4xNCAqIG4yMyAqIG40MSAtIG4xMyAqIG4yNCAqIG40MSAtIG4xNCAqIG4yMSAqIG40MyArIG4xMSAqIG4yNCAqIG40MyArIG4xMyAqIG4yMSAqIG40NCAtIG4xMSAqIG4yMyAqIG40NDtcclxuXHRcdHRlWyAxMyBdID0gbjEzICogbjI0ICogbjMxIC0gbjE0ICogbjIzICogbjMxICsgbjE0ICogbjIxICogbjMzIC0gbjExICogbjI0ICogbjMzIC0gbjEzICogbjIxICogbjM0ICsgbjExICogbjIzICogbjM0O1xyXG5cdFx0dGVbIDIgXSA9IG4yMiAqIG4zNCAqIG40MSAtIG4yNCAqIG4zMiAqIG40MSArIG4yNCAqIG4zMSAqIG40MiAtIG4yMSAqIG4zNCAqIG40MiAtIG4yMiAqIG4zMSAqIG40NCArIG4yMSAqIG4zMiAqIG40NDtcclxuXHRcdHRlWyA2IF0gPSBuMTQgKiBuMzIgKiBuNDEgLSBuMTIgKiBuMzQgKiBuNDEgLSBuMTQgKiBuMzEgKiBuNDIgKyBuMTEgKiBuMzQgKiBuNDIgKyBuMTIgKiBuMzEgKiBuNDQgLSBuMTEgKiBuMzIgKiBuNDQ7XHJcblx0XHR0ZVsgMTAgXSA9IG4xMiAqIG4yNCAqIG40MSAtIG4xNCAqIG4yMiAqIG40MSArIG4xNCAqIG4yMSAqIG40MiAtIG4xMSAqIG4yNCAqIG40MiAtIG4xMiAqIG4yMSAqIG40NCArIG4xMSAqIG4yMiAqIG40NDtcclxuXHRcdHRlWyAxNCBdID0gbjE0ICogbjIyICogbjMxIC0gbjEyICogbjI0ICogbjMxIC0gbjE0ICogbjIxICogbjMyICsgbjExICogbjI0ICogbjMyICsgbjEyICogbjIxICogbjM0IC0gbjExICogbjIyICogbjM0O1xyXG5cdFx0dGVbIDMgXSA9IG4yMyAqIG4zMiAqIG40MSAtIG4yMiAqIG4zMyAqIG40MSAtIG4yMyAqIG4zMSAqIG40MiArIG4yMSAqIG4zMyAqIG40MiArIG4yMiAqIG4zMSAqIG40MyAtIG4yMSAqIG4zMiAqIG40MztcclxuXHRcdHRlWyA3IF0gPSBuMTIgKiBuMzMgKiBuNDEgLSBuMTMgKiBuMzIgKiBuNDEgKyBuMTMgKiBuMzEgKiBuNDIgLSBuMTEgKiBuMzMgKiBuNDIgLSBuMTIgKiBuMzEgKiBuNDMgKyBuMTEgKiBuMzIgKiBuNDM7XHJcblx0XHR0ZVsgMTEgXSA9IG4xMyAqIG4yMiAqIG40MSAtIG4xMiAqIG4yMyAqIG40MSAtIG4xMyAqIG4yMSAqIG40MiArIG4xMSAqIG4yMyAqIG40MiArIG4xMiAqIG4yMSAqIG40MyAtIG4xMSAqIG4yMiAqIG40MztcclxuXHRcdHRlWyAxNSBdID0gbjEyICogbjIzICogbjMxIC0gbjEzICogbjIyICogbjMxICsgbjEzICogbjIxICogbjMyIC0gbjExICogbjIzICogbjMyIC0gbjEyICogbjIxICogbjMzICsgbjExICogbjIyICogbjMzO1xyXG5cclxuXHRcdHZhciBkZXQgPSBuMTEgKiB0ZVsgMCBdICsgbjIxICogdGVbIDQgXSArIG4zMSAqIHRlWyA4IF0gKyBuNDEgKiB0ZVsgMTIgXTtcclxuXHJcblx0XHRpZiAoIGRldCA9PT0gMCApIHtcclxuXHJcblx0XHRcdHZhciBtc2cgPSBcIlRIUkVFLk1hdHJpeDQuZ2V0SW52ZXJzZSgpOiBjYW4ndCBpbnZlcnQgbWF0cml4LCBkZXRlcm1pbmFudCBpcyAwXCI7XHJcblxyXG5cdFx0XHRpZiAoIHRocm93T25JbnZlcnRpYmxlIHx8IGZhbHNlICkge1xyXG5cclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoIG1zZyApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCBtc2cgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuaWRlbnRpdHkoKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLm11bHRpcGx5U2NhbGFyKCAxIC8gZGV0ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNjYWxlOiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHRcdHZhciB4ID0gdi54LCB5ID0gdi55LCB6ID0gdi56O1xyXG5cclxuXHRcdHRlWyAwIF0gKj0geDsgdGVbIDQgXSAqPSB5OyB0ZVsgOCBdICo9IHo7XHJcblx0XHR0ZVsgMSBdICo9IHg7IHRlWyA1IF0gKj0geTsgdGVbIDkgXSAqPSB6O1xyXG5cdFx0dGVbIDIgXSAqPSB4OyB0ZVsgNiBdICo9IHk7IHRlWyAxMCBdICo9IHo7XHJcblx0XHR0ZVsgMyBdICo9IHg7IHRlWyA3IF0gKj0geTsgdGVbIDExIF0gKj0gejtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0TWF4U2NhbGVPbkF4aXM6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuXHRcdHZhciBzY2FsZVhTcSA9IHRlWyAwIF0gKiB0ZVsgMCBdICsgdGVbIDEgXSAqIHRlWyAxIF0gKyB0ZVsgMiBdICogdGVbIDIgXTtcclxuXHRcdHZhciBzY2FsZVlTcSA9IHRlWyA0IF0gKiB0ZVsgNCBdICsgdGVbIDUgXSAqIHRlWyA1IF0gKyB0ZVsgNiBdICogdGVbIDYgXTtcclxuXHRcdHZhciBzY2FsZVpTcSA9IHRlWyA4IF0gKiB0ZVsgOCBdICsgdGVbIDkgXSAqIHRlWyA5IF0gKyB0ZVsgMTAgXSAqIHRlWyAxMCBdO1xyXG5cclxuXHRcdHJldHVybiBNYXRoLnNxcnQoIE1hdGgubWF4KCBzY2FsZVhTcSwgc2NhbGVZU3EsIHNjYWxlWlNxICkgKTtcclxuXHJcblx0fSxcclxuXHJcblx0bWFrZVRyYW5zbGF0aW9uOiBmdW5jdGlvbiAoIHgsIHksIHogKSB7XHJcblxyXG5cdFx0dGhpcy5zZXQoXHJcblxyXG5cdFx0XHQxLCAwLCAwLCB4LFxyXG5cdFx0XHQwLCAxLCAwLCB5LFxyXG5cdFx0XHQwLCAwLCAxLCB6LFxyXG5cdFx0XHQwLCAwLCAwLCAxXHJcblxyXG5cdFx0KTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bWFrZVJvdGF0aW9uWDogZnVuY3Rpb24gKCB0aGV0YSApIHtcclxuXHJcblx0XHR2YXIgYyA9IE1hdGguY29zKCB0aGV0YSApLCBzID0gTWF0aC5zaW4oIHRoZXRhICk7XHJcblxyXG5cdFx0dGhpcy5zZXQoXHJcblxyXG5cdFx0XHQxLCAwLCAgMCwgMCxcclxuXHRcdFx0MCwgYywgLSBzLCAwLFxyXG5cdFx0XHQwLCBzLCAgYywgMCxcclxuXHRcdFx0MCwgMCwgIDAsIDFcclxuXHJcblx0XHQpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtYWtlUm90YXRpb25ZOiBmdW5jdGlvbiAoIHRoZXRhICkge1xyXG5cclxuXHRcdHZhciBjID0gTWF0aC5jb3MoIHRoZXRhICksIHMgPSBNYXRoLnNpbiggdGhldGEgKTtcclxuXHJcblx0XHR0aGlzLnNldChcclxuXHJcblx0XHRcdCBjLCAwLCBzLCAwLFxyXG5cdFx0XHQgMCwgMSwgMCwgMCxcclxuXHRcdFx0LSBzLCAwLCBjLCAwLFxyXG5cdFx0XHQgMCwgMCwgMCwgMVxyXG5cclxuXHRcdCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG1ha2VSb3RhdGlvblo6IGZ1bmN0aW9uICggdGhldGEgKSB7XHJcblxyXG5cdFx0dmFyIGMgPSBNYXRoLmNvcyggdGhldGEgKSwgcyA9IE1hdGguc2luKCB0aGV0YSApO1xyXG5cclxuXHRcdHRoaXMuc2V0KFxyXG5cclxuXHRcdFx0YywgLSBzLCAwLCAwLFxyXG5cdFx0XHRzLCAgYywgMCwgMCxcclxuXHRcdFx0MCwgIDAsIDEsIDAsXHJcblx0XHRcdDAsICAwLCAwLCAxXHJcblxyXG5cdFx0KTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bWFrZVJvdGF0aW9uQXhpczogZnVuY3Rpb24gKCBheGlzLCBhbmdsZSApIHtcclxuXHJcblx0XHQvLyBCYXNlZCBvbiBodHRwOi8vd3d3LmdhbWVkZXYubmV0L3JlZmVyZW5jZS9hcnRpY2xlcy9hcnRpY2xlMTE5OS5hc3BcclxuXHJcblx0XHR2YXIgYyA9IE1hdGguY29zKCBhbmdsZSApO1xyXG5cdFx0dmFyIHMgPSBNYXRoLnNpbiggYW5nbGUgKTtcclxuXHRcdHZhciB0ID0gMSAtIGM7XHJcblx0XHR2YXIgeCA9IGF4aXMueCwgeSA9IGF4aXMueSwgeiA9IGF4aXMuejtcclxuXHRcdHZhciB0eCA9IHQgKiB4LCB0eSA9IHQgKiB5O1xyXG5cclxuXHRcdHRoaXMuc2V0KFxyXG5cclxuXHRcdFx0dHggKiB4ICsgYywgdHggKiB5IC0gcyAqIHosIHR4ICogeiArIHMgKiB5LCAwLFxyXG5cdFx0XHR0eCAqIHkgKyBzICogeiwgdHkgKiB5ICsgYywgdHkgKiB6IC0gcyAqIHgsIDAsXHJcblx0XHRcdHR4ICogeiAtIHMgKiB5LCB0eSAqIHogKyBzICogeCwgdCAqIHogKiB6ICsgYywgMCxcclxuXHRcdFx0MCwgMCwgMCwgMVxyXG5cclxuXHRcdCk7XHJcblxyXG5cdFx0IHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtYWtlU2NhbGU6IGZ1bmN0aW9uICggeCwgeSwgeiApIHtcclxuXHJcblx0XHR0aGlzLnNldChcclxuXHJcblx0XHRcdHgsIDAsIDAsIDAsXHJcblx0XHRcdDAsIHksIDAsIDAsXHJcblx0XHRcdDAsIDAsIHosIDAsXHJcblx0XHRcdDAsIDAsIDAsIDFcclxuXHJcblx0XHQpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb21wb3NlOiBmdW5jdGlvbiAoIHBvc2l0aW9uLCBxdWF0ZXJuaW9uLCBzY2FsZSApIHtcclxuXHJcblx0XHR0aGlzLm1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uICk7XHJcblx0XHR0aGlzLnNjYWxlKCBzY2FsZSApO1xyXG5cdFx0dGhpcy5zZXRQb3NpdGlvbiggcG9zaXRpb24gKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZGVjb21wb3NlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHZlY3RvciwgbWF0cml4O1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIHBvc2l0aW9uLCBxdWF0ZXJuaW9uLCBzY2FsZSApIHtcclxuXHJcblx0XHRcdGlmICggdmVjdG9yID09PSB1bmRlZmluZWQgKSB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0XHRpZiAoIG1hdHJpeCA9PT0gdW5kZWZpbmVkICkgbWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHJcblx0XHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG5cdFx0XHR2YXIgc3ggPSB2ZWN0b3Iuc2V0KCB0ZVsgMCBdLCB0ZVsgMSBdLCB0ZVsgMiBdICkubGVuZ3RoKCk7XHJcblx0XHRcdHZhciBzeSA9IHZlY3Rvci5zZXQoIHRlWyA0IF0sIHRlWyA1IF0sIHRlWyA2IF0gKS5sZW5ndGgoKTtcclxuXHRcdFx0dmFyIHN6ID0gdmVjdG9yLnNldCggdGVbIDggXSwgdGVbIDkgXSwgdGVbIDEwIF0gKS5sZW5ndGgoKTtcclxuXHJcblx0XHRcdC8vIGlmIGRldGVybWluZSBpcyBuZWdhdGl2ZSwgd2UgbmVlZCB0byBpbnZlcnQgb25lIHNjYWxlXHJcblx0XHRcdHZhciBkZXQgPSB0aGlzLmRldGVybWluYW50KCk7XHJcblx0XHRcdGlmICggZGV0IDwgMCApIHtcclxuXHJcblx0XHRcdFx0c3ggPSAtIHN4O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cG9zaXRpb24ueCA9IHRlWyAxMiBdO1xyXG5cdFx0XHRwb3NpdGlvbi55ID0gdGVbIDEzIF07XHJcblx0XHRcdHBvc2l0aW9uLnogPSB0ZVsgMTQgXTtcclxuXHJcblx0XHRcdC8vIHNjYWxlIHRoZSByb3RhdGlvbiBwYXJ0XHJcblxyXG5cdFx0XHRtYXRyaXguZWxlbWVudHMuc2V0KCB0aGlzLmVsZW1lbnRzICk7IC8vIGF0IHRoaXMgcG9pbnQgbWF0cml4IGlzIGluY29tcGxldGUgc28gd2UgY2FuJ3QgdXNlIC5jb3B5KClcclxuXHJcblx0XHRcdHZhciBpbnZTWCA9IDEgLyBzeDtcclxuXHRcdFx0dmFyIGludlNZID0gMSAvIHN5O1xyXG5cdFx0XHR2YXIgaW52U1ogPSAxIC8gc3o7XHJcblxyXG5cdFx0XHRtYXRyaXguZWxlbWVudHNbIDAgXSAqPSBpbnZTWDtcclxuXHRcdFx0bWF0cml4LmVsZW1lbnRzWyAxIF0gKj0gaW52U1g7XHJcblx0XHRcdG1hdHJpeC5lbGVtZW50c1sgMiBdICo9IGludlNYO1xyXG5cclxuXHRcdFx0bWF0cml4LmVsZW1lbnRzWyA0IF0gKj0gaW52U1k7XHJcblx0XHRcdG1hdHJpeC5lbGVtZW50c1sgNSBdICo9IGludlNZO1xyXG5cdFx0XHRtYXRyaXguZWxlbWVudHNbIDYgXSAqPSBpbnZTWTtcclxuXHJcblx0XHRcdG1hdHJpeC5lbGVtZW50c1sgOCBdICo9IGludlNaO1xyXG5cdFx0XHRtYXRyaXguZWxlbWVudHNbIDkgXSAqPSBpbnZTWjtcclxuXHRcdFx0bWF0cml4LmVsZW1lbnRzWyAxMCBdICo9IGludlNaO1xyXG5cclxuXHRcdFx0cXVhdGVybmlvbi5zZXRGcm9tUm90YXRpb25NYXRyaXgoIG1hdHJpeCApO1xyXG5cclxuXHRcdFx0c2NhbGUueCA9IHN4O1xyXG5cdFx0XHRzY2FsZS55ID0gc3k7XHJcblx0XHRcdHNjYWxlLnogPSBzejtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0bWFrZUZydXN0dW06IGZ1bmN0aW9uICggbGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXIgKSB7XHJcblxyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHRcdHZhciB4ID0gMiAqIG5lYXIgLyAoIHJpZ2h0IC0gbGVmdCApO1xyXG5cdFx0dmFyIHkgPSAyICogbmVhciAvICggdG9wIC0gYm90dG9tICk7XHJcblxyXG5cdFx0dmFyIGEgPSAoIHJpZ2h0ICsgbGVmdCApIC8gKCByaWdodCAtIGxlZnQgKTtcclxuXHRcdHZhciBiID0gKCB0b3AgKyBib3R0b20gKSAvICggdG9wIC0gYm90dG9tICk7XHJcblx0XHR2YXIgYyA9IC0gKCBmYXIgKyBuZWFyICkgLyAoIGZhciAtIG5lYXIgKTtcclxuXHRcdHZhciBkID0gLSAyICogZmFyICogbmVhciAvICggZmFyIC0gbmVhciApO1xyXG5cclxuXHRcdHRlWyAwIF0gPSB4O1x0dGVbIDQgXSA9IDA7XHR0ZVsgOCBdID0gYTtcdHRlWyAxMiBdID0gMDtcclxuXHRcdHRlWyAxIF0gPSAwO1x0dGVbIDUgXSA9IHk7XHR0ZVsgOSBdID0gYjtcdHRlWyAxMyBdID0gMDtcclxuXHRcdHRlWyAyIF0gPSAwO1x0dGVbIDYgXSA9IDA7XHR0ZVsgMTAgXSA9IGM7XHR0ZVsgMTQgXSA9IGQ7XHJcblx0XHR0ZVsgMyBdID0gMDtcdHRlWyA3IF0gPSAwO1x0dGVbIDExIF0gPSAtIDE7XHR0ZVsgMTUgXSA9IDA7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG1ha2VQZXJzcGVjdGl2ZTogZnVuY3Rpb24gKCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyICkge1xyXG5cclxuXHRcdHZhciB5bWF4ID0gbmVhciAqIE1hdGgudGFuKCBUSFJFRS5NYXRoLmRlZ1RvUmFkKCBmb3YgKiAwLjUgKSApO1xyXG5cdFx0dmFyIHltaW4gPSAtIHltYXg7XHJcblx0XHR2YXIgeG1pbiA9IHltaW4gKiBhc3BlY3Q7XHJcblx0XHR2YXIgeG1heCA9IHltYXggKiBhc3BlY3Q7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMubWFrZUZydXN0dW0oIHhtaW4sIHhtYXgsIHltaW4sIHltYXgsIG5lYXIsIGZhciApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtYWtlT3J0aG9ncmFwaGljOiBmdW5jdGlvbiAoIGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSwgbmVhciwgZmFyICkge1xyXG5cclxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblx0XHR2YXIgdyA9IHJpZ2h0IC0gbGVmdDtcclxuXHRcdHZhciBoID0gdG9wIC0gYm90dG9tO1xyXG5cdFx0dmFyIHAgPSBmYXIgLSBuZWFyO1xyXG5cclxuXHRcdHZhciB4ID0gKCByaWdodCArIGxlZnQgKSAvIHc7XHJcblx0XHR2YXIgeSA9ICggdG9wICsgYm90dG9tICkgLyBoO1xyXG5cdFx0dmFyIHogPSAoIGZhciArIG5lYXIgKSAvIHA7XHJcblxyXG5cdFx0dGVbIDAgXSA9IDIgLyB3O1x0dGVbIDQgXSA9IDA7XHR0ZVsgOCBdID0gMDtcdHRlWyAxMiBdID0gLSB4O1xyXG5cdFx0dGVbIDEgXSA9IDA7XHR0ZVsgNSBdID0gMiAvIGg7XHR0ZVsgOSBdID0gMDtcdHRlWyAxMyBdID0gLSB5O1xyXG5cdFx0dGVbIDIgXSA9IDA7XHR0ZVsgNiBdID0gMDtcdHRlWyAxMCBdID0gLSAyIC8gcDtcdHRlWyAxNCBdID0gLSB6O1xyXG5cdFx0dGVbIDMgXSA9IDA7XHR0ZVsgNyBdID0gMDtcdHRlWyAxMSBdID0gMDtcdHRlWyAxNSBdID0gMTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZXF1YWxzOiBmdW5jdGlvbiAoIG1hdHJpeCApIHtcclxuXHJcblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cdFx0dmFyIG1lID0gbWF0cml4LmVsZW1lbnRzO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IDE2OyBpICsrICkge1xyXG5cclxuXHRcdFx0aWYgKCB0ZVsgaSBdICE9PSBtZVsgaSBdICkgcmV0dXJuIGZhbHNlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHJcblx0fSxcclxuXHJcblx0ZnJvbUFycmF5OiBmdW5jdGlvbiAoIGFycmF5ICkge1xyXG5cclxuXHRcdHRoaXMuZWxlbWVudHMuc2V0KCBhcnJheSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHR0b0FycmF5OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcblx0XHRyZXR1cm4gW1xyXG5cdFx0XHR0ZVsgMCBdLCB0ZVsgMSBdLCB0ZVsgMiBdLCB0ZVsgMyBdLFxyXG5cdFx0XHR0ZVsgNCBdLCB0ZVsgNSBdLCB0ZVsgNiBdLCB0ZVsgNyBdLFxyXG5cdFx0XHR0ZVsgOCBdLCB0ZVsgOSBdLCB0ZVsgMTAgXSwgdGVbIDExIF0sXHJcblx0XHRcdHRlWyAxMiBdLCB0ZVsgMTMgXSwgdGVbIDE0IF0sIHRlWyAxNSBdXHJcblx0XHRdO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbWF0aC9SYXkuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXHJcbiAqL1xyXG5cclxuVEhSRUUuUmF5ID0gZnVuY3Rpb24gKCBvcmlnaW4sIGRpcmVjdGlvbiApIHtcclxuXHJcblx0dGhpcy5vcmlnaW4gPSAoIG9yaWdpbiAhPT0gdW5kZWZpbmVkICkgPyBvcmlnaW4gOiBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdHRoaXMuZGlyZWN0aW9uID0gKCBkaXJlY3Rpb24gIT09IHVuZGVmaW5lZCApID8gZGlyZWN0aW9uIDogbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5SYXkucHJvdG90eXBlID0ge1xyXG5cclxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuUmF5LFxyXG5cclxuXHRzZXQ6IGZ1bmN0aW9uICggb3JpZ2luLCBkaXJlY3Rpb24gKSB7XHJcblxyXG5cdFx0dGhpcy5vcmlnaW4uY29weSggb3JpZ2luICk7XHJcblx0XHR0aGlzLmRpcmVjdGlvbi5jb3B5KCBkaXJlY3Rpb24gKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvcHk6IGZ1bmN0aW9uICggcmF5ICkge1xyXG5cclxuXHRcdHRoaXMub3JpZ2luLmNvcHkoIHJheS5vcmlnaW4gKTtcclxuXHRcdHRoaXMuZGlyZWN0aW9uLmNvcHkoIHJheS5kaXJlY3Rpb24gKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0YXQ6IGZ1bmN0aW9uICggdCwgb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIHJlc3VsdC5jb3B5KCB0aGlzLmRpcmVjdGlvbiApLm11bHRpcGx5U2NhbGFyKCB0ICkuYWRkKCB0aGlzLm9yaWdpbiApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRsb29rQXQ6IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHR0aGlzLmRpcmVjdGlvbi5jb3B5KCB2ICkuc3ViKCB0aGlzLm9yaWdpbiApLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHR9LFxyXG5cclxuXHRyZWNhc3Q6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIHQgKSB7XHJcblxyXG5cdFx0XHR0aGlzLm9yaWdpbi5jb3B5KCB0aGlzLmF0KCB0LCB2MSApICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGNsb3Nlc3RQb2ludFRvUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0cmVzdWx0LnN1YlZlY3RvcnMoIHBvaW50LCB0aGlzLm9yaWdpbiApO1xyXG5cdFx0dmFyIGRpcmVjdGlvbkRpc3RhbmNlID0gcmVzdWx0LmRvdCggdGhpcy5kaXJlY3Rpb24gKTtcclxuXHJcblx0XHRpZiAoIGRpcmVjdGlvbkRpc3RhbmNlIDwgMCApIHtcclxuXHJcblx0XHRcdHJldHVybiByZXN1bHQuY29weSggdGhpcy5vcmlnaW4gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHJlc3VsdC5jb3B5KCB0aGlzLmRpcmVjdGlvbiApLm11bHRpcGx5U2NhbGFyKCBkaXJlY3Rpb25EaXN0YW5jZSApLmFkZCggdGhpcy5vcmlnaW4gKTtcclxuXHJcblx0fSxcclxuXHJcblx0ZGlzdGFuY2VUb1BvaW50OiBmdW5jdGlvbiAoIHBvaW50ICkge1xyXG5cclxuXHRcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMuZGlzdGFuY2VTcVRvUG9pbnQoIHBvaW50ICkgKTtcclxuXHJcblx0fSxcclxuXHJcblx0ZGlzdGFuY2VTcVRvUG9pbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIHBvaW50ICkge1xyXG5cclxuXHRcdFx0dmFyIGRpcmVjdGlvbkRpc3RhbmNlID0gdjEuc3ViVmVjdG9ycyggcG9pbnQsIHRoaXMub3JpZ2luICkuZG90KCB0aGlzLmRpcmVjdGlvbiApO1xyXG5cclxuXHRcdFx0Ly8gcG9pbnQgYmVoaW5kIHRoZSByYXlcclxuXHJcblx0XHRcdGlmICggZGlyZWN0aW9uRGlzdGFuY2UgPCAwICkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5vcmlnaW4uZGlzdGFuY2VUb1NxdWFyZWQoIHBvaW50ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2MS5jb3B5KCB0aGlzLmRpcmVjdGlvbiApLm11bHRpcGx5U2NhbGFyKCBkaXJlY3Rpb25EaXN0YW5jZSApLmFkZCggdGhpcy5vcmlnaW4gKTtcclxuXHJcblx0XHRcdHJldHVybiB2MS5kaXN0YW5jZVRvU3F1YXJlZCggcG9pbnQgKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGRpc3RhbmNlU3FUb1NlZ21lbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgc2VnQ2VudGVyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdHZhciBzZWdEaXIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0dmFyIGRpZmYgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIHYwLCB2MSwgb3B0aW9uYWxQb2ludE9uUmF5LCBvcHRpb25hbFBvaW50T25TZWdtZW50ICkge1xyXG5cclxuXHRcdFx0Ly8gZnJvbSBodHRwOi8vd3d3Lmdlb21ldHJpY3Rvb2xzLmNvbS9MaWJNYXRoZW1hdGljcy9EaXN0YW5jZS9XbTVEaXN0UmF5M1NlZ21lbnQzLmNwcFxyXG5cdFx0XHQvLyBJdCByZXR1cm5zIHRoZSBtaW4gZGlzdGFuY2UgYmV0d2VlbiB0aGUgcmF5IGFuZCB0aGUgc2VnbWVudFxyXG5cdFx0XHQvLyBkZWZpbmVkIGJ5IHYwIGFuZCB2MVxyXG5cdFx0XHQvLyBJdCBjYW4gYWxzbyBzZXQgdHdvIG9wdGlvbmFsIHRhcmdldHMgOlxyXG5cdFx0XHQvLyAtIFRoZSBjbG9zZXN0IHBvaW50IG9uIHRoZSByYXlcclxuXHRcdFx0Ly8gLSBUaGUgY2xvc2VzdCBwb2ludCBvbiB0aGUgc2VnbWVudFxyXG5cclxuXHRcdFx0c2VnQ2VudGVyLmNvcHkoIHYwICkuYWRkKCB2MSApLm11bHRpcGx5U2NhbGFyKCAwLjUgKTtcclxuXHRcdFx0c2VnRGlyLmNvcHkoIHYxICkuc3ViKCB2MCApLm5vcm1hbGl6ZSgpO1xyXG5cdFx0XHRkaWZmLmNvcHkoIHRoaXMub3JpZ2luICkuc3ViKCBzZWdDZW50ZXIgKTtcclxuXHJcblx0XHRcdHZhciBzZWdFeHRlbnQgPSB2MC5kaXN0YW5jZVRvKCB2MSApICogMC41O1xyXG5cdFx0XHR2YXIgYTAxID0gLSB0aGlzLmRpcmVjdGlvbi5kb3QoIHNlZ0RpciApO1xyXG5cdFx0XHR2YXIgYjAgPSBkaWZmLmRvdCggdGhpcy5kaXJlY3Rpb24gKTtcclxuXHRcdFx0dmFyIGIxID0gLSBkaWZmLmRvdCggc2VnRGlyICk7XHJcblx0XHRcdHZhciBjID0gZGlmZi5sZW5ndGhTcSgpO1xyXG5cdFx0XHR2YXIgZGV0ID0gTWF0aC5hYnMoIDEgLSBhMDEgKiBhMDEgKTtcclxuXHRcdFx0dmFyIHMwLCBzMSwgc3FyRGlzdCwgZXh0RGV0O1xyXG5cclxuXHRcdFx0aWYgKCBkZXQgPiAwICkge1xyXG5cclxuXHRcdFx0XHQvLyBUaGUgcmF5IGFuZCBzZWdtZW50IGFyZSBub3QgcGFyYWxsZWwuXHJcblxyXG5cdFx0XHRcdHMwID0gYTAxICogYjEgLSBiMDtcclxuXHRcdFx0XHRzMSA9IGEwMSAqIGIwIC0gYjE7XHJcblx0XHRcdFx0ZXh0RGV0ID0gc2VnRXh0ZW50ICogZGV0O1xyXG5cclxuXHRcdFx0XHRpZiAoIHMwID49IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBzMSA+PSAtIGV4dERldCApIHtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggczEgPD0gZXh0RGV0ICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHQvLyByZWdpb24gMFxyXG5cdFx0XHRcdFx0XHRcdC8vIE1pbmltdW0gYXQgaW50ZXJpb3IgcG9pbnRzIG9mIHJheSBhbmQgc2VnbWVudC5cclxuXHJcblx0XHRcdFx0XHRcdFx0dmFyIGludkRldCA9IDEgLyBkZXQ7XHJcblx0XHRcdFx0XHRcdFx0czAgKj0gaW52RGV0O1xyXG5cdFx0XHRcdFx0XHRcdHMxICo9IGludkRldDtcclxuXHRcdFx0XHRcdFx0XHRzcXJEaXN0ID0gczAgKiAoIHMwICsgYTAxICogczEgKyAyICogYjAgKSArIHMxICogKCBhMDEgKiBzMCArIHMxICsgMiAqIGIxICkgKyBjO1xyXG5cclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0Ly8gcmVnaW9uIDFcclxuXHJcblx0XHRcdFx0XHRcdFx0czEgPSBzZWdFeHRlbnQ7XHJcblx0XHRcdFx0XHRcdFx0czAgPSBNYXRoLm1heCggMCwgLSAoIGEwMSAqIHMxICsgYjAgKSApO1xyXG5cdFx0XHRcdFx0XHRcdHNxckRpc3QgPSAtIHMwICogczAgKyBzMSAqICggczEgKyAyICogYjEgKSArIGM7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdC8vIHJlZ2lvbiA1XHJcblxyXG5cdFx0XHRcdFx0XHRzMSA9IC0gc2VnRXh0ZW50O1xyXG5cdFx0XHRcdFx0XHRzMCA9IE1hdGgubWF4KCAwLCAtICggYTAxICogczEgKyBiMCApICk7XHJcblx0XHRcdFx0XHRcdHNxckRpc3QgPSAtIHMwICogczAgKyBzMSAqICggczEgKyAyICogYjEgKSArIGM7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdGlmICggczEgPD0gLSBleHREZXQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHQvLyByZWdpb24gNFxyXG5cclxuXHRcdFx0XHRcdFx0czAgPSBNYXRoLm1heCggMCwgLSAoIC0gYTAxICogc2VnRXh0ZW50ICsgYjAgKSApO1xyXG5cdFx0XHRcdFx0XHRzMSA9ICggczAgPiAwICkgPyAtIHNlZ0V4dGVudCA6IE1hdGgubWluKCBNYXRoLm1heCggLSBzZWdFeHRlbnQsIC0gYjEgKSwgc2VnRXh0ZW50ICk7XHJcblx0XHRcdFx0XHRcdHNxckRpc3QgPSAtIHMwICogczAgKyBzMSAqICggczEgKyAyICogYjEgKSArIGM7XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggczEgPD0gZXh0RGV0ICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Ly8gcmVnaW9uIDNcclxuXHJcblx0XHRcdFx0XHRcdHMwID0gMDtcclxuXHRcdFx0XHRcdFx0czEgPSBNYXRoLm1pbiggTWF0aC5tYXgoIC0gc2VnRXh0ZW50LCAtIGIxICksIHNlZ0V4dGVudCApO1xyXG5cdFx0XHRcdFx0XHRzcXJEaXN0ID0gczEgKiAoIHMxICsgMiAqIGIxICkgKyBjO1xyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHQvLyByZWdpb24gMlxyXG5cclxuXHRcdFx0XHRcdFx0czAgPSBNYXRoLm1heCggMCwgLSAoIGEwMSAqIHNlZ0V4dGVudCArIGIwICkgKTtcclxuXHRcdFx0XHRcdFx0czEgPSAoIHMwID4gMCApID8gc2VnRXh0ZW50IDogTWF0aC5taW4oIE1hdGgubWF4KCAtIHNlZ0V4dGVudCwgLSBiMSApLCBzZWdFeHRlbnQgKTtcclxuXHRcdFx0XHRcdFx0c3FyRGlzdCA9IC0gczAgKiBzMCArIHMxICogKCBzMSArIDIgKiBiMSApICsgYztcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdC8vIFJheSBhbmQgc2VnbWVudCBhcmUgcGFyYWxsZWwuXHJcblxyXG5cdFx0XHRcdHMxID0gKCBhMDEgPiAwICkgPyAtIHNlZ0V4dGVudCA6IHNlZ0V4dGVudDtcclxuXHRcdFx0XHRzMCA9IE1hdGgubWF4KCAwLCAtICggYTAxICogczEgKyBiMCApICk7XHJcblx0XHRcdFx0c3FyRGlzdCA9IC0gczAgKiBzMCArIHMxICogKCBzMSArIDIgKiBiMSApICsgYztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggb3B0aW9uYWxQb2ludE9uUmF5ICkge1xyXG5cclxuXHRcdFx0XHRvcHRpb25hbFBvaW50T25SYXkuY29weSggdGhpcy5kaXJlY3Rpb24gKS5tdWx0aXBseVNjYWxhciggczAgKS5hZGQoIHRoaXMub3JpZ2luICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIG9wdGlvbmFsUG9pbnRPblNlZ21lbnQgKSB7XHJcblxyXG5cdFx0XHRcdG9wdGlvbmFsUG9pbnRPblNlZ21lbnQuY29weSggc2VnRGlyICkubXVsdGlwbHlTY2FsYXIoIHMxICkuYWRkKCBzZWdDZW50ZXIgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBzcXJEaXN0O1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0aW50ZXJzZWN0U3BoZXJlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBzcGhlcmUsIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdFx0djEuc3ViVmVjdG9ycyggc3BoZXJlLmNlbnRlciwgdGhpcy5vcmlnaW4gKTtcclxuXHRcdFx0dmFyIHRjYSA9IHYxLmRvdCggdGhpcy5kaXJlY3Rpb24gKTtcclxuXHRcdFx0dmFyIGQyID0gdjEuZG90KCB2MSApIC0gdGNhICogdGNhO1xyXG5cdFx0XHR2YXIgcmFkaXVzMiA9IHNwaGVyZS5yYWRpdXMgKiBzcGhlcmUucmFkaXVzO1xyXG5cclxuXHRcdFx0aWYgKCBkMiA+IHJhZGl1czIgKSByZXR1cm4gbnVsbDtcclxuXHJcblx0XHRcdHZhciB0aGMgPSBNYXRoLnNxcnQoIHJhZGl1czIgLSBkMiApO1xyXG5cclxuXHRcdFx0Ly8gdDAgPSBmaXJzdCBpbnRlcnNlY3QgcG9pbnQgLSBlbnRyYW5jZSBvbiBmcm9udCBvZiBzcGhlcmVcclxuXHRcdFx0dmFyIHQwID0gdGNhIC0gdGhjO1xyXG5cclxuXHRcdFx0Ly8gdDEgPSBzZWNvbmQgaW50ZXJzZWN0IHBvaW50IC0gZXhpdCBwb2ludCBvbiBiYWNrIG9mIHNwaGVyZVxyXG5cdFx0XHR2YXIgdDEgPSB0Y2EgKyB0aGM7XHJcblxyXG5cdFx0XHQvLyB0ZXN0IHRvIHNlZSBpZiBib3RoIHQwIGFuZCB0MSBhcmUgYmVoaW5kIHRoZSByYXkgLSBpZiBzbywgcmV0dXJuIG51bGxcclxuXHRcdFx0aWYgKCB0MCA8IDAgJiYgdDEgPCAwICkgcmV0dXJuIG51bGw7XHJcblxyXG5cdFx0XHQvLyB0ZXN0IHRvIHNlZSBpZiB0MCBpcyBiZWhpbmQgdGhlIHJheTpcclxuXHRcdFx0Ly8gaWYgaXQgaXMsIHRoZSByYXkgaXMgaW5zaWRlIHRoZSBzcGhlcmUsIHNvIHJldHVybiB0aGUgc2Vjb25kIGV4aXQgcG9pbnQgc2NhbGVkIGJ5IHQxLFxyXG5cdFx0XHQvLyBpbiBvcmRlciB0byBhbHdheXMgcmV0dXJuIGFuIGludGVyc2VjdCBwb2ludCB0aGF0IGlzIGluIGZyb250IG9mIHRoZSByYXkuXHJcblx0XHRcdGlmICggdDAgPCAwICkgcmV0dXJuIHRoaXMuYXQoIHQxLCBvcHRpb25hbFRhcmdldCApO1xyXG5cclxuXHRcdFx0Ly8gZWxzZSB0MCBpcyBpbiBmcm9udCBvZiB0aGUgcmF5LCBzbyByZXR1cm4gdGhlIGZpcnN0IGNvbGxpc2lvbiBwb2ludCBzY2FsZWQgYnkgdDBcclxuXHRcdFx0cmV0dXJuIHRoaXMuYXQoIHQwLCBvcHRpb25hbFRhcmdldCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSgpLFxyXG5cclxuXHRpbnRlcnNlY3RzU3BoZXJlOiBmdW5jdGlvbiAoIHNwaGVyZSApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5kaXN0YW5jZVRvUG9pbnQoIHNwaGVyZS5jZW50ZXIgKSA8PSBzcGhlcmUucmFkaXVzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRkaXN0YW5jZVRvUGxhbmU6IGZ1bmN0aW9uICggcGxhbmUgKSB7XHJcblxyXG5cdFx0dmFyIGRlbm9taW5hdG9yID0gcGxhbmUubm9ybWFsLmRvdCggdGhpcy5kaXJlY3Rpb24gKTtcclxuXHJcblx0XHRpZiAoIGRlbm9taW5hdG9yID09PSAwICkge1xyXG5cclxuXHRcdFx0Ly8gbGluZSBpcyBjb3BsYW5hciwgcmV0dXJuIG9yaWdpblxyXG5cdFx0XHRpZiAoIHBsYW5lLmRpc3RhbmNlVG9Qb2ludCggdGhpcy5vcmlnaW4gKSA9PT0gMCApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIDA7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBOdWxsIGlzIHByZWZlcmFibGUgdG8gdW5kZWZpbmVkIHNpbmNlIHVuZGVmaW5lZCBtZWFucy4uLi4gaXQgaXMgdW5kZWZpbmVkXHJcblxyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHQgPSAtICggdGhpcy5vcmlnaW4uZG90KCBwbGFuZS5ub3JtYWwgKSArIHBsYW5lLmNvbnN0YW50ICkgLyBkZW5vbWluYXRvcjtcclxuXHJcblx0XHQvLyBSZXR1cm4gaWYgdGhlIHJheSBuZXZlciBpbnRlcnNlY3RzIHRoZSBwbGFuZVxyXG5cclxuXHRcdHJldHVybiB0ID49IDAgPyB0IDogIG51bGw7XHJcblxyXG5cdH0sXHJcblxyXG5cdGludGVyc2VjdFBsYW5lOiBmdW5jdGlvbiAoIHBsYW5lLCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHR2YXIgdCA9IHRoaXMuZGlzdGFuY2VUb1BsYW5lKCBwbGFuZSApO1xyXG5cclxuXHRcdGlmICggdCA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdHJldHVybiBudWxsO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5hdCggdCwgb3B0aW9uYWxUYXJnZXQgKTtcclxuXHJcblx0fSxcclxuXHJcblxyXG5cclxuXHRpbnRlcnNlY3RzUGxhbmU6IGZ1bmN0aW9uICggcGxhbmUgKSB7XHJcblxyXG5cdFx0Ly8gY2hlY2sgaWYgdGhlIHJheSBsaWVzIG9uIHRoZSBwbGFuZSBmaXJzdFxyXG5cclxuXHRcdHZhciBkaXN0VG9Qb2ludCA9IHBsYW5lLmRpc3RhbmNlVG9Qb2ludCggdGhpcy5vcmlnaW4gKTtcclxuXHJcblx0XHRpZiAoIGRpc3RUb1BvaW50ID09PSAwICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBkZW5vbWluYXRvciA9IHBsYW5lLm5vcm1hbC5kb3QoIHRoaXMuZGlyZWN0aW9uICk7XHJcblxyXG5cdFx0aWYgKCBkZW5vbWluYXRvciAqIGRpc3RUb1BvaW50IDwgMCApIHtcclxuXHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyByYXkgb3JpZ2luIGlzIGJlaGluZCB0aGUgcGxhbmUgKGFuZCBpcyBwb2ludGluZyBiZWhpbmQgaXQpXHJcblxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cclxuXHR9LFxyXG5cclxuXHRpbnRlcnNlY3RCb3g6IGZ1bmN0aW9uICggYm94LCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHR2YXIgdG1pbiwgdG1heCwgdHltaW4sIHR5bWF4LCB0em1pbiwgdHptYXg7XHJcblxyXG5cdFx0dmFyIGludmRpcnggPSAxIC8gdGhpcy5kaXJlY3Rpb24ueCxcclxuXHRcdFx0aW52ZGlyeSA9IDEgLyB0aGlzLmRpcmVjdGlvbi55LFxyXG5cdFx0XHRpbnZkaXJ6ID0gMSAvIHRoaXMuZGlyZWN0aW9uLno7XHJcblxyXG5cdFx0dmFyIG9yaWdpbiA9IHRoaXMub3JpZ2luO1xyXG5cclxuXHRcdGlmICggaW52ZGlyeCA+PSAwICkge1xyXG5cclxuXHRcdFx0dG1pbiA9ICggYm94Lm1pbi54IC0gb3JpZ2luLnggKSAqIGludmRpcng7XHJcblx0XHRcdHRtYXggPSAoIGJveC5tYXgueCAtIG9yaWdpbi54ICkgKiBpbnZkaXJ4O1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHR0bWluID0gKCBib3gubWF4LnggLSBvcmlnaW4ueCApICogaW52ZGlyeDtcclxuXHRcdFx0dG1heCA9ICggYm94Lm1pbi54IC0gb3JpZ2luLnggKSAqIGludmRpcng7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggaW52ZGlyeSA+PSAwICkge1xyXG5cclxuXHRcdFx0dHltaW4gPSAoIGJveC5taW4ueSAtIG9yaWdpbi55ICkgKiBpbnZkaXJ5O1xyXG5cdFx0XHR0eW1heCA9ICggYm94Lm1heC55IC0gb3JpZ2luLnkgKSAqIGludmRpcnk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHR5bWluID0gKCBib3gubWF4LnkgLSBvcmlnaW4ueSApICogaW52ZGlyeTtcclxuXHRcdFx0dHltYXggPSAoIGJveC5taW4ueSAtIG9yaWdpbi55ICkgKiBpbnZkaXJ5O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoICggdG1pbiA+IHR5bWF4ICkgfHwgKCB0eW1pbiA+IHRtYXggKSApIHJldHVybiBudWxsO1xyXG5cclxuXHRcdC8vIFRoZXNlIGxpbmVzIGFsc28gaGFuZGxlIHRoZSBjYXNlIHdoZXJlIHRtaW4gb3IgdG1heCBpcyBOYU5cclxuXHRcdC8vIChyZXN1bHQgb2YgMCAqIEluZmluaXR5KS4geCAhPT0geCByZXR1cm5zIHRydWUgaWYgeCBpcyBOYU5cclxuXHJcblx0XHRpZiAoIHR5bWluID4gdG1pbiB8fCB0bWluICE9PSB0bWluICkgdG1pbiA9IHR5bWluO1xyXG5cclxuXHRcdGlmICggdHltYXggPCB0bWF4IHx8IHRtYXggIT09IHRtYXggKSB0bWF4ID0gdHltYXg7XHJcblxyXG5cdFx0aWYgKCBpbnZkaXJ6ID49IDAgKSB7XHJcblxyXG5cdFx0XHR0em1pbiA9ICggYm94Lm1pbi56IC0gb3JpZ2luLnogKSAqIGludmRpcno7XHJcblx0XHRcdHR6bWF4ID0gKCBib3gubWF4LnogLSBvcmlnaW4ueiApICogaW52ZGlyejtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0dHptaW4gPSAoIGJveC5tYXgueiAtIG9yaWdpbi56ICkgKiBpbnZkaXJ6O1xyXG5cdFx0XHR0em1heCA9ICggYm94Lm1pbi56IC0gb3JpZ2luLnogKSAqIGludmRpcno7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggKCB0bWluID4gdHptYXggKSB8fCAoIHR6bWluID4gdG1heCApICkgcmV0dXJuIG51bGw7XHJcblxyXG5cdFx0aWYgKCB0em1pbiA+IHRtaW4gfHwgdG1pbiAhPT0gdG1pbiApIHRtaW4gPSB0em1pbjtcclxuXHJcblx0XHRpZiAoIHR6bWF4IDwgdG1heCB8fCB0bWF4ICE9PSB0bWF4ICkgdG1heCA9IHR6bWF4O1xyXG5cclxuXHRcdC8vcmV0dXJuIHBvaW50IGNsb3Nlc3QgdG8gdGhlIHJheSAocG9zaXRpdmUgc2lkZSlcclxuXHJcblx0XHRpZiAoIHRtYXggPCAwICkgcmV0dXJuIG51bGw7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuYXQoIHRtaW4gPj0gMCA/IHRtaW4gOiB0bWF4LCBvcHRpb25hbFRhcmdldCApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRpbnRlcnNlY3RzQm94OiAoIGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggYm94ICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuaW50ZXJzZWN0Qm94KCBib3gsIHYgKSAhPT0gbnVsbDtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9ICkoKSxcclxuXHJcblx0aW50ZXJzZWN0VHJpYW5nbGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHQvLyBDb21wdXRlIHRoZSBvZmZzZXQgb3JpZ2luLCBlZGdlcywgYW5kIG5vcm1hbC5cclxuXHRcdHZhciBkaWZmID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdHZhciBlZGdlMSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHR2YXIgZWRnZTIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0dmFyIG5vcm1hbCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggYSwgYiwgYywgYmFja2ZhY2VDdWxsaW5nLCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHRcdC8vIGZyb20gaHR0cDovL3d3dy5nZW9tZXRyaWN0b29scy5jb20vTGliTWF0aGVtYXRpY3MvSW50ZXJzZWN0aW9uL1dtNUludHJSYXkzVHJpYW5nbGUzLmNwcFxyXG5cclxuXHRcdFx0ZWRnZTEuc3ViVmVjdG9ycyggYiwgYSApO1xyXG5cdFx0XHRlZGdlMi5zdWJWZWN0b3JzKCBjLCBhICk7XHJcblx0XHRcdG5vcm1hbC5jcm9zc1ZlY3RvcnMoIGVkZ2UxLCBlZGdlMiApO1xyXG5cclxuXHRcdFx0Ly8gU29sdmUgUSArIHQqRCA9IGIxKkUxICsgYjIqRTIgKFEgPSBrRGlmZiwgRCA9IHJheSBkaXJlY3Rpb24sXHJcblx0XHRcdC8vIEUxID0ga0VkZ2UxLCBFMiA9IGtFZGdlMiwgTiA9IENyb3NzKEUxLEUyKSkgYnlcclxuXHRcdFx0Ly8gICB8RG90KEQsTil8KmIxID0gc2lnbihEb3QoRCxOKSkqRG90KEQsQ3Jvc3MoUSxFMikpXHJcblx0XHRcdC8vICAgfERvdChELE4pfCpiMiA9IHNpZ24oRG90KEQsTikpKkRvdChELENyb3NzKEUxLFEpKVxyXG5cdFx0XHQvLyAgIHxEb3QoRCxOKXwqdCA9IC1zaWduKERvdChELE4pKSpEb3QoUSxOKVxyXG5cdFx0XHR2YXIgRGROID0gdGhpcy5kaXJlY3Rpb24uZG90KCBub3JtYWwgKTtcclxuXHRcdFx0dmFyIHNpZ247XHJcblxyXG5cdFx0XHRpZiAoIERkTiA+IDAgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggYmFja2ZhY2VDdWxsaW5nICkgcmV0dXJuIG51bGw7XHJcblx0XHRcdFx0c2lnbiA9IDE7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBEZE4gPCAwICkge1xyXG5cclxuXHRcdFx0XHRzaWduID0gLSAxO1xyXG5cdFx0XHRcdERkTiA9IC0gRGROO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIG51bGw7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRkaWZmLnN1YlZlY3RvcnMoIHRoaXMub3JpZ2luLCBhICk7XHJcblx0XHRcdHZhciBEZFF4RTIgPSBzaWduICogdGhpcy5kaXJlY3Rpb24uZG90KCBlZGdlMi5jcm9zc1ZlY3RvcnMoIGRpZmYsIGVkZ2UyICkgKTtcclxuXHJcblx0XHRcdC8vIGIxIDwgMCwgbm8gaW50ZXJzZWN0aW9uXHJcblx0XHRcdGlmICggRGRReEUyIDwgMCApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIG51bGw7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgRGRFMXhRID0gc2lnbiAqIHRoaXMuZGlyZWN0aW9uLmRvdCggZWRnZTEuY3Jvc3MoIGRpZmYgKSApO1xyXG5cclxuXHRcdFx0Ly8gYjIgPCAwLCBubyBpbnRlcnNlY3Rpb25cclxuXHRcdFx0aWYgKCBEZEUxeFEgPCAwICkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIGIxK2IyID4gMSwgbm8gaW50ZXJzZWN0aW9uXHJcblx0XHRcdGlmICggRGRReEUyICsgRGRFMXhRID4gRGROICkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIExpbmUgaW50ZXJzZWN0cyB0cmlhbmdsZSwgY2hlY2sgaWYgcmF5IGRvZXMuXHJcblx0XHRcdHZhciBRZE4gPSAtIHNpZ24gKiBkaWZmLmRvdCggbm9ybWFsICk7XHJcblxyXG5cdFx0XHQvLyB0IDwgMCwgbm8gaW50ZXJzZWN0aW9uXHJcblx0XHRcdGlmICggUWROIDwgMCApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIG51bGw7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBSYXkgaW50ZXJzZWN0cyB0cmlhbmdsZS5cclxuXHRcdFx0cmV0dXJuIHRoaXMuYXQoIFFkTiAvIERkTiwgb3B0aW9uYWxUYXJnZXQgKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGFwcGx5TWF0cml4NDogZnVuY3Rpb24gKCBtYXRyaXg0ICkge1xyXG5cclxuXHRcdHRoaXMuZGlyZWN0aW9uLmFkZCggdGhpcy5vcmlnaW4gKS5hcHBseU1hdHJpeDQoIG1hdHJpeDQgKTtcclxuXHRcdHRoaXMub3JpZ2luLmFwcGx5TWF0cml4NCggbWF0cml4NCApO1xyXG5cdFx0dGhpcy5kaXJlY3Rpb24uc3ViKCB0aGlzLm9yaWdpbiApO1xyXG5cdFx0dGhpcy5kaXJlY3Rpb24ubm9ybWFsaXplKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGVxdWFsczogZnVuY3Rpb24gKCByYXkgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHJheS5vcmlnaW4uZXF1YWxzKCB0aGlzLm9yaWdpbiApICYmIHJheS5kaXJlY3Rpb24uZXF1YWxzKCB0aGlzLmRpcmVjdGlvbiApO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbWF0aC9TcGhlcmUuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuU3BoZXJlID0gZnVuY3Rpb24gKCBjZW50ZXIsIHJhZGl1cyApIHtcclxuXHJcblx0dGhpcy5jZW50ZXIgPSAoIGNlbnRlciAhPT0gdW5kZWZpbmVkICkgPyBjZW50ZXIgOiBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdHRoaXMucmFkaXVzID0gKCByYWRpdXMgIT09IHVuZGVmaW5lZCApID8gcmFkaXVzIDogMDtcclxuXHJcbn07XHJcblxyXG5USFJFRS5TcGhlcmUucHJvdG90eXBlID0ge1xyXG5cclxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuU3BoZXJlLFxyXG5cclxuXHRzZXQ6IGZ1bmN0aW9uICggY2VudGVyLCByYWRpdXMgKSB7XHJcblxyXG5cdFx0dGhpcy5jZW50ZXIuY29weSggY2VudGVyICk7XHJcblx0XHR0aGlzLnJhZGl1cyA9IHJhZGl1cztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0RnJvbVBvaW50czogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBib3ggPSBuZXcgVEhSRUUuQm94MygpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIHBvaW50cywgb3B0aW9uYWxDZW50ZXIgKSB7XHJcblxyXG5cdFx0XHR2YXIgY2VudGVyID0gdGhpcy5jZW50ZXI7XHJcblxyXG5cdFx0XHRpZiAoIG9wdGlvbmFsQ2VudGVyICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGNlbnRlci5jb3B5KCBvcHRpb25hbENlbnRlciApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Ym94LnNldEZyb21Qb2ludHMoIHBvaW50cyApLmNlbnRlciggY2VudGVyICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgbWF4UmFkaXVzU3EgPSAwO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0bWF4UmFkaXVzU3EgPSBNYXRoLm1heCggbWF4UmFkaXVzU3EsIGNlbnRlci5kaXN0YW5jZVRvU3F1YXJlZCggcG9pbnRzWyBpIF0gKSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5yYWRpdXMgPSBNYXRoLnNxcnQoIG1heFJhZGl1c1NxICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb3B5OiBmdW5jdGlvbiAoIHNwaGVyZSApIHtcclxuXHJcblx0XHR0aGlzLmNlbnRlci5jb3B5KCBzcGhlcmUuY2VudGVyICk7XHJcblx0XHR0aGlzLnJhZGl1cyA9IHNwaGVyZS5yYWRpdXM7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGVtcHR5OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuICggdGhpcy5yYWRpdXMgPD0gMCApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb250YWluc1BvaW50OiBmdW5jdGlvbiAoIHBvaW50ICkge1xyXG5cclxuXHRcdHJldHVybiAoIHBvaW50LmRpc3RhbmNlVG9TcXVhcmVkKCB0aGlzLmNlbnRlciApIDw9ICggdGhpcy5yYWRpdXMgKiB0aGlzLnJhZGl1cyApICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRpc3RhbmNlVG9Qb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcclxuXHJcblx0XHRyZXR1cm4gKCBwb2ludC5kaXN0YW5jZVRvKCB0aGlzLmNlbnRlciApIC0gdGhpcy5yYWRpdXMgKTtcclxuXHJcblx0fSxcclxuXHJcblx0aW50ZXJzZWN0c1NwaGVyZTogZnVuY3Rpb24gKCBzcGhlcmUgKSB7XHJcblxyXG5cdFx0dmFyIHJhZGl1c1N1bSA9IHRoaXMucmFkaXVzICsgc3BoZXJlLnJhZGl1cztcclxuXHJcblx0XHRyZXR1cm4gc3BoZXJlLmNlbnRlci5kaXN0YW5jZVRvU3F1YXJlZCggdGhpcy5jZW50ZXIgKSA8PSAoIHJhZGl1c1N1bSAqIHJhZGl1c1N1bSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRpbnRlcnNlY3RzQm94OiBmdW5jdGlvbiAoIGJveCApIHtcclxuXHJcblx0XHRyZXR1cm4gYm94LmludGVyc2VjdHNTcGhlcmUoIHRoaXMgKTtcclxuXHJcblx0fSxcclxuXHJcblx0aW50ZXJzZWN0c1BsYW5lOiBmdW5jdGlvbiAoIHBsYW5lICkge1xyXG5cclxuXHRcdC8vIFdlIHVzZSB0aGUgZm9sbG93aW5nIGVxdWF0aW9uIHRvIGNvbXB1dGUgdGhlIHNpZ25lZCBkaXN0YW5jZSBmcm9tXHJcblx0XHQvLyB0aGUgY2VudGVyIG9mIHRoZSBzcGhlcmUgdG8gdGhlIHBsYW5lLlxyXG5cdFx0Ly9cclxuXHRcdC8vIGRpc3RhbmNlID0gcSAqIG4gLSBkXHJcblx0XHQvL1xyXG5cdFx0Ly8gSWYgdGhpcyBkaXN0YW5jZSBpcyBncmVhdGVyIHRoYW4gdGhlIHJhZGl1cyBvZiB0aGUgc3BoZXJlLFxyXG5cdFx0Ly8gdGhlbiB0aGVyZSBpcyBubyBpbnRlcnNlY3Rpb24uXHJcblxyXG5cdFx0cmV0dXJuIE1hdGguYWJzKCB0aGlzLmNlbnRlci5kb3QoIHBsYW5lLm5vcm1hbCApIC0gcGxhbmUuY29uc3RhbnQgKSA8PSB0aGlzLnJhZGl1cztcclxuXHJcblx0fSxcclxuXHJcblx0Y2xhbXBQb2ludDogZnVuY3Rpb24gKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0dmFyIGRlbHRhTGVuZ3RoU3EgPSB0aGlzLmNlbnRlci5kaXN0YW5jZVRvU3F1YXJlZCggcG9pbnQgKTtcclxuXHJcblx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHRyZXN1bHQuY29weSggcG9pbnQgKTtcclxuXHJcblx0XHRpZiAoIGRlbHRhTGVuZ3RoU3EgPiAoIHRoaXMucmFkaXVzICogdGhpcy5yYWRpdXMgKSApIHtcclxuXHJcblx0XHRcdHJlc3VsdC5zdWIoIHRoaXMuY2VudGVyICkubm9ybWFsaXplKCk7XHJcblx0XHRcdHJlc3VsdC5tdWx0aXBseVNjYWxhciggdGhpcy5yYWRpdXMgKS5hZGQoIHRoaXMuY2VudGVyICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiByZXN1bHQ7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldEJvdW5kaW5nQm94OiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdHZhciBib3ggPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuQm94MygpO1xyXG5cclxuXHRcdGJveC5zZXQoIHRoaXMuY2VudGVyLCB0aGlzLmNlbnRlciApO1xyXG5cdFx0Ym94LmV4cGFuZEJ5U2NhbGFyKCB0aGlzLnJhZGl1cyApO1xyXG5cclxuXHRcdHJldHVybiBib3g7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFwcGx5TWF0cml4NDogZnVuY3Rpb24gKCBtYXRyaXggKSB7XHJcblxyXG5cdFx0dGhpcy5jZW50ZXIuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcclxuXHRcdHRoaXMucmFkaXVzID0gdGhpcy5yYWRpdXMgKiBtYXRyaXguZ2V0TWF4U2NhbGVPbkF4aXMoKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0dHJhbnNsYXRlOiBmdW5jdGlvbiAoIG9mZnNldCApIHtcclxuXHJcblx0XHR0aGlzLmNlbnRlci5hZGQoIG9mZnNldCApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRlcXVhbHM6IGZ1bmN0aW9uICggc3BoZXJlICkge1xyXG5cclxuXHRcdHJldHVybiBzcGhlcmUuY2VudGVyLmVxdWFscyggdGhpcy5jZW50ZXIgKSAmJiAoIHNwaGVyZS5yYWRpdXMgPT09IHRoaXMucmFkaXVzICk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9tYXRoL0ZydXN0dW0uanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXHJcbiAqL1xyXG5cclxuVEhSRUUuRnJ1c3R1bSA9IGZ1bmN0aW9uICggcDAsIHAxLCBwMiwgcDMsIHA0LCBwNSApIHtcclxuXHJcblx0dGhpcy5wbGFuZXMgPSBbXHJcblxyXG5cdFx0KCBwMCAhPT0gdW5kZWZpbmVkICkgPyBwMCA6IG5ldyBUSFJFRS5QbGFuZSgpLFxyXG5cdFx0KCBwMSAhPT0gdW5kZWZpbmVkICkgPyBwMSA6IG5ldyBUSFJFRS5QbGFuZSgpLFxyXG5cdFx0KCBwMiAhPT0gdW5kZWZpbmVkICkgPyBwMiA6IG5ldyBUSFJFRS5QbGFuZSgpLFxyXG5cdFx0KCBwMyAhPT0gdW5kZWZpbmVkICkgPyBwMyA6IG5ldyBUSFJFRS5QbGFuZSgpLFxyXG5cdFx0KCBwNCAhPT0gdW5kZWZpbmVkICkgPyBwNCA6IG5ldyBUSFJFRS5QbGFuZSgpLFxyXG5cdFx0KCBwNSAhPT0gdW5kZWZpbmVkICkgPyBwNSA6IG5ldyBUSFJFRS5QbGFuZSgpXHJcblxyXG5cdF07XHJcblxyXG59O1xyXG5cclxuVEhSRUUuRnJ1c3R1bS5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5GcnVzdHVtLFxyXG5cclxuXHRzZXQ6IGZ1bmN0aW9uICggcDAsIHAxLCBwMiwgcDMsIHA0LCBwNSApIHtcclxuXHJcblx0XHR2YXIgcGxhbmVzID0gdGhpcy5wbGFuZXM7XHJcblxyXG5cdFx0cGxhbmVzWyAwIF0uY29weSggcDAgKTtcclxuXHRcdHBsYW5lc1sgMSBdLmNvcHkoIHAxICk7XHJcblx0XHRwbGFuZXNbIDIgXS5jb3B5KCBwMiApO1xyXG5cdFx0cGxhbmVzWyAzIF0uY29weSggcDMgKTtcclxuXHRcdHBsYW5lc1sgNCBdLmNvcHkoIHA0ICk7XHJcblx0XHRwbGFuZXNbIDUgXS5jb3B5KCBwNSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y29weTogZnVuY3Rpb24gKCBmcnVzdHVtICkge1xyXG5cclxuXHRcdHZhciBwbGFuZXMgPSB0aGlzLnBsYW5lcztcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCA2OyBpICsrICkge1xyXG5cclxuXHRcdFx0cGxhbmVzWyBpIF0uY29weSggZnJ1c3R1bS5wbGFuZXNbIGkgXSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0RnJvbU1hdHJpeDogZnVuY3Rpb24gKCBtICkge1xyXG5cclxuXHRcdHZhciBwbGFuZXMgPSB0aGlzLnBsYW5lcztcclxuXHRcdHZhciBtZSA9IG0uZWxlbWVudHM7XHJcblx0XHR2YXIgbWUwID0gbWVbIDAgXSwgbWUxID0gbWVbIDEgXSwgbWUyID0gbWVbIDIgXSwgbWUzID0gbWVbIDMgXTtcclxuXHRcdHZhciBtZTQgPSBtZVsgNCBdLCBtZTUgPSBtZVsgNSBdLCBtZTYgPSBtZVsgNiBdLCBtZTcgPSBtZVsgNyBdO1xyXG5cdFx0dmFyIG1lOCA9IG1lWyA4IF0sIG1lOSA9IG1lWyA5IF0sIG1lMTAgPSBtZVsgMTAgXSwgbWUxMSA9IG1lWyAxMSBdO1xyXG5cdFx0dmFyIG1lMTIgPSBtZVsgMTIgXSwgbWUxMyA9IG1lWyAxMyBdLCBtZTE0ID0gbWVbIDE0IF0sIG1lMTUgPSBtZVsgMTUgXTtcclxuXHJcblx0XHRwbGFuZXNbIDAgXS5zZXRDb21wb25lbnRzKCBtZTMgLSBtZTAsIG1lNyAtIG1lNCwgbWUxMSAtIG1lOCwgbWUxNSAtIG1lMTIgKS5ub3JtYWxpemUoKTtcclxuXHRcdHBsYW5lc1sgMSBdLnNldENvbXBvbmVudHMoIG1lMyArIG1lMCwgbWU3ICsgbWU0LCBtZTExICsgbWU4LCBtZTE1ICsgbWUxMiApLm5vcm1hbGl6ZSgpO1xyXG5cdFx0cGxhbmVzWyAyIF0uc2V0Q29tcG9uZW50cyggbWUzICsgbWUxLCBtZTcgKyBtZTUsIG1lMTEgKyBtZTksIG1lMTUgKyBtZTEzICkubm9ybWFsaXplKCk7XHJcblx0XHRwbGFuZXNbIDMgXS5zZXRDb21wb25lbnRzKCBtZTMgLSBtZTEsIG1lNyAtIG1lNSwgbWUxMSAtIG1lOSwgbWUxNSAtIG1lMTMgKS5ub3JtYWxpemUoKTtcclxuXHRcdHBsYW5lc1sgNCBdLnNldENvbXBvbmVudHMoIG1lMyAtIG1lMiwgbWU3IC0gbWU2LCBtZTExIC0gbWUxMCwgbWUxNSAtIG1lMTQgKS5ub3JtYWxpemUoKTtcclxuXHRcdHBsYW5lc1sgNSBdLnNldENvbXBvbmVudHMoIG1lMyArIG1lMiwgbWU3ICsgbWU2LCBtZTExICsgbWUxMCwgbWUxNSArIG1lMTQgKS5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0aW50ZXJzZWN0c09iamVjdDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBzcGhlcmUgPSBuZXcgVEhSRUUuU3BoZXJlKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggb2JqZWN0ICkge1xyXG5cclxuXHRcdFx0dmFyIGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xyXG5cclxuXHRcdFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApIGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xyXG5cclxuXHRcdFx0c3BoZXJlLmNvcHkoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlICk7XHJcblx0XHRcdHNwaGVyZS5hcHBseU1hdHJpeDQoIG9iamVjdC5tYXRyaXhXb3JsZCApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuaW50ZXJzZWN0c1NwaGVyZSggc3BoZXJlICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRpbnRlcnNlY3RzU3BoZXJlOiBmdW5jdGlvbiAoIHNwaGVyZSApIHtcclxuXHJcblx0XHR2YXIgcGxhbmVzID0gdGhpcy5wbGFuZXM7XHJcblx0XHR2YXIgY2VudGVyID0gc3BoZXJlLmNlbnRlcjtcclxuXHRcdHZhciBuZWdSYWRpdXMgPSAtIHNwaGVyZS5yYWRpdXM7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgNjsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciBkaXN0YW5jZSA9IHBsYW5lc1sgaSBdLmRpc3RhbmNlVG9Qb2ludCggY2VudGVyICk7XHJcblxyXG5cdFx0XHRpZiAoIGRpc3RhbmNlIDwgbmVnUmFkaXVzICkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0cnVlO1xyXG5cclxuXHR9LFxyXG5cclxuXHRpbnRlcnNlY3RzQm94OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHAxID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHRcdFx0cDIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIGJveCApIHtcclxuXHJcblx0XHRcdHZhciBwbGFuZXMgPSB0aGlzLnBsYW5lcztcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IDYgOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgcGxhbmUgPSBwbGFuZXNbIGkgXTtcclxuXHJcblx0XHRcdFx0cDEueCA9IHBsYW5lLm5vcm1hbC54ID4gMCA/IGJveC5taW4ueCA6IGJveC5tYXgueDtcclxuXHRcdFx0XHRwMi54ID0gcGxhbmUubm9ybWFsLnggPiAwID8gYm94Lm1heC54IDogYm94Lm1pbi54O1xyXG5cdFx0XHRcdHAxLnkgPSBwbGFuZS5ub3JtYWwueSA+IDAgPyBib3gubWluLnkgOiBib3gubWF4Lnk7XHJcblx0XHRcdFx0cDIueSA9IHBsYW5lLm5vcm1hbC55ID4gMCA/IGJveC5tYXgueSA6IGJveC5taW4ueTtcclxuXHRcdFx0XHRwMS56ID0gcGxhbmUubm9ybWFsLnogPiAwID8gYm94Lm1pbi56IDogYm94Lm1heC56O1xyXG5cdFx0XHRcdHAyLnogPSBwbGFuZS5ub3JtYWwueiA+IDAgPyBib3gubWF4LnogOiBib3gubWluLno7XHJcblxyXG5cdFx0XHRcdHZhciBkMSA9IHBsYW5lLmRpc3RhbmNlVG9Qb2ludCggcDEgKTtcclxuXHRcdFx0XHR2YXIgZDIgPSBwbGFuZS5kaXN0YW5jZVRvUG9pbnQoIHAyICk7XHJcblxyXG5cdFx0XHRcdC8vIGlmIGJvdGggb3V0c2lkZSBwbGFuZSwgbm8gaW50ZXJzZWN0aW9uXHJcblxyXG5cdFx0XHRcdGlmICggZDEgPCAwICYmIGQyIDwgMCApIHtcclxuXHJcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblxyXG5cdGNvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XHJcblxyXG5cdFx0dmFyIHBsYW5lcyA9IHRoaXMucGxhbmVzO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IDY7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHBsYW5lc1sgaSBdLmRpc3RhbmNlVG9Qb2ludCggcG9pbnQgKSA8IDAgKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9tYXRoL1BsYW5lLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pb1xyXG4gKi9cclxuXHJcblRIUkVFLlBsYW5lID0gZnVuY3Rpb24gKCBub3JtYWwsIGNvbnN0YW50ICkge1xyXG5cclxuXHR0aGlzLm5vcm1hbCA9ICggbm9ybWFsICE9PSB1bmRlZmluZWQgKSA/IG5vcm1hbCA6IG5ldyBUSFJFRS5WZWN0b3IzKCAxLCAwLCAwICk7XHJcblx0dGhpcy5jb25zdGFudCA9ICggY29uc3RhbnQgIT09IHVuZGVmaW5lZCApID8gY29uc3RhbnQgOiAwO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlBsYW5lLnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLlBsYW5lLFxyXG5cclxuXHRzZXQ6IGZ1bmN0aW9uICggbm9ybWFsLCBjb25zdGFudCApIHtcclxuXHJcblx0XHR0aGlzLm5vcm1hbC5jb3B5KCBub3JtYWwgKTtcclxuXHRcdHRoaXMuY29uc3RhbnQgPSBjb25zdGFudDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0Q29tcG9uZW50czogZnVuY3Rpb24gKCB4LCB5LCB6LCB3ICkge1xyXG5cclxuXHRcdHRoaXMubm9ybWFsLnNldCggeCwgeSwgeiApO1xyXG5cdFx0dGhpcy5jb25zdGFudCA9IHc7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldEZyb21Ob3JtYWxBbmRDb3BsYW5hclBvaW50OiBmdW5jdGlvbiAoIG5vcm1hbCwgcG9pbnQgKSB7XHJcblxyXG5cdFx0dGhpcy5ub3JtYWwuY29weSggbm9ybWFsICk7XHJcblx0XHR0aGlzLmNvbnN0YW50ID0gLSBwb2ludC5kb3QoIHRoaXMubm9ybWFsICk7XHQvLyBtdXN0IGJlIHRoaXMubm9ybWFsLCBub3Qgbm9ybWFsLCBhcyB0aGlzLm5vcm1hbCBpcyBub3JtYWxpemVkXHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldEZyb21Db3BsYW5hclBvaW50czogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHR2YXIgdjIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIGEsIGIsIGMgKSB7XHJcblxyXG5cdFx0XHR2YXIgbm9ybWFsID0gdjEuc3ViVmVjdG9ycyggYywgYiApLmNyb3NzKCB2Mi5zdWJWZWN0b3JzKCBhLCBiICkgKS5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRcdC8vIFE6IHNob3VsZCBhbiBlcnJvciBiZSB0aHJvd24gaWYgbm9ybWFsIGlzIHplcm8gKGUuZy4gZGVnZW5lcmF0ZSBwbGFuZSk/XHJcblxyXG5cdFx0XHR0aGlzLnNldEZyb21Ob3JtYWxBbmRDb3BsYW5hclBvaW50KCBub3JtYWwsIGEgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvcHk6IGZ1bmN0aW9uICggcGxhbmUgKSB7XHJcblxyXG5cdFx0dGhpcy5ub3JtYWwuY29weSggcGxhbmUubm9ybWFsICk7XHJcblx0XHR0aGlzLmNvbnN0YW50ID0gcGxhbmUuY29uc3RhbnQ7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG5vcm1hbGl6ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdC8vIE5vdGU6IHdpbGwgbGVhZCB0byBhIGRpdmlkZSBieSB6ZXJvIGlmIHRoZSBwbGFuZSBpcyBpbnZhbGlkLlxyXG5cclxuXHRcdHZhciBpbnZlcnNlTm9ybWFsTGVuZ3RoID0gMS4wIC8gdGhpcy5ub3JtYWwubGVuZ3RoKCk7XHJcblx0XHR0aGlzLm5vcm1hbC5tdWx0aXBseVNjYWxhciggaW52ZXJzZU5vcm1hbExlbmd0aCApO1xyXG5cdFx0dGhpcy5jb25zdGFudCAqPSBpbnZlcnNlTm9ybWFsTGVuZ3RoO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRuZWdhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLmNvbnN0YW50ICo9IC0gMTtcclxuXHRcdHRoaXMubm9ybWFsLm5lZ2F0ZSgpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRkaXN0YW5jZVRvUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMubm9ybWFsLmRvdCggcG9pbnQgKSArIHRoaXMuY29uc3RhbnQ7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRpc3RhbmNlVG9TcGhlcmU6IGZ1bmN0aW9uICggc3BoZXJlICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmRpc3RhbmNlVG9Qb2ludCggc3BoZXJlLmNlbnRlciApIC0gc3BoZXJlLnJhZGl1cztcclxuXHJcblx0fSxcclxuXHJcblx0cHJvamVjdFBvaW50OiBmdW5jdGlvbiAoIHBvaW50LCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5vcnRob1BvaW50KCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKS5zdWIoIHBvaW50ICkubmVnYXRlKCk7XHJcblxyXG5cdH0sXHJcblxyXG5cdG9ydGhvUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdHZhciBwZXJwZW5kaWN1bGFyTWFnbml0dWRlID0gdGhpcy5kaXN0YW5jZVRvUG9pbnQoIHBvaW50ICk7XHJcblxyXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHRyZXR1cm4gcmVzdWx0LmNvcHkoIHRoaXMubm9ybWFsICkubXVsdGlwbHlTY2FsYXIoIHBlcnBlbmRpY3VsYXJNYWduaXR1ZGUgKTtcclxuXHJcblx0fSxcclxuXHJcblx0aW50ZXJzZWN0TGluZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggbGluZSwgb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHRcdHZhciBkaXJlY3Rpb24gPSBsaW5lLmRlbHRhKCB2MSApO1xyXG5cclxuXHRcdFx0dmFyIGRlbm9taW5hdG9yID0gdGhpcy5ub3JtYWwuZG90KCBkaXJlY3Rpb24gKTtcclxuXHJcblx0XHRcdGlmICggZGVub21pbmF0b3IgPT09IDAgKSB7XHJcblxyXG5cdFx0XHRcdC8vIGxpbmUgaXMgY29wbGFuYXIsIHJldHVybiBvcmlnaW5cclxuXHRcdFx0XHRpZiAoIHRoaXMuZGlzdGFuY2VUb1BvaW50KCBsaW5lLnN0YXJ0ICkgPT09IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdC5jb3B5KCBsaW5lLnN0YXJ0ICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gVW5zdXJlIGlmIHRoaXMgaXMgdGhlIGNvcnJlY3QgbWV0aG9kIHRvIGhhbmRsZSB0aGlzIGNhc2UuXHJcblx0XHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciB0ID0gLSAoIGxpbmUuc3RhcnQuZG90KCB0aGlzLm5vcm1hbCApICsgdGhpcy5jb25zdGFudCApIC8gZGVub21pbmF0b3I7XHJcblxyXG5cdFx0XHRpZiAoIHQgPCAwIHx8IHQgPiAxICkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHJlc3VsdC5jb3B5KCBkaXJlY3Rpb24gKS5tdWx0aXBseVNjYWxhciggdCApLmFkZCggbGluZS5zdGFydCApO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0aW50ZXJzZWN0c0xpbmU6IGZ1bmN0aW9uICggbGluZSApIHtcclxuXHJcblx0XHQvLyBOb3RlOiB0aGlzIHRlc3RzIGlmIGEgbGluZSBpbnRlcnNlY3RzIHRoZSBwbGFuZSwgbm90IHdoZXRoZXIgaXQgKG9yIGl0cyBlbmQtcG9pbnRzKSBhcmUgY29wbGFuYXIgd2l0aCBpdC5cclxuXHJcblx0XHR2YXIgc3RhcnRTaWduID0gdGhpcy5kaXN0YW5jZVRvUG9pbnQoIGxpbmUuc3RhcnQgKTtcclxuXHRcdHZhciBlbmRTaWduID0gdGhpcy5kaXN0YW5jZVRvUG9pbnQoIGxpbmUuZW5kICk7XHJcblxyXG5cdFx0cmV0dXJuICggc3RhcnRTaWduIDwgMCAmJiBlbmRTaWduID4gMCApIHx8ICggZW5kU2lnbiA8IDAgJiYgc3RhcnRTaWduID4gMCApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRpbnRlcnNlY3RzQm94OiBmdW5jdGlvbiAoIGJveCApIHtcclxuXHJcblx0XHRyZXR1cm4gYm94LmludGVyc2VjdHNQbGFuZSggdGhpcyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRpbnRlcnNlY3RzU3BoZXJlOiBmdW5jdGlvbiAoIHNwaGVyZSApIHtcclxuXHJcblx0XHRyZXR1cm4gc3BoZXJlLmludGVyc2VjdHNQbGFuZSggdGhpcyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb3BsYW5hclBvaW50OiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0cmV0dXJuIHJlc3VsdC5jb3B5KCB0aGlzLm5vcm1hbCApLm11bHRpcGx5U2NhbGFyKCAtIHRoaXMuY29uc3RhbnQgKTtcclxuXHJcblx0fSxcclxuXHJcblx0YXBwbHlNYXRyaXg0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdHZhciB2MiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHR2YXIgbTEgPSBuZXcgVEhSRUUuTWF0cml4MygpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIG1hdHJpeCwgb3B0aW9uYWxOb3JtYWxNYXRyaXggKSB7XHJcblxyXG5cdFx0XHQvLyBjb21wdXRlIG5ldyBub3JtYWwgYmFzZWQgb24gdGhlb3J5IGhlcmU6XHJcblx0XHRcdC8vIGh0dHA6Ly93d3cuc29uZ2hvLmNhL29wZW5nbC9nbF9ub3JtYWx0cmFuc2Zvcm0uaHRtbFxyXG5cdFx0XHR2YXIgbm9ybWFsTWF0cml4ID0gb3B0aW9uYWxOb3JtYWxNYXRyaXggfHwgbTEuZ2V0Tm9ybWFsTWF0cml4KCBtYXRyaXggKTtcclxuXHRcdFx0dmFyIG5ld05vcm1hbCA9IHYxLmNvcHkoIHRoaXMubm9ybWFsICkuYXBwbHlNYXRyaXgzKCBub3JtYWxNYXRyaXggKTtcclxuXHJcblx0XHRcdHZhciBuZXdDb3BsYW5hclBvaW50ID0gdGhpcy5jb3BsYW5hclBvaW50KCB2MiApO1xyXG5cdFx0XHRuZXdDb3BsYW5hclBvaW50LmFwcGx5TWF0cml4NCggbWF0cml4ICk7XHJcblxyXG5cdFx0XHR0aGlzLnNldEZyb21Ob3JtYWxBbmRDb3BsYW5hclBvaW50KCBuZXdOb3JtYWwsIG5ld0NvcGxhbmFyUG9pbnQgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0dHJhbnNsYXRlOiBmdW5jdGlvbiAoIG9mZnNldCApIHtcclxuXHJcblx0XHR0aGlzLmNvbnN0YW50ID0gdGhpcy5jb25zdGFudCAtIG9mZnNldC5kb3QoIHRoaXMubm9ybWFsICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGVxdWFsczogZnVuY3Rpb24gKCBwbGFuZSApIHtcclxuXHJcblx0XHRyZXR1cm4gcGxhbmUubm9ybWFsLmVxdWFscyggdGhpcy5ub3JtYWwgKSAmJiAoIHBsYW5lLmNvbnN0YW50ID09PSB0aGlzLmNvbnN0YW50ICk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9tYXRoL01hdGguanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLk1hdGggPSB7XHJcblxyXG5cdGdlbmVyYXRlVVVJRDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdC8vIGh0dHA6Ly93d3cuYnJvb2ZhLmNvbS9Ub29scy9NYXRoLnV1aWQuaHRtXHJcblxyXG5cdFx0dmFyIGNoYXJzID0gJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6Jy5zcGxpdCggJycgKTtcclxuXHRcdHZhciB1dWlkID0gbmV3IEFycmF5KCAzNiApO1xyXG5cdFx0dmFyIHJuZCA9IDAsIHI7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IDM2OyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIGkgPT09IDggfHwgaSA9PT0gMTMgfHwgaSA9PT0gMTggfHwgaSA9PT0gMjMgKSB7XHJcblxyXG5cdFx0XHRcdFx0dXVpZFsgaSBdID0gJy0nO1xyXG5cclxuXHRcdFx0XHR9IGVsc2UgaWYgKCBpID09PSAxNCApIHtcclxuXHJcblx0XHRcdFx0XHR1dWlkWyBpIF0gPSAnNCc7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBybmQgPD0gMHgwMiApIHJuZCA9IDB4MjAwMDAwMCArICggTWF0aC5yYW5kb20oKSAqIDB4MTAwMDAwMCApIHwgMDtcclxuXHRcdFx0XHRcdHIgPSBybmQgJiAweGY7XHJcblx0XHRcdFx0XHRybmQgPSBybmQgPj4gNDtcclxuXHRcdFx0XHRcdHV1aWRbIGkgXSA9IGNoYXJzWyAoIGkgPT09IDE5ICkgPyAoIHIgJiAweDMgKSB8IDB4OCA6IHIgXTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHV1aWQuam9pbiggJycgKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGNsYW1wOiBmdW5jdGlvbiAoIHZhbHVlLCBtaW4sIG1heCApIHtcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5tYXgoIG1pbiwgTWF0aC5taW4oIG1heCwgdmFsdWUgKSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHQvLyBjb21wdXRlIGV1Y2xpZGlhbiBtb2R1bG8gb2YgbSAlIG5cclxuXHQvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Nb2R1bG9fb3BlcmF0aW9uXHJcblxyXG5cdGV1Y2xpZGVhbk1vZHVsbzogZnVuY3Rpb24gKCBuLCBtICkge1xyXG5cclxuXHRcdHJldHVybiAoICggbiAlIG0gKSArIG0gKSAlIG07XHJcblxyXG5cdH0sXHJcblxyXG5cdC8vIExpbmVhciBtYXBwaW5nIGZyb20gcmFuZ2UgPGExLCBhMj4gdG8gcmFuZ2UgPGIxLCBiMj5cclxuXHJcblx0bWFwTGluZWFyOiBmdW5jdGlvbiAoIHgsIGExLCBhMiwgYjEsIGIyICkge1xyXG5cclxuXHRcdHJldHVybiBiMSArICggeCAtIGExICkgKiAoIGIyIC0gYjEgKSAvICggYTIgLSBhMSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHQvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1Ntb290aHN0ZXBcclxuXHJcblx0c21vb3Roc3RlcDogZnVuY3Rpb24gKCB4LCBtaW4sIG1heCApIHtcclxuXHJcblx0XHRpZiAoIHggPD0gbWluICkgcmV0dXJuIDA7XHJcblx0XHRpZiAoIHggPj0gbWF4ICkgcmV0dXJuIDE7XHJcblxyXG5cdFx0eCA9ICggeCAtIG1pbiApIC8gKCBtYXggLSBtaW4gKTtcclxuXHJcblx0XHRyZXR1cm4geCAqIHggKiAoIDMgLSAyICogeCApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzbW9vdGhlcnN0ZXA6IGZ1bmN0aW9uICggeCwgbWluLCBtYXggKSB7XHJcblxyXG5cdFx0aWYgKCB4IDw9IG1pbiApIHJldHVybiAwO1xyXG5cdFx0aWYgKCB4ID49IG1heCApIHJldHVybiAxO1xyXG5cclxuXHRcdHggPSAoIHggLSBtaW4gKSAvICggbWF4IC0gbWluICk7XHJcblxyXG5cdFx0cmV0dXJuIHggKiB4ICogeCAqICggeCAqICggeCAqIDYgLSAxNSApICsgMTAgKTtcclxuXHJcblx0fSxcclxuXHJcblx0cmFuZG9tMTY6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRoLnJhbmRvbTE2KCkgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIE1hdGgucmFuZG9tKCkgaW5zdGVhZC4nICk7XHJcblx0XHRyZXR1cm4gTWF0aC5yYW5kb20oKTtcclxuXHJcblx0fSxcclxuXHJcblx0Ly8gUmFuZG9tIGludGVnZXIgZnJvbSA8bG93LCBoaWdoPiBpbnRlcnZhbFxyXG5cclxuXHRyYW5kSW50OiBmdW5jdGlvbiAoIGxvdywgaGlnaCApIHtcclxuXHJcblx0XHRyZXR1cm4gbG93ICsgTWF0aC5mbG9vciggTWF0aC5yYW5kb20oKSAqICggaGlnaCAtIGxvdyArIDEgKSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHQvLyBSYW5kb20gZmxvYXQgZnJvbSA8bG93LCBoaWdoPiBpbnRlcnZhbFxyXG5cclxuXHRyYW5kRmxvYXQ6IGZ1bmN0aW9uICggbG93LCBoaWdoICkge1xyXG5cclxuXHRcdHJldHVybiBsb3cgKyBNYXRoLnJhbmRvbSgpICogKCBoaWdoIC0gbG93ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdC8vIFJhbmRvbSBmbG9hdCBmcm9tIDwtcmFuZ2UvMiwgcmFuZ2UvMj4gaW50ZXJ2YWxcclxuXHJcblx0cmFuZEZsb2F0U3ByZWFkOiBmdW5jdGlvbiAoIHJhbmdlICkge1xyXG5cclxuXHRcdHJldHVybiByYW5nZSAqICggMC41IC0gTWF0aC5yYW5kb20oKSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRkZWdUb1JhZDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBkZWdyZWVUb1JhZGlhbnNGYWN0b3IgPSBNYXRoLlBJIC8gMTgwO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIGRlZ3JlZXMgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gZGVncmVlcyAqIGRlZ3JlZVRvUmFkaWFuc0ZhY3RvcjtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdHJhZFRvRGVnOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHJhZGlhblRvRGVncmVlc0ZhY3RvciA9IDE4MCAvIE1hdGguUEk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggcmFkaWFucyApIHtcclxuXHJcblx0XHRcdHJldHVybiByYWRpYW5zICogcmFkaWFuVG9EZWdyZWVzRmFjdG9yO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0aXNQb3dlck9mVHdvOiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdHJldHVybiAoIHZhbHVlICYgKCB2YWx1ZSAtIDEgKSApID09PSAwICYmIHZhbHVlICE9PSAwO1xyXG5cclxuXHR9LFxyXG5cclxuXHRuZWFyZXN0UG93ZXJPZlR3bzogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5wb3coIDIsIE1hdGgucm91bmQoIE1hdGgubG9nKCB2YWx1ZSApIC8gTWF0aC5MTjIgKSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRuZXh0UG93ZXJPZlR3bzogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0XHR2YWx1ZSAtLTtcclxuXHRcdHZhbHVlIHw9IHZhbHVlID4+IDE7XHJcblx0XHR2YWx1ZSB8PSB2YWx1ZSA+PiAyO1xyXG5cdFx0dmFsdWUgfD0gdmFsdWUgPj4gNDtcclxuXHRcdHZhbHVlIHw9IHZhbHVlID4+IDg7XHJcblx0XHR2YWx1ZSB8PSB2YWx1ZSA+PiAxNjtcclxuXHRcdHZhbHVlICsrO1xyXG5cclxuXHRcdHJldHVybiB2YWx1ZTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL21hdGgvU3BsaW5lLmpzXHJcblxyXG4vKipcclxuICogU3BsaW5lIGZyb20gVHdlZW4uanMsIHNsaWdodGx5IG9wdGltaXplZCAoYW5kIHRyYXNoZWQpXHJcbiAqIGh0dHA6Ly9zb2xlLmdpdGh1Yi5jb20vdHdlZW4uanMvZXhhbXBsZXMvMDVfc3BsaW5lLmh0bWxcclxuICpcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5TcGxpbmUgPSBmdW5jdGlvbiAoIHBvaW50cyApIHtcclxuXHJcblx0dGhpcy5wb2ludHMgPSBwb2ludHM7XHJcblxyXG5cdHZhciBjID0gW10sIHYzID0geyB4OiAwLCB5OiAwLCB6OiAwIH0sXHJcblx0cG9pbnQsIGludFBvaW50LCB3ZWlnaHQsIHcyLCB3MyxcclxuXHRwYSwgcGIsIHBjLCBwZDtcclxuXHJcblx0dGhpcy5pbml0RnJvbUFycmF5ID0gZnVuY3Rpb24gKCBhICkge1xyXG5cclxuXHRcdHRoaXMucG9pbnRzID0gW107XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnBvaW50c1sgaSBdID0geyB4OiBhWyBpIF1bIDAgXSwgeTogYVsgaSBdWyAxIF0sIHo6IGFbIGkgXVsgMiBdIH07XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLmdldFBvaW50ID0gZnVuY3Rpb24gKCBrICkge1xyXG5cclxuXHRcdHBvaW50ID0gKCB0aGlzLnBvaW50cy5sZW5ndGggLSAxICkgKiBrO1xyXG5cdFx0aW50UG9pbnQgPSBNYXRoLmZsb29yKCBwb2ludCApO1xyXG5cdFx0d2VpZ2h0ID0gcG9pbnQgLSBpbnRQb2ludDtcclxuXHJcblx0XHRjWyAwIF0gPSBpbnRQb2ludCA9PT0gMCA/IGludFBvaW50IDogaW50UG9pbnQgLSAxO1xyXG5cdFx0Y1sgMSBdID0gaW50UG9pbnQ7XHJcblx0XHRjWyAyIF0gPSBpbnRQb2ludCAgPiB0aGlzLnBvaW50cy5sZW5ndGggLSAyID8gdGhpcy5wb2ludHMubGVuZ3RoIC0gMSA6IGludFBvaW50ICsgMTtcclxuXHRcdGNbIDMgXSA9IGludFBvaW50ICA+IHRoaXMucG9pbnRzLmxlbmd0aCAtIDMgPyB0aGlzLnBvaW50cy5sZW5ndGggLSAxIDogaW50UG9pbnQgKyAyO1xyXG5cclxuXHRcdHBhID0gdGhpcy5wb2ludHNbIGNbIDAgXSBdO1xyXG5cdFx0cGIgPSB0aGlzLnBvaW50c1sgY1sgMSBdIF07XHJcblx0XHRwYyA9IHRoaXMucG9pbnRzWyBjWyAyIF0gXTtcclxuXHRcdHBkID0gdGhpcy5wb2ludHNbIGNbIDMgXSBdO1xyXG5cclxuXHRcdHcyID0gd2VpZ2h0ICogd2VpZ2h0O1xyXG5cdFx0dzMgPSB3ZWlnaHQgKiB3MjtcclxuXHJcblx0XHR2My54ID0gaW50ZXJwb2xhdGUoIHBhLngsIHBiLngsIHBjLngsIHBkLngsIHdlaWdodCwgdzIsIHczICk7XHJcblx0XHR2My55ID0gaW50ZXJwb2xhdGUoIHBhLnksIHBiLnksIHBjLnksIHBkLnksIHdlaWdodCwgdzIsIHczICk7XHJcblx0XHR2My56ID0gaW50ZXJwb2xhdGUoIHBhLnosIHBiLnosIHBjLnosIHBkLnosIHdlaWdodCwgdzIsIHczICk7XHJcblxyXG5cdFx0cmV0dXJuIHYzO1xyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLmdldENvbnRyb2xQb2ludHNBcnJheSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgaSwgcCwgbCA9IHRoaXMucG9pbnRzLmxlbmd0aCxcclxuXHRcdFx0Y29vcmRzID0gW107XHJcblxyXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0cCA9IHRoaXMucG9pbnRzWyBpIF07XHJcblx0XHRcdGNvb3Jkc1sgaSBdID0gWyBwLngsIHAueSwgcC56IF07XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBjb29yZHM7XHJcblxyXG5cdH07XHJcblxyXG5cdC8vIGFwcHJveGltYXRlIGxlbmd0aCBieSBzdW1taW5nIGxpbmVhciBzZWdtZW50c1xyXG5cclxuXHR0aGlzLmdldExlbmd0aCA9IGZ1bmN0aW9uICggblN1YkRpdmlzaW9ucyApIHtcclxuXHJcblx0XHR2YXIgaSwgaW5kZXgsIG5TYW1wbGVzLCBwb3NpdGlvbixcclxuXHRcdFx0cG9pbnQgPSAwLCBpbnRQb2ludCA9IDAsIG9sZEludFBvaW50ID0gMCxcclxuXHRcdFx0b2xkUG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG5cdFx0XHR0bXBWZWMgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG5cdFx0XHRjaHVua0xlbmd0aHMgPSBbXSxcclxuXHRcdFx0dG90YWxMZW5ndGggPSAwO1xyXG5cclxuXHRcdC8vIGZpcnN0IHBvaW50IGhhcyAwIGxlbmd0aFxyXG5cclxuXHRcdGNodW5rTGVuZ3Roc1sgMCBdID0gMDtcclxuXHJcblx0XHRpZiAoICEgblN1YkRpdmlzaW9ucyApIG5TdWJEaXZpc2lvbnMgPSAxMDA7XHJcblxyXG5cdFx0blNhbXBsZXMgPSB0aGlzLnBvaW50cy5sZW5ndGggKiBuU3ViRGl2aXNpb25zO1xyXG5cclxuXHRcdG9sZFBvc2l0aW9uLmNvcHkoIHRoaXMucG9pbnRzWyAwIF0gKTtcclxuXHJcblx0XHRmb3IgKCBpID0gMTsgaSA8IG5TYW1wbGVzOyBpICsrICkge1xyXG5cclxuXHRcdFx0aW5kZXggPSBpIC8gblNhbXBsZXM7XHJcblxyXG5cdFx0XHRwb3NpdGlvbiA9IHRoaXMuZ2V0UG9pbnQoIGluZGV4ICk7XHJcblx0XHRcdHRtcFZlYy5jb3B5KCBwb3NpdGlvbiApO1xyXG5cclxuXHRcdFx0dG90YWxMZW5ndGggKz0gdG1wVmVjLmRpc3RhbmNlVG8oIG9sZFBvc2l0aW9uICk7XHJcblxyXG5cdFx0XHRvbGRQb3NpdGlvbi5jb3B5KCBwb3NpdGlvbiApO1xyXG5cclxuXHRcdFx0cG9pbnQgPSAoIHRoaXMucG9pbnRzLmxlbmd0aCAtIDEgKSAqIGluZGV4O1xyXG5cdFx0XHRpbnRQb2ludCA9IE1hdGguZmxvb3IoIHBvaW50ICk7XHJcblxyXG5cdFx0XHRpZiAoIGludFBvaW50ICE9PSBvbGRJbnRQb2ludCApIHtcclxuXHJcblx0XHRcdFx0Y2h1bmtMZW5ndGhzWyBpbnRQb2ludCBdID0gdG90YWxMZW5ndGg7XHJcblx0XHRcdFx0b2xkSW50UG9pbnQgPSBpbnRQb2ludDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gbGFzdCBwb2ludCBlbmRzIHdpdGggdG90YWwgbGVuZ3RoXHJcblxyXG5cdFx0Y2h1bmtMZW5ndGhzWyBjaHVua0xlbmd0aHMubGVuZ3RoIF0gPSB0b3RhbExlbmd0aDtcclxuXHJcblx0XHRyZXR1cm4geyBjaHVua3M6IGNodW5rTGVuZ3RocywgdG90YWw6IHRvdGFsTGVuZ3RoIH07XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMucmVwYXJhbWV0cml6ZUJ5QXJjTGVuZ3RoID0gZnVuY3Rpb24gKCBzYW1wbGluZ0NvZWYgKSB7XHJcblxyXG5cdFx0dmFyIGksIGosXHJcblx0XHRcdGluZGV4LCBpbmRleEN1cnJlbnQsIGluZGV4TmV4dCxcclxuXHRcdFx0cmVhbERpc3RhbmNlLFxyXG5cdFx0XHRzYW1wbGluZywgcG9zaXRpb24sXHJcblx0XHRcdG5ld3BvaW50cyA9IFtdLFxyXG5cdFx0XHR0bXBWZWMgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG5cdFx0XHRzbCA9IHRoaXMuZ2V0TGVuZ3RoKCk7XHJcblxyXG5cdFx0bmV3cG9pbnRzLnB1c2goIHRtcFZlYy5jb3B5KCB0aGlzLnBvaW50c1sgMCBdICkuY2xvbmUoKSApO1xyXG5cclxuXHRcdGZvciAoIGkgPSAxOyBpIDwgdGhpcy5wb2ludHMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0Ly90bXBWZWMuY29weSggdGhpcy5wb2ludHNbIGkgLSAxIF0gKTtcclxuXHRcdFx0Ly9saW5lYXJEaXN0YW5jZSA9IHRtcFZlYy5kaXN0YW5jZVRvKCB0aGlzLnBvaW50c1sgaSBdICk7XHJcblxyXG5cdFx0XHRyZWFsRGlzdGFuY2UgPSBzbC5jaHVua3NbIGkgXSAtIHNsLmNodW5rc1sgaSAtIDEgXTtcclxuXHJcblx0XHRcdHNhbXBsaW5nID0gTWF0aC5jZWlsKCBzYW1wbGluZ0NvZWYgKiByZWFsRGlzdGFuY2UgLyBzbC50b3RhbCApO1xyXG5cclxuXHRcdFx0aW5kZXhDdXJyZW50ID0gKCBpIC0gMSApIC8gKCB0aGlzLnBvaW50cy5sZW5ndGggLSAxICk7XHJcblx0XHRcdGluZGV4TmV4dCA9IGkgLyAoIHRoaXMucG9pbnRzLmxlbmd0aCAtIDEgKTtcclxuXHJcblx0XHRcdGZvciAoIGogPSAxOyBqIDwgc2FtcGxpbmcgLSAxOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHRpbmRleCA9IGluZGV4Q3VycmVudCArIGogKiAoIDEgLyBzYW1wbGluZyApICogKCBpbmRleE5leHQgLSBpbmRleEN1cnJlbnQgKTtcclxuXHJcblx0XHRcdFx0cG9zaXRpb24gPSB0aGlzLmdldFBvaW50KCBpbmRleCApO1xyXG5cdFx0XHRcdG5ld3BvaW50cy5wdXNoKCB0bXBWZWMuY29weSggcG9zaXRpb24gKS5jbG9uZSgpICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRuZXdwb2ludHMucHVzaCggdG1wVmVjLmNvcHkoIHRoaXMucG9pbnRzWyBpIF0gKS5jbG9uZSgpICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMucG9pbnRzID0gbmV3cG9pbnRzO1xyXG5cclxuXHR9O1xyXG5cclxuXHQvLyBDYXRtdWxsLVJvbVxyXG5cclxuXHRmdW5jdGlvbiBpbnRlcnBvbGF0ZSggcDAsIHAxLCBwMiwgcDMsIHQsIHQyLCB0MyApIHtcclxuXHJcblx0XHR2YXIgdjAgPSAoIHAyIC0gcDAgKSAqIDAuNSxcclxuXHRcdFx0djEgPSAoIHAzIC0gcDEgKSAqIDAuNTtcclxuXHJcblx0XHRyZXR1cm4gKCAyICogKCBwMSAtIHAyICkgKyB2MCArIHYxICkgKiB0MyArICggLSAzICogKCBwMSAtIHAyICkgLSAyICogdjAgLSB2MSApICogdDIgKyB2MCAqIHQgKyBwMTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL21hdGgvVHJpYW5nbGUuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuVHJpYW5nbGUgPSBmdW5jdGlvbiAoIGEsIGIsIGMgKSB7XHJcblxyXG5cdHRoaXMuYSA9ICggYSAhPT0gdW5kZWZpbmVkICkgPyBhIDogbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHR0aGlzLmIgPSAoIGIgIT09IHVuZGVmaW5lZCApID8gYiA6IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0dGhpcy5jID0gKCBjICE9PSB1bmRlZmluZWQgKSA/IGMgOiBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlRyaWFuZ2xlLm5vcm1hbCA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dmFyIHYwID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uICggYSwgYiwgYywgb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0cmVzdWx0LnN1YlZlY3RvcnMoIGMsIGIgKTtcclxuXHRcdHYwLnN1YlZlY3RvcnMoIGEsIGIgKTtcclxuXHRcdHJlc3VsdC5jcm9zcyggdjAgKTtcclxuXHJcblx0XHR2YXIgcmVzdWx0TGVuZ3RoU3EgPSByZXN1bHQubGVuZ3RoU3EoKTtcclxuXHRcdGlmICggcmVzdWx0TGVuZ3RoU3EgPiAwICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHJlc3VsdC5tdWx0aXBseVNjYWxhciggMSAvIE1hdGguc3FydCggcmVzdWx0TGVuZ3RoU3EgKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcmVzdWx0LnNldCggMCwgMCwgMCApO1xyXG5cclxuXHR9O1xyXG5cclxufSgpO1xyXG5cclxuLy8gc3RhdGljL2luc3RhbmNlIG1ldGhvZCB0byBjYWxjdWxhdGUgYmFyeWNlbnRyaWMgY29vcmRpbmF0ZXNcclxuLy8gYmFzZWQgb246IGh0dHA6Ly93d3cuYmxhY2twYXduLmNvbS90ZXh0cy9wb2ludGlucG9seS9kZWZhdWx0Lmh0bWxcclxuVEhSRUUuVHJpYW5nbGUuYmFyeWNvb3JkRnJvbVBvaW50ID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgdjAgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0dmFyIHYyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uICggcG9pbnQsIGEsIGIsIGMsIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdHYwLnN1YlZlY3RvcnMoIGMsIGEgKTtcclxuXHRcdHYxLnN1YlZlY3RvcnMoIGIsIGEgKTtcclxuXHRcdHYyLnN1YlZlY3RvcnMoIHBvaW50LCBhICk7XHJcblxyXG5cdFx0dmFyIGRvdDAwID0gdjAuZG90KCB2MCApO1xyXG5cdFx0dmFyIGRvdDAxID0gdjAuZG90KCB2MSApO1xyXG5cdFx0dmFyIGRvdDAyID0gdjAuZG90KCB2MiApO1xyXG5cdFx0dmFyIGRvdDExID0gdjEuZG90KCB2MSApO1xyXG5cdFx0dmFyIGRvdDEyID0gdjEuZG90KCB2MiApO1xyXG5cclxuXHRcdHZhciBkZW5vbSA9ICggZG90MDAgKiBkb3QxMSAtIGRvdDAxICogZG90MDEgKTtcclxuXHJcblx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHQvLyBjb2xsaW5lYXIgb3Igc2luZ3VsYXIgdHJpYW5nbGVcclxuXHRcdGlmICggZGVub20gPT09IDAgKSB7XHJcblxyXG5cdFx0XHQvLyBhcmJpdHJhcnkgbG9jYXRpb24gb3V0c2lkZSBvZiB0cmlhbmdsZT9cclxuXHRcdFx0Ly8gbm90IHN1cmUgaWYgdGhpcyBpcyB0aGUgYmVzdCBpZGVhLCBtYXliZSBzaG91bGQgYmUgcmV0dXJuaW5nIHVuZGVmaW5lZFxyXG5cdFx0XHRyZXR1cm4gcmVzdWx0LnNldCggLSAyLCAtIDEsIC0gMSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgaW52RGVub20gPSAxIC8gZGVub207XHJcblx0XHR2YXIgdSA9ICggZG90MTEgKiBkb3QwMiAtIGRvdDAxICogZG90MTIgKSAqIGludkRlbm9tO1xyXG5cdFx0dmFyIHYgPSAoIGRvdDAwICogZG90MTIgLSBkb3QwMSAqIGRvdDAyICkgKiBpbnZEZW5vbTtcclxuXHJcblx0XHQvLyBiYXJ5Y2VudHJpYyBjb29yZGluYXRlcyBtdXN0IGFsd2F5cyBzdW0gdG8gMVxyXG5cdFx0cmV0dXJuIHJlc3VsdC5zZXQoIDEgLSB1IC0gdiwgdiwgdSApO1xyXG5cclxuXHR9O1xyXG5cclxufSgpO1xyXG5cclxuVEhSRUUuVHJpYW5nbGUuY29udGFpbnNQb2ludCA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uICggcG9pbnQsIGEsIGIsIGMgKSB7XHJcblxyXG5cdFx0dmFyIHJlc3VsdCA9IFRIUkVFLlRyaWFuZ2xlLmJhcnljb29yZEZyb21Qb2ludCggcG9pbnQsIGEsIGIsIGMsIHYxICk7XHJcblxyXG5cdFx0cmV0dXJuICggcmVzdWx0LnggPj0gMCApICYmICggcmVzdWx0LnkgPj0gMCApICYmICggKCByZXN1bHQueCArIHJlc3VsdC55ICkgPD0gMSApO1xyXG5cclxuXHR9O1xyXG5cclxufSgpO1xyXG5cclxuVEhSRUUuVHJpYW5nbGUucHJvdG90eXBlID0ge1xyXG5cclxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuVHJpYW5nbGUsXHJcblxyXG5cdHNldDogZnVuY3Rpb24gKCBhLCBiLCBjICkge1xyXG5cclxuXHRcdHRoaXMuYS5jb3B5KCBhICk7XHJcblx0XHR0aGlzLmIuY29weSggYiApO1xyXG5cdFx0dGhpcy5jLmNvcHkoIGMgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0RnJvbVBvaW50c0FuZEluZGljZXM6IGZ1bmN0aW9uICggcG9pbnRzLCBpMCwgaTEsIGkyICkge1xyXG5cclxuXHRcdHRoaXMuYS5jb3B5KCBwb2ludHNbIGkwIF0gKTtcclxuXHRcdHRoaXMuYi5jb3B5KCBwb2ludHNbIGkxIF0gKTtcclxuXHRcdHRoaXMuYy5jb3B5KCBwb2ludHNbIGkyIF0gKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvcHk6IGZ1bmN0aW9uICggdHJpYW5nbGUgKSB7XHJcblxyXG5cdFx0dGhpcy5hLmNvcHkoIHRyaWFuZ2xlLmEgKTtcclxuXHRcdHRoaXMuYi5jb3B5KCB0cmlhbmdsZS5iICk7XHJcblx0XHR0aGlzLmMuY29weSggdHJpYW5nbGUuYyApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRhcmVhOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHYwID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHYwLnN1YlZlY3RvcnMoIHRoaXMuYywgdGhpcy5iICk7XHJcblx0XHRcdHYxLnN1YlZlY3RvcnMoIHRoaXMuYSwgdGhpcy5iICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdjAuY3Jvc3MoIHYxICkubGVuZ3RoKCkgKiAwLjU7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRtaWRwb2ludDogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdHJldHVybiByZXN1bHQuYWRkVmVjdG9ycyggdGhpcy5hLCB0aGlzLmIgKS5hZGQoIHRoaXMuYyApLm11bHRpcGx5U2NhbGFyKCAxIC8gMyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRub3JtYWw6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0cmV0dXJuIFRIUkVFLlRyaWFuZ2xlLm5vcm1hbCggdGhpcy5hLCB0aGlzLmIsIHRoaXMuYywgb3B0aW9uYWxUYXJnZXQgKTtcclxuXHJcblx0fSxcclxuXHJcblx0cGxhbmU6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5QbGFuZSgpO1xyXG5cclxuXHRcdHJldHVybiByZXN1bHQuc2V0RnJvbUNvcGxhbmFyUG9pbnRzKCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5jICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGJhcnljb29yZEZyb21Qb2ludDogZnVuY3Rpb24gKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0cmV0dXJuIFRIUkVFLlRyaWFuZ2xlLmJhcnljb29yZEZyb21Qb2ludCggcG9pbnQsIHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMsIG9wdGlvbmFsVGFyZ2V0ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XHJcblxyXG5cdFx0cmV0dXJuIFRIUkVFLlRyaWFuZ2xlLmNvbnRhaW5zUG9pbnQoIHBvaW50LCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5jICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGVxdWFsczogZnVuY3Rpb24gKCB0cmlhbmdsZSApIHtcclxuXHJcblx0XHRyZXR1cm4gdHJpYW5nbGUuYS5lcXVhbHMoIHRoaXMuYSApICYmIHRyaWFuZ2xlLmIuZXF1YWxzKCB0aGlzLmIgKSAmJiB0cmlhbmdsZS5jLmVxdWFscyggdGhpcy5jICk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9tYXRoL0ludGVycG9sYW50LmpzXHJcblxyXG4vKipcclxuICogQWJzdHJhY3QgYmFzZSBjbGFzcyBvZiBpbnRlcnBvbGFudHMgb3ZlciBwYXJhbWV0cmljIHNhbXBsZXMuXHJcbiAqXHJcbiAqIFRoZSBwYXJhbWV0ZXIgZG9tYWluIGlzIG9uZSBkaW1lbnNpb25hbCwgdHlwaWNhbGx5IHRoZSB0aW1lIG9yIGEgcGF0aFxyXG4gKiBhbG9uZyBhIGN1cnZlIGRlZmluZWQgYnkgdGhlIGRhdGEuXHJcbiAqXHJcbiAqIFRoZSBzYW1wbGUgdmFsdWVzIGNhbiBoYXZlIGFueSBkaW1lbnNpb25hbGl0eSBhbmQgZGVyaXZlZCBjbGFzc2VzIG1heVxyXG4gKiBhcHBseSBzcGVjaWFsIGludGVycHJldGF0aW9ucyB0byB0aGUgZGF0YS5cclxuICpcclxuICogVGhpcyBjbGFzcyBwcm92aWRlcyB0aGUgaW50ZXJ2YWwgc2VlayBpbiBhIFRlbXBsYXRlIE1ldGhvZCwgZGVmZXJyaW5nXHJcbiAqIHRoZSBhY3R1YWwgaW50ZXJwb2xhdGlvbiB0byBkZXJpdmVkIGNsYXNzZXMuXHJcbiAqXHJcbiAqIFRpbWUgY29tcGxleGl0eSBpcyBPKDEpIGZvciBsaW5lYXIgYWNjZXNzIGNyb3NzaW5nIGF0IG1vc3QgdHdvIHBvaW50c1xyXG4gKiBhbmQgTyhsb2cgTikgZm9yIHJhbmRvbSBhY2Nlc3MsIHdoZXJlIE4gaXMgdGhlIG51bWJlciBvZiBwb3NpdGlvbnMuXHJcbiAqXHJcbiAqIFJlZmVyZW5jZXM6XHJcbiAqXHJcbiAqIFx0XHRodHRwOi8vd3d3Lm9vZGVzaWduLmNvbS90ZW1wbGF0ZS1tZXRob2QtcGF0dGVybi5odG1sXHJcbiAqXHJcbiAqIEBhdXRob3IgdHNjaHdcclxuICovXHJcblxyXG5USFJFRS5JbnRlcnBvbGFudCA9IGZ1bmN0aW9uKFxyXG5cdFx0cGFyYW1ldGVyUG9zaXRpb25zLCBzYW1wbGVWYWx1ZXMsIHNhbXBsZVNpemUsIHJlc3VsdEJ1ZmZlciApIHtcclxuXHJcblx0dGhpcy5wYXJhbWV0ZXJQb3NpdGlvbnMgPSBwYXJhbWV0ZXJQb3NpdGlvbnM7XHJcblx0dGhpcy5fY2FjaGVkSW5kZXggPSAwO1xyXG5cclxuXHR0aGlzLnJlc3VsdEJ1ZmZlciA9IHJlc3VsdEJ1ZmZlciAhPT0gdW5kZWZpbmVkID9cclxuXHRcdFx0cmVzdWx0QnVmZmVyIDogbmV3IHNhbXBsZVZhbHVlcy5jb25zdHJ1Y3Rvciggc2FtcGxlU2l6ZSApO1xyXG5cdHRoaXMuc2FtcGxlVmFsdWVzID0gc2FtcGxlVmFsdWVzO1xyXG5cdHRoaXMudmFsdWVTaXplID0gc2FtcGxlU2l6ZTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5JbnRlcnBvbGFudC5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5JbnRlcnBvbGFudCxcclxuXHJcblx0ZXZhbHVhdGU6IGZ1bmN0aW9uKCB0ICkge1xyXG5cclxuXHRcdHZhciBwcCA9IHRoaXMucGFyYW1ldGVyUG9zaXRpb25zLFxyXG5cdFx0XHRpMSA9IHRoaXMuX2NhY2hlZEluZGV4LFxyXG5cclxuXHRcdFx0dDEgPSBwcFsgICBpMSAgIF0sXHJcblx0XHRcdHQwID0gcHBbIGkxIC0gMSBdO1xyXG5cclxuXHRcdHZhbGlkYXRlX2ludGVydmFsOiB7XHJcblxyXG5cdFx0XHRzZWVrOiB7XHJcblxyXG5cdFx0XHRcdHZhciByaWdodDtcclxuXHJcblx0XHRcdFx0bGluZWFyX3NjYW46IHtcclxuLy8tIFNlZSBodHRwOi8vanNwZXJmLmNvbS9jb21wYXJpc29uLXRvLXVuZGVmaW5lZC8zXHJcbi8vLSBzbG93ZXIgY29kZTpcclxuLy8tXHJcbi8vLSBcdFx0XHRcdGlmICggdCA+PSB0MSB8fCB0MSA9PT0gdW5kZWZpbmVkICkge1xyXG5cdFx0XHRcdFx0Zm9yd2FyZF9zY2FuOiBpZiAoICEgKCB0IDwgdDEgKSApIHtcclxuXHJcblx0XHRcdFx0XHRcdGZvciAoIHZhciBnaXZlVXBBdCA9IGkxICsgMjsgOykge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRpZiAoIHQxID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCB0IDwgdDAgKSBicmVhayBmb3J3YXJkX3NjYW47XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0Ly8gYWZ0ZXIgZW5kXHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0aTEgPSBwcC5sZW5ndGg7XHJcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9jYWNoZWRJbmRleCA9IGkxO1xyXG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMuYWZ0ZXJFbmRfKCBpMSAtIDEsIHQsIHQwICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdFx0aWYgKCBpMSA9PT0gZ2l2ZVVwQXQgKSBicmVhazsgLy8gdGhpcyBsb29wXHJcblxyXG5cdFx0XHRcdFx0XHRcdHQwID0gdDE7XHJcblx0XHRcdFx0XHRcdFx0dDEgPSBwcFsgKysgaTEgXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0aWYgKCB0IDwgdDEgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0Ly8gd2UgaGF2ZSBhcnJpdmVkIGF0IHRoZSBzb3VnaHQgaW50ZXJ2YWxcclxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrIHNlZWs7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdC8vIHByZXBhcmUgYmluYXJ5IHNlYXJjaCBvbiB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgaW5kZXhcclxuXHRcdFx0XHRcdFx0cmlnaHQgPSBwcC5sZW5ndGg7XHJcblx0XHRcdFx0XHRcdGJyZWFrIGxpbmVhcl9zY2FuO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcbi8vLSBzbG93ZXIgY29kZTpcclxuLy8tXHRcdFx0XHRcdGlmICggdCA8IHQwIHx8IHQwID09PSB1bmRlZmluZWQgKSB7XHJcblx0XHRcdFx0XHRpZiAoICEgKCB0ID49IHQwICkgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHQvLyBsb29waW5nP1xyXG5cclxuXHRcdFx0XHRcdFx0dmFyIHQxZ2xvYmFsID0gcHBbIDEgXTtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggdCA8IHQxZ2xvYmFsICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRpMSA9IDI7IC8vICsgMSwgdXNpbmcgdGhlIHNjYW4gZm9yIHRoZSBkZXRhaWxzXHJcblx0XHRcdFx0XHRcdFx0dDAgPSB0MWdsb2JhbDtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdC8vIGxpbmVhciByZXZlcnNlIHNjYW5cclxuXHJcblx0XHRcdFx0XHRcdGZvciAoIHZhciBnaXZlVXBBdCA9IGkxIC0gMjsgOykge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRpZiAoIHQwID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0Ly8gYmVmb3JlIHN0YXJ0XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fY2FjaGVkSW5kZXggPSAwO1xyXG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMuYmVmb3JlU3RhcnRfKCAwLCB0LCB0MSApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRcdGlmICggaTEgPT09IGdpdmVVcEF0ICkgYnJlYWs7IC8vIHRoaXMgbG9vcFxyXG5cclxuXHRcdFx0XHRcdFx0XHR0MSA9IHQwO1xyXG5cdFx0XHRcdFx0XHRcdHQwID0gcHBbIC0tIGkxIC0gMSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRpZiAoIHQgPj0gdDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0Ly8gd2UgaGF2ZSBhcnJpdmVkIGF0IHRoZSBzb3VnaHQgaW50ZXJ2YWxcclxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrIHNlZWs7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdC8vIHByZXBhcmUgYmluYXJ5IHNlYXJjaCBvbiB0aGUgbGVmdCBzaWRlIG9mIHRoZSBpbmRleFxyXG5cdFx0XHRcdFx0XHRyaWdodCA9IGkxO1xyXG5cdFx0XHRcdFx0XHRpMSA9IDA7XHJcblx0XHRcdFx0XHRcdGJyZWFrIGxpbmVhcl9zY2FuO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHQvLyB0aGUgaW50ZXJ2YWwgaXMgdmFsaWRcclxuXHJcblx0XHRcdFx0XHRicmVhayB2YWxpZGF0ZV9pbnRlcnZhbDtcclxuXHJcblx0XHRcdFx0fSAvLyBsaW5lYXIgc2NhblxyXG5cclxuXHRcdFx0XHQvLyBiaW5hcnkgc2VhcmNoXHJcblxyXG5cdFx0XHRcdHdoaWxlICggaTEgPCByaWdodCApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgbWlkID0gKCBpMSArIHJpZ2h0ICkgPj4+IDE7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCB0IDwgcHBbIG1pZCBdICkge1xyXG5cclxuXHRcdFx0XHRcdFx0cmlnaHQgPSBtaWQ7XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdGkxID0gbWlkICsgMTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dDEgPSBwcFsgICBpMSAgIF07XHJcblx0XHRcdFx0dDAgPSBwcFsgaTEgLSAxIF07XHJcblxyXG5cdFx0XHRcdC8vIGNoZWNrIGJvdW5kYXJ5IGNhc2VzLCBhZ2FpblxyXG5cclxuXHRcdFx0XHRpZiAoIHQwID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5fY2FjaGVkSW5kZXggPSAwO1xyXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuYmVmb3JlU3RhcnRfKCAwLCB0LCB0MSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggdDEgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRpMSA9IHBwLmxlbmd0aDtcclxuXHRcdFx0XHRcdHRoaXMuX2NhY2hlZEluZGV4ID0gaTE7XHJcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5hZnRlckVuZF8oIGkxIC0gMSwgdDAsIHQgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSAvLyBzZWVrXHJcblxyXG5cdFx0XHR0aGlzLl9jYWNoZWRJbmRleCA9IGkxO1xyXG5cclxuXHRcdFx0dGhpcy5pbnRlcnZhbENoYW5nZWRfKCBpMSwgdDAsIHQxICk7XHJcblxyXG5cdFx0fSAvLyB2YWxpZGF0ZV9pbnRlcnZhbFxyXG5cclxuXHRcdHJldHVybiB0aGlzLmludGVycG9sYXRlXyggaTEsIHQwLCB0LCB0MSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXR0aW5nczogbnVsbCwgLy8gb3B0aW9uYWwsIHN1YmNsYXNzLXNwZWNpZmljIHNldHRpbmdzIHN0cnVjdHVyZVxyXG5cdC8vIE5vdGU6IFRoZSBpbmRpcmVjdGlvbiBhbGxvd3MgY2VudHJhbCBjb250cm9sIG9mIG1hbnkgaW50ZXJwb2xhbnRzLlxyXG5cclxuXHQvLyAtLS0gUHJvdGVjdGVkIGludGVyZmFjZVxyXG5cclxuXHREZWZhdWx0U2V0dGluZ3NfOiB7fSxcclxuXHJcblx0Z2V0U2V0dGluZ3NfOiBmdW5jdGlvbigpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5zZXR0aW5ncyB8fCB0aGlzLkRlZmF1bHRTZXR0aW5nc187XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvcHlTYW1wbGVWYWx1ZV86IGZ1bmN0aW9uKCBpbmRleCApIHtcclxuXHJcblx0XHQvLyBjb3BpZXMgYSBzYW1wbGUgdmFsdWUgdG8gdGhlIHJlc3VsdCBidWZmZXJcclxuXHJcblx0XHR2YXIgcmVzdWx0ID0gdGhpcy5yZXN1bHRCdWZmZXIsXHJcblx0XHRcdHZhbHVlcyA9IHRoaXMuc2FtcGxlVmFsdWVzLFxyXG5cdFx0XHRzdHJpZGUgPSB0aGlzLnZhbHVlU2l6ZSxcclxuXHRcdFx0b2Zmc2V0ID0gaW5kZXggKiBzdHJpZGU7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpICE9PSBzdHJpZGU7ICsrIGkgKSB7XHJcblxyXG5cdFx0XHRyZXN1bHRbIGkgXSA9IHZhbHVlc1sgb2Zmc2V0ICsgaSBdO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cclxuXHR9LFxyXG5cclxuXHQvLyBUZW1wbGF0ZSBtZXRob2RzIGZvciBkZXJpdmVkIGNsYXNzZXM6XHJcblxyXG5cdGludGVycG9sYXRlXzogZnVuY3Rpb24oIGkxLCB0MCwgdCwgdDEgKSB7XHJcblxyXG5cdFx0dGhyb3cgbmV3IEVycm9yKCBcImNhbGwgdG8gYWJzdHJhY3QgbWV0aG9kXCIgKTtcclxuXHRcdC8vIGltcGxlbWVudGF0aW9ucyBzaGFsbCByZXR1cm4gdGhpcy5yZXN1bHRCdWZmZXJcclxuXHJcblx0fSxcclxuXHJcblx0aW50ZXJ2YWxDaGFuZ2VkXzogZnVuY3Rpb24oIGkxLCB0MCwgdDEgKSB7XHJcblxyXG5cdFx0Ly8gZW1wdHlcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbk9iamVjdC5hc3NpZ24oIFRIUkVFLkludGVycG9sYW50LnByb3RvdHlwZSwge1xyXG5cclxuXHRiZWZvcmVTdGFydF86IC8vKCAwLCB0LCB0MCApLCByZXR1cm5zIHRoaXMucmVzdWx0QnVmZmVyXHJcblx0XHRUSFJFRS5JbnRlcnBvbGFudC5wcm90b3R5cGUuY29weVNhbXBsZVZhbHVlXyxcclxuXHJcblx0YWZ0ZXJFbmRfOiAvLyggTi0xLCB0Ti0xLCB0ICksIHJldHVybnMgdGhpcy5yZXN1bHRCdWZmZXJcclxuXHRcdFRIUkVFLkludGVycG9sYW50LnByb3RvdHlwZS5jb3B5U2FtcGxlVmFsdWVfXHJcblxyXG59ICk7XHJcblxyXG4vLyBGaWxlOnNyYy9tYXRoL2ludGVycG9sYW50cy9DdWJpY0ludGVycG9sYW50LmpzXHJcblxyXG4vKipcclxuICogRmFzdCBhbmQgc2ltcGxlIGN1YmljIHNwbGluZSBpbnRlcnBvbGFudC5cclxuICpcclxuICogSXQgd2FzIGRlcml2ZWQgZnJvbSBhIEhlcm1pdGlhbiBjb25zdHJ1Y3Rpb24gc2V0dGluZyB0aGUgZmlyc3QgZGVyaXZhdGl2ZVxyXG4gKiBhdCBlYWNoIHNhbXBsZSBwb3NpdGlvbiB0byB0aGUgbGluZWFyIHNsb3BlIGJldHdlZW4gbmVpZ2hib3JpbmcgcG9zaXRpb25zXHJcbiAqIG92ZXIgdGhlaXIgcGFyYW1ldGVyIGludGVydmFsLlxyXG4gKlxyXG4gKiBAYXV0aG9yIHRzY2h3XHJcbiAqL1xyXG5cclxuVEhSRUUuQ3ViaWNJbnRlcnBvbGFudCA9IGZ1bmN0aW9uKFxyXG5cdFx0cGFyYW1ldGVyUG9zaXRpb25zLCBzYW1wbGVWYWx1ZXMsIHNhbXBsZVNpemUsIHJlc3VsdEJ1ZmZlciApIHtcclxuXHJcblx0VEhSRUUuSW50ZXJwb2xhbnQuY2FsbChcclxuXHRcdFx0dGhpcywgcGFyYW1ldGVyUG9zaXRpb25zLCBzYW1wbGVWYWx1ZXMsIHNhbXBsZVNpemUsIHJlc3VsdEJ1ZmZlciApO1xyXG5cclxuXHR0aGlzLl93ZWlnaHRQcmV2ID0gLTA7XHJcblx0dGhpcy5fb2Zmc2V0UHJldiA9IC0wO1xyXG5cdHRoaXMuX3dlaWdodE5leHQgPSAtMDtcclxuXHR0aGlzLl9vZmZzZXROZXh0ID0gLTA7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQ3ViaWNJbnRlcnBvbGFudC5wcm90b3R5cGUgPVxyXG5cdFx0T2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggVEhSRUUuSW50ZXJwb2xhbnQucHJvdG90eXBlICksIHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLkN1YmljSW50ZXJwb2xhbnQsXHJcblxyXG5cdERlZmF1bHRTZXR0aW5nc186IHtcclxuXHJcblx0XHRlbmRpbmdTdGFydDogXHRUSFJFRS5aZXJvQ3VydmF0dXJlRW5kaW5nLFxyXG5cdFx0ZW5kaW5nRW5kOlx0XHRUSFJFRS5aZXJvQ3VydmF0dXJlRW5kaW5nXHJcblxyXG5cdH0sXHJcblxyXG5cdGludGVydmFsQ2hhbmdlZF86IGZ1bmN0aW9uKCBpMSwgdDAsIHQxICkge1xyXG5cclxuXHRcdHZhciBwcCA9IHRoaXMucGFyYW1ldGVyUG9zaXRpb25zLFxyXG5cdFx0XHRpUHJldiA9IGkxIC0gMixcclxuXHRcdFx0aU5leHQgPSBpMSArIDEsXHJcblxyXG5cdFx0XHR0UHJldiA9IHBwWyBpUHJldiBdLFxyXG5cdFx0XHR0TmV4dCA9IHBwWyBpTmV4dCBdO1xyXG5cclxuXHRcdGlmICggdFByZXYgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHN3aXRjaCAoIHRoaXMuZ2V0U2V0dGluZ3NfKCkuZW5kaW5nU3RhcnQgKSB7XHJcblxyXG5cdFx0XHRcdGNhc2UgVEhSRUUuWmVyb1Nsb3BlRW5kaW5nOlxyXG5cclxuXHRcdFx0XHRcdC8vIGYnKHQwKSA9IDBcclxuXHRcdFx0XHRcdGlQcmV2ID0gaTE7XHJcblx0XHRcdFx0XHR0UHJldiA9IDIgKiB0MCAtIHQxO1xyXG5cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlIFRIUkVFLldyYXBBcm91bmRFbmRpbmc6XHJcblxyXG5cdFx0XHRcdFx0Ly8gdXNlIHRoZSBvdGhlciBlbmQgb2YgdGhlIGN1cnZlXHJcblx0XHRcdFx0XHRpUHJldiA9IHBwLmxlbmd0aCAtIDI7XHJcblx0XHRcdFx0XHR0UHJldiA9IHQwICsgcHBbIGlQcmV2IF0gLSBwcFsgaVByZXYgKyAxIF07XHJcblxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGRlZmF1bHQ6IC8vIFplcm9DdXJ2YXR1cmVFbmRpbmdcclxuXHJcblx0XHRcdFx0XHQvLyBmJycodDApID0gMCBhLmsuYS4gTmF0dXJhbCBTcGxpbmVcclxuXHRcdFx0XHRcdGlQcmV2ID0gaTE7XHJcblx0XHRcdFx0XHR0UHJldiA9IHQxO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHROZXh0ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRzd2l0Y2ggKCB0aGlzLmdldFNldHRpbmdzXygpLmVuZGluZ0VuZCApIHtcclxuXHJcblx0XHRcdFx0Y2FzZSBUSFJFRS5aZXJvU2xvcGVFbmRpbmc6XHJcblxyXG5cdFx0XHRcdFx0Ly8gZicodE4pID0gMFxyXG5cdFx0XHRcdFx0aU5leHQgPSBpMTtcclxuXHRcdFx0XHRcdHROZXh0ID0gMiAqIHQxIC0gdDA7XHJcblxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgVEhSRUUuV3JhcEFyb3VuZEVuZGluZzpcclxuXHJcblx0XHRcdFx0XHQvLyB1c2UgdGhlIG90aGVyIGVuZCBvZiB0aGUgY3VydmVcclxuXHRcdFx0XHRcdGlOZXh0ID0gMTtcclxuXHRcdFx0XHRcdHROZXh0ID0gdDEgKyBwcFsgMSBdIC0gcHBbIDAgXTtcclxuXHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0ZGVmYXVsdDogLy8gWmVyb0N1cnZhdHVyZUVuZGluZ1xyXG5cclxuXHRcdFx0XHRcdC8vIGYnJyh0TikgPSAwLCBhLmsuYS4gTmF0dXJhbCBTcGxpbmVcclxuXHRcdFx0XHRcdGlOZXh0ID0gaTEgLSAxO1xyXG5cdFx0XHRcdFx0dE5leHQgPSB0MDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGhhbGZEdCA9ICggdDEgLSB0MCApICogMC41LFxyXG5cdFx0XHRzdHJpZGUgPSB0aGlzLnZhbHVlU2l6ZTtcclxuXHJcblx0XHR0aGlzLl93ZWlnaHRQcmV2ID0gaGFsZkR0IC8gKCB0MCAtIHRQcmV2ICk7XHJcblx0XHR0aGlzLl93ZWlnaHROZXh0ID0gaGFsZkR0IC8gKCB0TmV4dCAtIHQxICk7XHJcblx0XHR0aGlzLl9vZmZzZXRQcmV2ID0gaVByZXYgKiBzdHJpZGU7XHJcblx0XHR0aGlzLl9vZmZzZXROZXh0ID0gaU5leHQgKiBzdHJpZGU7XHJcblxyXG5cdH0sXHJcblxyXG5cdGludGVycG9sYXRlXzogZnVuY3Rpb24oIGkxLCB0MCwgdCwgdDEgKSB7XHJcblxyXG5cdFx0dmFyIHJlc3VsdCA9IHRoaXMucmVzdWx0QnVmZmVyLFxyXG5cdFx0XHR2YWx1ZXMgPSB0aGlzLnNhbXBsZVZhbHVlcyxcclxuXHRcdFx0c3RyaWRlID0gdGhpcy52YWx1ZVNpemUsXHJcblxyXG5cdFx0XHRvMSA9IGkxICogc3RyaWRlLFx0XHRvMCA9IG8xIC0gc3RyaWRlLFxyXG5cdFx0XHRvUCA9IHRoaXMuX29mZnNldFByZXYsIFx0b04gPSB0aGlzLl9vZmZzZXROZXh0LFxyXG5cdFx0XHR3UCA9IHRoaXMuX3dlaWdodFByZXYsXHR3TiA9IHRoaXMuX3dlaWdodE5leHQsXHJcblxyXG5cdFx0XHRwID0gKCB0IC0gdDAgKSAvICggdDEgLSB0MCApLFxyXG5cdFx0XHRwcCA9IHAgKiBwLFxyXG5cdFx0XHRwcHAgPSBwcCAqIHA7XHJcblxyXG5cdFx0Ly8gZXZhbHVhdGUgcG9seW5vbWlhbHNcclxuXHJcblx0XHR2YXIgc1AgPSAgICAgLSB3UCAgICogcHBwICAgKyAgICAgICAgIDIgKiB3UCAgICAqIHBwICAgIC0gICAgICAgICAgd1AgICAqIHA7XHJcblx0XHR2YXIgczAgPSAoIDEgKyB3UCApICogcHBwICAgKyAoLTEuNSAtIDIgKiB3UCApICAqIHBwICAgICsgKCAtMC41ICsgd1AgKSAqIHAgICAgICsgMTtcclxuXHRcdHZhciBzMSA9ICgtMSAtIHdOICkgKiBwcHAgICArICggMS41ICsgICB3TiAgICkgICogcHAgICAgKyAgICAwLjUgICAgICAgICogcDtcclxuXHRcdHZhciBzTiA9ICAgICAgIHdOICAgKiBwcHAgICAtICAgICAgICAgICB3TiAgICAgICogcHA7XHJcblxyXG5cdFx0Ly8gY29tYmluZSBkYXRhIGxpbmVhcmx5XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpICE9PSBzdHJpZGU7ICsrIGkgKSB7XHJcblxyXG5cdFx0XHRyZXN1bHRbIGkgXSA9XHJcblx0XHRcdFx0XHRzUCAqIHZhbHVlc1sgb1AgKyBpIF0gK1xyXG5cdFx0XHRcdFx0czAgKiB2YWx1ZXNbIG8wICsgaSBdICtcclxuXHRcdFx0XHRcdHMxICogdmFsdWVzWyBvMSArIGkgXSArXHJcblx0XHRcdFx0XHRzTiAqIHZhbHVlc1sgb04gKyBpIF07XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiByZXN1bHQ7XHJcblxyXG5cdH1cclxuXHJcbn0gKTtcclxuXHJcbi8vIEZpbGU6c3JjL21hdGgvaW50ZXJwb2xhbnRzL0Rpc2NyZXRlSW50ZXJwb2xhbnQuanNcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBJbnRlcnBvbGFudCB0aGF0IGV2YWx1YXRlcyB0byB0aGUgc2FtcGxlIHZhbHVlIGF0IHRoZSBwb3NpdGlvbiBwcmVjZWVkaW5nXHJcbiAqIHRoZSBwYXJhbWV0ZXIuXHJcbiAqXHJcbiAqIEBhdXRob3IgdHNjaHdcclxuICovXHJcblxyXG5USFJFRS5EaXNjcmV0ZUludGVycG9sYW50ID0gZnVuY3Rpb24oXHJcblx0XHRwYXJhbWV0ZXJQb3NpdGlvbnMsIHNhbXBsZVZhbHVlcywgc2FtcGxlU2l6ZSwgcmVzdWx0QnVmZmVyICkge1xyXG5cclxuXHRUSFJFRS5JbnRlcnBvbGFudC5jYWxsKFxyXG5cdFx0XHR0aGlzLCBwYXJhbWV0ZXJQb3NpdGlvbnMsIHNhbXBsZVZhbHVlcywgc2FtcGxlU2l6ZSwgcmVzdWx0QnVmZmVyICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuRGlzY3JldGVJbnRlcnBvbGFudC5wcm90b3R5cGUgPVxyXG5cdFx0T2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggVEhSRUUuSW50ZXJwb2xhbnQucHJvdG90eXBlICksIHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLkRpc2NyZXRlSW50ZXJwb2xhbnQsXHJcblxyXG5cdGludGVycG9sYXRlXzogZnVuY3Rpb24oIGkxLCB0MCwgdCwgdDEgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuY29weVNhbXBsZVZhbHVlXyggaTEgLSAxICk7XHJcblxyXG5cdH1cclxuXHJcbn0gKTtcclxuXHJcbi8vIEZpbGU6c3JjL21hdGgvaW50ZXJwb2xhbnRzL0xpbmVhckludGVycG9sYW50LmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciB0c2Nod1xyXG4gKi9cclxuXHJcblRIUkVFLkxpbmVhckludGVycG9sYW50ID0gZnVuY3Rpb24oXHJcblx0XHRwYXJhbWV0ZXJQb3NpdGlvbnMsIHNhbXBsZVZhbHVlcywgc2FtcGxlU2l6ZSwgcmVzdWx0QnVmZmVyICkge1xyXG5cclxuXHRUSFJFRS5JbnRlcnBvbGFudC5jYWxsKFxyXG5cdFx0XHR0aGlzLCBwYXJhbWV0ZXJQb3NpdGlvbnMsIHNhbXBsZVZhbHVlcywgc2FtcGxlU2l6ZSwgcmVzdWx0QnVmZmVyICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTGluZWFySW50ZXJwb2xhbnQucHJvdG90eXBlID1cclxuXHRcdE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIFRIUkVFLkludGVycG9sYW50LnByb3RvdHlwZSApLCB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5MaW5lYXJJbnRlcnBvbGFudCxcclxuXHJcblx0aW50ZXJwb2xhdGVfOiBmdW5jdGlvbiggaTEsIHQwLCB0LCB0MSApIHtcclxuXHJcblx0XHR2YXIgcmVzdWx0ID0gdGhpcy5yZXN1bHRCdWZmZXIsXHJcblx0XHRcdHZhbHVlcyA9IHRoaXMuc2FtcGxlVmFsdWVzLFxyXG5cdFx0XHRzdHJpZGUgPSB0aGlzLnZhbHVlU2l6ZSxcclxuXHJcblx0XHRcdG9mZnNldDEgPSBpMSAqIHN0cmlkZSxcclxuXHRcdFx0b2Zmc2V0MCA9IG9mZnNldDEgLSBzdHJpZGUsXHJcblxyXG5cdFx0XHR3ZWlnaHQxID0gKCB0IC0gdDAgKSAvICggdDEgLSB0MCApLFxyXG5cdFx0XHR3ZWlnaHQwID0gMSAtIHdlaWdodDE7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpICE9PSBzdHJpZGU7ICsrIGkgKSB7XHJcblxyXG5cdFx0XHRyZXN1bHRbIGkgXSA9XHJcblx0XHRcdFx0XHR2YWx1ZXNbIG9mZnNldDAgKyBpIF0gKiB3ZWlnaHQwICtcclxuXHRcdFx0XHRcdHZhbHVlc1sgb2Zmc2V0MSArIGkgXSAqIHdlaWdodDE7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiByZXN1bHQ7XHJcblxyXG5cdH1cclxuXHJcbn0gKTtcclxuXHJcbi8vIEZpbGU6c3JjL21hdGgvaW50ZXJwb2xhbnRzL1F1YXRlcm5pb25MaW5lYXJJbnRlcnBvbGFudC5qc1xyXG5cclxuLyoqXHJcbiAqIFNwaGVyaWNhbCBsaW5lYXIgdW5pdCBxdWF0ZXJuaW9uIGludGVycG9sYW50LlxyXG4gKlxyXG4gKiBAYXV0aG9yIHRzY2h3XHJcbiAqL1xyXG5cclxuVEhSRUUuUXVhdGVybmlvbkxpbmVhckludGVycG9sYW50ID0gZnVuY3Rpb24oXHJcblx0XHRwYXJhbWV0ZXJQb3NpdGlvbnMsIHNhbXBsZVZhbHVlcywgc2FtcGxlU2l6ZSwgcmVzdWx0QnVmZmVyICkge1xyXG5cclxuXHRUSFJFRS5JbnRlcnBvbGFudC5jYWxsKFxyXG5cdFx0XHR0aGlzLCBwYXJhbWV0ZXJQb3NpdGlvbnMsIHNhbXBsZVZhbHVlcywgc2FtcGxlU2l6ZSwgcmVzdWx0QnVmZmVyICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUXVhdGVybmlvbkxpbmVhckludGVycG9sYW50LnByb3RvdHlwZSA9XHJcblx0XHRPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBUSFJFRS5JbnRlcnBvbGFudC5wcm90b3R5cGUgKSwge1xyXG5cclxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuUXVhdGVybmlvbkxpbmVhckludGVycG9sYW50LFxyXG5cclxuXHRpbnRlcnBvbGF0ZV86IGZ1bmN0aW9uKCBpMSwgdDAsIHQsIHQxICkge1xyXG5cclxuXHRcdHZhciByZXN1bHQgPSB0aGlzLnJlc3VsdEJ1ZmZlcixcclxuXHRcdFx0dmFsdWVzID0gdGhpcy5zYW1wbGVWYWx1ZXMsXHJcblx0XHRcdHN0cmlkZSA9IHRoaXMudmFsdWVTaXplLFxyXG5cclxuXHRcdFx0b2Zmc2V0ID0gaTEgKiBzdHJpZGUsXHJcblxyXG5cdFx0XHRhbHBoYSA9ICggdCAtIHQwICkgLyAoIHQxIC0gdDAgKTtcclxuXHJcblx0XHRmb3IgKCB2YXIgZW5kID0gb2Zmc2V0ICsgc3RyaWRlOyBvZmZzZXQgIT09IGVuZDsgb2Zmc2V0ICs9IDQgKSB7XHJcblxyXG5cdFx0XHRUSFJFRS5RdWF0ZXJuaW9uLnNsZXJwRmxhdCggcmVzdWx0LCAwLFxyXG5cdFx0XHRcdFx0dmFsdWVzLCBvZmZzZXQgLSBzdHJpZGUsIHZhbHVlcywgb2Zmc2V0LCBhbHBoYSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cclxuXHR9XHJcblxyXG59ICk7XHJcblxyXG4vLyBGaWxlOnNyYy9jb3JlL0Nsb2NrLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5DbG9jayA9IGZ1bmN0aW9uICggYXV0b1N0YXJ0ICkge1xyXG5cclxuXHR0aGlzLmF1dG9TdGFydCA9ICggYXV0b1N0YXJ0ICE9PSB1bmRlZmluZWQgKSA/IGF1dG9TdGFydCA6IHRydWU7XHJcblxyXG5cdHRoaXMuc3RhcnRUaW1lID0gMDtcclxuXHR0aGlzLm9sZFRpbWUgPSAwO1xyXG5cdHRoaXMuZWxhcHNlZFRpbWUgPSAwO1xyXG5cclxuXHR0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5DbG9jay5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5DbG9jayxcclxuXHJcblx0c3RhcnQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLnN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG5cclxuXHRcdHRoaXMub2xkVGltZSA9IHRoaXMuc3RhcnRUaW1lO1xyXG5cdFx0dGhpcy5ydW5uaW5nID0gdHJ1ZTtcclxuXHJcblx0fSxcclxuXHJcblx0c3RvcDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMuZ2V0RWxhcHNlZFRpbWUoKTtcclxuXHRcdHRoaXMucnVubmluZyA9IGZhbHNlO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXRFbGFwc2VkVGltZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMuZ2V0RGVsdGEoKTtcclxuXHRcdHJldHVybiB0aGlzLmVsYXBzZWRUaW1lO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXREZWx0YTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBkaWZmID0gMDtcclxuXHJcblx0XHRpZiAoIHRoaXMuYXV0b1N0YXJ0ICYmICEgdGhpcy5ydW5uaW5nICkge1xyXG5cclxuXHRcdFx0dGhpcy5zdGFydCgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHRoaXMucnVubmluZyApIHtcclxuXHJcblx0XHRcdHZhciBuZXdUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcblxyXG5cdFx0XHRkaWZmID0gMC4wMDEgKiAoIG5ld1RpbWUgLSB0aGlzLm9sZFRpbWUgKTtcclxuXHRcdFx0dGhpcy5vbGRUaW1lID0gbmV3VGltZTtcclxuXHJcblx0XHRcdHRoaXMuZWxhcHNlZFRpbWUgKz0gZGlmZjtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGRpZmY7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9jb3JlL0V2ZW50RGlzcGF0Y2hlci5qc1xyXG5cclxuLyoqXHJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvZXZlbnRkaXNwYXRjaGVyLmpzL1xyXG4gKi9cclxuXHJcblRIUkVFLkV2ZW50RGlzcGF0Y2hlciA9IGZ1bmN0aW9uICgpIHt9O1xyXG5cclxuVEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLkV2ZW50RGlzcGF0Y2hlcixcclxuXHJcblx0YXBwbHk6IGZ1bmN0aW9uICggb2JqZWN0ICkge1xyXG5cclxuXHRcdG9iamVjdC5hZGRFdmVudExpc3RlbmVyID0gVEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyO1xyXG5cdFx0b2JqZWN0Lmhhc0V2ZW50TGlzdGVuZXIgPSBUSFJFRS5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmhhc0V2ZW50TGlzdGVuZXI7XHJcblx0XHRvYmplY3QucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IFRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lcjtcclxuXHRcdG9iamVjdC5kaXNwYXRjaEV2ZW50ID0gVEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5kaXNwYXRjaEV2ZW50O1xyXG5cclxuXHR9LFxyXG5cclxuXHRhZGRFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAoIHR5cGUsIGxpc3RlbmVyICkge1xyXG5cclxuXHRcdGlmICggdGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQgKSB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcclxuXHJcblx0XHR2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xyXG5cclxuXHRcdGlmICggbGlzdGVuZXJzWyB0eXBlIF0gPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGxpc3RlbmVyc1sgdHlwZSBdID0gW107XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggbGlzdGVuZXJzWyB0eXBlIF0uaW5kZXhPZiggbGlzdGVuZXIgKSA9PT0gLSAxICkge1xyXG5cclxuXHRcdFx0bGlzdGVuZXJzWyB0eXBlIF0ucHVzaCggbGlzdGVuZXIgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdGhhc0V2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uICggdHlwZSwgbGlzdGVuZXIgKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLl9saXN0ZW5lcnMgPT09IHVuZGVmaW5lZCApIHJldHVybiBmYWxzZTtcclxuXHJcblx0XHR2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xyXG5cclxuXHRcdGlmICggbGlzdGVuZXJzWyB0eXBlIF0gIT09IHVuZGVmaW5lZCAmJiBsaXN0ZW5lcnNbIHR5cGUgXS5pbmRleE9mKCBsaXN0ZW5lciApICE9PSAtIDEgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cclxuXHR9LFxyXG5cclxuXHRyZW1vdmVFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAoIHR5cGUsIGxpc3RlbmVyICkge1xyXG5cclxuXHRcdGlmICggdGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQgKSByZXR1cm47XHJcblxyXG5cdFx0dmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcclxuXHRcdHZhciBsaXN0ZW5lckFycmF5ID0gbGlzdGVuZXJzWyB0eXBlIF07XHJcblxyXG5cdFx0aWYgKCBsaXN0ZW5lckFycmF5ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHR2YXIgaW5kZXggPSBsaXN0ZW5lckFycmF5LmluZGV4T2YoIGxpc3RlbmVyICk7XHJcblxyXG5cdFx0XHRpZiAoIGluZGV4ICE9PSAtIDEgKSB7XHJcblxyXG5cdFx0XHRcdGxpc3RlbmVyQXJyYXkuc3BsaWNlKCBpbmRleCwgMSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0ZGlzcGF0Y2hFdmVudDogZnVuY3Rpb24gKCBldmVudCApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xyXG5cclxuXHRcdHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XHJcblx0XHR2YXIgbGlzdGVuZXJBcnJheSA9IGxpc3RlbmVyc1sgZXZlbnQudHlwZSBdO1xyXG5cclxuXHRcdGlmICggbGlzdGVuZXJBcnJheSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0ZXZlbnQudGFyZ2V0ID0gdGhpcztcclxuXHJcblx0XHRcdHZhciBhcnJheSA9IFtdO1xyXG5cdFx0XHR2YXIgbGVuZ3RoID0gbGlzdGVuZXJBcnJheS5sZW5ndGg7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdGFycmF5WyBpIF0gPSBsaXN0ZW5lckFycmF5WyBpIF07XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdGFycmF5WyBpIF0uY2FsbCggdGhpcywgZXZlbnQgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9jb3JlL0xheWVycy5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuTGF5ZXJzID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR0aGlzLm1hc2sgPSAxO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkxheWVycy5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5MYXllcnMsXHJcblxyXG5cdHNldDogZnVuY3Rpb24gKCBjaGFubmVsICkge1xyXG5cclxuXHRcdHRoaXMubWFzayA9IDEgPDwgY2hhbm5lbDtcclxuXHJcblx0fSxcclxuXHJcblx0ZW5hYmxlOiBmdW5jdGlvbiAoIGNoYW5uZWwgKSB7XHJcblxyXG5cdFx0dGhpcy5tYXNrIHw9IDEgPDwgY2hhbm5lbDtcclxuXHJcblx0fSxcclxuXHJcblx0dG9nZ2xlOiBmdW5jdGlvbiAoIGNoYW5uZWwgKSB7XHJcblxyXG5cdFx0dGhpcy5tYXNrIF49IDEgPDwgY2hhbm5lbDtcclxuXHJcblx0fSxcclxuXHJcblx0ZGlzYWJsZTogZnVuY3Rpb24gKCBjaGFubmVsICkge1xyXG5cclxuXHRcdHRoaXMubWFzayAmPSB+ICggMSA8PCBjaGFubmVsICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHRlc3Q6IGZ1bmN0aW9uICggbGF5ZXJzICkge1xyXG5cclxuXHRcdHJldHVybiAoIHRoaXMubWFzayAmIGxheWVycy5tYXNrICkgIT09IDA7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9jb3JlL1JheWNhc3Rlci5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW8vXHJcbiAqIEBhdXRob3Igc3RlcGhvbWkgLyBodHRwOi8vc3RlcGhhbmVnaW5pZXIuY29tL1xyXG4gKi9cclxuXHJcbiggZnVuY3Rpb24gKCBUSFJFRSApIHtcclxuXHJcblx0VEhSRUUuUmF5Y2FzdGVyID0gZnVuY3Rpb24gKCBvcmlnaW4sIGRpcmVjdGlvbiwgbmVhciwgZmFyICkge1xyXG5cclxuXHRcdHRoaXMucmF5ID0gbmV3IFRIUkVFLlJheSggb3JpZ2luLCBkaXJlY3Rpb24gKTtcclxuXHRcdC8vIGRpcmVjdGlvbiBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWQgKGZvciBhY2N1cmF0ZSBkaXN0YW5jZSBjYWxjdWxhdGlvbnMpXHJcblxyXG5cdFx0dGhpcy5uZWFyID0gbmVhciB8fCAwO1xyXG5cdFx0dGhpcy5mYXIgPSBmYXIgfHwgSW5maW5pdHk7XHJcblxyXG5cdFx0dGhpcy5wYXJhbXMgPSB7XHJcblx0XHRcdE1lc2g6IHt9LFxyXG5cdFx0XHRMaW5lOiB7fSxcclxuXHRcdFx0TE9EOiB7fSxcclxuXHRcdFx0UG9pbnRzOiB7IHRocmVzaG9sZDogMSB9LFxyXG5cdFx0XHRTcHJpdGU6IHt9XHJcblx0XHR9O1xyXG5cclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCB0aGlzLnBhcmFtcywge1xyXG5cdFx0XHRQb2ludENsb3VkOiB7XHJcblx0XHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5SYXljYXN0ZXI6IHBhcmFtcy5Qb2ludENsb3VkIGhhcyBiZWVuIHJlbmFtZWQgdG8gcGFyYW1zLlBvaW50cy4nICk7XHJcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5Qb2ludHM7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9ICk7XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIGFzY1NvcnQoIGEsIGIgKSB7XHJcblxyXG5cdFx0cmV0dXJuIGEuZGlzdGFuY2UgLSBiLmRpc3RhbmNlO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGludGVyc2VjdE9iamVjdCggb2JqZWN0LCByYXljYXN0ZXIsIGludGVyc2VjdHMsIHJlY3Vyc2l2ZSApIHtcclxuXHJcblx0XHRpZiAoIG9iamVjdC52aXNpYmxlID09PSBmYWxzZSApIHJldHVybjtcclxuXHJcblx0XHRvYmplY3QucmF5Y2FzdCggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICk7XHJcblxyXG5cdFx0aWYgKCByZWN1cnNpdmUgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHR2YXIgY2hpbGRyZW4gPSBvYmplY3QuY2hpbGRyZW47XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRpbnRlcnNlY3RPYmplY3QoIGNoaWxkcmVuWyBpIF0sIHJheWNhc3RlciwgaW50ZXJzZWN0cywgdHJ1ZSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHQvL1xyXG5cclxuXHRUSFJFRS5SYXljYXN0ZXIucHJvdG90eXBlID0ge1xyXG5cclxuXHRcdGNvbnN0cnVjdG9yOiBUSFJFRS5SYXljYXN0ZXIsXHJcblxyXG5cdFx0bGluZVByZWNpc2lvbjogMSxcclxuXHJcblx0XHRzZXQ6IGZ1bmN0aW9uICggb3JpZ2luLCBkaXJlY3Rpb24gKSB7XHJcblxyXG5cdFx0XHQvLyBkaXJlY3Rpb24gaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkIChmb3IgYWNjdXJhdGUgZGlzdGFuY2UgY2FsY3VsYXRpb25zKVxyXG5cclxuXHRcdFx0dGhpcy5yYXkuc2V0KCBvcmlnaW4sIGRpcmVjdGlvbiApO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0c2V0RnJvbUNhbWVyYTogZnVuY3Rpb24gKCBjb29yZHMsIGNhbWVyYSApIHtcclxuXHJcblx0XHRcdGlmICggY2FtZXJhIGluc3RhbmNlb2YgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMucmF5Lm9yaWdpbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGNhbWVyYS5tYXRyaXhXb3JsZCApO1xyXG5cdFx0XHRcdHRoaXMucmF5LmRpcmVjdGlvbi5zZXQoIGNvb3Jkcy54LCBjb29yZHMueSwgMC41ICkudW5wcm9qZWN0KCBjYW1lcmEgKS5zdWIoIHRoaXMucmF5Lm9yaWdpbiApLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggY2FtZXJhIGluc3RhbmNlb2YgVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLnJheS5vcmlnaW4uc2V0KCBjb29yZHMueCwgY29vcmRzLnksIC0gMSApLnVucHJvamVjdCggY2FtZXJhICk7XHJcblx0XHRcdFx0dGhpcy5yYXkuZGlyZWN0aW9uLnNldCggMCwgMCwgLSAxICkudHJhbnNmb3JtRGlyZWN0aW9uKCBjYW1lcmEubWF0cml4V29ybGQgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5SYXljYXN0ZXI6IFVuc3VwcG9ydGVkIGNhbWVyYSB0eXBlLicgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGludGVyc2VjdE9iamVjdDogZnVuY3Rpb24gKCBvYmplY3QsIHJlY3Vyc2l2ZSApIHtcclxuXHJcblx0XHRcdHZhciBpbnRlcnNlY3RzID0gW107XHJcblxyXG5cdFx0XHRpbnRlcnNlY3RPYmplY3QoIG9iamVjdCwgdGhpcywgaW50ZXJzZWN0cywgcmVjdXJzaXZlICk7XHJcblxyXG5cdFx0XHRpbnRlcnNlY3RzLnNvcnQoIGFzY1NvcnQgKTtcclxuXHJcblx0XHRcdHJldHVybiBpbnRlcnNlY3RzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0aW50ZXJzZWN0T2JqZWN0czogZnVuY3Rpb24gKCBvYmplY3RzLCByZWN1cnNpdmUgKSB7XHJcblxyXG5cdFx0XHR2YXIgaW50ZXJzZWN0cyA9IFtdO1xyXG5cclxuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBvYmplY3RzICkgPT09IGZhbHNlICkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5SYXljYXN0ZXIuaW50ZXJzZWN0T2JqZWN0czogb2JqZWN0cyBpcyBub3QgYW4gQXJyYXkuJyApO1xyXG5cdFx0XHRcdHJldHVybiBpbnRlcnNlY3RzO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gb2JqZWN0cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRpbnRlcnNlY3RPYmplY3QoIG9iamVjdHNbIGkgXSwgdGhpcywgaW50ZXJzZWN0cywgcmVjdXJzaXZlICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpbnRlcnNlY3RzLnNvcnQoIGFzY1NvcnQgKTtcclxuXHJcblx0XHRcdHJldHVybiBpbnRlcnNlY3RzO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcbn0oIFRIUkVFICkgKTtcclxuXHJcbi8vIEZpbGU6c3JjL2NvcmUvT2JqZWN0M0QuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcclxuICogQGF1dGhvciBlbGVwaGFudGF0d29yayAvIHd3dy5lbGVwaGFudGF0d29yay5jaFxyXG4gKi9cclxuXHJcblRIUkVFLk9iamVjdDNEID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsICdpZCcsIHsgdmFsdWU6IFRIUkVFLk9iamVjdDNESWRDb3VudCArKyB9ICk7XHJcblxyXG5cdHRoaXMudXVpZCA9IFRIUkVFLk1hdGguZ2VuZXJhdGVVVUlEKCk7XHJcblxyXG5cdHRoaXMubmFtZSA9ICcnO1xyXG5cdHRoaXMudHlwZSA9ICdPYmplY3QzRCc7XHJcblxyXG5cdHRoaXMucGFyZW50ID0gbnVsbDtcclxuXHR0aGlzLmNoaWxkcmVuID0gW107XHJcblxyXG5cdHRoaXMudXAgPSBUSFJFRS5PYmplY3QzRC5EZWZhdWx0VXAuY2xvbmUoKTtcclxuXHJcblx0dmFyIHBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHR2YXIgcm90YXRpb24gPSBuZXcgVEhSRUUuRXVsZXIoKTtcclxuXHR2YXIgcXVhdGVybmlvbiA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XHJcblx0dmFyIHNjYWxlID0gbmV3IFRIUkVFLlZlY3RvcjMoIDEsIDEsIDEgKTtcclxuXHJcblx0ZnVuY3Rpb24gb25Sb3RhdGlvbkNoYW5nZSgpIHtcclxuXHJcblx0XHRxdWF0ZXJuaW9uLnNldEZyb21FdWxlciggcm90YXRpb24sIGZhbHNlICk7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gb25RdWF0ZXJuaW9uQ2hhbmdlKCkge1xyXG5cclxuXHRcdHJvdGF0aW9uLnNldEZyb21RdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uLCB1bmRlZmluZWQsIGZhbHNlICk7XHJcblxyXG5cdH1cclxuXHJcblx0cm90YXRpb24ub25DaGFuZ2UoIG9uUm90YXRpb25DaGFuZ2UgKTtcclxuXHRxdWF0ZXJuaW9uLm9uQ2hhbmdlKCBvblF1YXRlcm5pb25DaGFuZ2UgKTtcclxuXHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIHRoaXMsIHtcclxuXHRcdHBvc2l0aW9uOiB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdHZhbHVlOiBwb3NpdGlvblxyXG5cdFx0fSxcclxuXHRcdHJvdGF0aW9uOiB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdHZhbHVlOiByb3RhdGlvblxyXG5cdFx0fSxcclxuXHRcdHF1YXRlcm5pb246IHtcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0dmFsdWU6IHF1YXRlcm5pb25cclxuXHRcdH0sXHJcblx0XHRzY2FsZToge1xyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHR2YWx1ZTogc2NhbGVcclxuXHRcdH0sXHJcblx0XHRtb2RlbFZpZXdNYXRyaXg6IHtcclxuXHRcdFx0dmFsdWU6IG5ldyBUSFJFRS5NYXRyaXg0KClcclxuXHRcdH0sXHJcblx0XHRub3JtYWxNYXRyaXg6IHtcclxuXHRcdFx0dmFsdWU6IG5ldyBUSFJFRS5NYXRyaXgzKClcclxuXHRcdH1cclxuXHR9ICk7XHJcblxyXG5cdHRoaXMucm90YXRpb25BdXRvVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0dGhpcy5tYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xyXG5cdHRoaXMubWF0cml4V29ybGQgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xyXG5cclxuXHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBUSFJFRS5PYmplY3QzRC5EZWZhdWx0TWF0cml4QXV0b1VwZGF0ZTtcclxuXHR0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSBmYWxzZTtcclxuXHJcblx0dGhpcy5sYXllcnMgPSBuZXcgVEhSRUUuTGF5ZXJzKCk7XHJcblx0dGhpcy52aXNpYmxlID0gdHJ1ZTtcclxuXHJcblx0dGhpcy5jYXN0U2hhZG93ID0gZmFsc2U7XHJcblx0dGhpcy5yZWNlaXZlU2hhZG93ID0gZmFsc2U7XHJcblxyXG5cdHRoaXMuZnJ1c3R1bUN1bGxlZCA9IHRydWU7XHJcblx0dGhpcy5yZW5kZXJPcmRlciA9IDA7XHJcblxyXG5cdHRoaXMudXNlckRhdGEgPSB7fTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5PYmplY3QzRC5EZWZhdWx0VXAgPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMSwgMCApO1xyXG5USFJFRS5PYmplY3QzRC5EZWZhdWx0TWF0cml4QXV0b1VwZGF0ZSA9IHRydWU7XHJcblxyXG5USFJFRS5PYmplY3QzRC5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5PYmplY3QzRCxcclxuXHJcblx0YXBwbHlNYXRyaXg6IGZ1bmN0aW9uICggbWF0cml4ICkge1xyXG5cclxuXHRcdHRoaXMubWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIG1hdHJpeCwgdGhpcy5tYXRyaXggKTtcclxuXHJcblx0XHR0aGlzLm1hdHJpeC5kZWNvbXBvc2UoIHRoaXMucG9zaXRpb24sIHRoaXMucXVhdGVybmlvbiwgdGhpcy5zY2FsZSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRSb3RhdGlvbkZyb21BeGlzQW5nbGU6IGZ1bmN0aW9uICggYXhpcywgYW5nbGUgKSB7XHJcblxyXG5cdFx0Ly8gYXNzdW1lcyBheGlzIGlzIG5vcm1hbGl6ZWRcclxuXHJcblx0XHR0aGlzLnF1YXRlcm5pb24uc2V0RnJvbUF4aXNBbmdsZSggYXhpcywgYW5nbGUgKTtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0Um90YXRpb25Gcm9tRXVsZXI6IGZ1bmN0aW9uICggZXVsZXIgKSB7XHJcblxyXG5cdFx0dGhpcy5xdWF0ZXJuaW9uLnNldEZyb21FdWxlciggZXVsZXIsIHRydWUgKTtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0Um90YXRpb25Gcm9tTWF0cml4OiBmdW5jdGlvbiAoIG0gKSB7XHJcblxyXG5cdFx0Ly8gYXNzdW1lcyB0aGUgdXBwZXIgM3gzIG9mIG0gaXMgYSBwdXJlIHJvdGF0aW9uIG1hdHJpeCAoaS5lLCB1bnNjYWxlZClcclxuXHJcblx0XHR0aGlzLnF1YXRlcm5pb24uc2V0RnJvbVJvdGF0aW9uTWF0cml4KCBtICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldFJvdGF0aW9uRnJvbVF1YXRlcm5pb246IGZ1bmN0aW9uICggcSApIHtcclxuXHJcblx0XHQvLyBhc3N1bWVzIHEgaXMgbm9ybWFsaXplZFxyXG5cclxuXHRcdHRoaXMucXVhdGVybmlvbi5jb3B5KCBxICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHJvdGF0ZU9uQXhpczogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdC8vIHJvdGF0ZSBvYmplY3Qgb24gYXhpcyBpbiBvYmplY3Qgc3BhY2VcclxuXHRcdC8vIGF4aXMgaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkXHJcblxyXG5cdFx0dmFyIHExID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBheGlzLCBhbmdsZSApIHtcclxuXHJcblx0XHRcdHExLnNldEZyb21BeGlzQW5nbGUoIGF4aXMsIGFuZ2xlICk7XHJcblxyXG5cdFx0XHR0aGlzLnF1YXRlcm5pb24ubXVsdGlwbHkoIHExICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdHJvdGF0ZVg6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMyggMSwgMCwgMCApO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIGFuZ2xlICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMucm90YXRlT25BeGlzKCB2MSwgYW5nbGUgKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdHJvdGF0ZVk6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMSwgMCApO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIGFuZ2xlICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMucm90YXRlT25BeGlzKCB2MSwgYW5nbGUgKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdHJvdGF0ZVo6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMCwgMSApO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIGFuZ2xlICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMucm90YXRlT25BeGlzKCB2MSwgYW5nbGUgKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdHRyYW5zbGF0ZU9uQXhpczogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdC8vIHRyYW5zbGF0ZSBvYmplY3QgYnkgZGlzdGFuY2UgYWxvbmcgYXhpcyBpbiBvYmplY3Qgc3BhY2VcclxuXHRcdC8vIGF4aXMgaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkXHJcblxyXG5cdFx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBheGlzLCBkaXN0YW5jZSApIHtcclxuXHJcblx0XHRcdHYxLmNvcHkoIGF4aXMgKS5hcHBseVF1YXRlcm5pb24oIHRoaXMucXVhdGVybmlvbiApO1xyXG5cclxuXHRcdFx0dGhpcy5wb3NpdGlvbi5hZGQoIHYxLm11bHRpcGx5U2NhbGFyKCBkaXN0YW5jZSApICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdHRyYW5zbGF0ZVg6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMyggMSwgMCwgMCApO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIGRpc3RhbmNlICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKCB2MSwgZGlzdGFuY2UgKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdHRyYW5zbGF0ZVk6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMSwgMCApO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIGRpc3RhbmNlICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKCB2MSwgZGlzdGFuY2UgKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdHRyYW5zbGF0ZVo6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMCwgMSApO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIGRpc3RhbmNlICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKCB2MSwgZGlzdGFuY2UgKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGxvY2FsVG9Xb3JsZDogZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHZlY3Rvci5hcHBseU1hdHJpeDQoIHRoaXMubWF0cml4V29ybGQgKTtcclxuXHJcblx0fSxcclxuXHJcblx0d29ybGRUb0xvY2FsOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIG0xID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdmVjdG9yLmFwcGx5TWF0cml4NCggbTEuZ2V0SW52ZXJzZSggdGhpcy5tYXRyaXhXb3JsZCApICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRsb29rQXQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHQvLyBUaGlzIHJvdXRpbmUgZG9lcyBub3Qgc3VwcG9ydCBvYmplY3RzIHdpdGggcm90YXRlZCBhbmQvb3IgdHJhbnNsYXRlZCBwYXJlbnQocylcclxuXHJcblx0XHR2YXIgbTEgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIHZlY3RvciApIHtcclxuXHJcblx0XHRcdG0xLmxvb2tBdCggdmVjdG9yLCB0aGlzLnBvc2l0aW9uLCB0aGlzLnVwICk7XHJcblxyXG5cdFx0XHR0aGlzLnF1YXRlcm5pb24uc2V0RnJvbVJvdGF0aW9uTWF0cml4KCBtMSApO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0YWRkOiBmdW5jdGlvbiAoIG9iamVjdCApIHtcclxuXHJcblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPiAxICkge1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5hZGQoIGFyZ3VtZW50c1sgaSBdICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBvYmplY3QgPT09IHRoaXMgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLmVycm9yKCBcIlRIUkVFLk9iamVjdDNELmFkZDogb2JqZWN0IGNhbid0IGJlIGFkZGVkIGFzIGEgY2hpbGQgb2YgaXRzZWxmLlwiLCBvYmplY3QgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuT2JqZWN0M0QgKSB7XHJcblxyXG5cdFx0XHRpZiAoIG9iamVjdC5wYXJlbnQgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdG9iamVjdC5wYXJlbnQucmVtb3ZlKCBvYmplY3QgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdG9iamVjdC5wYXJlbnQgPSB0aGlzO1xyXG5cdFx0XHRvYmplY3QuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAnYWRkZWQnIH0gKTtcclxuXHJcblx0XHRcdHRoaXMuY2hpbGRyZW4ucHVzaCggb2JqZWN0ICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoIFwiVEhSRUUuT2JqZWN0M0QuYWRkOiBvYmplY3Qgbm90IGFuIGluc3RhbmNlIG9mIFRIUkVFLk9iamVjdDNELlwiLCBvYmplY3QgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHJlbW92ZTogZnVuY3Rpb24gKCBvYmplY3QgKSB7XHJcblxyXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID4gMSApIHtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMucmVtb3ZlKCBhcmd1bWVudHNbIGkgXSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgaW5kZXggPSB0aGlzLmNoaWxkcmVuLmluZGV4T2YoIG9iamVjdCApO1xyXG5cclxuXHRcdGlmICggaW5kZXggIT09IC0gMSApIHtcclxuXHJcblx0XHRcdG9iamVjdC5wYXJlbnQgPSBudWxsO1xyXG5cclxuXHRcdFx0b2JqZWN0LmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ3JlbW92ZWQnIH0gKTtcclxuXHJcblx0XHRcdHRoaXMuY2hpbGRyZW4uc3BsaWNlKCBpbmRleCwgMSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0Z2V0T2JqZWN0QnlJZDogZnVuY3Rpb24gKCBpZCApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5nZXRPYmplY3RCeVByb3BlcnR5KCAnaWQnLCBpZCApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXRPYmplY3RCeU5hbWU6IGZ1bmN0aW9uICggbmFtZSApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5nZXRPYmplY3RCeVByb3BlcnR5KCAnbmFtZScsIG5hbWUgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0T2JqZWN0QnlQcm9wZXJ0eTogZnVuY3Rpb24gKCBuYW1lLCB2YWx1ZSApIHtcclxuXHJcblx0XHRpZiAoIHRoaXNbIG5hbWUgXSA9PT0gdmFsdWUgKSByZXR1cm4gdGhpcztcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuWyBpIF07XHJcblx0XHRcdHZhciBvYmplY3QgPSBjaGlsZC5nZXRPYmplY3RCeVByb3BlcnR5KCBuYW1lLCB2YWx1ZSApO1xyXG5cclxuXHRcdFx0aWYgKCBvYmplY3QgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIG9iamVjdDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHVuZGVmaW5lZDtcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0V29ybGRQb3NpdGlvbjogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHR0aGlzLnVwZGF0ZU1hdHJpeFdvcmxkKCB0cnVlICk7XHJcblxyXG5cdFx0cmV0dXJuIHJlc3VsdC5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubWF0cml4V29ybGQgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0V29ybGRRdWF0ZXJuaW9uOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdHZhciBzY2FsZSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcclxuXHJcblx0XHRcdHRoaXMudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcclxuXHJcblx0XHRcdHRoaXMubWF0cml4V29ybGQuZGVjb21wb3NlKCBwb3NpdGlvbiwgcmVzdWx0LCBzY2FsZSApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGdldFdvcmxkUm90YXRpb246IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgcXVhdGVybmlvbiA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLkV1bGVyKCk7XHJcblxyXG5cdFx0XHR0aGlzLmdldFdvcmxkUXVhdGVybmlvbiggcXVhdGVybmlvbiApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHJlc3VsdC5zZXRGcm9tUXVhdGVybmlvbiggcXVhdGVybmlvbiwgdGhpcy5yb3RhdGlvbi5vcmRlciwgZmFsc2UgKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGdldFdvcmxkU2NhbGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgcG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0dmFyIHF1YXRlcm5pb24gPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0XHR0aGlzLnVwZGF0ZU1hdHJpeFdvcmxkKCB0cnVlICk7XHJcblxyXG5cdFx0XHR0aGlzLm1hdHJpeFdvcmxkLmRlY29tcG9zZSggcG9zaXRpb24sIHF1YXRlcm5pb24sIHJlc3VsdCApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGdldFdvcmxkRGlyZWN0aW9uOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHF1YXRlcm5pb24gPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0XHR0aGlzLmdldFdvcmxkUXVhdGVybmlvbiggcXVhdGVybmlvbiApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHJlc3VsdC5zZXQoIDAsIDAsIDEgKS5hcHBseVF1YXRlcm5pb24oIHF1YXRlcm5pb24gKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdHJheWNhc3Q6IGZ1bmN0aW9uICgpIHt9LFxyXG5cclxuXHR0cmF2ZXJzZTogZnVuY3Rpb24gKCBjYWxsYmFjayApIHtcclxuXHJcblx0XHRjYWxsYmFjayggdGhpcyApO1xyXG5cclxuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdGNoaWxkcmVuWyBpIF0udHJhdmVyc2UoIGNhbGxiYWNrICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHR0cmF2ZXJzZVZpc2libGU6IGZ1bmN0aW9uICggY2FsbGJhY2sgKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLnZpc2libGUgPT09IGZhbHNlICkgcmV0dXJuO1xyXG5cclxuXHRcdGNhbGxiYWNrKCB0aGlzICk7XHJcblxyXG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0Y2hpbGRyZW5bIGkgXS50cmF2ZXJzZVZpc2libGUoIGNhbGxiYWNrICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHR0cmF2ZXJzZUFuY2VzdG9yczogZnVuY3Rpb24gKCBjYWxsYmFjayApIHtcclxuXHJcblx0XHR2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XHJcblxyXG5cdFx0aWYgKCBwYXJlbnQgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRjYWxsYmFjayggcGFyZW50ICk7XHJcblxyXG5cdFx0XHRwYXJlbnQudHJhdmVyc2VBbmNlc3RvcnMoIGNhbGxiYWNrICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHR1cGRhdGVNYXRyaXg6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLm1hdHJpeC5jb21wb3NlKCB0aGlzLnBvc2l0aW9uLCB0aGlzLnF1YXRlcm5pb24sIHRoaXMuc2NhbGUgKTtcclxuXHJcblx0XHR0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHR9LFxyXG5cclxuXHR1cGRhdGVNYXRyaXhXb3JsZDogZnVuY3Rpb24gKCBmb3JjZSApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9PT0gdHJ1ZSApIHRoaXMudXBkYXRlTWF0cml4KCk7XHJcblxyXG5cdFx0aWYgKCB0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPT09IHRydWUgfHwgZm9yY2UgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMucGFyZW50ID09PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLm1hdHJpeFdvcmxkLmNvcHkoIHRoaXMubWF0cml4ICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHR0aGlzLm1hdHJpeFdvcmxkLm11bHRpcGx5TWF0cmljZXMoIHRoaXMucGFyZW50Lm1hdHJpeFdvcmxkLCB0aGlzLm1hdHJpeCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gZmFsc2U7XHJcblxyXG5cdFx0XHRmb3JjZSA9IHRydWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHVwZGF0ZSBjaGlsZHJlblxyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHRoaXMuY2hpbGRyZW5bIGkgXS51cGRhdGVNYXRyaXhXb3JsZCggZm9yY2UgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdHRvSlNPTjogZnVuY3Rpb24gKCBtZXRhICkge1xyXG5cclxuXHRcdHZhciBpc1Jvb3RPYmplY3QgPSAoIG1ldGEgPT09IHVuZGVmaW5lZCApO1xyXG5cclxuXHRcdHZhciBvdXRwdXQgPSB7fTtcclxuXHJcblx0XHQvLyBtZXRhIGlzIGEgaGFzaCB1c2VkIHRvIGNvbGxlY3QgZ2VvbWV0cmllcywgbWF0ZXJpYWxzLlxyXG5cdFx0Ly8gbm90IHByb3ZpZGluZyBpdCBpbXBsaWVzIHRoYXQgdGhpcyBpcyB0aGUgcm9vdCBvYmplY3RcclxuXHRcdC8vIGJlaW5nIHNlcmlhbGl6ZWQuXHJcblx0XHRpZiAoIGlzUm9vdE9iamVjdCApIHtcclxuXHJcblx0XHRcdC8vIGluaXRpYWxpemUgbWV0YSBvYmpcclxuXHRcdFx0bWV0YSA9IHtcclxuXHRcdFx0XHRnZW9tZXRyaWVzOiB7fSxcclxuXHRcdFx0XHRtYXRlcmlhbHM6IHt9LFxyXG5cdFx0XHRcdHRleHR1cmVzOiB7fSxcclxuXHRcdFx0XHRpbWFnZXM6IHt9XHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHRvdXRwdXQubWV0YWRhdGEgPSB7XHJcblx0XHRcdFx0dmVyc2lvbjogNC40LFxyXG5cdFx0XHRcdHR5cGU6ICdPYmplY3QnLFxyXG5cdFx0XHRcdGdlbmVyYXRvcjogJ09iamVjdDNELnRvSlNPTidcclxuXHRcdFx0fTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gc3RhbmRhcmQgT2JqZWN0M0Qgc2VyaWFsaXphdGlvblxyXG5cclxuXHRcdHZhciBvYmplY3QgPSB7fTtcclxuXHJcblx0XHRvYmplY3QudXVpZCA9IHRoaXMudXVpZDtcclxuXHRcdG9iamVjdC50eXBlID0gdGhpcy50eXBlO1xyXG5cclxuXHRcdGlmICggdGhpcy5uYW1lICE9PSAnJyApIG9iamVjdC5uYW1lID0gdGhpcy5uYW1lO1xyXG5cdFx0aWYgKCBKU09OLnN0cmluZ2lmeSggdGhpcy51c2VyRGF0YSApICE9PSAne30nICkgb2JqZWN0LnVzZXJEYXRhID0gdGhpcy51c2VyRGF0YTtcclxuXHRcdGlmICggdGhpcy5jYXN0U2hhZG93ID09PSB0cnVlICkgb2JqZWN0LmNhc3RTaGFkb3cgPSB0cnVlO1xyXG5cdFx0aWYgKCB0aGlzLnJlY2VpdmVTaGFkb3cgPT09IHRydWUgKSBvYmplY3QucmVjZWl2ZVNoYWRvdyA9IHRydWU7XHJcblx0XHRpZiAoIHRoaXMudmlzaWJsZSA9PT0gZmFsc2UgKSBvYmplY3QudmlzaWJsZSA9IGZhbHNlO1xyXG5cclxuXHRcdG9iamVjdC5tYXRyaXggPSB0aGlzLm1hdHJpeC50b0FycmF5KCk7XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHRpZiAoIHRoaXMuZ2VvbWV0cnkgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGlmICggbWV0YS5nZW9tZXRyaWVzWyB0aGlzLmdlb21ldHJ5LnV1aWQgXSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRtZXRhLmdlb21ldHJpZXNbIHRoaXMuZ2VvbWV0cnkudXVpZCBdID0gdGhpcy5nZW9tZXRyeS50b0pTT04oIG1ldGEgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdG9iamVjdC5nZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnkudXVpZDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0aGlzLm1hdGVyaWFsICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRpZiAoIG1ldGEubWF0ZXJpYWxzWyB0aGlzLm1hdGVyaWFsLnV1aWQgXSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRtZXRhLm1hdGVyaWFsc1sgdGhpcy5tYXRlcmlhbC51dWlkIF0gPSB0aGlzLm1hdGVyaWFsLnRvSlNPTiggbWV0YSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0b2JqZWN0Lm1hdGVyaWFsID0gdGhpcy5tYXRlcmlhbC51dWlkO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdGlmICggdGhpcy5jaGlsZHJlbi5sZW5ndGggPiAwICkge1xyXG5cclxuXHRcdFx0b2JqZWN0LmNoaWxkcmVuID0gW107XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0b2JqZWN0LmNoaWxkcmVuLnB1c2goIHRoaXMuY2hpbGRyZW5bIGkgXS50b0pTT04oIG1ldGEgKS5vYmplY3QgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBpc1Jvb3RPYmplY3QgKSB7XHJcblxyXG5cdFx0XHR2YXIgZ2VvbWV0cmllcyA9IGV4dHJhY3RGcm9tQ2FjaGUoIG1ldGEuZ2VvbWV0cmllcyApO1xyXG5cdFx0XHR2YXIgbWF0ZXJpYWxzID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS5tYXRlcmlhbHMgKTtcclxuXHRcdFx0dmFyIHRleHR1cmVzID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS50ZXh0dXJlcyApO1xyXG5cdFx0XHR2YXIgaW1hZ2VzID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS5pbWFnZXMgKTtcclxuXHJcblx0XHRcdGlmICggZ2VvbWV0cmllcy5sZW5ndGggPiAwICkgb3V0cHV0Lmdlb21ldHJpZXMgPSBnZW9tZXRyaWVzO1xyXG5cdFx0XHRpZiAoIG1hdGVyaWFscy5sZW5ndGggPiAwICkgb3V0cHV0Lm1hdGVyaWFscyA9IG1hdGVyaWFscztcclxuXHRcdFx0aWYgKCB0ZXh0dXJlcy5sZW5ndGggPiAwICkgb3V0cHV0LnRleHR1cmVzID0gdGV4dHVyZXM7XHJcblx0XHRcdGlmICggaW1hZ2VzLmxlbmd0aCA+IDAgKSBvdXRwdXQuaW1hZ2VzID0gaW1hZ2VzO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRvdXRwdXQub2JqZWN0ID0gb2JqZWN0O1xyXG5cclxuXHRcdHJldHVybiBvdXRwdXQ7XHJcblxyXG5cdFx0Ly8gZXh0cmFjdCBkYXRhIGZyb20gdGhlIGNhY2hlIGhhc2hcclxuXHRcdC8vIHJlbW92ZSBtZXRhZGF0YSBvbiBlYWNoIGl0ZW1cclxuXHRcdC8vIGFuZCByZXR1cm4gYXMgYXJyYXlcclxuXHRcdGZ1bmN0aW9uIGV4dHJhY3RGcm9tQ2FjaGUgKCBjYWNoZSApIHtcclxuXHJcblx0XHRcdHZhciB2YWx1ZXMgPSBbXTtcclxuXHRcdFx0Zm9yICggdmFyIGtleSBpbiBjYWNoZSApIHtcclxuXHJcblx0XHRcdFx0dmFyIGRhdGEgPSBjYWNoZVsga2V5IF07XHJcblx0XHRcdFx0ZGVsZXRlIGRhdGEubWV0YWRhdGE7XHJcblx0XHRcdFx0dmFsdWVzLnB1c2goIGRhdGEgKTtcclxuXHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHZhbHVlcztcclxuXHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdGNsb25lOiBmdW5jdGlvbiAoIHJlY3Vyc2l2ZSApIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzLCByZWN1cnNpdmUgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UsIHJlY3Vyc2l2ZSApIHtcclxuXHJcblx0XHRpZiAoIHJlY3Vyc2l2ZSA9PT0gdW5kZWZpbmVkICkgcmVjdXJzaXZlID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLm5hbWUgPSBzb3VyY2UubmFtZTtcclxuXHJcblx0XHR0aGlzLnVwLmNvcHkoIHNvdXJjZS51cCApO1xyXG5cclxuXHRcdHRoaXMucG9zaXRpb24uY29weSggc291cmNlLnBvc2l0aW9uICk7XHJcblx0XHR0aGlzLnF1YXRlcm5pb24uY29weSggc291cmNlLnF1YXRlcm5pb24gKTtcclxuXHRcdHRoaXMuc2NhbGUuY29weSggc291cmNlLnNjYWxlICk7XHJcblxyXG5cdFx0dGhpcy5yb3RhdGlvbkF1dG9VcGRhdGUgPSBzb3VyY2Uucm90YXRpb25BdXRvVXBkYXRlO1xyXG5cclxuXHRcdHRoaXMubWF0cml4LmNvcHkoIHNvdXJjZS5tYXRyaXggKTtcclxuXHRcdHRoaXMubWF0cml4V29ybGQuY29weSggc291cmNlLm1hdHJpeFdvcmxkICk7XHJcblxyXG5cdFx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gc291cmNlLm1hdHJpeEF1dG9VcGRhdGU7XHJcblx0XHR0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSBzb3VyY2UubWF0cml4V29ybGROZWVkc1VwZGF0ZTtcclxuXHJcblx0XHR0aGlzLnZpc2libGUgPSBzb3VyY2UudmlzaWJsZTtcclxuXHJcblx0XHR0aGlzLmNhc3RTaGFkb3cgPSBzb3VyY2UuY2FzdFNoYWRvdztcclxuXHRcdHRoaXMucmVjZWl2ZVNoYWRvdyA9IHNvdXJjZS5yZWNlaXZlU2hhZG93O1xyXG5cclxuXHRcdHRoaXMuZnJ1c3R1bUN1bGxlZCA9IHNvdXJjZS5mcnVzdHVtQ3VsbGVkO1xyXG5cdFx0dGhpcy5yZW5kZXJPcmRlciA9IHNvdXJjZS5yZW5kZXJPcmRlcjtcclxuXHJcblx0XHR0aGlzLnVzZXJEYXRhID0gSlNPTi5wYXJzZSggSlNPTi5zdHJpbmdpZnkoIHNvdXJjZS51c2VyRGF0YSApICk7XHJcblxyXG5cdFx0aWYgKCByZWN1cnNpdmUgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBzb3VyY2UuY2hpbGRyZW4ubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgY2hpbGQgPSBzb3VyY2UuY2hpbGRyZW5bIGkgXTtcclxuXHRcdFx0XHR0aGlzLmFkZCggY2hpbGQuY2xvbmUoKSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcblRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuYXBwbHkoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xyXG5cclxuVEhSRUUuT2JqZWN0M0RJZENvdW50ID0gMDtcclxuXHJcbi8vIEZpbGU6c3JjL2NvcmUvRmFjZTMuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkZhY2UzID0gZnVuY3Rpb24gKCBhLCBiLCBjLCBub3JtYWwsIGNvbG9yLCBtYXRlcmlhbEluZGV4ICkge1xyXG5cclxuXHR0aGlzLmEgPSBhO1xyXG5cdHRoaXMuYiA9IGI7XHJcblx0dGhpcy5jID0gYztcclxuXHJcblx0dGhpcy5ub3JtYWwgPSBub3JtYWwgaW5zdGFuY2VvZiBUSFJFRS5WZWN0b3IzID8gbm9ybWFsIDogbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHR0aGlzLnZlcnRleE5vcm1hbHMgPSBBcnJheS5pc0FycmF5KCBub3JtYWwgKSA/IG5vcm1hbCA6IFtdO1xyXG5cclxuXHR0aGlzLmNvbG9yID0gY29sb3IgaW5zdGFuY2VvZiBUSFJFRS5Db2xvciA/IGNvbG9yIDogbmV3IFRIUkVFLkNvbG9yKCk7XHJcblx0dGhpcy52ZXJ0ZXhDb2xvcnMgPSBBcnJheS5pc0FycmF5KCBjb2xvciApID8gY29sb3IgOiBbXTtcclxuXHJcblx0dGhpcy5tYXRlcmlhbEluZGV4ID0gbWF0ZXJpYWxJbmRleCAhPT0gdW5kZWZpbmVkID8gbWF0ZXJpYWxJbmRleCA6IDA7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuRmFjZTMucHJvdG90eXBlID0ge1xyXG5cclxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuRmFjZTMsXHJcblxyXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcblx0XHR0aGlzLmEgPSBzb3VyY2UuYTtcclxuXHRcdHRoaXMuYiA9IHNvdXJjZS5iO1xyXG5cdFx0dGhpcy5jID0gc291cmNlLmM7XHJcblxyXG5cdFx0dGhpcy5ub3JtYWwuY29weSggc291cmNlLm5vcm1hbCApO1xyXG5cdFx0dGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcclxuXHJcblx0XHR0aGlzLm1hdGVyaWFsSW5kZXggPSBzb3VyY2UubWF0ZXJpYWxJbmRleDtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gc291cmNlLnZlcnRleE5vcm1hbHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnZlcnRleE5vcm1hbHNbIGkgXSA9IHNvdXJjZS52ZXJ0ZXhOb3JtYWxzWyBpIF0uY2xvbmUoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHNvdXJjZS52ZXJ0ZXhDb2xvcnMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnZlcnRleENvbG9yc1sgaSBdID0gc291cmNlLnZlcnRleENvbG9yc1sgaSBdLmNsb25lKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvY29yZS9CdWZmZXJBdHRyaWJ1dGUuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSA9IGZ1bmN0aW9uICggYXJyYXksIGl0ZW1TaXplICkge1xyXG5cclxuXHR0aGlzLnV1aWQgPSBUSFJFRS5NYXRoLmdlbmVyYXRlVVVJRCgpO1xyXG5cclxuXHR0aGlzLmFycmF5ID0gYXJyYXk7XHJcblx0dGhpcy5pdGVtU2l6ZSA9IGl0ZW1TaXplO1xyXG5cclxuXHR0aGlzLmR5bmFtaWMgPSBmYWxzZTtcclxuXHR0aGlzLnVwZGF0ZVJhbmdlID0geyBvZmZzZXQ6IDAsIGNvdW50OiAtIDEgfTtcclxuXHJcblx0dGhpcy52ZXJzaW9uID0gMDtcclxuXHJcbn07XHJcblxyXG5USFJFRS5CdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlID0ge1xyXG5cclxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuQnVmZmVyQXR0cmlidXRlLFxyXG5cclxuXHRnZXQgY291bnQoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuYXJyYXkubGVuZ3RoIC8gdGhpcy5pdGVtU2l6ZTtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0IG5lZWRzVXBkYXRlKCB2YWx1ZSApIHtcclxuXHJcblx0XHRpZiAoIHZhbHVlID09PSB0cnVlICkgdGhpcy52ZXJzaW9uICsrO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXREeW5hbWljOiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdHRoaXMuZHluYW1pYyA9IHZhbHVlO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcblx0XHR0aGlzLmFycmF5ID0gbmV3IHNvdXJjZS5hcnJheS5jb25zdHJ1Y3Rvciggc291cmNlLmFycmF5ICk7XHJcblx0XHR0aGlzLml0ZW1TaXplID0gc291cmNlLml0ZW1TaXplO1xyXG5cclxuXHRcdHRoaXMuZHluYW1pYyA9IHNvdXJjZS5keW5hbWljO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb3B5QXQ6IGZ1bmN0aW9uICggaW5kZXgxLCBhdHRyaWJ1dGUsIGluZGV4MiApIHtcclxuXHJcblx0XHRpbmRleDEgKj0gdGhpcy5pdGVtU2l6ZTtcclxuXHRcdGluZGV4MiAqPSBhdHRyaWJ1dGUuaXRlbVNpemU7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy5pdGVtU2l6ZTsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmFycmF5WyBpbmRleDEgKyBpIF0gPSBhdHRyaWJ1dGUuYXJyYXlbIGluZGV4MiArIGkgXTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvcHlBcnJheTogZnVuY3Rpb24gKCBhcnJheSApIHtcclxuXHJcblx0XHR0aGlzLmFycmF5LnNldCggYXJyYXkgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y29weUNvbG9yc0FycmF5OiBmdW5jdGlvbiAoIGNvbG9ycyApIHtcclxuXHJcblx0XHR2YXIgYXJyYXkgPSB0aGlzLmFycmF5LCBvZmZzZXQgPSAwO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGNvbG9ycy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIGNvbG9yID0gY29sb3JzWyBpIF07XHJcblxyXG5cdFx0XHRpZiAoIGNvbG9yID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckF0dHJpYnV0ZS5jb3B5Q29sb3JzQXJyYXkoKTogY29sb3IgaXMgdW5kZWZpbmVkJywgaSApO1xyXG5cdFx0XHRcdGNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRhcnJheVsgb2Zmc2V0ICsrIF0gPSBjb2xvci5yO1xyXG5cdFx0XHRhcnJheVsgb2Zmc2V0ICsrIF0gPSBjb2xvci5nO1xyXG5cdFx0XHRhcnJheVsgb2Zmc2V0ICsrIF0gPSBjb2xvci5iO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y29weUluZGljZXNBcnJheTogZnVuY3Rpb24gKCBpbmRpY2VzICkge1xyXG5cclxuXHRcdHZhciBhcnJheSA9IHRoaXMuYXJyYXksIG9mZnNldCA9IDA7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gaW5kaWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIGluZGV4ID0gaW5kaWNlc1sgaSBdO1xyXG5cclxuXHRcdFx0YXJyYXlbIG9mZnNldCArKyBdID0gaW5kZXguYTtcclxuXHRcdFx0YXJyYXlbIG9mZnNldCArKyBdID0gaW5kZXguYjtcclxuXHRcdFx0YXJyYXlbIG9mZnNldCArKyBdID0gaW5kZXguYztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvcHlWZWN0b3Iyc0FycmF5OiBmdW5jdGlvbiAoIHZlY3RvcnMgKSB7XHJcblxyXG5cdFx0dmFyIGFycmF5ID0gdGhpcy5hcnJheSwgb2Zmc2V0ID0gMDtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB2ZWN0b3JzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgdmVjdG9yID0gdmVjdG9yc1sgaSBdO1xyXG5cclxuXHRcdFx0aWYgKCB2ZWN0b3IgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyQXR0cmlidXRlLmNvcHlWZWN0b3Iyc0FycmF5KCk6IHZlY3RvciBpcyB1bmRlZmluZWQnLCBpICk7XHJcblx0XHRcdFx0dmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGFycmF5WyBvZmZzZXQgKysgXSA9IHZlY3Rvci54O1xyXG5cdFx0XHRhcnJheVsgb2Zmc2V0ICsrIF0gPSB2ZWN0b3IueTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvcHlWZWN0b3Izc0FycmF5OiBmdW5jdGlvbiAoIHZlY3RvcnMgKSB7XHJcblxyXG5cdFx0dmFyIGFycmF5ID0gdGhpcy5hcnJheSwgb2Zmc2V0ID0gMDtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB2ZWN0b3JzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgdmVjdG9yID0gdmVjdG9yc1sgaSBdO1xyXG5cclxuXHRcdFx0aWYgKCB2ZWN0b3IgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyQXR0cmlidXRlLmNvcHlWZWN0b3Izc0FycmF5KCk6IHZlY3RvciBpcyB1bmRlZmluZWQnLCBpICk7XHJcblx0XHRcdFx0dmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGFycmF5WyBvZmZzZXQgKysgXSA9IHZlY3Rvci54O1xyXG5cdFx0XHRhcnJheVsgb2Zmc2V0ICsrIF0gPSB2ZWN0b3IueTtcclxuXHRcdFx0YXJyYXlbIG9mZnNldCArKyBdID0gdmVjdG9yLno7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb3B5VmVjdG9yNHNBcnJheTogZnVuY3Rpb24gKCB2ZWN0b3JzICkge1xyXG5cclxuXHRcdHZhciBhcnJheSA9IHRoaXMuYXJyYXksIG9mZnNldCA9IDA7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gdmVjdG9ycy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIHZlY3RvciA9IHZlY3RvcnNbIGkgXTtcclxuXHJcblx0XHRcdGlmICggdmVjdG9yID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckF0dHJpYnV0ZS5jb3B5VmVjdG9yNHNBcnJheSgpOiB2ZWN0b3IgaXMgdW5kZWZpbmVkJywgaSApO1xyXG5cdFx0XHRcdHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3I0KCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRhcnJheVsgb2Zmc2V0ICsrIF0gPSB2ZWN0b3IueDtcclxuXHRcdFx0YXJyYXlbIG9mZnNldCArKyBdID0gdmVjdG9yLnk7XHJcblx0XHRcdGFycmF5WyBvZmZzZXQgKysgXSA9IHZlY3Rvci56O1xyXG5cdFx0XHRhcnJheVsgb2Zmc2V0ICsrIF0gPSB2ZWN0b3IudztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldDogZnVuY3Rpb24gKCB2YWx1ZSwgb2Zmc2V0ICkge1xyXG5cclxuXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xyXG5cclxuXHRcdHRoaXMuYXJyYXkuc2V0KCB2YWx1ZSwgb2Zmc2V0ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldFg6IGZ1bmN0aW9uICggaW5kZXggKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSBdO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRYOiBmdW5jdGlvbiAoIGluZGV4LCB4ICkge1xyXG5cclxuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSBdID0geDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0WTogZnVuY3Rpb24gKCBpbmRleCApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMSBdO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRZOiBmdW5jdGlvbiAoIGluZGV4LCB5ICkge1xyXG5cclxuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDEgXSA9IHk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldFo6IGZ1bmN0aW9uICggaW5kZXggKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDIgXTtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0WjogZnVuY3Rpb24gKCBpbmRleCwgeiApIHtcclxuXHJcblx0XHR0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAyIF0gPSB6O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXRXOiBmdW5jdGlvbiAoIGluZGV4ICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAzIF07XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldFc6IGZ1bmN0aW9uICggaW5kZXgsIHcgKSB7XHJcblxyXG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMyBdID0gdztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0WFk6IGZ1bmN0aW9uICggaW5kZXgsIHgsIHkgKSB7XHJcblxyXG5cdFx0aW5kZXggKj0gdGhpcy5pdGVtU2l6ZTtcclxuXHJcblx0XHR0aGlzLmFycmF5WyBpbmRleCArIDAgXSA9IHg7XHJcblx0XHR0aGlzLmFycmF5WyBpbmRleCArIDEgXSA9IHk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldFhZWjogZnVuY3Rpb24gKCBpbmRleCwgeCwgeSwgeiApIHtcclxuXHJcblx0XHRpbmRleCAqPSB0aGlzLml0ZW1TaXplO1xyXG5cclxuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMCBdID0geDtcclxuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMSBdID0geTtcclxuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMiBdID0gejtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0WFlaVzogZnVuY3Rpb24gKCBpbmRleCwgeCwgeSwgeiwgdyApIHtcclxuXHJcblx0XHRpbmRleCAqPSB0aGlzLml0ZW1TaXplO1xyXG5cclxuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMCBdID0geDtcclxuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMSBdID0geTtcclxuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMiBdID0gejtcclxuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMyBdID0gdztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vL1xyXG5cclxuVEhSRUUuSW50OEF0dHJpYnV0ZSA9IGZ1bmN0aW9uICggYXJyYXksIGl0ZW1TaXplICkge1xyXG5cclxuXHRyZXR1cm4gbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IEludDhBcnJheSggYXJyYXkgKSwgaXRlbVNpemUgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5VaW50OEF0dHJpYnV0ZSA9IGZ1bmN0aW9uICggYXJyYXksIGl0ZW1TaXplICkge1xyXG5cclxuXHRyZXR1cm4gbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IFVpbnQ4QXJyYXkoIGFycmF5ICksIGl0ZW1TaXplICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuVWludDhDbGFtcGVkQXR0cmlidXRlID0gZnVuY3Rpb24gKCBhcnJheSwgaXRlbVNpemUgKSB7XHJcblxyXG5cdHJldHVybiBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgVWludDhDbGFtcGVkQXJyYXkoIGFycmF5ICksIGl0ZW1TaXplICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuSW50MTZBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoIGFycmF5LCBpdGVtU2l6ZSApIHtcclxuXHJcblx0cmV0dXJuIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBJbnQxNkFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlVpbnQxNkF0dHJpYnV0ZSA9IGZ1bmN0aW9uICggYXJyYXksIGl0ZW1TaXplICkge1xyXG5cclxuXHRyZXR1cm4gbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IFVpbnQxNkFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkludDMyQXR0cmlidXRlID0gZnVuY3Rpb24gKCBhcnJheSwgaXRlbVNpemUgKSB7XHJcblxyXG5cdHJldHVybiBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgSW50MzJBcnJheSggYXJyYXkgKSwgaXRlbVNpemUgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5VaW50MzJBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoIGFycmF5LCBpdGVtU2l6ZSApIHtcclxuXHJcblx0cmV0dXJuIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBVaW50MzJBcnJheSggYXJyYXkgKSwgaXRlbVNpemUgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5GbG9hdDMyQXR0cmlidXRlID0gZnVuY3Rpb24gKCBhcnJheSwgaXRlbVNpemUgKSB7XHJcblxyXG5cdHJldHVybiBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgRmxvYXQzMkFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkZsb2F0NjRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoIGFycmF5LCBpdGVtU2l6ZSApIHtcclxuXHJcblx0cmV0dXJuIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBGbG9hdDY0QXJyYXkoIGFycmF5ICksIGl0ZW1TaXplICk7XHJcblxyXG59O1xyXG5cclxuXHJcbi8vIERlcHJlY2F0ZWRcclxuXHJcblRIUkVFLkR5bmFtaWNCdWZmZXJBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoIGFycmF5LCBpdGVtU2l6ZSApIHtcclxuXHJcblx0Y29uc29sZS53YXJuKCAnVEhSRUUuRHluYW1pY0J1ZmZlckF0dHJpYnV0ZSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSgpLnNldER5bmFtaWMoIHRydWUgKSBpbnN0ZWFkLicgKTtcclxuXHRyZXR1cm4gbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplICkuc2V0RHluYW1pYyggdHJ1ZSApO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2NvcmUvSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBiZW5hYWRhbXMgLyBodHRwczovL3R3aXR0ZXIuY29tL2Jlbl9hX2FkYW1zXHJcbiAqL1xyXG5cclxuVEhSRUUuSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlID0gZnVuY3Rpb24gKCBhcnJheSwgaXRlbVNpemUsIG1lc2hQZXJBdHRyaWJ1dGUgKSB7XHJcblxyXG5cdFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZS5jYWxsKCB0aGlzLCBhcnJheSwgaXRlbVNpemUgKTtcclxuXHJcblx0dGhpcy5tZXNoUGVyQXR0cmlidXRlID0gbWVzaFBlckF0dHJpYnV0ZSB8fCAxO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlICk7XHJcblRIUkVFLkluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5JbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGU7XHJcblxyXG5USFJFRS5JbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcblx0VEhSRUUuQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xyXG5cclxuXHR0aGlzLm1lc2hQZXJBdHRyaWJ1dGUgPSBzb3VyY2UubWVzaFBlckF0dHJpYnV0ZTtcclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvY29yZS9JbnRlcmxlYXZlZEJ1ZmZlci5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYmVuYWFkYW1zIC8gaHR0cHM6Ly90d2l0dGVyLmNvbS9iZW5fYV9hZGFtc1xyXG4gKi9cclxuXHJcblRIUkVFLkludGVybGVhdmVkQnVmZmVyID0gZnVuY3Rpb24gKCBhcnJheSwgc3RyaWRlICkge1xyXG5cclxuXHR0aGlzLnV1aWQgPSBUSFJFRS5NYXRoLmdlbmVyYXRlVVVJRCgpO1xyXG5cclxuXHR0aGlzLmFycmF5ID0gYXJyYXk7XHJcblx0dGhpcy5zdHJpZGUgPSBzdHJpZGU7XHJcblxyXG5cdHRoaXMuZHluYW1pYyA9IGZhbHNlO1xyXG5cdHRoaXMudXBkYXRlUmFuZ2UgPSB7IG9mZnNldDogMCwgY291bnQ6IC0gMSB9O1xyXG5cclxuXHR0aGlzLnZlcnNpb24gPSAwO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkludGVybGVhdmVkQnVmZmVyLnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLkludGVybGVhdmVkQnVmZmVyLFxyXG5cclxuXHRnZXQgbGVuZ3RoICgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5hcnJheS5sZW5ndGg7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldCBjb3VudCAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuYXJyYXkubGVuZ3RoIC8gdGhpcy5zdHJpZGU7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldCBuZWVkc1VwZGF0ZSggdmFsdWUgKSB7XHJcblxyXG5cdFx0aWYgKCB2YWx1ZSA9PT0gdHJ1ZSApIHRoaXMudmVyc2lvbiArKztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0RHluYW1pYzogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0XHR0aGlzLmR5bmFtaWMgPSB2YWx1ZTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG5cdFx0dGhpcy5hcnJheSA9IG5ldyBzb3VyY2UuYXJyYXkuY29uc3RydWN0b3IoIHNvdXJjZS5hcnJheSApO1xyXG5cdFx0dGhpcy5zdHJpZGUgPSBzb3VyY2Uuc3RyaWRlO1xyXG5cdFx0dGhpcy5keW5hbWljID0gc291cmNlLmR5bmFtaWM7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvcHlBdDogZnVuY3Rpb24gKCBpbmRleDEsIGF0dHJpYnV0ZSwgaW5kZXgyICkge1xyXG5cclxuXHRcdGluZGV4MSAqPSB0aGlzLnN0cmlkZTtcclxuXHRcdGluZGV4MiAqPSBhdHRyaWJ1dGUuc3RyaWRlO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMuc3RyaWRlOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHRoaXMuYXJyYXlbIGluZGV4MSArIGkgXSA9IGF0dHJpYnV0ZS5hcnJheVsgaW5kZXgyICsgaSBdO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlLCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XHJcblxyXG5cdFx0dGhpcy5hcnJheS5zZXQoIHZhbHVlLCBvZmZzZXQgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9jb3JlL0luc3RhbmNlZEludGVybGVhdmVkQnVmZmVyLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBiZW5hYWRhbXMgLyBodHRwczovL3R3aXR0ZXIuY29tL2Jlbl9hX2FkYW1zXHJcbiAqL1xyXG5cclxuVEhSRUUuSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIgPSBmdW5jdGlvbiAoIGFycmF5LCBzdHJpZGUsIG1lc2hQZXJBdHRyaWJ1dGUgKSB7XHJcblxyXG5cdFRIUkVFLkludGVybGVhdmVkQnVmZmVyLmNhbGwoIHRoaXMsIGFycmF5LCBzdHJpZGUgKTtcclxuXHJcblx0dGhpcy5tZXNoUGVyQXR0cmlidXRlID0gbWVzaFBlckF0dHJpYnV0ZSB8fCAxO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkluc3RhbmNlZEludGVybGVhdmVkQnVmZmVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkludGVybGVhdmVkQnVmZmVyLnByb3RvdHlwZSApO1xyXG5USFJFRS5JbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5JbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlcjtcclxuXHJcblRIUkVFLkluc3RhbmNlZEludGVybGVhdmVkQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG5cdFRIUkVFLkludGVybGVhdmVkQnVmZmVyLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xyXG5cclxuXHR0aGlzLm1lc2hQZXJBdHRyaWJ1dGUgPSBzb3VyY2UubWVzaFBlckF0dHJpYnV0ZTtcclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvY29yZS9JbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYmVuYWFkYW1zIC8gaHR0cHM6Ly90d2l0dGVyLmNvbS9iZW5fYV9hZGFtc1xyXG4gKi9cclxuXHJcblRIUkVFLkludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlID0gZnVuY3Rpb24gKCBpbnRlcmxlYXZlZEJ1ZmZlciwgaXRlbVNpemUsIG9mZnNldCApIHtcclxuXHJcblx0dGhpcy51dWlkID0gVEhSRUUuTWF0aC5nZW5lcmF0ZVVVSUQoKTtcclxuXHJcblx0dGhpcy5kYXRhID0gaW50ZXJsZWF2ZWRCdWZmZXI7XHJcblx0dGhpcy5pdGVtU2l6ZSA9IGl0ZW1TaXplO1xyXG5cdHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xyXG5cclxufTtcclxuXHJcblxyXG5USFJFRS5JbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5JbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSxcclxuXHJcblx0Z2V0IGxlbmd0aCgpIHtcclxuXHJcblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJBdHRyaWJ1dGU6IC5sZW5ndGggaGFzIGJlZW4gZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSAuY291bnQuJyApO1xyXG5cdFx0cmV0dXJuIHRoaXMuYXJyYXkubGVuZ3RoO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXQgY291bnQoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZGF0YS5jb3VudDtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0WDogZnVuY3Rpb24gKCBpbmRleCwgeCApIHtcclxuXHJcblx0XHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0IF0gPSB4O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRZOiBmdW5jdGlvbiAoIGluZGV4LCB5ICkge1xyXG5cclxuXHRcdHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQgKyAxIF0gPSB5O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRaOiBmdW5jdGlvbiAoIGluZGV4LCB6ICkge1xyXG5cclxuXHRcdHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQgKyAyIF0gPSB6O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRXOiBmdW5jdGlvbiAoIGluZGV4LCB3ICkge1xyXG5cclxuXHRcdHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQgKyAzIF0gPSB3O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXRYOiBmdW5jdGlvbiAoIGluZGV4ICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0IF07XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldFk6IGZ1bmN0aW9uICggaW5kZXggKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQgKyAxIF07XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldFo6IGZ1bmN0aW9uICggaW5kZXggKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQgKyAyIF07XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldFc6IGZ1bmN0aW9uICggaW5kZXggKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQgKyAzIF07XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldFhZOiBmdW5jdGlvbiAoIGluZGV4LCB4LCB5ICkge1xyXG5cclxuXHRcdGluZGV4ID0gaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQ7XHJcblxyXG5cdFx0dGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDAgXSA9IHg7XHJcblx0XHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMSBdID0geTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0WFlaOiBmdW5jdGlvbiAoIGluZGV4LCB4LCB5LCB6ICkge1xyXG5cclxuXHRcdGluZGV4ID0gaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQ7XHJcblxyXG5cdFx0dGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDAgXSA9IHg7XHJcblx0XHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMSBdID0geTtcclxuXHRcdHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKyAyIF0gPSB6O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRYWVpXOiBmdW5jdGlvbiAoIGluZGV4LCB4LCB5LCB6LCB3ICkge1xyXG5cclxuXHRcdGluZGV4ID0gaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQ7XHJcblxyXG5cdFx0dGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDAgXSA9IHg7XHJcblx0XHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMSBdID0geTtcclxuXHRcdHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKyAyIF0gPSB6O1xyXG5cdFx0dGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDMgXSA9IHc7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9jb3JlL0dlb21ldHJ5LmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBraWxlIC8gaHR0cDovL2tpbGUuc3RyYXZhZ2FuemEub3JnL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xyXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXHJcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cclxuICovXHJcblxyXG5USFJFRS5HZW9tZXRyeSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCAnaWQnLCB7IHZhbHVlOiBUSFJFRS5HZW9tZXRyeUlkQ291bnQgKysgfSApO1xyXG5cclxuXHR0aGlzLnV1aWQgPSBUSFJFRS5NYXRoLmdlbmVyYXRlVVVJRCgpO1xyXG5cclxuXHR0aGlzLm5hbWUgPSAnJztcclxuXHR0aGlzLnR5cGUgPSAnR2VvbWV0cnknO1xyXG5cclxuXHR0aGlzLnZlcnRpY2VzID0gW107XHJcblx0dGhpcy5jb2xvcnMgPSBbXTtcclxuXHR0aGlzLmZhY2VzID0gW107XHJcblx0dGhpcy5mYWNlVmVydGV4VXZzID0gWyBbXSBdO1xyXG5cclxuXHR0aGlzLm1vcnBoVGFyZ2V0cyA9IFtdO1xyXG5cdHRoaXMubW9ycGhOb3JtYWxzID0gW107XHJcblxyXG5cdHRoaXMuc2tpbldlaWdodHMgPSBbXTtcclxuXHR0aGlzLnNraW5JbmRpY2VzID0gW107XHJcblxyXG5cdHRoaXMubGluZURpc3RhbmNlcyA9IFtdO1xyXG5cclxuXHR0aGlzLmJvdW5kaW5nQm94ID0gbnVsbDtcclxuXHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gbnVsbDtcclxuXHJcblx0Ly8gdXBkYXRlIGZsYWdzXHJcblxyXG5cdHRoaXMudmVydGljZXNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblx0dGhpcy5lbGVtZW50c05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHR0aGlzLnV2c05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHR0aGlzLm5vcm1hbHNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblx0dGhpcy5jb2xvcnNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblx0dGhpcy5saW5lRGlzdGFuY2VzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cdHRoaXMuZ3JvdXBzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLkdlb21ldHJ5LFxyXG5cclxuXHRhcHBseU1hdHJpeDogZnVuY3Rpb24gKCBtYXRyaXggKSB7XHJcblxyXG5cdFx0dmFyIG5vcm1hbE1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXgzKCkuZ2V0Tm9ybWFsTWF0cml4KCBtYXRyaXggKTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciB2ZXJ0ZXggPSB0aGlzLnZlcnRpY2VzWyBpIF07XHJcblx0XHRcdHZlcnRleC5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciBmYWNlID0gdGhpcy5mYWNlc1sgaSBdO1xyXG5cdFx0XHRmYWNlLm5vcm1hbC5hcHBseU1hdHJpeDMoIG5vcm1hbE1hdHJpeCApLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IGZhY2UudmVydGV4Tm9ybWFscy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0ZmFjZS52ZXJ0ZXhOb3JtYWxzWyBqIF0uYXBwbHlNYXRyaXgzKCBub3JtYWxNYXRyaXggKS5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0aGlzLmJvdW5kaW5nQm94ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0dGhpcy5jb21wdXRlQm91bmRpbmdCb3goKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0aGlzLmJvdW5kaW5nU3BoZXJlICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0dGhpcy5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy52ZXJ0aWNlc05lZWRVcGRhdGUgPSB0cnVlO1xyXG5cdFx0dGhpcy5ub3JtYWxzTmVlZFVwZGF0ZSA9IHRydWU7XHJcblxyXG5cdH0sXHJcblxyXG5cdHJvdGF0ZVg6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHQvLyByb3RhdGUgZ2VvbWV0cnkgYXJvdW5kIHdvcmxkIHgtYXhpc1xyXG5cclxuXHRcdHZhciBtMTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gcm90YXRlWCggYW5nbGUgKSB7XHJcblxyXG5cdFx0XHRpZiAoIG0xID09PSB1bmRlZmluZWQgKSBtMSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblxyXG5cdFx0XHRtMS5tYWtlUm90YXRpb25YKCBhbmdsZSApO1xyXG5cclxuXHRcdFx0dGhpcy5hcHBseU1hdHJpeCggbTEgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0cm90YXRlWTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdC8vIHJvdGF0ZSBnZW9tZXRyeSBhcm91bmQgd29ybGQgeS1heGlzXHJcblxyXG5cdFx0dmFyIG0xO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiByb3RhdGVZKCBhbmdsZSApIHtcclxuXHJcblx0XHRcdGlmICggbTEgPT09IHVuZGVmaW5lZCApIG0xID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHJcblx0XHRcdG0xLm1ha2VSb3RhdGlvblkoIGFuZ2xlICk7XHJcblxyXG5cdFx0XHR0aGlzLmFwcGx5TWF0cml4KCBtMSApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRyb3RhdGVaOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0Ly8gcm90YXRlIGdlb21ldHJ5IGFyb3VuZCB3b3JsZCB6LWF4aXNcclxuXHJcblx0XHR2YXIgbTE7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHJvdGF0ZVooIGFuZ2xlICkge1xyXG5cclxuXHRcdFx0aWYgKCBtMSA9PT0gdW5kZWZpbmVkICkgbTEgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xyXG5cclxuXHRcdFx0bTEubWFrZVJvdGF0aW9uWiggYW5nbGUgKTtcclxuXHJcblx0XHRcdHRoaXMuYXBwbHlNYXRyaXgoIG0xICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdHRyYW5zbGF0ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdC8vIHRyYW5zbGF0ZSBnZW9tZXRyeVxyXG5cclxuXHRcdHZhciBtMTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gdHJhbnNsYXRlKCB4LCB5LCB6ICkge1xyXG5cclxuXHRcdFx0aWYgKCBtMSA9PT0gdW5kZWZpbmVkICkgbTEgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xyXG5cclxuXHRcdFx0bTEubWFrZVRyYW5zbGF0aW9uKCB4LCB5LCB6ICk7XHJcblxyXG5cdFx0XHR0aGlzLmFwcGx5TWF0cml4KCBtMSApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRzY2FsZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdC8vIHNjYWxlIGdlb21ldHJ5XHJcblxyXG5cdFx0dmFyIG0xO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiBzY2FsZSggeCwgeSwgeiApIHtcclxuXHJcblx0XHRcdGlmICggbTEgPT09IHVuZGVmaW5lZCApIG0xID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHJcblx0XHRcdG0xLm1ha2VTY2FsZSggeCwgeSwgeiApO1xyXG5cclxuXHRcdFx0dGhpcy5hcHBseU1hdHJpeCggbTEgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0bG9va0F0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIG9iajtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gbG9va0F0KCB2ZWN0b3IgKSB7XHJcblxyXG5cdFx0XHRpZiAoIG9iaiA9PT0gdW5kZWZpbmVkICkgb2JqID0gbmV3IFRIUkVFLk9iamVjdDNEKCk7XHJcblxyXG5cdFx0XHRvYmoubG9va0F0KCB2ZWN0b3IgKTtcclxuXHJcblx0XHRcdG9iai51cGRhdGVNYXRyaXgoKTtcclxuXHJcblx0XHRcdHRoaXMuYXBwbHlNYXRyaXgoIG9iai5tYXRyaXggKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGZyb21CdWZmZXJHZW9tZXRyeTogZnVuY3Rpb24gKCBnZW9tZXRyeSApIHtcclxuXHJcblx0XHR2YXIgc2NvcGUgPSB0aGlzO1xyXG5cclxuXHRcdHZhciBpbmRpY2VzID0gZ2VvbWV0cnkuaW5kZXggIT09IG51bGwgPyBnZW9tZXRyeS5pbmRleC5hcnJheSA6IHVuZGVmaW5lZDtcclxuXHRcdHZhciBhdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcclxuXHJcblx0XHR2YXIgcG9zaXRpb25zID0gYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcclxuXHRcdHZhciBub3JtYWxzID0gYXR0cmlidXRlcy5ub3JtYWwgIT09IHVuZGVmaW5lZCA/IGF0dHJpYnV0ZXMubm9ybWFsLmFycmF5IDogdW5kZWZpbmVkO1xyXG5cdFx0dmFyIGNvbG9ycyA9IGF0dHJpYnV0ZXMuY29sb3IgIT09IHVuZGVmaW5lZCA/IGF0dHJpYnV0ZXMuY29sb3IuYXJyYXkgOiB1bmRlZmluZWQ7XHJcblx0XHR2YXIgdXZzID0gYXR0cmlidXRlcy51diAhPT0gdW5kZWZpbmVkID8gYXR0cmlidXRlcy51di5hcnJheSA6IHVuZGVmaW5lZDtcclxuXHRcdHZhciB1dnMyID0gYXR0cmlidXRlcy51djIgIT09IHVuZGVmaW5lZCA/IGF0dHJpYnV0ZXMudXYyLmFycmF5IDogdW5kZWZpbmVkO1xyXG5cclxuXHRcdGlmICggdXZzMiAhPT0gdW5kZWZpbmVkICkgdGhpcy5mYWNlVmVydGV4VXZzWyAxIF0gPSBbXTtcclxuXHJcblx0XHR2YXIgdGVtcE5vcm1hbHMgPSBbXTtcclxuXHRcdHZhciB0ZW1wVVZzID0gW107XHJcblx0XHR2YXIgdGVtcFVWczIgPSBbXTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGogPSAwOyBpIDwgcG9zaXRpb25zLmxlbmd0aDsgaSArPSAzLCBqICs9IDIgKSB7XHJcblxyXG5cdFx0XHRzY29wZS52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMyggcG9zaXRpb25zWyBpIF0sIHBvc2l0aW9uc1sgaSArIDEgXSwgcG9zaXRpb25zWyBpICsgMiBdICkgKTtcclxuXHJcblx0XHRcdGlmICggbm9ybWFscyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHR0ZW1wTm9ybWFscy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMyggbm9ybWFsc1sgaSBdLCBub3JtYWxzWyBpICsgMSBdLCBub3JtYWxzWyBpICsgMiBdICkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggY29sb3JzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdHNjb3BlLmNvbG9ycy5wdXNoKCBuZXcgVEhSRUUuQ29sb3IoIGNvbG9yc1sgaSBdLCBjb2xvcnNbIGkgKyAxIF0sIGNvbG9yc1sgaSArIDIgXSApICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIHV2cyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHR0ZW1wVVZzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCB1dnNbIGogXSwgdXZzWyBqICsgMSBdICkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggdXZzMiAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHR0ZW1wVVZzMi5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMiggdXZzMlsgaiBdLCB1dnMyWyBqICsgMSBdICkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gYWRkRmFjZSggYSwgYiwgYyApIHtcclxuXHJcblx0XHRcdHZhciB2ZXJ0ZXhOb3JtYWxzID0gbm9ybWFscyAhPT0gdW5kZWZpbmVkID8gWyB0ZW1wTm9ybWFsc1sgYSBdLmNsb25lKCksIHRlbXBOb3JtYWxzWyBiIF0uY2xvbmUoKSwgdGVtcE5vcm1hbHNbIGMgXS5jbG9uZSgpIF0gOiBbXTtcclxuXHRcdFx0dmFyIHZlcnRleENvbG9ycyA9IGNvbG9ycyAhPT0gdW5kZWZpbmVkID8gWyBzY29wZS5jb2xvcnNbIGEgXS5jbG9uZSgpLCBzY29wZS5jb2xvcnNbIGIgXS5jbG9uZSgpLCBzY29wZS5jb2xvcnNbIGMgXS5jbG9uZSgpIF0gOiBbXTtcclxuXHJcblx0XHRcdHZhciBmYWNlID0gbmV3IFRIUkVFLkZhY2UzKCBhLCBiLCBjLCB2ZXJ0ZXhOb3JtYWxzLCB2ZXJ0ZXhDb2xvcnMgKTtcclxuXHJcblx0XHRcdHNjb3BlLmZhY2VzLnB1c2goIGZhY2UgKTtcclxuXHJcblx0XHRcdGlmICggdXZzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdHNjb3BlLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHRlbXBVVnNbIGEgXS5jbG9uZSgpLCB0ZW1wVVZzWyBiIF0uY2xvbmUoKSwgdGVtcFVWc1sgYyBdLmNsb25lKCkgXSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCB1dnMyICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdHNjb3BlLmZhY2VWZXJ0ZXhVdnNbIDEgXS5wdXNoKCBbIHRlbXBVVnMyWyBhIF0uY2xvbmUoKSwgdGVtcFVWczJbIGIgXS5jbG9uZSgpLCB0ZW1wVVZzMlsgYyBdLmNsb25lKCkgXSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGluZGljZXMgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHZhciBncm91cHMgPSBnZW9tZXRyeS5ncm91cHM7XHJcblxyXG5cdFx0XHRpZiAoIGdyb3Vwcy5sZW5ndGggPiAwICkge1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciBncm91cCA9IGdyb3Vwc1sgaSBdO1xyXG5cclxuXHRcdFx0XHRcdHZhciBzdGFydCA9IGdyb3VwLnN0YXJ0O1xyXG5cdFx0XHRcdFx0dmFyIGNvdW50ID0gZ3JvdXAuY291bnQ7XHJcblxyXG5cdFx0XHRcdFx0Zm9yICggdmFyIGogPSBzdGFydCwgamwgPSBzdGFydCArIGNvdW50OyBqIDwgamw7IGogKz0gMyApIHtcclxuXHJcblx0XHRcdFx0XHRcdGFkZEZhY2UoIGluZGljZXNbIGogXSwgaW5kaWNlc1sgaiArIDEgXSwgaW5kaWNlc1sgaiArIDIgXSApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgaW5kaWNlcy5sZW5ndGg7IGkgKz0gMyApIHtcclxuXHJcblx0XHRcdFx0XHRhZGRGYWNlKCBpbmRpY2VzWyBpIF0sIGluZGljZXNbIGkgKyAxIF0sIGluZGljZXNbIGkgKyAyIF0gKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBwb3NpdGlvbnMubGVuZ3RoIC8gMzsgaSArPSAzICkge1xyXG5cclxuXHRcdFx0XHRhZGRGYWNlKCBpLCBpICsgMSwgaSArIDIgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nQm94ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0dGhpcy5ib3VuZGluZ0JveCA9IGdlb21ldHJ5LmJvdW5kaW5nQm94LmNsb25lKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUuY2xvbmUoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNlbnRlcjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMuY29tcHV0ZUJvdW5kaW5nQm94KCk7XHJcblxyXG5cdFx0dmFyIG9mZnNldCA9IHRoaXMuYm91bmRpbmdCb3guY2VudGVyKCkubmVnYXRlKCk7XHJcblxyXG5cdFx0dGhpcy50cmFuc2xhdGUoIG9mZnNldC54LCBvZmZzZXQueSwgb2Zmc2V0LnogKTtcclxuXHJcblx0XHRyZXR1cm4gb2Zmc2V0O1xyXG5cclxuXHR9LFxyXG5cclxuXHRub3JtYWxpemU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xyXG5cclxuXHRcdHZhciBjZW50ZXIgPSB0aGlzLmJvdW5kaW5nU3BoZXJlLmNlbnRlcjtcclxuXHRcdHZhciByYWRpdXMgPSB0aGlzLmJvdW5kaW5nU3BoZXJlLnJhZGl1cztcclxuXHJcblx0XHR2YXIgcyA9IHJhZGl1cyA9PT0gMCA/IDEgOiAxLjAgLyByYWRpdXM7XHJcblxyXG5cdFx0dmFyIG1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblx0XHRtYXRyaXguc2V0KFxyXG5cdFx0XHRzLCAwLCAwLCAtIHMgKiBjZW50ZXIueCxcclxuXHRcdFx0MCwgcywgMCwgLSBzICogY2VudGVyLnksXHJcblx0XHRcdDAsIDAsIHMsIC0gcyAqIGNlbnRlci56LFxyXG5cdFx0XHQwLCAwLCAwLCAxXHJcblx0XHQpO1xyXG5cclxuXHRcdHRoaXMuYXBwbHlNYXRyaXgoIG1hdHJpeCApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb21wdXRlRmFjZU5vcm1hbHM6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgY2IgPSBuZXcgVEhSRUUuVmVjdG9yMygpLCBhYiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0Zm9yICggdmFyIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcclxuXHJcblx0XHRcdHZhciB2QSA9IHRoaXMudmVydGljZXNbIGZhY2UuYSBdO1xyXG5cdFx0XHR2YXIgdkIgPSB0aGlzLnZlcnRpY2VzWyBmYWNlLmIgXTtcclxuXHRcdFx0dmFyIHZDID0gdGhpcy52ZXJ0aWNlc1sgZmFjZS5jIF07XHJcblxyXG5cdFx0XHRjYi5zdWJWZWN0b3JzKCB2QywgdkIgKTtcclxuXHRcdFx0YWIuc3ViVmVjdG9ycyggdkEsIHZCICk7XHJcblx0XHRcdGNiLmNyb3NzKCBhYiApO1xyXG5cclxuXHRcdFx0Y2Iubm9ybWFsaXplKCk7XHJcblxyXG5cdFx0XHRmYWNlLm5vcm1hbC5jb3B5KCBjYiApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0Y29tcHV0ZVZlcnRleE5vcm1hbHM6IGZ1bmN0aW9uICggYXJlYVdlaWdodGVkICkge1xyXG5cclxuXHRcdGlmICggYXJlYVdlaWdodGVkID09PSB1bmRlZmluZWQgKSBhcmVhV2VpZ2h0ZWQgPSB0cnVlO1xyXG5cclxuXHRcdHZhciB2LCB2bCwgZiwgZmwsIGZhY2UsIHZlcnRpY2VzO1xyXG5cclxuXHRcdHZlcnRpY2VzID0gbmV3IEFycmF5KCB0aGlzLnZlcnRpY2VzLmxlbmd0aCApO1xyXG5cclxuXHRcdGZvciAoIHYgPSAwLCB2bCA9IHRoaXMudmVydGljZXMubGVuZ3RoOyB2IDwgdmw7IHYgKysgKSB7XHJcblxyXG5cdFx0XHR2ZXJ0aWNlc1sgdiBdID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBhcmVhV2VpZ2h0ZWQgKSB7XHJcblxyXG5cdFx0XHQvLyB2ZXJ0ZXggbm9ybWFscyB3ZWlnaHRlZCBieSB0cmlhbmdsZSBhcmVhc1xyXG5cdFx0XHQvLyBodHRwOi8vd3d3LmlxdWlsZXpsZXMub3JnL3d3dy9hcnRpY2xlcy9ub3JtYWxzL25vcm1hbHMuaHRtXHJcblxyXG5cdFx0XHR2YXIgdkEsIHZCLCB2QztcclxuXHRcdFx0dmFyIGNiID0gbmV3IFRIUkVFLlZlY3RvcjMoKSwgYWIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdFx0Zm9yICggZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcclxuXHJcblx0XHRcdFx0ZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcclxuXHJcblx0XHRcdFx0dkEgPSB0aGlzLnZlcnRpY2VzWyBmYWNlLmEgXTtcclxuXHRcdFx0XHR2QiA9IHRoaXMudmVydGljZXNbIGZhY2UuYiBdO1xyXG5cdFx0XHRcdHZDID0gdGhpcy52ZXJ0aWNlc1sgZmFjZS5jIF07XHJcblxyXG5cdFx0XHRcdGNiLnN1YlZlY3RvcnMoIHZDLCB2QiApO1xyXG5cdFx0XHRcdGFiLnN1YlZlY3RvcnMoIHZBLCB2QiApO1xyXG5cdFx0XHRcdGNiLmNyb3NzKCBhYiApO1xyXG5cclxuXHRcdFx0XHR2ZXJ0aWNlc1sgZmFjZS5hIF0uYWRkKCBjYiApO1xyXG5cdFx0XHRcdHZlcnRpY2VzWyBmYWNlLmIgXS5hZGQoIGNiICk7XHJcblx0XHRcdFx0dmVydGljZXNbIGZhY2UuYyBdLmFkZCggY2IgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0Zm9yICggZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcclxuXHJcblx0XHRcdFx0ZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcclxuXHJcblx0XHRcdFx0dmVydGljZXNbIGZhY2UuYSBdLmFkZCggZmFjZS5ub3JtYWwgKTtcclxuXHRcdFx0XHR2ZXJ0aWNlc1sgZmFjZS5iIF0uYWRkKCBmYWNlLm5vcm1hbCApO1xyXG5cdFx0XHRcdHZlcnRpY2VzWyBmYWNlLmMgXS5hZGQoIGZhY2Uubm9ybWFsICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoIHYgPSAwLCB2bCA9IHRoaXMudmVydGljZXMubGVuZ3RoOyB2IDwgdmw7IHYgKysgKSB7XHJcblxyXG5cdFx0XHR2ZXJ0aWNlc1sgdiBdLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuXHRcdFx0ZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcclxuXHJcblx0XHRcdHZhciB2ZXJ0ZXhOb3JtYWxzID0gZmFjZS52ZXJ0ZXhOb3JtYWxzO1xyXG5cclxuXHRcdFx0aWYgKCB2ZXJ0ZXhOb3JtYWxzLmxlbmd0aCA9PT0gMyApIHtcclxuXHJcblx0XHRcdFx0dmVydGV4Tm9ybWFsc1sgMCBdLmNvcHkoIHZlcnRpY2VzWyBmYWNlLmEgXSApO1xyXG5cdFx0XHRcdHZlcnRleE5vcm1hbHNbIDEgXS5jb3B5KCB2ZXJ0aWNlc1sgZmFjZS5iIF0gKTtcclxuXHRcdFx0XHR2ZXJ0ZXhOb3JtYWxzWyAyIF0uY29weSggdmVydGljZXNbIGZhY2UuYyBdICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHR2ZXJ0ZXhOb3JtYWxzWyAwIF0gPSB2ZXJ0aWNlc1sgZmFjZS5hIF0uY2xvbmUoKTtcclxuXHRcdFx0XHR2ZXJ0ZXhOb3JtYWxzWyAxIF0gPSB2ZXJ0aWNlc1sgZmFjZS5iIF0uY2xvbmUoKTtcclxuXHRcdFx0XHR2ZXJ0ZXhOb3JtYWxzWyAyIF0gPSB2ZXJ0aWNlc1sgZmFjZS5jIF0uY2xvbmUoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0aGlzLmZhY2VzLmxlbmd0aCA+IDAgKSB7XHJcblxyXG5cdFx0XHR0aGlzLm5vcm1hbHNOZWVkVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvbXB1dGVNb3JwaE5vcm1hbHM6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgaSwgaWwsIGYsIGZsLCBmYWNlO1xyXG5cclxuXHRcdC8vIHNhdmUgb3JpZ2luYWwgbm9ybWFsc1xyXG5cdFx0Ly8gLSBjcmVhdGUgdGVtcCB2YXJpYWJsZXMgb24gZmlyc3QgYWNjZXNzXHJcblx0XHQvLyAgIG90aGVyd2lzZSBqdXN0IGNvcHkgKGZvciBmYXN0ZXIgcmVwZWF0ZWQgY2FsbHMpXHJcblxyXG5cdFx0Zm9yICggZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcclxuXHJcblx0XHRcdGZhY2UgPSB0aGlzLmZhY2VzWyBmIF07XHJcblxyXG5cdFx0XHRpZiAoICEgZmFjZS5fX29yaWdpbmFsRmFjZU5vcm1hbCApIHtcclxuXHJcblx0XHRcdFx0ZmFjZS5fX29yaWdpbmFsRmFjZU5vcm1hbCA9IGZhY2Uubm9ybWFsLmNsb25lKCk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRmYWNlLl9fb3JpZ2luYWxGYWNlTm9ybWFsLmNvcHkoIGZhY2Uubm9ybWFsICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoICEgZmFjZS5fX29yaWdpbmFsVmVydGV4Tm9ybWFscyApIGZhY2UuX19vcmlnaW5hbFZlcnRleE5vcm1hbHMgPSBbXTtcclxuXHJcblx0XHRcdGZvciAoIGkgPSAwLCBpbCA9IGZhY2UudmVydGV4Tm9ybWFscy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0aWYgKCAhIGZhY2UuX19vcmlnaW5hbFZlcnRleE5vcm1hbHNbIGkgXSApIHtcclxuXHJcblx0XHRcdFx0XHRmYWNlLl9fb3JpZ2luYWxWZXJ0ZXhOb3JtYWxzWyBpIF0gPSBmYWNlLnZlcnRleE5vcm1hbHNbIGkgXS5jbG9uZSgpO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdGZhY2UuX19vcmlnaW5hbFZlcnRleE5vcm1hbHNbIGkgXS5jb3B5KCBmYWNlLnZlcnRleE5vcm1hbHNbIGkgXSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHVzZSB0ZW1wIGdlb21ldHJ5IHRvIGNvbXB1dGUgZmFjZSBhbmQgdmVydGV4IG5vcm1hbHMgZm9yIGVhY2ggbW9ycGhcclxuXHJcblx0XHR2YXIgdG1wR2VvID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XHJcblx0XHR0bXBHZW8uZmFjZXMgPSB0aGlzLmZhY2VzO1xyXG5cclxuXHRcdGZvciAoIGkgPSAwLCBpbCA9IHRoaXMubW9ycGhUYXJnZXRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0Ly8gY3JlYXRlIG9uIGZpcnN0IGFjY2Vzc1xyXG5cclxuXHRcdFx0aWYgKCAhIHRoaXMubW9ycGhOb3JtYWxzWyBpIF0gKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMubW9ycGhOb3JtYWxzWyBpIF0gPSB7fTtcclxuXHRcdFx0XHR0aGlzLm1vcnBoTm9ybWFsc1sgaSBdLmZhY2VOb3JtYWxzID0gW107XHJcblx0XHRcdFx0dGhpcy5tb3JwaE5vcm1hbHNbIGkgXS52ZXJ0ZXhOb3JtYWxzID0gW107XHJcblxyXG5cdFx0XHRcdHZhciBkc3ROb3JtYWxzRmFjZSA9IHRoaXMubW9ycGhOb3JtYWxzWyBpIF0uZmFjZU5vcm1hbHM7XHJcblx0XHRcdFx0dmFyIGRzdE5vcm1hbHNWZXJ0ZXggPSB0aGlzLm1vcnBoTm9ybWFsc1sgaSBdLnZlcnRleE5vcm1hbHM7XHJcblxyXG5cdFx0XHRcdHZhciBmYWNlTm9ybWFsLCB2ZXJ0ZXhOb3JtYWxzO1xyXG5cclxuXHRcdFx0XHRmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuXHRcdFx0XHRcdGZhY2VOb3JtYWwgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0XHRcdFx0dmVydGV4Tm9ybWFscyA9IHsgYTogbmV3IFRIUkVFLlZlY3RvcjMoKSwgYjogbmV3IFRIUkVFLlZlY3RvcjMoKSwgYzogbmV3IFRIUkVFLlZlY3RvcjMoKSB9O1xyXG5cclxuXHRcdFx0XHRcdGRzdE5vcm1hbHNGYWNlLnB1c2goIGZhY2VOb3JtYWwgKTtcclxuXHRcdFx0XHRcdGRzdE5vcm1hbHNWZXJ0ZXgucHVzaCggdmVydGV4Tm9ybWFscyApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgbW9ycGhOb3JtYWxzID0gdGhpcy5tb3JwaE5vcm1hbHNbIGkgXTtcclxuXHJcblx0XHRcdC8vIHNldCB2ZXJ0aWNlcyB0byBtb3JwaCB0YXJnZXRcclxuXHJcblx0XHRcdHRtcEdlby52ZXJ0aWNlcyA9IHRoaXMubW9ycGhUYXJnZXRzWyBpIF0udmVydGljZXM7XHJcblxyXG5cdFx0XHQvLyBjb21wdXRlIG1vcnBoIG5vcm1hbHNcclxuXHJcblx0XHRcdHRtcEdlby5jb21wdXRlRmFjZU5vcm1hbHMoKTtcclxuXHRcdFx0dG1wR2VvLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7XHJcblxyXG5cdFx0XHQvLyBzdG9yZSBtb3JwaCBub3JtYWxzXHJcblxyXG5cdFx0XHR2YXIgZmFjZU5vcm1hbCwgdmVydGV4Tm9ybWFscztcclxuXHJcblx0XHRcdGZvciAoIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XHJcblxyXG5cdFx0XHRcdGZhY2UgPSB0aGlzLmZhY2VzWyBmIF07XHJcblxyXG5cdFx0XHRcdGZhY2VOb3JtYWwgPSBtb3JwaE5vcm1hbHMuZmFjZU5vcm1hbHNbIGYgXTtcclxuXHRcdFx0XHR2ZXJ0ZXhOb3JtYWxzID0gbW9ycGhOb3JtYWxzLnZlcnRleE5vcm1hbHNbIGYgXTtcclxuXHJcblx0XHRcdFx0ZmFjZU5vcm1hbC5jb3B5KCBmYWNlLm5vcm1hbCApO1xyXG5cclxuXHRcdFx0XHR2ZXJ0ZXhOb3JtYWxzLmEuY29weSggZmFjZS52ZXJ0ZXhOb3JtYWxzWyAwIF0gKTtcclxuXHRcdFx0XHR2ZXJ0ZXhOb3JtYWxzLmIuY29weSggZmFjZS52ZXJ0ZXhOb3JtYWxzWyAxIF0gKTtcclxuXHRcdFx0XHR2ZXJ0ZXhOb3JtYWxzLmMuY29weSggZmFjZS52ZXJ0ZXhOb3JtYWxzWyAyIF0gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gcmVzdG9yZSBvcmlnaW5hbCBub3JtYWxzXHJcblxyXG5cdFx0Zm9yICggZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcclxuXHJcblx0XHRcdGZhY2UgPSB0aGlzLmZhY2VzWyBmIF07XHJcblxyXG5cdFx0XHRmYWNlLm5vcm1hbCA9IGZhY2UuX19vcmlnaW5hbEZhY2VOb3JtYWw7XHJcblx0XHRcdGZhY2UudmVydGV4Tm9ybWFscyA9IGZhY2UuX19vcmlnaW5hbFZlcnRleE5vcm1hbHM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHRjb21wdXRlVGFuZ2VudHM6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5HZW9tZXRyeTogLmNvbXB1dGVUYW5nZW50cygpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb21wdXRlTGluZURpc3RhbmNlczogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBkID0gMDtcclxuXHRcdHZhciB2ZXJ0aWNlcyA9IHRoaXMudmVydGljZXM7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHZlcnRpY2VzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0aWYgKCBpID4gMCApIHtcclxuXHJcblx0XHRcdFx0ZCArPSB2ZXJ0aWNlc1sgaSBdLmRpc3RhbmNlVG8oIHZlcnRpY2VzWyBpIC0gMSBdICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmxpbmVEaXN0YW5jZXNbIGkgXSA9IGQ7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHRjb21wdXRlQm91bmRpbmdCb3g6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRpZiAoIHRoaXMuYm91bmRpbmdCb3ggPT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmJvdW5kaW5nQm94ID0gbmV3IFRIUkVFLkJveDMoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5ib3VuZGluZ0JveC5zZXRGcm9tUG9pbnRzKCB0aGlzLnZlcnRpY2VzICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvbXB1dGVCb3VuZGluZ1NwaGVyZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdGlmICggdGhpcy5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBuZXcgVEhSRUUuU3BoZXJlKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuYm91bmRpbmdTcGhlcmUuc2V0RnJvbVBvaW50cyggdGhpcy52ZXJ0aWNlcyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtZXJnZTogZnVuY3Rpb24gKCBnZW9tZXRyeSwgbWF0cml4LCBtYXRlcmlhbEluZGV4T2Zmc2V0ICkge1xyXG5cclxuXHRcdGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5HZW9tZXRyeSA9PT0gZmFsc2UgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuR2VvbWV0cnkubWVyZ2UoKTogZ2VvbWV0cnkgbm90IGFuIGluc3RhbmNlIG9mIFRIUkVFLkdlb21ldHJ5LicsIGdlb21ldHJ5ICk7XHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG5vcm1hbE1hdHJpeCxcclxuXHRcdHZlcnRleE9mZnNldCA9IHRoaXMudmVydGljZXMubGVuZ3RoLFxyXG5cdFx0dmVydGljZXMxID0gdGhpcy52ZXJ0aWNlcyxcclxuXHRcdHZlcnRpY2VzMiA9IGdlb21ldHJ5LnZlcnRpY2VzLFxyXG5cdFx0ZmFjZXMxID0gdGhpcy5mYWNlcyxcclxuXHRcdGZhY2VzMiA9IGdlb21ldHJ5LmZhY2VzLFxyXG5cdFx0dXZzMSA9IHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLFxyXG5cdFx0dXZzMiA9IGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIDAgXTtcclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsSW5kZXhPZmZzZXQgPT09IHVuZGVmaW5lZCApIG1hdGVyaWFsSW5kZXhPZmZzZXQgPSAwO1xyXG5cclxuXHRcdGlmICggbWF0cml4ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRub3JtYWxNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4MygpLmdldE5vcm1hbE1hdHJpeCggbWF0cml4ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHZlcnRpY2VzXHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHZlcnRpY2VzMi5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciB2ZXJ0ZXggPSB2ZXJ0aWNlczJbIGkgXTtcclxuXHJcblx0XHRcdHZhciB2ZXJ0ZXhDb3B5ID0gdmVydGV4LmNsb25lKCk7XHJcblxyXG5cdFx0XHRpZiAoIG1hdHJpeCAhPT0gdW5kZWZpbmVkICkgdmVydGV4Q29weS5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1xyXG5cclxuXHRcdFx0dmVydGljZXMxLnB1c2goIHZlcnRleENvcHkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gZmFjZXNcclxuXHJcblx0XHRmb3IgKCBpID0gMCwgaWwgPSBmYWNlczIubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgZmFjZSA9IGZhY2VzMlsgaSBdLCBmYWNlQ29weSwgbm9ybWFsLCBjb2xvcixcclxuXHRcdFx0ZmFjZVZlcnRleE5vcm1hbHMgPSBmYWNlLnZlcnRleE5vcm1hbHMsXHJcblx0XHRcdGZhY2VWZXJ0ZXhDb2xvcnMgPSBmYWNlLnZlcnRleENvbG9ycztcclxuXHJcblx0XHRcdGZhY2VDb3B5ID0gbmV3IFRIUkVFLkZhY2UzKCBmYWNlLmEgKyB2ZXJ0ZXhPZmZzZXQsIGZhY2UuYiArIHZlcnRleE9mZnNldCwgZmFjZS5jICsgdmVydGV4T2Zmc2V0ICk7XHJcblx0XHRcdGZhY2VDb3B5Lm5vcm1hbC5jb3B5KCBmYWNlLm5vcm1hbCApO1xyXG5cclxuXHRcdFx0aWYgKCBub3JtYWxNYXRyaXggIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0ZmFjZUNvcHkubm9ybWFsLmFwcGx5TWF0cml4Myggbm9ybWFsTWF0cml4ICkubm9ybWFsaXplKCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gZmFjZVZlcnRleE5vcm1hbHMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdG5vcm1hbCA9IGZhY2VWZXJ0ZXhOb3JtYWxzWyBqIF0uY2xvbmUoKTtcclxuXHJcblx0XHRcdFx0aWYgKCBub3JtYWxNYXRyaXggIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRub3JtYWwuYXBwbHlNYXRyaXgzKCBub3JtYWxNYXRyaXggKS5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRmYWNlQ29weS52ZXJ0ZXhOb3JtYWxzLnB1c2goIG5vcm1hbCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0ZmFjZUNvcHkuY29sb3IuY29weSggZmFjZS5jb2xvciApO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IGZhY2VWZXJ0ZXhDb2xvcnMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdGNvbG9yID0gZmFjZVZlcnRleENvbG9yc1sgaiBdO1xyXG5cdFx0XHRcdGZhY2VDb3B5LnZlcnRleENvbG9ycy5wdXNoKCBjb2xvci5jbG9uZSgpICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmYWNlQ29weS5tYXRlcmlhbEluZGV4ID0gZmFjZS5tYXRlcmlhbEluZGV4ICsgbWF0ZXJpYWxJbmRleE9mZnNldDtcclxuXHJcblx0XHRcdGZhY2VzMS5wdXNoKCBmYWNlQ29weSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyB1dnNcclxuXHJcblx0XHRmb3IgKCBpID0gMCwgaWwgPSB1dnMyLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIHV2ID0gdXZzMlsgaSBdLCB1dkNvcHkgPSBbXTtcclxuXHJcblx0XHRcdGlmICggdXYgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0Y29udGludWU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gdXYubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdHV2Q29weS5wdXNoKCB1dlsgaiBdLmNsb25lKCkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHV2czEucHVzaCggdXZDb3B5ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHRtZXJnZU1lc2g6IGZ1bmN0aW9uICggbWVzaCApIHtcclxuXHJcblx0XHRpZiAoIG1lc2ggaW5zdGFuY2VvZiBUSFJFRS5NZXNoID09PSBmYWxzZSApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5HZW9tZXRyeS5tZXJnZU1lc2goKTogbWVzaCBub3QgYW4gaW5zdGFuY2Ugb2YgVEhSRUUuTWVzaC4nLCBtZXNoICk7XHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0bWVzaC5tYXRyaXhBdXRvVXBkYXRlICYmIG1lc2gudXBkYXRlTWF0cml4KCk7XHJcblxyXG5cdFx0dGhpcy5tZXJnZSggbWVzaC5nZW9tZXRyeSwgbWVzaC5tYXRyaXggKTtcclxuXHJcblx0fSxcclxuXHJcblx0LypcclxuXHQgKiBDaGVja3MgZm9yIGR1cGxpY2F0ZSB2ZXJ0aWNlcyB3aXRoIGhhc2htYXAuXHJcblx0ICogRHVwbGljYXRlZCB2ZXJ0aWNlcyBhcmUgcmVtb3ZlZFxyXG5cdCAqIGFuZCBmYWNlcycgdmVydGljZXMgYXJlIHVwZGF0ZWQuXHJcblx0ICovXHJcblxyXG5cdG1lcmdlVmVydGljZXM6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdmVydGljZXNNYXAgPSB7fTsgLy8gSGFzaG1hcCBmb3IgbG9va2luZyB1cCB2ZXJ0aWNlcyBieSBwb3NpdGlvbiBjb29yZGluYXRlcyAoYW5kIG1ha2luZyBzdXJlIHRoZXkgYXJlIHVuaXF1ZSlcclxuXHRcdHZhciB1bmlxdWUgPSBbXSwgY2hhbmdlcyA9IFtdO1xyXG5cclxuXHRcdHZhciB2LCBrZXk7XHJcblx0XHR2YXIgcHJlY2lzaW9uUG9pbnRzID0gNDsgLy8gbnVtYmVyIG9mIGRlY2ltYWwgcG9pbnRzLCBlLmcuIDQgZm9yIGVwc2lsb24gb2YgMC4wMDAxXHJcblx0XHR2YXIgcHJlY2lzaW9uID0gTWF0aC5wb3coIDEwLCBwcmVjaXNpb25Qb2ludHMgKTtcclxuXHRcdHZhciBpLCBpbCwgZmFjZTtcclxuXHRcdHZhciBpbmRpY2VzLCBqLCBqbDtcclxuXHJcblx0XHRmb3IgKCBpID0gMCwgaWwgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0diA9IHRoaXMudmVydGljZXNbIGkgXTtcclxuXHRcdFx0a2V5ID0gTWF0aC5yb3VuZCggdi54ICogcHJlY2lzaW9uICkgKyAnXycgKyBNYXRoLnJvdW5kKCB2LnkgKiBwcmVjaXNpb24gKSArICdfJyArIE1hdGgucm91bmQoIHYueiAqIHByZWNpc2lvbiApO1xyXG5cclxuXHRcdFx0aWYgKCB2ZXJ0aWNlc01hcFsga2V5IF0gPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0dmVydGljZXNNYXBbIGtleSBdID0gaTtcclxuXHRcdFx0XHR1bmlxdWUucHVzaCggdGhpcy52ZXJ0aWNlc1sgaSBdICk7XHJcblx0XHRcdFx0Y2hhbmdlc1sgaSBdID0gdW5pcXVlLmxlbmd0aCAtIDE7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHQvL2NvbnNvbGUubG9nKCdEdXBsaWNhdGUgdmVydGV4IGZvdW5kLiAnLCBpLCAnIGNvdWxkIGJlIHVzaW5nICcsIHZlcnRpY2VzTWFwW2tleV0pO1xyXG5cdFx0XHRcdGNoYW5nZXNbIGkgXSA9IGNoYW5nZXNbIHZlcnRpY2VzTWFwWyBrZXkgXSBdO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblxyXG5cdFx0Ly8gaWYgZmFjZXMgYXJlIGNvbXBsZXRlbHkgZGVnZW5lcmF0ZSBhZnRlciBtZXJnaW5nIHZlcnRpY2VzLCB3ZVxyXG5cdFx0Ly8gaGF2ZSB0byByZW1vdmUgdGhlbSBmcm9tIHRoZSBnZW9tZXRyeS5cclxuXHRcdHZhciBmYWNlSW5kaWNlc1RvUmVtb3ZlID0gW107XHJcblxyXG5cdFx0Zm9yICggaSA9IDAsIGlsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdGZhY2UgPSB0aGlzLmZhY2VzWyBpIF07XHJcblxyXG5cdFx0XHRmYWNlLmEgPSBjaGFuZ2VzWyBmYWNlLmEgXTtcclxuXHRcdFx0ZmFjZS5iID0gY2hhbmdlc1sgZmFjZS5iIF07XHJcblx0XHRcdGZhY2UuYyA9IGNoYW5nZXNbIGZhY2UuYyBdO1xyXG5cclxuXHRcdFx0aW5kaWNlcyA9IFsgZmFjZS5hLCBmYWNlLmIsIGZhY2UuYyBdO1xyXG5cclxuXHRcdFx0dmFyIGR1cEluZGV4ID0gLSAxO1xyXG5cclxuXHRcdFx0Ly8gaWYgYW55IGR1cGxpY2F0ZSB2ZXJ0aWNlcyBhcmUgZm91bmQgaW4gYSBGYWNlM1xyXG5cdFx0XHQvLyB3ZSBoYXZlIHRvIHJlbW92ZSB0aGUgZmFjZSBhcyBub3RoaW5nIGNhbiBiZSBzYXZlZFxyXG5cdFx0XHRmb3IgKCB2YXIgbiA9IDA7IG4gPCAzOyBuICsrICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIGluZGljZXNbIG4gXSA9PT0gaW5kaWNlc1sgKCBuICsgMSApICUgMyBdICkge1xyXG5cclxuXHRcdFx0XHRcdGR1cEluZGV4ID0gbjtcclxuXHRcdFx0XHRcdGZhY2VJbmRpY2VzVG9SZW1vdmUucHVzaCggaSApO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICggaSA9IGZhY2VJbmRpY2VzVG9SZW1vdmUubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC0tICkge1xyXG5cclxuXHRcdFx0dmFyIGlkeCA9IGZhY2VJbmRpY2VzVG9SZW1vdmVbIGkgXTtcclxuXHJcblx0XHRcdHRoaXMuZmFjZXMuc3BsaWNlKCBpZHgsIDEgKTtcclxuXHJcblx0XHRcdGZvciAoIGogPSAwLCBqbCA9IHRoaXMuZmFjZVZlcnRleFV2cy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5mYWNlVmVydGV4VXZzWyBqIF0uc3BsaWNlKCBpZHgsIDEgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gVXNlIHVuaXF1ZSBzZXQgb2YgdmVydGljZXNcclxuXHJcblx0XHR2YXIgZGlmZiA9IHRoaXMudmVydGljZXMubGVuZ3RoIC0gdW5pcXVlLmxlbmd0aDtcclxuXHRcdHRoaXMudmVydGljZXMgPSB1bmlxdWU7XHJcblx0XHRyZXR1cm4gZGlmZjtcclxuXHJcblx0fSxcclxuXHJcblx0c29ydEZhY2VzQnlNYXRlcmlhbEluZGV4OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIGZhY2VzID0gdGhpcy5mYWNlcztcclxuXHRcdHZhciBsZW5ndGggPSBmYWNlcy5sZW5ndGg7XHJcblxyXG5cdFx0Ly8gdGFnIGZhY2VzXHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0ZmFjZXNbIGkgXS5faWQgPSBpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBzb3J0IGZhY2VzXHJcblxyXG5cdFx0ZnVuY3Rpb24gbWF0ZXJpYWxJbmRleFNvcnQoIGEsIGIgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gYS5tYXRlcmlhbEluZGV4IC0gYi5tYXRlcmlhbEluZGV4O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmYWNlcy5zb3J0KCBtYXRlcmlhbEluZGV4U29ydCApO1xyXG5cclxuXHRcdC8vIHNvcnQgdXZzXHJcblxyXG5cdFx0dmFyIHV2czEgPSB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXTtcclxuXHRcdHZhciB1dnMyID0gdGhpcy5mYWNlVmVydGV4VXZzWyAxIF07XHJcblxyXG5cdFx0dmFyIG5ld1V2czEsIG5ld1V2czI7XHJcblxyXG5cdFx0aWYgKCB1dnMxICYmIHV2czEubGVuZ3RoID09PSBsZW5ndGggKSBuZXdVdnMxID0gW107XHJcblx0XHRpZiAoIHV2czIgJiYgdXZzMi5sZW5ndGggPT09IGxlbmd0aCApIG5ld1V2czIgPSBbXTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgaWQgPSBmYWNlc1sgaSBdLl9pZDtcclxuXHJcblx0XHRcdGlmICggbmV3VXZzMSApIG5ld1V2czEucHVzaCggdXZzMVsgaWQgXSApO1xyXG5cdFx0XHRpZiAoIG5ld1V2czIgKSBuZXdVdnMyLnB1c2goIHV2czJbIGlkIF0gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBuZXdVdnMxICkgdGhpcy5mYWNlVmVydGV4VXZzWyAwIF0gPSBuZXdVdnMxO1xyXG5cdFx0aWYgKCBuZXdVdnMyICkgdGhpcy5mYWNlVmVydGV4VXZzWyAxIF0gPSBuZXdVdnMyO1xyXG5cclxuXHR9LFxyXG5cclxuXHR0b0pTT046IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgZGF0YSA9IHtcclxuXHRcdFx0bWV0YWRhdGE6IHtcclxuXHRcdFx0XHR2ZXJzaW9uOiA0LjQsXHJcblx0XHRcdFx0dHlwZTogJ0dlb21ldHJ5JyxcclxuXHRcdFx0XHRnZW5lcmF0b3I6ICdHZW9tZXRyeS50b0pTT04nXHJcblx0XHRcdH1cclxuXHRcdH07XHJcblxyXG5cdFx0Ly8gc3RhbmRhcmQgR2VvbWV0cnkgc2VyaWFsaXphdGlvblxyXG5cclxuXHRcdGRhdGEudXVpZCA9IHRoaXMudXVpZDtcclxuXHRcdGRhdGEudHlwZSA9IHRoaXMudHlwZTtcclxuXHRcdGlmICggdGhpcy5uYW1lICE9PSAnJyApIGRhdGEubmFtZSA9IHRoaXMubmFtZTtcclxuXHJcblx0XHRpZiAoIHRoaXMucGFyYW1ldGVycyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0dmFyIHBhcmFtZXRlcnMgPSB0aGlzLnBhcmFtZXRlcnM7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIga2V5IGluIHBhcmFtZXRlcnMgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggcGFyYW1ldGVyc1sga2V5IF0gIT09IHVuZGVmaW5lZCApIGRhdGFbIGtleSBdID0gcGFyYW1ldGVyc1sga2V5IF07XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gZGF0YTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHZlcnRpY2VzID0gW107XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgdmVydGV4ID0gdGhpcy52ZXJ0aWNlc1sgaSBdO1xyXG5cdFx0XHR2ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBmYWNlcyA9IFtdO1xyXG5cdFx0dmFyIG5vcm1hbHMgPSBbXTtcclxuXHRcdHZhciBub3JtYWxzSGFzaCA9IHt9O1xyXG5cdFx0dmFyIGNvbG9ycyA9IFtdO1xyXG5cdFx0dmFyIGNvbG9yc0hhc2ggPSB7fTtcclxuXHRcdHZhciB1dnMgPSBbXTtcclxuXHRcdHZhciB1dnNIYXNoID0ge307XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5mYWNlcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgZmFjZSA9IHRoaXMuZmFjZXNbIGkgXTtcclxuXHJcblx0XHRcdHZhciBoYXNNYXRlcmlhbCA9IHRydWU7XHJcblx0XHRcdHZhciBoYXNGYWNlVXYgPSBmYWxzZTsgLy8gZGVwcmVjYXRlZFxyXG5cdFx0XHR2YXIgaGFzRmFjZVZlcnRleFV2ID0gdGhpcy5mYWNlVmVydGV4VXZzWyAwIF1bIGkgXSAhPT0gdW5kZWZpbmVkO1xyXG5cdFx0XHR2YXIgaGFzRmFjZU5vcm1hbCA9IGZhY2Uubm9ybWFsLmxlbmd0aCgpID4gMDtcclxuXHRcdFx0dmFyIGhhc0ZhY2VWZXJ0ZXhOb3JtYWwgPSBmYWNlLnZlcnRleE5vcm1hbHMubGVuZ3RoID4gMDtcclxuXHRcdFx0dmFyIGhhc0ZhY2VDb2xvciA9IGZhY2UuY29sb3IuciAhPT0gMSB8fCBmYWNlLmNvbG9yLmcgIT09IDEgfHwgZmFjZS5jb2xvci5iICE9PSAxO1xyXG5cdFx0XHR2YXIgaGFzRmFjZVZlcnRleENvbG9yID0gZmFjZS52ZXJ0ZXhDb2xvcnMubGVuZ3RoID4gMDtcclxuXHJcblx0XHRcdHZhciBmYWNlVHlwZSA9IDA7XHJcblxyXG5cdFx0XHRmYWNlVHlwZSA9IHNldEJpdCggZmFjZVR5cGUsIDAsIDAgKTsgLy8gaXNRdWFkXHJcblx0XHRcdGZhY2VUeXBlID0gc2V0Qml0KCBmYWNlVHlwZSwgMSwgaGFzTWF0ZXJpYWwgKTtcclxuXHRcdFx0ZmFjZVR5cGUgPSBzZXRCaXQoIGZhY2VUeXBlLCAyLCBoYXNGYWNlVXYgKTtcclxuXHRcdFx0ZmFjZVR5cGUgPSBzZXRCaXQoIGZhY2VUeXBlLCAzLCBoYXNGYWNlVmVydGV4VXYgKTtcclxuXHRcdFx0ZmFjZVR5cGUgPSBzZXRCaXQoIGZhY2VUeXBlLCA0LCBoYXNGYWNlTm9ybWFsICk7XHJcblx0XHRcdGZhY2VUeXBlID0gc2V0Qml0KCBmYWNlVHlwZSwgNSwgaGFzRmFjZVZlcnRleE5vcm1hbCApO1xyXG5cdFx0XHRmYWNlVHlwZSA9IHNldEJpdCggZmFjZVR5cGUsIDYsIGhhc0ZhY2VDb2xvciApO1xyXG5cdFx0XHRmYWNlVHlwZSA9IHNldEJpdCggZmFjZVR5cGUsIDcsIGhhc0ZhY2VWZXJ0ZXhDb2xvciApO1xyXG5cclxuXHRcdFx0ZmFjZXMucHVzaCggZmFjZVR5cGUgKTtcclxuXHRcdFx0ZmFjZXMucHVzaCggZmFjZS5hLCBmYWNlLmIsIGZhY2UuYyApO1xyXG5cdFx0XHRmYWNlcy5wdXNoKCBmYWNlLm1hdGVyaWFsSW5kZXggKTtcclxuXHJcblx0XHRcdGlmICggaGFzRmFjZVZlcnRleFV2ICkge1xyXG5cclxuXHRcdFx0XHR2YXIgZmFjZVZlcnRleFV2cyA9IHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdWyBpIF07XHJcblxyXG5cdFx0XHRcdGZhY2VzLnB1c2goXHJcblx0XHRcdFx0XHRnZXRVdkluZGV4KCBmYWNlVmVydGV4VXZzWyAwIF0gKSxcclxuXHRcdFx0XHRcdGdldFV2SW5kZXgoIGZhY2VWZXJ0ZXhVdnNbIDEgXSApLFxyXG5cdFx0XHRcdFx0Z2V0VXZJbmRleCggZmFjZVZlcnRleFV2c1sgMiBdIClcclxuXHRcdFx0XHQpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBoYXNGYWNlTm9ybWFsICkge1xyXG5cclxuXHRcdFx0XHRmYWNlcy5wdXNoKCBnZXROb3JtYWxJbmRleCggZmFjZS5ub3JtYWwgKSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBoYXNGYWNlVmVydGV4Tm9ybWFsICkge1xyXG5cclxuXHRcdFx0XHR2YXIgdmVydGV4Tm9ybWFscyA9IGZhY2UudmVydGV4Tm9ybWFscztcclxuXHJcblx0XHRcdFx0ZmFjZXMucHVzaChcclxuXHRcdFx0XHRcdGdldE5vcm1hbEluZGV4KCB2ZXJ0ZXhOb3JtYWxzWyAwIF0gKSxcclxuXHRcdFx0XHRcdGdldE5vcm1hbEluZGV4KCB2ZXJ0ZXhOb3JtYWxzWyAxIF0gKSxcclxuXHRcdFx0XHRcdGdldE5vcm1hbEluZGV4KCB2ZXJ0ZXhOb3JtYWxzWyAyIF0gKVxyXG5cdFx0XHRcdCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGhhc0ZhY2VDb2xvciApIHtcclxuXHJcblx0XHRcdFx0ZmFjZXMucHVzaCggZ2V0Q29sb3JJbmRleCggZmFjZS5jb2xvciApICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGhhc0ZhY2VWZXJ0ZXhDb2xvciApIHtcclxuXHJcblx0XHRcdFx0dmFyIHZlcnRleENvbG9ycyA9IGZhY2UudmVydGV4Q29sb3JzO1xyXG5cclxuXHRcdFx0XHRmYWNlcy5wdXNoKFxyXG5cdFx0XHRcdFx0Z2V0Q29sb3JJbmRleCggdmVydGV4Q29sb3JzWyAwIF0gKSxcclxuXHRcdFx0XHRcdGdldENvbG9ySW5kZXgoIHZlcnRleENvbG9yc1sgMSBdICksXHJcblx0XHRcdFx0XHRnZXRDb2xvckluZGV4KCB2ZXJ0ZXhDb2xvcnNbIDIgXSApXHJcblx0XHRcdFx0KTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gc2V0Qml0KCB2YWx1ZSwgcG9zaXRpb24sIGVuYWJsZWQgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gZW5hYmxlZCA/IHZhbHVlIHwgKCAxIDw8IHBvc2l0aW9uICkgOiB2YWx1ZSAmICggfiAoIDEgPDwgcG9zaXRpb24gKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBnZXROb3JtYWxJbmRleCggbm9ybWFsICkge1xyXG5cclxuXHRcdFx0dmFyIGhhc2ggPSBub3JtYWwueC50b1N0cmluZygpICsgbm9ybWFsLnkudG9TdHJpbmcoKSArIG5vcm1hbC56LnRvU3RyaW5nKCk7XHJcblxyXG5cdFx0XHRpZiAoIG5vcm1hbHNIYXNoWyBoYXNoIF0gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIG5vcm1hbHNIYXNoWyBoYXNoIF07XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRub3JtYWxzSGFzaFsgaGFzaCBdID0gbm9ybWFscy5sZW5ndGggLyAzO1xyXG5cdFx0XHRub3JtYWxzLnB1c2goIG5vcm1hbC54LCBub3JtYWwueSwgbm9ybWFsLnogKTtcclxuXHJcblx0XHRcdHJldHVybiBub3JtYWxzSGFzaFsgaGFzaCBdO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBnZXRDb2xvckluZGV4KCBjb2xvciApIHtcclxuXHJcblx0XHRcdHZhciBoYXNoID0gY29sb3Iuci50b1N0cmluZygpICsgY29sb3IuZy50b1N0cmluZygpICsgY29sb3IuYi50b1N0cmluZygpO1xyXG5cclxuXHRcdFx0aWYgKCBjb2xvcnNIYXNoWyBoYXNoIF0gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIGNvbG9yc0hhc2hbIGhhc2ggXTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNvbG9yc0hhc2hbIGhhc2ggXSA9IGNvbG9ycy5sZW5ndGg7XHJcblx0XHRcdGNvbG9ycy5wdXNoKCBjb2xvci5nZXRIZXgoKSApO1xyXG5cclxuXHRcdFx0cmV0dXJuIGNvbG9yc0hhc2hbIGhhc2ggXTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gZ2V0VXZJbmRleCggdXYgKSB7XHJcblxyXG5cdFx0XHR2YXIgaGFzaCA9IHV2LngudG9TdHJpbmcoKSArIHV2LnkudG9TdHJpbmcoKTtcclxuXHJcblx0XHRcdGlmICggdXZzSGFzaFsgaGFzaCBdICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiB1dnNIYXNoWyBoYXNoIF07XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR1dnNIYXNoWyBoYXNoIF0gPSB1dnMubGVuZ3RoIC8gMjtcclxuXHRcdFx0dXZzLnB1c2goIHV2LngsIHV2LnkgKTtcclxuXHJcblx0XHRcdHJldHVybiB1dnNIYXNoWyBoYXNoIF07XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGRhdGEuZGF0YSA9IHt9O1xyXG5cclxuXHRcdGRhdGEuZGF0YS52ZXJ0aWNlcyA9IHZlcnRpY2VzO1xyXG5cdFx0ZGF0YS5kYXRhLm5vcm1hbHMgPSBub3JtYWxzO1xyXG5cdFx0aWYgKCBjb2xvcnMubGVuZ3RoID4gMCApIGRhdGEuZGF0YS5jb2xvcnMgPSBjb2xvcnM7XHJcblx0XHRpZiAoIHV2cy5sZW5ndGggPiAwICkgZGF0YS5kYXRhLnV2cyA9IFsgdXZzIF07IC8vIHRlbXBvcmFsIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcclxuXHRcdGRhdGEuZGF0YS5mYWNlcyA9IGZhY2VzO1xyXG5cclxuXHRcdHJldHVybiBkYXRhO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdC8qXHJcblx0XHQvLyBIYW5kbGUgcHJpbWl0aXZlc1xyXG5cclxuXHRcdHZhciBwYXJhbWV0ZXJzID0gdGhpcy5wYXJhbWV0ZXJzO1xyXG5cclxuXHRcdGlmICggcGFyYW1ldGVycyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0dmFyIHZhbHVlcyA9IFtdO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGtleSBpbiBwYXJhbWV0ZXJzICkge1xyXG5cclxuXHRcdFx0XHR2YWx1ZXMucHVzaCggcGFyYW1ldGVyc1sga2V5IF0gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBnZW9tZXRyeSA9IE9iamVjdC5jcmVhdGUoIHRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlICk7XHJcblx0XHRcdHRoaXMuY29uc3RydWN0b3IuYXBwbHkoIGdlb21ldHJ5LCB2YWx1ZXMgKTtcclxuXHRcdFx0cmV0dXJuIGdlb21ldHJ5O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XHJcblx0XHQqL1xyXG5cclxuXHRcdHJldHVybiBuZXcgVEhSRUUuR2VvbWV0cnkoKS5jb3B5KCB0aGlzICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuXHRcdHRoaXMudmVydGljZXMgPSBbXTtcclxuXHRcdHRoaXMuZmFjZXMgPSBbXTtcclxuXHRcdHRoaXMuZmFjZVZlcnRleFV2cyA9IFsgW10gXTtcclxuXHJcblx0XHR2YXIgdmVydGljZXMgPSBzb3VyY2UudmVydGljZXM7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHZlcnRpY2VzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dGhpcy52ZXJ0aWNlcy5wdXNoKCB2ZXJ0aWNlc1sgaSBdLmNsb25lKCkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGZhY2VzID0gc291cmNlLmZhY2VzO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBmYWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHRoaXMuZmFjZXMucHVzaCggZmFjZXNbIGkgXS5jbG9uZSgpICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBzb3VyY2UuZmFjZVZlcnRleFV2cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciBmYWNlVmVydGV4VXZzID0gc291cmNlLmZhY2VWZXJ0ZXhVdnNbIGkgXTtcclxuXHJcblx0XHRcdGlmICggdGhpcy5mYWNlVmVydGV4VXZzWyBpIF0gPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5mYWNlVmVydGV4VXZzWyBpIF0gPSBbXTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSBmYWNlVmVydGV4VXZzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgdXZzID0gZmFjZVZlcnRleFV2c1sgaiBdLCB1dnNDb3B5ID0gW107XHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciBrID0gMCwga2wgPSB1dnMubGVuZ3RoOyBrIDwga2w7IGsgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIHV2ID0gdXZzWyBrIF07XHJcblxyXG5cdFx0XHRcdFx0dXZzQ29weS5wdXNoKCB1di5jbG9uZSgpICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGhpcy5mYWNlVmVydGV4VXZzWyBpIF0ucHVzaCggdXZzQ29weSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZGlzcG9zZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAnZGlzcG9zZScgfSApO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5hcHBseSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XHJcblxyXG5USFJFRS5HZW9tZXRyeUlkQ291bnQgPSAwO1xyXG5cclxuLy8gRmlsZTpzcmMvY29yZS9EaXJlY3RHZW9tZXRyeS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuRGlyZWN0R2VvbWV0cnkgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgJ2lkJywgeyB2YWx1ZTogVEhSRUUuR2VvbWV0cnlJZENvdW50ICsrIH0gKTtcclxuXHJcblx0dGhpcy51dWlkID0gVEhSRUUuTWF0aC5nZW5lcmF0ZVVVSUQoKTtcclxuXHJcblx0dGhpcy5uYW1lID0gJyc7XHJcblx0dGhpcy50eXBlID0gJ0RpcmVjdEdlb21ldHJ5JztcclxuXHJcblx0dGhpcy5pbmRpY2VzID0gW107XHJcblx0dGhpcy52ZXJ0aWNlcyA9IFtdO1xyXG5cdHRoaXMubm9ybWFscyA9IFtdO1xyXG5cdHRoaXMuY29sb3JzID0gW107XHJcblx0dGhpcy51dnMgPSBbXTtcclxuXHR0aGlzLnV2czIgPSBbXTtcclxuXHJcblx0dGhpcy5ncm91cHMgPSBbXTtcclxuXHJcblx0dGhpcy5tb3JwaFRhcmdldHMgPSB7fTtcclxuXHJcblx0dGhpcy5za2luV2VpZ2h0cyA9IFtdO1xyXG5cdHRoaXMuc2tpbkluZGljZXMgPSBbXTtcclxuXHJcblx0Ly8gdGhpcy5saW5lRGlzdGFuY2VzID0gW107XHJcblxyXG5cdHRoaXMuYm91bmRpbmdCb3ggPSBudWxsO1xyXG5cdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBudWxsO1xyXG5cclxuXHQvLyB1cGRhdGUgZmxhZ3NcclxuXHJcblx0dGhpcy52ZXJ0aWNlc05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHR0aGlzLm5vcm1hbHNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblx0dGhpcy5jb2xvcnNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblx0dGhpcy51dnNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblx0dGhpcy5ncm91cHNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuRGlyZWN0R2VvbWV0cnkucHJvdG90eXBlID0ge1xyXG5cclxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuRGlyZWN0R2VvbWV0cnksXHJcblxyXG5cdGNvbXB1dGVCb3VuZGluZ0JveDogVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlLmNvbXB1dGVCb3VuZGluZ0JveCxcclxuXHRjb21wdXRlQm91bmRpbmdTcGhlcmU6IFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZS5jb21wdXRlQm91bmRpbmdTcGhlcmUsXHJcblxyXG5cdGNvbXB1dGVGYWNlTm9ybWFsczogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkRpcmVjdEdlb21ldHJ5OiBjb21wdXRlRmFjZU5vcm1hbHMoKSBpcyBub3QgYSBtZXRob2Qgb2YgdGhpcyB0eXBlIG9mIGdlb21ldHJ5LicgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y29tcHV0ZVZlcnRleE5vcm1hbHM6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5EaXJlY3RHZW9tZXRyeTogY29tcHV0ZVZlcnRleE5vcm1hbHMoKSBpcyBub3QgYSBtZXRob2Qgb2YgdGhpcyB0eXBlIG9mIGdlb21ldHJ5LicgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y29tcHV0ZUdyb3VwczogZnVuY3Rpb24gKCBnZW9tZXRyeSApIHtcclxuXHJcblx0XHR2YXIgZ3JvdXA7XHJcblx0XHR2YXIgZ3JvdXBzID0gW107XHJcblx0XHR2YXIgbWF0ZXJpYWxJbmRleDtcclxuXHJcblx0XHR2YXIgZmFjZXMgPSBnZW9tZXRyeS5mYWNlcztcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBmYWNlcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgZmFjZSA9IGZhY2VzWyBpIF07XHJcblxyXG5cdFx0XHQvLyBtYXRlcmlhbHNcclxuXHJcblx0XHRcdGlmICggZmFjZS5tYXRlcmlhbEluZGV4ICE9PSBtYXRlcmlhbEluZGV4ICkge1xyXG5cclxuXHRcdFx0XHRtYXRlcmlhbEluZGV4ID0gZmFjZS5tYXRlcmlhbEluZGV4O1xyXG5cclxuXHRcdFx0XHRpZiAoIGdyb3VwICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0Z3JvdXAuY291bnQgPSAoIGkgKiAzICkgLSBncm91cC5zdGFydDtcclxuXHRcdFx0XHRcdGdyb3Vwcy5wdXNoKCBncm91cCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGdyb3VwID0ge1xyXG5cdFx0XHRcdFx0c3RhcnQ6IGkgKiAzLFxyXG5cdFx0XHRcdFx0bWF0ZXJpYWxJbmRleDogbWF0ZXJpYWxJbmRleFxyXG5cdFx0XHRcdH07XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggZ3JvdXAgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGdyb3VwLmNvdW50ID0gKCBpICogMyApIC0gZ3JvdXAuc3RhcnQ7XHJcblx0XHRcdGdyb3Vwcy5wdXNoKCBncm91cCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmdyb3VwcyA9IGdyb3VwcztcclxuXHJcblx0fSxcclxuXHJcblx0ZnJvbUdlb21ldHJ5OiBmdW5jdGlvbiAoIGdlb21ldHJ5ICkge1xyXG5cclxuXHRcdHZhciBmYWNlcyA9IGdlb21ldHJ5LmZhY2VzO1xyXG5cdFx0dmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXM7XHJcblx0XHR2YXIgZmFjZVZlcnRleFV2cyA9IGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnM7XHJcblxyXG5cdFx0dmFyIGhhc0ZhY2VWZXJ0ZXhVdiA9IGZhY2VWZXJ0ZXhVdnNbIDAgXSAmJiBmYWNlVmVydGV4VXZzWyAwIF0ubGVuZ3RoID4gMDtcclxuXHRcdHZhciBoYXNGYWNlVmVydGV4VXYyID0gZmFjZVZlcnRleFV2c1sgMSBdICYmIGZhY2VWZXJ0ZXhVdnNbIDEgXS5sZW5ndGggPiAwO1xyXG5cclxuXHRcdC8vIG1vcnBoc1xyXG5cclxuXHRcdHZhciBtb3JwaFRhcmdldHMgPSBnZW9tZXRyeS5tb3JwaFRhcmdldHM7XHJcblx0XHR2YXIgbW9ycGhUYXJnZXRzTGVuZ3RoID0gbW9ycGhUYXJnZXRzLmxlbmd0aDtcclxuXHJcblx0XHR2YXIgbW9ycGhUYXJnZXRzUG9zaXRpb247XHJcblxyXG5cdFx0aWYgKCBtb3JwaFRhcmdldHNMZW5ndGggPiAwICkge1xyXG5cclxuXHRcdFx0bW9ycGhUYXJnZXRzUG9zaXRpb24gPSBbXTtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IG1vcnBoVGFyZ2V0c0xlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0bW9ycGhUYXJnZXRzUG9zaXRpb25bIGkgXSA9IFtdO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5tb3JwaFRhcmdldHMucG9zaXRpb24gPSBtb3JwaFRhcmdldHNQb3NpdGlvbjtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG1vcnBoTm9ybWFscyA9IGdlb21ldHJ5Lm1vcnBoTm9ybWFscztcclxuXHRcdHZhciBtb3JwaE5vcm1hbHNMZW5ndGggPSBtb3JwaE5vcm1hbHMubGVuZ3RoO1xyXG5cclxuXHRcdHZhciBtb3JwaFRhcmdldHNOb3JtYWw7XHJcblxyXG5cdFx0aWYgKCBtb3JwaE5vcm1hbHNMZW5ndGggPiAwICkge1xyXG5cclxuXHRcdFx0bW9ycGhUYXJnZXRzTm9ybWFsID0gW107XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBtb3JwaE5vcm1hbHNMZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdG1vcnBoVGFyZ2V0c05vcm1hbFsgaSBdID0gW107XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLm1vcnBoVGFyZ2V0cy5ub3JtYWwgPSBtb3JwaFRhcmdldHNOb3JtYWw7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHNraW5zXHJcblxyXG5cdFx0dmFyIHNraW5JbmRpY2VzID0gZ2VvbWV0cnkuc2tpbkluZGljZXM7XHJcblx0XHR2YXIgc2tpbldlaWdodHMgPSBnZW9tZXRyeS5za2luV2VpZ2h0cztcclxuXHJcblx0XHR2YXIgaGFzU2tpbkluZGljZXMgPSBza2luSW5kaWNlcy5sZW5ndGggPT09IHZlcnRpY2VzLmxlbmd0aDtcclxuXHRcdHZhciBoYXNTa2luV2VpZ2h0cyA9IHNraW5XZWlnaHRzLmxlbmd0aCA9PT0gdmVydGljZXMubGVuZ3RoO1xyXG5cclxuXHRcdC8vXHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZmFjZXMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIGZhY2UgPSBmYWNlc1sgaSBdO1xyXG5cclxuXHRcdFx0dGhpcy52ZXJ0aWNlcy5wdXNoKCB2ZXJ0aWNlc1sgZmFjZS5hIF0sIHZlcnRpY2VzWyBmYWNlLmIgXSwgdmVydGljZXNbIGZhY2UuYyBdICk7XHJcblxyXG5cdFx0XHR2YXIgdmVydGV4Tm9ybWFscyA9IGZhY2UudmVydGV4Tm9ybWFscztcclxuXHJcblx0XHRcdGlmICggdmVydGV4Tm9ybWFscy5sZW5ndGggPT09IDMgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMubm9ybWFscy5wdXNoKCB2ZXJ0ZXhOb3JtYWxzWyAwIF0sIHZlcnRleE5vcm1hbHNbIDEgXSwgdmVydGV4Tm9ybWFsc1sgMiBdICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHR2YXIgbm9ybWFsID0gZmFjZS5ub3JtYWw7XHJcblxyXG5cdFx0XHRcdHRoaXMubm9ybWFscy5wdXNoKCBub3JtYWwsIG5vcm1hbCwgbm9ybWFsICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgdmVydGV4Q29sb3JzID0gZmFjZS52ZXJ0ZXhDb2xvcnM7XHJcblxyXG5cdFx0XHRpZiAoIHZlcnRleENvbG9ycy5sZW5ndGggPT09IDMgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuY29sb3JzLnB1c2goIHZlcnRleENvbG9yc1sgMCBdLCB2ZXJ0ZXhDb2xvcnNbIDEgXSwgdmVydGV4Q29sb3JzWyAyIF0gKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHZhciBjb2xvciA9IGZhY2UuY29sb3I7XHJcblxyXG5cdFx0XHRcdHRoaXMuY29sb3JzLnB1c2goIGNvbG9yLCBjb2xvciwgY29sb3IgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggaGFzRmFjZVZlcnRleFV2ID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0XHR2YXIgdmVydGV4VXZzID0gZmFjZVZlcnRleFV2c1sgMCBdWyBpIF07XHJcblxyXG5cdFx0XHRcdGlmICggdmVydGV4VXZzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0dGhpcy51dnMucHVzaCggdmVydGV4VXZzWyAwIF0sIHZlcnRleFV2c1sgMSBdLCB2ZXJ0ZXhVdnNbIDIgXSApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkRpcmVjdEdlb21ldHJ5LmZyb21HZW9tZXRyeSgpOiBVbmRlZmluZWQgdmVydGV4VXYgJywgaSApO1xyXG5cclxuXHRcdFx0XHRcdHRoaXMudXZzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCksIG5ldyBUSFJFRS5WZWN0b3IyKCksIG5ldyBUSFJFRS5WZWN0b3IyKCkgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBoYXNGYWNlVmVydGV4VXYyID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0XHR2YXIgdmVydGV4VXZzID0gZmFjZVZlcnRleFV2c1sgMSBdWyBpIF07XHJcblxyXG5cdFx0XHRcdGlmICggdmVydGV4VXZzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0dGhpcy51dnMyLnB1c2goIHZlcnRleFV2c1sgMCBdLCB2ZXJ0ZXhVdnNbIDEgXSwgdmVydGV4VXZzWyAyIF0gKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5EaXJlY3RHZW9tZXRyeS5mcm9tR2VvbWV0cnkoKTogVW5kZWZpbmVkIHZlcnRleFV2MiAnLCBpICk7XHJcblxyXG5cdFx0XHRcdFx0dGhpcy51dnMyLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCksIG5ldyBUSFJFRS5WZWN0b3IyKCksIG5ldyBUSFJFRS5WZWN0b3IyKCkgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gbW9ycGhzXHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCBtb3JwaFRhcmdldHNMZW5ndGg7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBtb3JwaFRhcmdldCA9IG1vcnBoVGFyZ2V0c1sgaiBdLnZlcnRpY2VzO1xyXG5cclxuXHRcdFx0XHRtb3JwaFRhcmdldHNQb3NpdGlvblsgaiBdLnB1c2goIG1vcnBoVGFyZ2V0WyBmYWNlLmEgXSwgbW9ycGhUYXJnZXRbIGZhY2UuYiBdLCBtb3JwaFRhcmdldFsgZmFjZS5jIF0gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZvciAoIHZhciBqID0gMDsgaiA8IG1vcnBoTm9ybWFsc0xlbmd0aDsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0dmFyIG1vcnBoTm9ybWFsID0gbW9ycGhOb3JtYWxzWyBqIF0udmVydGV4Tm9ybWFsc1sgaSBdO1xyXG5cclxuXHRcdFx0XHRtb3JwaFRhcmdldHNOb3JtYWxbIGogXS5wdXNoKCBtb3JwaE5vcm1hbC5hLCBtb3JwaE5vcm1hbC5iLCBtb3JwaE5vcm1hbC5jICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBza2luc1xyXG5cclxuXHRcdFx0aWYgKCBoYXNTa2luSW5kaWNlcyApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5za2luSW5kaWNlcy5wdXNoKCBza2luSW5kaWNlc1sgZmFjZS5hIF0sIHNraW5JbmRpY2VzWyBmYWNlLmIgXSwgc2tpbkluZGljZXNbIGZhY2UuYyBdICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGhhc1NraW5XZWlnaHRzICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLnNraW5XZWlnaHRzLnB1c2goIHNraW5XZWlnaHRzWyBmYWNlLmEgXSwgc2tpbldlaWdodHNbIGZhY2UuYiBdLCBza2luV2VpZ2h0c1sgZmFjZS5jIF0gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5jb21wdXRlR3JvdXBzKCBnZW9tZXRyeSApO1xyXG5cclxuXHRcdHRoaXMudmVydGljZXNOZWVkVXBkYXRlID0gZ2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlO1xyXG5cdFx0dGhpcy5ub3JtYWxzTmVlZFVwZGF0ZSA9IGdlb21ldHJ5Lm5vcm1hbHNOZWVkVXBkYXRlO1xyXG5cdFx0dGhpcy5jb2xvcnNOZWVkVXBkYXRlID0gZ2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZTtcclxuXHRcdHRoaXMudXZzTmVlZFVwZGF0ZSA9IGdlb21ldHJ5LnV2c05lZWRVcGRhdGU7XHJcblx0XHR0aGlzLmdyb3Vwc05lZWRVcGRhdGUgPSBnZW9tZXRyeS5ncm91cHNOZWVkVXBkYXRlO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdkaXNwb3NlJyB9ICk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmFwcGx5KCBUSFJFRS5EaXJlY3RHZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuXHJcbi8vIEZpbGU6c3JjL2NvcmUvQnVmZmVyR2VvbWV0cnkuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkJ1ZmZlckdlb21ldHJ5ID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsICdpZCcsIHsgdmFsdWU6IFRIUkVFLkdlb21ldHJ5SWRDb3VudCArKyB9ICk7XHJcblxyXG5cdHRoaXMudXVpZCA9IFRIUkVFLk1hdGguZ2VuZXJhdGVVVUlEKCk7XHJcblxyXG5cdHRoaXMubmFtZSA9ICcnO1xyXG5cdHRoaXMudHlwZSA9ICdCdWZmZXJHZW9tZXRyeSc7XHJcblxyXG5cdHRoaXMuaW5kZXggPSBudWxsO1xyXG5cdHRoaXMuYXR0cmlidXRlcyA9IHt9O1xyXG5cclxuXHR0aGlzLm1vcnBoQXR0cmlidXRlcyA9IHt9O1xyXG5cclxuXHR0aGlzLmdyb3VwcyA9IFtdO1xyXG5cclxuXHR0aGlzLmJvdW5kaW5nQm94ID0gbnVsbDtcclxuXHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gbnVsbDtcclxuXHJcblx0dGhpcy5kcmF3UmFuZ2UgPSB7IHN0YXJ0OiAwLCBjb3VudDogSW5maW5pdHkgfTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5CdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5CdWZmZXJHZW9tZXRyeSxcclxuXHJcblx0Z2V0SW5kZXg6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5pbmRleDtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0SW5kZXg6IGZ1bmN0aW9uICggaW5kZXggKSB7XHJcblxyXG5cdFx0dGhpcy5pbmRleCA9IGluZGV4O1xyXG5cclxuXHR9LFxyXG5cclxuXHRhZGRBdHRyaWJ1dGU6IGZ1bmN0aW9uICggbmFtZSwgYXR0cmlidXRlICkge1xyXG5cclxuXHRcdGlmICggYXR0cmlidXRlIGluc3RhbmNlb2YgVEhSRUUuQnVmZmVyQXR0cmlidXRlID09PSBmYWxzZSAmJiBhdHRyaWJ1dGUgaW5zdGFuY2VvZiBUSFJFRS5JbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSA9PT0gZmFsc2UgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLmFkZEF0dHJpYnV0ZSgpIG5vdyBleHBlY3RzICggbmFtZSwgYXR0cmlidXRlICkuJyApO1xyXG5cclxuXHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGUoIG5hbWUsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIGFyZ3VtZW50c1sgMSBdLCBhcmd1bWVudHNbIDIgXSApICk7XHJcblxyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggbmFtZSA9PT0gJ2luZGV4JyApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5LmFkZEF0dHJpYnV0ZTogVXNlIC5zZXRJbmRleCgpIGZvciBpbmRleCBhdHRyaWJ1dGUuJyApO1xyXG5cdFx0XHR0aGlzLnNldEluZGV4KCBhdHRyaWJ1dGUgKTtcclxuXHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5hdHRyaWJ1dGVzWyBuYW1lIF0gPSBhdHRyaWJ1dGU7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldEF0dHJpYnV0ZTogZnVuY3Rpb24gKCBuYW1lICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmF0dHJpYnV0ZXNbIG5hbWUgXTtcclxuXHJcblx0fSxcclxuXHJcblx0cmVtb3ZlQXR0cmlidXRlOiBmdW5jdGlvbiAoIG5hbWUgKSB7XHJcblxyXG5cdFx0ZGVsZXRlIHRoaXMuYXR0cmlidXRlc1sgbmFtZSBdO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRhZGRHcm91cDogZnVuY3Rpb24gKCBzdGFydCwgY291bnQsIG1hdGVyaWFsSW5kZXggKSB7XHJcblxyXG5cdFx0dGhpcy5ncm91cHMucHVzaCgge1xyXG5cclxuXHRcdFx0c3RhcnQ6IHN0YXJ0LFxyXG5cdFx0XHRjb3VudDogY291bnQsXHJcblx0XHRcdG1hdGVyaWFsSW5kZXg6IG1hdGVyaWFsSW5kZXggIT09IHVuZGVmaW5lZCA/IG1hdGVyaWFsSW5kZXggOiAwXHJcblxyXG5cdFx0fSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjbGVhckdyb3VwczogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMuZ3JvdXBzID0gW107XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldERyYXdSYW5nZTogZnVuY3Rpb24gKCBzdGFydCwgY291bnQgKSB7XHJcblxyXG5cdFx0dGhpcy5kcmF3UmFuZ2Uuc3RhcnQgPSBzdGFydDtcclxuXHRcdHRoaXMuZHJhd1JhbmdlLmNvdW50ID0gY291bnQ7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFwcGx5TWF0cml4OiBmdW5jdGlvbiAoIG1hdHJpeCApIHtcclxuXHJcblx0XHR2YXIgcG9zaXRpb24gPSB0aGlzLmF0dHJpYnV0ZXMucG9zaXRpb247XHJcblxyXG5cdFx0aWYgKCBwb3NpdGlvbiAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0bWF0cml4LmFwcGx5VG9WZWN0b3IzQXJyYXkoIHBvc2l0aW9uLmFycmF5ICk7XHJcblx0XHRcdHBvc2l0aW9uLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG5vcm1hbCA9IHRoaXMuYXR0cmlidXRlcy5ub3JtYWw7XHJcblxyXG5cdFx0aWYgKCBub3JtYWwgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHZhciBub3JtYWxNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4MygpLmdldE5vcm1hbE1hdHJpeCggbWF0cml4ICk7XHJcblxyXG5cdFx0XHRub3JtYWxNYXRyaXguYXBwbHlUb1ZlY3RvcjNBcnJheSggbm9ybWFsLmFycmF5ICk7XHJcblx0XHRcdG5vcm1hbC5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdGhpcy5ib3VuZGluZ0JveCAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdHRoaXMuY29tcHV0ZUJvdW5kaW5nQm94KCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdGhpcy5ib3VuZGluZ1NwaGVyZSAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdHRoaXMuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHRyb3RhdGVYOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0Ly8gcm90YXRlIGdlb21ldHJ5IGFyb3VuZCB3b3JsZCB4LWF4aXNcclxuXHJcblx0XHR2YXIgbTE7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHJvdGF0ZVgoIGFuZ2xlICkge1xyXG5cclxuXHRcdFx0aWYgKCBtMSA9PT0gdW5kZWZpbmVkICkgbTEgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xyXG5cclxuXHRcdFx0bTEubWFrZVJvdGF0aW9uWCggYW5nbGUgKTtcclxuXHJcblx0XHRcdHRoaXMuYXBwbHlNYXRyaXgoIG0xICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdHJvdGF0ZVk6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHQvLyByb3RhdGUgZ2VvbWV0cnkgYXJvdW5kIHdvcmxkIHktYXhpc1xyXG5cclxuXHRcdHZhciBtMTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gcm90YXRlWSggYW5nbGUgKSB7XHJcblxyXG5cdFx0XHRpZiAoIG0xID09PSB1bmRlZmluZWQgKSBtMSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblxyXG5cdFx0XHRtMS5tYWtlUm90YXRpb25ZKCBhbmdsZSApO1xyXG5cclxuXHRcdFx0dGhpcy5hcHBseU1hdHJpeCggbTEgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0cm90YXRlWjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdC8vIHJvdGF0ZSBnZW9tZXRyeSBhcm91bmQgd29ybGQgei1heGlzXHJcblxyXG5cdFx0dmFyIG0xO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiByb3RhdGVaKCBhbmdsZSApIHtcclxuXHJcblx0XHRcdGlmICggbTEgPT09IHVuZGVmaW5lZCApIG0xID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHJcblx0XHRcdG0xLm1ha2VSb3RhdGlvblooIGFuZ2xlICk7XHJcblxyXG5cdFx0XHR0aGlzLmFwcGx5TWF0cml4KCBtMSApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHR0cmFuc2xhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHQvLyB0cmFuc2xhdGUgZ2VvbWV0cnlcclxuXHJcblx0XHR2YXIgbTE7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHRyYW5zbGF0ZSggeCwgeSwgeiApIHtcclxuXHJcblx0XHRcdGlmICggbTEgPT09IHVuZGVmaW5lZCApIG0xID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHJcblx0XHRcdG0xLm1ha2VUcmFuc2xhdGlvbiggeCwgeSwgeiApO1xyXG5cclxuXHRcdFx0dGhpcy5hcHBseU1hdHJpeCggbTEgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0c2NhbGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHQvLyBzY2FsZSBnZW9tZXRyeVxyXG5cclxuXHRcdHZhciBtMTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gc2NhbGUoIHgsIHksIHogKSB7XHJcblxyXG5cdFx0XHRpZiAoIG0xID09PSB1bmRlZmluZWQgKSBtMSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblxyXG5cdFx0XHRtMS5tYWtlU2NhbGUoIHgsIHksIHogKTtcclxuXHJcblx0XHRcdHRoaXMuYXBwbHlNYXRyaXgoIG0xICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGxvb2tBdDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBvYmo7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGxvb2tBdCggdmVjdG9yICkge1xyXG5cclxuXHRcdFx0aWYgKCBvYmogPT09IHVuZGVmaW5lZCApIG9iaiA9IG5ldyBUSFJFRS5PYmplY3QzRCgpO1xyXG5cclxuXHRcdFx0b2JqLmxvb2tBdCggdmVjdG9yICk7XHJcblxyXG5cdFx0XHRvYmoudXBkYXRlTWF0cml4KCk7XHJcblxyXG5cdFx0XHR0aGlzLmFwcGx5TWF0cml4KCBvYmoubWF0cml4ICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRjZW50ZXI6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLmNvbXB1dGVCb3VuZGluZ0JveCgpO1xyXG5cclxuXHRcdHZhciBvZmZzZXQgPSB0aGlzLmJvdW5kaW5nQm94LmNlbnRlcigpLm5lZ2F0ZSgpO1xyXG5cclxuXHRcdHRoaXMudHJhbnNsYXRlKCBvZmZzZXQueCwgb2Zmc2V0LnksIG9mZnNldC56ICk7XHJcblxyXG5cdFx0cmV0dXJuIG9mZnNldDtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0RnJvbU9iamVjdDogZnVuY3Rpb24gKCBvYmplY3QgKSB7XHJcblxyXG5cdFx0Ly8gY29uc29sZS5sb2coICdUSFJFRS5CdWZmZXJHZW9tZXRyeS5zZXRGcm9tT2JqZWN0KCkuIENvbnZlcnRpbmcnLCBvYmplY3QsIHRoaXMgKTtcclxuXHJcblx0XHR2YXIgZ2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnk7XHJcblxyXG5cdFx0aWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5Qb2ludHMgfHwgb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTGluZSApIHtcclxuXHJcblx0XHRcdHZhciBwb3NpdGlvbnMgPSBuZXcgVEhSRUUuRmxvYXQzMkF0dHJpYnV0ZSggZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoICogMywgMyApO1xyXG5cdFx0XHR2YXIgY29sb3JzID0gbmV3IFRIUkVFLkZsb2F0MzJBdHRyaWJ1dGUoIGdlb21ldHJ5LmNvbG9ycy5sZW5ndGggKiAzLCAzICk7XHJcblxyXG5cdFx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgcG9zaXRpb25zLmNvcHlWZWN0b3Izc0FycmF5KCBnZW9tZXRyeS52ZXJ0aWNlcyApICk7XHJcblx0XHRcdHRoaXMuYWRkQXR0cmlidXRlKCAnY29sb3InLCBjb2xvcnMuY29weUNvbG9yc0FycmF5KCBnZW9tZXRyeS5jb2xvcnMgKSApO1xyXG5cclxuXHRcdFx0aWYgKCBnZW9tZXRyeS5saW5lRGlzdGFuY2VzICYmIGdlb21ldHJ5LmxpbmVEaXN0YW5jZXMubGVuZ3RoID09PSBnZW9tZXRyeS52ZXJ0aWNlcy5sZW5ndGggKSB7XHJcblxyXG5cdFx0XHRcdHZhciBsaW5lRGlzdGFuY2VzID0gbmV3IFRIUkVFLkZsb2F0MzJBdHRyaWJ1dGUoIGdlb21ldHJ5LmxpbmVEaXN0YW5jZXMubGVuZ3RoLCAxICk7XHJcblxyXG5cdFx0XHRcdHRoaXMuYWRkQXR0cmlidXRlKCAnbGluZURpc3RhbmNlJywgbGluZURpc3RhbmNlcy5jb3B5QXJyYXkoIGdlb21ldHJ5LmxpbmVEaXN0YW5jZXMgKSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlLmNsb25lKCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nQm94ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLmJvdW5kaW5nQm94ID0gZ2VvbWV0cnkuYm91bmRpbmdCb3guY2xvbmUoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2UgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5NZXNoICkge1xyXG5cclxuXHRcdFx0aWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkdlb21ldHJ5ICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLmZyb21HZW9tZXRyeSggZ2VvbWV0cnkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZUZyb21PYmplY3Q6IGZ1bmN0aW9uICggb2JqZWN0ICkge1xyXG5cclxuXHRcdHZhciBnZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeTtcclxuXHJcblx0XHRpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLk1lc2ggKSB7XHJcblxyXG5cdFx0XHR2YXIgZGlyZWN0ID0gZ2VvbWV0cnkuX19kaXJlY3RHZW9tZXRyeTtcclxuXHJcblx0XHRcdGlmICggZGlyZWN0ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiB0aGlzLmZyb21HZW9tZXRyeSggZ2VvbWV0cnkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGRpcmVjdC52ZXJ0aWNlc05lZWRVcGRhdGUgPSBnZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGU7XHJcblx0XHRcdGRpcmVjdC5ub3JtYWxzTmVlZFVwZGF0ZSA9IGdlb21ldHJ5Lm5vcm1hbHNOZWVkVXBkYXRlO1xyXG5cdFx0XHRkaXJlY3QuY29sb3JzTmVlZFVwZGF0ZSA9IGdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGU7XHJcblx0XHRcdGRpcmVjdC51dnNOZWVkVXBkYXRlID0gZ2VvbWV0cnkudXZzTmVlZFVwZGF0ZTtcclxuXHRcdFx0ZGlyZWN0Lmdyb3Vwc05lZWRVcGRhdGUgPSBnZW9tZXRyeS5ncm91cHNOZWVkVXBkYXRlO1xyXG5cclxuXHRcdFx0Z2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblx0XHRcdGdlb21ldHJ5Lm5vcm1hbHNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblx0XHRcdGdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHRcdFx0Z2VvbWV0cnkudXZzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cdFx0XHRnZW9tZXRyeS5ncm91cHNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblxyXG5cdFx0XHRnZW9tZXRyeSA9IGRpcmVjdDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBnZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHR2YXIgYXR0cmlidXRlID0gdGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xyXG5cclxuXHRcdFx0aWYgKCBhdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0YXR0cmlidXRlLmNvcHlWZWN0b3Izc0FycmF5KCBnZW9tZXRyeS52ZXJ0aWNlcyApO1xyXG5cdFx0XHRcdGF0dHJpYnV0ZS5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRnZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBnZW9tZXRyeS5ub3JtYWxzTmVlZFVwZGF0ZSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdHZhciBhdHRyaWJ1dGUgPSB0aGlzLmF0dHJpYnV0ZXMubm9ybWFsO1xyXG5cclxuXHRcdFx0aWYgKCBhdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0YXR0cmlidXRlLmNvcHlWZWN0b3Izc0FycmF5KCBnZW9tZXRyeS5ub3JtYWxzICk7XHJcblx0XHRcdFx0YXR0cmlidXRlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGdlb21ldHJ5Lm5vcm1hbHNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggZ2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdHZhciBhdHRyaWJ1dGUgPSB0aGlzLmF0dHJpYnV0ZXMuY29sb3I7XHJcblxyXG5cdFx0XHRpZiAoIGF0dHJpYnV0ZSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRhdHRyaWJ1dGUuY29weUNvbG9yc0FycmF5KCBnZW9tZXRyeS5jb2xvcnMgKTtcclxuXHRcdFx0XHRhdHRyaWJ1dGUubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Z2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5LnV2c05lZWRVcGRhdGUgKSB7XHJcblxyXG5cdFx0XHR2YXIgYXR0cmlidXRlID0gdGhpcy5hdHRyaWJ1dGVzLnV2O1xyXG5cclxuXHRcdFx0aWYgKCBhdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0YXR0cmlidXRlLmNvcHlWZWN0b3Iyc0FycmF5KCBnZW9tZXRyeS51dnMgKTtcclxuXHRcdFx0XHRhdHRyaWJ1dGUubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Z2VvbWV0cnkudXZzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5LmxpbmVEaXN0YW5jZXNOZWVkVXBkYXRlICkge1xyXG5cclxuXHRcdFx0dmFyIGF0dHJpYnV0ZSA9IHRoaXMuYXR0cmlidXRlcy5saW5lRGlzdGFuY2U7XHJcblxyXG5cdFx0XHRpZiAoIGF0dHJpYnV0ZSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRhdHRyaWJ1dGUuY29weUFycmF5KCBnZW9tZXRyeS5saW5lRGlzdGFuY2VzICk7XHJcblx0XHRcdFx0YXR0cmlidXRlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGdlb21ldHJ5LmxpbmVEaXN0YW5jZXNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggZ2VvbWV0cnkuZ3JvdXBzTmVlZFVwZGF0ZSApIHtcclxuXHJcblx0XHRcdGdlb21ldHJ5LmNvbXB1dGVHcm91cHMoIG9iamVjdC5nZW9tZXRyeSApO1xyXG5cdFx0XHR0aGlzLmdyb3VwcyA9IGdlb21ldHJ5Lmdyb3VwcztcclxuXHJcblx0XHRcdGdlb21ldHJ5Lmdyb3Vwc05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGZyb21HZW9tZXRyeTogZnVuY3Rpb24gKCBnZW9tZXRyeSApIHtcclxuXHJcblx0XHRnZW9tZXRyeS5fX2RpcmVjdEdlb21ldHJ5ID0gbmV3IFRIUkVFLkRpcmVjdEdlb21ldHJ5KCkuZnJvbUdlb21ldHJ5KCBnZW9tZXRyeSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmZyb21EaXJlY3RHZW9tZXRyeSggZ2VvbWV0cnkuX19kaXJlY3RHZW9tZXRyeSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRmcm9tRGlyZWN0R2VvbWV0cnk6IGZ1bmN0aW9uICggZ2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0dmFyIHBvc2l0aW9ucyA9IG5ldyBGbG9hdDMyQXJyYXkoIGdlb21ldHJ5LnZlcnRpY2VzLmxlbmd0aCAqIDMgKTtcclxuXHRcdHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbnMsIDMgKS5jb3B5VmVjdG9yM3NBcnJheSggZ2VvbWV0cnkudmVydGljZXMgKSApO1xyXG5cclxuXHRcdGlmICggZ2VvbWV0cnkubm9ybWFscy5sZW5ndGggPiAwICkge1xyXG5cclxuXHRcdFx0dmFyIG5vcm1hbHMgPSBuZXcgRmxvYXQzMkFycmF5KCBnZW9tZXRyeS5ub3JtYWxzLmxlbmd0aCAqIDMgKTtcclxuXHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBub3JtYWxzLCAzICkuY29weVZlY3RvcjNzQXJyYXkoIGdlb21ldHJ5Lm5vcm1hbHMgKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5LmNvbG9ycy5sZW5ndGggPiAwICkge1xyXG5cclxuXHRcdFx0dmFyIGNvbG9ycyA9IG5ldyBGbG9hdDMyQXJyYXkoIGdlb21ldHJ5LmNvbG9ycy5sZW5ndGggKiAzICk7XHJcblx0XHRcdHRoaXMuYWRkQXR0cmlidXRlKCAnY29sb3InLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBjb2xvcnMsIDMgKS5jb3B5Q29sb3JzQXJyYXkoIGdlb21ldHJ5LmNvbG9ycyApICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggZ2VvbWV0cnkudXZzLmxlbmd0aCA+IDAgKSB7XHJcblxyXG5cdFx0XHR2YXIgdXZzID0gbmV3IEZsb2F0MzJBcnJheSggZ2VvbWV0cnkudXZzLmxlbmd0aCAqIDIgKTtcclxuXHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICd1dicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIHV2cywgMiApLmNvcHlWZWN0b3Iyc0FycmF5KCBnZW9tZXRyeS51dnMgKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5LnV2czIubGVuZ3RoID4gMCApIHtcclxuXHJcblx0XHRcdHZhciB1dnMyID0gbmV3IEZsb2F0MzJBcnJheSggZ2VvbWV0cnkudXZzMi5sZW5ndGggKiAyICk7XHJcblx0XHRcdHRoaXMuYWRkQXR0cmlidXRlKCAndXYyJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggdXZzMiwgMiApLmNvcHlWZWN0b3Iyc0FycmF5KCBnZW9tZXRyeS51dnMyICkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBnZW9tZXRyeS5pbmRpY2VzLmxlbmd0aCA+IDAgKSB7XHJcblxyXG5cdFx0XHR2YXIgVHlwZUFycmF5ID0gZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoID4gNjU1MzUgPyBVaW50MzJBcnJheSA6IFVpbnQxNkFycmF5O1xyXG5cdFx0XHR2YXIgaW5kaWNlcyA9IG5ldyBUeXBlQXJyYXkoIGdlb21ldHJ5LmluZGljZXMubGVuZ3RoICogMyApO1xyXG5cdFx0XHR0aGlzLnNldEluZGV4KCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBpbmRpY2VzLCAxICkuY29weUluZGljZXNBcnJheSggZ2VvbWV0cnkuaW5kaWNlcyApICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGdyb3Vwc1xyXG5cclxuXHRcdHRoaXMuZ3JvdXBzID0gZ2VvbWV0cnkuZ3JvdXBzO1xyXG5cclxuXHRcdC8vIG1vcnBoc1xyXG5cclxuXHRcdGZvciAoIHZhciBuYW1lIGluIGdlb21ldHJ5Lm1vcnBoVGFyZ2V0cyApIHtcclxuXHJcblx0XHRcdHZhciBhcnJheSA9IFtdO1xyXG5cdFx0XHR2YXIgbW9ycGhUYXJnZXRzID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzWyBuYW1lIF07XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBtb3JwaFRhcmdldHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0dmFyIG1vcnBoVGFyZ2V0ID0gbW9ycGhUYXJnZXRzWyBpIF07XHJcblxyXG5cdFx0XHRcdHZhciBhdHRyaWJ1dGUgPSBuZXcgVEhSRUUuRmxvYXQzMkF0dHJpYnV0ZSggbW9ycGhUYXJnZXQubGVuZ3RoICogMywgMyApO1xyXG5cclxuXHRcdFx0XHRhcnJheS5wdXNoKCBhdHRyaWJ1dGUuY29weVZlY3RvcjNzQXJyYXkoIG1vcnBoVGFyZ2V0ICkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMubW9ycGhBdHRyaWJ1dGVzWyBuYW1lIF0gPSBhcnJheTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gc2tpbm5pbmdcclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5LnNraW5JbmRpY2VzLmxlbmd0aCA+IDAgKSB7XHJcblxyXG5cdFx0XHR2YXIgc2tpbkluZGljZXMgPSBuZXcgVEhSRUUuRmxvYXQzMkF0dHJpYnV0ZSggZ2VvbWV0cnkuc2tpbkluZGljZXMubGVuZ3RoICogNCwgNCApO1xyXG5cdFx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3NraW5JbmRleCcsIHNraW5JbmRpY2VzLmNvcHlWZWN0b3I0c0FycmF5KCBnZW9tZXRyeS5za2luSW5kaWNlcyApICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggZ2VvbWV0cnkuc2tpbldlaWdodHMubGVuZ3RoID4gMCApIHtcclxuXHJcblx0XHRcdHZhciBza2luV2VpZ2h0cyA9IG5ldyBUSFJFRS5GbG9hdDMyQXR0cmlidXRlKCBnZW9tZXRyeS5za2luV2VpZ2h0cy5sZW5ndGggKiA0LCA0ICk7XHJcblx0XHRcdHRoaXMuYWRkQXR0cmlidXRlKCAnc2tpbldlaWdodCcsIHNraW5XZWlnaHRzLmNvcHlWZWN0b3I0c0FycmF5KCBnZW9tZXRyeS5za2luV2VpZ2h0cyApICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vXHJcblxyXG5cdFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZS5jbG9uZSgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nQm94ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0dGhpcy5ib3VuZGluZ0JveCA9IGdlb21ldHJ5LmJvdW5kaW5nQm94LmNsb25lKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb21wdXRlQm91bmRpbmdCb3g6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0aWYgKCB0aGlzLmJvdW5kaW5nQm94ID09PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLmJvdW5kaW5nQm94ID0gbmV3IFRIUkVFLkJveDMoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBwb3NpdGlvbnMgPSB0aGlzLmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XHJcblxyXG5cdFx0XHRpZiAoIHBvc2l0aW9ucyApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5ib3VuZGluZ0JveC5zZXRGcm9tQXJyYXkoIHBvc2l0aW9ucyApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBwb3NpdGlvbnMgPT09IHVuZGVmaW5lZCB8fCBwb3NpdGlvbnMubGVuZ3RoID09PSAwICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLmJvdW5kaW5nQm94Lm1pbi5zZXQoIDAsIDAsIDAgKTtcclxuXHRcdFx0XHR0aGlzLmJvdW5kaW5nQm94Lm1heC5zZXQoIDAsIDAsIDAgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggaXNOYU4oIHRoaXMuYm91bmRpbmdCb3gubWluLnggKSB8fCBpc05hTiggdGhpcy5ib3VuZGluZ0JveC5taW4ueSApIHx8IGlzTmFOKCB0aGlzLmJvdW5kaW5nQm94Lm1pbi56ICkgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5CdWZmZXJHZW9tZXRyeS5jb21wdXRlQm91bmRpbmdCb3g6IENvbXB1dGVkIG1pbi9tYXggaGF2ZSBOYU4gdmFsdWVzLiBUaGUgXCJwb3NpdGlvblwiIGF0dHJpYnV0ZSBpcyBsaWtlbHkgdG8gaGF2ZSBOYU4gdmFsdWVzLicsIHRoaXMgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGNvbXB1dGVCb3VuZGluZ1NwaGVyZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBib3ggPSBuZXcgVEhSRUUuQm94MygpO1xyXG5cdFx0dmFyIHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdGlmICggdGhpcy5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG5ldyBUSFJFRS5TcGhlcmUoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBwb3NpdGlvbnMgPSB0aGlzLmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XHJcblxyXG5cdFx0XHRpZiAoIHBvc2l0aW9ucyApIHtcclxuXHJcblx0XHRcdFx0dmFyIGNlbnRlciA9IHRoaXMuYm91bmRpbmdTcGhlcmUuY2VudGVyO1xyXG5cclxuXHRcdFx0XHRib3guc2V0RnJvbUFycmF5KCBwb3NpdGlvbnMgKTtcclxuXHRcdFx0XHRib3guY2VudGVyKCBjZW50ZXIgKTtcclxuXHJcblx0XHRcdFx0Ly8gaG9waW5nIHRvIGZpbmQgYSBib3VuZGluZ1NwaGVyZSB3aXRoIGEgcmFkaXVzIHNtYWxsZXIgdGhhbiB0aGVcclxuXHRcdFx0XHQvLyBib3VuZGluZ1NwaGVyZSBvZiB0aGUgYm91bmRpbmdCb3g6IHNxcnQoMykgc21hbGxlciBpbiB0aGUgYmVzdCBjYXNlXHJcblxyXG5cdFx0XHRcdHZhciBtYXhSYWRpdXNTcSA9IDA7XHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBwb3NpdGlvbnMubGVuZ3RoOyBpIDwgaWw7IGkgKz0gMyApIHtcclxuXHJcblx0XHRcdFx0XHR2ZWN0b3IuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGkgKTtcclxuXHRcdFx0XHRcdG1heFJhZGl1c1NxID0gTWF0aC5tYXgoIG1heFJhZGl1c1NxLCBjZW50ZXIuZGlzdGFuY2VUb1NxdWFyZWQoIHZlY3RvciApICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGhpcy5ib3VuZGluZ1NwaGVyZS5yYWRpdXMgPSBNYXRoLnNxcnQoIG1heFJhZGl1c1NxICk7XHJcblxyXG5cdFx0XHRcdGlmICggaXNOYU4oIHRoaXMuYm91bmRpbmdTcGhlcmUucmFkaXVzICkgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpOiBDb21wdXRlZCByYWRpdXMgaXMgTmFOLiBUaGUgXCJwb3NpdGlvblwiIGF0dHJpYnV0ZSBpcyBsaWtlbHkgdG8gaGF2ZSBOYU4gdmFsdWVzLicsIHRoaXMgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0Y29tcHV0ZUZhY2VOb3JtYWxzOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0Ly8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcclxuXHJcblx0fSxcclxuXHJcblx0Y29tcHV0ZVZlcnRleE5vcm1hbHM6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgaW5kZXggPSB0aGlzLmluZGV4O1xyXG5cdFx0dmFyIGF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXM7XHJcblx0XHR2YXIgZ3JvdXBzID0gdGhpcy5ncm91cHM7XHJcblxyXG5cdFx0aWYgKCBhdHRyaWJ1dGVzLnBvc2l0aW9uICkge1xyXG5cclxuXHRcdFx0dmFyIHBvc2l0aW9ucyA9IGF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XHJcblxyXG5cdFx0XHRpZiAoIGF0dHJpYnV0ZXMubm9ybWFsID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuYWRkQXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IEZsb2F0MzJBcnJheSggcG9zaXRpb25zLmxlbmd0aCApLCAzICkgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdC8vIHJlc2V0IGV4aXN0aW5nIG5vcm1hbHMgdG8gemVyb1xyXG5cclxuXHRcdFx0XHR2YXIgYXJyYXkgPSBhdHRyaWJ1dGVzLm5vcm1hbC5hcnJheTtcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdGFycmF5WyBpIF0gPSAwO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgbm9ybWFscyA9IGF0dHJpYnV0ZXMubm9ybWFsLmFycmF5O1xyXG5cclxuXHRcdFx0dmFyIHZBLCB2QiwgdkMsXHJcblxyXG5cdFx0XHRwQSA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXHJcblx0XHRcdHBCID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHRcdFx0cEMgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG5cclxuXHRcdFx0Y2IgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG5cdFx0XHRhYiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0XHQvLyBpbmRleGVkIGVsZW1lbnRzXHJcblxyXG5cdFx0XHRpZiAoIGluZGV4ICkge1xyXG5cclxuXHRcdFx0XHR2YXIgaW5kaWNlcyA9IGluZGV4LmFycmF5O1xyXG5cclxuXHRcdFx0XHRpZiAoIGdyb3Vwcy5sZW5ndGggPT09IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5hZGRHcm91cCggMCwgaW5kaWNlcy5sZW5ndGggKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gZ3JvdXBzLmxlbmd0aDsgaiA8IGpsOyArKyBqICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciBncm91cCA9IGdyb3Vwc1sgaiBdO1xyXG5cclxuXHRcdFx0XHRcdHZhciBzdGFydCA9IGdyb3VwLnN0YXJ0O1xyXG5cdFx0XHRcdFx0dmFyIGNvdW50ID0gZ3JvdXAuY291bnQ7XHJcblxyXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSBzdGFydCwgaWwgPSBzdGFydCArIGNvdW50OyBpIDwgaWw7IGkgKz0gMyApIHtcclxuXHJcblx0XHRcdFx0XHRcdHZBID0gaW5kaWNlc1sgaSArIDAgXSAqIDM7XHJcblx0XHRcdFx0XHRcdHZCID0gaW5kaWNlc1sgaSArIDEgXSAqIDM7XHJcblx0XHRcdFx0XHRcdHZDID0gaW5kaWNlc1sgaSArIDIgXSAqIDM7XHJcblxyXG5cdFx0XHRcdFx0XHRwQS5mcm9tQXJyYXkoIHBvc2l0aW9ucywgdkEgKTtcclxuXHRcdFx0XHRcdFx0cEIuZnJvbUFycmF5KCBwb3NpdGlvbnMsIHZCICk7XHJcblx0XHRcdFx0XHRcdHBDLmZyb21BcnJheSggcG9zaXRpb25zLCB2QyApO1xyXG5cclxuXHRcdFx0XHRcdFx0Y2Iuc3ViVmVjdG9ycyggcEMsIHBCICk7XHJcblx0XHRcdFx0XHRcdGFiLnN1YlZlY3RvcnMoIHBBLCBwQiApO1xyXG5cdFx0XHRcdFx0XHRjYi5jcm9zcyggYWIgKTtcclxuXHJcblx0XHRcdFx0XHRcdG5vcm1hbHNbIHZBIF0gKz0gY2IueDtcclxuXHRcdFx0XHRcdFx0bm9ybWFsc1sgdkEgKyAxIF0gKz0gY2IueTtcclxuXHRcdFx0XHRcdFx0bm9ybWFsc1sgdkEgKyAyIF0gKz0gY2IuejtcclxuXHJcblx0XHRcdFx0XHRcdG5vcm1hbHNbIHZCIF0gKz0gY2IueDtcclxuXHRcdFx0XHRcdFx0bm9ybWFsc1sgdkIgKyAxIF0gKz0gY2IueTtcclxuXHRcdFx0XHRcdFx0bm9ybWFsc1sgdkIgKyAyIF0gKz0gY2IuejtcclxuXHJcblx0XHRcdFx0XHRcdG5vcm1hbHNbIHZDIF0gKz0gY2IueDtcclxuXHRcdFx0XHRcdFx0bm9ybWFsc1sgdkMgKyAxIF0gKz0gY2IueTtcclxuXHRcdFx0XHRcdFx0bm9ybWFsc1sgdkMgKyAyIF0gKz0gY2IuejtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdC8vIG5vbi1pbmRleGVkIGVsZW1lbnRzICh1bmNvbm5lY3RlZCB0cmlhbmdsZSBzb3VwKVxyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gcG9zaXRpb25zLmxlbmd0aDsgaSA8IGlsOyBpICs9IDkgKSB7XHJcblxyXG5cdFx0XHRcdFx0cEEuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGkgKTtcclxuXHRcdFx0XHRcdHBCLmZyb21BcnJheSggcG9zaXRpb25zLCBpICsgMyApO1xyXG5cdFx0XHRcdFx0cEMuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGkgKyA2ICk7XHJcblxyXG5cdFx0XHRcdFx0Y2Iuc3ViVmVjdG9ycyggcEMsIHBCICk7XHJcblx0XHRcdFx0XHRhYi5zdWJWZWN0b3JzKCBwQSwgcEIgKTtcclxuXHRcdFx0XHRcdGNiLmNyb3NzKCBhYiApO1xyXG5cclxuXHRcdFx0XHRcdG5vcm1hbHNbIGkgXSA9IGNiLng7XHJcblx0XHRcdFx0XHRub3JtYWxzWyBpICsgMSBdID0gY2IueTtcclxuXHRcdFx0XHRcdG5vcm1hbHNbIGkgKyAyIF0gPSBjYi56O1xyXG5cclxuXHRcdFx0XHRcdG5vcm1hbHNbIGkgKyAzIF0gPSBjYi54O1xyXG5cdFx0XHRcdFx0bm9ybWFsc1sgaSArIDQgXSA9IGNiLnk7XHJcblx0XHRcdFx0XHRub3JtYWxzWyBpICsgNSBdID0gY2IuejtcclxuXHJcblx0XHRcdFx0XHRub3JtYWxzWyBpICsgNiBdID0gY2IueDtcclxuXHRcdFx0XHRcdG5vcm1hbHNbIGkgKyA3IF0gPSBjYi55O1xyXG5cdFx0XHRcdFx0bm9ybWFsc1sgaSArIDggXSA9IGNiLno7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMubm9ybWFsaXplTm9ybWFscygpO1xyXG5cclxuXHRcdFx0YXR0cmlidXRlcy5ub3JtYWwubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0bWVyZ2U6IGZ1bmN0aW9uICggZ2VvbWV0cnksIG9mZnNldCApIHtcclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuQnVmZmVyR2VvbWV0cnkgPT09IGZhbHNlICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5Lm1lcmdlKCk6IGdlb21ldHJ5IG5vdCBhbiBpbnN0YW5jZSBvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeS4nLCBnZW9tZXRyeSApO1xyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xyXG5cclxuXHRcdHZhciBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzO1xyXG5cclxuXHRcdGZvciAoIHZhciBrZXkgaW4gYXR0cmlidXRlcyApIHtcclxuXHJcblx0XHRcdGlmICggZ2VvbWV0cnkuYXR0cmlidXRlc1sga2V5IF0gPT09IHVuZGVmaW5lZCApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0dmFyIGF0dHJpYnV0ZTEgPSBhdHRyaWJ1dGVzWyBrZXkgXTtcclxuXHRcdFx0dmFyIGF0dHJpYnV0ZUFycmF5MSA9IGF0dHJpYnV0ZTEuYXJyYXk7XHJcblxyXG5cdFx0XHR2YXIgYXR0cmlidXRlMiA9IGdlb21ldHJ5LmF0dHJpYnV0ZXNbIGtleSBdO1xyXG5cdFx0XHR2YXIgYXR0cmlidXRlQXJyYXkyID0gYXR0cmlidXRlMi5hcnJheTtcclxuXHJcblx0XHRcdHZhciBhdHRyaWJ1dGVTaXplID0gYXR0cmlidXRlMi5pdGVtU2l6ZTtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMCwgaiA9IGF0dHJpYnV0ZVNpemUgKiBvZmZzZXQ7IGkgPCBhdHRyaWJ1dGVBcnJheTIubGVuZ3RoOyBpICsrLCBqICsrICkge1xyXG5cclxuXHRcdFx0XHRhdHRyaWJ1dGVBcnJheTFbIGogXSA9IGF0dHJpYnV0ZUFycmF5MlsgaSBdO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bm9ybWFsaXplTm9ybWFsczogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBub3JtYWxzID0gdGhpcy5hdHRyaWJ1dGVzLm5vcm1hbC5hcnJheTtcclxuXHJcblx0XHR2YXIgeCwgeSwgeiwgbjtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gbm9ybWFscy5sZW5ndGg7IGkgPCBpbDsgaSArPSAzICkge1xyXG5cclxuXHRcdFx0eCA9IG5vcm1hbHNbIGkgXTtcclxuXHRcdFx0eSA9IG5vcm1hbHNbIGkgKyAxIF07XHJcblx0XHRcdHogPSBub3JtYWxzWyBpICsgMiBdO1xyXG5cclxuXHRcdFx0biA9IDEuMCAvIE1hdGguc3FydCggeCAqIHggKyB5ICogeSArIHogKiB6ICk7XHJcblxyXG5cdFx0XHRub3JtYWxzWyBpIF0gKj0gbjtcclxuXHRcdFx0bm9ybWFsc1sgaSArIDEgXSAqPSBuO1xyXG5cdFx0XHRub3JtYWxzWyBpICsgMiBdICo9IG47XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHR0b05vbkluZGV4ZWQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRpZiAoIHRoaXMuaW5kZXggPT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJHZW9tZXRyeS50b05vbkluZGV4ZWQoKTogR2VvbWV0cnkgaXMgYWxyZWFkeSBub24taW5kZXhlZC4nICk7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZ2VvbWV0cnkyID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCk7XHJcblxyXG5cdFx0dmFyIGluZGljZXMgPSB0aGlzLmluZGV4LmFycmF5O1xyXG5cdFx0dmFyIGF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXM7XHJcblxyXG5cdFx0Zm9yICggdmFyIG5hbWUgaW4gYXR0cmlidXRlcyApIHtcclxuXHJcblx0XHRcdHZhciBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzWyBuYW1lIF07XHJcblxyXG5cdFx0XHR2YXIgYXJyYXkgPSBhdHRyaWJ1dGUuYXJyYXk7XHJcblx0XHRcdHZhciBpdGVtU2l6ZSA9IGF0dHJpYnV0ZS5pdGVtU2l6ZTtcclxuXHJcblx0XHRcdHZhciBhcnJheTIgPSBuZXcgYXJyYXkuY29uc3RydWN0b3IoIGluZGljZXMubGVuZ3RoICogaXRlbVNpemUgKTtcclxuXHJcblx0XHRcdHZhciBpbmRleCA9IDAsIGluZGV4MiA9IDA7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBpbmRpY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdGluZGV4ID0gaW5kaWNlc1sgaSBdICogaXRlbVNpemU7XHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciBqID0gMDsgaiA8IGl0ZW1TaXplOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHRcdGFycmF5MlsgaW5kZXgyICsrIF0gPSBhcnJheVsgaW5kZXggKysgXTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Z2VvbWV0cnkyLmFkZEF0dHJpYnV0ZSggbmFtZSwgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggYXJyYXkyLCBpdGVtU2l6ZSApICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBnZW9tZXRyeTI7XHJcblxyXG5cdH0sXHJcblxyXG5cdHRvSlNPTjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBkYXRhID0ge1xyXG5cdFx0XHRtZXRhZGF0YToge1xyXG5cdFx0XHRcdHZlcnNpb246IDQuNCxcclxuXHRcdFx0XHR0eXBlOiAnQnVmZmVyR2VvbWV0cnknLFxyXG5cdFx0XHRcdGdlbmVyYXRvcjogJ0J1ZmZlckdlb21ldHJ5LnRvSlNPTidcclxuXHRcdFx0fVxyXG5cdFx0fTtcclxuXHJcblx0XHQvLyBzdGFuZGFyZCBCdWZmZXJHZW9tZXRyeSBzZXJpYWxpemF0aW9uXHJcblxyXG5cdFx0ZGF0YS51dWlkID0gdGhpcy51dWlkO1xyXG5cdFx0ZGF0YS50eXBlID0gdGhpcy50eXBlO1xyXG5cdFx0aWYgKCB0aGlzLm5hbWUgIT09ICcnICkgZGF0YS5uYW1lID0gdGhpcy5uYW1lO1xyXG5cclxuXHRcdGlmICggdGhpcy5wYXJhbWV0ZXJzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHR2YXIgcGFyYW1ldGVycyA9IHRoaXMucGFyYW1ldGVycztcclxuXHJcblx0XHRcdGZvciAoIHZhciBrZXkgaW4gcGFyYW1ldGVycyApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBwYXJhbWV0ZXJzWyBrZXkgXSAhPT0gdW5kZWZpbmVkICkgZGF0YVsga2V5IF0gPSBwYXJhbWV0ZXJzWyBrZXkgXTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBkYXRhO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRkYXRhLmRhdGEgPSB7IGF0dHJpYnV0ZXM6IHt9IH07XHJcblxyXG5cdFx0dmFyIGluZGV4ID0gdGhpcy5pbmRleDtcclxuXHJcblx0XHRpZiAoIGluZGV4ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0dmFyIGFycmF5ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGluZGV4LmFycmF5ICk7XHJcblxyXG5cdFx0XHRkYXRhLmRhdGEuaW5kZXggPSB7XHJcblx0XHRcdFx0dHlwZTogaW5kZXguYXJyYXkuY29uc3RydWN0b3IubmFtZSxcclxuXHRcdFx0XHRhcnJheTogYXJyYXlcclxuXHRcdFx0fTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXM7XHJcblxyXG5cdFx0Zm9yICggdmFyIGtleSBpbiBhdHRyaWJ1dGVzICkge1xyXG5cclxuXHRcdFx0dmFyIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbIGtleSBdO1xyXG5cclxuXHRcdFx0dmFyIGFycmF5ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGF0dHJpYnV0ZS5hcnJheSApO1xyXG5cclxuXHRcdFx0ZGF0YS5kYXRhLmF0dHJpYnV0ZXNbIGtleSBdID0ge1xyXG5cdFx0XHRcdGl0ZW1TaXplOiBhdHRyaWJ1dGUuaXRlbVNpemUsXHJcblx0XHRcdFx0dHlwZTogYXR0cmlidXRlLmFycmF5LmNvbnN0cnVjdG9yLm5hbWUsXHJcblx0XHRcdFx0YXJyYXk6IGFycmF5XHJcblx0XHRcdH07XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBncm91cHMgPSB0aGlzLmdyb3VwcztcclxuXHJcblx0XHRpZiAoIGdyb3Vwcy5sZW5ndGggPiAwICkge1xyXG5cclxuXHRcdFx0ZGF0YS5kYXRhLmdyb3VwcyA9IEpTT04ucGFyc2UoIEpTT04uc3RyaW5naWZ5KCBncm91cHMgKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgYm91bmRpbmdTcGhlcmUgPSB0aGlzLmJvdW5kaW5nU3BoZXJlO1xyXG5cclxuXHRcdGlmICggYm91bmRpbmdTcGhlcmUgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRkYXRhLmRhdGEuYm91bmRpbmdTcGhlcmUgPSB7XHJcblx0XHRcdFx0Y2VudGVyOiBib3VuZGluZ1NwaGVyZS5jZW50ZXIudG9BcnJheSgpLFxyXG5cdFx0XHRcdHJhZGl1czogYm91bmRpbmdTcGhlcmUucmFkaXVzXHJcblx0XHRcdH07XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBkYXRhO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdC8qXHJcblx0XHQvLyBIYW5kbGUgcHJpbWl0aXZlc1xyXG5cclxuXHRcdHZhciBwYXJhbWV0ZXJzID0gdGhpcy5wYXJhbWV0ZXJzO1xyXG5cclxuXHRcdGlmICggcGFyYW1ldGVycyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0dmFyIHZhbHVlcyA9IFtdO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGtleSBpbiBwYXJhbWV0ZXJzICkge1xyXG5cclxuXHRcdFx0XHR2YWx1ZXMucHVzaCggcGFyYW1ldGVyc1sga2V5IF0gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBnZW9tZXRyeSA9IE9iamVjdC5jcmVhdGUoIHRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlICk7XHJcblx0XHRcdHRoaXMuY29uc3RydWN0b3IuYXBwbHkoIGdlb21ldHJ5LCB2YWx1ZXMgKTtcclxuXHRcdFx0cmV0dXJuIGdlb21ldHJ5O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XHJcblx0XHQqL1xyXG5cclxuXHRcdHJldHVybiBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKS5jb3B5KCB0aGlzICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuXHRcdHZhciBpbmRleCA9IHNvdXJjZS5pbmRleDtcclxuXHJcblx0XHRpZiAoIGluZGV4ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0dGhpcy5zZXRJbmRleCggaW5kZXguY2xvbmUoKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgYXR0cmlidXRlcyA9IHNvdXJjZS5hdHRyaWJ1dGVzO1xyXG5cclxuXHRcdGZvciAoIHZhciBuYW1lIGluIGF0dHJpYnV0ZXMgKSB7XHJcblxyXG5cdFx0XHR2YXIgYXR0cmlidXRlID0gYXR0cmlidXRlc1sgbmFtZSBdO1xyXG5cdFx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggbmFtZSwgYXR0cmlidXRlLmNsb25lKCkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGdyb3VwcyA9IHNvdXJjZS5ncm91cHM7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gZ3JvdXBzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgZ3JvdXAgPSBncm91cHNbIGkgXTtcclxuXHRcdFx0dGhpcy5hZGRHcm91cCggZ3JvdXAuc3RhcnQsIGdyb3VwLmNvdW50ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdkaXNwb3NlJyB9ICk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmFwcGx5KCBUSFJFRS5CdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuXHJcblRIUkVFLkJ1ZmZlckdlb21ldHJ5Lk1heEluZGV4ID0gNjU1MzU7XHJcblxyXG4vLyBGaWxlOnNyYy9jb3JlL0luc3RhbmNlZEJ1ZmZlckdlb21ldHJ5LmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBiZW5hYWRhbXMgLyBodHRwczovL3R3aXR0ZXIuY29tL2Jlbl9hX2FkYW1zXHJcbiAqL1xyXG5cclxuVEhSRUUuSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFRIUkVFLkJ1ZmZlckdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy50eXBlID0gJ0luc3RhbmNlZEJ1ZmZlckdlb21ldHJ5JztcclxuXHR0aGlzLm1heEluc3RhbmNlZENvdW50ID0gdW5kZWZpbmVkO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG5USFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeTtcclxuXHJcblRIUkVFLkluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5hZGRHcm91cCA9IGZ1bmN0aW9uICggc3RhcnQsIGNvdW50LCBpbnN0YW5jZXMgKSB7XHJcblxyXG5cdHRoaXMuZ3JvdXBzLnB1c2goIHtcclxuXHJcblx0XHRzdGFydDogc3RhcnQsXHJcblx0XHRjb3VudDogY291bnQsXHJcblx0XHRpbnN0YW5jZXM6IGluc3RhbmNlc1xyXG5cclxuXHR9ICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcblx0dmFyIGluZGV4ID0gc291cmNlLmluZGV4O1xyXG5cclxuXHRpZiAoIGluZGV4ICE9PSBudWxsICkge1xyXG5cclxuXHRcdHRoaXMuc2V0SW5kZXgoIGluZGV4LmNsb25lKCkgKTtcclxuXHJcblx0fVxyXG5cclxuXHR2YXIgYXR0cmlidXRlcyA9IHNvdXJjZS5hdHRyaWJ1dGVzO1xyXG5cclxuXHRmb3IgKCB2YXIgbmFtZSBpbiBhdHRyaWJ1dGVzICkge1xyXG5cclxuXHRcdHZhciBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzWyBuYW1lIF07XHJcblx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggbmFtZSwgYXR0cmlidXRlLmNsb25lKCkgKTtcclxuXHJcblx0fVxyXG5cclxuXHR2YXIgZ3JvdXBzID0gc291cmNlLmdyb3VwcztcclxuXHJcblx0Zm9yICggdmFyIGkgPSAwLCBsID0gZ3JvdXBzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0dmFyIGdyb3VwID0gZ3JvdXBzWyBpIF07XHJcblx0XHR0aGlzLmFkZEdyb3VwKCBncm91cC5zdGFydCwgZ3JvdXAuY291bnQsIGdyb3VwLmluc3RhbmNlcyApO1xyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiB0aGlzO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuYXBwbHkoIFRIUkVFLkluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG5cclxuLy8gRmlsZTpzcmMvY29yZS9Vbmlmb3JtLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5Vbmlmb3JtID0gZnVuY3Rpb24gKCB0eXBlLCB2YWx1ZSApIHtcclxuXHJcblx0dGhpcy50eXBlID0gdHlwZTtcclxuXHR0aGlzLnZhbHVlID0gdmFsdWU7XHJcblxyXG5cdHRoaXMuZHluYW1pYyA9IGZhbHNlO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlVuaWZvcm0ucHJvdG90eXBlID0ge1xyXG5cclxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuVW5pZm9ybSxcclxuXHJcblx0b25VcGRhdGU6IGZ1bmN0aW9uICggY2FsbGJhY2sgKSB7XHJcblxyXG5cdFx0dGhpcy5keW5hbWljID0gdHJ1ZTtcclxuXHRcdHRoaXMub25VcGRhdGVDYWxsYmFjayA9IGNhbGxiYWNrO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvYW5pbWF0aW9uL0FuaW1hdGlvbkNsaXAuanNcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBSZXVzYWJsZSBzZXQgb2YgVHJhY2tzIHRoYXQgcmVwcmVzZW50IGFuIGFuaW1hdGlvbi5cclxuICpcclxuICogQGF1dGhvciBCZW4gSG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pby9cclxuICogQGF1dGhvciBEYXZpZCBTYXJubyAvIGh0dHA6Ly9saWdodGhhdXMudXMvXHJcbiAqL1xyXG5cclxuVEhSRUUuQW5pbWF0aW9uQ2xpcCA9IGZ1bmN0aW9uICggbmFtZSwgZHVyYXRpb24sIHRyYWNrcyApIHtcclxuXHJcblx0dGhpcy5uYW1lID0gbmFtZSB8fCBUSFJFRS5NYXRoLmdlbmVyYXRlVVVJRCgpO1xyXG5cdHRoaXMudHJhY2tzID0gdHJhY2tzO1xyXG5cdHRoaXMuZHVyYXRpb24gPSAoIGR1cmF0aW9uICE9PSB1bmRlZmluZWQgKSA/IGR1cmF0aW9uIDogLTE7XHJcblxyXG5cdC8vIHRoaXMgbWVhbnMgaXQgc2hvdWxkIGZpZ3VyZSBvdXQgaXRzIGR1cmF0aW9uIGJ5IHNjYW5uaW5nIHRoZSB0cmFja3NcclxuXHRpZiAoIHRoaXMuZHVyYXRpb24gPCAwICkge1xyXG5cclxuXHRcdHRoaXMucmVzZXREdXJhdGlvbigpO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIG1heWJlIG9ubHkgZG8gdGhlc2Ugb24gZGVtYW5kLCBhcyBkb2luZyB0aGVtIGhlcmUgY291bGQgcG90ZW50aWFsbHkgc2xvdyBkb3duIGxvYWRpbmdcclxuXHQvLyBidXQgbGVhdmluZyB0aGVzZSBoZXJlIGR1cmluZyBkZXZlbG9wbWVudCBhcyB0aGlzIGVuc3VyZXMgYSBsb3Qgb2YgdGVzdGluZyBvZiB0aGVzZSBmdW5jdGlvbnNcclxuXHR0aGlzLnRyaW0oKTtcclxuXHR0aGlzLm9wdGltaXplKCk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQW5pbWF0aW9uQ2xpcC5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5BbmltYXRpb25DbGlwLFxyXG5cclxuXHRyZXNldER1cmF0aW9uOiBmdW5jdGlvbigpIHtcclxuXHJcblx0XHR2YXIgdHJhY2tzID0gdGhpcy50cmFja3MsXHJcblx0XHRcdGR1cmF0aW9uID0gMDtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIG4gPSB0cmFja3MubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xyXG5cclxuXHRcdFx0dmFyIHRyYWNrID0gdGhpcy50cmFja3NbIGkgXTtcclxuXHJcblx0XHRcdGR1cmF0aW9uID0gTWF0aC5tYXgoXHJcblx0XHRcdFx0XHRkdXJhdGlvbiwgdHJhY2sudGltZXNbIHRyYWNrLnRpbWVzLmxlbmd0aCAtIDEgXSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmR1cmF0aW9uID0gZHVyYXRpb247XHJcblxyXG5cdH0sXHJcblxyXG5cdHRyaW06IGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMudHJhY2tzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdHRoaXMudHJhY2tzWyBpIF0udHJpbSggMCwgdGhpcy5kdXJhdGlvbiApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0b3B0aW1pemU6IGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMudHJhY2tzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdHRoaXMudHJhY2tzWyBpIF0ub3B0aW1pemUoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vLyBTdGF0aWMgbWV0aG9kczpcclxuXHJcbk9iamVjdC5hc3NpZ24oIFRIUkVFLkFuaW1hdGlvbkNsaXAsIHtcclxuXHJcblx0cGFyc2U6IGZ1bmN0aW9uKCBqc29uICkge1xyXG5cclxuXHRcdHZhciB0cmFja3MgPSBbXSxcclxuXHRcdFx0anNvblRyYWNrcyA9IGpzb24udHJhY2tzLFxyXG5cdFx0XHRmcmFtZVRpbWUgPSAxLjAgLyAoIGpzb24uZnBzIHx8IDEuMCApO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgbiA9IGpzb25UcmFja3MubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xyXG5cclxuXHRcdFx0dHJhY2tzLnB1c2goIFRIUkVFLktleWZyYW1lVHJhY2sucGFyc2UoIGpzb25UcmFja3NbIGkgXSApLnNjYWxlKCBmcmFtZVRpbWUgKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbmV3IFRIUkVFLkFuaW1hdGlvbkNsaXAoIGpzb24ubmFtZSwganNvbi5kdXJhdGlvbiwgdHJhY2tzICk7XHJcblxyXG5cdH0sXHJcblxyXG5cclxuXHR0b0pTT046IGZ1bmN0aW9uKCBjbGlwICkge1xyXG5cclxuXHRcdHZhciB0cmFja3MgPSBbXSxcclxuXHRcdFx0Y2xpcFRyYWNrcyA9IGNsaXAudHJhY2tzO1xyXG5cclxuXHRcdHZhciBqc29uID0ge1xyXG5cclxuXHRcdFx0J25hbWUnOiBjbGlwLm5hbWUsXHJcblx0XHRcdCdkdXJhdGlvbic6IGNsaXAuZHVyYXRpb24sXHJcblx0XHRcdCd0cmFja3MnOiB0cmFja3NcclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgbiA9IGNsaXBUcmFja3MubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xyXG5cclxuXHRcdFx0dHJhY2tzLnB1c2goIFRIUkVFLktleWZyYW1lVHJhY2sudG9KU09OKCBjbGlwVHJhY2tzWyBpIF0gKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4ganNvbjtcclxuXHJcblx0fSxcclxuXHJcblxyXG5cdENyZWF0ZUZyb21Nb3JwaFRhcmdldFNlcXVlbmNlOiBmdW5jdGlvbiggbmFtZSwgbW9ycGhUYXJnZXRTZXF1ZW5jZSwgZnBzICkge1xyXG5cclxuXHRcdHZhciBudW1Nb3JwaFRhcmdldHMgPSBtb3JwaFRhcmdldFNlcXVlbmNlLmxlbmd0aDtcclxuXHRcdHZhciB0cmFja3MgPSBbXTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBudW1Nb3JwaFRhcmdldHM7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgdGltZXMgPSBbXTtcclxuXHRcdFx0dmFyIHZhbHVlcyA9IFtdO1xyXG5cclxuXHRcdFx0dGltZXMucHVzaChcclxuXHRcdFx0XHRcdCggaSArIG51bU1vcnBoVGFyZ2V0cyAtIDEgKSAlIG51bU1vcnBoVGFyZ2V0cyxcclxuXHRcdFx0XHRcdGksXHJcblx0XHRcdFx0XHQoIGkgKyAxICkgJSBudW1Nb3JwaFRhcmdldHMgKTtcclxuXHJcblx0XHRcdHZhbHVlcy5wdXNoKCAwLCAxLCAwICk7XHJcblxyXG5cdFx0XHR2YXIgb3JkZXIgPSBUSFJFRS5BbmltYXRpb25VdGlscy5nZXRLZXlmcmFtZU9yZGVyKCB0aW1lcyApO1xyXG5cdFx0XHR0aW1lcyA9IFRIUkVFLkFuaW1hdGlvblV0aWxzLnNvcnRlZEFycmF5KCB0aW1lcywgMSwgb3JkZXIgKTtcclxuXHRcdFx0dmFsdWVzID0gVEhSRUUuQW5pbWF0aW9uVXRpbHMuc29ydGVkQXJyYXkoIHZhbHVlcywgMSwgb3JkZXIgKTtcclxuXHJcblx0XHRcdC8vIGlmIHRoZXJlIGlzIGEga2V5IGF0IHRoZSBmaXJzdCBmcmFtZSwgZHVwbGljYXRlIGl0IGFzIHRoZVxyXG5cdFx0XHQvLyBsYXN0IGZyYW1lIGFzIHdlbGwgZm9yIHBlcmZlY3QgbG9vcC5cclxuXHRcdFx0aWYgKCB0aW1lc1sgMCBdID09PSAwICkge1xyXG5cclxuXHRcdFx0XHR0aW1lcy5wdXNoKCBudW1Nb3JwaFRhcmdldHMgKTtcclxuXHRcdFx0XHR2YWx1ZXMucHVzaCggdmFsdWVzWyAwIF0gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRyYWNrcy5wdXNoKFxyXG5cdFx0XHRcdFx0bmV3IFRIUkVFLk51bWJlcktleWZyYW1lVHJhY2soXHJcblx0XHRcdFx0XHRcdCcubW9ycGhUYXJnZXRJbmZsdWVuY2VzWycgKyBtb3JwaFRhcmdldFNlcXVlbmNlWyBpIF0ubmFtZSArICddJyxcclxuXHRcdFx0XHRcdFx0dGltZXMsIHZhbHVlc1xyXG5cdFx0XHRcdFx0KS5zY2FsZSggMS4wIC8gZnBzICkgKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbmV3IFRIUkVFLkFuaW1hdGlvbkNsaXAoIG5hbWUsIC0xLCB0cmFja3MgKTtcclxuXHJcblx0fSxcclxuXHJcblx0ZmluZEJ5TmFtZTogZnVuY3Rpb24oIGNsaXBBcnJheSwgbmFtZSApIHtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBjbGlwQXJyYXkubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0aWYgKCBjbGlwQXJyYXlbIGkgXS5uYW1lID09PSBuYW1lICkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gY2xpcEFycmF5WyBpIF07XHJcblxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG51bGw7XHJcblxyXG5cdH0sXHJcblxyXG5cdENyZWF0ZUNsaXBzRnJvbU1vcnBoVGFyZ2V0U2VxdWVuY2VzOiBmdW5jdGlvbiggbW9ycGhUYXJnZXRzLCBmcHMgKSB7XHJcblxyXG5cdFx0dmFyIGFuaW1hdGlvblRvTW9ycGhUYXJnZXRzID0ge307XHJcblxyXG5cdFx0Ly8gdGVzdGVkIHdpdGggaHR0cHM6Ly9yZWdleDEwMS5jb20vIG9uIHRyaWNrIHNlcXVlbmNlc1xyXG5cdFx0Ly8gc3VjaCBmbGFtaW5nb19mbHlBXzAwMywgZmxhbWluZ29fcnVuMV8wMDMsIGNyZGVhdGgwMDU5XHJcblx0XHR2YXIgcGF0dGVybiA9IC9eKFtcXHctXSo/KShbXFxkXSspJC87XHJcblxyXG5cdFx0Ly8gc29ydCBtb3JwaCB0YXJnZXQgbmFtZXMgaW50byBhbmltYXRpb24gZ3JvdXBzIGJhc2VkXHJcblx0XHQvLyBwYXR0ZXJucyBsaWtlIFdhbGtfMDAxLCBXYWxrXzAwMiwgUnVuXzAwMSwgUnVuXzAwMlxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IG1vcnBoVGFyZ2V0cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciBtb3JwaFRhcmdldCA9IG1vcnBoVGFyZ2V0c1sgaSBdO1xyXG5cdFx0XHR2YXIgcGFydHMgPSBtb3JwaFRhcmdldC5uYW1lLm1hdGNoKCBwYXR0ZXJuICk7XHJcblxyXG5cdFx0XHRpZiAoIHBhcnRzICYmIHBhcnRzLmxlbmd0aCA+IDEgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBuYW1lID0gcGFydHNbIDEgXTtcclxuXHJcblx0XHRcdFx0dmFyIGFuaW1hdGlvbk1vcnBoVGFyZ2V0cyA9IGFuaW1hdGlvblRvTW9ycGhUYXJnZXRzWyBuYW1lIF07XHJcblx0XHRcdFx0aWYgKCAhIGFuaW1hdGlvbk1vcnBoVGFyZ2V0cyApIHtcclxuXHJcblx0XHRcdFx0XHRhbmltYXRpb25Ub01vcnBoVGFyZ2V0c1sgbmFtZSBdID0gYW5pbWF0aW9uTW9ycGhUYXJnZXRzID0gW107XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0YW5pbWF0aW9uTW9ycGhUYXJnZXRzLnB1c2goIG1vcnBoVGFyZ2V0ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBjbGlwcyA9IFtdO1xyXG5cclxuXHRcdGZvciAoIHZhciBuYW1lIGluIGFuaW1hdGlvblRvTW9ycGhUYXJnZXRzICkge1xyXG5cclxuXHRcdFx0Y2xpcHMucHVzaCggVEhSRUUuQW5pbWF0aW9uQ2xpcC5DcmVhdGVGcm9tTW9ycGhUYXJnZXRTZXF1ZW5jZSggbmFtZSwgYW5pbWF0aW9uVG9Nb3JwaFRhcmdldHNbIG5hbWUgXSwgZnBzICkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGNsaXBzO1xyXG5cclxuXHR9LFxyXG5cclxuXHQvLyBwYXJzZSB0aGUgYW5pbWF0aW9uLmhpZXJhcmNoeSBmb3JtYXRcclxuXHRwYXJzZUFuaW1hdGlvbjogZnVuY3Rpb24oIGFuaW1hdGlvbiwgYm9uZXMsIG5vZGVOYW1lICkge1xyXG5cclxuXHRcdGlmICggISBhbmltYXRpb24gKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLmVycm9yKCBcIiAgbm8gYW5pbWF0aW9uIGluIEpTT05Mb2FkZXIgZGF0YVwiICk7XHJcblx0XHRcdHJldHVybiBudWxsO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgYWRkTm9uZW1wdHlUcmFjayA9IGZ1bmN0aW9uKFxyXG5cdFx0XHRcdHRyYWNrVHlwZSwgdHJhY2tOYW1lLCBhbmltYXRpb25LZXlzLCBwcm9wZXJ0eU5hbWUsIGRlc3RUcmFja3MgKSB7XHJcblxyXG5cdFx0XHQvLyBvbmx5IHJldHVybiB0cmFjayBpZiB0aGVyZSBhcmUgYWN0dWFsbHkga2V5cy5cclxuXHRcdFx0aWYgKCBhbmltYXRpb25LZXlzLmxlbmd0aCAhPT0gMCApIHtcclxuXHJcblx0XHRcdFx0dmFyIHRpbWVzID0gW107XHJcblx0XHRcdFx0dmFyIHZhbHVlcyA9IFtdO1xyXG5cclxuXHRcdFx0XHRUSFJFRS5BbmltYXRpb25VdGlscy5mbGF0dGVuSlNPTihcclxuXHRcdFx0XHRcdFx0YW5pbWF0aW9uS2V5cywgdGltZXMsIHZhbHVlcywgcHJvcGVydHlOYW1lICk7XHJcblxyXG5cdFx0XHRcdC8vIGVtcHR5IGtleXMgYXJlIGZpbHRlcmVkIG91dCwgc28gY2hlY2sgYWdhaW5cclxuXHRcdFx0XHRpZiAoIHRpbWVzLmxlbmd0aCAhPT0gMCApIHtcclxuXHJcblx0XHRcdFx0XHRkZXN0VHJhY2tzLnB1c2goIG5ldyB0cmFja1R5cGUoIHRyYWNrTmFtZSwgdGltZXMsIHZhbHVlcyApICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdHZhciB0cmFja3MgPSBbXTtcclxuXHJcblx0XHR2YXIgY2xpcE5hbWUgPSBhbmltYXRpb24ubmFtZSB8fCAnZGVmYXVsdCc7XHJcblx0XHQvLyBhdXRvbWF0aWMgbGVuZ3RoIGRldGVybWluYXRpb24gaW4gQW5pbWF0aW9uQ2xpcC5cclxuXHRcdHZhciBkdXJhdGlvbiA9IGFuaW1hdGlvbi5sZW5ndGggfHwgLTE7XHJcblx0XHR2YXIgZnBzID0gYW5pbWF0aW9uLmZwcyB8fCAzMDtcclxuXHJcblx0XHR2YXIgaGllcmFyY2h5VHJhY2tzID0gYW5pbWF0aW9uLmhpZXJhcmNoeSB8fCBbXTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaCA9IDA7IGggPCBoaWVyYXJjaHlUcmFja3MubGVuZ3RoOyBoICsrICkge1xyXG5cclxuXHRcdFx0dmFyIGFuaW1hdGlvbktleXMgPSBoaWVyYXJjaHlUcmFja3NbIGggXS5rZXlzO1xyXG5cclxuXHRcdFx0Ly8gc2tpcCBlbXB0eSB0cmFja3NcclxuXHRcdFx0aWYgKCAhIGFuaW1hdGlvbktleXMgfHwgYW5pbWF0aW9uS2V5cy5sZW5ndGggPT0gMCApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0Ly8gcHJvY2VzcyBtb3JwaCB0YXJnZXRzIGluIGEgd2F5IGV4YWN0bHkgY29tcGF0aWJsZVxyXG5cdFx0XHQvLyB3aXRoIEFuaW1hdGlvbkhhbmRsZXIuaW5pdCggYW5pbWF0aW9uIClcclxuXHRcdFx0aWYgKCBhbmltYXRpb25LZXlzWzBdLm1vcnBoVGFyZ2V0cyApIHtcclxuXHJcblx0XHRcdFx0Ly8gZmlndXJlIG91dCBhbGwgbW9ycGggdGFyZ2V0cyB1c2VkIGluIHRoaXMgdHJhY2tcclxuXHRcdFx0XHR2YXIgbW9ycGhUYXJnZXROYW1lcyA9IHt9O1xyXG5cdFx0XHRcdGZvciAoIHZhciBrID0gMDsgayA8IGFuaW1hdGlvbktleXMubGVuZ3RoOyBrICsrICkge1xyXG5cclxuXHRcdFx0XHRcdGlmICggYW5pbWF0aW9uS2V5c1trXS5tb3JwaFRhcmdldHMgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgbSA9IDA7IG0gPCBhbmltYXRpb25LZXlzW2tdLm1vcnBoVGFyZ2V0cy5sZW5ndGg7IG0gKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdG1vcnBoVGFyZ2V0TmFtZXNbIGFuaW1hdGlvbktleXNba10ubW9ycGhUYXJnZXRzW21dIF0gPSAtMTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBjcmVhdGUgYSB0cmFjayBmb3IgZWFjaCBtb3JwaCB0YXJnZXQgd2l0aCBhbGwgemVyb1xyXG5cdFx0XHRcdC8vIG1vcnBoVGFyZ2V0SW5mbHVlbmNlcyBleGNlcHQgZm9yIHRoZSBrZXlzIGluIHdoaWNoXHJcblx0XHRcdFx0Ly8gdGhlIG1vcnBoVGFyZ2V0IGlzIG5hbWVkLlxyXG5cdFx0XHRcdGZvciAoIHZhciBtb3JwaFRhcmdldE5hbWUgaW4gbW9ycGhUYXJnZXROYW1lcyApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgdGltZXMgPSBbXTtcclxuXHRcdFx0XHRcdHZhciB2YWx1ZXMgPSBbXTtcclxuXHJcblx0XHRcdFx0XHRmb3IgKCB2YXIgbSA9IDA7XHJcblx0XHRcdFx0XHRcdFx0bSAhPT0gYW5pbWF0aW9uS2V5c1trXS5tb3JwaFRhcmdldHMubGVuZ3RoOyArKyBtICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dmFyIGFuaW1hdGlvbktleSA9IGFuaW1hdGlvbktleXNba107XHJcblxyXG5cdFx0XHRcdFx0XHR0aW1lcy5wdXNoKCBhbmltYXRpb25LZXkudGltZSApO1xyXG5cdFx0XHRcdFx0XHR2YWx1ZXMucHVzaCggKCBhbmltYXRpb25LZXkubW9ycGhUYXJnZXQgPT09IG1vcnBoVGFyZ2V0TmFtZSApID8gMSA6IDAgKVxyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR0cmFja3MucHVzaCggbmV3IFRIUkVFLk51bWJlcktleWZyYW1lVHJhY2soXHJcblx0XHRcdFx0XHRcdFx0Jy5tb3JwaFRhcmdldEluZmx1ZW5jZVsnICsgbW9ycGhUYXJnZXROYW1lICsgJ10nLCB0aW1lcywgdmFsdWVzICkgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRkdXJhdGlvbiA9IG1vcnBoVGFyZ2V0TmFtZXMubGVuZ3RoICogKCBmcHMgfHwgMS4wICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdC8vIC4uLmFzc3VtZSBza2VsZXRhbCBhbmltYXRpb25cclxuXHJcblx0XHRcdFx0dmFyIGJvbmVOYW1lID0gJy5ib25lc1snICsgYm9uZXNbIGggXS5uYW1lICsgJ10nO1xyXG5cclxuXHRcdFx0XHRhZGROb25lbXB0eVRyYWNrKFxyXG5cdFx0XHRcdFx0XHRUSFJFRS5WZWN0b3JLZXlmcmFtZVRyYWNrLCBib25lTmFtZSArICcucG9zaXRpb24nLFxyXG5cdFx0XHRcdFx0XHRhbmltYXRpb25LZXlzLCAncG9zJywgdHJhY2tzICk7XHJcblxyXG5cdFx0XHRcdGFkZE5vbmVtcHR5VHJhY2soXHJcblx0XHRcdFx0XHRcdFRIUkVFLlF1YXRlcm5pb25LZXlmcmFtZVRyYWNrLCBib25lTmFtZSArICcucXVhdGVybmlvbicsXHJcblx0XHRcdFx0XHRcdGFuaW1hdGlvbktleXMsICdyb3QnLCB0cmFja3MgKTtcclxuXHJcblx0XHRcdFx0YWRkTm9uZW1wdHlUcmFjayhcclxuXHRcdFx0XHRcdFx0VEhSRUUuVmVjdG9yS2V5ZnJhbWVUcmFjaywgYm9uZU5hbWUgKyAnLnNjYWxlJyxcclxuXHRcdFx0XHRcdFx0YW5pbWF0aW9uS2V5cywgJ3NjbCcsIHRyYWNrcyApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHRyYWNrcy5sZW5ndGggPT09IDAgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGNsaXAgPSBuZXcgVEhSRUUuQW5pbWF0aW9uQ2xpcCggY2xpcE5hbWUsIGR1cmF0aW9uLCB0cmFja3MgKTtcclxuXHJcblx0XHRyZXR1cm4gY2xpcDtcclxuXHJcblx0fVxyXG5cclxufSApO1xyXG5cclxuXHJcbi8vIEZpbGU6c3JjL2FuaW1hdGlvbi9BbmltYXRpb25NaXhlci5qc1xyXG5cclxuLyoqXHJcbiAqXHJcbiAqIFBsYXllciBmb3IgQW5pbWF0aW9uQ2xpcHMuXHJcbiAqXHJcbiAqXHJcbiAqIEBhdXRob3IgQmVuIEhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW8vXHJcbiAqIEBhdXRob3IgRGF2aWQgU2Fybm8gLyBodHRwOi8vbGlnaHRoYXVzLnVzL1xyXG4gKiBAYXV0aG9yIHRzY2h3XHJcbiAqL1xyXG5cclxuVEhSRUUuQW5pbWF0aW9uTWl4ZXIgPSBmdW5jdGlvbiggcm9vdCApIHtcclxuXHJcblx0dGhpcy5fcm9vdCA9IHJvb3Q7XHJcblx0dGhpcy5faW5pdE1lbW9yeU1hbmFnZXIoKTtcclxuXHR0aGlzLl9hY2N1SW5kZXggPSAwO1xyXG5cclxuXHR0aGlzLnRpbWUgPSAwO1xyXG5cclxuXHR0aGlzLnRpbWVTY2FsZSA9IDEuMDtcclxuXHJcbn07XHJcblxyXG5USFJFRS5BbmltYXRpb25NaXhlci5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5BbmltYXRpb25NaXhlcixcclxuXHJcblx0Ly8gcmV0dXJuIGFuIGFjdGlvbiBmb3IgYSBjbGlwIG9wdGlvbmFsbHkgdXNpbmcgYSBjdXN0b20gcm9vdCB0YXJnZXRcclxuXHQvLyBvYmplY3QgKHRoaXMgbWV0aG9kIGFsbG9jYXRlcyBhIGxvdCBvZiBkeW5hbWljIG1lbW9yeSBpbiBjYXNlIGFcclxuXHQvLyBwcmV2aW91c2x5IHVua25vd24gY2xpcC9yb290IGNvbWJpbmF0aW9uIGlzIHNwZWNpZmllZClcclxuXHRjbGlwQWN0aW9uOiBmdW5jdGlvbiggY2xpcCwgb3B0aW9uYWxSb290ICkge1xyXG5cclxuXHRcdHZhciByb290ID0gb3B0aW9uYWxSb290IHx8IHRoaXMuX3Jvb3QsXHJcblx0XHRcdHJvb3RVdWlkID0gcm9vdC51dWlkLFxyXG5cdFx0XHRjbGlwTmFtZSA9ICggdHlwZW9mIGNsaXAgPT09ICdzdHJpbmcnICkgPyBjbGlwIDogY2xpcC5uYW1lLFxyXG5cdFx0XHRjbGlwT2JqZWN0ID0gKCBjbGlwICE9PSBjbGlwTmFtZSApID8gY2xpcCA6IG51bGwsXHJcblxyXG5cdFx0XHRhY3Rpb25zRm9yQ2xpcCA9IHRoaXMuX2FjdGlvbnNCeUNsaXBbIGNsaXBOYW1lIF0sXHJcblx0XHRcdHByb3RvdHlwZUFjdGlvbjtcclxuXHJcblx0XHRpZiAoIGFjdGlvbnNGb3JDbGlwICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHR2YXIgZXhpc3RpbmdBY3Rpb24gPVxyXG5cdFx0XHRcdFx0YWN0aW9uc0ZvckNsaXAuYWN0aW9uQnlSb290WyByb290VXVpZCBdO1xyXG5cclxuXHRcdFx0aWYgKCBleGlzdGluZ0FjdGlvbiAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gZXhpc3RpbmdBY3Rpb247XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyB3ZSBrbm93IHRoZSBjbGlwLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHBhcnNlIGFsbFxyXG5cdFx0XHQvLyB0aGUgYmluZGluZ3MgYWdhaW4gYnV0IGNhbiBqdXN0IGNvcHlcclxuXHRcdFx0cHJvdG90eXBlQWN0aW9uID0gYWN0aW9uc0ZvckNsaXAua25vd25BY3Rpb25zWyAwIF07XHJcblxyXG5cdFx0XHQvLyBhbHNvLCB0YWtlIHRoZSBjbGlwIGZyb20gdGhlIHByb3RvdHlwZSBhY3Rpb25cclxuXHRcdFx0Y2xpcE9iamVjdCA9IHByb3RvdHlwZUFjdGlvbi5fY2xpcDtcclxuXHJcblx0XHRcdGlmICggY2xpcCAhPT0gY2xpcE5hbWUgJiYgY2xpcCAhPT0gY2xpcE9iamVjdCApIHtcclxuXHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFxyXG5cdFx0XHRcdFx0XHRcIkRpZmZlcmVudCBjbGlwcyB3aXRoIHRoZSBzYW1lIG5hbWUgZGV0ZWN0ZWQhXCIgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gY2xpcCBtdXN0IGJlIGtub3duIHdoZW4gc3BlY2lmaWVkIHZpYSBzdHJpbmdcclxuXHRcdGlmICggY2xpcE9iamVjdCA9PT0gbnVsbCApIHJldHVybiBudWxsO1xyXG5cclxuXHRcdC8vIGFsbG9jYXRlIGFsbCByZXNvdXJjZXMgcmVxdWlyZWQgdG8gcnVuIGl0XHJcblx0XHR2YXIgbmV3QWN0aW9uID0gbmV3IFRIUkVFLlxyXG5cdFx0XHRcdEFuaW1hdGlvbk1peGVyLl9BY3Rpb24oIHRoaXMsIGNsaXBPYmplY3QsIG9wdGlvbmFsUm9vdCApO1xyXG5cclxuXHRcdHRoaXMuX2JpbmRBY3Rpb24oIG5ld0FjdGlvbiwgcHJvdG90eXBlQWN0aW9uICk7XHJcblxyXG5cdFx0Ly8gYW5kIG1ha2UgdGhlIGFjdGlvbiBrbm93biB0byB0aGUgbWVtb3J5IG1hbmFnZXJcclxuXHRcdHRoaXMuX2FkZEluYWN0aXZlQWN0aW9uKCBuZXdBY3Rpb24sIGNsaXBOYW1lLCByb290VXVpZCApO1xyXG5cclxuXHRcdHJldHVybiBuZXdBY3Rpb247XHJcblxyXG5cdH0sXHJcblxyXG5cdC8vIGdldCBhbiBleGlzdGluZyBhY3Rpb25cclxuXHRleGlzdGluZ0FjdGlvbjogZnVuY3Rpb24oIGNsaXAsIG9wdGlvbmFsUm9vdCApIHtcclxuXHJcblx0XHR2YXIgcm9vdCA9IG9wdGlvbmFsUm9vdCB8fCB0aGlzLl9yb290LFxyXG5cdFx0XHRyb290VXVpZCA9IHJvb3QudXVpZCxcclxuXHRcdFx0Y2xpcE5hbWUgPSAoIHR5cGVvZiBjbGlwID09PSAnc3RyaW5nJyApID8gY2xpcCA6IGNsaXAubmFtZSxcclxuXHRcdFx0YWN0aW9uc0ZvckNsaXAgPSB0aGlzLl9hY3Rpb25zQnlDbGlwWyBjbGlwTmFtZSBdO1xyXG5cclxuXHRcdGlmICggYWN0aW9uc0ZvckNsaXAgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHJldHVybiBhY3Rpb25zRm9yQ2xpcC5hY3Rpb25CeVJvb3RbIHJvb3RVdWlkIF0gfHwgbnVsbDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG51bGw7XHJcblxyXG5cdH0sXHJcblxyXG5cdC8vIGRlYWN0aXZhdGVzIGFsbCBwcmV2aW91c2x5IHNjaGVkdWxlZCBhY3Rpb25zXHJcblx0c3RvcEFsbEFjdGlvbjogZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0dmFyIGFjdGlvbnMgPSB0aGlzLl9hY3Rpb25zLFxyXG5cdFx0XHRuQWN0aW9ucyA9IHRoaXMuX25BY3RpdmVBY3Rpb25zLFxyXG5cdFx0XHRiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzLFxyXG5cdFx0XHRuQmluZGluZ3MgPSB0aGlzLl9uQWN0aXZlQmluZGluZ3M7XHJcblxyXG5cdFx0dGhpcy5fbkFjdGl2ZUFjdGlvbnMgPSAwO1xyXG5cdFx0dGhpcy5fbkFjdGl2ZUJpbmRpbmdzID0gMDtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgIT09IG5BY3Rpb25zOyArKyBpICkge1xyXG5cclxuXHRcdFx0YWN0aW9uc1sgaSBdLnJlc2V0KCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSAhPT0gbkJpbmRpbmdzOyArKyBpICkge1xyXG5cclxuXHRcdFx0YmluZGluZ3NbIGkgXS51c2VDb3VudCA9IDA7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHQvLyBhZHZhbmNlIHRoZSB0aW1lIGFuZCB1cGRhdGUgYXBwbHkgdGhlIGFuaW1hdGlvblxyXG5cdHVwZGF0ZTogZnVuY3Rpb24oIGRlbHRhVGltZSApIHtcclxuXHJcblx0XHRkZWx0YVRpbWUgKj0gdGhpcy50aW1lU2NhbGU7XHJcblxyXG5cdFx0dmFyIGFjdGlvbnMgPSB0aGlzLl9hY3Rpb25zLFxyXG5cdFx0XHRuQWN0aW9ucyA9IHRoaXMuX25BY3RpdmVBY3Rpb25zLFxyXG5cclxuXHRcdFx0dGltZSA9IHRoaXMudGltZSArPSBkZWx0YVRpbWUsXHJcblx0XHRcdHRpbWVEaXJlY3Rpb24gPSBNYXRoLnNpZ24oIGRlbHRhVGltZSApLFxyXG5cclxuXHRcdFx0YWNjdUluZGV4ID0gdGhpcy5fYWNjdUluZGV4IF49IDE7XHJcblxyXG5cdFx0Ly8gcnVuIGFjdGl2ZSBhY3Rpb25zXHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpICE9PSBuQWN0aW9uczsgKysgaSApIHtcclxuXHJcblx0XHRcdHZhciBhY3Rpb24gPSBhY3Rpb25zWyBpIF07XHJcblxyXG5cdFx0XHRpZiAoIGFjdGlvbi5lbmFibGVkICkge1xyXG5cclxuXHRcdFx0XHRhY3Rpb24uX3VwZGF0ZSggdGltZSwgZGVsdGFUaW1lLCB0aW1lRGlyZWN0aW9uLCBhY2N1SW5kZXggKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gdXBkYXRlIHNjZW5lIGdyYXBoXHJcblxyXG5cdFx0dmFyIGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3MsXHJcblx0XHRcdG5CaW5kaW5ncyA9IHRoaXMuX25BY3RpdmVCaW5kaW5ncztcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgIT09IG5CaW5kaW5nczsgKysgaSApIHtcclxuXHJcblx0XHRcdGJpbmRpbmdzWyBpIF0uYXBwbHkoIGFjY3VJbmRleCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Ly8gcmV0dXJuIHRoaXMgbWl4ZXIncyByb290IHRhcmdldCBvYmplY3RcclxuXHRnZXRSb290OiBmdW5jdGlvbigpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fcm9vdDtcclxuXHJcblx0fSxcclxuXHJcblx0Ly8gZnJlZSBhbGwgcmVzb3VyY2VzIHNwZWNpZmljIHRvIGEgcGFydGljdWxhciBjbGlwXHJcblx0dW5jYWNoZUNsaXA6IGZ1bmN0aW9uKCBjbGlwICkge1xyXG5cclxuXHRcdHZhciBhY3Rpb25zID0gdGhpcy5fYWN0aW9ucyxcclxuXHRcdFx0Y2xpcE5hbWUgPSBjbGlwLm5hbWUsXHJcblx0XHRcdGFjdGlvbnNCeUNsaXAgPSB0aGlzLl9hY3Rpb25zQnlDbGlwLFxyXG5cdFx0XHRhY3Rpb25zRm9yQ2xpcCA9IGFjdGlvbnNCeUNsaXBbIGNsaXBOYW1lIF07XHJcblxyXG5cdFx0aWYgKCBhY3Rpb25zRm9yQ2xpcCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Ly8gbm90ZToganVzdCBjYWxsaW5nIF9yZW1vdmVJbmFjdGl2ZUFjdGlvbiB3b3VsZCBtZXNzIHVwIHRoZVxyXG5cdFx0XHQvLyBpdGVyYXRpb24gc3RhdGUgYW5kIGFsc28gcmVxdWlyZSB1cGRhdGluZyB0aGUgc3RhdGUgd2UgY2FuXHJcblx0XHRcdC8vIGp1c3QgdGhyb3cgYXdheVxyXG5cclxuXHRcdFx0dmFyIGFjdGlvbnNUb1JlbW92ZSA9IGFjdGlvbnNGb3JDbGlwLmtub3duQWN0aW9ucztcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMCwgbiA9IGFjdGlvbnNUb1JlbW92ZS5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBhY3Rpb24gPSBhY3Rpb25zVG9SZW1vdmVbIGkgXTtcclxuXHJcblx0XHRcdFx0dGhpcy5fZGVhY3RpdmF0ZUFjdGlvbiggYWN0aW9uICk7XHJcblxyXG5cdFx0XHRcdHZhciBjYWNoZUluZGV4ID0gYWN0aW9uLl9jYWNoZUluZGV4LFxyXG5cdFx0XHRcdFx0bGFzdEluYWN0aXZlQWN0aW9uID0gYWN0aW9uc1sgYWN0aW9ucy5sZW5ndGggLSAxIF07XHJcblxyXG5cdFx0XHRcdGFjdGlvbi5fY2FjaGVJbmRleCA9IG51bGw7XHJcblx0XHRcdFx0YWN0aW9uLl9ieUNsaXBDYWNoZUluZGV4ID0gbnVsbDtcclxuXHJcblx0XHRcdFx0bGFzdEluYWN0aXZlQWN0aW9uLl9jYWNoZUluZGV4ID0gY2FjaGVJbmRleDtcclxuXHRcdFx0XHRhY3Rpb25zWyBjYWNoZUluZGV4IF0gPSBsYXN0SW5hY3RpdmVBY3Rpb247XHJcblx0XHRcdFx0YWN0aW9ucy5wb3AoKTtcclxuXHJcblx0XHRcdFx0dGhpcy5fcmVtb3ZlSW5hY3RpdmVCaW5kaW5nc0ZvckFjdGlvbiggYWN0aW9uICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRkZWxldGUgYWN0aW9uc0J5Q2xpcFsgY2xpcE5hbWUgXTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdC8vIGZyZWUgYWxsIHJlc291cmNlcyBzcGVjaWZpYyB0byBhIHBhcnRpY3VsYXIgcm9vdCB0YXJnZXQgb2JqZWN0XHJcblx0dW5jYWNoZVJvb3Q6IGZ1bmN0aW9uKCByb290ICkge1xyXG5cclxuXHRcdHZhciByb290VXVpZCA9IHJvb3QudXVpZCxcclxuXHRcdFx0YWN0aW9uc0J5Q2xpcCA9IHRoaXMuX2FjdGlvbnNCeUNsaXA7XHJcblxyXG5cdFx0Zm9yICggdmFyIGNsaXBOYW1lIGluIGFjdGlvbnNCeUNsaXAgKSB7XHJcblxyXG5cdFx0XHR2YXIgYWN0aW9uQnlSb290ID0gYWN0aW9uc0J5Q2xpcFsgY2xpcE5hbWUgXS5hY3Rpb25CeVJvb3QsXHJcblx0XHRcdFx0YWN0aW9uID0gYWN0aW9uQnlSb290WyByb290VXVpZCBdO1xyXG5cclxuXHRcdFx0aWYgKCBhY3Rpb24gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5fZGVhY3RpdmF0ZUFjdGlvbiggYWN0aW9uICk7XHJcblx0XHRcdFx0dGhpcy5fcmVtb3ZlSW5hY3RpdmVBY3Rpb24oIGFjdGlvbiApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgYmluZGluZ3NCeVJvb3QgPSB0aGlzLl9iaW5kaW5nc0J5Um9vdEFuZE5hbWUsXHJcblx0XHRcdGJpbmRpbmdCeU5hbWUgPSBiaW5kaW5nc0J5Um9vdFsgcm9vdFV1aWQgXTtcclxuXHJcblx0XHRpZiAoIGJpbmRpbmdCeU5hbWUgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGZvciAoIHZhciB0cmFja05hbWUgaW4gYmluZGluZ0J5TmFtZSApIHtcclxuXHJcblx0XHRcdFx0dmFyIGJpbmRpbmcgPSBiaW5kaW5nQnlOYW1lWyB0cmFja05hbWUgXTtcclxuXHRcdFx0XHRiaW5kaW5nLnJlc3RvcmVPcmlnaW5hbFN0YXRlKCk7XHJcblx0XHRcdFx0dGhpcy5fcmVtb3ZlSW5hY3RpdmVCaW5kaW5nKCBiaW5kaW5nICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHQvLyByZW1vdmUgYSB0YXJnZXRlZCBjbGlwIGZyb20gdGhlIGNhY2hlXHJcblx0dW5jYWNoZUFjdGlvbjogZnVuY3Rpb24oIGNsaXAsIG9wdGlvbmFsUm9vdCApIHtcclxuXHJcblx0XHR2YXIgYWN0aW9uID0gdGhpcy5leGlzdGluZ0FjdGlvbiggY2xpcCwgb3B0aW9uYWxSb290ICk7XHJcblxyXG5cdFx0aWYgKCBhY3Rpb24gIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl9kZWFjdGl2YXRlQWN0aW9uKCBhY3Rpb24gKTtcclxuXHRcdFx0dGhpcy5fcmVtb3ZlSW5hY3RpdmVBY3Rpb24oIGFjdGlvbiApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcblRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuYXBwbHkoIFRIUkVFLkFuaW1hdGlvbk1peGVyLnByb3RvdHlwZSApO1xyXG5cclxuVEhSRUUuQW5pbWF0aW9uTWl4ZXIuX0FjdGlvbiA9XHJcblx0XHRmdW5jdGlvbiggbWl4ZXIsIGNsaXAsIGxvY2FsUm9vdCApIHtcclxuXHJcblx0dGhpcy5fbWl4ZXIgPSBtaXhlcjtcclxuXHR0aGlzLl9jbGlwID0gY2xpcDtcclxuXHR0aGlzLl9sb2NhbFJvb3QgPSBsb2NhbFJvb3QgfHwgbnVsbDtcclxuXHJcblx0dmFyIHRyYWNrcyA9IGNsaXAudHJhY2tzLFxyXG5cdFx0blRyYWNrcyA9IHRyYWNrcy5sZW5ndGgsXHJcblx0XHRpbnRlcnBvbGFudHMgPSBuZXcgQXJyYXkoIG5UcmFja3MgKTtcclxuXHJcblx0dmFyIGludGVycG9sYW50U2V0dGluZ3MgPSB7XHJcblx0XHRcdGVuZGluZ1N0YXJ0OiBcdFRIUkVFLlplcm9DdXJ2YXR1cmVFbmRpbmcsXHJcblx0XHRcdGVuZGluZ0VuZDpcdFx0VEhSRUUuWmVyb0N1cnZhdHVyZUVuZGluZ1xyXG5cdH07XHJcblxyXG5cdGZvciAoIHZhciBpID0gMDsgaSAhPT0gblRyYWNrczsgKysgaSApIHtcclxuXHJcblx0XHR2YXIgaW50ZXJwb2xhbnQgPSB0cmFja3NbIGkgXS5jcmVhdGVJbnRlcnBvbGFudCggbnVsbCApO1xyXG5cdFx0aW50ZXJwb2xhbnRzWyBpIF0gPSBpbnRlcnBvbGFudDtcclxuXHRcdGludGVycG9sYW50LnNldHRpbmdzID0gaW50ZXJwb2xhbnRTZXR0aW5nc1xyXG5cclxuXHR9XHJcblxyXG5cdHRoaXMuX2ludGVycG9sYW50U2V0dGluZ3MgPSBpbnRlcnBvbGFudFNldHRpbmdzO1xyXG5cclxuXHR0aGlzLl9pbnRlcnBvbGFudHMgPSBpbnRlcnBvbGFudHM7XHQvLyBib3VuZCBieSB0aGUgbWl4ZXJcclxuXHJcblx0Ly8gaW5zaWRlOiBQcm9wZXJ0eU1peGVyIChtYW5hZ2VkIGJ5IHRoZSBtaXhlcilcclxuXHR0aGlzLl9wcm9wZXJ0eUJpbmRpbmdzID0gbmV3IEFycmF5KCBuVHJhY2tzICk7XHJcblxyXG5cdHRoaXMuX2NhY2hlSW5kZXggPSBudWxsO1x0XHRcdC8vIGZvciB0aGUgbWVtb3J5IG1hbmFnZXJcclxuXHR0aGlzLl9ieUNsaXBDYWNoZUluZGV4ID0gbnVsbDtcdFx0Ly8gZm9yIHRoZSBtZW1vcnkgbWFuYWdlclxyXG5cclxuXHR0aGlzLl90aW1lU2NhbGVJbnRlcnBvbGFudCA9IG51bGw7XHJcblx0dGhpcy5fd2VpZ2h0SW50ZXJwb2xhbnQgPSBudWxsO1xyXG5cclxuXHR0aGlzLmxvb3AgPSBUSFJFRS5Mb29wUmVwZWF0O1xyXG5cdHRoaXMuX2xvb3BDb3VudCA9IC0xO1xyXG5cclxuXHQvLyBnbG9iYWwgbWl4ZXIgdGltZSB3aGVuIHRoZSBhY3Rpb24gaXMgdG8gYmUgc3RhcnRlZFxyXG5cdC8vIGl0J3Mgc2V0IGJhY2sgdG8gJ251bGwnIHVwb24gc3RhcnQgb2YgdGhlIGFjdGlvblxyXG5cdHRoaXMuX3N0YXJ0VGltZSA9IG51bGw7XHJcblxyXG5cdC8vIHNjYWxlZCBsb2NhbCB0aW1lIG9mIHRoZSBhY3Rpb25cclxuXHQvLyBnZXRzIGNsYW1wZWQgb3Igd3JhcHBlZCB0byAwLi5jbGlwLmR1cmF0aW9uIGFjY29yZGluZyB0byBsb29wXHJcblx0dGhpcy50aW1lID0gMDtcclxuXHJcblx0dGhpcy50aW1lU2NhbGUgPSAxO1xyXG5cdHRoaXMuX2VmZmVjdGl2ZVRpbWVTY2FsZSA9IDE7XHJcblxyXG5cdHRoaXMud2VpZ2h0ID0gMTtcclxuXHR0aGlzLl9lZmZlY3RpdmVXZWlnaHQgPSAxO1xyXG5cclxuXHR0aGlzLnJlcGV0aXRpb25zID0gSW5maW5pdHk7IFx0XHQvLyBuby4gb2YgcmVwZXRpdGlvbnMgd2hlbiBsb29waW5nXHJcblxyXG5cdHRoaXMucGF1c2VkID0gZmFsc2U7XHRcdFx0XHQvLyBmYWxzZSAtPiB6ZXJvIGVmZmVjdGl2ZSB0aW1lIHNjYWxlXHJcblx0dGhpcy5lbmFibGVkID0gdHJ1ZTtcdFx0XHRcdC8vIHRydWUgLT4gemVybyBlZmZlY3RpdmUgd2VpZ2h0XHJcblxyXG5cdHRoaXMuY2xhbXBXaGVuRmluaXNoZWQgXHQ9IGZhbHNlO1x0Ly8ga2VlcCBmZWVkaW5nIHRoZSBsYXN0IGZyYW1lP1xyXG5cclxuXHR0aGlzLnplcm9TbG9wZUF0U3RhcnQgXHQ9IHRydWU7XHRcdC8vIGZvciBzbW9vdGggaW50ZXJwb2xhdGlvbiB3L28gc2VwYXJhdGVcclxuXHR0aGlzLnplcm9TbG9wZUF0RW5kXHRcdD0gdHJ1ZTtcdFx0Ly8gY2xpcHMgZm9yIHN0YXJ0LCBsb29wIGFuZCBlbmRcclxuXHJcbn07XHJcblxyXG5USFJFRS5BbmltYXRpb25NaXhlci5fQWN0aW9uLnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLkFuaW1hdGlvbk1peGVyLl9BY3Rpb24sXHJcblxyXG5cdC8vIFN0YXRlICYgU2NoZWR1bGluZ1xyXG5cclxuXHRwbGF5OiBmdW5jdGlvbigpIHtcclxuXHJcblx0XHR0aGlzLl9taXhlci5fYWN0aXZhdGVBY3Rpb24oIHRoaXMgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c3RvcDogZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0dGhpcy5fbWl4ZXIuX2RlYWN0aXZhdGVBY3Rpb24oIHRoaXMgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5yZXNldCgpO1xyXG5cclxuXHR9LFxyXG5cclxuXHRyZXNldDogZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0dGhpcy5wYXVzZWQgPSBmYWxzZTtcclxuXHRcdHRoaXMuZW5hYmxlZCA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy50aW1lID0gMDtcdFx0XHQvLyByZXN0YXJ0IGNsaXBcclxuXHRcdHRoaXMuX2xvb3BDb3VudCA9IC0xO1x0Ly8gZm9yZ2V0IHByZXZpb3VzIGxvb3BzXHJcblx0XHR0aGlzLl9zdGFydFRpbWUgPSBudWxsO1x0Ly8gZm9yZ2V0IHNjaGVkdWxpbmdcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5zdG9wRmFkaW5nKCkuc3RvcFdhcnBpbmcoKTtcclxuXHJcblx0fSxcclxuXHJcblx0aXNSdW5uaW5nOiBmdW5jdGlvbigpIHtcclxuXHJcblx0XHR2YXIgc3RhcnQgPSB0aGlzLl9zdGFydFRpbWU7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZW5hYmxlZCAmJiAhIHRoaXMucGF1c2VkICYmIHRoaXMudGltZVNjYWxlICE9PSAwICYmXHJcblx0XHRcdFx0dGhpcy5fc3RhcnRUaW1lID09PSBudWxsICYmIHRoaXMuX21peGVyLl9pc0FjdGl2ZUFjdGlvbiggdGhpcyApXHJcblxyXG5cdH0sXHJcblxyXG5cdC8vIHJldHVybiB0cnVlIHdoZW4gcGxheSBoYXMgYmVlbiBjYWxsZWRcclxuXHRpc1NjaGVkdWxlZDogZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX21peGVyLl9pc0FjdGl2ZUFjdGlvbiggdGhpcyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzdGFydEF0OiBmdW5jdGlvbiggdGltZSApIHtcclxuXHJcblx0XHR0aGlzLl9zdGFydFRpbWUgPSB0aW1lO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRMb29wOiBmdW5jdGlvbiggbW9kZSwgcmVwZXRpdGlvbnMgKSB7XHJcblxyXG5cdFx0dGhpcy5sb29wID0gbW9kZTtcclxuXHRcdHRoaXMucmVwZXRpdGlvbnMgPSByZXBldGl0aW9ucztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Ly8gV2VpZ2h0XHJcblxyXG5cdC8vIHNldCB0aGUgd2VpZ2h0IHN0b3BwaW5nIGFueSBzY2hlZHVsZWQgZmFkaW5nXHJcblx0Ly8gYWx0aG91Z2ggLmVuYWJsZWQgPSBmYWxzZSB5aWVsZHMgYW4gZWZmZWN0aXZlIHdlaWdodCBvZiB6ZXJvLCB0aGlzXHJcblx0Ly8gbWV0aG9kIGRvZXMgKm5vdCogY2hhbmdlIC5lbmFibGVkLCBiZWNhdXNlIGl0IHdvdWxkIGJlIGNvbmZ1c2luZ1xyXG5cdHNldEVmZmVjdGl2ZVdlaWdodDogZnVuY3Rpb24oIHdlaWdodCApIHtcclxuXHJcblx0XHR0aGlzLndlaWdodCA9IHdlaWdodDtcclxuXHJcblx0XHQvLyBub3RlOiBzYW1lIGxvZ2ljIGFzIHdoZW4gdXBkYXRlZCBhdCBydW50aW1lXHJcblx0XHR0aGlzLl9lZmZlY3RpdmVXZWlnaHQgPSB0aGlzLmVuYWJsZWQgPyB3ZWlnaHQgOiAwO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnN0b3BGYWRpbmcoKTtcclxuXHJcblx0fSxcclxuXHJcblx0Ly8gcmV0dXJuIHRoZSB3ZWlnaHQgY29uc2lkZXJpbmcgZmFkaW5nIGFuZCAuZW5hYmxlZFxyXG5cdGdldEVmZmVjdGl2ZVdlaWdodDogZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX2VmZmVjdGl2ZVdlaWdodDtcclxuXHJcblx0fSxcclxuXHJcblx0ZmFkZUluOiBmdW5jdGlvbiggZHVyYXRpb24gKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX3NjaGVkdWxlRmFkaW5nKCBkdXJhdGlvbiwgMCwgMSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRmYWRlT3V0OiBmdW5jdGlvbiggZHVyYXRpb24gKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX3NjaGVkdWxlRmFkaW5nKCBkdXJhdGlvbiwgMSwgMCApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjcm9zc0ZhZGVGcm9tOiBmdW5jdGlvbiggZmFkZU91dEFjdGlvbiwgZHVyYXRpb24sIHdhcnAgKSB7XHJcblxyXG5cdFx0dmFyIG1peGVyID0gdGhpcy5fbWl4ZXI7XHJcblxyXG5cdFx0ZmFkZU91dEFjdGlvbi5mYWRlT3V0KCBkdXJhdGlvbiApO1xyXG5cdFx0dGhpcy5mYWRlSW4oIGR1cmF0aW9uICk7XHJcblxyXG5cdFx0aWYoIHdhcnAgKSB7XHJcblxyXG5cdFx0XHR2YXIgZmFkZUluRHVyYXRpb24gPSB0aGlzLl9jbGlwLmR1cmF0aW9uLFxyXG5cdFx0XHRcdGZhZGVPdXREdXJhdGlvbiA9IGZhZGVPdXRBY3Rpb24uX2NsaXAuZHVyYXRpb24sXHJcblxyXG5cdFx0XHRcdHN0YXJ0RW5kUmF0aW8gPSBmYWRlT3V0RHVyYXRpb24gLyBmYWRlSW5EdXJhdGlvbixcclxuXHRcdFx0XHRlbmRTdGFydFJhdGlvID0gZmFkZUluRHVyYXRpb24gLyBmYWRlT3V0RHVyYXRpb247XHJcblxyXG5cdFx0XHRmYWRlT3V0QWN0aW9uLndhcnAoIDEuMCwgc3RhcnRFbmRSYXRpbywgZHVyYXRpb24gKTtcclxuXHRcdFx0dGhpcy53YXJwKCBlbmRTdGFydFJhdGlvLCAxLjAsIGR1cmF0aW9uICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjcm9zc0ZhZGVUbzogZnVuY3Rpb24oIGZhZGVJbkFjdGlvbiwgZHVyYXRpb24sIHdhcnAgKSB7XHJcblxyXG5cdFx0cmV0dXJuIGZhZGVJbkFjdGlvbi5jcm9zc0ZhZGVGcm9tKCB0aGlzLCBkdXJhdGlvbiwgd2FycCApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzdG9wRmFkaW5nOiBmdW5jdGlvbigpIHtcclxuXHJcblx0XHR2YXIgd2VpZ2h0SW50ZXJwb2xhbnQgPSB0aGlzLl93ZWlnaHRJbnRlcnBvbGFudDtcclxuXHJcblx0XHRpZiAoIHdlaWdodEludGVycG9sYW50ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0dGhpcy5fd2VpZ2h0SW50ZXJwb2xhbnQgPSBudWxsO1xyXG5cdFx0XHR0aGlzLl9taXhlci5fdGFrZUJhY2tDb250cm9sSW50ZXJwb2xhbnQoIHdlaWdodEludGVycG9sYW50ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHQvLyBUaW1lIFNjYWxlIENvbnRyb2xcclxuXHJcblx0Ly8gc2V0IHRoZSB3ZWlnaHQgc3RvcHBpbmcgYW55IHNjaGVkdWxlZCB3YXJwaW5nXHJcblx0Ly8gYWx0aG91Z2ggLnBhdXNlZCA9IHRydWUgeWllbGRzIGFuIGVmZmVjdGl2ZSB0aW1lIHNjYWxlIG9mIHplcm8sIHRoaXNcclxuXHQvLyBtZXRob2QgZG9lcyAqbm90KiBjaGFuZ2UgLnBhdXNlZCwgYmVjYXVzZSBpdCB3b3VsZCBiZSBjb25mdXNpbmdcclxuXHRzZXRFZmZlY3RpdmVUaW1lU2NhbGU6IGZ1bmN0aW9uKCB0aW1lU2NhbGUgKSB7XHJcblxyXG5cdFx0dGhpcy50aW1lU2NhbGUgPSB0aW1lU2NhbGU7XHJcblx0XHR0aGlzLl9lZmZlY3RpdmVUaW1lU2NhbGUgPSB0aGlzLnBhdXNlZCA/IDAgOnRpbWVTY2FsZTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5zdG9wV2FycGluZygpO1xyXG5cclxuXHR9LFxyXG5cclxuXHQvLyByZXR1cm4gdGhlIHRpbWUgc2NhbGUgY29uc2lkZXJpbmcgd2FycGluZyBhbmQgLnBhdXNlZFxyXG5cdGdldEVmZmVjdGl2ZVRpbWVTY2FsZTogZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX2VmZmVjdGl2ZVRpbWVTY2FsZTtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0RHVyYXRpb246IGZ1bmN0aW9uKCBkdXJhdGlvbiApIHtcclxuXHJcblx0XHR0aGlzLnRpbWVTY2FsZSA9IHRoaXMuX2NsaXAuZHVyYXRpb24gLyBkdXJhdGlvbjtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5zdG9wV2FycGluZygpO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzeW5jV2l0aDogZnVuY3Rpb24oIGFjdGlvbiApIHtcclxuXHJcblx0XHR0aGlzLnRpbWUgPSBhY3Rpb24udGltZTtcclxuXHRcdHRoaXMudGltZVNjYWxlID0gYWN0aW9uLnRpbWVTY2FsZTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5zdG9wV2FycGluZygpO1xyXG5cclxuXHR9LFxyXG5cclxuXHRoYWx0OiBmdW5jdGlvbiggZHVyYXRpb24gKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMud2FycCggdGhpcy5fY3VycmVudFRpbWVTY2FsZSwgMCwgZHVyYXRpb24gKTtcclxuXHJcblx0fSxcclxuXHJcblx0d2FycDogZnVuY3Rpb24oIHN0YXJ0VGltZVNjYWxlLCBlbmRUaW1lU2NhbGUsIGR1cmF0aW9uICkge1xyXG5cclxuXHRcdHZhciBtaXhlciA9IHRoaXMuX21peGVyLCBub3cgPSBtaXhlci50aW1lLFxyXG5cdFx0XHRpbnRlcnBvbGFudCA9IHRoaXMuX3RpbWVTY2FsZUludGVycG9sYW50LFxyXG5cclxuXHRcdFx0dGltZVNjYWxlID0gdGhpcy50aW1lU2NhbGU7XHJcblxyXG5cdFx0aWYgKCBpbnRlcnBvbGFudCA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdGludGVycG9sYW50ID0gbWl4ZXIuX2xlbmRDb250cm9sSW50ZXJwb2xhbnQoKSxcclxuXHRcdFx0dGhpcy5fdGltZVNjYWxlSW50ZXJwb2xhbnQgPSBpbnRlcnBvbGFudDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHRpbWVzID0gaW50ZXJwb2xhbnQucGFyYW1ldGVyUG9zaXRpb25zLFxyXG5cdFx0XHR2YWx1ZXMgPSBpbnRlcnBvbGFudC5zYW1wbGVWYWx1ZXM7XHJcblxyXG5cdFx0dGltZXNbIDAgXSA9IG5vdztcclxuXHRcdHRpbWVzWyAxIF0gPSBub3cgKyBkdXJhdGlvbjtcclxuXHJcblx0XHR2YWx1ZXNbIDAgXSA9IHN0YXJ0VGltZVNjYWxlIC8gdGltZVNjYWxlO1xyXG5cdFx0dmFsdWVzWyAxIF0gPSBlbmRUaW1lU2NhbGUgLyB0aW1lU2NhbGU7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHN0b3BXYXJwaW5nOiBmdW5jdGlvbigpIHtcclxuXHJcblx0XHR2YXIgdGltZVNjYWxlSW50ZXJwb2xhbnQgPSB0aGlzLl90aW1lU2NhbGVJbnRlcnBvbGFudDtcclxuXHJcblx0XHRpZiAoIHRpbWVTY2FsZUludGVycG9sYW50ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0dGhpcy5fdGltZVNjYWxlSW50ZXJwb2xhbnQgPSBudWxsO1xyXG5cdFx0XHR0aGlzLl9taXhlci5fdGFrZUJhY2tDb250cm9sSW50ZXJwb2xhbnQoIHRpbWVTY2FsZUludGVycG9sYW50ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHQvLyBPYmplY3QgQWNjZXNzb3JzXHJcblxyXG5cdGdldE1peGVyOiBmdW5jdGlvbigpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fbWl4ZXI7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldENsaXA6IGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLl9jbGlwO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXRSb290OiBmdW5jdGlvbigpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fbG9jYWxSb290IHx8IHRoaXMuX21peGVyLl9yb290O1xyXG5cclxuXHR9LFxyXG5cclxuXHQvLyBJbnRlcm5hXHJcblxyXG5cdF91cGRhdGU6IGZ1bmN0aW9uKCB0aW1lLCBkZWx0YVRpbWUsIHRpbWVEaXJlY3Rpb24sIGFjY3VJbmRleCApIHtcclxuXHRcdC8vIGNhbGxlZCBieSB0aGUgbWl4ZXJcclxuXHJcblx0XHR2YXIgc3RhcnRUaW1lID0gdGhpcy5fc3RhcnRUaW1lO1xyXG5cclxuXHRcdGlmICggc3RhcnRUaW1lICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0Ly8gY2hlY2sgZm9yIHNjaGVkdWxlZCBzdGFydCBvZiBhY3Rpb25cclxuXHJcblx0XHRcdHZhciB0aW1lUnVubmluZyA9ICggdGltZSAtIHN0YXJ0VGltZSApICogdGltZURpcmVjdGlvbjtcclxuXHRcdFx0aWYgKCB0aW1lUnVubmluZyA8IDAgfHwgdGltZURpcmVjdGlvbiA9PT0gMCApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuOyAvLyB5ZXQgdG8gY29tZSAvIGRvbid0IGRlY2lkZSB3aGVuIGRlbHRhID0gMFxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gc3RhcnRcclxuXHJcblx0XHRcdHRoaXMuX3N0YXJ0VGltZSA9IG51bGw7IC8vIHVuc2NoZWR1bGVcclxuXHRcdFx0ZGVsdGFUaW1lID0gdGltZURpcmVjdGlvbiAqIHRpbWVSdW5uaW5nO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBhcHBseSB0aW1lIHNjYWxlIGFuZCBhZHZhbmNlIHRpbWVcclxuXHJcblx0XHRkZWx0YVRpbWUgKj0gdGhpcy5fdXBkYXRlVGltZVNjYWxlKCB0aW1lICk7XHJcblx0XHR2YXIgY2xpcFRpbWUgPSB0aGlzLl91cGRhdGVUaW1lKCBkZWx0YVRpbWUgKTtcclxuXHJcblx0XHQvLyBub3RlOiBfdXBkYXRlVGltZSBtYXkgZGlzYWJsZSB0aGUgYWN0aW9uIHJlc3VsdGluZyBpblxyXG5cdFx0Ly8gYW4gZWZmZWN0aXZlIHdlaWdodCBvZiAwXHJcblxyXG5cdFx0dmFyIHdlaWdodCA9IHRoaXMuX3VwZGF0ZVdlaWdodCggdGltZSApO1xyXG5cclxuXHRcdGlmICggd2VpZ2h0ID4gMCApIHtcclxuXHJcblx0XHRcdHZhciBpbnRlcnBvbGFudHMgPSB0aGlzLl9pbnRlcnBvbGFudHM7XHJcblx0XHRcdHZhciBwcm9wZXJ0eU1peGVycyA9IHRoaXMuX3Byb3BlcnR5QmluZGluZ3M7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaiA9IDAsIG0gPSBpbnRlcnBvbGFudHMubGVuZ3RoOyBqICE9PSBtOyArKyBqICkge1xyXG5cclxuXHRcdFx0XHRpbnRlcnBvbGFudHNbIGogXS5ldmFsdWF0ZSggY2xpcFRpbWUgKTtcclxuXHRcdFx0XHRwcm9wZXJ0eU1peGVyc1sgaiBdLmFjY3VtdWxhdGUoIGFjY3VJbmRleCwgd2VpZ2h0ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlV2VpZ2h0OiBmdW5jdGlvbiggdGltZSApIHtcclxuXHJcblx0XHR2YXIgd2VpZ2h0ID0gMDtcclxuXHJcblx0XHRpZiAoIHRoaXMuZW5hYmxlZCApIHtcclxuXHJcblx0XHRcdHdlaWdodCA9IHRoaXMud2VpZ2h0O1xyXG5cdFx0XHR2YXIgaW50ZXJwb2xhbnQgPSB0aGlzLl93ZWlnaHRJbnRlcnBvbGFudDtcclxuXHJcblx0XHRcdGlmICggaW50ZXJwb2xhbnQgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBpbnRlcnBvbGFudFZhbHVlID0gaW50ZXJwb2xhbnQuZXZhbHVhdGUoIHRpbWUgKVsgMCBdO1xyXG5cclxuXHRcdFx0XHR3ZWlnaHQgKj0gaW50ZXJwb2xhbnRWYWx1ZTtcclxuXHJcblx0XHRcdFx0aWYgKCB0aW1lID4gaW50ZXJwb2xhbnQucGFyYW1ldGVyUG9zaXRpb25zWyAxIF0gKSB7XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5zdG9wRmFkaW5nKCk7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBpbnRlcnBvbGFudFZhbHVlID09PSAwICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Ly8gZmFkZWQgb3V0LCBkaXNhYmxlXHJcblx0XHRcdFx0XHRcdHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9lZmZlY3RpdmVXZWlnaHQgPSB3ZWlnaHQ7XHJcblx0XHRyZXR1cm4gd2VpZ2h0O1xyXG5cclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlVGltZVNjYWxlOiBmdW5jdGlvbiggdGltZSApIHtcclxuXHJcblx0XHR2YXIgdGltZVNjYWxlID0gMDtcclxuXHJcblx0XHRpZiAoICEgdGhpcy5wYXVzZWQgKSB7XHJcblxyXG5cdFx0XHR0aW1lU2NhbGUgPSB0aGlzLnRpbWVTY2FsZTtcclxuXHJcblx0XHRcdHZhciBpbnRlcnBvbGFudCA9IHRoaXMuX3RpbWVTY2FsZUludGVycG9sYW50O1xyXG5cclxuXHRcdFx0aWYgKCBpbnRlcnBvbGFudCAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0dmFyIGludGVycG9sYW50VmFsdWUgPSBpbnRlcnBvbGFudC5ldmFsdWF0ZSggdGltZSApWyAwIF07XHJcblxyXG5cdFx0XHRcdHRpbWVTY2FsZSAqPSBpbnRlcnBvbGFudFZhbHVlO1xyXG5cclxuXHRcdFx0XHRpZiAoIHRpbWUgPiBpbnRlcnBvbGFudC5wYXJhbWV0ZXJQb3NpdGlvbnNbIDEgXSApIHtcclxuXHJcblx0XHRcdFx0XHR0aGlzLnN0b3BXYXJwaW5nKCk7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCB0aW1lU2NhbGUgPT09IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHQvLyBtb3Rpb24gaGFzIGhhbHRlZCwgcGF1c2VcclxuXHRcdFx0XHRcdFx0dGhpcy5wYXVzZSA9IHRydWU7XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdC8vIHdhcnAgZG9uZSAtIGFwcGx5IGZpbmFsIHRpbWUgc2NhbGVcclxuXHRcdFx0XHRcdFx0dGhpcy50aW1lU2NhbGUgPSB0aW1lU2NhbGU7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2VmZmVjdGl2ZVRpbWVTY2FsZSA9IHRpbWVTY2FsZTtcclxuXHRcdHJldHVybiB0aW1lU2NhbGU7XHJcblxyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVUaW1lOiBmdW5jdGlvbiggZGVsdGFUaW1lICkge1xyXG5cclxuXHRcdHZhciB0aW1lID0gdGhpcy50aW1lICsgZGVsdGFUaW1lO1xyXG5cclxuXHRcdGlmICggZGVsdGFUaW1lID09PSAwICkgcmV0dXJuIHRpbWU7XHJcblxyXG5cdFx0dmFyIGR1cmF0aW9uID0gdGhpcy5fY2xpcC5kdXJhdGlvbixcclxuXHJcblx0XHRcdGxvb3AgPSB0aGlzLmxvb3AsXHJcblx0XHRcdGxvb3BDb3VudCA9IHRoaXMuX2xvb3BDb3VudCxcclxuXHJcblx0XHRcdHBpbmdQb25nID0gZmFsc2U7XHJcblxyXG5cdFx0c3dpdGNoICggbG9vcCApIHtcclxuXHJcblx0XHRcdGNhc2UgVEhSRUUuTG9vcE9uY2U6XHJcblxyXG5cdFx0XHRcdGlmICggbG9vcENvdW50ID09PSAtMSApIHtcclxuXHJcblx0XHRcdFx0XHQvLyBqdXN0IHN0YXJ0ZWRcclxuXHJcblx0XHRcdFx0XHR0aGlzLmxvb3BDb3VudCA9IDA7XHJcblx0XHRcdFx0XHR0aGlzLl9zZXRFbmRpbmdzKCB0cnVlLCB0cnVlLCBmYWxzZSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggdGltZSA+PSBkdXJhdGlvbiApIHtcclxuXHJcblx0XHRcdFx0XHR0aW1lID0gZHVyYXRpb247XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHRpbWUgPCAwICkge1xyXG5cclxuXHRcdFx0XHRcdHRpbWUgPSAwO1xyXG5cclxuXHRcdFx0XHR9IGVsc2UgYnJlYWs7XHJcblxyXG5cdFx0XHRcdC8vIHJlYWNoZWQgdGhlIGVuZFxyXG5cclxuXHRcdFx0XHRpZiAoIHRoaXMuY2xhbXBXaGVuRmluaXNoZWQgKSB0aGlzLnBhdXNlID0gdHJ1ZTtcclxuXHRcdFx0XHRlbHNlIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xyXG5cclxuXHRcdFx0XHR0aGlzLl9taXhlci5kaXNwYXRjaEV2ZW50KCB7XHJcblx0XHRcdFx0XHR0eXBlOiAnZmluaXNoZWQnLCBhY3Rpb246IHRoaXMsXHJcblx0XHRcdFx0XHRkaXJlY3Rpb246IGRlbHRhVGltZSA8IDAgPyAtMSA6IDFcclxuXHRcdFx0XHR9ICk7XHJcblxyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0Y2FzZSBUSFJFRS5Mb29wUGluZ1Bvbmc6XHJcblxyXG5cdFx0XHRcdHBpbmdQb25nID0gdHJ1ZTtcclxuXHJcblx0XHRcdGNhc2UgVEhSRUUuTG9vcFJlcGVhdDpcclxuXHJcblx0XHRcdFx0aWYgKCBsb29wQ291bnQgPT09IC0xICkge1xyXG5cclxuXHRcdFx0XHRcdC8vIGp1c3Qgc3RhcnRlZFxyXG5cclxuXHRcdFx0XHRcdGlmICggZGVsdGFUaW1lID4gMCApIHtcclxuXHJcblx0XHRcdFx0XHRcdGxvb3BDb3VudCA9IDA7XHJcblxyXG5cdFx0XHRcdFx0XHR0aGlzLl9zZXRFbmRpbmdzKFxyXG5cdFx0XHRcdFx0XHRcdFx0dHJ1ZSwgdGhpcy5yZXBldGl0aW9ucyA9PT0gMCwgcGluZ1BvbmcgKTtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0Ly8gd2hlbiBsb29waW5nIGluIHJldmVyc2UgZGlyZWN0aW9uLCB0aGUgaW5pdGlhbFxyXG5cdFx0XHRcdFx0XHQvLyB0cmFuc2l0aW9uIHRocm91Z2ggemVybyBjb3VudHMgYXMgYSByZXBldGl0aW9uLFxyXG5cdFx0XHRcdFx0XHQvLyBzbyBsZWF2ZSBsb29wQ291bnQgYXQgLTFcclxuXHJcblx0XHRcdFx0XHRcdHRoaXMuX3NldEVuZGluZ3MoXHJcblx0XHRcdFx0XHRcdFx0XHR0aGlzLnJlcGV0aXRpb25zID09PSAwLCB0cnVlLCBwaW5nUG9uZyApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIHRpbWUgPj0gZHVyYXRpb24gfHwgdGltZSA8IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0Ly8gd3JhcCBhcm91bmRcclxuXHJcblx0XHRcdFx0XHR2YXIgbG9vcERlbHRhID0gTWF0aC5mbG9vciggdGltZSAvIGR1cmF0aW9uICk7IC8vIHNpZ25lZFxyXG5cdFx0XHRcdFx0dGltZSAtPSBkdXJhdGlvbiAqIGxvb3BEZWx0YTtcclxuXHJcblx0XHRcdFx0XHRsb29wQ291bnQgKz0gTWF0aC5hYnMoIGxvb3BEZWx0YSApO1xyXG5cclxuXHRcdFx0XHRcdHZhciBwZW5kaW5nID0gdGhpcy5yZXBldGl0aW9ucyAtIGxvb3BDb3VudDtcclxuXHJcblx0XHRcdFx0XHRpZiAoIHBlbmRpbmcgPCAwICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Ly8gc3RvcCAoc3dpdGNoIHN0YXRlLCBjbGFtcCB0aW1lLCBmaXJlIGV2ZW50KVxyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCB0aGlzLmNsYW1wV2hlbkZpbmlzaGVkICkgdGhpcy5wYXVzZWQgPSB0cnVlO1xyXG5cdFx0XHRcdFx0XHRlbHNlIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xyXG5cclxuXHRcdFx0XHRcdFx0dGltZSA9IGRlbHRhVGltZSA+IDAgPyBkdXJhdGlvbiA6IDA7XHJcblxyXG5cdFx0XHRcdFx0XHR0aGlzLl9taXhlci5kaXNwYXRjaEV2ZW50KCB7XHJcblx0XHRcdFx0XHRcdFx0dHlwZTogJ2ZpbmlzaGVkJywgYWN0aW9uOiB0aGlzLFxyXG5cdFx0XHRcdFx0XHRcdGRpcmVjdGlvbjogZGVsdGFUaW1lID4gMCA/IDEgOiAtMVxyXG5cdFx0XHRcdFx0XHR9ICk7XHJcblxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBwZW5kaW5nID09PSAwICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Ly8gdHJhbnNpdGlvbiB0byBsYXN0IHJvdW5kXHJcblxyXG5cdFx0XHRcdFx0XHR2YXIgYXRTdGFydCA9IGRlbHRhVGltZSA8IDA7XHJcblx0XHRcdFx0XHRcdHRoaXMuX3NldEVuZGluZ3MoIGF0U3RhcnQsICEgYXRTdGFydCwgcGluZ1BvbmcgKTtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0dGhpcy5fc2V0RW5kaW5ncyggZmFsc2UsIGZhbHNlLCBwaW5nUG9uZyApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR0aGlzLl9sb29wQ291bnQgPSBsb29wQ291bnQ7XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5fbWl4ZXIuZGlzcGF0Y2hFdmVudCgge1xyXG5cdFx0XHRcdFx0XHR0eXBlOiAnbG9vcCcsIGFjdGlvbjogdGhpcywgbG9vcERlbHRhOiBsb29wRGVsdGFcclxuXHRcdFx0XHRcdH0gKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIGxvb3AgPT09IFRIUkVFLkxvb3BQaW5nUG9uZyAmJiAoIGxvb3BDb3VudCAmIDEgKSA9PT0gMSApIHtcclxuXHJcblx0XHRcdFx0XHQvLyBpbnZlcnQgdGltZSBmb3IgdGhlIFwicG9uZyByb3VuZFwiXHJcblxyXG5cdFx0XHRcdFx0dGhpcy50aW1lID0gdGltZTtcclxuXHJcblx0XHRcdFx0XHRyZXR1cm4gZHVyYXRpb24gLSB0aW1lO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnRpbWUgPSB0aW1lO1xyXG5cclxuXHRcdHJldHVybiB0aW1lO1xyXG5cclxuXHR9LFxyXG5cclxuXHRfc2V0RW5kaW5nczogZnVuY3Rpb24oIGF0U3RhcnQsIGF0RW5kLCBwaW5nUG9uZyApIHtcclxuXHJcblx0XHR2YXIgc2V0dGluZ3MgPSB0aGlzLl9pbnRlcnBvbGFudFNldHRpbmdzO1xyXG5cclxuXHRcdGlmICggcGluZ1BvbmcgKSB7XHJcblxyXG5cdFx0XHRzZXR0aW5ncy5lbmRpbmdTdGFydCBcdD0gVEhSRUUuWmVyb1Nsb3BlRW5kaW5nO1xyXG5cdFx0XHRzZXR0aW5ncy5lbmRpbmdFbmRcdFx0PSBUSFJFRS5aZXJvU2xvcGVFbmRpbmc7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdC8vIGFzc3VtaW5nIGZvciBMb29wT25jZSBhdFN0YXJ0ID09IGF0RW5kID09IHRydWVcclxuXHJcblx0XHRcdGlmICggYXRTdGFydCApIHtcclxuXHJcblx0XHRcdFx0c2V0dGluZ3MuZW5kaW5nU3RhcnQgPSB0aGlzLnplcm9TbG9wZUF0U3RhcnQgP1xyXG5cdFx0XHRcdFx0XHRUSFJFRS5aZXJvU2xvcGVFbmRpbmcgOiBUSFJFRS5aZXJvQ3VydmF0dXJlRW5kaW5nO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0c2V0dGluZ3MuZW5kaW5nU3RhcnQgPSBUSFJFRS5XcmFwQXJvdW5kRW5kaW5nO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBhdEVuZCApIHtcclxuXHJcblx0XHRcdFx0c2V0dGluZ3MuZW5kaW5nRW5kID0gdGhpcy56ZXJvU2xvcGVBdEVuZCA/XHJcblx0XHRcdFx0XHRcdFRIUkVFLlplcm9TbG9wZUVuZGluZyA6IFRIUkVFLlplcm9DdXJ2YXR1cmVFbmRpbmc7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRzZXR0aW5ncy5lbmRpbmdFbmQgXHQgPSBUSFJFRS5XcmFwQXJvdW5kRW5kaW5nO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0X3NjaGVkdWxlRmFkaW5nOiBmdW5jdGlvbiggZHVyYXRpb24sIHdlaWdodE5vdywgd2VpZ2h0VGhlbiApIHtcclxuXHJcblx0XHR2YXIgbWl4ZXIgPSB0aGlzLl9taXhlciwgbm93ID0gbWl4ZXIudGltZSxcclxuXHRcdFx0aW50ZXJwb2xhbnQgPSB0aGlzLl93ZWlnaHRJbnRlcnBvbGFudDtcclxuXHJcblx0XHRpZiAoIGludGVycG9sYW50ID09PSBudWxsICkge1xyXG5cclxuXHRcdFx0aW50ZXJwb2xhbnQgPSBtaXhlci5fbGVuZENvbnRyb2xJbnRlcnBvbGFudCgpLFxyXG5cdFx0XHR0aGlzLl93ZWlnaHRJbnRlcnBvbGFudCA9IGludGVycG9sYW50O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgdGltZXMgPSBpbnRlcnBvbGFudC5wYXJhbWV0ZXJQb3NpdGlvbnMsXHJcblx0XHRcdHZhbHVlcyA9IGludGVycG9sYW50LnNhbXBsZVZhbHVlcztcclxuXHJcblx0XHR0aW1lc1sgMCBdID0gbm93OyBcdFx0XHRcdHZhbHVlc1sgMCBdID0gd2VpZ2h0Tm93O1xyXG5cdFx0dGltZXNbIDEgXSA9IG5vdyArIGR1cmF0aW9uO1x0dmFsdWVzWyAxIF0gPSB3ZWlnaHRUaGVuO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuLy8gSW1wbGVtZW50YXRpb24gZGV0YWlsczpcclxuXHJcbk9iamVjdC5hc3NpZ24oIFRIUkVFLkFuaW1hdGlvbk1peGVyLnByb3RvdHlwZSwge1xyXG5cclxuXHRfYmluZEFjdGlvbjogZnVuY3Rpb24oIGFjdGlvbiwgcHJvdG90eXBlQWN0aW9uICkge1xyXG5cclxuXHRcdHZhciByb290ID0gYWN0aW9uLl9sb2NhbFJvb3QgfHwgdGhpcy5fcm9vdCxcclxuXHRcdFx0dHJhY2tzID0gYWN0aW9uLl9jbGlwLnRyYWNrcyxcclxuXHRcdFx0blRyYWNrcyA9IHRyYWNrcy5sZW5ndGgsXHJcblx0XHRcdGJpbmRpbmdzID0gYWN0aW9uLl9wcm9wZXJ0eUJpbmRpbmdzLFxyXG5cdFx0XHRpbnRlcnBvbGFudHMgPSBhY3Rpb24uX2ludGVycG9sYW50cyxcclxuXHRcdFx0cm9vdFV1aWQgPSByb290LnV1aWQsXHJcblx0XHRcdGJpbmRpbmdzQnlSb290ID0gdGhpcy5fYmluZGluZ3NCeVJvb3RBbmROYW1lLFxyXG5cdFx0XHRiaW5kaW5nc0J5TmFtZSA9IGJpbmRpbmdzQnlSb290WyByb290VXVpZCBdO1xyXG5cclxuXHRcdGlmICggYmluZGluZ3NCeU5hbWUgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGJpbmRpbmdzQnlOYW1lID0ge307XHJcblx0XHRcdGJpbmRpbmdzQnlSb290WyByb290VXVpZCBdID0gYmluZGluZ3NCeU5hbWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSAhPT0gblRyYWNrczsgKysgaSApIHtcclxuXHJcblx0XHRcdHZhciB0cmFjayA9IHRyYWNrc1sgaSBdLFxyXG5cdFx0XHRcdHRyYWNrTmFtZSA9IHRyYWNrLm5hbWUsXHJcblx0XHRcdFx0YmluZGluZyA9IGJpbmRpbmdzQnlOYW1lWyB0cmFja05hbWUgXTtcclxuXHJcblx0XHRcdGlmICggYmluZGluZyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRiaW5kaW5nc1sgaSBdID0gYmluZGluZztcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGJpbmRpbmcgPSBiaW5kaW5nc1sgaSBdO1xyXG5cclxuXHRcdFx0XHRpZiAoIGJpbmRpbmcgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHQvLyBleGlzdGluZyBiaW5kaW5nLCBtYWtlIHN1cmUgdGhlIGNhY2hlIGtub3dzXHJcblxyXG5cdFx0XHRcdFx0aWYgKCBiaW5kaW5nLl9jYWNoZUluZGV4ID09PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHRcdFx0KysgYmluZGluZy5yZWZlcmVuY2VDb3VudDtcclxuXHRcdFx0XHRcdFx0dGhpcy5fYWRkSW5hY3RpdmVCaW5kaW5nKCBiaW5kaW5nLCByb290VXVpZCwgdHJhY2tOYW1lICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHZhciBwYXRoID0gcHJvdG90eXBlQWN0aW9uICYmIHByb3RvdHlwZUFjdGlvbi5cclxuXHRcdFx0XHRcdFx0X3Byb3BlcnR5QmluZGluZ3NbIGkgXS5iaW5kaW5nLnBhcnNlZFBhdGg7XHJcblxyXG5cdFx0XHRcdGJpbmRpbmcgPSBuZXcgVEhSRUUuUHJvcGVydHlNaXhlcihcclxuXHRcdFx0XHRcdFx0VEhSRUUuUHJvcGVydHlCaW5kaW5nLmNyZWF0ZSggcm9vdCwgdHJhY2tOYW1lLCBwYXRoICksXHJcblx0XHRcdFx0XHRcdHRyYWNrLlZhbHVlVHlwZU5hbWUsIHRyYWNrLmdldFZhbHVlU2l6ZSgpICk7XHJcblxyXG5cdFx0XHRcdCsrIGJpbmRpbmcucmVmZXJlbmNlQ291bnQ7XHJcblx0XHRcdFx0dGhpcy5fYWRkSW5hY3RpdmVCaW5kaW5nKCBiaW5kaW5nLCByb290VXVpZCwgdHJhY2tOYW1lICk7XHJcblxyXG5cdFx0XHRcdGJpbmRpbmdzWyBpIF0gPSBiaW5kaW5nO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aW50ZXJwb2xhbnRzWyBpIF0ucmVzdWx0QnVmZmVyID0gYmluZGluZy5idWZmZXI7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHRfYWN0aXZhdGVBY3Rpb246IGZ1bmN0aW9uKCBhY3Rpb24gKSB7XHJcblxyXG5cdFx0aWYgKCAhIHRoaXMuX2lzQWN0aXZlQWN0aW9uKCBhY3Rpb24gKSApIHtcclxuXHJcblx0XHRcdGlmICggYWN0aW9uLl9jYWNoZUluZGV4ID09PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHQvLyB0aGlzIGFjdGlvbiBoYXMgYmVlbiBmb3Jnb3R0ZW4gYnkgdGhlIGNhY2hlLCBidXQgdGhlIHVzZXJcclxuXHRcdFx0XHQvLyBhcHBlYXJzIHRvIGJlIHN0aWxsIHVzaW5nIGl0IC0+IHJlYmluZFxyXG5cclxuXHRcdFx0XHR2YXIgcm9vdFV1aWQgPSAoIGFjdGlvbi5fbG9jYWxSb290IHx8IHRoaXMuX3Jvb3QgKS51dWlkLFxyXG5cdFx0XHRcdFx0Y2xpcE5hbWUgPSBhY3Rpb24uX2NsaXAubmFtZSxcclxuXHRcdFx0XHRcdGFjdGlvbnNGb3JDbGlwID0gdGhpcy5fYWN0aW9uc0J5Q2xpcFsgY2xpcE5hbWUgXTtcclxuXHJcblx0XHRcdFx0dGhpcy5fYmluZEFjdGlvbiggYWN0aW9uLFxyXG5cdFx0XHRcdFx0XHRhY3Rpb25zRm9yQ2xpcCAmJiBhY3Rpb25zRm9yQ2xpcC5rbm93bkFjdGlvbnNbIDAgXSApO1xyXG5cclxuXHRcdFx0XHR0aGlzLl9hZGRJbmFjdGl2ZUFjdGlvbiggYWN0aW9uLCBjbGlwTmFtZSwgcm9vdFV1aWQgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBiaW5kaW5ncyA9IGFjdGlvbi5fcHJvcGVydHlCaW5kaW5ncztcclxuXHJcblx0XHRcdC8vIGluY3JlbWVudCByZWZlcmVuY2UgY291bnRzIC8gc29ydCBvdXQgc3RhdGVcclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBuID0gYmluZGluZ3MubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xyXG5cclxuXHRcdFx0XHR2YXIgYmluZGluZyA9IGJpbmRpbmdzWyBpIF07XHJcblxyXG5cdFx0XHRcdGlmICggYmluZGluZy51c2VDb3VudCArKyA9PT0gMCApIHtcclxuXHJcblx0XHRcdFx0XHR0aGlzLl9sZW5kQmluZGluZyggYmluZGluZyApO1xyXG5cdFx0XHRcdFx0YmluZGluZy5zYXZlT3JpZ2luYWxTdGF0ZSgpO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLl9sZW5kQWN0aW9uKCBhY3Rpb24gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdF9kZWFjdGl2YXRlQWN0aW9uOiBmdW5jdGlvbiggYWN0aW9uICkge1xyXG5cclxuXHRcdGlmICggdGhpcy5faXNBY3RpdmVBY3Rpb24oIGFjdGlvbiApICkge1xyXG5cclxuXHRcdFx0dmFyIGJpbmRpbmdzID0gYWN0aW9uLl9wcm9wZXJ0eUJpbmRpbmdzO1xyXG5cclxuXHRcdFx0Ly8gZGVjcmVtZW50IHJlZmVyZW5jZSBjb3VudHMgLyBzb3J0IG91dCBzdGF0ZVxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIG4gPSBiaW5kaW5ncy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBiaW5kaW5nID0gYmluZGluZ3NbIGkgXTtcclxuXHJcblx0XHRcdFx0aWYgKCAtLSBiaW5kaW5nLnVzZUNvdW50ID09PSAwICkge1xyXG5cclxuXHRcdFx0XHRcdGJpbmRpbmcucmVzdG9yZU9yaWdpbmFsU3RhdGUoKTtcclxuXHRcdFx0XHRcdHRoaXMuX3Rha2VCYWNrQmluZGluZyggYmluZGluZyApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLl90YWtlQmFja0FjdGlvbiggYWN0aW9uICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHQvLyBNZW1vcnkgbWFuYWdlclxyXG5cclxuXHRfaW5pdE1lbW9yeU1hbmFnZXI6IGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdHRoaXMuX2FjdGlvbnMgPSBbXTsgLy8gJ25BY3RpdmVBY3Rpb25zJyBmb2xsb3dlZCBieSBpbmFjdGl2ZSBvbmVzXHJcblx0XHR0aGlzLl9uQWN0aXZlQWN0aW9ucyA9IDA7XHJcblxyXG5cdFx0dGhpcy5fYWN0aW9uc0J5Q2xpcCA9IHt9O1xyXG5cdFx0Ly8gaW5zaWRlOlxyXG5cdFx0Ly8ge1xyXG5cdFx0Ly8gXHRcdGtub3duQWN0aW9uczogQXJyYXk8IF9BY3Rpb24gPlx0LSB1c2VkIGFzIHByb3RvdHlwZXNcclxuXHRcdC8vIFx0XHRhY3Rpb25CeVJvb3Q6IF9BY3Rpb25cdFx0XHQtIGxvb2t1cFxyXG5cdFx0Ly8gfVxyXG5cclxuXHJcblx0XHR0aGlzLl9iaW5kaW5ncyA9IFtdOyAvLyAnbkFjdGl2ZUJpbmRpbmdzJyBmb2xsb3dlZCBieSBpbmFjdGl2ZSBvbmVzXHJcblx0XHR0aGlzLl9uQWN0aXZlQmluZGluZ3MgPSAwO1xyXG5cclxuXHRcdHRoaXMuX2JpbmRpbmdzQnlSb290QW5kTmFtZSA9IHt9OyAvLyBpbnNpZGU6IE1hcDwgbmFtZSwgUHJvcGVydHlNaXhlciA+XHJcblxyXG5cclxuXHRcdHRoaXMuX2NvbnRyb2xJbnRlcnBvbGFudHMgPSBbXTsgLy8gc2FtZSBnYW1lIGFzIGFib3ZlXHJcblx0XHR0aGlzLl9uQWN0aXZlQ29udHJvbEludGVycG9sYW50cyA9IDA7XHJcblxyXG5cdFx0dmFyIHNjb3BlID0gdGhpcztcclxuXHJcblx0XHR0aGlzLnN0YXRzID0ge1xyXG5cclxuXHRcdFx0YWN0aW9uczoge1xyXG5cdFx0XHRcdGdldCB0b3RhbCgpIHsgcmV0dXJuIHNjb3BlLl9hY3Rpb25zLmxlbmd0aDsgfSxcclxuXHRcdFx0XHRnZXQgaW5Vc2UoKSB7IHJldHVybiBzY29wZS5fbkFjdGl2ZUFjdGlvbnM7IH1cclxuXHRcdFx0fSxcclxuXHRcdFx0YmluZGluZ3M6IHtcclxuXHRcdFx0XHRnZXQgdG90YWwoKSB7IHJldHVybiBzY29wZS5fYmluZGluZ3MubGVuZ3RoOyB9LFxyXG5cdFx0XHRcdGdldCBpblVzZSgpIHsgcmV0dXJuIHNjb3BlLl9uQWN0aXZlQmluZGluZ3M7IH1cclxuXHRcdFx0fSxcclxuXHRcdFx0Y29udHJvbEludGVycG9sYW50czoge1xyXG5cdFx0XHRcdGdldCB0b3RhbCgpIHsgcmV0dXJuIHNjb3BlLl9jb250cm9sSW50ZXJwb2xhbnRzLmxlbmd0aDsgfSxcclxuXHRcdFx0XHRnZXQgaW5Vc2UoKSB7IHJldHVybiBzY29wZS5fbkFjdGl2ZUNvbnRyb2xJbnRlcnBvbGFudHM7IH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdH07XHJcblxyXG5cdH0sXHJcblxyXG5cdC8vIE1lbW9yeSBtYW5hZ2VtZW50IGZvciBfQWN0aW9uIG9iamVjdHNcclxuXHJcblx0X2lzQWN0aXZlQWN0aW9uOiBmdW5jdGlvbiggYWN0aW9uICkge1xyXG5cclxuXHRcdHZhciBpbmRleCA9IGFjdGlvbi5fY2FjaGVJbmRleDtcclxuXHRcdHJldHVybiBpbmRleCAhPT0gbnVsbCAmJiBpbmRleCA8IHRoaXMuX25BY3RpdmVBY3Rpb25zO1xyXG5cclxuXHR9LFxyXG5cclxuXHRfYWRkSW5hY3RpdmVBY3Rpb246IGZ1bmN0aW9uKCBhY3Rpb24sIGNsaXBOYW1lLCByb290VXVpZCApIHtcclxuXHJcblx0XHR2YXIgYWN0aW9ucyA9IHRoaXMuX2FjdGlvbnMsXHJcblx0XHRcdGFjdGlvbnNCeUNsaXAgPSB0aGlzLl9hY3Rpb25zQnlDbGlwLFxyXG5cdFx0XHRhY3Rpb25zRm9yQ2xpcCA9IGFjdGlvbnNCeUNsaXBbIGNsaXBOYW1lIF07XHJcblxyXG5cdFx0aWYgKCBhY3Rpb25zRm9yQ2xpcCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0YWN0aW9uc0ZvckNsaXAgPSB7XHJcblxyXG5cdFx0XHRcdGtub3duQWN0aW9uczogWyBhY3Rpb24gXSxcclxuXHRcdFx0XHRhY3Rpb25CeVJvb3Q6IHt9XHJcblxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0YWN0aW9uLl9ieUNsaXBDYWNoZUluZGV4ID0gMDtcclxuXHJcblx0XHRcdGFjdGlvbnNCeUNsaXBbIGNsaXBOYW1lIF0gPSBhY3Rpb25zRm9yQ2xpcDtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0dmFyIGtub3duQWN0aW9ucyA9IGFjdGlvbnNGb3JDbGlwLmtub3duQWN0aW9ucztcclxuXHJcblx0XHRcdGFjdGlvbi5fYnlDbGlwQ2FjaGVJbmRleCA9IGtub3duQWN0aW9ucy5sZW5ndGg7XHJcblx0XHRcdGtub3duQWN0aW9ucy5wdXNoKCBhY3Rpb24gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0YWN0aW9uLl9jYWNoZUluZGV4ID0gYWN0aW9ucy5sZW5ndGg7XHJcblx0XHRhY3Rpb25zLnB1c2goIGFjdGlvbiApO1xyXG5cclxuXHRcdGFjdGlvbnNGb3JDbGlwLmFjdGlvbkJ5Um9vdFsgcm9vdFV1aWQgXSA9IGFjdGlvbjtcclxuXHJcblx0fSxcclxuXHJcblx0X3JlbW92ZUluYWN0aXZlQWN0aW9uOiBmdW5jdGlvbiggYWN0aW9uICkge1xyXG5cclxuXHRcdHZhciBhY3Rpb25zID0gdGhpcy5fYWN0aW9ucyxcclxuXHRcdFx0bGFzdEluYWN0aXZlQWN0aW9uID0gYWN0aW9uc1sgYWN0aW9ucy5sZW5ndGggLSAxIF0sXHJcblx0XHRcdGNhY2hlSW5kZXggPSBhY3Rpb24uX2NhY2hlSW5kZXg7XHJcblxyXG5cdFx0bGFzdEluYWN0aXZlQWN0aW9uLl9jYWNoZUluZGV4ID0gY2FjaGVJbmRleDtcclxuXHRcdGFjdGlvbnNbIGNhY2hlSW5kZXggXSA9IGxhc3RJbmFjdGl2ZUFjdGlvbjtcclxuXHRcdGFjdGlvbnMucG9wKCk7XHJcblxyXG5cdFx0YWN0aW9uLl9jYWNoZUluZGV4ID0gbnVsbDtcclxuXHJcblxyXG5cdFx0dmFyIGNsaXBOYW1lID0gYWN0aW9uLl9jbGlwLm5hbWUsXHJcblx0XHRcdGFjdGlvbnNCeUNsaXAgPSB0aGlzLl9hY3Rpb25zQnlDbGlwLFxyXG5cdFx0XHRhY3Rpb25zRm9yQ2xpcCA9IGFjdGlvbnNCeUNsaXBbIGNsaXBOYW1lIF0sXHJcblx0XHRcdGtub3duQWN0aW9uc0ZvckNsaXAgPSBhY3Rpb25zRm9yQ2xpcC5rbm93bkFjdGlvbnMsXHJcblxyXG5cdFx0XHRsYXN0S25vd25BY3Rpb24gPVxyXG5cdFx0XHRcdGtub3duQWN0aW9uc0ZvckNsaXBbIGtub3duQWN0aW9uc0ZvckNsaXAubGVuZ3RoIC0gMSBdLFxyXG5cclxuXHRcdFx0YnlDbGlwQ2FjaGVJbmRleCA9IGFjdGlvbi5fYnlDbGlwQ2FjaGVJbmRleDtcclxuXHJcblx0XHRsYXN0S25vd25BY3Rpb24uX2J5Q2xpcENhY2hlSW5kZXggPSBieUNsaXBDYWNoZUluZGV4O1xyXG5cdFx0a25vd25BY3Rpb25zRm9yQ2xpcFsgYnlDbGlwQ2FjaGVJbmRleCBdID0gbGFzdEtub3duQWN0aW9uO1xyXG5cdFx0a25vd25BY3Rpb25zRm9yQ2xpcC5wb3AoKTtcclxuXHJcblx0XHRhY3Rpb24uX2J5Q2xpcENhY2hlSW5kZXggPSBudWxsO1xyXG5cclxuXHJcblx0XHR2YXIgYWN0aW9uQnlSb290ID0gYWN0aW9uc0ZvckNsaXAuYWN0aW9uQnlSb290LFxyXG5cdFx0XHRyb290VXVpZCA9ICggYWN0aW9ucy5fbG9jYWxSb290IHx8IHRoaXMuX3Jvb3QgKS51dWlkO1xyXG5cclxuXHRcdGRlbGV0ZSBhY3Rpb25CeVJvb3RbIHJvb3RVdWlkIF07XHJcblxyXG5cdFx0aWYgKCBrbm93bkFjdGlvbnNGb3JDbGlwLmxlbmd0aCA9PT0gMCApIHtcclxuXHJcblx0XHRcdGRlbGV0ZSBhY3Rpb25zQnlDbGlwWyBjbGlwTmFtZSBdO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9yZW1vdmVJbmFjdGl2ZUJpbmRpbmdzRm9yQWN0aW9uKCBhY3Rpb24gKTtcclxuXHJcblx0fSxcclxuXHJcblx0X3JlbW92ZUluYWN0aXZlQmluZGluZ3NGb3JBY3Rpb246IGZ1bmN0aW9uKCBhY3Rpb24gKSB7XHJcblxyXG5cdFx0dmFyIGJpbmRpbmdzID0gYWN0aW9uLl9wcm9wZXJ0eUJpbmRpbmdzO1xyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBuID0gYmluZGluZ3MubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xyXG5cclxuXHRcdFx0dmFyIGJpbmRpbmcgPSBiaW5kaW5nc1sgaSBdO1xyXG5cclxuXHRcdFx0aWYgKCAtLSBiaW5kaW5nLnJlZmVyZW5jZUNvdW50ID09PSAwICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLl9yZW1vdmVJbmFjdGl2ZUJpbmRpbmcoIGJpbmRpbmcgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdF9sZW5kQWN0aW9uOiBmdW5jdGlvbiggYWN0aW9uICkge1xyXG5cclxuXHRcdC8vIFsgYWN0aXZlIGFjdGlvbnMgfCAgaW5hY3RpdmUgYWN0aW9ucyAgXVxyXG5cdFx0Ly8gWyAgYWN0aXZlIGFjdGlvbnMgPnwgaW5hY3RpdmUgYWN0aW9ucyBdXHJcblx0XHQvLyAgICAgICAgICAgICAgICAgcyAgICAgICAgYVxyXG5cdFx0Ly8gICAgICAgICAgICAgICAgICA8LXN3YXAtPlxyXG5cdFx0Ly8gICAgICAgICAgICAgICAgIGEgICAgICAgIHNcclxuXHJcblx0XHR2YXIgYWN0aW9ucyA9IHRoaXMuX2FjdGlvbnMsXHJcblx0XHRcdHByZXZJbmRleCA9IGFjdGlvbi5fY2FjaGVJbmRleCxcclxuXHJcblx0XHRcdGxhc3RBY3RpdmVJbmRleCA9IHRoaXMuX25BY3RpdmVBY3Rpb25zICsrLFxyXG5cclxuXHRcdFx0Zmlyc3RJbmFjdGl2ZUFjdGlvbiA9IGFjdGlvbnNbIGxhc3RBY3RpdmVJbmRleCBdO1xyXG5cclxuXHRcdGFjdGlvbi5fY2FjaGVJbmRleCA9IGxhc3RBY3RpdmVJbmRleDtcclxuXHRcdGFjdGlvbnNbIGxhc3RBY3RpdmVJbmRleCBdID0gYWN0aW9uO1xyXG5cclxuXHRcdGZpcnN0SW5hY3RpdmVBY3Rpb24uX2NhY2hlSW5kZXggPSBwcmV2SW5kZXg7XHJcblx0XHRhY3Rpb25zWyBwcmV2SW5kZXggXSA9IGZpcnN0SW5hY3RpdmVBY3Rpb247XHJcblxyXG5cdH0sXHJcblxyXG5cdF90YWtlQmFja0FjdGlvbjogZnVuY3Rpb24oIGFjdGlvbiApIHtcclxuXHJcblx0XHQvLyBbICBhY3RpdmUgYWN0aW9ucyAgfCBpbmFjdGl2ZSBhY3Rpb25zIF1cclxuXHRcdC8vIFsgYWN0aXZlIGFjdGlvbnMgfDwgaW5hY3RpdmUgYWN0aW9ucyAgXVxyXG5cdFx0Ly8gICAgICAgIGEgICAgICAgIHNcclxuXHRcdC8vICAgICAgICAgPC1zd2FwLT5cclxuXHRcdC8vICAgICAgICBzICAgICAgICBhXHJcblxyXG5cdFx0dmFyIGFjdGlvbnMgPSB0aGlzLl9hY3Rpb25zLFxyXG5cdFx0XHRwcmV2SW5kZXggPSBhY3Rpb24uX2NhY2hlSW5kZXgsXHJcblxyXG5cdFx0XHRmaXJzdEluYWN0aXZlSW5kZXggPSAtLSB0aGlzLl9uQWN0aXZlQWN0aW9ucyxcclxuXHJcblx0XHRcdGxhc3RBY3RpdmVBY3Rpb24gPSBhY3Rpb25zWyBmaXJzdEluYWN0aXZlSW5kZXggXTtcclxuXHJcblx0XHRhY3Rpb24uX2NhY2hlSW5kZXggPSBmaXJzdEluYWN0aXZlSW5kZXg7XHJcblx0XHRhY3Rpb25zWyBmaXJzdEluYWN0aXZlSW5kZXggXSA9IGFjdGlvbjtcclxuXHJcblx0XHRsYXN0QWN0aXZlQWN0aW9uLl9jYWNoZUluZGV4ID0gcHJldkluZGV4O1xyXG5cdFx0YWN0aW9uc1sgcHJldkluZGV4IF0gPSBsYXN0QWN0aXZlQWN0aW9uO1xyXG5cclxuXHR9LFxyXG5cclxuXHQvLyBNZW1vcnkgbWFuYWdlbWVudCBmb3IgUHJvcGVydHlNaXhlciBvYmplY3RzXHJcblxyXG5cdF9hZGRJbmFjdGl2ZUJpbmRpbmc6IGZ1bmN0aW9uKCBiaW5kaW5nLCByb290VXVpZCwgdHJhY2tOYW1lICkge1xyXG5cclxuXHRcdHZhciBiaW5kaW5nc0J5Um9vdCA9IHRoaXMuX2JpbmRpbmdzQnlSb290QW5kTmFtZSxcclxuXHRcdFx0YmluZGluZ0J5TmFtZSA9IGJpbmRpbmdzQnlSb290WyByb290VXVpZCBdLFxyXG5cclxuXHRcdFx0YmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncztcclxuXHJcblx0XHRpZiAoIGJpbmRpbmdCeU5hbWUgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGJpbmRpbmdCeU5hbWUgPSB7fTtcclxuXHRcdFx0YmluZGluZ3NCeVJvb3RbIHJvb3RVdWlkIF0gPSBiaW5kaW5nQnlOYW1lO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRiaW5kaW5nQnlOYW1lWyB0cmFja05hbWUgXSA9IGJpbmRpbmc7XHJcblxyXG5cdFx0YmluZGluZy5fY2FjaGVJbmRleCA9IGJpbmRpbmdzLmxlbmd0aDtcclxuXHRcdGJpbmRpbmdzLnB1c2goIGJpbmRpbmcgKTtcclxuXHJcblx0fSxcclxuXHJcblx0X3JlbW92ZUluYWN0aXZlQmluZGluZzogZnVuY3Rpb24oIGJpbmRpbmcgKSB7XHJcblxyXG5cdFx0dmFyIGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3MsXHJcblx0XHRcdHByb3BCaW5kaW5nID0gYmluZGluZy5iaW5kaW5nLFxyXG5cdFx0XHRyb290VXVpZCA9IHByb3BCaW5kaW5nLnJvb3ROb2RlLnV1aWQsXHJcblx0XHRcdHRyYWNrTmFtZSA9IHByb3BCaW5kaW5nLnBhdGgsXHJcblx0XHRcdGJpbmRpbmdzQnlSb290ID0gdGhpcy5fYmluZGluZ3NCeVJvb3RBbmROYW1lLFxyXG5cdFx0XHRiaW5kaW5nQnlOYW1lID0gYmluZGluZ3NCeVJvb3RbIHJvb3RVdWlkIF0sXHJcblxyXG5cdFx0XHRsYXN0SW5hY3RpdmVCaW5kaW5nID0gYmluZGluZ3NbIGJpbmRpbmdzLmxlbmd0aCAtIDEgXSxcclxuXHRcdFx0Y2FjaGVJbmRleCA9IGJpbmRpbmcuX2NhY2hlSW5kZXg7XHJcblxyXG5cdFx0bGFzdEluYWN0aXZlQmluZGluZy5fY2FjaGVJbmRleCA9IGNhY2hlSW5kZXg7XHJcblx0XHRiaW5kaW5nc1sgY2FjaGVJbmRleCBdID0gbGFzdEluYWN0aXZlQmluZGluZztcclxuXHRcdGJpbmRpbmdzLnBvcCgpO1xyXG5cclxuXHRcdGRlbGV0ZSBiaW5kaW5nQnlOYW1lWyB0cmFja05hbWUgXTtcclxuXHJcblx0XHRyZW1vdmVfZW1wdHlfbWFwOiB7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgXyBpbiBiaW5kaW5nQnlOYW1lICkgYnJlYWsgcmVtb3ZlX2VtcHR5X21hcDtcclxuXHJcblx0XHRcdGRlbGV0ZSBiaW5kaW5nc0J5Um9vdFsgcm9vdFV1aWQgXTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdF9sZW5kQmluZGluZzogZnVuY3Rpb24oIGJpbmRpbmcgKSB7XHJcblxyXG5cdFx0dmFyIGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3MsXHJcblx0XHRcdHByZXZJbmRleCA9IGJpbmRpbmcuX2NhY2hlSW5kZXgsXHJcblxyXG5cdFx0XHRsYXN0QWN0aXZlSW5kZXggPSB0aGlzLl9uQWN0aXZlQmluZGluZ3MgKyssXHJcblxyXG5cdFx0XHRmaXJzdEluYWN0aXZlQmluZGluZyA9IGJpbmRpbmdzWyBsYXN0QWN0aXZlSW5kZXggXTtcclxuXHJcblx0XHRiaW5kaW5nLl9jYWNoZUluZGV4ID0gbGFzdEFjdGl2ZUluZGV4O1xyXG5cdFx0YmluZGluZ3NbIGxhc3RBY3RpdmVJbmRleCBdID0gYmluZGluZztcclxuXHJcblx0XHRmaXJzdEluYWN0aXZlQmluZGluZy5fY2FjaGVJbmRleCA9IHByZXZJbmRleDtcclxuXHRcdGJpbmRpbmdzWyBwcmV2SW5kZXggXSA9IGZpcnN0SW5hY3RpdmVCaW5kaW5nO1xyXG5cclxuXHR9LFxyXG5cclxuXHRfdGFrZUJhY2tCaW5kaW5nOiBmdW5jdGlvbiggYmluZGluZyApIHtcclxuXHJcblx0XHR2YXIgYmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncyxcclxuXHRcdFx0cHJldkluZGV4ID0gYmluZGluZy5fY2FjaGVJbmRleCxcclxuXHJcblx0XHRcdGZpcnN0SW5hY3RpdmVJbmRleCA9IC0tIHRoaXMuX25BY3RpdmVCaW5kaW5ncyxcclxuXHJcblx0XHRcdGxhc3RBY3RpdmVCaW5kaW5nID0gYmluZGluZ3NbIGZpcnN0SW5hY3RpdmVJbmRleCBdO1xyXG5cclxuXHRcdGJpbmRpbmcuX2NhY2hlSW5kZXggPSBmaXJzdEluYWN0aXZlSW5kZXg7XHJcblx0XHRiaW5kaW5nc1sgZmlyc3RJbmFjdGl2ZUluZGV4IF0gPSBiaW5kaW5nO1xyXG5cclxuXHRcdGxhc3RBY3RpdmVCaW5kaW5nLl9jYWNoZUluZGV4ID0gcHJldkluZGV4O1xyXG5cdFx0YmluZGluZ3NbIHByZXZJbmRleCBdID0gbGFzdEFjdGl2ZUJpbmRpbmc7XHJcblxyXG5cdH0sXHJcblxyXG5cclxuXHQvLyBNZW1vcnkgbWFuYWdlbWVudCBvZiBJbnRlcnBvbGFudHMgZm9yIHdlaWdodCBhbmQgdGltZSBzY2FsZVxyXG5cclxuXHRfbGVuZENvbnRyb2xJbnRlcnBvbGFudDogZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0dmFyIGludGVycG9sYW50cyA9IHRoaXMuX2NvbnRyb2xJbnRlcnBvbGFudHMsXHJcblx0XHRcdGxhc3RBY3RpdmVJbmRleCA9IHRoaXMuX25BY3RpdmVDb250cm9sSW50ZXJwb2xhbnRzICsrLFxyXG5cdFx0XHRpbnRlcnBvbGFudCA9IGludGVycG9sYW50c1sgbGFzdEFjdGl2ZUluZGV4IF07XHJcblxyXG5cdFx0aWYgKCBpbnRlcnBvbGFudCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0aW50ZXJwb2xhbnQgPSBuZXcgVEhSRUUuTGluZWFySW50ZXJwb2xhbnQoXHJcblx0XHRcdFx0XHRuZXcgRmxvYXQzMkFycmF5KCAyICksIG5ldyBGbG9hdDMyQXJyYXkoIDIgKSxcclxuXHRcdFx0XHRcdFx0MSwgdGhpcy5fY29udHJvbEludGVycG9sYW50c1Jlc3VsdEJ1ZmZlciApO1xyXG5cclxuXHRcdFx0aW50ZXJwb2xhbnQuX19jYWNoZUluZGV4ID0gbGFzdEFjdGl2ZUluZGV4O1xyXG5cdFx0XHRpbnRlcnBvbGFudHNbIGxhc3RBY3RpdmVJbmRleCBdID0gaW50ZXJwb2xhbnQ7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBpbnRlcnBvbGFudDtcclxuXHJcblx0fSxcclxuXHJcblx0X3Rha2VCYWNrQ29udHJvbEludGVycG9sYW50OiBmdW5jdGlvbiggaW50ZXJwb2xhbnQgKSB7XHJcblxyXG5cdFx0dmFyIGludGVycG9sYW50cyA9IHRoaXMuX2NvbnRyb2xJbnRlcnBvbGFudHMsXHJcblx0XHRcdHByZXZJbmRleCA9IGludGVycG9sYW50Ll9fY2FjaGVJbmRleCxcclxuXHJcblx0XHRcdGZpcnN0SW5hY3RpdmVJbmRleCA9IC0tIHRoaXMuX25BY3RpdmVDb250cm9sSW50ZXJwb2xhbnRzLFxyXG5cclxuXHRcdFx0bGFzdEFjdGl2ZUludGVycG9sYW50ID0gaW50ZXJwb2xhbnRzWyBmaXJzdEluYWN0aXZlSW5kZXggXTtcclxuXHJcblx0XHRpbnRlcnBvbGFudC5fX2NhY2hlSW5kZXggPSBmaXJzdEluYWN0aXZlSW5kZXg7XHJcblx0XHRpbnRlcnBvbGFudHNbIGZpcnN0SW5hY3RpdmVJbmRleCBdID0gaW50ZXJwb2xhbnQ7XHJcblxyXG5cdFx0bGFzdEFjdGl2ZUludGVycG9sYW50Ll9fY2FjaGVJbmRleCA9IHByZXZJbmRleDtcclxuXHRcdGludGVycG9sYW50c1sgcHJldkluZGV4IF0gPSBsYXN0QWN0aXZlSW50ZXJwb2xhbnQ7XHJcblxyXG5cdH0sXHJcblxyXG5cdF9jb250cm9sSW50ZXJwb2xhbnRzUmVzdWx0QnVmZmVyOiBuZXcgRmxvYXQzMkFycmF5KCAxIClcclxuXHJcbn0gKTtcclxuXHJcblxyXG4vLyBGaWxlOnNyYy9hbmltYXRpb24vQW5pbWF0aW9uT2JqZWN0R3JvdXAuanNcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBBIGdyb3VwIG9mIG9iamVjdHMgdGhhdCByZWNlaXZlcyBhIHNoYXJlZCBhbmltYXRpb24gc3RhdGUuXHJcbiAqXHJcbiAqIFVzYWdlOlxyXG4gKlxyXG4gKiBcdC1cdEFkZCBvYmplY3RzIHlvdSB3b3VsZCBvdGhlcndpc2UgcGFzcyBhcyAncm9vdCcgdG8gdGhlXHJcbiAqIFx0XHRjb25zdHJ1Y3RvciBvciB0aGUgLmNsaXBBY3Rpb24gbWV0aG9kIG9mIEFuaW1hdGlvbk1peGVyLlxyXG4gKlxyXG4gKiBcdC1cdEluc3RlYWQgcGFzcyB0aGlzIG9iamVjdCBhcyAncm9vdCcuXHJcbiAqXHJcbiAqIFx0LVx0WW91IGNhbiBhbHNvIGFkZCBhbmQgcmVtb3ZlIG9iamVjdHMgbGF0ZXIgd2hlbiB0aGUgbWl4ZXJcclxuICogXHRcdGlzIHJ1bm5pbmcuXHJcbiAqXHJcbiAqIE5vdGU6XHJcbiAqXHJcbiAqICBcdE9iamVjdHMgb2YgdGhpcyBjbGFzcyBhcHBlYXIgYXMgb25lIG9iamVjdCB0byB0aGUgbWl4ZXIsXHJcbiAqICBcdHNvIGNhY2hlIGNvbnRyb2wgb2YgdGhlIGluZGl2aWR1YWwgb2JqZWN0cyBtdXN0IGJlIGRvbmVcclxuICogIFx0b24gdGhlIGdyb3VwLlxyXG4gKlxyXG4gKiBMaW1pdGF0aW9uOlxyXG4gKlxyXG4gKiBcdC0gXHRUaGUgYW5pbWF0ZWQgcHJvcGVydGllcyBtdXN0IGJlIGNvbXBhdGlibGUgYW1vbmcgdGhlXHJcbiAqIFx0XHRhbGwgb2JqZWN0cyBpbiB0aGUgZ3JvdXAuXHJcbiAqXHJcbiAqICAtXHRBIHNpbmdsZSBwcm9wZXJ0eSBjYW4gZWl0aGVyIGJlIGNvbnRyb2xsZWQgdGhyb3VnaCBhXHJcbiAqICBcdHRhcmdldCBncm91cCBvciBkaXJlY3RseSwgYnV0IG5vdCBib3RoLlxyXG4gKlxyXG4gKiBAYXV0aG9yIHRzY2h3XHJcbiAqL1xyXG5cclxuVEhSRUUuQW5pbWF0aW9uT2JqZWN0R3JvdXAgPSBmdW5jdGlvbiggdmFyX2FyZ3MgKSB7XHJcblxyXG5cdHRoaXMudXVpZCA9IFRIUkVFLk1hdGguZ2VuZXJhdGVVVUlEKCk7XHJcblxyXG5cdC8vIGNhY2hlZCBvYmplY3RzIGZvbGxvd2VkIGJ5IHRoZSBhY3RpdmUgb25lc1xyXG5cdHRoaXMuX29iamVjdHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggYXJndW1lbnRzICk7XHJcblxyXG5cdHRoaXMubkNhY2hlZE9iamVjdHNfID0gMDtcdFx0XHQvLyB0aHJlc2hvbGRcclxuXHQvLyBub3RlOiByZWFkIGJ5IFByb3BlcnR5QmluZGluZy5Db21wb3NpdGVcclxuXHJcblx0dmFyIGluZGljZXMgPSB7fTtcclxuXHR0aGlzLl9pbmRpY2VzQnlVVUlEID0gaW5kaWNlcztcdFx0Ly8gZm9yIGJvb2trZWVwaW5nXHJcblxyXG5cdGZvciAoIHZhciBpID0gMCwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XHJcblxyXG5cdFx0aW5kaWNlc1sgYXJndW1lbnRzWyBpIF0udXVpZCBdID0gaTtcclxuXHJcblx0fVxyXG5cclxuXHR0aGlzLl9wYXRocyA9IFtdO1x0XHRcdFx0XHQvLyBpbnNpZGU6IHN0cmluZ1xyXG5cdHRoaXMuX3BhcnNlZFBhdGhzID0gW107XHRcdFx0XHQvLyBpbnNpZGU6IHsgd2UgZG9uJ3QgY2FyZSwgaGVyZSB9XHJcblx0dGhpcy5fYmluZGluZ3MgPSBbXTsgXHRcdFx0XHQvLyBpbnNpZGU6IEFycmF5PCBQcm9wZXJ0eUJpbmRpbmcgPlxyXG5cdHRoaXMuX2JpbmRpbmdzSW5kaWNlc0J5UGF0aCA9IHt9OyBcdC8vIGluc2lkZTogaW5kaWNlcyBpbiB0aGVzZSBhcnJheXNcclxuXHJcblx0dmFyIHNjb3BlID0gdGhpcztcclxuXHJcblx0dGhpcy5zdGF0cyA9IHtcclxuXHJcblx0XHRvYmplY3RzOiB7XHJcblx0XHRcdGdldCB0b3RhbCgpIHsgcmV0dXJuIHNjb3BlLl9vYmplY3RzLmxlbmd0aDsgfSxcclxuXHRcdFx0Z2V0IGluVXNlKCkgeyByZXR1cm4gdGhpcy50b3RhbCAtIHNjb3BlLm5DYWNoZWRPYmplY3RzXzsgIH1cclxuXHRcdH0sXHJcblxyXG5cdFx0Z2V0IGJpbmRpbmdzUGVyT2JqZWN0KCkgeyByZXR1cm4gc2NvcGUuX2JpbmRpbmdzLmxlbmd0aDsgfVxyXG5cclxuXHR9O1xyXG5cclxufTtcclxuXHJcblRIUkVFLkFuaW1hdGlvbk9iamVjdEdyb3VwLnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLkFuaW1hdGlvbk9iamVjdEdyb3VwLFxyXG5cclxuXHRhZGQ6IGZ1bmN0aW9uKCB2YXJfYXJncyApIHtcclxuXHJcblx0XHR2YXIgb2JqZWN0cyA9IHRoaXMuX29iamVjdHMsXHJcblx0XHRcdG5PYmplY3RzID0gb2JqZWN0cy5sZW5ndGgsXHJcblx0XHRcdG5DYWNoZWRPYmplY3RzID0gdGhpcy5uQ2FjaGVkT2JqZWN0c18sXHJcblx0XHRcdGluZGljZXNCeVVVSUQgPSB0aGlzLl9pbmRpY2VzQnlVVUlELFxyXG5cdFx0XHRwYXRocyA9IHRoaXMuX3BhdGhzLFxyXG5cdFx0XHRwYXJzZWRQYXRocyA9IHRoaXMuX3BhcnNlZFBhdGhzLFxyXG5cdFx0XHRiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzLFxyXG5cdFx0XHRuQmluZGluZ3MgPSBiaW5kaW5ncy5sZW5ndGg7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcclxuXHJcblx0XHRcdHZhciBvYmplY3QgPSBhcmd1bWVudHNbIGkgXSxcclxuXHRcdFx0XHR1dWlkID0gb2JqZWN0LnV1aWQsXHJcblx0XHRcdFx0aW5kZXggPSBpbmRpY2VzQnlVVUlEWyB1dWlkIF07XHJcblxyXG5cdFx0XHRpZiAoIGluZGV4ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdC8vIHVua25vd24gb2JqZWN0IC0+IGFkZCBpdCB0byB0aGUgQUNUSVZFIHJlZ2lvblxyXG5cclxuXHRcdFx0XHRpbmRleCA9IG5PYmplY3RzICsrO1xyXG5cdFx0XHRcdGluZGljZXNCeVVVSURbIHV1aWQgXSA9IGluZGV4O1xyXG5cdFx0XHRcdG9iamVjdHMucHVzaCggb2JqZWN0ICk7XHJcblxyXG5cdFx0XHRcdC8vIGFjY291bnRpbmcgaXMgZG9uZSwgbm93IGRvIHRoZSBzYW1lIGZvciBhbGwgYmluZGluZ3NcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGogPSAwLCBtID0gbkJpbmRpbmdzOyBqICE9PSBtOyArKyBqICkge1xyXG5cclxuXHRcdFx0XHRcdGJpbmRpbmdzWyBqIF0ucHVzaChcclxuXHRcdFx0XHRcdFx0XHRuZXcgVEhSRUUuUHJvcGVydHlCaW5kaW5nKFxyXG5cdFx0XHRcdFx0XHRcdFx0b2JqZWN0LCBwYXRoc1sgaiBdLCBwYXJzZWRQYXRoc1sgaiBdICkgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggaW5kZXggPCBuQ2FjaGVkT2JqZWN0cyApIHtcclxuXHJcblx0XHRcdFx0dmFyIGtub3duT2JqZWN0ID0gb2JqZWN0c1sgaW5kZXggXTtcclxuXHJcblx0XHRcdFx0Ly8gbW92ZSBleGlzdGluZyBvYmplY3QgdG8gdGhlIEFDVElWRSByZWdpb25cclxuXHJcblx0XHRcdFx0dmFyIGZpcnN0QWN0aXZlSW5kZXggPSAtLSBuQ2FjaGVkT2JqZWN0cyxcclxuXHRcdFx0XHRcdGxhc3RDYWNoZWRPYmplY3QgPSBvYmplY3RzWyBmaXJzdEFjdGl2ZUluZGV4IF07XHJcblxyXG5cdFx0XHRcdGluZGljZXNCeVVVSURbIGxhc3RDYWNoZWRPYmplY3QudXVpZCBdID0gaW5kZXg7XHJcblx0XHRcdFx0b2JqZWN0c1sgaW5kZXggXSA9IGxhc3RDYWNoZWRPYmplY3Q7XHJcblxyXG5cdFx0XHRcdGluZGljZXNCeVVVSURbIHV1aWQgXSA9IGZpcnN0QWN0aXZlSW5kZXg7XHJcblx0XHRcdFx0b2JqZWN0c1sgZmlyc3RBY3RpdmVJbmRleCBdID0gb2JqZWN0O1xyXG5cclxuXHRcdFx0XHQvLyBhY2NvdW50aW5nIGlzIGRvbmUsIG5vdyBkbyB0aGUgc2FtZSBmb3IgYWxsIGJpbmRpbmdzXHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciBqID0gMCwgbSA9IG5CaW5kaW5nczsgaiAhPT0gbTsgKysgaiApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgYmluZGluZ3NGb3JQYXRoID0gYmluZGluZ3NbIGogXSxcclxuXHRcdFx0XHRcdFx0bGFzdENhY2hlZCA9IGJpbmRpbmdzRm9yUGF0aFsgZmlyc3RBY3RpdmVJbmRleCBdLFxyXG5cdFx0XHRcdFx0XHRiaW5kaW5nID0gYmluZGluZ3NGb3JQYXRoWyBpbmRleCBdO1xyXG5cclxuXHRcdFx0XHRcdGJpbmRpbmdzRm9yUGF0aFsgaW5kZXggXSA9IGxhc3RDYWNoZWQ7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBiaW5kaW5nID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHQvLyBzaW5jZSB3ZSBkbyBub3QgYm90aGVyIHRvIGNyZWF0ZSBuZXcgYmluZGluZ3NcclxuXHRcdFx0XHRcdFx0Ly8gZm9yIG9iamVjdHMgdGhhdCBhcmUgY2FjaGVkLCB0aGUgYmluZGluZyBtYXlcclxuXHRcdFx0XHRcdFx0Ly8gb3IgbWF5IG5vdCBleGlzdFxyXG5cclxuXHRcdFx0XHRcdFx0YmluZGluZyA9IG5ldyBUSFJFRS5Qcm9wZXJ0eUJpbmRpbmcoXHJcblx0XHRcdFx0XHRcdFx0XHRvYmplY3QsIHBhdGhzWyBqIF0sIHBhcnNlZFBhdGhzWyBqIF0gKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0YmluZGluZ3NGb3JQYXRoWyBmaXJzdEFjdGl2ZUluZGV4IF0gPSBiaW5kaW5nO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBvYmplY3RzWyBpbmRleCBdICE9PSBrbm93bk9iamVjdCkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCBcIkRpZmZlcmVudCBvYmplY3RzIHdpdGggdGhlIHNhbWUgVVVJRCBcIiArXHJcblx0XHRcdFx0XHRcdFwiZGV0ZWN0ZWQuIENsZWFuIHRoZSBjYWNoZXMgb3IgcmVjcmVhdGUgeW91ciBcIiArXHJcblx0XHRcdFx0XHRcdFwiaW5mcmFzdHJ1Y3R1cmUgd2hlbiByZWxvYWRpbmcgc2NlbmVzLi4uXCIgKTtcclxuXHJcblx0XHRcdH0gLy8gZWxzZSB0aGUgb2JqZWN0IGlzIGFscmVhZHkgd2hlcmUgd2Ugd2FudCBpdCB0byBiZVxyXG5cclxuXHRcdH0gLy8gZm9yIGFyZ3VtZW50c1xyXG5cclxuXHRcdHRoaXMubkNhY2hlZE9iamVjdHNfID0gbkNhY2hlZE9iamVjdHM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHJlbW92ZTogZnVuY3Rpb24oIHZhcl9hcmdzICkge1xyXG5cclxuXHRcdHZhciBvYmplY3RzID0gdGhpcy5fb2JqZWN0cyxcclxuXHRcdFx0bk9iamVjdHMgPSBvYmplY3RzLmxlbmd0aCxcclxuXHRcdFx0bkNhY2hlZE9iamVjdHMgPSB0aGlzLm5DYWNoZWRPYmplY3RzXyxcclxuXHRcdFx0aW5kaWNlc0J5VVVJRCA9IHRoaXMuX2luZGljZXNCeVVVSUQsXHJcblx0XHRcdGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3MsXHJcblx0XHRcdG5CaW5kaW5ncyA9IGJpbmRpbmdzLmxlbmd0aDtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xyXG5cclxuXHRcdFx0dmFyIG9iamVjdCA9IGFyZ3VtZW50c1sgaSBdLFxyXG5cdFx0XHRcdHV1aWQgPSBvYmplY3QudXVpZCxcclxuXHRcdFx0XHRpbmRleCA9IGluZGljZXNCeVVVSURbIHV1aWQgXTtcclxuXHJcblx0XHRcdGlmICggaW5kZXggIT09IHVuZGVmaW5lZCAmJiBpbmRleCA+PSBuQ2FjaGVkT2JqZWN0cyApIHtcclxuXHJcblx0XHRcdFx0Ly8gbW92ZSBleGlzdGluZyBvYmplY3QgaW50byB0aGUgQ0FDSEVEIHJlZ2lvblxyXG5cclxuXHRcdFx0XHR2YXIgbGFzdENhY2hlZEluZGV4ID0gbkNhY2hlZE9iamVjdHMgKyssXHJcblx0XHRcdFx0XHRmaXJzdEFjdGl2ZU9iamVjdCA9IG9iamVjdHNbIGxhc3RDYWNoZWRJbmRleCBdO1xyXG5cclxuXHRcdFx0XHRpbmRpY2VzQnlVVUlEWyBmaXJzdEFjdGl2ZU9iamVjdC51dWlkIF0gPSBpbmRleDtcclxuXHRcdFx0XHRvYmplY3RzWyBpbmRleCBdID0gZmlyc3RBY3RpdmVPYmplY3Q7XHJcblxyXG5cdFx0XHRcdGluZGljZXNCeVVVSURbIHV1aWQgXSA9IGxhc3RDYWNoZWRJbmRleDtcclxuXHRcdFx0XHRvYmplY3RzWyBsYXN0Q2FjaGVkSW5kZXggXSA9IG9iamVjdDtcclxuXHJcblx0XHRcdFx0Ly8gYWNjb3VudGluZyBpcyBkb25lLCBub3cgZG8gdGhlIHNhbWUgZm9yIGFsbCBiaW5kaW5nc1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaiA9IDAsIG0gPSBuQmluZGluZ3M7IGogIT09IG07ICsrIGogKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIGJpbmRpbmdzRm9yUGF0aCA9IGJpbmRpbmdzWyBqIF0sXHJcblx0XHRcdFx0XHRcdGZpcnN0QWN0aXZlID0gYmluZGluZ3NGb3JQYXRoWyBsYXN0Q2FjaGVkSW5kZXggXSxcclxuXHRcdFx0XHRcdFx0YmluZGluZyA9IGJpbmRpbmdzRm9yUGF0aFsgaW5kZXggXTtcclxuXHJcblx0XHRcdFx0XHRiaW5kaW5nc0ZvclBhdGhbIGluZGV4IF0gPSBmaXJzdEFjdGl2ZTtcclxuXHRcdFx0XHRcdGJpbmRpbmdzRm9yUGF0aFsgbGFzdENhY2hlZEluZGV4IF0gPSBiaW5kaW5nO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSAvLyBmb3IgYXJndW1lbnRzXHJcblxyXG5cdFx0dGhpcy5uQ2FjaGVkT2JqZWN0c18gPSBuQ2FjaGVkT2JqZWN0cztcclxuXHJcblx0fSxcclxuXHJcblx0Ly8gcmVtb3ZlICYgZm9yZ2V0XHJcblx0dW5jYWNoZTogZnVuY3Rpb24oIHZhcl9hcmdzICkge1xyXG5cclxuXHRcdHZhciBvYmplY3RzID0gdGhpcy5fb2JqZWN0cyxcclxuXHRcdFx0bk9iamVjdHMgPSBvYmplY3RzLmxlbmd0aCxcclxuXHRcdFx0bkNhY2hlZE9iamVjdHMgPSB0aGlzLm5DYWNoZWRPYmplY3RzXyxcclxuXHRcdFx0aW5kaWNlc0J5VVVJRCA9IHRoaXMuX2luZGljZXNCeVVVSUQsXHJcblx0XHRcdGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3MsXHJcblx0XHRcdG5CaW5kaW5ncyA9IGJpbmRpbmdzLmxlbmd0aDtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xyXG5cclxuXHRcdFx0dmFyIG9iamVjdCA9IGFyZ3VtZW50c1sgaSBdLFxyXG5cdFx0XHRcdHV1aWQgPSBvYmplY3QudXVpZCxcclxuXHRcdFx0XHRpbmRleCA9IGluZGljZXNCeVVVSURbIHV1aWQgXTtcclxuXHJcblx0XHRcdGlmICggaW5kZXggIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0ZGVsZXRlIGluZGljZXNCeVVVSURbIHV1aWQgXTtcclxuXHJcblx0XHRcdFx0aWYgKCBpbmRleCA8IG5DYWNoZWRPYmplY3RzICkge1xyXG5cclxuXHRcdFx0XHRcdC8vIG9iamVjdCBpcyBjYWNoZWQsIHNocmluayB0aGUgQ0FDSEVEIHJlZ2lvblxyXG5cclxuXHRcdFx0XHRcdHZhciBmaXJzdEFjdGl2ZUluZGV4ID0gLS0gbkNhY2hlZE9iamVjdHMsXHJcblx0XHRcdFx0XHRcdGxhc3RDYWNoZWRPYmplY3QgPSBvYmplY3RzWyBmaXJzdEFjdGl2ZUluZGV4IF0sXHJcblx0XHRcdFx0XHRcdGxhc3RJbmRleCA9IC0tIG5PYmplY3RzLFxyXG5cdFx0XHRcdFx0XHRsYXN0T2JqZWN0ID0gb2JqZWN0c1sgbGFzdEluZGV4IF07XHJcblxyXG5cdFx0XHRcdFx0Ly8gbGFzdCBjYWNoZWQgb2JqZWN0IHRha2VzIHRoaXMgb2JqZWN0J3MgcGxhY2VcclxuXHRcdFx0XHRcdGluZGljZXNCeVVVSURbIGxhc3RDYWNoZWRPYmplY3QudXVpZCBdID0gaW5kZXg7XHJcblx0XHRcdFx0XHRvYmplY3RzWyBpbmRleCBdID0gbGFzdENhY2hlZE9iamVjdDtcclxuXHJcblx0XHRcdFx0XHQvLyBsYXN0IG9iamVjdCBnb2VzIHRvIHRoZSBhY3RpdmF0ZWQgc2xvdCBhbmQgcG9wXHJcblx0XHRcdFx0XHRpbmRpY2VzQnlVVUlEWyBsYXN0T2JqZWN0LnV1aWQgXSA9IGZpcnN0QWN0aXZlSW5kZXg7XHJcblx0XHRcdFx0XHRvYmplY3RzWyBmaXJzdEFjdGl2ZUluZGV4IF0gPSBsYXN0T2JqZWN0O1xyXG5cdFx0XHRcdFx0b2JqZWN0cy5wb3AoKTtcclxuXHJcblx0XHRcdFx0XHQvLyBhY2NvdW50aW5nIGlzIGRvbmUsIG5vdyBkbyB0aGUgc2FtZSBmb3IgYWxsIGJpbmRpbmdzXHJcblxyXG5cdFx0XHRcdFx0Zm9yICggdmFyIGogPSAwLCBtID0gbkJpbmRpbmdzOyBqICE9PSBtOyArKyBqICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dmFyIGJpbmRpbmdzRm9yUGF0aCA9IGJpbmRpbmdzWyBqIF0sXHJcblx0XHRcdFx0XHRcdFx0bGFzdENhY2hlZCA9IGJpbmRpbmdzRm9yUGF0aFsgZmlyc3RBY3RpdmVJbmRleCBdLFxyXG5cdFx0XHRcdFx0XHRcdGxhc3QgPSBiaW5kaW5nc0ZvclBhdGhbIGxhc3RJbmRleCBdO1xyXG5cclxuXHRcdFx0XHRcdFx0YmluZGluZ3NGb3JQYXRoWyBpbmRleCBdID0gbGFzdENhY2hlZDtcclxuXHRcdFx0XHRcdFx0YmluZGluZ3NGb3JQYXRoWyBmaXJzdEFjdGl2ZUluZGV4IF0gPSBsYXN0O1xyXG5cdFx0XHRcdFx0XHRiaW5kaW5nc0ZvclBhdGgucG9wKCk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdC8vIG9iamVjdCBpcyBhY3RpdmUsIGp1c3Qgc3dhcCB3aXRoIHRoZSBsYXN0IGFuZCBwb3BcclxuXHJcblx0XHRcdFx0XHR2YXIgbGFzdEluZGV4ID0gLS0gbk9iamVjdHMsXHJcblx0XHRcdFx0XHRcdGxhc3RPYmplY3QgPSBvYmplY3RzWyBsYXN0SW5kZXggXTtcclxuXHJcblx0XHRcdFx0XHRpbmRpY2VzQnlVVUlEWyBsYXN0T2JqZWN0LnV1aWQgXSA9IGluZGV4O1xyXG5cdFx0XHRcdFx0b2JqZWN0c1sgaW5kZXggXSA9IGxhc3RPYmplY3Q7XHJcblx0XHRcdFx0XHRvYmplY3RzLnBvcCgpO1xyXG5cclxuXHRcdFx0XHRcdC8vIGFjY291bnRpbmcgaXMgZG9uZSwgbm93IGRvIHRoZSBzYW1lIGZvciBhbGwgYmluZGluZ3NcclxuXHJcblx0XHRcdFx0XHRmb3IgKCB2YXIgaiA9IDAsIG0gPSBuQmluZGluZ3M7IGogIT09IG07ICsrIGogKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR2YXIgYmluZGluZ3NGb3JQYXRoID0gYmluZGluZ3NbIGogXTtcclxuXHJcblx0XHRcdFx0XHRcdGJpbmRpbmdzRm9yUGF0aFsgaW5kZXggXSA9IGJpbmRpbmdzRm9yUGF0aFsgbGFzdEluZGV4IF07XHJcblx0XHRcdFx0XHRcdGJpbmRpbmdzRm9yUGF0aC5wb3AoKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH0gLy8gY2FjaGVkIG9yIGFjdGl2ZVxyXG5cclxuXHRcdFx0fSAvLyBpZiBvYmplY3QgaXMga25vd25cclxuXHJcblx0XHR9IC8vIGZvciBhcmd1bWVudHNcclxuXHJcblx0XHR0aGlzLm5DYWNoZWRPYmplY3RzXyA9IG5DYWNoZWRPYmplY3RzO1xyXG5cclxuXHR9LFxyXG5cclxuXHQvLyBJbnRlcm5hbCBpbnRlcmZhY2UgdXNlZCBieSBiZWZyaWVuZGVkIFByb3BlcnR5QmluZGluZy5Db21wb3NpdGU6XHJcblxyXG5cdHN1YnNjcmliZV86IGZ1bmN0aW9uKCBwYXRoLCBwYXJzZWRQYXRoICkge1xyXG5cdFx0Ly8gcmV0dXJucyBhbiBhcnJheSBvZiBiaW5kaW5ncyBmb3IgdGhlIGdpdmVuIHBhdGggdGhhdCBpcyBjaGFuZ2VkXHJcblx0XHQvLyBhY2NvcmRpbmcgdG8gdGhlIGNvbnRhaW5lZCBvYmplY3RzIGluIHRoZSBncm91cFxyXG5cclxuXHRcdHZhciBpbmRpY2VzQnlQYXRoID0gdGhpcy5fYmluZGluZ3NJbmRpY2VzQnlQYXRoLFxyXG5cdFx0XHRpbmRleCA9IGluZGljZXNCeVBhdGhbIHBhdGggXSxcclxuXHRcdFx0YmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncztcclxuXHJcblx0XHRpZiAoIGluZGV4ICE9PSB1bmRlZmluZWQgKSByZXR1cm4gYmluZGluZ3NbIGluZGV4IF07XHJcblxyXG5cdFx0dmFyIHBhdGhzID0gdGhpcy5fcGF0aHMsXHJcblx0XHRcdHBhcnNlZFBhdGhzID0gdGhpcy5fcGFyc2VkUGF0aHMsXHJcblx0XHRcdG9iamVjdHMgPSB0aGlzLl9vYmplY3RzLFxyXG5cdFx0XHRuT2JqZWN0cyA9IG9iamVjdHMubGVuZ3RoLFxyXG5cdFx0XHRuQ2FjaGVkT2JqZWN0cyA9IHRoaXMubkNhY2hlZE9iamVjdHNfLFxyXG5cdFx0XHRiaW5kaW5nc0ZvclBhdGggPSBuZXcgQXJyYXkoIG5PYmplY3RzICk7XHJcblxyXG5cdFx0aW5kZXggPSBiaW5kaW5ncy5sZW5ndGg7XHJcblxyXG5cdFx0aW5kaWNlc0J5UGF0aFsgcGF0aCBdID0gaW5kZXg7XHJcblxyXG5cdFx0cGF0aHMucHVzaCggcGF0aCApO1xyXG5cdFx0cGFyc2VkUGF0aHMucHVzaCggcGFyc2VkUGF0aCApO1xyXG5cdFx0YmluZGluZ3MucHVzaCggYmluZGluZ3NGb3JQYXRoICk7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSBuQ2FjaGVkT2JqZWN0cyxcclxuXHRcdFx0XHRuID0gb2JqZWN0cy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XHJcblxyXG5cdFx0XHR2YXIgb2JqZWN0ID0gb2JqZWN0c1sgaSBdO1xyXG5cclxuXHRcdFx0YmluZGluZ3NGb3JQYXRoWyBpIF0gPVxyXG5cdFx0XHRcdFx0bmV3IFRIUkVFLlByb3BlcnR5QmluZGluZyggb2JqZWN0LCBwYXRoLCBwYXJzZWRQYXRoICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBiaW5kaW5nc0ZvclBhdGg7XHJcblxyXG5cdH0sXHJcblxyXG5cdHVuc3Vic2NyaWJlXzogZnVuY3Rpb24oIHBhdGggKSB7XHJcblx0XHQvLyB0ZWxscyB0aGUgZ3JvdXAgdG8gZm9yZ2V0IGFib3V0IGEgcHJvcGVydHkgcGF0aCBhbmQgbm8gbG9uZ2VyXHJcblx0XHQvLyB1cGRhdGUgdGhlIGFycmF5IHByZXZpb3VzbHkgb2J0YWluZWQgd2l0aCAnc3Vic2NyaWJlXydcclxuXHJcblx0XHR2YXIgaW5kaWNlc0J5UGF0aCA9IHRoaXMuX2JpbmRpbmdzSW5kaWNlc0J5UGF0aCxcclxuXHRcdFx0aW5kZXggPSBpbmRpY2VzQnlQYXRoWyBwYXRoIF07XHJcblxyXG5cdFx0aWYgKCBpbmRleCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0dmFyIHBhdGhzID0gdGhpcy5fcGF0aHMsXHJcblx0XHRcdFx0cGFyc2VkUGF0aHMgPSB0aGlzLl9wYXJzZWRQYXRocyxcclxuXHRcdFx0XHRiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzLFxyXG5cdFx0XHRcdGxhc3RCaW5kaW5nc0luZGV4ID0gYmluZGluZ3MubGVuZ3RoIC0gMSxcclxuXHRcdFx0XHRsYXN0QmluZGluZ3MgPSBiaW5kaW5nc1sgbGFzdEJpbmRpbmdzSW5kZXggXSxcclxuXHRcdFx0XHRsYXN0QmluZGluZ3NQYXRoID0gcGF0aFsgbGFzdEJpbmRpbmdzSW5kZXggXTtcclxuXHJcblx0XHRcdGluZGljZXNCeVBhdGhbIGxhc3RCaW5kaW5nc1BhdGggXSA9IGluZGV4O1xyXG5cclxuXHRcdFx0YmluZGluZ3NbIGluZGV4IF0gPSBsYXN0QmluZGluZ3M7XHJcblx0XHRcdGJpbmRpbmdzLnBvcCgpO1xyXG5cclxuXHRcdFx0cGFyc2VkUGF0aHNbIGluZGV4IF0gPSBwYXJzZWRQYXRoc1sgbGFzdEJpbmRpbmdzSW5kZXggXTtcclxuXHRcdFx0cGFyc2VkUGF0aHMucG9wKCk7XHJcblxyXG5cdFx0XHRwYXRoc1sgaW5kZXggXSA9IHBhdGhzWyBsYXN0QmluZGluZ3NJbmRleCBdO1xyXG5cdFx0XHRwYXRocy5wb3AoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5cclxuLy8gRmlsZTpzcmMvYW5pbWF0aW9uL0FuaW1hdGlvblV0aWxzLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciB0c2Nod1xyXG4gKiBAYXV0aG9yIEJlbiBIb3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvL1xyXG4gKiBAYXV0aG9yIERhdmlkIFNhcm5vIC8gaHR0cDovL2xpZ2h0aGF1cy51cy9cclxuICovXHJcblxyXG5USFJFRS5BbmltYXRpb25VdGlscyA9IHtcclxuXHJcblx0Ly8gc2FtZSBhcyBBcnJheS5wcm90b3R5cGUuc2xpY2UsIGJ1dCBhbHNvIHdvcmtzIG9uIHR5cGVkIGFycmF5c1xyXG5cdGFycmF5U2xpY2U6IGZ1bmN0aW9uKCBhcnJheSwgZnJvbSwgdG8gKSB7XHJcblxyXG5cdFx0aWYgKCBUSFJFRS5BbmltYXRpb25VdGlscy5pc1R5cGVkQXJyYXkoIGFycmF5ICkgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gbmV3IGFycmF5LmNvbnN0cnVjdG9yKCBhcnJheS5zdWJhcnJheSggZnJvbSwgdG8gKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gYXJyYXkuc2xpY2UoIGZyb20sIHRvICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdC8vIGNvbnZlcnRzIGFuIGFycmF5IHRvIGEgc3BlY2lmaWMgdHlwZVxyXG5cdGNvbnZlcnRBcnJheTogZnVuY3Rpb24oIGFycmF5LCB0eXBlLCBmb3JjZUNsb25lICkge1xyXG5cclxuXHRcdGlmICggISBhcnJheSB8fCAvLyBsZXQgJ3VuZGVmaW5lZCcgYW5kICdudWxsJyBwYXNzXHJcblx0XHRcdFx0ISBmb3JjZUNsb25lICYmIGFycmF5LmNvbnN0cnVjdG9yID09PSB0eXBlICkgcmV0dXJuIGFycmF5O1xyXG5cclxuXHRcdGlmICggdHlwZW9mIHR5cGUuQllURVNfUEVSX0VMRU1FTlQgPT09ICdudW1iZXInICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIG5ldyB0eXBlKCBhcnJheSApOyAvLyBjcmVhdGUgdHlwZWQgYXJyYXlcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBhcnJheSApOyAvLyBjcmVhdGUgQXJyYXlcclxuXHJcblx0fSxcclxuXHJcblx0aXNUeXBlZEFycmF5OiBmdW5jdGlvbiggb2JqZWN0ICkge1xyXG5cclxuXHRcdHJldHVybiBBcnJheUJ1ZmZlci5pc1ZpZXcoIG9iamVjdCApICYmXHJcblx0XHRcdFx0ISAoIG9iamVjdCBpbnN0YW5jZW9mIERhdGFWaWV3ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdC8vIHJldHVybnMgYW4gYXJyYXkgYnkgd2hpY2ggdGltZXMgYW5kIHZhbHVlcyBjYW4gYmUgc29ydGVkXHJcblx0Z2V0S2V5ZnJhbWVPcmRlcjogZnVuY3Rpb24oIHRpbWVzICkge1xyXG5cclxuXHRcdGZ1bmN0aW9uIGNvbXBhcmVUaW1lKCBpLCBqICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRpbWVzWyBpIF0gLSB0aW1lc1sgaiBdO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgbiA9IHRpbWVzLmxlbmd0aDtcclxuXHRcdHZhciByZXN1bHQgPSBuZXcgQXJyYXkoIG4gKTtcclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSAhPT0gbjsgKysgaSApIHJlc3VsdFsgaSBdID0gaTtcclxuXHJcblx0XHRyZXN1bHQuc29ydCggY29tcGFyZVRpbWUgKTtcclxuXHJcblx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cclxuXHR9LFxyXG5cclxuXHQvLyB1c2VzIHRoZSBhcnJheSBwcmV2aW91c2x5IHJldHVybmVkIGJ5ICdnZXRLZXlmcmFtZU9yZGVyJyB0byBzb3J0IGRhdGFcclxuXHRzb3J0ZWRBcnJheTogZnVuY3Rpb24oIHZhbHVlcywgc3RyaWRlLCBvcmRlciApIHtcclxuXHJcblx0XHR2YXIgblZhbHVlcyA9IHZhbHVlcy5sZW5ndGg7XHJcblx0XHR2YXIgcmVzdWx0ID0gbmV3IHZhbHVlcy5jb25zdHJ1Y3RvciggblZhbHVlcyApO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgZHN0T2Zmc2V0ID0gMDsgZHN0T2Zmc2V0ICE9PSBuVmFsdWVzOyArKyBpICkge1xyXG5cclxuXHRcdFx0dmFyIHNyY09mZnNldCA9IG9yZGVyWyBpIF0gKiBzdHJpZGU7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogIT09IHN0cmlkZTsgKysgaiApIHtcclxuXHJcblx0XHRcdFx0cmVzdWx0WyBkc3RPZmZzZXQgKysgXSA9IHZhbHVlc1sgc3JjT2Zmc2V0ICsgaiBdO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cclxuXHR9LFxyXG5cclxuXHQvLyBmdW5jdGlvbiBmb3IgcGFyc2luZyBBT1Mga2V5ZnJhbWUgZm9ybWF0c1xyXG5cdGZsYXR0ZW5KU09OOiBmdW5jdGlvbigganNvbktleXMsIHRpbWVzLCB2YWx1ZXMsIHZhbHVlUHJvcGVydHlOYW1lICkge1xyXG5cclxuXHRcdHZhciBpID0gMSwga2V5ID0ganNvbktleXNbIDAgXTtcclxuXHJcblx0XHR3aGlsZSAoIGtleSAhPT0gdW5kZWZpbmVkICYmIGtleVsgdmFsdWVQcm9wZXJ0eU5hbWUgXSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0a2V5ID0ganNvbktleXNbIGkgKysgXTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCApIHJldHVybjsgLy8gbm8gZGF0YVxyXG5cclxuXHRcdHZhciB2YWx1ZSA9IGtleVsgdmFsdWVQcm9wZXJ0eU5hbWUgXTtcclxuXHRcdGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCApIHJldHVybjsgLy8gbm8gZGF0YVxyXG5cclxuXHRcdGlmICggQXJyYXkuaXNBcnJheSggdmFsdWUgKSApIHtcclxuXHJcblx0XHRcdGRvIHtcclxuXHJcblx0XHRcdFx0dmFsdWUgPSBrZXlbIHZhbHVlUHJvcGVydHlOYW1lIF07XHJcblxyXG5cdFx0XHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHR0aW1lcy5wdXNoKCBrZXkudGltZSApO1xyXG5cdFx0XHRcdFx0dmFsdWVzLnB1c2guYXBwbHkoIHZhbHVlcywgdmFsdWUgKTsgLy8gcHVzaCBhbGwgZWxlbWVudHNcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRrZXkgPSBqc29uS2V5c1sgaSArKyBdO1xyXG5cclxuXHRcdFx0fSB3aGlsZSAoIGtleSAhPT0gdW5kZWZpbmVkICk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggdmFsdWUudG9BcnJheSAhPT0gdW5kZWZpbmVkICkge1xyXG5cdFx0XHQvLyAuLi5hc3N1bWUgVEhSRUUuTWF0aC1pc2hcclxuXHJcblx0XHRcdGRvIHtcclxuXHJcblx0XHRcdFx0dmFsdWUgPSBrZXlbIHZhbHVlUHJvcGVydHlOYW1lIF07XHJcblxyXG5cdFx0XHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHR0aW1lcy5wdXNoKCBrZXkudGltZSApO1xyXG5cdFx0XHRcdFx0dmFsdWUudG9BcnJheSggdmFsdWVzLCB2YWx1ZXMubGVuZ3RoICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0a2V5ID0ganNvbktleXNbIGkgKysgXTtcclxuXHJcblx0XHRcdH0gd2hpbGUgKCBrZXkgIT09IHVuZGVmaW5lZCApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8vIG90aGVyd2lzZSBwdXNoIGFzLWlzXHJcblxyXG5cdFx0XHRkbyB7XHJcblxyXG5cdFx0XHRcdHZhbHVlID0ga2V5WyB2YWx1ZVByb3BlcnR5TmFtZSBdO1xyXG5cclxuXHRcdFx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0dGltZXMucHVzaCgga2V5LnRpbWUgKTtcclxuXHRcdFx0XHRcdHZhbHVlcy5wdXNoKCB2YWx1ZSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGtleSA9IGpzb25LZXlzWyBpICsrIF07XHJcblxyXG5cdFx0XHR9IHdoaWxlICgga2V5ICE9PSB1bmRlZmluZWQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9hbmltYXRpb24vS2V5ZnJhbWVUcmFjay5qc1xyXG5cclxuLyoqXHJcbiAqXHJcbiAqIEEgdGltZWQgc2VxdWVuY2Ugb2Yga2V5ZnJhbWVzIGZvciBhIHNwZWNpZmljIHByb3BlcnR5LlxyXG4gKlxyXG4gKlxyXG4gKiBAYXV0aG9yIEJlbiBIb3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvL1xyXG4gKiBAYXV0aG9yIERhdmlkIFNhcm5vIC8gaHR0cDovL2xpZ2h0aGF1cy51cy9cclxuICogQGF1dGhvciB0c2Nod1xyXG4gKi9cclxuXHJcblRIUkVFLktleWZyYW1lVHJhY2sgPSBmdW5jdGlvbiAoIG5hbWUsIHRpbWVzLCB2YWx1ZXMsIGludGVycG9sYXRpb24gKSB7XHJcblxyXG5cdGlmKCBuYW1lID09PSB1bmRlZmluZWQgKSB0aHJvdyBuZXcgRXJyb3IoIFwidHJhY2sgbmFtZSBpcyB1bmRlZmluZWRcIiApO1xyXG5cclxuXHRpZiggdGltZXMgPT09IHVuZGVmaW5lZCB8fCB0aW1lcy5sZW5ndGggPT09IDAgKSB7XHJcblxyXG5cdFx0dGhyb3cgbmV3IEVycm9yKCBcIm5vIGtleWZyYW1lcyBpbiB0cmFjayBuYW1lZCBcIiArIG5hbWUgKTtcclxuXHJcblx0fVxyXG5cclxuXHR0aGlzLm5hbWUgPSBuYW1lO1xyXG5cclxuXHR0aGlzLnRpbWVzID0gVEhSRUUuQW5pbWF0aW9uVXRpbHMuY29udmVydEFycmF5KCB0aW1lcywgdGhpcy5UaW1lQnVmZmVyVHlwZSApO1xyXG5cdHRoaXMudmFsdWVzID0gVEhSRUUuQW5pbWF0aW9uVXRpbHMuY29udmVydEFycmF5KCB2YWx1ZXMsIHRoaXMuVmFsdWVCdWZmZXJUeXBlICk7XHJcblxyXG5cdHRoaXMuc2V0SW50ZXJwb2xhdGlvbiggaW50ZXJwb2xhdGlvbiB8fCB0aGlzLkRlZmF1bHRJbnRlcnBvbGF0aW9uICk7XHJcblxyXG5cdHRoaXMudmFsaWRhdGUoKTtcclxuXHR0aGlzLm9wdGltaXplKCk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5LZXlmcmFtZVRyYWNrLFxyXG5cclxuXHRUaW1lQnVmZmVyVHlwZTogRmxvYXQzMkFycmF5LFxyXG5cdFZhbHVlQnVmZmVyVHlwZTogRmxvYXQzMkFycmF5LFxyXG5cclxuXHREZWZhdWx0SW50ZXJwb2xhdGlvbjogVEhSRUUuSW50ZXJwb2xhdGVMaW5lYXIsXHJcblxyXG5cdEludGVycG9sYW50RmFjdG9yeU1ldGhvZERpc2NyZXRlOiBmdW5jdGlvbiggcmVzdWx0ICkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgVEhSRUUuRGlzY3JldGVJbnRlcnBvbGFudChcclxuXHRcdFx0XHR0aGlzLnRpbWVzLCB0aGlzLnZhbHVlcywgdGhpcy5nZXRWYWx1ZVNpemUoKSwgcmVzdWx0ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdEludGVycG9sYW50RmFjdG9yeU1ldGhvZExpbmVhcjogZnVuY3Rpb24oIHJlc3VsdCApIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IFRIUkVFLkxpbmVhckludGVycG9sYW50KFxyXG5cdFx0XHRcdHRoaXMudGltZXMsIHRoaXMudmFsdWVzLCB0aGlzLmdldFZhbHVlU2l6ZSgpLCByZXN1bHQgKTtcclxuXHJcblx0fSxcclxuXHJcblx0SW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kU21vb3RoOiBmdW5jdGlvbiggcmVzdWx0ICkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgVEhSRUUuQ3ViaWNJbnRlcnBvbGFudChcclxuXHRcdFx0XHR0aGlzLnRpbWVzLCB0aGlzLnZhbHVlcywgdGhpcy5nZXRWYWx1ZVNpemUoKSwgcmVzdWx0ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldEludGVycG9sYXRpb246IGZ1bmN0aW9uKCBpbnRlcnBvbGF0aW9uICkge1xyXG5cclxuXHRcdHZhciBmYWN0b3J5TWV0aG9kID0gdW5kZWZpbmVkO1xyXG5cclxuXHRcdHN3aXRjaCAoIGludGVycG9sYXRpb24gKSB7XHJcblxyXG5cdFx0XHRjYXNlIFRIUkVFLkludGVycG9sYXRlRGlzY3JldGU6XHJcblxyXG5cdFx0XHRcdGZhY3RvcnlNZXRob2QgPSB0aGlzLkludGVycG9sYW50RmFjdG9yeU1ldGhvZERpc2NyZXRlO1xyXG5cclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGNhc2UgVEhSRUUuSW50ZXJwb2xhdGVMaW5lYXI6XHJcblxyXG5cdFx0XHRcdGZhY3RvcnlNZXRob2QgPSB0aGlzLkludGVycG9sYW50RmFjdG9yeU1ldGhvZExpbmVhcjtcclxuXHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRjYXNlIFRIUkVFLkludGVycG9sYXRlU21vb3RoOlxyXG5cclxuXHRcdFx0XHRmYWN0b3J5TWV0aG9kID0gdGhpcy5JbnRlcnBvbGFudEZhY3RvcnlNZXRob2RTbW9vdGg7XHJcblxyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGZhY3RvcnlNZXRob2QgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHZhciBtZXNzYWdlID0gXCJ1bnN1cHBvcnRlZCBpbnRlcnBvbGF0aW9uIGZvciBcIiArXHJcblx0XHRcdFx0XHR0aGlzLlZhbHVlVHlwZU5hbWUgKyBcIiBrZXlmcmFtZSB0cmFjayBuYW1lZCBcIiArIHRoaXMubmFtZTtcclxuXHJcblx0XHRcdGlmICggdGhpcy5jcmVhdGVJbnRlcnBvbGFudCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHQvLyBmYWxsIGJhY2sgdG8gZGVmYXVsdCwgdW5sZXNzIHRoZSBkZWZhdWx0IGl0c2VsZiBpcyBtZXNzZWQgdXBcclxuXHRcdFx0XHRpZiAoIGludGVycG9sYXRpb24gIT09IHRoaXMuRGVmYXVsdEludGVycG9sYXRpb24gKSB7XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5zZXRJbnRlcnBvbGF0aW9uKCB0aGlzLkRlZmF1bHRJbnRlcnBvbGF0aW9uICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBtZXNzYWdlICk7IC8vIGZhdGFsLCBpbiB0aGlzIGNhc2VcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCBtZXNzYWdlICk7XHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5jcmVhdGVJbnRlcnBvbGFudCA9IGZhY3RvcnlNZXRob2Q7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldEludGVycG9sYXRpb246IGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdHN3aXRjaCAoIHRoaXMuY3JlYXRlSW50ZXJwb2xhbnQgKSB7XHJcblxyXG5cdFx0XHRjYXNlIHRoaXMuSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kRGlzY3JldGU6XHJcblxyXG5cdFx0XHRcdHJldHVybiBUSFJFRS5JbnRlcnBvbGF0ZURpc2NyZXRlO1xyXG5cclxuXHRcdFx0Y2FzZSB0aGlzLkludGVycG9sYW50RmFjdG9yeU1ldGhvZExpbmVhcjpcclxuXHJcblx0XHRcdFx0cmV0dXJuIFRIUkVFLkludGVycG9sYXRlTGluZWFyO1xyXG5cclxuXHRcdFx0Y2FzZSB0aGlzLkludGVycG9sYW50RmFjdG9yeU1ldGhvZFNtb290aDpcclxuXHJcblx0XHRcdFx0cmV0dXJuIFRIUkVFLkludGVycG9sYXRlU21vb3RoO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0Z2V0VmFsdWVTaXplOiBmdW5jdGlvbigpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy52YWx1ZXMubGVuZ3RoIC8gdGhpcy50aW1lcy5sZW5ndGg7XHJcblxyXG5cdH0sXHJcblxyXG5cdC8vIG1vdmUgYWxsIGtleWZyYW1lcyBlaXRoZXIgZm9yd2FyZHMgb3IgYmFja3dhcmRzIGluIHRpbWVcclxuXHRzaGlmdDogZnVuY3Rpb24oIHRpbWVPZmZzZXQgKSB7XHJcblxyXG5cdFx0aWYoIHRpbWVPZmZzZXQgIT09IDAuMCApIHtcclxuXHJcblx0XHRcdHZhciB0aW1lcyA9IHRoaXMudGltZXM7XHJcblxyXG5cdFx0XHRmb3IoIHZhciBpID0gMCwgbiA9IHRpbWVzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcclxuXHJcblx0XHRcdFx0dGltZXNbIGkgXSArPSB0aW1lT2Zmc2V0O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Ly8gc2NhbGUgYWxsIGtleWZyYW1lIHRpbWVzIGJ5IGEgZmFjdG9yICh1c2VmdWwgZm9yIGZyYW1lIDwtPiBzZWNvbmRzIGNvbnZlcnNpb25zKVxyXG5cdHNjYWxlOiBmdW5jdGlvbiggdGltZVNjYWxlICkge1xyXG5cclxuXHRcdGlmKCB0aW1lU2NhbGUgIT09IDEuMCApIHtcclxuXHJcblx0XHRcdHZhciB0aW1lcyA9IHRoaXMudGltZXM7XHJcblxyXG5cdFx0XHRmb3IoIHZhciBpID0gMCwgbiA9IHRpbWVzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcclxuXHJcblx0XHRcdFx0dGltZXNbIGkgXSAqPSB0aW1lU2NhbGU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHQvLyByZW1vdmVzIGtleWZyYW1lcyBiZWZvcmUgYW5kIGFmdGVyIGFuaW1hdGlvbiB3aXRob3V0IGNoYW5naW5nIGFueSB2YWx1ZXMgd2l0aGluIHRoZSByYW5nZSBbc3RhcnRUaW1lLCBlbmRUaW1lXS5cclxuXHQvLyBJTVBPUlRBTlQ6IFdlIGRvIG5vdCBzaGlmdCBhcm91bmQga2V5cyB0byB0aGUgc3RhcnQgb2YgdGhlIHRyYWNrIHRpbWUsIGJlY2F1c2UgZm9yIGludGVycG9sYXRlZCBrZXlzIHRoaXMgd2lsbCBjaGFuZ2UgdGhlaXIgdmFsdWVzXHJcblx0dHJpbTogZnVuY3Rpb24oIHN0YXJ0VGltZSwgZW5kVGltZSApIHtcclxuXHJcblx0XHR2YXIgdGltZXMgPSB0aGlzLnRpbWVzLFxyXG5cdFx0XHRuS2V5cyA9IHRpbWVzLmxlbmd0aCxcclxuXHRcdFx0ZnJvbSA9IDAsXHJcblx0XHRcdHRvID0gbktleXMgLSAxO1xyXG5cclxuXHRcdHdoaWxlICggZnJvbSAhPT0gbktleXMgJiYgdGltZXNbIGZyb20gXSA8IHN0YXJ0VGltZSApICsrIGZyb207XHJcblx0XHR3aGlsZSAoIHRvICE9PSAtMSAmJiB0aW1lc1sgdG8gXSA+IGVuZFRpbWUgKSAtLSB0bztcclxuXHJcblx0XHQrKyB0bzsgLy8gaW5jbHVzaXZlIC0+IGV4Y2x1c2l2ZSBib3VuZFxyXG5cclxuXHRcdGlmKCBmcm9tICE9PSAwIHx8IHRvICE9PSBuS2V5cyApIHtcclxuXHJcblx0XHRcdC8vIGVtcHR5IHRyYWNrcyBhcmUgZm9yYmlkZGVuLCBzbyBrZWVwIGF0IGxlYXN0IG9uZSBrZXlmcmFtZVxyXG5cdFx0XHRpZiAoIGZyb20gPj0gdG8gKSB0byA9IE1hdGgubWF4KCB0byAsIDEgKSwgZnJvbSA9IHRvIC0gMTtcclxuXHJcblx0XHRcdHZhciBzdHJpZGUgPSB0aGlzLmdldFZhbHVlU2l6ZSgpO1xyXG5cdFx0XHR0aGlzLnRpbWVzID0gVEhSRUUuQW5pbWF0aW9uVXRpbHMuYXJyYXlTbGljZSggdGltZXMsIGZyb20sIHRvICk7XHJcblx0XHRcdHRoaXMudmFsdWVzID0gVEhSRUUuQW5pbWF0aW9uVXRpbHMuXHJcblx0XHRcdFx0XHRhcnJheVNsaWNlKCB0aGlzLnZhbHVlcywgZnJvbSAqIHN0cmlkZSwgdG8gKiBzdHJpZGUgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdC8vIGVuc3VyZSB3ZSBkbyBub3QgZ2V0IGEgR2FyYmFnZUluR2FyYmFnZU91dCBzaXR1YXRpb24sIG1ha2Ugc3VyZSB0cmFja3MgYXJlIGF0IGxlYXN0IG1pbmltYWxseSB2aWFibGVcclxuXHR2YWxpZGF0ZTogZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0dmFyIHZhbGlkID0gdHJ1ZTtcclxuXHJcblx0XHR2YXIgdmFsdWVTaXplID0gdGhpcy5nZXRWYWx1ZVNpemUoKTtcclxuXHRcdGlmICggdmFsdWVTaXplIC0gTWF0aC5mbG9vciggdmFsdWVTaXplICkgIT09IDAgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLmVycm9yKCBcImludmFsaWQgdmFsdWUgc2l6ZSBpbiB0cmFja1wiLCB0aGlzICk7XHJcblx0XHRcdHZhbGlkID0gZmFsc2U7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciB0aW1lcyA9IHRoaXMudGltZXMsXHJcblx0XHRcdHZhbHVlcyA9IHRoaXMudmFsdWVzLFxyXG5cclxuXHRcdFx0bktleXMgPSB0aW1lcy5sZW5ndGg7XHJcblxyXG5cdFx0aWYoIG5LZXlzID09PSAwICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS5lcnJvciggXCJ0cmFjayBpcyBlbXB0eVwiLCB0aGlzICk7XHJcblx0XHRcdHZhbGlkID0gZmFsc2U7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBwcmV2VGltZSA9IG51bGw7XHJcblxyXG5cdFx0Zm9yKCB2YXIgaSA9IDA7IGkgIT09IG5LZXlzOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIGN1cnJUaW1lID0gdGltZXNbIGkgXTtcclxuXHJcblx0XHRcdGlmICggdHlwZW9mIGN1cnJUaW1lID09PSAnbnVtYmVyJyAmJiBpc05hTiggY3VyclRpbWUgKSApIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS5lcnJvciggXCJ0aW1lIGlzIG5vdCBhIHZhbGlkIG51bWJlclwiLCB0aGlzLCBpLCBjdXJyVGltZSApO1xyXG5cdFx0XHRcdHZhbGlkID0gZmFsc2U7XHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiggcHJldlRpbWUgIT09IG51bGwgJiYgcHJldlRpbWUgPiBjdXJyVGltZSApIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS5lcnJvciggXCJvdXQgb2Ygb3JkZXIga2V5c1wiLCB0aGlzLCBpLCBjdXJyVGltZSwgcHJldlRpbWUgKTtcclxuXHRcdFx0XHR2YWxpZCA9IGZhbHNlO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cHJldlRpbWUgPSBjdXJyVGltZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB2YWx1ZXMgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGlmICggVEhSRUUuQW5pbWF0aW9uVXRpbHMuaXNUeXBlZEFycmF5KCB2YWx1ZXMgKSApIHtcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBuID0gdmFsdWVzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgdmFsdWUgPSB2YWx1ZXNbIGkgXTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGlzTmFOKCB2YWx1ZSApICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvciggXCJ2YWx1ZSBpcyBub3QgYSB2YWxpZCBudW1iZXJcIiwgdGhpcywgaSwgdmFsdWUgKTtcclxuXHRcdFx0XHRcdFx0dmFsaWQgPSBmYWxzZTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB2YWxpZDtcclxuXHJcblx0fSxcclxuXHJcblx0Ly8gcmVtb3ZlcyBlcXVpdmFsZW50IHNlcXVlbnRpYWwga2V5cyBhcyBjb21tb24gaW4gbW9ycGggdGFyZ2V0IHNlcXVlbmNlc1xyXG5cdC8vICgwLDAsMCwwLDEsMSwxLDAsMCwwLDAsMCwwLDApIC0tPiAoMCwwLDEsMSwwLDApXHJcblx0b3B0aW1pemU6IGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdHZhciB0aW1lcyA9IHRoaXMudGltZXMsXHJcblx0XHRcdHZhbHVlcyA9IHRoaXMudmFsdWVzLFxyXG5cdFx0XHRzdHJpZGUgPSB0aGlzLmdldFZhbHVlU2l6ZSgpLFxyXG5cclxuXHRcdFx0d3JpdGVJbmRleCA9IDE7XHJcblxyXG5cdFx0Zm9yKCB2YXIgaSA9IDEsIG4gPSB0aW1lcy5sZW5ndGggLSAxOyBpIDw9IG47ICsrIGkgKSB7XHJcblxyXG5cdFx0XHR2YXIga2VlcCA9IGZhbHNlO1xyXG5cclxuXHRcdFx0dmFyIHRpbWUgPSB0aW1lc1sgaSBdO1xyXG5cdFx0XHR2YXIgdGltZU5leHQgPSB0aW1lc1sgaSArIDEgXTtcclxuXHJcblx0XHRcdC8vIHJlbW92ZSBhZGphY2VudCBrZXlmcmFtZXMgc2NoZWR1bGVkIGF0IHRoZSBzYW1lIHRpbWVcclxuXHJcblx0XHRcdGlmICggdGltZSAhPT0gdGltZU5leHQgJiYgKCBpICE9PSAxIHx8IHRpbWUgIT09IHRpbWVbIDAgXSApICkge1xyXG5cclxuXHRcdFx0XHQvLyByZW1vdmUgdW5uZWNlc3Nhcnkga2V5ZnJhbWVzIHNhbWUgYXMgdGhlaXIgbmVpZ2hib3JzXHJcblx0XHRcdFx0dmFyIG9mZnNldCA9IGkgKiBzdHJpZGUsXHJcblx0XHRcdFx0XHRvZmZzZXRQID0gb2Zmc2V0IC0gc3RyaWRlLFxyXG5cdFx0XHRcdFx0b2Zmc2V0TiA9IG9mZnNldCArIHN0cmlkZTtcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGogPSAwOyBqICE9PSBzdHJpZGU7ICsrIGogKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIHZhbHVlID0gdmFsdWVzWyBvZmZzZXQgKyBqIF07XHJcblxyXG5cdFx0XHRcdFx0aWYgKCB2YWx1ZSAhPT0gdmFsdWVzWyBvZmZzZXRQICsgaiBdIHx8XHJcblx0XHRcdFx0XHRcdFx0dmFsdWUgIT09IHZhbHVlc1sgb2Zmc2V0TiArIGogXSApIHtcclxuXHJcblx0XHRcdFx0XHRcdGtlZXAgPSB0cnVlO1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIGluLXBsYWNlIGNvbXBhY3Rpb25cclxuXHJcblx0XHRcdGlmICgga2VlcCApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBpICE9PSB3cml0ZUluZGV4ICkge1xyXG5cclxuXHRcdFx0XHRcdHRpbWVzWyB3cml0ZUluZGV4IF0gPSB0aW1lc1sgaSBdO1xyXG5cclxuXHRcdFx0XHRcdHZhciByZWFkT2Zmc2V0ID0gaSAqIHN0cmlkZSxcclxuXHRcdFx0XHRcdFx0d3JpdGVPZmZzZXQgPSB3cml0ZUluZGV4ICogc3RyaWRlO1xyXG5cclxuXHRcdFx0XHRcdGZvciAoIHZhciBqID0gMDsgaiAhPT0gc3RyaWRlOyArKyBqICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dmFsdWVzWyB3cml0ZU9mZnNldCArIGogXSA9IHZhbHVlc1sgcmVhZE9mZnNldCArIGogXTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdCsrIHdyaXRlSW5kZXg7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggd3JpdGVJbmRleCAhPT0gdGltZXMubGVuZ3RoICkge1xyXG5cclxuXHRcdFx0dGhpcy50aW1lcyA9IFRIUkVFLkFuaW1hdGlvblV0aWxzLmFycmF5U2xpY2UoIHRpbWVzLCAwLCB3cml0ZUluZGV4ICk7XHJcblx0XHRcdHRoaXMudmFsdWVzID0gVEhSRUUuQW5pbWF0aW9uVXRpbHMuYXJyYXlTbGljZSggdmFsdWVzLCAwLCB3cml0ZUluZGV4ICogc3RyaWRlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuLy8gU3RhdGljIG1ldGhvZHM6XHJcblxyXG5PYmplY3QuYXNzaWduKCBUSFJFRS5LZXlmcmFtZVRyYWNrLCB7XHJcblxyXG5cdC8vIFNlcmlhbGl6YXRpb24gKGluIHN0YXRpYyBjb250ZXh0LCBiZWNhdXNlIG9mIGNvbnN0cnVjdG9yIGludm9jYXRpb25cclxuXHQvLyBhbmQgYXV0b21hdGljIGludm9jYXRpb24gb2YgLnRvSlNPTik6XHJcblxyXG5cdHBhcnNlOiBmdW5jdGlvbigganNvbiApIHtcclxuXHJcblx0XHRpZigganNvbi50eXBlID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoIFwidHJhY2sgdHlwZSB1bmRlZmluZWQsIGNhbiBub3QgcGFyc2VcIiApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgdHJhY2tUeXBlID0gVEhSRUUuS2V5ZnJhbWVUcmFjay5fZ2V0VHJhY2tUeXBlRm9yVmFsdWVUeXBlTmFtZSgganNvbi50eXBlICk7XHJcblxyXG5cdFx0aWYgKCBqc29uLnRpbWVzID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oIFwibGVnYWN5IEpTT04gZm9ybWF0IGRldGVjdGVkLCBjb252ZXJ0aW5nXCIgKTtcclxuXHJcblx0XHRcdHZhciB0aW1lcyA9IFtdLCB2YWx1ZXMgPSBbXTtcclxuXHJcblx0XHRcdFRIUkVFLkFuaW1hdGlvblV0aWxzLmZsYXR0ZW5KU09OKCBqc29uLmtleXMsIHRpbWVzLCB2YWx1ZXMsICd2YWx1ZScgKTtcclxuXHJcblx0XHRcdGpzb24udGltZXMgPSB0aW1lcztcclxuXHRcdFx0anNvbi52YWx1ZXMgPSB2YWx1ZXM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGRlcml2ZWQgY2xhc3NlcyBjYW4gZGVmaW5lIGEgc3RhdGljIHBhcnNlIG1ldGhvZFxyXG5cdFx0aWYgKCB0cmFja1R5cGUucGFyc2UgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHJldHVybiB0cmFja1R5cGUucGFyc2UoIGpzb24gKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0Ly8gYnkgZGVmYXVsdCwgd2UgYXNzc3VtZSBhIGNvbnN0cnVjdG9yIGNvbXBhdGlibGUgd2l0aCB0aGUgYmFzZVxyXG5cdFx0XHRyZXR1cm4gbmV3IHRyYWNrVHlwZShcclxuXHRcdFx0XHRcdGpzb24ubmFtZSwganNvbi50aW1lcywganNvbi52YWx1ZXMsIGpzb24uaW50ZXJwb2xhdGlvbiApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0dG9KU09OOiBmdW5jdGlvbiggdHJhY2sgKSB7XHJcblxyXG5cdFx0dmFyIHRyYWNrVHlwZSA9IHRyYWNrLmNvbnN0cnVjdG9yO1xyXG5cclxuXHRcdHZhciBqc29uO1xyXG5cclxuXHRcdC8vIGRlcml2ZWQgY2xhc3NlcyBjYW4gZGVmaW5lIGEgc3RhdGljIHRvSlNPTiBtZXRob2RcclxuXHRcdGlmICggdHJhY2tUeXBlLnRvSlNPTiAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0anNvbiA9IHRyYWNrVHlwZS50b0pTT04oIHRyYWNrICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdC8vIGJ5IGRlZmF1bHQsIHdlIGFzc3VtZSB0aGUgZGF0YSBjYW4gYmUgc2VyaWFsaXplZCBhcy1pc1xyXG5cdFx0XHRqc29uID0ge1xyXG5cclxuXHRcdFx0XHQnbmFtZSc6IHRyYWNrLm5hbWUsXHJcblx0XHRcdFx0J3RpbWVzJzogVEhSRUUuQW5pbWF0aW9uVXRpbHMuY29udmVydEFycmF5KCB0cmFjay50aW1lcywgQXJyYXkgKSxcclxuXHRcdFx0XHQndmFsdWVzJzogVEhSRUUuQW5pbWF0aW9uVXRpbHMuY29udmVydEFycmF5KCB0cmFjay52YWx1ZXMsIEFycmF5IClcclxuXHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHR2YXIgaW50ZXJwb2xhdGlvbiA9IHRyYWNrLmdldEludGVycG9sYXRpb24oKTtcclxuXHJcblx0XHRcdGlmICggaW50ZXJwb2xhdGlvbiAhPT0gdHJhY2suRGVmYXVsdEludGVycG9sYXRpb24gKSB7XHJcblxyXG5cdFx0XHRcdGpzb24uaW50ZXJwb2xhdGlvbiA9IGludGVycG9sYXRpb247XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGpzb24udHlwZSA9IHRyYWNrLlZhbHVlVHlwZU5hbWU7IC8vIG1hbmRhdG9yeVxyXG5cclxuXHRcdHJldHVybiBqc29uO1xyXG5cclxuXHR9LFxyXG5cclxuXHRfZ2V0VHJhY2tUeXBlRm9yVmFsdWVUeXBlTmFtZTogZnVuY3Rpb24oIHR5cGVOYW1lICkge1xyXG5cclxuXHRcdHN3aXRjaCggdHlwZU5hbWUudG9Mb3dlckNhc2UoKSApIHtcclxuXHJcblx0XHRcdGNhc2UgXCJzY2FsYXJcIjpcclxuXHRcdFx0Y2FzZSBcImRvdWJsZVwiOlxyXG5cdFx0XHRjYXNlIFwiZmxvYXRcIjpcclxuXHRcdFx0Y2FzZSBcIm51bWJlclwiOlxyXG5cdFx0XHRjYXNlIFwiaW50ZWdlclwiOlxyXG5cclxuXHRcdFx0XHRyZXR1cm4gVEhSRUUuTnVtYmVyS2V5ZnJhbWVUcmFjaztcclxuXHJcblx0XHRcdGNhc2UgXCJ2ZWN0b3JcIjpcclxuXHRcdFx0Y2FzZSBcInZlY3RvcjJcIjpcclxuXHRcdFx0Y2FzZSBcInZlY3RvcjNcIjpcclxuXHRcdFx0Y2FzZSBcInZlY3RvcjRcIjpcclxuXHJcblx0XHRcdFx0cmV0dXJuIFRIUkVFLlZlY3RvcktleWZyYW1lVHJhY2s7XHJcblxyXG5cdFx0XHRjYXNlIFwiY29sb3JcIjpcclxuXHJcblx0XHRcdFx0cmV0dXJuIFRIUkVFLkNvbG9yS2V5ZnJhbWVUcmFjaztcclxuXHJcblx0XHRcdGNhc2UgXCJxdWF0ZXJuaW9uXCI6XHJcblxyXG5cdFx0XHRcdHJldHVybiBUSFJFRS5RdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjaztcclxuXHJcblx0XHRcdGNhc2UgXCJib29sXCI6XHJcblx0XHRcdGNhc2UgXCJib29sZWFuXCI6XHJcblxyXG5cdFx0XHRcdHJldHVybiBUSFJFRS5Cb29sZWFuS2V5ZnJhbWVUcmFjaztcclxuXHJcblx0XHRcdGNhc2UgXCJzdHJpbmdcIjpcclxuXHJcblx0XHRcdFx0cmV0dXJuIFRIUkVFLlN0cmluZ0tleWZyYW1lVHJhY2s7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoIFwiVW5zdXBwb3J0ZWQgdHlwZU5hbWU6IFwiICsgdHlwZU5hbWUgKTtcclxuXHJcblx0fVxyXG5cclxufSApO1xyXG5cclxuLy8gRmlsZTpzcmMvYW5pbWF0aW9uL1Byb3BlcnR5QmluZGluZy5qc1xyXG5cclxuLyoqXHJcbiAqXHJcbiAqIEEgcmVmZXJlbmNlIHRvIGEgcmVhbCBwcm9wZXJ0eSBpbiB0aGUgc2NlbmUgZ3JhcGguXHJcbiAqXHJcbiAqXHJcbiAqIEBhdXRob3IgQmVuIEhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW8vXHJcbiAqIEBhdXRob3IgRGF2aWQgU2Fybm8gLyBodHRwOi8vbGlnaHRoYXVzLnVzL1xyXG4gKiBAYXV0aG9yIHRzY2h3XHJcbiAqL1xyXG5cclxuVEhSRUUuUHJvcGVydHlCaW5kaW5nID0gZnVuY3Rpb24gKCByb290Tm9kZSwgcGF0aCwgcGFyc2VkUGF0aCApIHtcclxuXHJcblx0dGhpcy5wYXRoID0gcGF0aDtcclxuXHR0aGlzLnBhcnNlZFBhdGggPSBwYXJzZWRQYXRoIHx8XHJcblx0XHRcdFRIUkVFLlByb3BlcnR5QmluZGluZy5wYXJzZVRyYWNrTmFtZSggcGF0aCApO1xyXG5cclxuXHR0aGlzLm5vZGUgPSBUSFJFRS5Qcm9wZXJ0eUJpbmRpbmcuZmluZE5vZGUoXHJcblx0XHRcdHJvb3ROb2RlLCB0aGlzLnBhcnNlZFBhdGgubm9kZU5hbWUgKSB8fCByb290Tm9kZTtcclxuXHJcblx0dGhpcy5yb290Tm9kZSA9IHJvb3ROb2RlO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlByb3BlcnR5QmluZGluZy5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5Qcm9wZXJ0eUJpbmRpbmcsXHJcblxyXG5cdGdldFZhbHVlOiBmdW5jdGlvbiBnZXRWYWx1ZV91bmJvdW5kKCB0YXJnZXRBcnJheSwgb2Zmc2V0ICkge1xyXG5cclxuXHRcdHRoaXMuYmluZCgpO1xyXG5cdFx0dGhpcy5nZXRWYWx1ZSggdGFyZ2V0QXJyYXksIG9mZnNldCApO1xyXG5cclxuXHRcdC8vIE5vdGU6IFRoaXMgY2xhc3MgdXNlcyBhIFN0YXRlIHBhdHRlcm4gb24gYSBwZXItbWV0aG9kIGJhc2lzOlxyXG5cdFx0Ly8gJ2JpbmQnIHNldHMgJ3RoaXMuZ2V0VmFsdWUnIC8gJ3NldFZhbHVlJyBhbmQgc2hhZG93cyB0aGVcclxuXHRcdC8vIHByb3RvdHlwZSB2ZXJzaW9uIG9mIHRoZXNlIG1ldGhvZHMgd2l0aCBvbmUgdGhhdCByZXByZXNlbnRzXHJcblx0XHQvLyB0aGUgYm91bmQgc3RhdGUuIFdoZW4gdGhlIHByb3BlcnR5IGlzIG5vdCBmb3VuZCwgdGhlIG1ldGhvZHNcclxuXHRcdC8vIGJlY29tZSBuby1vcHMuXHJcblxyXG5cdH0sXHJcblxyXG5cdHNldFZhbHVlOiBmdW5jdGlvbiBnZXRWYWx1ZV91bmJvdW5kKCBzb3VyY2VBcnJheSwgb2Zmc2V0ICkge1xyXG5cclxuXHRcdHRoaXMuYmluZCgpO1xyXG5cdFx0dGhpcy5zZXRWYWx1ZSggc291cmNlQXJyYXksIG9mZnNldCApO1xyXG5cclxuXHR9LFxyXG5cclxuXHQvLyBjcmVhdGUgZ2V0dGVyIC8gc2V0dGVyIHBhaXIgZm9yIGEgcHJvcGVydHkgaW4gdGhlIHNjZW5lIGdyYXBoXHJcblx0YmluZDogZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0dmFyIHRhcmdldE9iamVjdCA9IHRoaXMubm9kZSxcclxuXHRcdFx0cGFyc2VkUGF0aCA9IHRoaXMucGFyc2VkUGF0aCxcclxuXHJcblx0XHRcdG9iamVjdE5hbWUgPSBwYXJzZWRQYXRoLm9iamVjdE5hbWUsXHJcblx0XHRcdHByb3BlcnR5TmFtZSA9IHBhcnNlZFBhdGgucHJvcGVydHlOYW1lLFxyXG5cdFx0XHRwcm9wZXJ0eUluZGV4ID0gcGFyc2VkUGF0aC5wcm9wZXJ0eUluZGV4O1xyXG5cclxuXHRcdGlmICggISB0YXJnZXRPYmplY3QgKSB7XHJcblxyXG5cdFx0XHR0YXJnZXRPYmplY3QgPSBUSFJFRS5Qcm9wZXJ0eUJpbmRpbmcuZmluZE5vZGUoXHJcblx0XHRcdFx0XHR0aGlzLnJvb3ROb2RlLCBwYXJzZWRQYXRoLm5vZGVOYW1lICkgfHwgdGhpcy5yb290Tm9kZTtcclxuXHJcblx0XHRcdHRoaXMubm9kZSA9IHRhcmdldE9iamVjdDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gc2V0IGZhaWwgc3RhdGUgc28gd2UgY2FuIGp1c3QgJ3JldHVybicgb24gZXJyb3JcclxuXHRcdHRoaXMuZ2V0VmFsdWUgPSB0aGlzLl9nZXRWYWx1ZV91bmF2YWlsYWJsZTtcclxuXHRcdHRoaXMuc2V0VmFsdWUgPSB0aGlzLl9zZXRWYWx1ZV91bmF2YWlsYWJsZTtcclxuXHJcbiBcdFx0Ly8gZW5zdXJlIHRoZXJlIGlzIGEgdmFsdWUgbm9kZVxyXG5cdFx0aWYgKCAhIHRhcmdldE9iamVjdCApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoIFwiICB0cnlpbmcgdG8gdXBkYXRlIG5vZGUgZm9yIHRyYWNrOiBcIiArIHRoaXMucGF0aCArIFwiIGJ1dCBpdCB3YXNuJ3QgZm91bmQuXCIgKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiggb2JqZWN0TmFtZSApIHtcclxuXHJcblx0XHRcdHZhciBvYmplY3RJbmRleCA9IHBhcnNlZFBhdGgub2JqZWN0SW5kZXg7XHJcblxyXG5cdFx0XHQvLyBzcGVjaWFsIGNhc2VzIHdlcmUgd2UgbmVlZCB0byByZWFjaCBkZWVwZXIgaW50byB0aGUgaGllcmFyY2h5IHRvIGdldCB0aGUgZmFjZSBtYXRlcmlhbHMuLi4uXHJcblx0XHRcdHN3aXRjaCAoIG9iamVjdE5hbWUgKSB7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ21hdGVyaWFscyc6XHJcblxyXG5cdFx0XHRcdFx0aWYoICEgdGFyZ2V0T2JqZWN0Lm1hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJyAgY2FuIG5vdCBiaW5kIHRvIG1hdGVyaWFsIGFzIG5vZGUgZG9lcyBub3QgaGF2ZSBhIG1hdGVyaWFsJywgdGhpcyApO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGlmKCAhIHRhcmdldE9iamVjdC5tYXRlcmlhbC5tYXRlcmlhbHMgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnICBjYW4gbm90IGJpbmQgdG8gbWF0ZXJpYWwubWF0ZXJpYWxzIGFzIG5vZGUubWF0ZXJpYWwgZG9lcyBub3QgaGF2ZSBhIG1hdGVyaWFscyBhcnJheScsIHRoaXMgKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR0YXJnZXRPYmplY3QgPSB0YXJnZXRPYmplY3QubWF0ZXJpYWwubWF0ZXJpYWxzO1xyXG5cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICdib25lcyc6XHJcblxyXG5cdFx0XHRcdFx0aWYoICEgdGFyZ2V0T2JqZWN0LnNrZWxldG9uICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJyAgY2FuIG5vdCBiaW5kIHRvIGJvbmVzIGFzIG5vZGUgZG9lcyBub3QgaGF2ZSBhIHNrZWxldG9uJywgdGhpcyApO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdC8vIHBvdGVudGlhbCBmdXR1cmUgb3B0aW1pemF0aW9uOiBza2lwIHRoaXMgaWYgcHJvcGVydHlJbmRleCBpcyBhbHJlYWR5IGFuIGludGVnZXJcclxuXHRcdFx0XHRcdC8vIGFuZCBjb252ZXJ0IHRoZSBpbnRlZ2VyIHN0cmluZyB0byBhIHRydWUgaW50ZWdlci5cclxuXHJcblx0XHRcdFx0XHR0YXJnZXRPYmplY3QgPSB0YXJnZXRPYmplY3Quc2tlbGV0b24uYm9uZXM7XHJcblxyXG5cdFx0XHRcdFx0Ly8gc3VwcG9ydCByZXNvbHZpbmcgbW9ycGhUYXJnZXQgbmFtZXMgaW50byBpbmRpY2VzLlxyXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGFyZ2V0T2JqZWN0Lmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggdGFyZ2V0T2JqZWN0W2ldLm5hbWUgPT09IG9iamVjdEluZGV4ICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRvYmplY3RJbmRleCA9IGk7XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRkZWZhdWx0OlxyXG5cclxuXHRcdFx0XHRcdGlmICggdGFyZ2V0T2JqZWN0WyBvYmplY3ROYW1lIF0gPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICcgIGNhbiBub3QgYmluZCB0byBvYmplY3ROYW1lIG9mIG5vZGUsIHVuZGVmaW5lZCcsIHRoaXMgKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR0YXJnZXRPYmplY3QgPSB0YXJnZXRPYmplY3RbIG9iamVjdE5hbWUgXTtcclxuXHJcblx0XHRcdH1cclxuXHJcblxyXG5cdFx0XHRpZiAoIG9iamVjdEluZGV4ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGlmKCB0YXJnZXRPYmplY3RbIG9iamVjdEluZGV4IF0gPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCBcIiAgdHJ5aW5nIHRvIGJpbmQgdG8gb2JqZWN0SW5kZXggb2Ygb2JqZWN0TmFtZSwgYnV0IGlzIHVuZGVmaW5lZDpcIiwgdGhpcywgdGFyZ2V0T2JqZWN0ICk7XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGFyZ2V0T2JqZWN0ID0gdGFyZ2V0T2JqZWN0WyBvYmplY3RJbmRleCBdO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyByZXNvbHZlIHByb3BlcnR5XHJcblx0XHR2YXIgbm9kZVByb3BlcnR5ID0gdGFyZ2V0T2JqZWN0WyBwcm9wZXJ0eU5hbWUgXTtcclxuXHJcblx0XHRpZiAoICEgbm9kZVByb3BlcnR5ICkge1xyXG5cclxuXHRcdFx0dmFyIG5vZGVOYW1lID0gcGFyc2VkUGF0aC5ub2RlTmFtZTtcclxuXHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoIFwiICB0cnlpbmcgdG8gdXBkYXRlIHByb3BlcnR5IGZvciB0cmFjazogXCIgKyBub2RlTmFtZSArXHJcblx0XHRcdFx0XHQnLicgKyBwcm9wZXJ0eU5hbWUgKyBcIiBidXQgaXQgd2Fzbid0IGZvdW5kLlwiLCB0YXJnZXRPYmplY3QgKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBkZXRlcm1pbmUgdmVyc2lvbmluZyBzY2hlbWVcclxuXHRcdHZhciB2ZXJzaW9uaW5nID0gdGhpcy5WZXJzaW9uaW5nLk5vbmU7XHJcblxyXG5cdFx0aWYgKCB0YXJnZXRPYmplY3QubmVlZHNVcGRhdGUgIT09IHVuZGVmaW5lZCApIHsgLy8gbWF0ZXJpYWxcclxuXHJcblx0XHRcdHZlcnNpb25pbmcgPSB0aGlzLlZlcnNpb25pbmcuTmVlZHNVcGRhdGU7XHJcblx0XHRcdHRoaXMudGFyZ2V0T2JqZWN0ID0gdGFyZ2V0T2JqZWN0O1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIHRhcmdldE9iamVjdC5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlICE9PSB1bmRlZmluZWQgKSB7IC8vIG5vZGUgdHJhbnNmb3JtXHJcblxyXG5cdFx0XHR2ZXJzaW9uaW5nID0gdGhpcy5WZXJzaW9uaW5nLk1hdHJpeFdvcmxkTmVlZHNVcGRhdGU7XHJcblx0XHRcdHRoaXMudGFyZ2V0T2JqZWN0ID0gdGFyZ2V0T2JqZWN0O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBkZXRlcm1pbmUgaG93IHRoZSBwcm9wZXJ0eSBnZXRzIGJvdW5kXHJcblx0XHR2YXIgYmluZGluZ1R5cGUgPSB0aGlzLkJpbmRpbmdUeXBlLkRpcmVjdDtcclxuXHJcblx0XHRpZiAoIHByb3BlcnR5SW5kZXggIT09IHVuZGVmaW5lZCApIHtcclxuXHRcdFx0Ly8gYWNjZXNzIGEgc3ViIGVsZW1lbnQgb2YgdGhlIHByb3BlcnR5IGFycmF5IChvbmx5IHByaW1pdGl2ZXMgYXJlIHN1cHBvcnRlZCByaWdodCBub3cpXHJcblxyXG5cdFx0XHRpZiAoIHByb3BlcnR5TmFtZSA9PT0gXCJtb3JwaFRhcmdldEluZmx1ZW5jZXNcIiApIHtcclxuXHRcdFx0XHQvLyBwb3RlbnRpYWwgb3B0aW1pemF0aW9uLCBza2lwIHRoaXMgaWYgcHJvcGVydHlJbmRleCBpcyBhbHJlYWR5IGFuIGludGVnZXIsIGFuZCBjb252ZXJ0IHRoZSBpbnRlZ2VyIHN0cmluZyB0byBhIHRydWUgaW50ZWdlci5cclxuXHJcblx0XHRcdFx0Ly8gc3VwcG9ydCByZXNvbHZpbmcgbW9ycGhUYXJnZXQgbmFtZXMgaW50byBpbmRpY2VzLlxyXG5cdFx0XHRcdGlmICggISB0YXJnZXRPYmplY3QuZ2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJyAgY2FuIG5vdCBiaW5kIHRvIG1vcnBoVGFyZ2V0SW5mbHVlbmNlcyBiZWNhc3VzZSBub2RlIGRvZXMgbm90IGhhdmUgYSBnZW9tZXRyeScsIHRoaXMgKTtcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoICEgdGFyZ2V0T2JqZWN0Lmdlb21ldHJ5Lm1vcnBoVGFyZ2V0cyApIHtcclxuXHJcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnICBjYW4gbm90IGJpbmQgdG8gbW9ycGhUYXJnZXRJbmZsdWVuY2VzIGJlY2FzdXNlIG5vZGUgZG9lcyBub3QgaGF2ZSBhIGdlb21ldHJ5Lm1vcnBoVGFyZ2V0cycsIHRoaXMgKTtcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLm5vZGUuZ2VvbWV0cnkubW9ycGhUYXJnZXRzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIHRhcmdldE9iamVjdC5nZW9tZXRyeS5tb3JwaFRhcmdldHNbaV0ubmFtZSA9PT0gcHJvcGVydHlJbmRleCApIHtcclxuXHJcblx0XHRcdFx0XHRcdHByb3BlcnR5SW5kZXggPSBpO1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGJpbmRpbmdUeXBlID0gdGhpcy5CaW5kaW5nVHlwZS5BcnJheUVsZW1lbnQ7XHJcblxyXG5cdFx0XHR0aGlzLnJlc29sdmVkUHJvcGVydHkgPSBub2RlUHJvcGVydHk7XHJcblx0XHRcdHRoaXMucHJvcGVydHlJbmRleCA9IHByb3BlcnR5SW5kZXg7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggbm9kZVByb3BlcnR5LmZyb21BcnJheSAhPT0gdW5kZWZpbmVkICYmIG5vZGVQcm9wZXJ0eS50b0FycmF5ICE9PSB1bmRlZmluZWQgKSB7XHJcblx0XHRcdC8vIG11c3QgdXNlIGNvcHkgZm9yIE9iamVjdDNELkV1bGVyL1F1YXRlcm5pb25cclxuXHJcblx0XHRcdGJpbmRpbmdUeXBlID0gdGhpcy5CaW5kaW5nVHlwZS5IYXNGcm9tVG9BcnJheTtcclxuXHJcblx0XHRcdHRoaXMucmVzb2x2ZWRQcm9wZXJ0eSA9IG5vZGVQcm9wZXJ0eTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBub2RlUHJvcGVydHkubGVuZ3RoICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRiaW5kaW5nVHlwZSA9IHRoaXMuQmluZGluZ1R5cGUuRW50aXJlQXJyYXk7XHJcblxyXG5cdFx0XHR0aGlzLnJlc29sdmVkUHJvcGVydHkgPSBub2RlUHJvcGVydHk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHRoaXMucHJvcGVydHlOYW1lID0gcHJvcGVydHlOYW1lO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBzZWxlY3QgZ2V0dGVyIC8gc2V0dGVyXHJcblx0XHR0aGlzLmdldFZhbHVlID0gdGhpcy5HZXR0ZXJCeUJpbmRpbmdUeXBlWyBiaW5kaW5nVHlwZSBdO1xyXG5cdFx0dGhpcy5zZXRWYWx1ZSA9IHRoaXMuU2V0dGVyQnlCaW5kaW5nVHlwZUFuZFZlcnNpb25pbmdbIGJpbmRpbmdUeXBlIF1bIHZlcnNpb25pbmcgXTtcclxuXHJcblx0fSxcclxuXHJcblx0dW5iaW5kOiBmdW5jdGlvbigpIHtcclxuXHJcblx0XHR0aGlzLm5vZGUgPSBudWxsO1xyXG5cclxuXHRcdC8vIGJhY2sgdG8gdGhlIHByb3RvdHlwZSB2ZXJzaW9uIG9mIGdldFZhbHVlIC8gc2V0VmFsdWVcclxuXHRcdC8vIG5vdGU6IGF2b2lkaW5nIHRvIG11dGF0ZSB0aGUgc2hhcGUgb2YgJ3RoaXMnIHZpYSAnZGVsZXRlJ1xyXG5cdFx0dGhpcy5nZXRWYWx1ZSA9IHRoaXMuX2dldFZhbHVlX3VuYm91bmQ7XHJcblx0XHR0aGlzLnNldFZhbHVlID0gdGhpcy5fc2V0VmFsdWVfdW5ib3VuZDtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbk9iamVjdC5hc3NpZ24oIFRIUkVFLlByb3BlcnR5QmluZGluZy5wcm90b3R5cGUsIHsgLy8gcHJvdG90eXBlLCBjb250aW51ZWRcclxuXHJcblx0Ly8gdGhlc2UgYXJlIHVzZWQgdG8gXCJiaW5kXCIgYSBub25leGlzdGVudCBwcm9wZXJ0eVxyXG5cdF9nZXRWYWx1ZV91bmF2YWlsYWJsZTogZnVuY3Rpb24oKSB7fSxcclxuXHRfc2V0VmFsdWVfdW5hdmFpbGFibGU6IGZ1bmN0aW9uKCkge30sXHJcblxyXG5cdC8vIGluaXRpYWwgc3RhdGUgb2YgdGhlc2UgbWV0aG9kcyB0aGF0IGNhbGxzICdiaW5kJ1xyXG5cdF9nZXRWYWx1ZV91bmJvdW5kOiBUSFJFRS5Qcm9wZXJ0eUJpbmRpbmcucHJvdG90eXBlLmdldFZhbHVlLFxyXG5cdF9zZXRWYWx1ZV91bmJvdW5kOiBUSFJFRS5Qcm9wZXJ0eUJpbmRpbmcucHJvdG90eXBlLnNldFZhbHVlLFxyXG5cclxuXHRCaW5kaW5nVHlwZToge1xyXG5cdFx0RGlyZWN0OiAwLFxyXG5cdFx0RW50aXJlQXJyYXk6IDEsXHJcblx0XHRBcnJheUVsZW1lbnQ6IDIsXHJcblx0XHRIYXNGcm9tVG9BcnJheTogM1xyXG5cdH0sXHJcblxyXG5cdFZlcnNpb25pbmc6IHtcclxuXHRcdE5vbmU6IDAsXHJcblx0XHROZWVkc1VwZGF0ZTogMSxcclxuXHRcdE1hdHJpeFdvcmxkTmVlZHNVcGRhdGU6IDJcclxuXHR9LFxyXG5cclxuXHRHZXR0ZXJCeUJpbmRpbmdUeXBlOiBbXHJcblxyXG5cdFx0ZnVuY3Rpb24gZ2V0VmFsdWVfZGlyZWN0KCBidWZmZXIsIG9mZnNldCApIHtcclxuXHJcblx0XHRcdGJ1ZmZlclsgb2Zmc2V0IF0gPSB0aGlzLm5vZGVbIHRoaXMucHJvcGVydHlOYW1lIF07XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRmdW5jdGlvbiBnZXRWYWx1ZV9hcnJheSggYnVmZmVyLCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0XHR2YXIgc291cmNlID0gdGhpcy5yZXNvbHZlZFByb3BlcnR5O1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBuID0gc291cmNlLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcclxuXHJcblx0XHRcdFx0YnVmZmVyWyBvZmZzZXQgKysgXSA9IHNvdXJjZVsgaSBdO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0ZnVuY3Rpb24gZ2V0VmFsdWVfYXJyYXlFbGVtZW50KCBidWZmZXIsIG9mZnNldCApIHtcclxuXHJcblx0XHRcdGJ1ZmZlclsgb2Zmc2V0IF0gPSB0aGlzLnJlc29sdmVkUHJvcGVydHlbIHRoaXMucHJvcGVydHlJbmRleCBdO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0ZnVuY3Rpb24gZ2V0VmFsdWVfdG9BcnJheSggYnVmZmVyLCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnJlc29sdmVkUHJvcGVydHkudG9BcnJheSggYnVmZmVyLCBvZmZzZXQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdF0sXHJcblxyXG5cdFNldHRlckJ5QmluZGluZ1R5cGVBbmRWZXJzaW9uaW5nOiBbXHJcblxyXG5cdFx0W1xyXG5cdFx0XHQvLyBEaXJlY3RcclxuXHJcblx0XHRcdGZ1bmN0aW9uIHNldFZhbHVlX2RpcmVjdCggYnVmZmVyLCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMubm9kZVsgdGhpcy5wcm9wZXJ0eU5hbWUgXSA9IGJ1ZmZlclsgb2Zmc2V0IF07XHJcblxyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0ZnVuY3Rpb24gc2V0VmFsdWVfZGlyZWN0X3NldE5lZWRzVXBkYXRlKCBidWZmZXIsIG9mZnNldCApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5ub2RlWyB0aGlzLnByb3BlcnR5TmFtZSBdID0gYnVmZmVyWyBvZmZzZXQgXTtcclxuXHRcdFx0XHR0aGlzLnRhcmdldE9iamVjdC5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0ZnVuY3Rpb24gc2V0VmFsdWVfZGlyZWN0X3NldE1hdHJpeFdvcmxkTmVlZHNVcGRhdGUoIGJ1ZmZlciwgb2Zmc2V0ICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLm5vZGVbIHRoaXMucHJvcGVydHlOYW1lIF0gPSBidWZmZXJbIG9mZnNldCBdO1xyXG5cdFx0XHRcdHRoaXMudGFyZ2V0T2JqZWN0Lm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdF0sIFtcclxuXHJcblx0XHRcdC8vIEVudGlyZUFycmF5XHJcblxyXG5cdFx0XHRmdW5jdGlvbiBzZXRWYWx1ZV9hcnJheSggYnVmZmVyLCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBkZXN0ID0gdGhpcy5yZXNvbHZlZFByb3BlcnR5O1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIG4gPSBkZXN0Lmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcclxuXHJcblx0XHRcdFx0XHRkZXN0WyBpIF0gPSBidWZmZXJbIG9mZnNldCArKyBdO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0ZnVuY3Rpb24gc2V0VmFsdWVfYXJyYXlfc2V0TmVlZHNVcGRhdGUoIGJ1ZmZlciwgb2Zmc2V0ICkge1xyXG5cclxuXHRcdFx0XHR2YXIgZGVzdCA9IHRoaXMucmVzb2x2ZWRQcm9wZXJ0eTtcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBuID0gZGVzdC5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XHJcblxyXG5cdFx0XHRcdFx0ZGVzdFsgaSBdID0gYnVmZmVyWyBvZmZzZXQgKysgXTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR0aGlzLnRhcmdldE9iamVjdC5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0ZnVuY3Rpb24gc2V0VmFsdWVfYXJyYXlfc2V0TWF0cml4V29ybGROZWVkc1VwZGF0ZSggYnVmZmVyLCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBkZXN0ID0gdGhpcy5yZXNvbHZlZFByb3BlcnR5O1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIG4gPSBkZXN0Lmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcclxuXHJcblx0XHRcdFx0XHRkZXN0WyBpIF0gPSBidWZmZXJbIG9mZnNldCArKyBdO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRoaXMudGFyZ2V0T2JqZWN0Lm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdF0sIFtcclxuXHJcblx0XHRcdC8vIEFycmF5RWxlbWVudFxyXG5cclxuXHRcdFx0ZnVuY3Rpb24gc2V0VmFsdWVfYXJyYXlFbGVtZW50KCBidWZmZXIsIG9mZnNldCApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5yZXNvbHZlZFByb3BlcnR5WyB0aGlzLnByb3BlcnR5SW5kZXggXSA9IGJ1ZmZlclsgb2Zmc2V0IF07XHJcblxyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0ZnVuY3Rpb24gc2V0VmFsdWVfYXJyYXlFbGVtZW50X3NldE5lZWRzVXBkYXRlKCBidWZmZXIsIG9mZnNldCApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5yZXNvbHZlZFByb3BlcnR5WyB0aGlzLnByb3BlcnR5SW5kZXggXSA9IGJ1ZmZlclsgb2Zmc2V0IF07XHJcblx0XHRcdFx0dGhpcy50YXJnZXRPYmplY3QubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdFx0fSxcclxuXHJcblx0XHRcdGZ1bmN0aW9uIHNldFZhbHVlX2FycmF5RWxlbWVudF9zZXRNYXRyaXhXb3JsZE5lZWRzVXBkYXRlKCBidWZmZXIsIG9mZnNldCApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5yZXNvbHZlZFByb3BlcnR5WyB0aGlzLnByb3BlcnR5SW5kZXggXSA9IGJ1ZmZlclsgb2Zmc2V0IF07XHJcblx0XHRcdFx0dGhpcy50YXJnZXRPYmplY3QubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XSwgW1xyXG5cclxuXHRcdFx0Ly8gSGFzVG9Gcm9tQXJyYXlcclxuXHJcblx0XHRcdGZ1bmN0aW9uIHNldFZhbHVlX2Zyb21BcnJheSggYnVmZmVyLCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMucmVzb2x2ZWRQcm9wZXJ0eS5mcm9tQXJyYXkoIGJ1ZmZlciwgb2Zmc2V0ICk7XHJcblxyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0ZnVuY3Rpb24gc2V0VmFsdWVfZnJvbUFycmF5X3NldE5lZWRzVXBkYXRlKCBidWZmZXIsIG9mZnNldCApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5yZXNvbHZlZFByb3BlcnR5LmZyb21BcnJheSggYnVmZmVyLCBvZmZzZXQgKTtcclxuXHRcdFx0XHR0aGlzLnRhcmdldE9iamVjdC5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0ZnVuY3Rpb24gc2V0VmFsdWVfZnJvbUFycmF5X3NldE1hdHJpeFdvcmxkTmVlZHNVcGRhdGUoIGJ1ZmZlciwgb2Zmc2V0ICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLnJlc29sdmVkUHJvcGVydHkuZnJvbUFycmF5KCBidWZmZXIsIG9mZnNldCApO1xyXG5cdFx0XHRcdHRoaXMudGFyZ2V0T2JqZWN0Lm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdF1cclxuXHJcblx0XVxyXG5cclxufSApO1xyXG5cclxuVEhSRUUuUHJvcGVydHlCaW5kaW5nLkNvbXBvc2l0ZSA9XHJcblx0XHRmdW5jdGlvbiggdGFyZ2V0R3JvdXAsIHBhdGgsIG9wdGlvbmFsUGFyc2VkUGF0aCApIHtcclxuXHJcblx0dmFyIHBhcnNlZFBhdGggPSBvcHRpb25hbFBhcnNlZFBhdGggfHxcclxuXHRcdFx0VEhSRUUuUHJvcGVydHlCaW5kaW5nLnBhcnNlVHJhY2tOYW1lKCBwYXRoICk7XHJcblxyXG5cdHRoaXMuX3RhcmdldEdyb3VwID0gdGFyZ2V0R3JvdXA7XHJcblx0dGhpcy5fYmluZGluZ3MgPSB0YXJnZXRHcm91cC5zdWJzY3JpYmVfKCBwYXRoLCBwYXJzZWRQYXRoICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUHJvcGVydHlCaW5kaW5nLkNvbXBvc2l0ZS5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5Qcm9wZXJ0eUJpbmRpbmcuQ29tcG9zaXRlLFxyXG5cclxuXHRnZXRWYWx1ZTogZnVuY3Rpb24oIGFycmF5LCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0dGhpcy5iaW5kKCk7IC8vIGJpbmQgYWxsIGJpbmRpbmdcclxuXHJcblx0XHR2YXIgZmlyc3RWYWxpZEluZGV4ID0gdGhpcy5fdGFyZ2V0R3JvdXAubkNhY2hlZE9iamVjdHNfLFxyXG5cdFx0XHRiaW5kaW5nID0gdGhpcy5fYmluZGluZ3NbIGZpcnN0VmFsaWRJbmRleCBdO1xyXG5cclxuXHRcdC8vIGFuZCBvbmx5IGNhbGwgLmdldFZhbHVlIG9uIHRoZSBmaXJzdFxyXG5cdFx0aWYgKCBiaW5kaW5nICE9PSB1bmRlZmluZWQgKSBiaW5kaW5nLmdldFZhbHVlKCBhcnJheSwgb2Zmc2V0ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldFZhbHVlOiBmdW5jdGlvbiggYXJyYXksIG9mZnNldCApIHtcclxuXHJcblx0XHR2YXIgYmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncztcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IHRoaXMuX3RhcmdldEdyb3VwLm5DYWNoZWRPYmplY3RzXyxcclxuXHRcdFx0XHRuID0gYmluZGluZ3MubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xyXG5cclxuXHRcdFx0YmluZGluZ3NbIGkgXS5zZXRWYWx1ZSggYXJyYXksIG9mZnNldCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0YmluZDogZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0dmFyIGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3M7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSB0aGlzLl90YXJnZXRHcm91cC5uQ2FjaGVkT2JqZWN0c18sXHJcblx0XHRcdFx0biA9IGJpbmRpbmdzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcclxuXHJcblx0XHRcdGJpbmRpbmdzWyBpIF0uYmluZCgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0dW5iaW5kOiBmdW5jdGlvbigpIHtcclxuXHJcblx0XHR2YXIgYmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncztcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IHRoaXMuX3RhcmdldEdyb3VwLm5DYWNoZWRPYmplY3RzXyxcclxuXHRcdFx0XHRuID0gYmluZGluZ3MubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xyXG5cclxuXHRcdFx0YmluZGluZ3NbIGkgXS51bmJpbmQoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5Qcm9wZXJ0eUJpbmRpbmcuY3JlYXRlID0gZnVuY3Rpb24oIHJvb3QsIHBhdGgsIHBhcnNlZFBhdGggKSB7XHJcblxyXG5cdGlmICggISAoIHJvb3QgaW5zdGFuY2VvZiBUSFJFRS5BbmltYXRpb25PYmplY3RHcm91cCApICkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgVEhSRUUuUHJvcGVydHlCaW5kaW5nKCByb290LCBwYXRoLCBwYXJzZWRQYXRoICk7XHJcblxyXG5cdH0gZWxzZSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBUSFJFRS5Qcm9wZXJ0eUJpbmRpbmcuQ29tcG9zaXRlKCByb290LCBwYXRoLCBwYXJzZWRQYXRoICk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5Qcm9wZXJ0eUJpbmRpbmcucGFyc2VUcmFja05hbWUgPSBmdW5jdGlvbiggdHJhY2tOYW1lICkge1xyXG5cclxuXHQvLyBtYXRjaGVzIHN0cmluZ3MgaW4gdGhlIGZvcm0gb2Y6XHJcblx0Ly8gICAgbm9kZU5hbWUucHJvcGVydHlcclxuXHQvLyAgICBub2RlTmFtZS5wcm9wZXJ0eVthY2Nlc3Nvcl1cclxuXHQvLyAgICBub2RlTmFtZS5tYXRlcmlhbC5wcm9wZXJ0eVthY2Nlc3Nvcl1cclxuXHQvLyAgICB1dWlkLnByb3BlcnR5W2FjY2Vzc29yXVxyXG5cdC8vICAgIHV1aWQub2JqZWN0TmFtZVtvYmplY3RJbmRleF0ucHJvcGVydHlOYW1lW3Byb3BlcnR5SW5kZXhdXHJcblx0Ly8gICAgcGFyZW50TmFtZS9ub2RlTmFtZS5wcm9wZXJ0eVxyXG5cdC8vICAgIHBhcmVudE5hbWUvcGFyZW50TmFtZS9ub2RlTmFtZS5wcm9wZXJ0eVtpbmRleF1cclxuXHQvL1x0ICAuYm9uZVtBcm1hdHVyZS5ERUZfY29nXS5wb3NpdGlvblxyXG5cdC8vIGNyZWF0ZWQgYW5kIHRlc3RlZCB2aWEgaHR0cHM6Ly9yZWdleDEwMS5jb20vI2phdmFzY3JpcHRcclxuXHJcblx0dmFyIHJlID0gL14oKFtcXHddK1xcLykqKShbXFx3LVxcZF0rKT8oXFwuKFtcXHddKykoXFxbKFtcXHdcXGRcXFtcXF1cXF8uIF0rKVxcXSk/KT8oXFwuKFtcXHcuXSspKFxcWyhbXFx3XFxkXFxbXFxdXFxfLiBdKylcXF0pPykkLztcclxuXHR2YXIgbWF0Y2hlcyA9IHJlLmV4ZWModHJhY2tOYW1lKTtcclxuXHJcblx0aWYoICEgbWF0Y2hlcyApIHtcclxuXHRcdHRocm93IG5ldyBFcnJvciggXCJjYW5ub3QgcGFyc2UgdHJhY2tOYW1lIGF0IGFsbDogXCIgKyB0cmFja05hbWUgKTtcclxuXHR9XHJcblxyXG4gICAgaWYgKG1hdGNoZXMuaW5kZXggPT09IHJlLmxhc3RJbmRleCkge1xyXG4gICAgICAgIHJlLmxhc3RJbmRleCsrO1xyXG4gICAgfVxyXG5cclxuXHR2YXIgcmVzdWx0cyA9IHtcclxuXHRcdC8vIGRpcmVjdG9yeU5hbWU6IG1hdGNoZXNbMV0sIC8vICh0c2NodykgY3VycmVudGx5IHVudXNlZFxyXG5cdFx0bm9kZU5hbWU6IG1hdGNoZXNbM10sIFx0Ly8gYWxsb3dlZCB0byBiZSBudWxsLCBzcGVjaWZpZWQgcm9vdCBub2RlLlxyXG5cdFx0b2JqZWN0TmFtZTogbWF0Y2hlc1s1XSxcclxuXHRcdG9iamVjdEluZGV4OiBtYXRjaGVzWzddLFxyXG5cdFx0cHJvcGVydHlOYW1lOiBtYXRjaGVzWzldLFxyXG5cdFx0cHJvcGVydHlJbmRleDogbWF0Y2hlc1sxMV1cdC8vIGFsbG93ZWQgdG8gYmUgbnVsbCwgc3BlY2lmaWVzIHRoYXQgdGhlIHdob2xlIHByb3BlcnR5IGlzIHNldC5cclxuXHR9O1xyXG5cclxuXHRpZiggcmVzdWx0cy5wcm9wZXJ0eU5hbWUgPT09IG51bGwgfHwgcmVzdWx0cy5wcm9wZXJ0eU5hbWUubGVuZ3RoID09PSAwICkge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKCBcImNhbiBub3QgcGFyc2UgcHJvcGVydHlOYW1lIGZyb20gdHJhY2tOYW1lOiBcIiArIHRyYWNrTmFtZSApO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHJlc3VsdHM7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUHJvcGVydHlCaW5kaW5nLmZpbmROb2RlID0gZnVuY3Rpb24oIHJvb3QsIG5vZGVOYW1lICkge1xyXG5cclxuXHRpZiggISBub2RlTmFtZSB8fCBub2RlTmFtZSA9PT0gXCJcIiB8fCBub2RlTmFtZSA9PT0gXCJyb290XCIgfHwgbm9kZU5hbWUgPT09IFwiLlwiIHx8IG5vZGVOYW1lID09PSAtMSB8fCBub2RlTmFtZSA9PT0gcm9vdC5uYW1lIHx8IG5vZGVOYW1lID09PSByb290LnV1aWQgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHJvb3Q7XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gc2VhcmNoIGludG8gc2tlbGV0b24gYm9uZXMuXHJcblx0aWYoIHJvb3Quc2tlbGV0b24gKSB7XHJcblxyXG5cdFx0dmFyIHNlYXJjaFNrZWxldG9uID0gZnVuY3Rpb24oIHNrZWxldG9uICkge1xyXG5cclxuXHRcdFx0Zm9yKCB2YXIgaSA9IDA7IGkgPCBza2VsZXRvbi5ib25lcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBib25lID0gc2tlbGV0b24uYm9uZXNbaV07XHJcblxyXG5cdFx0XHRcdGlmKCBib25lLm5hbWUgPT09IG5vZGVOYW1lICkge1xyXG5cclxuXHRcdFx0XHRcdHJldHVybiBib25lO1xyXG5cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBudWxsO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdFx0dmFyIGJvbmUgPSBzZWFyY2hTa2VsZXRvbiggcm9vdC5za2VsZXRvbiApO1xyXG5cclxuXHRcdGlmKCBib25lICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIGJvbmU7XHJcblxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gc2VhcmNoIGludG8gbm9kZSBzdWJ0cmVlLlxyXG5cdGlmKCByb290LmNoaWxkcmVuICkge1xyXG5cclxuXHRcdHZhciBzZWFyY2hOb2RlU3VidHJlZSA9IGZ1bmN0aW9uKCBjaGlsZHJlbiApIHtcclxuXHJcblx0XHRcdGZvciggdmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgY2hpbGROb2RlID0gY2hpbGRyZW5baV07XHJcblxyXG5cdFx0XHRcdGlmKCBjaGlsZE5vZGUubmFtZSA9PT0gbm9kZU5hbWUgfHwgY2hpbGROb2RlLnV1aWQgPT09IG5vZGVOYW1lICkge1xyXG5cclxuXHRcdFx0XHRcdHJldHVybiBjaGlsZE5vZGU7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dmFyIHJlc3VsdCA9IHNlYXJjaE5vZGVTdWJ0cmVlKCBjaGlsZE5vZGUuY2hpbGRyZW4gKTtcclxuXHJcblx0XHRcdFx0aWYoIHJlc3VsdCApIHJldHVybiByZXN1bHQ7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdHZhciBzdWJUcmVlTm9kZSA9IHNlYXJjaE5vZGVTdWJ0cmVlKCByb290LmNoaWxkcmVuICk7XHJcblxyXG5cdFx0aWYoIHN1YlRyZWVOb2RlICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHN1YlRyZWVOb2RlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gbnVsbDtcclxuXHJcbn1cclxuXHJcbi8vIEZpbGU6c3JjL2FuaW1hdGlvbi9Qcm9wZXJ0eU1peGVyLmpzXHJcblxyXG4vKipcclxuICpcclxuICogQnVmZmVyZWQgc2NlbmUgZ3JhcGggcHJvcGVydHkgdGhhdCBhbGxvd3Mgd2VpZ2h0ZWQgYWNjdW11bGF0aW9uLlxyXG4gKlxyXG4gKlxyXG4gKiBAYXV0aG9yIEJlbiBIb3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvL1xyXG4gKiBAYXV0aG9yIERhdmlkIFNhcm5vIC8gaHR0cDovL2xpZ2h0aGF1cy51cy9cclxuICogQGF1dGhvciB0c2Nod1xyXG4gKi9cclxuXHJcblRIUkVFLlByb3BlcnR5TWl4ZXIgPSBmdW5jdGlvbiAoIGJpbmRpbmcsIHR5cGVOYW1lLCB2YWx1ZVNpemUgKSB7XHJcblxyXG5cdHRoaXMuYmluZGluZyA9IGJpbmRpbmc7XHJcblx0dGhpcy52YWx1ZVNpemUgPSB2YWx1ZVNpemU7XHJcblxyXG5cdHZhciBidWZmZXJUeXBlID0gRmxvYXQ2NEFycmF5LFxyXG5cdFx0bWl4RnVuY3Rpb247XHJcblxyXG5cdHN3aXRjaCAoIHR5cGVOYW1lICkge1xyXG5cclxuXHRcdGNhc2UgJ3F1YXRlcm5pb24nOlx0XHRcdG1peEZ1bmN0aW9uID0gdGhpcy5fc2xlcnA7XHRcdGJyZWFrO1xyXG5cclxuXHRcdGNhc2UgJ3N0cmluZyc6XHJcblx0XHRjYXNlICdib29sJzpcclxuXHJcblx0XHRcdGJ1ZmZlclR5cGUgPSBBcnJheSxcdFx0bWl4RnVuY3Rpb24gPSB0aGlzLl9zZWxlY3Q7XHRcdGJyZWFrO1xyXG5cclxuXHRcdGRlZmF1bHQ6XHRcdFx0XHRcdG1peEZ1bmN0aW9uID0gdGhpcy5fbGVycDtcclxuXHJcblx0fVxyXG5cclxuXHR0aGlzLmJ1ZmZlciA9IG5ldyBidWZmZXJUeXBlKCB2YWx1ZVNpemUgKiA0ICk7XHJcblx0Ly8gbGF5b3V0OiBbIGluY29taW5nIHwgYWNjdTAgfCBhY2N1MSB8IG9yaWcgXVxyXG5cdC8vXHJcblx0Ly8gaW50ZXJwb2xhdG9ycyBjYW4gdXNlIC5idWZmZXIgYXMgdGhlaXIgLnJlc3VsdFxyXG5cdC8vIHRoZSBkYXRhIHRoZW4gZ29lcyB0byAnaW5jb21pbmcnXHJcblx0Ly9cclxuXHQvLyAnYWNjdTAnIGFuZCAnYWNjdTEnIGFyZSB1c2VkIGZyYW1lLWludGVybGVhdmVkIGZvclxyXG5cdC8vIHRoZSBjdW11bGF0aXZlIHJlc3VsdCBhbmQgYXJlIGNvbXBhcmVkIHRvIGRldGVjdFxyXG5cdC8vIGNoYW5nZXNcclxuXHQvL1xyXG5cdC8vICdvcmlnJyBzdG9yZXMgdGhlIG9yaWdpbmFsIHN0YXRlIG9mIHRoZSBwcm9wZXJ0eVxyXG5cclxuXHR0aGlzLl9taXhCdWZmZXJSZWdpb24gPSBtaXhGdW5jdGlvbjtcclxuXHJcblx0dGhpcy5jdW11bGF0aXZlV2VpZ2h0ID0gMDtcclxuXHJcblx0dGhpcy51c2VDb3VudCA9IDA7XHJcblx0dGhpcy5yZWZlcmVuY2VDb3VudCA9IDA7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUHJvcGVydHlNaXhlci5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5Qcm9wZXJ0eU1peGVyLFxyXG5cclxuXHQvLyBhY2N1bXVsYXRlIGRhdGEgaW4gdGhlICdpbmNvbWluZycgcmVnaW9uIGludG8gJ2FjY3U8aT4nXHJcblx0YWNjdW11bGF0ZTogZnVuY3Rpb24oIGFjY3VJbmRleCwgd2VpZ2h0ICkge1xyXG5cclxuXHRcdC8vIG5vdGU6IGhhcHBpbHkgYWNjdW11bGF0aW5nIG5vdGhpbmcgd2hlbiB3ZWlnaHQgPSAwLCB0aGUgY2FsbGVyIGtub3dzXHJcblx0XHQvLyB0aGUgd2VpZ2h0IGFuZCBzaG91bGRuJ3QgaGF2ZSBtYWRlIHRoZSBjYWxsIGluIHRoZSBmaXJzdCBwbGFjZVxyXG5cclxuXHRcdHZhciBidWZmZXIgPSB0aGlzLmJ1ZmZlcixcclxuXHRcdFx0c3RyaWRlID0gdGhpcy52YWx1ZVNpemUsXHJcblx0XHRcdG9mZnNldCA9IGFjY3VJbmRleCAqIHN0cmlkZSArIHN0cmlkZSxcclxuXHJcblx0XHRcdGN1cnJlbnRXZWlnaHQgPSB0aGlzLmN1bXVsYXRpdmVXZWlnaHQ7XHJcblxyXG5cdFx0aWYgKCBjdXJyZW50V2VpZ2h0ID09PSAwICkge1xyXG5cclxuXHRcdFx0Ly8gYWNjdU4gOj0gaW5jb21pbmcgKiB3ZWlnaHRcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSAhPT0gc3RyaWRlOyArKyBpICkge1xyXG5cclxuXHRcdFx0XHRidWZmZXJbIG9mZnNldCArIGkgXSA9IGJ1ZmZlclsgaSBdO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Y3VycmVudFdlaWdodCA9IHdlaWdodDtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0Ly8gYWNjdU4gOj0gYWNjdU4gKyBpbmNvbWluZyAqIHdlaWdodFxyXG5cclxuXHRcdFx0Y3VycmVudFdlaWdodCArPSB3ZWlnaHQ7XHJcblx0XHRcdHZhciBtaXggPSB3ZWlnaHQgLyBjdXJyZW50V2VpZ2h0O1xyXG5cdFx0XHR0aGlzLl9taXhCdWZmZXJSZWdpb24oIGJ1ZmZlciwgb2Zmc2V0LCAwLCBtaXgsIHN0cmlkZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmN1bXVsYXRpdmVXZWlnaHQgPSBjdXJyZW50V2VpZ2h0O1xyXG5cclxuXHR9LFxyXG5cclxuXHQvLyBhcHBseSB0aGUgc3RhdGUgb2YgJ2FjY3U8aT4nIHRvIHRoZSBiaW5kaW5nIHdoZW4gYWNjdXMgZGlmZmVyXHJcblx0YXBwbHk6IGZ1bmN0aW9uKCBhY2N1SW5kZXggKSB7XHJcblxyXG5cdFx0dmFyIHN0cmlkZSA9IHRoaXMudmFsdWVTaXplLFxyXG5cdFx0XHRidWZmZXIgPSB0aGlzLmJ1ZmZlcixcclxuXHRcdFx0b2Zmc2V0ID0gYWNjdUluZGV4ICogc3RyaWRlICsgc3RyaWRlLFxyXG5cclxuXHRcdFx0d2VpZ2h0ID0gdGhpcy5jdW11bGF0aXZlV2VpZ2h0LFxyXG5cclxuXHRcdFx0YmluZGluZyA9IHRoaXMuYmluZGluZztcclxuXHJcblx0XHR0aGlzLmN1bXVsYXRpdmVXZWlnaHQgPSAwO1xyXG5cclxuXHRcdGlmICggd2VpZ2h0IDwgMSApIHtcclxuXHJcblx0XHRcdC8vIGFjY3VOIDo9IGFjY3VOICsgb3JpZ2luYWwgKiAoIDEgLSBjdW11bGF0aXZlV2VpZ2h0IClcclxuXHJcblx0XHRcdHZhciBvcmlnaW5hbFZhbHVlT2Zmc2V0ID0gc3RyaWRlICogMztcclxuXHJcblx0XHRcdHRoaXMuX21peEJ1ZmZlclJlZ2lvbihcclxuXHRcdFx0XHRcdGJ1ZmZlciwgb2Zmc2V0LCBvcmlnaW5hbFZhbHVlT2Zmc2V0LCAxIC0gd2VpZ2h0LCBzdHJpZGUgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSBzdHJpZGUsIGUgPSBzdHJpZGUgKyBzdHJpZGU7IGkgIT09IGU7ICsrIGkgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGJ1ZmZlclsgaSBdICE9PSBidWZmZXJbIGkgKyBzdHJpZGUgXSApIHtcclxuXHJcblx0XHRcdFx0Ly8gdmFsdWUgaGFzIGNoYW5nZWQgLT4gdXBkYXRlIHNjZW5lIGdyYXBoXHJcblxyXG5cdFx0XHRcdGJpbmRpbmcuc2V0VmFsdWUoIGJ1ZmZlciwgb2Zmc2V0ICk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHQvLyByZW1lbWJlciB0aGUgc3RhdGUgb2YgdGhlIGJvdW5kIHByb3BlcnR5IGFuZCBjb3B5IGl0IHRvIGJvdGggYWNjdXNcclxuXHRzYXZlT3JpZ2luYWxTdGF0ZTogZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0dmFyIGJpbmRpbmcgPSB0aGlzLmJpbmRpbmc7XHJcblxyXG5cdFx0dmFyIGJ1ZmZlciA9IHRoaXMuYnVmZmVyLFxyXG5cdFx0XHRzdHJpZGUgPSB0aGlzLnZhbHVlU2l6ZSxcclxuXHJcblx0XHRcdG9yaWdpbmFsVmFsdWVPZmZzZXQgPSBzdHJpZGUgKiAzO1xyXG5cclxuXHRcdGJpbmRpbmcuZ2V0VmFsdWUoIGJ1ZmZlciwgb3JpZ2luYWxWYWx1ZU9mZnNldCApO1xyXG5cclxuXHRcdC8vIGFjY3VbMC4uMV0gOj0gb3JpZyAtLSBpbml0aWFsbHkgZGV0ZWN0IGNoYW5nZXMgYWdhaW5zdCB0aGUgb3JpZ2luYWxcclxuXHRcdGZvciAoIHZhciBpID0gc3RyaWRlLCBlID0gb3JpZ2luYWxWYWx1ZU9mZnNldDsgaSAhPT0gZTsgKysgaSApIHtcclxuXHJcblx0XHRcdGJ1ZmZlclsgaSBdID0gYnVmZmVyWyBvcmlnaW5hbFZhbHVlT2Zmc2V0ICsgKCBpICUgc3RyaWRlICkgXTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5jdW11bGF0aXZlV2VpZ2h0ID0gMDtcclxuXHJcblx0fSxcclxuXHJcblx0Ly8gYXBwbHkgdGhlIHN0YXRlIHByZXZpb3VzbHkgdGFrZW4gdmlhICdzYXZlT3JpZ2luYWxTdGF0ZScgdG8gdGhlIGJpbmRpbmdcclxuXHRyZXN0b3JlT3JpZ2luYWxTdGF0ZTogZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0dmFyIG9yaWdpbmFsVmFsdWVPZmZzZXQgPSB0aGlzLnZhbHVlU2l6ZSAqIDM7XHJcblx0XHR0aGlzLmJpbmRpbmcuc2V0VmFsdWUoIHRoaXMuYnVmZmVyLCBvcmlnaW5hbFZhbHVlT2Zmc2V0ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cclxuXHQvLyBtaXggZnVuY3Rpb25zXHJcblxyXG5cdF9zZWxlY3Q6IGZ1bmN0aW9uKCBidWZmZXIsIGRzdE9mZnNldCwgc3JjT2Zmc2V0LCB0LCBzdHJpZGUgKSB7XHJcblxyXG5cdFx0aWYgKCB0ID49IDAuNSApIHtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSAhPT0gc3RyaWRlOyArKyBpICkge1xyXG5cclxuXHRcdFx0XHRidWZmZXJbIGRzdE9mZnNldCArIGkgXSA9IGJ1ZmZlclsgc3JjT2Zmc2V0ICsgaSBdO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0X3NsZXJwOiBmdW5jdGlvbiggYnVmZmVyLCBkc3RPZmZzZXQsIHNyY09mZnNldCwgdCwgc3RyaWRlICkge1xyXG5cclxuXHRcdFRIUkVFLlF1YXRlcm5pb24uc2xlcnBGbGF0KCBidWZmZXIsIGRzdE9mZnNldCxcclxuXHRcdFx0XHRidWZmZXIsIGRzdE9mZnNldCwgYnVmZmVyLCBzcmNPZmZzZXQsIHQgKTtcclxuXHJcblx0fSxcclxuXHJcblx0X2xlcnA6IGZ1bmN0aW9uKCBidWZmZXIsIGRzdE9mZnNldCwgc3JjT2Zmc2V0LCB0LCBzdHJpZGUgKSB7XHJcblxyXG5cdFx0dmFyIHMgPSAxIC0gdDtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgIT09IHN0cmlkZTsgKysgaSApIHtcclxuXHJcblx0XHRcdHZhciBqID0gZHN0T2Zmc2V0ICsgaTtcclxuXHJcblx0XHRcdGJ1ZmZlclsgaiBdID0gYnVmZmVyWyBqIF0gKiBzICsgYnVmZmVyWyBzcmNPZmZzZXQgKyBpIF0gKiB0O1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2FuaW1hdGlvbi90cmFja3MvQm9vbGVhbktleWZyYW1lVHJhY2suanNcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBBIFRyYWNrIG9mIEJvb2xlYW4ga2V5ZnJhbWUgdmFsdWVzLlxyXG4gKlxyXG4gKlxyXG4gKiBAYXV0aG9yIEJlbiBIb3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvL1xyXG4gKiBAYXV0aG9yIERhdmlkIFNhcm5vIC8gaHR0cDovL2xpZ2h0aGF1cy51cy9cclxuICogQGF1dGhvciB0c2Nod1xyXG4gKi9cclxuXHJcblRIUkVFLkJvb2xlYW5LZXlmcmFtZVRyYWNrID0gZnVuY3Rpb24gKCBuYW1lLCB0aW1lcywgdmFsdWVzICkge1xyXG5cclxuXHRUSFJFRS5LZXlmcmFtZVRyYWNrLmNhbGwoIHRoaXMsIG5hbWUsIHRpbWVzLCB2YWx1ZXMgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Cb29sZWFuS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUgPVxyXG5cdFx0T2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggVEhSRUUuS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUgKSwge1xyXG5cclxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuQm9vbGVhbktleWZyYW1lVHJhY2ssXHJcblxyXG5cdFZhbHVlVHlwZU5hbWU6ICdib29sJyxcclxuXHRWYWx1ZUJ1ZmZlclR5cGU6IEFycmF5LFxyXG5cclxuXHREZWZhdWx0SW50ZXJwb2xhdGlvbjogVEhSRUUuSW50ZXBvbGF0ZURpc2NyZXRlLFxyXG5cclxuXHRJbnRlcnBvbGFudEZhY3RvcnlNZXRob2RMaW5lYXI6IHVuZGVmaW5lZCxcclxuXHRJbnRlcnBvbGFudEZhY3RvcnlNZXRob2RTbW9vdGg6IHVuZGVmaW5lZFxyXG5cclxuXHQvLyBOb3RlOiBBY3R1YWxseSB0aGlzIHRyYWNrIGNvdWxkIGhhdmUgYSBvcHRpbWl6ZWQgLyBjb21wcmVzc2VkXHJcblx0Ly8gcmVwcmVzZW50YXRpb24gb2YgYSBzaW5nbGUgdmFsdWUgYW5kIGEgY3VzdG9tIGludGVycG9sYW50IHRoYXRcclxuXHQvLyBjb21wdXRlcyBcImZpcnN0VmFsdWUgXiBpc09kZCggaW5kZXggKVwiLlxyXG5cclxufSApO1xyXG5cclxuLy8gRmlsZTpzcmMvYW5pbWF0aW9uL3RyYWNrcy9OdW1iZXJLZXlmcmFtZVRyYWNrLmpzXHJcblxyXG4vKipcclxuICpcclxuICogQSBUcmFjayBvZiBudW1lcmljIGtleWZyYW1lIHZhbHVlcy5cclxuICpcclxuICogQGF1dGhvciBCZW4gSG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pby9cclxuICogQGF1dGhvciBEYXZpZCBTYXJubyAvIGh0dHA6Ly9saWdodGhhdXMudXMvXHJcbiAqIEBhdXRob3IgdHNjaHdcclxuICovXHJcblxyXG5USFJFRS5OdW1iZXJLZXlmcmFtZVRyYWNrID0gZnVuY3Rpb24gKCBuYW1lLCB0aW1lcywgdmFsdWVzLCBpbnRlcnBvbGF0aW9uICkge1xyXG5cclxuXHRUSFJFRS5LZXlmcmFtZVRyYWNrLmNhbGwoIHRoaXMsIG5hbWUsIHRpbWVzLCB2YWx1ZXMsIGludGVycG9sYXRpb24gKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5OdW1iZXJLZXlmcmFtZVRyYWNrLnByb3RvdHlwZSA9XHJcblx0XHRPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBUSFJFRS5LZXlmcmFtZVRyYWNrLnByb3RvdHlwZSApLCB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5OdW1iZXJLZXlmcmFtZVRyYWNrLFxyXG5cclxuXHRWYWx1ZVR5cGVOYW1lOiAnbnVtYmVyJyxcclxuXHJcblx0Ly8gVmFsdWVCdWZmZXJUeXBlIGlzIGluaGVyaXRlZFxyXG5cclxuXHQvLyBEZWZhdWx0SW50ZXJwb2xhdGlvbiBpcyBpbmhlcml0ZWRcclxuXHJcbn0gKTtcclxuXHJcbi8vIEZpbGU6c3JjL2FuaW1hdGlvbi90cmFja3MvUXVhdGVybmlvbktleWZyYW1lVHJhY2suanNcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBBIFRyYWNrIG9mIHF1YXRlcm5pb24ga2V5ZnJhbWUgdmFsdWVzLlxyXG4gKlxyXG4gKiBAYXV0aG9yIEJlbiBIb3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvL1xyXG4gKiBAYXV0aG9yIERhdmlkIFNhcm5vIC8gaHR0cDovL2xpZ2h0aGF1cy51cy9cclxuICogQGF1dGhvciB0c2Nod1xyXG4gKi9cclxuXHJcblRIUkVFLlF1YXRlcm5pb25LZXlmcmFtZVRyYWNrID0gZnVuY3Rpb24gKCBuYW1lLCB0aW1lcywgdmFsdWVzLCBpbnRlcnBvbGF0aW9uICkge1xyXG5cclxuXHRUSFJFRS5LZXlmcmFtZVRyYWNrLmNhbGwoIHRoaXMsIG5hbWUsIHRpbWVzLCB2YWx1ZXMsIGludGVycG9sYXRpb24gKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5RdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUgPVxyXG5cdFx0T2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggVEhSRUUuS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUgKSwge1xyXG5cclxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuUXVhdGVybmlvbktleWZyYW1lVHJhY2ssXHJcblxyXG5cdFZhbHVlVHlwZU5hbWU6ICdxdWF0ZXJuaW9uJyxcclxuXHJcblx0Ly8gVmFsdWVCdWZmZXJUeXBlIGlzIGluaGVyaXRlZFxyXG5cclxuXHREZWZhdWx0SW50ZXJwb2xhdGlvbjogVEhSRUUuSW50ZXJwb2xhdGVMaW5lYXIsXHJcblxyXG5cdEludGVycG9sYW50RmFjdG9yeU1ldGhvZExpbmVhcjogZnVuY3Rpb24oIHJlc3VsdCApIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IFRIUkVFLlF1YXRlcm5pb25MaW5lYXJJbnRlcnBvbGFudChcclxuXHRcdFx0XHR0aGlzLnRpbWVzLCB0aGlzLnZhbHVlcywgdGhpcy5nZXRWYWx1ZVNpemUoKSwgcmVzdWx0ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdEludGVycG9sYW50RmFjdG9yeU1ldGhvZFNtb290aDogdW5kZWZpbmVkIC8vIG5vdCB5ZXQgaW1wbGVtZW50ZWRcclxuXHJcbn0gKTtcclxuXHJcbi8vIEZpbGU6c3JjL2FuaW1hdGlvbi90cmFja3MvU3RyaW5nS2V5ZnJhbWVUcmFjay5qc1xyXG5cclxuLyoqXHJcbiAqXHJcbiAqIEEgVHJhY2sgdGhhdCBpbnRlcnBvbGF0ZXMgU3RyaW5nc1xyXG4gKlxyXG4gKlxyXG4gKiBAYXV0aG9yIEJlbiBIb3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvL1xyXG4gKiBAYXV0aG9yIERhdmlkIFNhcm5vIC8gaHR0cDovL2xpZ2h0aGF1cy51cy9cclxuICogQGF1dGhvciB0c2Nod1xyXG4gKi9cclxuXHJcblRIUkVFLlN0cmluZ0tleWZyYW1lVHJhY2sgPSBmdW5jdGlvbiAoIG5hbWUsIHRpbWVzLCB2YWx1ZXMsIGludGVycG9sYXRpb24gKSB7XHJcblxyXG5cdFRIUkVFLktleWZyYW1lVHJhY2suY2FsbCggdGhpcywgbmFtZSwgdGltZXMsIHZhbHVlcywgaW50ZXJwb2xhdGlvbiApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlN0cmluZ0tleWZyYW1lVHJhY2sucHJvdG90eXBlID1cclxuXHRcdE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIFRIUkVFLktleWZyYW1lVHJhY2sucHJvdG90eXBlICksIHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLlN0cmluZ0tleWZyYW1lVHJhY2ssXHJcblxyXG5cdFZhbHVlVHlwZU5hbWU6ICdzdHJpbmcnLFxyXG5cdFZhbHVlQnVmZmVyVHlwZTogQXJyYXksXHJcblxyXG5cdERlZmF1bHRJbnRlcnBvbGF0aW9uOiBUSFJFRS5JbnRlcG9sYXRlRGlzY3JldGUsXHJcblxyXG5cdEludGVycG9sYW50RmFjdG9yeU1ldGhvZExpbmVhcjogdW5kZWZpbmVkLFxyXG5cclxuXHRJbnRlcnBvbGFudEZhY3RvcnlNZXRob2RTbW9vdGg6IHVuZGVmaW5lZFxyXG5cclxufSApO1xyXG5cclxuLy8gRmlsZTpzcmMvYW5pbWF0aW9uL3RyYWNrcy9WZWN0b3JLZXlmcmFtZVRyYWNrLmpzXHJcblxyXG4vKipcclxuICpcclxuICogQSBUcmFjayBvZiB2ZWN0b3JlZCBrZXlmcmFtZSB2YWx1ZXMuXHJcbiAqXHJcbiAqXHJcbiAqIEBhdXRob3IgQmVuIEhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW8vXHJcbiAqIEBhdXRob3IgRGF2aWQgU2Fybm8gLyBodHRwOi8vbGlnaHRoYXVzLnVzL1xyXG4gKiBAYXV0aG9yIHRzY2h3XHJcbiAqL1xyXG5cclxuVEhSRUUuVmVjdG9yS2V5ZnJhbWVUcmFjayA9IGZ1bmN0aW9uICggbmFtZSwgdGltZXMsIHZhbHVlcywgaW50ZXJwb2xhdGlvbiApIHtcclxuXHJcblx0VEhSRUUuS2V5ZnJhbWVUcmFjay5jYWxsKCB0aGlzLCBuYW1lLCB0aW1lcywgdmFsdWVzLCBpbnRlcnBvbGF0aW9uICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuVmVjdG9yS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUgPVxyXG5cdFx0T2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggVEhSRUUuS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUgKSwge1xyXG5cclxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuVmVjdG9yS2V5ZnJhbWVUcmFjayxcclxuXHJcblx0VmFsdWVUeXBlTmFtZTogJ3ZlY3RvcidcclxuXHJcblx0Ly8gVmFsdWVCdWZmZXJUeXBlIGlzIGluaGVyaXRlZFxyXG5cclxuXHQvLyBEZWZhdWx0SW50ZXJwb2xhdGlvbiBpcyBpbmhlcml0ZWRcclxuXHJcbn0gKTtcclxuXHJcbi8vIEZpbGU6c3JjL2F1ZGlvL0F1ZGlvLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5BdWRpbyA9IGZ1bmN0aW9uICggbGlzdGVuZXIgKSB7XHJcblxyXG5cdFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy50eXBlID0gJ0F1ZGlvJztcclxuXHJcblx0dGhpcy5jb250ZXh0ID0gbGlzdGVuZXIuY29udGV4dDtcclxuXHR0aGlzLnNvdXJjZSA9IHRoaXMuY29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoKTtcclxuXHR0aGlzLnNvdXJjZS5vbmVuZGVkID0gdGhpcy5vbkVuZGVkLmJpbmQoIHRoaXMgKTtcclxuXHJcblx0dGhpcy5nYWluID0gdGhpcy5jb250ZXh0LmNyZWF0ZUdhaW4oKTtcclxuXHR0aGlzLmdhaW4uY29ubmVjdCggbGlzdGVuZXIuZ2V0SW5wdXQoKSApO1xyXG5cclxuXHR0aGlzLmF1dG9wbGF5ID0gZmFsc2U7XHJcblxyXG5cdHRoaXMuc3RhcnRUaW1lID0gMDtcclxuXHR0aGlzLnBsYXliYWNrUmF0ZSA9IDE7XHJcblx0dGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcclxuXHR0aGlzLmhhc1BsYXliYWNrQ29udHJvbCA9IHRydWU7XHJcblx0dGhpcy5zb3VyY2VUeXBlID0gJ2VtcHR5JztcclxuXHJcblx0dGhpcy5maWx0ZXIgPSBudWxsO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkF1ZGlvLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xyXG5USFJFRS5BdWRpby5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5BdWRpbztcclxuXHJcblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5nZXRPdXRwdXQgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHJldHVybiB0aGlzLmdhaW47XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoIGZpbGUgKSB7XHJcblxyXG5cdHZhciBidWZmZXIgPSBuZXcgVEhSRUUuQXVkaW9CdWZmZXIoIHRoaXMuY29udGV4dCApO1xyXG5cdGJ1ZmZlci5sb2FkKCBmaWxlICk7XHJcblxyXG5cdHRoaXMuc2V0QnVmZmVyKCBidWZmZXIgKTtcclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLnNldE5vZGVTb3VyY2UgPSBmdW5jdGlvbiAoIGF1ZGlvTm9kZSApIHtcclxuXHJcblx0dGhpcy5oYXNQbGF5YmFja0NvbnRyb2wgPSBmYWxzZTtcclxuXHR0aGlzLnNvdXJjZVR5cGUgPSAnYXVkaW9Ob2RlJztcclxuXHR0aGlzLnNvdXJjZSA9IGF1ZGlvTm9kZTtcclxuXHR0aGlzLmNvbm5lY3QoKTtcclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLnNldEJ1ZmZlciA9IGZ1bmN0aW9uICggYXVkaW9CdWZmZXIgKSB7XHJcblxyXG5cdHZhciBzY29wZSA9IHRoaXM7XHJcblxyXG5cdGF1ZGlvQnVmZmVyLm9uUmVhZHkoIGZ1bmN0aW9uKCBidWZmZXIgKSB7XHJcblxyXG5cdFx0c2NvcGUuc291cmNlLmJ1ZmZlciA9IGJ1ZmZlcjtcclxuXHRcdHNjb3BlLnNvdXJjZVR5cGUgPSAnYnVmZmVyJztcclxuXHRcdGlmICggc2NvcGUuYXV0b3BsYXkgKSBzY29wZS5wbGF5KCk7XHJcblxyXG5cdH0gKTtcclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdGlmICggdGhpcy5pc1BsYXlpbmcgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQXVkaW86IEF1ZGlvIGlzIGFscmVhZHkgcGxheWluZy4nICk7XHJcblx0XHRyZXR1cm47XHJcblxyXG5cdH1cclxuXHJcblx0aWYgKCB0aGlzLmhhc1BsYXliYWNrQ29udHJvbCA9PT0gZmFsc2UgKSB7XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQXVkaW86IHRoaXMgQXVkaW8gaGFzIG5vIHBsYXliYWNrIGNvbnRyb2wuJyApO1xyXG5cdFx0cmV0dXJuO1xyXG5cclxuXHR9XHJcblxyXG5cdHZhciBzb3VyY2UgPSB0aGlzLmNvbnRleHQuY3JlYXRlQnVmZmVyU291cmNlKCk7XHJcblxyXG5cdHNvdXJjZS5idWZmZXIgPSB0aGlzLnNvdXJjZS5idWZmZXI7XHJcblx0c291cmNlLmxvb3AgPSB0aGlzLnNvdXJjZS5sb29wO1xyXG5cdHNvdXJjZS5vbmVuZGVkID0gdGhpcy5zb3VyY2Uub25lbmRlZDtcclxuXHRzb3VyY2Uuc3RhcnQoIDAsIHRoaXMuc3RhcnRUaW1lICk7XHJcblx0c291cmNlLnBsYXliYWNrUmF0ZS52YWx1ZSA9IHRoaXMucGxheWJhY2tSYXRlO1xyXG5cclxuXHR0aGlzLmlzUGxheWluZyA9IHRydWU7XHJcblxyXG5cdHRoaXMuc291cmNlID0gc291cmNlO1xyXG5cclxuXHR0aGlzLmNvbm5lY3QoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5BdWRpby5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdGlmICggdGhpcy5oYXNQbGF5YmFja0NvbnRyb2wgPT09IGZhbHNlICkge1xyXG5cclxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkF1ZGlvOiB0aGlzIEF1ZGlvIGhhcyBubyBwbGF5YmFjayBjb250cm9sLicgKTtcclxuXHRcdHJldHVybjtcclxuXHJcblx0fVxyXG5cclxuXHR0aGlzLnNvdXJjZS5zdG9wKCk7XHJcblx0dGhpcy5zdGFydFRpbWUgPSB0aGlzLmNvbnRleHQuY3VycmVudFRpbWU7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdGlmICggdGhpcy5oYXNQbGF5YmFja0NvbnRyb2wgPT09IGZhbHNlICkge1xyXG5cclxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkF1ZGlvOiB0aGlzIEF1ZGlvIGhhcyBubyBwbGF5YmFjayBjb250cm9sLicgKTtcclxuXHRcdHJldHVybjtcclxuXHJcblx0fVxyXG5cclxuXHR0aGlzLnNvdXJjZS5zdG9wKCk7XHJcblx0dGhpcy5zdGFydFRpbWUgPSAwO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRpZiAoIHRoaXMuZmlsdGVyICE9PSBudWxsICkge1xyXG5cclxuXHRcdHRoaXMuc291cmNlLmNvbm5lY3QoIHRoaXMuZmlsdGVyICk7XHJcblx0XHR0aGlzLmZpbHRlci5jb25uZWN0KCB0aGlzLmdldE91dHB1dCgpICk7XHJcblxyXG5cdH0gZWxzZSB7XHJcblxyXG5cdFx0dGhpcy5zb3VyY2UuY29ubmVjdCggdGhpcy5nZXRPdXRwdXQoKSApO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdGlmICggdGhpcy5maWx0ZXIgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0dGhpcy5zb3VyY2UuZGlzY29ubmVjdCggdGhpcy5maWx0ZXIgKTtcclxuXHRcdHRoaXMuZmlsdGVyLmRpc2Nvbm5lY3QoIHRoaXMuZ2V0T3V0cHV0KCkgKTtcclxuXHJcblx0fSBlbHNlIHtcclxuXHJcblx0XHR0aGlzLnNvdXJjZS5kaXNjb25uZWN0KCB0aGlzLmdldE91dHB1dCgpICk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5BdWRpby5wcm90b3R5cGUuZ2V0RmlsdGVyID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRyZXR1cm4gdGhpcy5maWx0ZXI7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLnNldEZpbHRlciA9IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCApIHZhbHVlID0gbnVsbDtcclxuXHJcblx0aWYgKCB0aGlzLmlzUGxheWluZyA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHR0aGlzLmRpc2Nvbm5lY3QoKTtcclxuXHRcdHRoaXMuZmlsdGVyID0gdmFsdWU7XHJcblx0XHR0aGlzLmNvbm5lY3QoKTtcclxuXHJcblx0fSBlbHNlIHtcclxuXHJcblx0XHR0aGlzLmZpbHRlciA9IHZhbHVlO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLnNldFBsYXliYWNrUmF0ZSA9IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdGlmICggdGhpcy5oYXNQbGF5YmFja0NvbnRyb2wgPT09IGZhbHNlICkge1xyXG5cclxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkF1ZGlvOiB0aGlzIEF1ZGlvIGhhcyBubyBwbGF5YmFjayBjb250cm9sLicgKTtcclxuXHRcdHJldHVybjtcclxuXHJcblx0fVxyXG5cclxuXHR0aGlzLnBsYXliYWNrUmF0ZSA9IHZhbHVlO1xyXG5cclxuXHRpZiAoIHRoaXMuaXNQbGF5aW5nID09PSB0cnVlICkge1xyXG5cclxuXHRcdHRoaXMuc291cmNlLnBsYXliYWNrUmF0ZS52YWx1ZSA9IHRoaXMucGxheWJhY2tSYXRlO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLmdldFBsYXliYWNrUmF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0cmV0dXJuIHRoaXMucGxheWJhY2tSYXRlO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5vbkVuZGVkID0gZnVuY3Rpb24oKSB7XHJcblxyXG5cdHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLnNldExvb3AgPSBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRpZiAoIHRoaXMuaGFzUGxheWJhY2tDb250cm9sID09PSBmYWxzZSApIHtcclxuXHJcblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5BdWRpbzogdGhpcyBBdWRpbyBoYXMgbm8gcGxheWJhY2sgY29udHJvbC4nICk7XHJcblx0XHRyZXR1cm47XHJcblxyXG5cdH1cclxuXHJcblx0dGhpcy5zb3VyY2UubG9vcCA9IHZhbHVlO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5nZXRMb29wID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRpZiAoIHRoaXMuaGFzUGxheWJhY2tDb250cm9sID09PSBmYWxzZSApIHtcclxuXHJcblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5BdWRpbzogdGhpcyBBdWRpbyBoYXMgbm8gcGxheWJhY2sgY29udHJvbC4nICk7XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIHRoaXMuc291cmNlLmxvb3A7XHJcblxyXG59O1xyXG5cclxuXHJcblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5zZXRWb2x1bWUgPSBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHR0aGlzLmdhaW4uZ2Fpbi52YWx1ZSA9IHZhbHVlO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5nZXRWb2x1bWUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHJldHVybiB0aGlzLmdhaW4uZ2Fpbi52YWx1ZTtcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9hdWRpby9BdWRpb0FuYWx5c2VyLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5BdWRpb0FuYWx5c2VyID0gZnVuY3Rpb24gKCBhdWRpbywgZmZ0U2l6ZSApIHtcclxuXHJcblx0dGhpcy5hbmFseXNlciA9IGF1ZGlvLmNvbnRleHQuY3JlYXRlQW5hbHlzZXIoKTtcclxuXHR0aGlzLmFuYWx5c2VyLmZmdFNpemUgPSBmZnRTaXplICE9PSB1bmRlZmluZWQgPyBmZnRTaXplIDogMjA0ODtcclxuXHJcblx0dGhpcy5kYXRhID0gbmV3IFVpbnQ4QXJyYXkoIHRoaXMuYW5hbHlzZXIuZnJlcXVlbmN5QmluQ291bnQgKTtcclxuXHJcblx0YXVkaW8uZ2V0T3V0cHV0KCkuY29ubmVjdCggdGhpcy5hbmFseXNlciApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkF1ZGlvQW5hbHlzZXIucHJvdG90eXBlID0ge1xyXG5cclxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuQXVkaW9BbmFseXNlcixcclxuXHJcblx0Z2V0RGF0YTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMuYW5hbHlzZXIuZ2V0Qnl0ZUZyZXF1ZW5jeURhdGEoIHRoaXMuZGF0YSApO1xyXG5cdFx0cmV0dXJuIHRoaXMuZGF0YTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2F1ZGlvL0F1ZGlvQnVmZmVyLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5BdWRpb0J1ZmZlciA9IGZ1bmN0aW9uICggY29udGV4dCApIHtcclxuXHJcblx0dGhpcy5jb250ZXh0ID0gY29udGV4dDtcclxuXHR0aGlzLnJlYWR5ID0gZmFsc2U7XHJcblx0dGhpcy5yZWFkeUNhbGxiYWNrcyA9IFtdO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkF1ZGlvQnVmZmVyLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKCBmaWxlICkge1xyXG5cclxuXHR2YXIgc2NvcGUgPSB0aGlzO1xyXG5cclxuXHR2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG5cdHJlcXVlc3Qub3BlbiggJ0dFVCcsIGZpbGUsIHRydWUgKTtcclxuXHRyZXF1ZXN0LnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XHJcblx0cmVxdWVzdC5vbmxvYWQgPSBmdW5jdGlvbiAoIGUgKSB7XHJcblxyXG5cdFx0c2NvcGUuY29udGV4dC5kZWNvZGVBdWRpb0RhdGEoIHRoaXMucmVzcG9uc2UsIGZ1bmN0aW9uICggYnVmZmVyICkge1xyXG5cclxuXHRcdFx0c2NvcGUuYnVmZmVyID0gYnVmZmVyO1xyXG5cdFx0XHRzY29wZS5yZWFkeSA9IHRydWU7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBzY29wZS5yZWFkeUNhbGxiYWNrcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHNjb3BlLnJlYWR5Q2FsbGJhY2tzWyBpIF0oIHNjb3BlLmJ1ZmZlciApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0c2NvcGUucmVhZHlDYWxsYmFja3MgPSBbXTtcclxuXHJcblx0XHR9ICk7XHJcblxyXG5cdH07XHJcblx0cmVxdWVzdC5zZW5kKCk7XHJcblxyXG5cdHJldHVybiB0aGlzO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkF1ZGlvQnVmZmVyLnByb3RvdHlwZS5vblJlYWR5ID0gZnVuY3Rpb24gKCBjYWxsYmFjayApIHtcclxuXHJcblx0aWYgKCB0aGlzLnJlYWR5ICkge1xyXG5cclxuXHRcdGNhbGxiYWNrKCB0aGlzLmJ1ZmZlciApO1xyXG5cclxuXHR9IGVsc2Uge1xyXG5cclxuXHRcdHRoaXMucmVhZHlDYWxsYmFja3MucHVzaCggY2FsbGJhY2sgKTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2F1ZGlvL1Bvc2l0aW9uYWxBdWRpby5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuUG9zaXRpb25hbEF1ZGlvID0gZnVuY3Rpb24gKCBsaXN0ZW5lciApIHtcclxuXHJcblx0VEhSRUUuQXVkaW8uY2FsbCggdGhpcywgbGlzdGVuZXIgKTtcclxuXHJcblx0dGhpcy5wYW5uZXIgPSB0aGlzLmNvbnRleHQuY3JlYXRlUGFubmVyKCk7XHJcblx0dGhpcy5wYW5uZXIuY29ubmVjdCggdGhpcy5nYWluICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUG9zaXRpb25hbEF1ZGlvLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkF1ZGlvLnByb3RvdHlwZSApO1xyXG5USFJFRS5Qb3NpdGlvbmFsQXVkaW8ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuUG9zaXRpb25hbEF1ZGlvO1xyXG5cclxuVEhSRUUuUG9zaXRpb25hbEF1ZGlvLnByb3RvdHlwZS5nZXRPdXRwdXQgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHJldHVybiB0aGlzLnBhbm5lcjtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Qb3NpdGlvbmFsQXVkaW8ucHJvdG90eXBlLnNldFJlZkRpc3RhbmNlID0gZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0dGhpcy5wYW5uZXIucmVmRGlzdGFuY2UgPSB2YWx1ZTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Qb3NpdGlvbmFsQXVkaW8ucHJvdG90eXBlLmdldFJlZkRpc3RhbmNlID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRyZXR1cm4gdGhpcy5wYW5uZXIucmVmRGlzdGFuY2U7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUG9zaXRpb25hbEF1ZGlvLnByb3RvdHlwZS5zZXRSb2xsb2ZmRmFjdG9yID0gZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0dGhpcy5wYW5uZXIucm9sbG9mZkZhY3RvciA9IHZhbHVlO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlBvc2l0aW9uYWxBdWRpby5wcm90b3R5cGUuZ2V0Um9sbG9mZkZhY3RvciA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0cmV0dXJuIHRoaXMucGFubmVyLnJvbGxvZmZGYWN0b3I7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUG9zaXRpb25hbEF1ZGlvLnByb3RvdHlwZS5zZXREaXN0YW5jZU1vZGVsID0gZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0dGhpcy5wYW5uZXIuZGlzdGFuY2VNb2RlbCA9IHZhbHVlO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlBvc2l0aW9uYWxBdWRpby5wcm90b3R5cGUuZ2V0RGlzdGFuY2VNb2RlbCA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0cmV0dXJuIHRoaXMucGFubmVyLmRpc3RhbmNlTW9kZWw7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUG9zaXRpb25hbEF1ZGlvLnByb3RvdHlwZS5zZXRNYXhEaXN0YW5jZSA9IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdHRoaXMucGFubmVyLm1heERpc3RhbmNlID0gdmFsdWU7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUG9zaXRpb25hbEF1ZGlvLnByb3RvdHlwZS5nZXRNYXhEaXN0YW5jZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0cmV0dXJuIHRoaXMucGFubmVyLm1heERpc3RhbmNlO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlBvc2l0aW9uYWxBdWRpby5wcm90b3R5cGUudXBkYXRlTWF0cml4V29ybGQgPSAoIGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dmFyIHBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZU1hdHJpeFdvcmxkKCBmb3JjZSApIHtcclxuXHJcblx0XHRUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUudXBkYXRlTWF0cml4V29ybGQuY2FsbCggdGhpcywgZm9yY2UgKTtcclxuXHJcblx0XHRwb3NpdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubWF0cml4V29ybGQgKTtcclxuXHJcblx0XHR0aGlzLnBhbm5lci5zZXRQb3NpdGlvbiggcG9zaXRpb24ueCwgcG9zaXRpb24ueSwgcG9zaXRpb24ueiApO1xyXG5cclxuXHR9O1xyXG5cclxufSApKCk7XHJcblxyXG4vLyBGaWxlOnNyYy9hdWRpby9BdWRpb0xpc3RlbmVyLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5BdWRpb0xpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMudHlwZSA9ICdBdWRpb0xpc3RlbmVyJztcclxuXHJcblx0dGhpcy5jb250ZXh0ID0gbmV3ICggd2luZG93LkF1ZGlvQ29udGV4dCB8fCB3aW5kb3cud2Via2l0QXVkaW9Db250ZXh0ICkoKTtcclxuXHJcblx0dGhpcy5nYWluID0gdGhpcy5jb250ZXh0LmNyZWF0ZUdhaW4oKTtcclxuXHR0aGlzLmdhaW4uY29ubmVjdCggdGhpcy5jb250ZXh0LmRlc3RpbmF0aW9uICk7XHJcblxyXG5cdHRoaXMuZmlsdGVyID0gbnVsbDtcclxuXHJcbn07XHJcblxyXG5USFJFRS5BdWRpb0xpc3RlbmVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xyXG5USFJFRS5BdWRpb0xpc3RlbmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkF1ZGlvTGlzdGVuZXI7XHJcblxyXG5USFJFRS5BdWRpb0xpc3RlbmVyLnByb3RvdHlwZS5nZXRJbnB1dCA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0cmV0dXJuIHRoaXMuZ2FpbjtcclxuXHJcbn07XHJcblxyXG5USFJFRS5BdWRpb0xpc3RlbmVyLnByb3RvdHlwZS5yZW1vdmVGaWx0ZXIgPSBmdW5jdGlvbiAoICkge1xyXG5cclxuXHRpZiAoIHRoaXMuZmlsdGVyICE9PSBudWxsICkge1xyXG5cclxuXHRcdHRoaXMuZ2Fpbi5kaXNjb25uZWN0KCB0aGlzLmZpbHRlciApO1xyXG5cdFx0dGhpcy5maWx0ZXIuZGlzY29ubmVjdCggdGhpcy5jb250ZXh0LmRlc3RpbmF0aW9uICk7XHJcblx0XHR0aGlzLmdhaW4uY29ubmVjdCggdGhpcy5jb250ZXh0LmRlc3RpbmF0aW9uICk7XHJcblx0XHR0aGlzLmZpbHRlciA9IG51bGw7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5BdWRpb0xpc3RlbmVyLnByb3RvdHlwZS5zZXRGaWx0ZXIgPSBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRpZiAoIHRoaXMuZmlsdGVyICE9PSBudWxsICkge1xyXG5cclxuXHRcdHRoaXMuZ2Fpbi5kaXNjb25uZWN0KCB0aGlzLmZpbHRlciApO1xyXG5cdFx0dGhpcy5maWx0ZXIuZGlzY29ubmVjdCggdGhpcy5jb250ZXh0LmRlc3RpbmF0aW9uICk7XHJcblxyXG5cdH0gZWxzZSB7XHJcblxyXG5cdFx0dGhpcy5nYWluLmRpc2Nvbm5lY3QoIHRoaXMuY29udGV4dC5kZXN0aW5hdGlvbiApO1xyXG5cclxuXHR9XHJcblxyXG5cdHRoaXMuZmlsdGVyID0gdmFsdWU7XHJcblx0dGhpcy5nYWluLmNvbm5lY3QoIHRoaXMuZmlsdGVyICk7XHJcblx0dGhpcy5maWx0ZXIuY29ubmVjdCggdGhpcy5jb250ZXh0LmRlc3RpbmF0aW9uICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQXVkaW9MaXN0ZW5lci5wcm90b3R5cGUuZ2V0RmlsdGVyID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRyZXR1cm4gdGhpcy5maWx0ZXI7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQXVkaW9MaXN0ZW5lci5wcm90b3R5cGUuc2V0TWFzdGVyVm9sdW1lID0gZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0dGhpcy5nYWluLmdhaW4udmFsdWUgPSB2YWx1ZTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5BdWRpb0xpc3RlbmVyLnByb3RvdHlwZS5nZXRNYXN0ZXJWb2x1bWUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHJldHVybiB0aGlzLmdhaW4uZ2Fpbi52YWx1ZTtcclxuXHJcbn07XHJcblxyXG5cclxuVEhSRUUuQXVkaW9MaXN0ZW5lci5wcm90b3R5cGUudXBkYXRlTWF0cml4V29ybGQgPSAoIGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dmFyIHBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHR2YXIgcXVhdGVybmlvbiA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XHJcblx0dmFyIHNjYWxlID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0dmFyIG9yaWVudGF0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZU1hdHJpeFdvcmxkKCBmb3JjZSApIHtcclxuXHJcblx0XHRUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUudXBkYXRlTWF0cml4V29ybGQuY2FsbCggdGhpcywgZm9yY2UgKTtcclxuXHJcblx0XHR2YXIgbGlzdGVuZXIgPSB0aGlzLmNvbnRleHQubGlzdGVuZXI7XHJcblx0XHR2YXIgdXAgPSB0aGlzLnVwO1xyXG5cclxuXHRcdHRoaXMubWF0cml4V29ybGQuZGVjb21wb3NlKCBwb3NpdGlvbiwgcXVhdGVybmlvbiwgc2NhbGUgKTtcclxuXHJcblx0XHRvcmllbnRhdGlvbi5zZXQoIDAsIDAsIC0gMSApLmFwcGx5UXVhdGVybmlvbiggcXVhdGVybmlvbiApO1xyXG5cclxuXHRcdGxpc3RlbmVyLnNldFBvc2l0aW9uKCBwb3NpdGlvbi54LCBwb3NpdGlvbi55LCBwb3NpdGlvbi56ICk7XHJcblx0XHRsaXN0ZW5lci5zZXRPcmllbnRhdGlvbiggb3JpZW50YXRpb24ueCwgb3JpZW50YXRpb24ueSwgb3JpZW50YXRpb24ueiwgdXAueCwgdXAueSwgdXAueiApO1xyXG5cclxuXHR9O1xyXG5cclxufSApKCk7XHJcblxyXG4vLyBGaWxlOnNyYy9jYW1lcmFzL0NhbWVyYS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXHJcbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxyXG4qL1xyXG5cclxuVEhSRUUuQ2FtZXJhID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMudHlwZSA9ICdDYW1lcmEnO1xyXG5cclxuXHR0aGlzLm1hdHJpeFdvcmxkSW52ZXJzZSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblx0dGhpcy5wcm9qZWN0aW9uTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5DYW1lcmEucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XHJcblRIUkVFLkNhbWVyYS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5DYW1lcmE7XHJcblxyXG5USFJFRS5DYW1lcmEucHJvdG90eXBlLmdldFdvcmxkRGlyZWN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgcXVhdGVybmlvbiA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XHJcblxyXG5cdHJldHVybiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdHRoaXMuZ2V0V29ybGRRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uICk7XHJcblxyXG5cdFx0cmV0dXJuIHJlc3VsdC5zZXQoIDAsIDAsIC0gMSApLmFwcGx5UXVhdGVybmlvbiggcXVhdGVybmlvbiApO1xyXG5cclxuXHR9O1xyXG5cclxufSgpO1xyXG5cclxuVEhSRUUuQ2FtZXJhLnByb3RvdHlwZS5sb29rQXQgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdC8vIFRoaXMgcm91dGluZSBkb2VzIG5vdCBzdXBwb3J0IGNhbWVyYXMgd2l0aCByb3RhdGVkIGFuZC9vciB0cmFuc2xhdGVkIHBhcmVudChzKVxyXG5cclxuXHR2YXIgbTEgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XHJcblxyXG5cdFx0bTEubG9va0F0KCB0aGlzLnBvc2l0aW9uLCB2ZWN0b3IsIHRoaXMudXAgKTtcclxuXHJcblx0XHR0aGlzLnF1YXRlcm5pb24uc2V0RnJvbVJvdGF0aW9uTWF0cml4KCBtMSApO1xyXG5cclxuXHR9O1xyXG5cclxufSgpO1xyXG5cclxuVEhSRUUuQ2FtZXJhLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkNhbWVyYS5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuXHRUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcclxuXHJcblx0dGhpcy5tYXRyaXhXb3JsZEludmVyc2UuY29weSggc291cmNlLm1hdHJpeFdvcmxkSW52ZXJzZSApO1xyXG5cdHRoaXMucHJvamVjdGlvbk1hdHJpeC5jb3B5KCBzb3VyY2UucHJvamVjdGlvbk1hdHJpeCApO1xyXG5cclxuXHRyZXR1cm4gdGhpcztcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9jYW1lcmFzL0N1YmVDYW1lcmEuanNcclxuXHJcbi8qKlxyXG4gKiBDYW1lcmEgZm9yIHJlbmRlcmluZyBjdWJlIG1hcHNcclxuICpcdC0gcmVuZGVycyBzY2VuZSBpbnRvIGF4aXMtYWxpZ25lZCBjdWJlXHJcbiAqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuQ3ViZUNhbWVyYSA9IGZ1bmN0aW9uICggbmVhciwgZmFyLCBjdWJlUmVzb2x1dGlvbiApIHtcclxuXHJcblx0VEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLnR5cGUgPSAnQ3ViZUNhbWVyYSc7XHJcblxyXG5cdHZhciBmb3YgPSA5MCwgYXNwZWN0ID0gMTtcclxuXHJcblx0dmFyIGNhbWVyYVBYID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyICk7XHJcblx0Y2FtZXJhUFgudXAuc2V0KCAwLCAtIDEsIDAgKTtcclxuXHRjYW1lcmFQWC5sb29rQXQoIG5ldyBUSFJFRS5WZWN0b3IzKCAxLCAwLCAwICkgKTtcclxuXHR0aGlzLmFkZCggY2FtZXJhUFggKTtcclxuXHJcblx0dmFyIGNhbWVyYU5YID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyICk7XHJcblx0Y2FtZXJhTlgudXAuc2V0KCAwLCAtIDEsIDAgKTtcclxuXHRjYW1lcmFOWC5sb29rQXQoIG5ldyBUSFJFRS5WZWN0b3IzKCAtIDEsIDAsIDAgKSApO1xyXG5cdHRoaXMuYWRkKCBjYW1lcmFOWCApO1xyXG5cclxuXHR2YXIgY2FtZXJhUFkgPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKTtcclxuXHRjYW1lcmFQWS51cC5zZXQoIDAsIDAsIDEgKTtcclxuXHRjYW1lcmFQWS5sb29rQXQoIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAxLCAwICkgKTtcclxuXHR0aGlzLmFkZCggY2FtZXJhUFkgKTtcclxuXHJcblx0dmFyIGNhbWVyYU5ZID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyICk7XHJcblx0Y2FtZXJhTlkudXAuc2V0KCAwLCAwLCAtIDEgKTtcclxuXHRjYW1lcmFOWS5sb29rQXQoIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAtIDEsIDAgKSApO1xyXG5cdHRoaXMuYWRkKCBjYW1lcmFOWSApO1xyXG5cclxuXHR2YXIgY2FtZXJhUFogPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKTtcclxuXHRjYW1lcmFQWi51cC5zZXQoIDAsIC0gMSwgMCApO1xyXG5cdGNhbWVyYVBaLmxvb2tBdCggbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDAsIDEgKSApO1xyXG5cdHRoaXMuYWRkKCBjYW1lcmFQWiApO1xyXG5cclxuXHR2YXIgY2FtZXJhTlogPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKTtcclxuXHRjYW1lcmFOWi51cC5zZXQoIDAsIC0gMSwgMCApO1xyXG5cdGNhbWVyYU5aLmxvb2tBdCggbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDAsIC0gMSApICk7XHJcblx0dGhpcy5hZGQoIGNhbWVyYU5aICk7XHJcblxyXG5cdHZhciBvcHRpb25zID0geyBmb3JtYXQ6IFRIUkVFLlJHQkZvcm1hdCwgbWFnRmlsdGVyOiBUSFJFRS5MaW5lYXJGaWx0ZXIsIG1pbkZpbHRlcjogVEhSRUUuTGluZWFyRmlsdGVyIH07XHJcblxyXG5cdHRoaXMucmVuZGVyVGFyZ2V0ID0gbmV3IFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZSggY3ViZVJlc29sdXRpb24sIGN1YmVSZXNvbHV0aW9uLCBvcHRpb25zICk7XHJcblxyXG5cdHRoaXMudXBkYXRlQ3ViZU1hcCA9IGZ1bmN0aW9uICggcmVuZGVyZXIsIHNjZW5lICkge1xyXG5cclxuXHRcdGlmICggdGhpcy5wYXJlbnQgPT09IG51bGwgKSB0aGlzLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XHJcblxyXG5cdFx0dmFyIHJlbmRlclRhcmdldCA9IHRoaXMucmVuZGVyVGFyZ2V0O1xyXG5cdFx0dmFyIGdlbmVyYXRlTWlwbWFwcyA9IHJlbmRlclRhcmdldC50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcztcclxuXHJcblx0XHRyZW5kZXJUYXJnZXQudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcclxuXHJcblx0XHRyZW5kZXJUYXJnZXQuYWN0aXZlQ3ViZUZhY2UgPSAwO1xyXG5cdFx0cmVuZGVyZXIucmVuZGVyKCBzY2VuZSwgY2FtZXJhUFgsIHJlbmRlclRhcmdldCApO1xyXG5cclxuXHRcdHJlbmRlclRhcmdldC5hY3RpdmVDdWJlRmFjZSA9IDE7XHJcblx0XHRyZW5kZXJlci5yZW5kZXIoIHNjZW5lLCBjYW1lcmFOWCwgcmVuZGVyVGFyZ2V0ICk7XHJcblxyXG5cdFx0cmVuZGVyVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlID0gMjtcclxuXHRcdHJlbmRlcmVyLnJlbmRlciggc2NlbmUsIGNhbWVyYVBZLCByZW5kZXJUYXJnZXQgKTtcclxuXHJcblx0XHRyZW5kZXJUYXJnZXQuYWN0aXZlQ3ViZUZhY2UgPSAzO1xyXG5cdFx0cmVuZGVyZXIucmVuZGVyKCBzY2VuZSwgY2FtZXJhTlksIHJlbmRlclRhcmdldCApO1xyXG5cclxuXHRcdHJlbmRlclRhcmdldC5hY3RpdmVDdWJlRmFjZSA9IDQ7XHJcblx0XHRyZW5kZXJlci5yZW5kZXIoIHNjZW5lLCBjYW1lcmFQWiwgcmVuZGVyVGFyZ2V0ICk7XHJcblxyXG5cdFx0cmVuZGVyVGFyZ2V0LnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gZ2VuZXJhdGVNaXBtYXBzO1xyXG5cclxuXHRcdHJlbmRlclRhcmdldC5hY3RpdmVDdWJlRmFjZSA9IDU7XHJcblx0XHRyZW5kZXJlci5yZW5kZXIoIHNjZW5lLCBjYW1lcmFOWiwgcmVuZGVyVGFyZ2V0ICk7XHJcblxyXG5cdFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KCBudWxsICk7XHJcblxyXG5cdH07XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQ3ViZUNhbWVyYS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcclxuVEhSRUUuQ3ViZUNhbWVyYS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5DdWJlQ2FtZXJhO1xyXG5cclxuLy8gRmlsZTpzcmMvY2FtZXJhcy9PcnRob2dyYXBoaWNDYW1lcmEuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYSA9IGZ1bmN0aW9uICggbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tLCBuZWFyLCBmYXIgKSB7XHJcblxyXG5cdFRIUkVFLkNhbWVyYS5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMudHlwZSA9ICdPcnRob2dyYXBoaWNDYW1lcmEnO1xyXG5cclxuXHR0aGlzLnpvb20gPSAxO1xyXG5cclxuXHR0aGlzLmxlZnQgPSBsZWZ0O1xyXG5cdHRoaXMucmlnaHQgPSByaWdodDtcclxuXHR0aGlzLnRvcCA9IHRvcDtcclxuXHR0aGlzLmJvdHRvbSA9IGJvdHRvbTtcclxuXHJcblx0dGhpcy5uZWFyID0gKCBuZWFyICE9PSB1bmRlZmluZWQgKSA/IG5lYXIgOiAwLjE7XHJcblx0dGhpcy5mYXIgPSAoIGZhciAhPT0gdW5kZWZpbmVkICkgPyBmYXIgOiAyMDAwO1xyXG5cclxuXHR0aGlzLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5PcnRob2dyYXBoaWNDYW1lcmEucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQ2FtZXJhLnByb3RvdHlwZSApO1xyXG5USFJFRS5PcnRob2dyYXBoaWNDYW1lcmEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhO1xyXG5cclxuVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhLnByb3RvdHlwZS51cGRhdGVQcm9qZWN0aW9uTWF0cml4ID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgZHggPSAoIHRoaXMucmlnaHQgLSB0aGlzLmxlZnQgKSAvICggMiAqIHRoaXMuem9vbSApO1xyXG5cdHZhciBkeSA9ICggdGhpcy50b3AgLSB0aGlzLmJvdHRvbSApIC8gKCAyICogdGhpcy56b29tICk7XHJcblx0dmFyIGN4ID0gKCB0aGlzLnJpZ2h0ICsgdGhpcy5sZWZ0ICkgLyAyO1xyXG5cdHZhciBjeSA9ICggdGhpcy50b3AgKyB0aGlzLmJvdHRvbSApIC8gMjtcclxuXHJcblx0dGhpcy5wcm9qZWN0aW9uTWF0cml4Lm1ha2VPcnRob2dyYXBoaWMoIGN4IC0gZHgsIGN4ICsgZHgsIGN5ICsgZHksIGN5IC0gZHksIHRoaXMubmVhciwgdGhpcy5mYXIgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5PcnRob2dyYXBoaWNDYW1lcmEucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcblx0VEhSRUUuQ2FtZXJhLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xyXG5cclxuXHR0aGlzLmxlZnQgPSBzb3VyY2UubGVmdDtcclxuXHR0aGlzLnJpZ2h0ID0gc291cmNlLnJpZ2h0O1xyXG5cdHRoaXMudG9wID0gc291cmNlLnRvcDtcclxuXHR0aGlzLmJvdHRvbSA9IHNvdXJjZS5ib3R0b207XHJcblx0dGhpcy5uZWFyID0gc291cmNlLm5lYXI7XHJcblx0dGhpcy5mYXIgPSBzb3VyY2UuZmFyO1xyXG5cclxuXHR0aGlzLnpvb20gPSBzb3VyY2Uuem9vbTtcclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoIG1ldGEgKSB7XHJcblxyXG5cdHZhciBkYXRhID0gVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzLCBtZXRhICk7XHJcblxyXG5cdGRhdGEub2JqZWN0Lnpvb20gPSB0aGlzLnpvb207XHJcblx0ZGF0YS5vYmplY3QubGVmdCA9IHRoaXMubGVmdDtcclxuXHRkYXRhLm9iamVjdC5yaWdodCA9IHRoaXMucmlnaHQ7XHJcblx0ZGF0YS5vYmplY3QudG9wID0gdGhpcy50b3A7XHJcblx0ZGF0YS5vYmplY3QuYm90dG9tID0gdGhpcy5ib3R0b207XHJcblx0ZGF0YS5vYmplY3QubmVhciA9IHRoaXMubmVhcjtcclxuXHRkYXRhLm9iamVjdC5mYXIgPSB0aGlzLmZhcjtcclxuXHJcblx0cmV0dXJuIGRhdGE7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvY2FtZXJhcy9QZXJzcGVjdGl2ZUNhbWVyYS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgZ3JlZ2dtYW4gLyBodHRwOi8vZ2FtZXMuZ3JlZ2dtYW4uY29tL1xyXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXHJcbiAqL1xyXG5cclxuVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEgPSBmdW5jdGlvbiAoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKSB7XHJcblxyXG5cdFRIUkVFLkNhbWVyYS5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMudHlwZSA9ICdQZXJzcGVjdGl2ZUNhbWVyYSc7XHJcblxyXG5cdHRoaXMuZm9jYWxMZW5ndGggPSAxMDtcclxuXHR0aGlzLnpvb20gPSAxO1xyXG5cclxuXHR0aGlzLmZvdiA9IGZvdiAhPT0gdW5kZWZpbmVkID8gZm92IDogNTA7XHJcblx0dGhpcy5hc3BlY3QgPSBhc3BlY3QgIT09IHVuZGVmaW5lZCA/IGFzcGVjdCA6IDE7XHJcblx0dGhpcy5uZWFyID0gbmVhciAhPT0gdW5kZWZpbmVkID8gbmVhciA6IDAuMTtcclxuXHR0aGlzLmZhciA9IGZhciAhPT0gdW5kZWZpbmVkID8gZmFyIDogMjAwMDtcclxuXHJcblx0dGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQ2FtZXJhLnByb3RvdHlwZSApO1xyXG5USFJFRS5QZXJzcGVjdGl2ZUNhbWVyYS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYTtcclxuXHJcblxyXG4vKipcclxuICogVXNlcyBGb2NhbCBMZW5ndGggKGluIG1tKSB0byBlc3RpbWF0ZSBhbmQgc2V0IEZPVlxyXG4gKiAzNW1tIChmdWxsLWZyYW1lKSBjYW1lcmEgaXMgdXNlZCBpZiBmcmFtZSBzaXplIGlzIG5vdCBzcGVjaWZpZWQ7XHJcbiAqIEZvcm11bGEgYmFzZWQgb24gaHR0cDovL3d3dy5ib2JhdGtpbnMuY29tL3Bob3RvZ3JhcGh5L3RlY2huaWNhbC9maWVsZF9vZl92aWV3Lmh0bWxcclxuICovXHJcblxyXG5USFJFRS5QZXJzcGVjdGl2ZUNhbWVyYS5wcm90b3R5cGUuc2V0TGVucyA9IGZ1bmN0aW9uICggZm9jYWxMZW5ndGgsIGZyYW1lSGVpZ2h0ICkge1xyXG5cclxuXHRpZiAoIGZyYW1lSGVpZ2h0ID09PSB1bmRlZmluZWQgKSBmcmFtZUhlaWdodCA9IDI0O1xyXG5cclxuXHR0aGlzLmZvdiA9IDIgKiBUSFJFRS5NYXRoLnJhZFRvRGVnKCBNYXRoLmF0YW4oIGZyYW1lSGVpZ2h0IC8gKCBmb2NhbExlbmd0aCAqIDIgKSApICk7XHJcblx0dGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XHJcblxyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBTZXRzIGFuIG9mZnNldCBpbiBhIGxhcmdlciBmcnVzdHVtLiBUaGlzIGlzIHVzZWZ1bCBmb3IgbXVsdGktd2luZG93IG9yXHJcbiAqIG11bHRpLW1vbml0b3IvbXVsdGktbWFjaGluZSBzZXR1cHMuXHJcbiAqXHJcbiAqIEZvciBleGFtcGxlLCBpZiB5b3UgaGF2ZSAzeDIgbW9uaXRvcnMgYW5kIGVhY2ggbW9uaXRvciBpcyAxOTIweDEwODAgYW5kXHJcbiAqIHRoZSBtb25pdG9ycyBhcmUgaW4gZ3JpZCBsaWtlIHRoaXNcclxuICpcclxuICogICArLS0tKy0tLSstLS0rXHJcbiAqICAgfCBBIHwgQiB8IEMgfFxyXG4gKiAgICstLS0rLS0tKy0tLStcclxuICogICB8IEQgfCBFIHwgRiB8XHJcbiAqICAgKy0tLSstLS0rLS0tK1xyXG4gKlxyXG4gKiB0aGVuIGZvciBlYWNoIG1vbml0b3IgeW91IHdvdWxkIGNhbGwgaXQgbGlrZSB0aGlzXHJcbiAqXHJcbiAqICAgdmFyIHcgPSAxOTIwO1xyXG4gKiAgIHZhciBoID0gMTA4MDtcclxuICogICB2YXIgZnVsbFdpZHRoID0gdyAqIDM7XHJcbiAqICAgdmFyIGZ1bGxIZWlnaHQgPSBoICogMjtcclxuICpcclxuICogICAtLUEtLVxyXG4gKiAgIGNhbWVyYS5zZXRPZmZzZXQoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgdyAqIDAsIGggKiAwLCB3LCBoICk7XHJcbiAqICAgLS1CLS1cclxuICogICBjYW1lcmEuc2V0T2Zmc2V0KCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHcgKiAxLCBoICogMCwgdywgaCApO1xyXG4gKiAgIC0tQy0tXHJcbiAqICAgY2FtZXJhLnNldE9mZnNldCggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB3ICogMiwgaCAqIDAsIHcsIGggKTtcclxuICogICAtLUQtLVxyXG4gKiAgIGNhbWVyYS5zZXRPZmZzZXQoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgdyAqIDAsIGggKiAxLCB3LCBoICk7XHJcbiAqICAgLS1FLS1cclxuICogICBjYW1lcmEuc2V0T2Zmc2V0KCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHcgKiAxLCBoICogMSwgdywgaCApO1xyXG4gKiAgIC0tRi0tXHJcbiAqICAgY2FtZXJhLnNldE9mZnNldCggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB3ICogMiwgaCAqIDEsIHcsIGggKTtcclxuICpcclxuICogICBOb3RlIHRoZXJlIGlzIG5vIHJlYXNvbiBtb25pdG9ycyBoYXZlIHRvIGJlIHRoZSBzYW1lIHNpemUgb3IgaW4gYSBncmlkLlxyXG4gKi9cclxuXHJcblRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhLnByb3RvdHlwZS5zZXRWaWV3T2Zmc2V0ID0gZnVuY3Rpb24gKCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHgsIHksIHdpZHRoLCBoZWlnaHQgKSB7XHJcblxyXG5cdHRoaXMuZnVsbFdpZHRoID0gZnVsbFdpZHRoO1xyXG5cdHRoaXMuZnVsbEhlaWdodCA9IGZ1bGxIZWlnaHQ7XHJcblx0dGhpcy54ID0geDtcclxuXHR0aGlzLnkgPSB5O1xyXG5cdHRoaXMud2lkdGggPSB3aWR0aDtcclxuXHR0aGlzLmhlaWdodCA9IGhlaWdodDtcclxuXHJcblx0dGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XHJcblxyXG59O1xyXG5cclxuXHJcblRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhLnByb3RvdHlwZS51cGRhdGVQcm9qZWN0aW9uTWF0cml4ID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgZm92ID0gVEhSRUUuTWF0aC5yYWRUb0RlZyggMiAqIE1hdGguYXRhbiggTWF0aC50YW4oIFRIUkVFLk1hdGguZGVnVG9SYWQoIHRoaXMuZm92ICkgKiAwLjUgKSAvIHRoaXMuem9vbSApICk7XHJcblxyXG5cdGlmICggdGhpcy5mdWxsV2lkdGggKSB7XHJcblxyXG5cdFx0dmFyIGFzcGVjdCA9IHRoaXMuZnVsbFdpZHRoIC8gdGhpcy5mdWxsSGVpZ2h0O1xyXG5cdFx0dmFyIHRvcCA9IE1hdGgudGFuKCBUSFJFRS5NYXRoLmRlZ1RvUmFkKCBmb3YgKiAwLjUgKSApICogdGhpcy5uZWFyO1xyXG5cdFx0dmFyIGJvdHRvbSA9IC0gdG9wO1xyXG5cdFx0dmFyIGxlZnQgPSBhc3BlY3QgKiBib3R0b207XHJcblx0XHR2YXIgcmlnaHQgPSBhc3BlY3QgKiB0b3A7XHJcblx0XHR2YXIgd2lkdGggPSBNYXRoLmFicyggcmlnaHQgLSBsZWZ0ICk7XHJcblx0XHR2YXIgaGVpZ2h0ID0gTWF0aC5hYnMoIHRvcCAtIGJvdHRvbSApO1xyXG5cclxuXHRcdHRoaXMucHJvamVjdGlvbk1hdHJpeC5tYWtlRnJ1c3R1bShcclxuXHRcdFx0bGVmdCArIHRoaXMueCAqIHdpZHRoIC8gdGhpcy5mdWxsV2lkdGgsXHJcblx0XHRcdGxlZnQgKyAoIHRoaXMueCArIHRoaXMud2lkdGggKSAqIHdpZHRoIC8gdGhpcy5mdWxsV2lkdGgsXHJcblx0XHRcdHRvcCAtICggdGhpcy55ICsgdGhpcy5oZWlnaHQgKSAqIGhlaWdodCAvIHRoaXMuZnVsbEhlaWdodCxcclxuXHRcdFx0dG9wIC0gdGhpcy55ICogaGVpZ2h0IC8gdGhpcy5mdWxsSGVpZ2h0LFxyXG5cdFx0XHR0aGlzLm5lYXIsXHJcblx0XHRcdHRoaXMuZmFyXHJcblx0XHQpO1xyXG5cclxuXHR9IGVsc2Uge1xyXG5cclxuXHRcdHRoaXMucHJvamVjdGlvbk1hdHJpeC5tYWtlUGVyc3BlY3RpdmUoIGZvdiwgdGhpcy5hc3BlY3QsIHRoaXMubmVhciwgdGhpcy5mYXIgKTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcblRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG5cdFRIUkVFLkNhbWVyYS5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcclxuXHJcblx0dGhpcy5mb2NhbExlbmd0aCA9IHNvdXJjZS5mb2NhbExlbmd0aDtcclxuXHR0aGlzLnpvb20gPSBzb3VyY2Uuem9vbTtcclxuXHJcblx0dGhpcy5mb3YgPSBzb3VyY2UuZm92O1xyXG5cdHRoaXMuYXNwZWN0ID0gc291cmNlLmFzcGVjdDtcclxuXHR0aGlzLm5lYXIgPSBzb3VyY2UubmVhcjtcclxuXHR0aGlzLmZhciA9IHNvdXJjZS5mYXI7XHJcblxyXG5cdHJldHVybiB0aGlzO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoIG1ldGEgKSB7XHJcblxyXG5cdHZhciBkYXRhID0gVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzLCBtZXRhICk7XHJcblxyXG5cdGRhdGEub2JqZWN0LmZvY2FsTGVuZ3RoID0gdGhpcy5mb2NhbExlbmd0aDtcclxuXHRkYXRhLm9iamVjdC56b29tID0gdGhpcy56b29tO1xyXG5cclxuXHRkYXRhLm9iamVjdC5mb3YgPSB0aGlzLmZvdjtcclxuXHRkYXRhLm9iamVjdC5hc3BlY3QgPSB0aGlzLmFzcGVjdDtcclxuXHRkYXRhLm9iamVjdC5uZWFyID0gdGhpcy5uZWFyO1xyXG5cdGRhdGEub2JqZWN0LmZhciA9IHRoaXMuZmFyO1xyXG5cclxuXHRyZXR1cm4gZGF0YTtcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9jYW1lcmFzL1N0ZXJlb0NhbWVyYS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuU3RlcmVvQ2FtZXJhID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR0aGlzLnR5cGUgPSAnU3RlcmVvQ2FtZXJhJztcclxuXHJcblx0dGhpcy5hc3BlY3QgPSAxO1xyXG5cclxuXHR0aGlzLmNhbWVyYUwgPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoKTtcclxuXHR0aGlzLmNhbWVyYUwubGF5ZXJzLmVuYWJsZSggMSApO1xyXG5cdHRoaXMuY2FtZXJhTC5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XHJcblxyXG5cdHRoaXMuY2FtZXJhUiA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSgpO1xyXG5cdHRoaXMuY2FtZXJhUi5sYXllcnMuZW5hYmxlKCAyICk7XHJcblx0dGhpcy5jYW1lcmFSLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5TdGVyZW9DYW1lcmEucHJvdG90eXBlID0ge1xyXG5cclxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuU3RlcmVvQ2FtZXJhLFxyXG5cclxuXHR1cGRhdGU6ICggZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBmb2NhbExlbmd0aCwgZm92LCBhc3BlY3QsIG5lYXIsIGZhcjtcclxuXHJcblx0XHR2YXIgZXllUmlnaHQgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xyXG5cdFx0dmFyIGV5ZUxlZnQgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiB1cGRhdGUgKCBjYW1lcmEgKSB7XHJcblxyXG5cdFx0XHR2YXIgbmVlZHNVcGRhdGUgPSBmb2NhbExlbmd0aCAhPT0gY2FtZXJhLmZvY2FsTGVuZ3RoIHx8IGZvdiAhPT0gY2FtZXJhLmZvdiB8fFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhc3BlY3QgIT09IGNhbWVyYS5hc3BlY3QgKiB0aGlzLmFzcGVjdCB8fCBuZWFyICE9PSBjYW1lcmEubmVhciB8fFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRmYXIgIT09IGNhbWVyYS5mYXI7XHJcblxyXG5cdFx0XHRpZiAoIG5lZWRzVXBkYXRlICkge1xyXG5cclxuXHRcdFx0XHRmb2NhbExlbmd0aCA9IGNhbWVyYS5mb2NhbExlbmd0aDtcclxuXHRcdFx0XHRmb3YgPSBjYW1lcmEuZm92O1xyXG5cdFx0XHRcdGFzcGVjdCA9IGNhbWVyYS5hc3BlY3QgKiB0aGlzLmFzcGVjdDtcclxuXHRcdFx0XHRuZWFyID0gY2FtZXJhLm5lYXI7XHJcblx0XHRcdFx0ZmFyID0gY2FtZXJhLmZhcjtcclxuXHJcblx0XHRcdFx0Ly8gT2ZmLWF4aXMgc3RlcmVvc2NvcGljIGVmZmVjdCBiYXNlZCBvblxyXG5cdFx0XHRcdC8vIGh0dHA6Ly9wYXVsYm91cmtlLm5ldC9zdGVyZW9ncmFwaGljcy9zdGVyZW9yZW5kZXIvXHJcblxyXG5cdFx0XHRcdHZhciBwcm9qZWN0aW9uTWF0cml4ID0gY2FtZXJhLnByb2plY3Rpb25NYXRyaXguY2xvbmUoKTtcclxuXHRcdFx0XHR2YXIgZXllU2VwID0gMC4wNjQgLyAyO1xyXG5cdFx0XHRcdHZhciBleWVTZXBPblByb2plY3Rpb24gPSBleWVTZXAgKiBuZWFyIC8gZm9jYWxMZW5ndGg7XHJcblx0XHRcdFx0dmFyIHltYXggPSBuZWFyICogTWF0aC50YW4oIFRIUkVFLk1hdGguZGVnVG9SYWQoIGZvdiAqIDAuNSApICk7XHJcblx0XHRcdFx0dmFyIHhtaW4sIHhtYXg7XHJcblxyXG5cdFx0XHRcdC8vIHRyYW5zbGF0ZSB4T2Zmc2V0XHJcblxyXG5cdFx0XHRcdGV5ZUxlZnQuZWxlbWVudHNbIDEyIF0gPSAtIGV5ZVNlcDtcclxuXHRcdFx0XHRleWVSaWdodC5lbGVtZW50c1sgMTIgXSA9IGV5ZVNlcDtcclxuXHJcblx0XHRcdFx0Ly8gZm9yIGxlZnQgZXllXHJcblxyXG5cdFx0XHRcdHhtaW4gPSAtIHltYXggKiBhc3BlY3QgKyBleWVTZXBPblByb2plY3Rpb247XHJcblx0XHRcdFx0eG1heCA9IHltYXggKiBhc3BlY3QgKyBleWVTZXBPblByb2plY3Rpb247XHJcblxyXG5cdFx0XHRcdHByb2plY3Rpb25NYXRyaXguZWxlbWVudHNbIDAgXSA9IDIgKiBuZWFyIC8gKCB4bWF4IC0geG1pbiApO1xyXG5cdFx0XHRcdHByb2plY3Rpb25NYXRyaXguZWxlbWVudHNbIDggXSA9ICggeG1heCArIHhtaW4gKSAvICggeG1heCAtIHhtaW4gKTtcclxuXHJcblx0XHRcdFx0dGhpcy5jYW1lcmFMLnByb2plY3Rpb25NYXRyaXguY29weSggcHJvamVjdGlvbk1hdHJpeCApO1xyXG5cclxuXHRcdFx0XHQvLyBmb3IgcmlnaHQgZXllXHJcblxyXG5cdFx0XHRcdHhtaW4gPSAtIHltYXggKiBhc3BlY3QgLSBleWVTZXBPblByb2plY3Rpb247XHJcblx0XHRcdFx0eG1heCA9IHltYXggKiBhc3BlY3QgLSBleWVTZXBPblByb2plY3Rpb247XHJcblxyXG5cdFx0XHRcdHByb2plY3Rpb25NYXRyaXguZWxlbWVudHNbIDAgXSA9IDIgKiBuZWFyIC8gKCB4bWF4IC0geG1pbiApO1xyXG5cdFx0XHRcdHByb2plY3Rpb25NYXRyaXguZWxlbWVudHNbIDggXSA9ICggeG1heCArIHhtaW4gKSAvICggeG1heCAtIHhtaW4gKTtcclxuXHJcblx0XHRcdFx0dGhpcy5jYW1lcmFSLnByb2plY3Rpb25NYXRyaXguY29weSggcHJvamVjdGlvbk1hdHJpeCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5jYW1lcmFMLm1hdHJpeFdvcmxkLmNvcHkoIGNhbWVyYS5tYXRyaXhXb3JsZCApLm11bHRpcGx5KCBleWVMZWZ0ICk7XHJcblx0XHRcdHRoaXMuY2FtZXJhUi5tYXRyaXhXb3JsZC5jb3B5KCBjYW1lcmEubWF0cml4V29ybGQgKS5tdWx0aXBseSggZXllUmlnaHQgKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9ICkoKVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2xpZ2h0cy9MaWdodC5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuTGlnaHQgPSBmdW5jdGlvbiAoIGNvbG9yLCBpbnRlbnNpdHkgKSB7XHJcblxyXG5cdFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy50eXBlID0gJ0xpZ2h0JztcclxuXHJcblx0dGhpcy5jb2xvciA9IG5ldyBUSFJFRS5Db2xvciggY29sb3IgKTtcclxuXHR0aGlzLmludGVuc2l0eSA9IGludGVuc2l0eSAhPT0gdW5kZWZpbmVkID8gaW50ZW5zaXR5IDogMTtcclxuXHJcblx0dGhpcy5yZWNlaXZlU2hhZG93ID0gdW5kZWZpbmVkO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkxpZ2h0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xyXG5USFJFRS5MaWdodC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5MaWdodDtcclxuXHJcblRIUkVFLkxpZ2h0LnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG5cdFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xyXG5cclxuXHR0aGlzLmNvbG9yLmNvcHkoIHNvdXJjZS5jb2xvciApO1xyXG5cdHRoaXMuaW50ZW5zaXR5ID0gc291cmNlLmludGVuc2l0eTtcclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTGlnaHQucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICggbWV0YSApIHtcclxuXHJcblx0dmFyIGRhdGEgPSBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMsIG1ldGEgKTtcclxuXHJcblx0ZGF0YS5vYmplY3QuY29sb3IgPSB0aGlzLmNvbG9yLmdldEhleCgpO1xyXG5cdGRhdGEub2JqZWN0LmludGVuc2l0eSA9IHRoaXMuaW50ZW5zaXR5O1xyXG5cclxuXHRpZiAoIHRoaXMuZ3JvdW5kQ29sb3IgIT09IHVuZGVmaW5lZCApIGRhdGEub2JqZWN0Lmdyb3VuZENvbG9yID0gdGhpcy5ncm91bmRDb2xvci5nZXRIZXgoKTtcclxuXHJcblx0aWYgKCB0aGlzLmRpc3RhbmNlICE9PSB1bmRlZmluZWQgKSBkYXRhLm9iamVjdC5kaXN0YW5jZSA9IHRoaXMuZGlzdGFuY2U7XHJcblx0aWYgKCB0aGlzLmFuZ2xlICE9PSB1bmRlZmluZWQgKSBkYXRhLm9iamVjdC5hbmdsZSA9IHRoaXMuYW5nbGU7XHJcblx0aWYgKCB0aGlzLmRlY2F5ICE9PSB1bmRlZmluZWQgKSBkYXRhLm9iamVjdC5kZWNheSA9IHRoaXMuZGVjYXk7XHJcblx0aWYgKCB0aGlzLmV4cG9uZW50ICE9PSB1bmRlZmluZWQgKSBkYXRhLm9iamVjdC5leHBvbmVudCA9IHRoaXMuZXhwb25lbnQ7XHJcblxyXG5cdHJldHVybiBkYXRhO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2xpZ2h0cy9MaWdodFNoYWRvdy5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuTGlnaHRTaGFkb3cgPSBmdW5jdGlvbiAoIGNhbWVyYSApIHtcclxuXHJcblx0dGhpcy5jYW1lcmEgPSBjYW1lcmE7XHJcblxyXG5cdHRoaXMuYmlhcyA9IDA7XHJcblx0dGhpcy5yYWRpdXMgPSAxO1xyXG5cclxuXHR0aGlzLm1hcFNpemUgPSBuZXcgVEhSRUUuVmVjdG9yMiggNTEyLCA1MTIgKTtcclxuXHJcblx0dGhpcy5tYXAgPSBudWxsO1xyXG5cdHRoaXMubWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5MaWdodFNoYWRvdy5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5MaWdodFNoYWRvdyxcclxuXHJcblx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG5cdFx0dGhpcy5jYW1lcmEgPSBzb3VyY2UuY2FtZXJhLmNsb25lKCk7XHJcblxyXG5cdFx0dGhpcy5iaWFzID0gc291cmNlLmJpYXM7XHJcblx0XHR0aGlzLnJhZGl1cyA9IHNvdXJjZS5yYWRpdXM7XHJcblxyXG5cdFx0dGhpcy5tYXBTaXplLmNvcHkoIHNvdXJjZS5tYXBTaXplICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbGlnaHRzL0FtYmllbnRMaWdodC5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuQW1iaWVudExpZ2h0ID0gZnVuY3Rpb24gKCBjb2xvciwgaW50ZW5zaXR5ICkge1xyXG5cclxuXHRUSFJFRS5MaWdodC5jYWxsKCB0aGlzLCBjb2xvciwgaW50ZW5zaXR5ICk7XHJcblxyXG5cdHRoaXMudHlwZSA9ICdBbWJpZW50TGlnaHQnO1xyXG5cclxuXHR0aGlzLmNhc3RTaGFkb3cgPSB1bmRlZmluZWQ7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQW1iaWVudExpZ2h0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpZ2h0LnByb3RvdHlwZSApO1xyXG5USFJFRS5BbWJpZW50TGlnaHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQW1iaWVudExpZ2h0O1xyXG5cclxuLy8gRmlsZTpzcmMvbGlnaHRzL0RpcmVjdGlvbmFsTGlnaHQuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkRpcmVjdGlvbmFsTGlnaHQgPSBmdW5jdGlvbiAoIGNvbG9yLCBpbnRlbnNpdHkgKSB7XHJcblxyXG5cdFRIUkVFLkxpZ2h0LmNhbGwoIHRoaXMsIGNvbG9yLCBpbnRlbnNpdHkgKTtcclxuXHJcblx0dGhpcy50eXBlID0gJ0RpcmVjdGlvbmFsTGlnaHQnO1xyXG5cclxuXHR0aGlzLnBvc2l0aW9uLnNldCggMCwgMSwgMCApO1xyXG5cdHRoaXMudXBkYXRlTWF0cml4KCk7XHJcblxyXG5cdHRoaXMudGFyZ2V0ID0gbmV3IFRIUkVFLk9iamVjdDNEKCk7XHJcblxyXG5cdHRoaXMuc2hhZG93ID0gbmV3IFRIUkVFLkxpZ2h0U2hhZG93KCBuZXcgVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhKCAtIDUsIDUsIDUsIC0gNSwgMC41LCA1MDAgKSApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkRpcmVjdGlvbmFsTGlnaHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGlnaHQucHJvdG90eXBlICk7XHJcblRIUkVFLkRpcmVjdGlvbmFsTGlnaHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuRGlyZWN0aW9uYWxMaWdodDtcclxuXHJcblRIUkVFLkRpcmVjdGlvbmFsTGlnaHQucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcblx0VEhSRUUuTGlnaHQucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XHJcblxyXG5cdHRoaXMudGFyZ2V0ID0gc291cmNlLnRhcmdldC5jbG9uZSgpO1xyXG5cclxuXHR0aGlzLnNoYWRvdyA9IHNvdXJjZS5zaGFkb3cuY2xvbmUoKTtcclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbGlnaHRzL0hlbWlzcGhlcmVMaWdodC5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuSGVtaXNwaGVyZUxpZ2h0ID0gZnVuY3Rpb24gKCBza3lDb2xvciwgZ3JvdW5kQ29sb3IsIGludGVuc2l0eSApIHtcclxuXHJcblx0VEhSRUUuTGlnaHQuY2FsbCggdGhpcywgc2t5Q29sb3IsIGludGVuc2l0eSApO1xyXG5cclxuXHR0aGlzLnR5cGUgPSAnSGVtaXNwaGVyZUxpZ2h0JztcclxuXHJcblx0dGhpcy5jYXN0U2hhZG93ID0gdW5kZWZpbmVkO1xyXG5cclxuXHR0aGlzLnBvc2l0aW9uLnNldCggMCwgMSwgMCApO1xyXG5cdHRoaXMudXBkYXRlTWF0cml4KCk7XHJcblxyXG5cdHRoaXMuZ3JvdW5kQ29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIGdyb3VuZENvbG9yICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuSGVtaXNwaGVyZUxpZ2h0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpZ2h0LnByb3RvdHlwZSApO1xyXG5USFJFRS5IZW1pc3BoZXJlTGlnaHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuSGVtaXNwaGVyZUxpZ2h0O1xyXG5cclxuVEhSRUUuSGVtaXNwaGVyZUxpZ2h0LnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG5cdFRIUkVFLkxpZ2h0LnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xyXG5cclxuXHR0aGlzLmdyb3VuZENvbG9yLmNvcHkoIHNvdXJjZS5ncm91bmRDb2xvciApO1xyXG5cclxuXHRyZXR1cm4gdGhpcztcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9saWdodHMvUG9pbnRMaWdodC5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuXHJcblRIUkVFLlBvaW50TGlnaHQgPSBmdW5jdGlvbiAoIGNvbG9yLCBpbnRlbnNpdHksIGRpc3RhbmNlLCBkZWNheSApIHtcclxuXHJcblx0VEhSRUUuTGlnaHQuY2FsbCggdGhpcywgY29sb3IsIGludGVuc2l0eSApO1xyXG5cclxuXHR0aGlzLnR5cGUgPSAnUG9pbnRMaWdodCc7XHJcblxyXG5cdHRoaXMuZGlzdGFuY2UgPSAoIGRpc3RhbmNlICE9PSB1bmRlZmluZWQgKSA/IGRpc3RhbmNlIDogMDtcclxuXHR0aGlzLmRlY2F5ID0gKCBkZWNheSAhPT0gdW5kZWZpbmVkICkgPyBkZWNheSA6IDE7XHQvLyBmb3IgcGh5c2ljYWxseSBjb3JyZWN0IGxpZ2h0cywgc2hvdWxkIGJlIDIuXHJcblxyXG5cdHRoaXMuc2hhZG93ID0gbmV3IFRIUkVFLkxpZ2h0U2hhZG93KCBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoIDkwLCAxLCAwLjUsIDUwMCApICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUG9pbnRMaWdodC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaWdodC5wcm90b3R5cGUgKTtcclxuVEhSRUUuUG9pbnRMaWdodC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Qb2ludExpZ2h0O1xyXG5cclxuVEhSRUUuUG9pbnRMaWdodC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuXHRUSFJFRS5MaWdodC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcclxuXHJcblx0dGhpcy5kaXN0YW5jZSA9IHNvdXJjZS5kaXN0YW5jZTtcclxuXHR0aGlzLmRlY2F5ID0gc291cmNlLmRlY2F5O1xyXG5cclxuXHR0aGlzLnNoYWRvdyA9IHNvdXJjZS5zaGFkb3cuY2xvbmUoKTtcclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbGlnaHRzL1Nwb3RMaWdodC5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuU3BvdExpZ2h0ID0gZnVuY3Rpb24gKCBjb2xvciwgaW50ZW5zaXR5LCBkaXN0YW5jZSwgYW5nbGUsIGV4cG9uZW50LCBkZWNheSApIHtcclxuXHJcblx0VEhSRUUuTGlnaHQuY2FsbCggdGhpcywgY29sb3IsIGludGVuc2l0eSApO1xyXG5cclxuXHR0aGlzLnR5cGUgPSAnU3BvdExpZ2h0JztcclxuXHJcblx0dGhpcy5wb3NpdGlvbi5zZXQoIDAsIDEsIDAgKTtcclxuXHR0aGlzLnVwZGF0ZU1hdHJpeCgpO1xyXG5cclxuXHR0aGlzLnRhcmdldCA9IG5ldyBUSFJFRS5PYmplY3QzRCgpO1xyXG5cclxuXHR0aGlzLmRpc3RhbmNlID0gKCBkaXN0YW5jZSAhPT0gdW5kZWZpbmVkICkgPyBkaXN0YW5jZSA6IDA7XHJcblx0dGhpcy5hbmdsZSA9ICggYW5nbGUgIT09IHVuZGVmaW5lZCApID8gYW5nbGUgOiBNYXRoLlBJIC8gMztcclxuXHR0aGlzLmV4cG9uZW50ID0gKCBleHBvbmVudCAhPT0gdW5kZWZpbmVkICkgPyBleHBvbmVudCA6IDEwO1xyXG5cdHRoaXMuZGVjYXkgPSAoIGRlY2F5ICE9PSB1bmRlZmluZWQgKSA/IGRlY2F5IDogMTtcdC8vIGZvciBwaHlzaWNhbGx5IGNvcnJlY3QgbGlnaHRzLCBzaG91bGQgYmUgMi5cclxuXHJcblx0dGhpcy5zaGFkb3cgPSBuZXcgVEhSRUUuTGlnaHRTaGFkb3coIG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSggNTAsIDEsIDAuNSwgNTAwICkgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5TcG90TGlnaHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGlnaHQucHJvdG90eXBlICk7XHJcblRIUkVFLlNwb3RMaWdodC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5TcG90TGlnaHQ7XHJcblxyXG5USFJFRS5TcG90TGlnaHQucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcblx0VEhSRUUuTGlnaHQucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XHJcblxyXG5cdHRoaXMuZGlzdGFuY2UgPSBzb3VyY2UuZGlzdGFuY2U7XHJcblx0dGhpcy5hbmdsZSA9IHNvdXJjZS5hbmdsZTtcclxuXHR0aGlzLmV4cG9uZW50ID0gc291cmNlLmV4cG9uZW50O1xyXG5cdHRoaXMuZGVjYXkgPSBzb3VyY2UuZGVjYXk7XHJcblxyXG5cdHRoaXMudGFyZ2V0ID0gc291cmNlLnRhcmdldC5jbG9uZSgpO1xyXG5cclxuXHR0aGlzLnNoYWRvdyA9IHNvdXJjZS5zaGFkb3cuY2xvbmUoKTtcclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbG9hZGVycy9DYWNoZS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuQ2FjaGUgPSB7XHJcblxyXG5cdGVuYWJsZWQ6IGZhbHNlLFxyXG5cclxuXHRmaWxlczoge30sXHJcblxyXG5cdGFkZDogZnVuY3Rpb24gKCBrZXksIGZpbGUgKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLmVuYWJsZWQgPT09IGZhbHNlICkgcmV0dXJuO1xyXG5cclxuXHRcdC8vIGNvbnNvbGUubG9nKCAnVEhSRUUuQ2FjaGUnLCAnQWRkaW5nIGtleTonLCBrZXkgKTtcclxuXHJcblx0XHR0aGlzLmZpbGVzWyBrZXkgXSA9IGZpbGU7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldDogZnVuY3Rpb24gKCBrZXkgKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLmVuYWJsZWQgPT09IGZhbHNlICkgcmV0dXJuO1xyXG5cclxuXHRcdC8vIGNvbnNvbGUubG9nKCAnVEhSRUUuQ2FjaGUnLCAnQ2hlY2tpbmcga2V5OicsIGtleSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmZpbGVzWyBrZXkgXTtcclxuXHJcblx0fSxcclxuXHJcblx0cmVtb3ZlOiBmdW5jdGlvbiAoIGtleSApIHtcclxuXHJcblx0XHRkZWxldGUgdGhpcy5maWxlc1sga2V5IF07XHJcblxyXG5cdH0sXHJcblxyXG5cdGNsZWFyOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy5maWxlcyA9IHt9O1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbG9hZGVycy9Mb2FkZXIuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkxvYWRlciA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dGhpcy5vbkxvYWRTdGFydCA9IGZ1bmN0aW9uICgpIHt9O1xyXG5cdHRoaXMub25Mb2FkUHJvZ3Jlc3MgPSBmdW5jdGlvbiAoKSB7fTtcclxuXHR0aGlzLm9uTG9hZENvbXBsZXRlID0gZnVuY3Rpb24gKCkge307XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTG9hZGVyLnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLkxvYWRlcixcclxuXHJcblx0Y3Jvc3NPcmlnaW46IHVuZGVmaW5lZCxcclxuXHJcblx0ZXh0cmFjdFVybEJhc2U6IGZ1bmN0aW9uICggdXJsICkge1xyXG5cclxuXHRcdHZhciBwYXJ0cyA9IHVybC5zcGxpdCggJy8nICk7XHJcblxyXG5cdFx0aWYgKCBwYXJ0cy5sZW5ndGggPT09IDEgKSByZXR1cm4gJy4vJztcclxuXHJcblx0XHRwYXJ0cy5wb3AoKTtcclxuXHJcblx0XHRyZXR1cm4gcGFydHMuam9pbiggJy8nICkgKyAnLyc7XHJcblxyXG5cdH0sXHJcblxyXG5cdGluaXRNYXRlcmlhbHM6IGZ1bmN0aW9uICggbWF0ZXJpYWxzLCB0ZXh0dXJlUGF0aCwgY3Jvc3NPcmlnaW4gKSB7XHJcblxyXG5cdFx0dmFyIGFycmF5ID0gW107XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbWF0ZXJpYWxzLmxlbmd0aDsgKysgaSApIHtcclxuXHJcblx0XHRcdGFycmF5WyBpIF0gPSB0aGlzLmNyZWF0ZU1hdGVyaWFsKCBtYXRlcmlhbHNbIGkgXSwgdGV4dHVyZVBhdGgsIGNyb3NzT3JpZ2luICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBhcnJheTtcclxuXHJcblx0fSxcclxuXHJcblx0Y3JlYXRlTWF0ZXJpYWw6ICggZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBjb2xvciwgdGV4dHVyZUxvYWRlciwgbWF0ZXJpYWxMb2FkZXI7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggbSwgdGV4dHVyZVBhdGgsIGNyb3NzT3JpZ2luICkge1xyXG5cclxuXHRcdFx0aWYgKCBjb2xvciA9PT0gdW5kZWZpbmVkICkgY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoKTtcclxuXHRcdFx0aWYgKCB0ZXh0dXJlTG9hZGVyID09PSB1bmRlZmluZWQgKSB0ZXh0dXJlTG9hZGVyID0gbmV3IFRIUkVFLlRleHR1cmVMb2FkZXIoKTtcclxuXHRcdFx0aWYgKCBtYXRlcmlhbExvYWRlciA9PT0gdW5kZWZpbmVkICkgbWF0ZXJpYWxMb2FkZXIgPSBuZXcgVEhSRUUuTWF0ZXJpYWxMb2FkZXIoKTtcclxuXHJcblx0XHRcdC8vIGNvbnZlcnQgZnJvbSBvbGQgbWF0ZXJpYWwgZm9ybWF0XHJcblxyXG5cdFx0XHR2YXIgdGV4dHVyZXMgPSB7fTtcclxuXHJcblx0XHRcdGZ1bmN0aW9uIGxvYWRUZXh0dXJlKCBwYXRoLCByZXBlYXQsIG9mZnNldCwgd3JhcCwgYW5pc290cm9weSApIHtcclxuXHJcblx0XHRcdFx0dmFyIGZ1bGxQYXRoID0gdGV4dHVyZVBhdGggKyBwYXRoO1xyXG5cdFx0XHRcdHZhciBsb2FkZXIgPSBUSFJFRS5Mb2FkZXIuSGFuZGxlcnMuZ2V0KCBmdWxsUGF0aCApO1xyXG5cclxuXHRcdFx0XHR2YXIgdGV4dHVyZTtcclxuXHJcblx0XHRcdFx0aWYgKCBsb2FkZXIgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdFx0dGV4dHVyZSA9IGxvYWRlci5sb2FkKCBmdWxsUGF0aCApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdHRleHR1cmVMb2FkZXIuc2V0Q3Jvc3NPcmlnaW4oIGNyb3NzT3JpZ2luICk7XHJcblx0XHRcdFx0XHR0ZXh0dXJlID0gdGV4dHVyZUxvYWRlci5sb2FkKCBmdWxsUGF0aCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggcmVwZWF0ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0dGV4dHVyZS5yZXBlYXQuZnJvbUFycmF5KCByZXBlYXQgKTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIHJlcGVhdFsgMCBdICE9PSAxICkgdGV4dHVyZS53cmFwUyA9IFRIUkVFLlJlcGVhdFdyYXBwaW5nO1xyXG5cdFx0XHRcdFx0aWYgKCByZXBlYXRbIDEgXSAhPT0gMSApIHRleHR1cmUud3JhcFQgPSBUSFJFRS5SZXBlYXRXcmFwcGluZztcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIG9mZnNldCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdHRleHR1cmUub2Zmc2V0LmZyb21BcnJheSggb2Zmc2V0ICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCB3cmFwICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCB3cmFwWyAwIF0gPT09ICdyZXBlYXQnICkgdGV4dHVyZS53cmFwUyA9IFRIUkVFLlJlcGVhdFdyYXBwaW5nO1xyXG5cdFx0XHRcdFx0aWYgKCB3cmFwWyAwIF0gPT09ICdtaXJyb3InICkgdGV4dHVyZS53cmFwUyA9IFRIUkVFLk1pcnJvcmVkUmVwZWF0V3JhcHBpbmc7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCB3cmFwWyAxIF0gPT09ICdyZXBlYXQnICkgdGV4dHVyZS53cmFwVCA9IFRIUkVFLlJlcGVhdFdyYXBwaW5nO1xyXG5cdFx0XHRcdFx0aWYgKCB3cmFwWyAxIF0gPT09ICdtaXJyb3InICkgdGV4dHVyZS53cmFwVCA9IFRIUkVFLk1pcnJvcmVkUmVwZWF0V3JhcHBpbmc7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCBhbmlzb3Ryb3B5ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0dGV4dHVyZS5hbmlzb3Ryb3B5ID0gYW5pc290cm9weTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR2YXIgdXVpZCA9IFRIUkVFLk1hdGguZ2VuZXJhdGVVVUlEKCk7XHJcblxyXG5cdFx0XHRcdHRleHR1cmVzWyB1dWlkIF0gPSB0ZXh0dXJlO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gdXVpZDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vXHJcblxyXG5cdFx0XHR2YXIganNvbiA9IHtcclxuXHRcdFx0XHR1dWlkOiBUSFJFRS5NYXRoLmdlbmVyYXRlVVVJRCgpLFxyXG5cdFx0XHRcdHR5cGU6ICdNZXNoTGFtYmVydE1hdGVyaWFsJ1xyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIG5hbWUgaW4gbSApIHtcclxuXHJcblx0XHRcdFx0dmFyIHZhbHVlID0gbVsgbmFtZSBdO1xyXG5cclxuXHRcdFx0XHRzd2l0Y2ggKCBuYW1lICkge1xyXG5cdFx0XHRcdFx0Y2FzZSAnRGJnQ29sb3InOlxyXG5cdFx0XHRcdFx0Y2FzZSAnRGJnSW5kZXgnOlxyXG5cdFx0XHRcdFx0Y2FzZSAnb3B0aWNhbERlbnNpdHknOlxyXG5cdFx0XHRcdFx0Y2FzZSAnaWxsdW1pbmF0aW9uJzpcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRjYXNlICdEYmdOYW1lJzpcclxuXHRcdFx0XHRcdFx0anNvbi5uYW1lID0gdmFsdWU7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0Y2FzZSAnYmxlbmRpbmcnOlxyXG5cdFx0XHRcdFx0XHRqc29uLmJsZW5kaW5nID0gVEhSRUVbIHZhbHVlIF07XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0Y2FzZSAnY29sb3JBbWJpZW50JzpcclxuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTG9hZGVyLmNyZWF0ZU1hdGVyaWFsOiBjb2xvckFtYmllbnQgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCcgKTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRjYXNlICdjb2xvckRpZmZ1c2UnOlxyXG5cdFx0XHRcdFx0XHRqc29uLmNvbG9yID0gY29sb3IuZnJvbUFycmF5KCB2YWx1ZSApLmdldEhleCgpO1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdGNhc2UgJ2NvbG9yU3BlY3VsYXInOlxyXG5cdFx0XHRcdFx0XHRqc29uLnNwZWN1bGFyID0gY29sb3IuZnJvbUFycmF5KCB2YWx1ZSApLmdldEhleCgpO1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdGNhc2UgJ2NvbG9yRW1pc3NpdmUnOlxyXG5cdFx0XHRcdFx0XHRqc29uLmVtaXNzaXZlID0gY29sb3IuZnJvbUFycmF5KCB2YWx1ZSApLmdldEhleCgpO1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdGNhc2UgJ3NwZWN1bGFyQ29lZic6XHJcblx0XHRcdFx0XHRcdGpzb24uc2hpbmluZXNzID0gdmFsdWU7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0Y2FzZSAnc2hhZGluZyc6XHJcblx0XHRcdFx0XHRcdGlmICggdmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gJ2Jhc2ljJyApIGpzb24udHlwZSA9ICdNZXNoQmFzaWNNYXRlcmlhbCc7XHJcblx0XHRcdFx0XHRcdGlmICggdmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gJ3Bob25nJyApIGpzb24udHlwZSA9ICdNZXNoUGhvbmdNYXRlcmlhbCc7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0Y2FzZSAnbWFwRGlmZnVzZSc6XHJcblx0XHRcdFx0XHRcdGpzb24ubWFwID0gbG9hZFRleHR1cmUoIHZhbHVlLCBtLm1hcERpZmZ1c2VSZXBlYXQsIG0ubWFwRGlmZnVzZU9mZnNldCwgbS5tYXBEaWZmdXNlV3JhcCwgbS5tYXBEaWZmdXNlQW5pc290cm9weSApO1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdGNhc2UgJ21hcERpZmZ1c2VSZXBlYXQnOlxyXG5cdFx0XHRcdFx0Y2FzZSAnbWFwRGlmZnVzZU9mZnNldCc6XHJcblx0XHRcdFx0XHRjYXNlICdtYXBEaWZmdXNlV3JhcCc6XHJcblx0XHRcdFx0XHRjYXNlICdtYXBEaWZmdXNlQW5pc290cm9weSc6XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0Y2FzZSAnbWFwTGlnaHQnOlxyXG5cdFx0XHRcdFx0XHRqc29uLmxpZ2h0TWFwID0gbG9hZFRleHR1cmUoIHZhbHVlLCBtLm1hcExpZ2h0UmVwZWF0LCBtLm1hcExpZ2h0T2Zmc2V0LCBtLm1hcExpZ2h0V3JhcCwgbS5tYXBMaWdodEFuaXNvdHJvcHkgKTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRjYXNlICdtYXBMaWdodFJlcGVhdCc6XHJcblx0XHRcdFx0XHRjYXNlICdtYXBMaWdodE9mZnNldCc6XHJcblx0XHRcdFx0XHRjYXNlICdtYXBMaWdodFdyYXAnOlxyXG5cdFx0XHRcdFx0Y2FzZSAnbWFwTGlnaHRBbmlzb3Ryb3B5JzpcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRjYXNlICdtYXBBTyc6XHJcblx0XHRcdFx0XHRcdGpzb24uYW9NYXAgPSBsb2FkVGV4dHVyZSggdmFsdWUsIG0ubWFwQU9SZXBlYXQsIG0ubWFwQU9PZmZzZXQsIG0ubWFwQU9XcmFwLCBtLm1hcEFPQW5pc290cm9weSApO1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdGNhc2UgJ21hcEFPUmVwZWF0JzpcclxuXHRcdFx0XHRcdGNhc2UgJ21hcEFPT2Zmc2V0JzpcclxuXHRcdFx0XHRcdGNhc2UgJ21hcEFPV3JhcCc6XHJcblx0XHRcdFx0XHRjYXNlICdtYXBBT0FuaXNvdHJvcHknOlxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdGNhc2UgJ21hcEJ1bXAnOlxyXG5cdFx0XHRcdFx0XHRqc29uLmJ1bXBNYXAgPSBsb2FkVGV4dHVyZSggdmFsdWUsIG0ubWFwQnVtcFJlcGVhdCwgbS5tYXBCdW1wT2Zmc2V0LCBtLm1hcEJ1bXBXcmFwLCBtLm1hcEJ1bXBBbmlzb3Ryb3B5ICk7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0Y2FzZSAnbWFwQnVtcFNjYWxlJzpcclxuXHRcdFx0XHRcdFx0anNvbi5idW1wU2NhbGUgPSB2YWx1ZTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRjYXNlICdtYXBCdW1wUmVwZWF0JzpcclxuXHRcdFx0XHRcdGNhc2UgJ21hcEJ1bXBPZmZzZXQnOlxyXG5cdFx0XHRcdFx0Y2FzZSAnbWFwQnVtcFdyYXAnOlxyXG5cdFx0XHRcdFx0Y2FzZSAnbWFwQnVtcEFuaXNvdHJvcHknOlxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdGNhc2UgJ21hcE5vcm1hbCc6XHJcblx0XHRcdFx0XHRcdGpzb24ubm9ybWFsTWFwID0gbG9hZFRleHR1cmUoIHZhbHVlLCBtLm1hcE5vcm1hbFJlcGVhdCwgbS5tYXBOb3JtYWxPZmZzZXQsIG0ubWFwTm9ybWFsV3JhcCwgbS5tYXBOb3JtYWxBbmlzb3Ryb3B5ICk7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0Y2FzZSAnbWFwTm9ybWFsRmFjdG9yJzpcclxuXHRcdFx0XHRcdFx0anNvbi5ub3JtYWxTY2FsZSA9IFsgdmFsdWUsIHZhbHVlIF07XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0Y2FzZSAnbWFwTm9ybWFsUmVwZWF0JzpcclxuXHRcdFx0XHRcdGNhc2UgJ21hcE5vcm1hbE9mZnNldCc6XHJcblx0XHRcdFx0XHRjYXNlICdtYXBOb3JtYWxXcmFwJzpcclxuXHRcdFx0XHRcdGNhc2UgJ21hcE5vcm1hbEFuaXNvdHJvcHknOlxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdGNhc2UgJ21hcFNwZWN1bGFyJzpcclxuXHRcdFx0XHRcdFx0anNvbi5zcGVjdWxhck1hcCA9IGxvYWRUZXh0dXJlKCB2YWx1ZSwgbS5tYXBTcGVjdWxhclJlcGVhdCwgbS5tYXBTcGVjdWxhck9mZnNldCwgbS5tYXBTcGVjdWxhcldyYXAsIG0ubWFwU3BlY3VsYXJBbmlzb3Ryb3B5ICk7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0Y2FzZSAnbWFwU3BlY3VsYXJSZXBlYXQnOlxyXG5cdFx0XHRcdFx0Y2FzZSAnbWFwU3BlY3VsYXJPZmZzZXQnOlxyXG5cdFx0XHRcdFx0Y2FzZSAnbWFwU3BlY3VsYXJXcmFwJzpcclxuXHRcdFx0XHRcdGNhc2UgJ21hcFNwZWN1bGFyQW5pc290cm9weSc6XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0Y2FzZSAnbWFwQWxwaGEnOlxyXG5cdFx0XHRcdFx0XHRqc29uLmFscGhhTWFwID0gbG9hZFRleHR1cmUoIHZhbHVlLCBtLm1hcEFscGhhUmVwZWF0LCBtLm1hcEFscGhhT2Zmc2V0LCBtLm1hcEFscGhhV3JhcCwgbS5tYXBBbHBoYUFuaXNvdHJvcHkgKTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRjYXNlICdtYXBBbHBoYVJlcGVhdCc6XHJcblx0XHRcdFx0XHRjYXNlICdtYXBBbHBoYU9mZnNldCc6XHJcblx0XHRcdFx0XHRjYXNlICdtYXBBbHBoYVdyYXAnOlxyXG5cdFx0XHRcdFx0Y2FzZSAnbWFwQWxwaGFBbmlzb3Ryb3B5JzpcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRjYXNlICdmbGlwU2lkZWQnOlxyXG5cdFx0XHRcdFx0XHRqc29uLnNpZGUgPSBUSFJFRS5CYWNrU2lkZTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRjYXNlICdkb3VibGVTaWRlZCc6XHJcblx0XHRcdFx0XHRcdGpzb24uc2lkZSA9IFRIUkVFLkRvdWJsZVNpZGU7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0Y2FzZSAndHJhbnNwYXJlbmN5JzpcclxuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTG9hZGVyLmNyZWF0ZU1hdGVyaWFsOiB0cmFuc3BhcmVuY3kgaGFzIGJlZW4gcmVuYW1lZCB0byBvcGFjaXR5JyApO1xyXG5cdFx0XHRcdFx0XHRqc29uLm9wYWNpdHkgPSB2YWx1ZTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRjYXNlICdkZXB0aFRlc3QnOlxyXG5cdFx0XHRcdFx0Y2FzZSAnZGVwdGhXcml0ZSc6XHJcblx0XHRcdFx0XHRjYXNlICdjb2xvcldyaXRlJzpcclxuXHRcdFx0XHRcdGNhc2UgJ29wYWNpdHknOlxyXG5cdFx0XHRcdFx0Y2FzZSAncmVmbGVjdGl2aXR5JzpcclxuXHRcdFx0XHRcdGNhc2UgJ3RyYW5zcGFyZW50JzpcclxuXHRcdFx0XHRcdGNhc2UgJ3Zpc2libGUnOlxyXG5cdFx0XHRcdFx0Y2FzZSAnd2lyZWZyYW1lJzpcclxuXHRcdFx0XHRcdFx0anNvblsgbmFtZSBdID0gdmFsdWU7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0Y2FzZSAndmVydGV4Q29sb3JzJzpcclxuXHRcdFx0XHRcdFx0aWYgKCB2YWx1ZSA9PT0gdHJ1ZSApIGpzb24udmVydGV4Q29sb3JzID0gVEhSRUUuVmVydGV4Q29sb3JzO1xyXG5cdFx0XHRcdFx0XHRpZiAoIHZhbHVlID09PSAnZmFjZScgKSBqc29uLnZlcnRleENvbG9ycyA9IFRIUkVFLkZhY2VDb2xvcnM7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0ZGVmYXVsdDpcclxuXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkxvYWRlci5jcmVhdGVNYXRlcmlhbDogVW5zdXBwb3J0ZWQnLCBuYW1lLCB2YWx1ZSApO1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGpzb24udHlwZSA9PT0gJ01lc2hCYXNpY01hdGVyaWFsJyApIGRlbGV0ZSBqc29uLmVtaXNzaXZlO1xyXG5cdFx0XHRpZiAoIGpzb24udHlwZSAhPT0gJ01lc2hQaG9uZ01hdGVyaWFsJyApIGRlbGV0ZSBqc29uLnNwZWN1bGFyO1xyXG5cclxuXHRcdFx0aWYgKCBqc29uLm9wYWNpdHkgPCAxICkganNvbi50cmFuc3BhcmVudCA9IHRydWU7XHJcblxyXG5cdFx0XHRtYXRlcmlhbExvYWRlci5zZXRUZXh0dXJlcyggdGV4dHVyZXMgKTtcclxuXHJcblx0XHRcdHJldHVybiBtYXRlcmlhbExvYWRlci5wYXJzZSgganNvbiApO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0gKSgpXHJcblxyXG59O1xyXG5cclxuVEhSRUUuTG9hZGVyLkhhbmRsZXJzID0ge1xyXG5cclxuXHRoYW5kbGVyczogW10sXHJcblxyXG5cdGFkZDogZnVuY3Rpb24gKCByZWdleCwgbG9hZGVyICkge1xyXG5cclxuXHRcdHRoaXMuaGFuZGxlcnMucHVzaCggcmVnZXgsIGxvYWRlciApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXQ6IGZ1bmN0aW9uICggZmlsZSApIHtcclxuXHJcblx0XHR2YXIgaGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGhhbmRsZXJzLmxlbmd0aDsgaSA8IGw7IGkgKz0gMiApIHtcclxuXHJcblx0XHRcdHZhciByZWdleCA9IGhhbmRsZXJzWyBpIF07XHJcblx0XHRcdHZhciBsb2FkZXIgID0gaGFuZGxlcnNbIGkgKyAxIF07XHJcblxyXG5cdFx0XHRpZiAoIHJlZ2V4LnRlc3QoIGZpbGUgKSApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIGxvYWRlcjtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG51bGw7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9sb2FkZXJzL1hIUkxvYWRlci5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuWEhSTG9hZGVyID0gZnVuY3Rpb24gKCBtYW5hZ2VyICkge1xyXG5cclxuXHR0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IFRIUkVFLkRlZmF1bHRMb2FkaW5nTWFuYWdlcjtcclxuXHJcbn07XHJcblxyXG5USFJFRS5YSFJMb2FkZXIucHJvdG90eXBlID0ge1xyXG5cclxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuWEhSTG9hZGVyLFxyXG5cclxuXHRsb2FkOiBmdW5jdGlvbiAoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xyXG5cclxuXHRcdGlmICggdGhpcy5wYXRoICE9PSB1bmRlZmluZWQgKSB1cmwgPSB0aGlzLnBhdGggKyB1cmw7XHJcblxyXG5cdFx0dmFyIHNjb3BlID0gdGhpcztcclxuXHJcblx0XHR2YXIgY2FjaGVkID0gVEhSRUUuQ2FjaGUuZ2V0KCB1cmwgKTtcclxuXHJcblx0XHRpZiAoIGNhY2hlZCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0aWYgKCBvbkxvYWQgKSB7XHJcblxyXG5cdFx0XHRcdHNldFRpbWVvdXQoIGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdFx0XHRvbkxvYWQoIGNhY2hlZCApO1xyXG5cclxuXHRcdFx0XHR9LCAwICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gY2FjaGVkO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG5cdFx0cmVxdWVzdC5vdmVycmlkZU1pbWVUeXBlKCAndGV4dC9wbGFpbicgKTtcclxuXHRcdHJlcXVlc3Qub3BlbiggJ0dFVCcsIHVybCwgdHJ1ZSApO1xyXG5cclxuXHRcdHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lciggJ2xvYWQnLCBmdW5jdGlvbiAoIGV2ZW50ICkge1xyXG5cclxuXHRcdFx0dmFyIHJlc3BvbnNlID0gZXZlbnQudGFyZ2V0LnJlc3BvbnNlO1xyXG5cclxuXHRcdFx0VEhSRUUuQ2FjaGUuYWRkKCB1cmwsIHJlc3BvbnNlICk7XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMuc3RhdHVzID09PSAyMDAgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggb25Mb2FkICkgb25Mb2FkKCByZXNwb25zZSApO1xyXG5cclxuXHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FbmQoIHVybCApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggdGhpcy5zdGF0dXMgPT09IDAgKSB7XHJcblxyXG5cdFx0XHRcdC8vIFNvbWUgYnJvd3NlcnMgcmV0dXJuIEhUVFAgU3RhdHVzIDAgd2hlbiB1c2luZyBub24taHR0cCBwcm90b2NvbFxyXG5cdFx0XHRcdC8vIGUuZy4gJ2ZpbGU6Ly8nIG9yICdkYXRhOi8vJy4gSGFuZGxlIGFzIHN1Y2Nlc3MuXHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlhIUkxvYWRlcjogSFRUUCBTdGF0dXMgMCByZWNlaXZlZC4nICk7XHJcblxyXG5cdFx0XHRcdGlmICggb25Mb2FkICkgb25Mb2FkKCByZXNwb25zZSApO1xyXG5cclxuXHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FbmQoIHVybCApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0aWYgKCBvbkVycm9yICkgb25FcnJvciggZXZlbnQgKTtcclxuXHJcblx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRXJyb3IoIHVybCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0sIGZhbHNlICk7XHJcblxyXG5cdFx0aWYgKCBvblByb2dyZXNzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRyZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoICdwcm9ncmVzcycsIGZ1bmN0aW9uICggZXZlbnQgKSB7XHJcblxyXG5cdFx0XHRcdG9uUHJvZ3Jlc3MoIGV2ZW50ICk7XHJcblxyXG5cdFx0XHR9LCBmYWxzZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoICdlcnJvcicsIGZ1bmN0aW9uICggZXZlbnQgKSB7XHJcblxyXG5cdFx0XHRpZiAoIG9uRXJyb3IgKSBvbkVycm9yKCBldmVudCApO1xyXG5cclxuXHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRXJyb3IoIHVybCApO1xyXG5cclxuXHRcdH0sIGZhbHNlICk7XHJcblxyXG5cdFx0aWYgKCB0aGlzLnJlc3BvbnNlVHlwZSAhPT0gdW5kZWZpbmVkICkgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSB0aGlzLnJlc3BvbnNlVHlwZTtcclxuXHRcdGlmICggdGhpcy53aXRoQ3JlZGVudGlhbHMgIT09IHVuZGVmaW5lZCApIHJlcXVlc3Qud2l0aENyZWRlbnRpYWxzID0gdGhpcy53aXRoQ3JlZGVudGlhbHM7XHJcblxyXG5cdFx0cmVxdWVzdC5zZW5kKCBudWxsICk7XHJcblxyXG5cdFx0c2NvcGUubWFuYWdlci5pdGVtU3RhcnQoIHVybCApO1xyXG5cclxuXHRcdHJldHVybiByZXF1ZXN0O1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRQYXRoOiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdHRoaXMucGF0aCA9IHZhbHVlO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRSZXNwb25zZVR5cGU6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdFx0dGhpcy5yZXNwb25zZVR5cGUgPSB2YWx1ZTtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0V2l0aENyZWRlbnRpYWxzOiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdHRoaXMud2l0aENyZWRlbnRpYWxzID0gdmFsdWU7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9sb2FkZXJzL0ZvbnRMb2FkZXIuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkZvbnRMb2FkZXIgPSBmdW5jdGlvbiAoIG1hbmFnZXIgKSB7XHJcblxyXG5cdHRoaXMubWFuYWdlciA9ICggbWFuYWdlciAhPT0gdW5kZWZpbmVkICkgPyBtYW5hZ2VyIDogVEhSRUUuRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkZvbnRMb2FkZXIucHJvdG90eXBlID0ge1xyXG5cclxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuRm9udExvYWRlcixcclxuXHJcblx0bG9hZDogZnVuY3Rpb24gKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcclxuXHJcblx0XHR2YXIgbG9hZGVyID0gbmV3IFRIUkVFLlhIUkxvYWRlciggdGhpcy5tYW5hZ2VyICk7XHJcblx0XHRsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIHRleHQgKSB7XHJcblxyXG5cdFx0XHRvbkxvYWQoIG5ldyBUSFJFRS5Gb250KCBKU09OLnBhcnNlKCB0ZXh0LnN1YnN0cmluZyggNjUsIHRleHQubGVuZ3RoIC0gMiApICkgKSApO1xyXG5cclxuXHRcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2xvYWRlcnMvSW1hZ2VMb2FkZXIuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkltYWdlTG9hZGVyID0gZnVuY3Rpb24gKCBtYW5hZ2VyICkge1xyXG5cclxuXHR0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IFRIUkVFLkRlZmF1bHRMb2FkaW5nTWFuYWdlcjtcclxuXHJcbn07XHJcblxyXG5USFJFRS5JbWFnZUxvYWRlci5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5JbWFnZUxvYWRlcixcclxuXHJcblx0bG9hZDogZnVuY3Rpb24gKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMucGF0aCAhPT0gdW5kZWZpbmVkICkgdXJsID0gdGhpcy5wYXRoICsgdXJsO1xyXG5cclxuXHRcdHZhciBzY29wZSA9IHRoaXM7XHJcblxyXG5cdFx0dmFyIGNhY2hlZCA9IFRIUkVFLkNhY2hlLmdldCggdXJsICk7XHJcblxyXG5cdFx0aWYgKCBjYWNoZWQgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbVN0YXJ0KCB1cmwgKTtcclxuXHJcblx0XHRcdGlmICggb25Mb2FkICkge1xyXG5cclxuXHRcdFx0XHRzZXRUaW1lb3V0KCBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRcdFx0b25Mb2FkKCBjYWNoZWQgKTtcclxuXHJcblx0XHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FbmQoIHVybCApO1xyXG5cclxuXHRcdFx0XHR9LCAwICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FbmQoIHVybCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIGNhY2hlZDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGltYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2ltZycgKTtcclxuXHJcblx0XHRpbWFnZS5hZGRFdmVudExpc3RlbmVyKCAnbG9hZCcsIGZ1bmN0aW9uICggZXZlbnQgKSB7XHJcblxyXG5cdFx0XHRUSFJFRS5DYWNoZS5hZGQoIHVybCwgdGhpcyApO1xyXG5cclxuXHRcdFx0aWYgKCBvbkxvYWQgKSBvbkxvYWQoIHRoaXMgKTtcclxuXHJcblx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVuZCggdXJsICk7XHJcblxyXG5cdFx0fSwgZmFsc2UgKTtcclxuXHJcblx0XHRpZiAoIG9uUHJvZ3Jlc3MgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoICdwcm9ncmVzcycsIGZ1bmN0aW9uICggZXZlbnQgKSB7XHJcblxyXG5cdFx0XHRcdG9uUHJvZ3Jlc3MoIGV2ZW50ICk7XHJcblxyXG5cdFx0XHR9LCBmYWxzZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpbWFnZS5hZGRFdmVudExpc3RlbmVyKCAnZXJyb3InLCBmdW5jdGlvbiAoIGV2ZW50ICkge1xyXG5cclxuXHRcdFx0aWYgKCBvbkVycm9yICkgb25FcnJvciggZXZlbnQgKTtcclxuXHJcblx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVycm9yKCB1cmwgKTtcclxuXHJcblx0XHR9LCBmYWxzZSApO1xyXG5cclxuXHRcdGlmICggdGhpcy5jcm9zc09yaWdpbiAhPT0gdW5kZWZpbmVkICkgaW1hZ2UuY3Jvc3NPcmlnaW4gPSB0aGlzLmNyb3NzT3JpZ2luO1xyXG5cclxuXHRcdHNjb3BlLm1hbmFnZXIuaXRlbVN0YXJ0KCB1cmwgKTtcclxuXHJcblx0XHRpbWFnZS5zcmMgPSB1cmw7XHJcblxyXG5cdFx0cmV0dXJuIGltYWdlO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRDcm9zc09yaWdpbjogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0XHR0aGlzLmNyb3NzT3JpZ2luID0gdmFsdWU7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldFBhdGg6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdFx0dGhpcy5wYXRoID0gdmFsdWU7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9sb2FkZXJzL0pTT05Mb2FkZXIuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkpTT05Mb2FkZXIgPSBmdW5jdGlvbiAoIG1hbmFnZXIgKSB7XHJcblxyXG5cdGlmICggdHlwZW9mIG1hbmFnZXIgPT09ICdib29sZWFuJyApIHtcclxuXHJcblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5KU09OTG9hZGVyOiBzaG93U3RhdHVzIHBhcmFtZXRlciBoYXMgYmVlbiByZW1vdmVkIGZyb20gY29uc3RydWN0b3IuJyApO1xyXG5cdFx0bWFuYWdlciA9IHVuZGVmaW5lZDtcclxuXHJcblx0fVxyXG5cclxuXHR0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IFRIUkVFLkRlZmF1bHRMb2FkaW5nTWFuYWdlcjtcclxuXHJcblx0dGhpcy53aXRoQ3JlZGVudGlhbHMgPSBmYWxzZTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5KU09OTG9hZGVyLnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLkpTT05Mb2FkZXIsXHJcblxyXG5cdC8vIERlcHJlY2F0ZWRcclxuXHJcblx0Z2V0IHN0YXR1c0RvbUVsZW1lbnQgKCkge1xyXG5cclxuXHRcdGlmICggdGhpcy5fc3RhdHVzRG9tRWxlbWVudCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0dGhpcy5fc3RhdHVzRG9tRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdkaXYnICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkpTT05Mb2FkZXI6IC5zdGF0dXNEb21FbGVtZW50IGhhcyBiZWVuIHJlbW92ZWQuJyApO1xyXG5cdFx0cmV0dXJuIHRoaXMuX3N0YXR1c0RvbUVsZW1lbnQ7XHJcblxyXG5cdH0sXHJcblxyXG5cdGxvYWQ6IGZ1bmN0aW9uKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcclxuXHJcblx0XHR2YXIgc2NvcGUgPSB0aGlzO1xyXG5cclxuXHRcdHZhciB0ZXh0dXJlUGF0aCA9IHRoaXMudGV4dHVyZVBhdGggJiYgKCB0eXBlb2YgdGhpcy50ZXh0dXJlUGF0aCA9PT0gXCJzdHJpbmdcIiApID8gdGhpcy50ZXh0dXJlUGF0aCA6IFRIUkVFLkxvYWRlci5wcm90b3R5cGUuZXh0cmFjdFVybEJhc2UoIHVybCApO1xyXG5cclxuXHRcdHZhciBsb2FkZXIgPSBuZXcgVEhSRUUuWEhSTG9hZGVyKCB0aGlzLm1hbmFnZXIgKTtcclxuXHRcdGxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHMoIHRoaXMud2l0aENyZWRlbnRpYWxzICk7XHJcblx0XHRsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIHRleHQgKSB7XHJcblxyXG5cdFx0XHR2YXIganNvbiA9IEpTT04ucGFyc2UoIHRleHQgKTtcclxuXHRcdFx0dmFyIG1ldGFkYXRhID0ganNvbi5tZXRhZGF0YTtcclxuXHJcblx0XHRcdGlmICggbWV0YWRhdGEgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0dmFyIHR5cGUgPSBtZXRhZGF0YS50eXBlO1xyXG5cclxuXHRcdFx0XHRpZiAoIHR5cGUgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIHR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ29iamVjdCcgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuSlNPTkxvYWRlcjogJyArIHVybCArICcgc2hvdWxkIGJlIGxvYWRlZCB3aXRoIFRIUkVFLk9iamVjdExvYWRlciBpbnN0ZWFkLicgKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRpZiAoIHR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ3NjZW5lJyApIHtcclxuXHJcblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5KU09OTG9hZGVyOiAnICsgdXJsICsgJyBzaG91bGQgYmUgbG9hZGVkIHdpdGggVEhSRUUuU2NlbmVMb2FkZXIgaW5zdGVhZC4nICk7XHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBvYmplY3QgPSBzY29wZS5wYXJzZSgganNvbiwgdGV4dHVyZVBhdGggKTtcclxuXHRcdFx0b25Mb2FkKCBvYmplY3QuZ2VvbWV0cnksIG9iamVjdC5tYXRlcmlhbHMgKTtcclxuXHJcblx0XHR9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldFRleHR1cmVQYXRoOiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdHRoaXMudGV4dHVyZVBhdGggPSB2YWx1ZTtcclxuXHJcblx0fSxcclxuXHJcblx0cGFyc2U6IGZ1bmN0aW9uICgganNvbiwgdGV4dHVyZVBhdGggKSB7XHJcblxyXG5cdFx0dmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkdlb21ldHJ5KCksXHJcblx0XHRzY2FsZSA9ICgganNvbi5zY2FsZSAhPT0gdW5kZWZpbmVkICkgPyAxLjAgLyBqc29uLnNjYWxlIDogMS4wO1xyXG5cclxuXHRcdHBhcnNlTW9kZWwoIHNjYWxlICk7XHJcblxyXG5cdFx0cGFyc2VTa2luKCk7XHJcblx0XHRwYXJzZU1vcnBoaW5nKCBzY2FsZSApO1xyXG5cdFx0cGFyc2VBbmltYXRpb25zKCk7XHJcblxyXG5cdFx0Z2VvbWV0cnkuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XHJcblx0XHRnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcclxuXHJcblx0XHRmdW5jdGlvbiBwYXJzZU1vZGVsKCBzY2FsZSApIHtcclxuXHJcblx0XHRcdGZ1bmN0aW9uIGlzQml0U2V0KCB2YWx1ZSwgcG9zaXRpb24gKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiB2YWx1ZSAmICggMSA8PCBwb3NpdGlvbiApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIGksIGosIGZpLFxyXG5cclxuXHRcdFx0b2Zmc2V0LCB6TGVuZ3RoLFxyXG5cclxuXHRcdGNvbG9ySW5kZXgsIG5vcm1hbEluZGV4LCB1dkluZGV4LCBtYXRlcmlhbEluZGV4LFxyXG5cclxuXHRcdFx0dHlwZSxcclxuXHRcdFx0aXNRdWFkLFxyXG5cdFx0XHRoYXNNYXRlcmlhbCxcclxuXHRcdFx0aGFzRmFjZVZlcnRleFV2LFxyXG5cdFx0XHRoYXNGYWNlTm9ybWFsLCBoYXNGYWNlVmVydGV4Tm9ybWFsLFxyXG5cdFx0XHRoYXNGYWNlQ29sb3IsIGhhc0ZhY2VWZXJ0ZXhDb2xvcixcclxuXHJcblx0XHR2ZXJ0ZXgsIGZhY2UsIGZhY2VBLCBmYWNlQiwgaGV4LCBub3JtYWwsXHJcblxyXG5cdFx0XHR1dkxheWVyLCB1diwgdSwgdixcclxuXHJcblx0XHRcdGZhY2VzID0ganNvbi5mYWNlcyxcclxuXHRcdFx0dmVydGljZXMgPSBqc29uLnZlcnRpY2VzLFxyXG5cdFx0XHRub3JtYWxzID0ganNvbi5ub3JtYWxzLFxyXG5cdFx0XHRjb2xvcnMgPSBqc29uLmNvbG9ycyxcclxuXHJcblx0XHRcdG5VdkxheWVycyA9IDA7XHJcblxyXG5cdFx0XHRpZiAoIGpzb24udXZzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdC8vIGRpc3JlZ2FyZCBlbXB0eSBhcnJheXNcclxuXHJcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBqc29uLnV2cy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBqc29uLnV2c1sgaSBdLmxlbmd0aCApIG5VdkxheWVycyArKztcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IG5VdkxheWVyczsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyBpIF0gPSBbXTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0b2Zmc2V0ID0gMDtcclxuXHRcdFx0ekxlbmd0aCA9IHZlcnRpY2VzLmxlbmd0aDtcclxuXHJcblx0XHRcdHdoaWxlICggb2Zmc2V0IDwgekxlbmd0aCApIHtcclxuXHJcblx0XHRcdFx0dmVydGV4ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHRcdFx0dmVydGV4LnggPSB2ZXJ0aWNlc1sgb2Zmc2V0ICsrIF0gKiBzY2FsZTtcclxuXHRcdFx0XHR2ZXJ0ZXgueSA9IHZlcnRpY2VzWyBvZmZzZXQgKysgXSAqIHNjYWxlO1xyXG5cdFx0XHRcdHZlcnRleC56ID0gdmVydGljZXNbIG9mZnNldCArKyBdICogc2NhbGU7XHJcblxyXG5cdFx0XHRcdGdlb21ldHJ5LnZlcnRpY2VzLnB1c2goIHZlcnRleCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0b2Zmc2V0ID0gMDtcclxuXHRcdFx0ekxlbmd0aCA9IGZhY2VzLmxlbmd0aDtcclxuXHJcblx0XHRcdHdoaWxlICggb2Zmc2V0IDwgekxlbmd0aCApIHtcclxuXHJcblx0XHRcdFx0dHlwZSA9IGZhY2VzWyBvZmZzZXQgKysgXTtcclxuXHJcblxyXG5cdFx0XHRcdGlzUXVhZCAgICAgICAgICAgICAgPSBpc0JpdFNldCggdHlwZSwgMCApO1xyXG5cdFx0XHRcdGhhc01hdGVyaWFsICAgICAgICAgPSBpc0JpdFNldCggdHlwZSwgMSApO1xyXG5cdFx0XHRcdGhhc0ZhY2VWZXJ0ZXhVdiAgICAgPSBpc0JpdFNldCggdHlwZSwgMyApO1xyXG5cdFx0XHRcdGhhc0ZhY2VOb3JtYWwgICAgICAgPSBpc0JpdFNldCggdHlwZSwgNCApO1xyXG5cdFx0XHRcdGhhc0ZhY2VWZXJ0ZXhOb3JtYWwgPSBpc0JpdFNldCggdHlwZSwgNSApO1xyXG5cdFx0XHRcdGhhc0ZhY2VDb2xvclx0ICAgICA9IGlzQml0U2V0KCB0eXBlLCA2ICk7XHJcblx0XHRcdFx0aGFzRmFjZVZlcnRleENvbG9yICA9IGlzQml0U2V0KCB0eXBlLCA3ICk7XHJcblxyXG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nKFwidHlwZVwiLCB0eXBlLCBcImJpdHNcIiwgaXNRdWFkLCBoYXNNYXRlcmlhbCwgaGFzRmFjZVZlcnRleFV2LCBoYXNGYWNlTm9ybWFsLCBoYXNGYWNlVmVydGV4Tm9ybWFsLCBoYXNGYWNlQ29sb3IsIGhhc0ZhY2VWZXJ0ZXhDb2xvcik7XHJcblxyXG5cdFx0XHRcdGlmICggaXNRdWFkICkge1xyXG5cclxuXHRcdFx0XHRcdGZhY2VBID0gbmV3IFRIUkVFLkZhY2UzKCk7XHJcblx0XHRcdFx0XHRmYWNlQS5hID0gZmFjZXNbIG9mZnNldCBdO1xyXG5cdFx0XHRcdFx0ZmFjZUEuYiA9IGZhY2VzWyBvZmZzZXQgKyAxIF07XHJcblx0XHRcdFx0XHRmYWNlQS5jID0gZmFjZXNbIG9mZnNldCArIDMgXTtcclxuXHJcblx0XHRcdFx0XHRmYWNlQiA9IG5ldyBUSFJFRS5GYWNlMygpO1xyXG5cdFx0XHRcdFx0ZmFjZUIuYSA9IGZhY2VzWyBvZmZzZXQgKyAxIF07XHJcblx0XHRcdFx0XHRmYWNlQi5iID0gZmFjZXNbIG9mZnNldCArIDIgXTtcclxuXHRcdFx0XHRcdGZhY2VCLmMgPSBmYWNlc1sgb2Zmc2V0ICsgMyBdO1xyXG5cclxuXHRcdFx0XHRcdG9mZnNldCArPSA0O1xyXG5cclxuXHRcdFx0XHRcdGlmICggaGFzTWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRtYXRlcmlhbEluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdO1xyXG5cdFx0XHRcdFx0XHRmYWNlQS5tYXRlcmlhbEluZGV4ID0gbWF0ZXJpYWxJbmRleDtcclxuXHRcdFx0XHRcdFx0ZmFjZUIubWF0ZXJpYWxJbmRleCA9IG1hdGVyaWFsSW5kZXg7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdC8vIHRvIGdldCBmYWNlIDw9PiB1diBpbmRleCBjb3JyZXNwb25kZW5jZVxyXG5cclxuXHRcdFx0XHRcdGZpID0gZ2VvbWV0cnkuZmFjZXMubGVuZ3RoO1xyXG5cclxuXHRcdFx0XHRcdGlmICggaGFzRmFjZVZlcnRleFV2ICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBuVXZMYXllcnM7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHV2TGF5ZXIgPSBqc29uLnV2c1sgaSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyBpIF1bIGZpIF0gPSBbXTtcclxuXHRcdFx0XHRcdFx0XHRnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyBpIF1bIGZpICsgMSBdID0gW107XHJcblxyXG5cdFx0XHRcdFx0XHRcdGZvciAoIGogPSAwOyBqIDwgNDsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHR1dkluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdHUgPSB1dkxheWVyWyB1dkluZGV4ICogMiBdO1xyXG5cdFx0XHRcdFx0XHRcdFx0diA9IHV2TGF5ZXJbIHV2SW5kZXggKiAyICsgMSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdHV2ID0gbmV3IFRIUkVFLlZlY3RvcjIoIHUsIHYgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGogIT09IDIgKSBnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyBpIF1bIGZpIF0ucHVzaCggdXYgKTtcclxuXHRcdFx0XHRcdFx0XHRcdGlmICggaiAhPT0gMCApIGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIGkgXVsgZmkgKyAxIF0ucHVzaCggdXYgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRpZiAoIGhhc0ZhY2VOb3JtYWwgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRub3JtYWxJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXSAqIDM7XHJcblxyXG5cdFx0XHRcdFx0XHRmYWNlQS5ub3JtYWwuc2V0KFxyXG5cdFx0XHRcdFx0XHRcdG5vcm1hbHNbIG5vcm1hbEluZGV4ICsrIF0sXHJcblx0XHRcdFx0XHRcdFx0bm9ybWFsc1sgbm9ybWFsSW5kZXggKysgXSxcclxuXHRcdFx0XHRcdFx0XHRub3JtYWxzWyBub3JtYWxJbmRleCBdXHJcblx0XHRcdFx0XHRcdCk7XHJcblxyXG5cdFx0XHRcdFx0XHRmYWNlQi5ub3JtYWwuY29weSggZmFjZUEubm9ybWFsICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGlmICggaGFzRmFjZVZlcnRleE5vcm1hbCApIHtcclxuXHJcblx0XHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgNDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0bm9ybWFsSW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF0gKiAzO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRub3JtYWwgPSBuZXcgVEhSRUUuVmVjdG9yMyhcclxuXHRcdFx0XHRcdFx0XHRcdG5vcm1hbHNbIG5vcm1hbEluZGV4ICsrIF0sXHJcblx0XHRcdFx0XHRcdFx0XHRub3JtYWxzWyBub3JtYWxJbmRleCArKyBdLFxyXG5cdFx0XHRcdFx0XHRcdFx0bm9ybWFsc1sgbm9ybWFsSW5kZXggXVxyXG5cdFx0XHRcdFx0XHRcdCk7XHJcblxyXG5cclxuXHRcdFx0XHRcdFx0XHRpZiAoIGkgIT09IDIgKSBmYWNlQS52ZXJ0ZXhOb3JtYWxzLnB1c2goIG5vcm1hbCApO1xyXG5cdFx0XHRcdFx0XHRcdGlmICggaSAhPT0gMCApIGZhY2VCLnZlcnRleE5vcm1hbHMucHVzaCggbm9ybWFsICk7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHJcblx0XHRcdFx0XHRpZiAoIGhhc0ZhY2VDb2xvciApIHtcclxuXHJcblx0XHRcdFx0XHRcdGNvbG9ySW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF07XHJcblx0XHRcdFx0XHRcdGhleCA9IGNvbG9yc1sgY29sb3JJbmRleCBdO1xyXG5cclxuXHRcdFx0XHRcdFx0ZmFjZUEuY29sb3Iuc2V0SGV4KCBoZXggKTtcclxuXHRcdFx0XHRcdFx0ZmFjZUIuY29sb3Iuc2V0SGV4KCBoZXggKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cclxuXHRcdFx0XHRcdGlmICggaGFzRmFjZVZlcnRleENvbG9yICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCA0OyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjb2xvckluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdO1xyXG5cdFx0XHRcdFx0XHRcdGhleCA9IGNvbG9yc1sgY29sb3JJbmRleCBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRpZiAoIGkgIT09IDIgKSBmYWNlQS52ZXJ0ZXhDb2xvcnMucHVzaCggbmV3IFRIUkVFLkNvbG9yKCBoZXggKSApO1xyXG5cdFx0XHRcdFx0XHRcdGlmICggaSAhPT0gMCApIGZhY2VCLnZlcnRleENvbG9ycy5wdXNoKCBuZXcgVEhSRUUuQ29sb3IoIGhleCApICk7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGdlb21ldHJ5LmZhY2VzLnB1c2goIGZhY2VBICk7XHJcblx0XHRcdFx0XHRnZW9tZXRyeS5mYWNlcy5wdXNoKCBmYWNlQiApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdGZhY2UgPSBuZXcgVEhSRUUuRmFjZTMoKTtcclxuXHRcdFx0XHRcdGZhY2UuYSA9IGZhY2VzWyBvZmZzZXQgKysgXTtcclxuXHRcdFx0XHRcdGZhY2UuYiA9IGZhY2VzWyBvZmZzZXQgKysgXTtcclxuXHRcdFx0XHRcdGZhY2UuYyA9IGZhY2VzWyBvZmZzZXQgKysgXTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGhhc01hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0XHRcdFx0bWF0ZXJpYWxJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXTtcclxuXHRcdFx0XHRcdFx0ZmFjZS5tYXRlcmlhbEluZGV4ID0gbWF0ZXJpYWxJbmRleDtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Ly8gdG8gZ2V0IGZhY2UgPD0+IHV2IGluZGV4IGNvcnJlc3BvbmRlbmNlXHJcblxyXG5cdFx0XHRcdFx0ZmkgPSBnZW9tZXRyeS5mYWNlcy5sZW5ndGg7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBoYXNGYWNlVmVydGV4VXYgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IG5VdkxheWVyczsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0dXZMYXllciA9IGpzb24udXZzWyBpIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIGkgXVsgZmkgXSA9IFtdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRmb3IgKCBqID0gMDsgaiA8IDM7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0dXZJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHR1ID0gdXZMYXllclsgdXZJbmRleCAqIDIgXTtcclxuXHRcdFx0XHRcdFx0XHRcdHYgPSB1dkxheWVyWyB1dkluZGV4ICogMiArIDEgXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHR1diA9IG5ldyBUSFJFRS5WZWN0b3IyKCB1LCB2ICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0Z2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgaSBdWyBmaSBdLnB1c2goIHV2ICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBoYXNGYWNlTm9ybWFsICkge1xyXG5cclxuXHRcdFx0XHRcdFx0bm9ybWFsSW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF0gKiAzO1xyXG5cclxuXHRcdFx0XHRcdFx0ZmFjZS5ub3JtYWwuc2V0KFxyXG5cdFx0XHRcdFx0XHRcdG5vcm1hbHNbIG5vcm1hbEluZGV4ICsrIF0sXHJcblx0XHRcdFx0XHRcdFx0bm9ybWFsc1sgbm9ybWFsSW5kZXggKysgXSxcclxuXHRcdFx0XHRcdFx0XHRub3JtYWxzWyBub3JtYWxJbmRleCBdXHJcblx0XHRcdFx0XHRcdCk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGlmICggaGFzRmFjZVZlcnRleE5vcm1hbCApIHtcclxuXHJcblx0XHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgMzsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0bm9ybWFsSW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF0gKiAzO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRub3JtYWwgPSBuZXcgVEhSRUUuVmVjdG9yMyhcclxuXHRcdFx0XHRcdFx0XHRcdG5vcm1hbHNbIG5vcm1hbEluZGV4ICsrIF0sXHJcblx0XHRcdFx0XHRcdFx0XHRub3JtYWxzWyBub3JtYWxJbmRleCArKyBdLFxyXG5cdFx0XHRcdFx0XHRcdFx0bm9ybWFsc1sgbm9ybWFsSW5kZXggXVxyXG5cdFx0XHRcdFx0XHRcdCk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGZhY2UudmVydGV4Tm9ybWFscy5wdXNoKCBub3JtYWwgKTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cclxuXHRcdFx0XHRcdGlmICggaGFzRmFjZUNvbG9yICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Y29sb3JJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXTtcclxuXHRcdFx0XHRcdFx0ZmFjZS5jb2xvci5zZXRIZXgoIGNvbG9yc1sgY29sb3JJbmRleCBdICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHJcblx0XHRcdFx0XHRpZiAoIGhhc0ZhY2VWZXJ0ZXhDb2xvciApIHtcclxuXHJcblx0XHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgMzsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0Y29sb3JJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXTtcclxuXHRcdFx0XHRcdFx0XHRmYWNlLnZlcnRleENvbG9ycy5wdXNoKCBuZXcgVEhSRUUuQ29sb3IoIGNvbG9yc1sgY29sb3JJbmRleCBdICkgKTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Z2VvbWV0cnkuZmFjZXMucHVzaCggZmFjZSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHRmdW5jdGlvbiBwYXJzZVNraW4oKSB7XHJcblxyXG5cdFx0XHR2YXIgaW5mbHVlbmNlc1BlclZlcnRleCA9ICgganNvbi5pbmZsdWVuY2VzUGVyVmVydGV4ICE9PSB1bmRlZmluZWQgKSA/IGpzb24uaW5mbHVlbmNlc1BlclZlcnRleCA6IDI7XHJcblxyXG5cdFx0XHRpZiAoIGpzb24uc2tpbldlaWdodHMgKSB7XHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGpzb24uc2tpbldlaWdodHMubGVuZ3RoOyBpIDwgbDsgaSArPSBpbmZsdWVuY2VzUGVyVmVydGV4ICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciB4ID0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbi5za2luV2VpZ2h0c1sgaSBdO1xyXG5cdFx0XHRcdFx0dmFyIHkgPSAoIGluZmx1ZW5jZXNQZXJWZXJ0ZXggPiAxICkgPyBqc29uLnNraW5XZWlnaHRzWyBpICsgMSBdIDogMDtcclxuXHRcdFx0XHRcdHZhciB6ID0gKCBpbmZsdWVuY2VzUGVyVmVydGV4ID4gMiApID8ganNvbi5za2luV2VpZ2h0c1sgaSArIDIgXSA6IDA7XHJcblx0XHRcdFx0XHR2YXIgdyA9ICggaW5mbHVlbmNlc1BlclZlcnRleCA+IDMgKSA/IGpzb24uc2tpbldlaWdodHNbIGkgKyAzIF0gOiAwO1xyXG5cclxuXHRcdFx0XHRcdGdlb21ldHJ5LnNraW5XZWlnaHRzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3I0KCB4LCB5LCB6LCB3ICkgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBqc29uLnNraW5JbmRpY2VzICkge1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBqc29uLnNraW5JbmRpY2VzLmxlbmd0aDsgaSA8IGw7IGkgKz0gaW5mbHVlbmNlc1BlclZlcnRleCApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgYSA9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb24uc2tpbkluZGljZXNbIGkgXTtcclxuXHRcdFx0XHRcdHZhciBiID0gKCBpbmZsdWVuY2VzUGVyVmVydGV4ID4gMSApID8ganNvbi5za2luSW5kaWNlc1sgaSArIDEgXSA6IDA7XHJcblx0XHRcdFx0XHR2YXIgYyA9ICggaW5mbHVlbmNlc1BlclZlcnRleCA+IDIgKSA/IGpzb24uc2tpbkluZGljZXNbIGkgKyAyIF0gOiAwO1xyXG5cdFx0XHRcdFx0dmFyIGQgPSAoIGluZmx1ZW5jZXNQZXJWZXJ0ZXggPiAzICkgPyBqc29uLnNraW5JbmRpY2VzWyBpICsgMyBdIDogMDtcclxuXHJcblx0XHRcdFx0XHRnZW9tZXRyeS5za2luSW5kaWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yNCggYSwgYiwgYywgZCApICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGdlb21ldHJ5LmJvbmVzID0ganNvbi5ib25lcztcclxuXHJcblx0XHRcdGlmICggZ2VvbWV0cnkuYm9uZXMgJiYgZ2VvbWV0cnkuYm9uZXMubGVuZ3RoID4gMCAmJiAoIGdlb21ldHJ5LnNraW5XZWlnaHRzLmxlbmd0aCAhPT0gZ2VvbWV0cnkuc2tpbkluZGljZXMubGVuZ3RoIHx8IGdlb21ldHJ5LnNraW5JbmRpY2VzLmxlbmd0aCAhPT0gZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoICkgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1doZW4gc2tpbm5pbmcsIG51bWJlciBvZiB2ZXJ0aWNlcyAoJyArIGdlb21ldHJ5LnZlcnRpY2VzLmxlbmd0aCArICcpLCBza2luSW5kaWNlcyAoJyArXHJcblx0XHRcdFx0XHRnZW9tZXRyeS5za2luSW5kaWNlcy5sZW5ndGggKyAnKSwgYW5kIHNraW5XZWlnaHRzICgnICsgZ2VvbWV0cnkuc2tpbldlaWdodHMubGVuZ3RoICsgJykgc2hvdWxkIG1hdGNoLicgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdGZ1bmN0aW9uIHBhcnNlTW9ycGhpbmcoIHNjYWxlICkge1xyXG5cclxuXHRcdFx0aWYgKCBqc29uLm1vcnBoVGFyZ2V0cyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBqc29uLm1vcnBoVGFyZ2V0cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdGdlb21ldHJ5Lm1vcnBoVGFyZ2V0c1sgaSBdID0ge307XHJcblx0XHRcdFx0XHRnZW9tZXRyeS5tb3JwaFRhcmdldHNbIGkgXS5uYW1lID0ganNvbi5tb3JwaFRhcmdldHNbIGkgXS5uYW1lO1xyXG5cdFx0XHRcdFx0Z2VvbWV0cnkubW9ycGhUYXJnZXRzWyBpIF0udmVydGljZXMgPSBbXTtcclxuXHJcblx0XHRcdFx0XHR2YXIgZHN0VmVydGljZXMgPSBnZW9tZXRyeS5tb3JwaFRhcmdldHNbIGkgXS52ZXJ0aWNlcztcclxuXHRcdFx0XHRcdHZhciBzcmNWZXJ0aWNlcyA9IGpzb24ubW9ycGhUYXJnZXRzWyBpIF0udmVydGljZXM7XHJcblxyXG5cdFx0XHRcdFx0Zm9yICggdmFyIHYgPSAwLCB2bCA9IHNyY1ZlcnRpY2VzLmxlbmd0aDsgdiA8IHZsOyB2ICs9IDMgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR2YXIgdmVydGV4ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdFx0XHRcdFx0dmVydGV4LnggPSBzcmNWZXJ0aWNlc1sgdiBdICogc2NhbGU7XHJcblx0XHRcdFx0XHRcdHZlcnRleC55ID0gc3JjVmVydGljZXNbIHYgKyAxIF0gKiBzY2FsZTtcclxuXHRcdFx0XHRcdFx0dmVydGV4LnogPSBzcmNWZXJ0aWNlc1sgdiArIDIgXSAqIHNjYWxlO1xyXG5cclxuXHRcdFx0XHRcdFx0ZHN0VmVydGljZXMucHVzaCggdmVydGV4ICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGpzb24ubW9ycGhDb2xvcnMgIT09IHVuZGVmaW5lZCAmJiBqc29uLm1vcnBoQ29sb3JzLmxlbmd0aCA+IDAgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkpTT05Mb2FkZXI6IFwibW9ycGhDb2xvcnNcIiBubyBsb25nZXIgc3VwcG9ydGVkLiBVc2luZyB0aGVtIGFzIGZhY2UgY29sb3JzLicgKTtcclxuXHJcblx0XHRcdFx0dmFyIGZhY2VzID0gZ2VvbWV0cnkuZmFjZXM7XHJcblx0XHRcdFx0dmFyIG1vcnBoQ29sb3JzID0ganNvbi5tb3JwaENvbG9yc1sgMCBdLmNvbG9ycztcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gZmFjZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRmYWNlc1sgaSBdLmNvbG9yLmZyb21BcnJheSggbW9ycGhDb2xvcnMsIGkgKiAzICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gcGFyc2VBbmltYXRpb25zKCkge1xyXG5cclxuXHRcdFx0dmFyIG91dHB1dEFuaW1hdGlvbnMgPSBbXTtcclxuXHJcblx0XHRcdC8vIHBhcnNlIG9sZCBzdHlsZSBCb25lL0hpZXJhcmNoeSBhbmltYXRpb25zXHJcblx0XHRcdHZhciBhbmltYXRpb25zID0gW107XHJcblxyXG5cdFx0XHRpZiAoIGpzb24uYW5pbWF0aW9uICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGFuaW1hdGlvbnMucHVzaCgganNvbi5hbmltYXRpb24gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICgganNvbi5hbmltYXRpb25zICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGlmICgganNvbi5hbmltYXRpb25zLmxlbmd0aCApIHtcclxuXHJcblx0XHRcdFx0XHRhbmltYXRpb25zID0gYW5pbWF0aW9ucy5jb25jYXQoIGpzb24uYW5pbWF0aW9ucyApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdGFuaW1hdGlvbnMucHVzaCgganNvbi5hbmltYXRpb25zICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGFuaW1hdGlvbnMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgY2xpcCA9IFRIUkVFLkFuaW1hdGlvbkNsaXAucGFyc2VBbmltYXRpb24oIGFuaW1hdGlvbnNbIGkgXSwgZ2VvbWV0cnkuYm9uZXMgKTtcclxuXHRcdFx0XHRpZiAoIGNsaXAgKSBvdXRwdXRBbmltYXRpb25zLnB1c2goIGNsaXAgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIHBhcnNlIGltcGxpY2l0IG1vcnBoIGFuaW1hdGlvbnNcclxuXHRcdFx0aWYgKCBnZW9tZXRyeS5tb3JwaFRhcmdldHMgKSB7XHJcblxyXG5cdFx0XHRcdC8vIFRPRE86IEZpZ3VyZSBvdXQgd2hhdCBhbiBhcHByb3ByYWl0ZSBGUFMgaXMgZm9yIG1vcnBoIHRhcmdldCBhbmltYXRpb25zIC0tIGRlZmF1bHRpbmcgdG8gMTAsIGJ1dCByZWFsbHkgaXQgaXMgY29tcGxldGVseSBhcmJpdHJhcnkuXHJcblx0XHRcdFx0dmFyIG1vcnBoQW5pbWF0aW9uQ2xpcHMgPSBUSFJFRS5BbmltYXRpb25DbGlwLkNyZWF0ZUNsaXBzRnJvbU1vcnBoVGFyZ2V0U2VxdWVuY2VzKCBnZW9tZXRyeS5tb3JwaFRhcmdldHMsIDEwICk7XHJcblx0XHRcdFx0b3V0cHV0QW5pbWF0aW9ucyA9IG91dHB1dEFuaW1hdGlvbnMuY29uY2F0KCBtb3JwaEFuaW1hdGlvbkNsaXBzICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIG91dHB1dEFuaW1hdGlvbnMubGVuZ3RoID4gMCApIGdlb21ldHJ5LmFuaW1hdGlvbnMgPSBvdXRwdXRBbmltYXRpb25zO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdFx0aWYgKCBqc29uLm1hdGVyaWFscyA9PT0gdW5kZWZpbmVkIHx8IGpzb24ubWF0ZXJpYWxzLmxlbmd0aCA9PT0gMCApIHtcclxuXHJcblx0XHRcdHJldHVybiB7IGdlb21ldHJ5OiBnZW9tZXRyeSB9O1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHR2YXIgbWF0ZXJpYWxzID0gVEhSRUUuTG9hZGVyLnByb3RvdHlwZS5pbml0TWF0ZXJpYWxzKCBqc29uLm1hdGVyaWFscywgdGV4dHVyZVBhdGgsIHRoaXMuY3Jvc3NPcmlnaW4gKTtcclxuXHJcblx0XHRcdHJldHVybiB7IGdlb21ldHJ5OiBnZW9tZXRyeSwgbWF0ZXJpYWxzOiBtYXRlcmlhbHMgfTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9sb2FkZXJzL0xvYWRpbmdNYW5hZ2VyLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5Mb2FkaW5nTWFuYWdlciA9IGZ1bmN0aW9uICggb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xyXG5cclxuXHR2YXIgc2NvcGUgPSB0aGlzO1xyXG5cclxuXHR2YXIgaXNMb2FkaW5nID0gZmFsc2UsIGl0ZW1zTG9hZGVkID0gMCwgaXRlbXNUb3RhbCA9IDA7XHJcblxyXG5cdHRoaXMub25TdGFydCA9IHVuZGVmaW5lZDtcclxuXHR0aGlzLm9uTG9hZCA9IG9uTG9hZDtcclxuXHR0aGlzLm9uUHJvZ3Jlc3MgPSBvblByb2dyZXNzO1xyXG5cdHRoaXMub25FcnJvciA9IG9uRXJyb3I7XHJcblxyXG5cdHRoaXMuaXRlbVN0YXJ0ID0gZnVuY3Rpb24gKCB1cmwgKSB7XHJcblxyXG5cdFx0aXRlbXNUb3RhbCArKztcclxuXHJcblx0XHRpZiAoIGlzTG9hZGluZyA9PT0gZmFsc2UgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHNjb3BlLm9uU3RhcnQgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0c2NvcGUub25TdGFydCggdXJsLCBpdGVtc0xvYWRlZCwgaXRlbXNUb3RhbCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpc0xvYWRpbmcgPSB0cnVlO1xyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLml0ZW1FbmQgPSBmdW5jdGlvbiAoIHVybCApIHtcclxuXHJcblx0XHRpdGVtc0xvYWRlZCArKztcclxuXHJcblx0XHRpZiAoIHNjb3BlLm9uUHJvZ3Jlc3MgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHNjb3BlLm9uUHJvZ3Jlc3MoIHVybCwgaXRlbXNMb2FkZWQsIGl0ZW1zVG90YWwgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBpdGVtc0xvYWRlZCA9PT0gaXRlbXNUb3RhbCApIHtcclxuXHJcblx0XHRcdGlzTG9hZGluZyA9IGZhbHNlO1xyXG5cclxuXHRcdFx0aWYgKCBzY29wZS5vbkxvYWQgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0c2NvcGUub25Mb2FkKCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLml0ZW1FcnJvciA9IGZ1bmN0aW9uICggdXJsICkge1xyXG5cclxuXHRcdGlmICggc2NvcGUub25FcnJvciAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0c2NvcGUub25FcnJvciggdXJsICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxufTtcclxuXHJcblRIUkVFLkRlZmF1bHRMb2FkaW5nTWFuYWdlciA9IG5ldyBUSFJFRS5Mb2FkaW5nTWFuYWdlcigpO1xyXG5cclxuLy8gRmlsZTpzcmMvbG9hZGVycy9CdWZmZXJHZW9tZXRyeUxvYWRlci5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuQnVmZmVyR2VvbWV0cnlMb2FkZXIgPSBmdW5jdGlvbiAoIG1hbmFnZXIgKSB7XHJcblxyXG5cdHRoaXMubWFuYWdlciA9ICggbWFuYWdlciAhPT0gdW5kZWZpbmVkICkgPyBtYW5hZ2VyIDogVEhSRUUuRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkJ1ZmZlckdlb21ldHJ5TG9hZGVyLnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLkJ1ZmZlckdlb21ldHJ5TG9hZGVyLFxyXG5cclxuXHRsb2FkOiBmdW5jdGlvbiAoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xyXG5cclxuXHRcdHZhciBzY29wZSA9IHRoaXM7XHJcblxyXG5cdFx0dmFyIGxvYWRlciA9IG5ldyBUSFJFRS5YSFJMb2FkZXIoIHNjb3BlLm1hbmFnZXIgKTtcclxuXHRcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggdGV4dCApIHtcclxuXHJcblx0XHRcdG9uTG9hZCggc2NvcGUucGFyc2UoIEpTT04ucGFyc2UoIHRleHQgKSApICk7XHJcblxyXG5cdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRwYXJzZTogZnVuY3Rpb24gKCBqc29uICkge1xyXG5cclxuXHRcdHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpO1xyXG5cclxuXHRcdHZhciBpbmRleCA9IGpzb24uZGF0YS5pbmRleDtcclxuXHJcblx0XHR2YXIgVFlQRURfQVJSQVlTID0ge1xyXG5cdFx0XHQnSW50OEFycmF5JzogSW50OEFycmF5LFxyXG5cdFx0XHQnVWludDhBcnJheSc6IFVpbnQ4QXJyYXksXHJcblx0XHRcdCdVaW50OENsYW1wZWRBcnJheSc6IFVpbnQ4Q2xhbXBlZEFycmF5LFxyXG5cdFx0XHQnSW50MTZBcnJheSc6IEludDE2QXJyYXksXHJcblx0XHRcdCdVaW50MTZBcnJheSc6IFVpbnQxNkFycmF5LFxyXG5cdFx0XHQnSW50MzJBcnJheSc6IEludDMyQXJyYXksXHJcblx0XHRcdCdVaW50MzJBcnJheSc6IFVpbnQzMkFycmF5LFxyXG5cdFx0XHQnRmxvYXQzMkFycmF5JzogRmxvYXQzMkFycmF5LFxyXG5cdFx0XHQnRmxvYXQ2NEFycmF5JzogRmxvYXQ2NEFycmF5XHJcblx0XHR9O1xyXG5cclxuXHRcdGlmICggaW5kZXggIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHZhciB0eXBlZEFycmF5ID0gbmV3IFRZUEVEX0FSUkFZU1sgaW5kZXgudHlwZSBdKCBpbmRleC5hcnJheSApO1xyXG5cdFx0XHRnZW9tZXRyeS5zZXRJbmRleCggbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggdHlwZWRBcnJheSwgMSApICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBhdHRyaWJ1dGVzID0ganNvbi5kYXRhLmF0dHJpYnV0ZXM7XHJcblxyXG5cdFx0Zm9yICggdmFyIGtleSBpbiBhdHRyaWJ1dGVzICkge1xyXG5cclxuXHRcdFx0dmFyIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbIGtleSBdO1xyXG5cdFx0XHR2YXIgdHlwZWRBcnJheSA9IG5ldyBUWVBFRF9BUlJBWVNbIGF0dHJpYnV0ZS50eXBlIF0oIGF0dHJpYnV0ZS5hcnJheSApO1xyXG5cclxuXHRcdFx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCBrZXksIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIHR5cGVkQXJyYXksIGF0dHJpYnV0ZS5pdGVtU2l6ZSApICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBncm91cHMgPSBqc29uLmRhdGEuZ3JvdXBzIHx8IGpzb24uZGF0YS5kcmF3Y2FsbHMgfHwganNvbi5kYXRhLm9mZnNldHM7XHJcblxyXG5cdFx0aWYgKCBncm91cHMgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMCwgbiA9IGdyb3Vwcy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBncm91cCA9IGdyb3Vwc1sgaSBdO1xyXG5cclxuXHRcdFx0XHRnZW9tZXRyeS5hZGRHcm91cCggZ3JvdXAuc3RhcnQsIGdyb3VwLmNvdW50LCBncm91cC5tYXRlcmlhbEluZGV4ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBib3VuZGluZ1NwaGVyZSA9IGpzb24uZGF0YS5ib3VuZGluZ1NwaGVyZTtcclxuXHJcblx0XHRpZiAoIGJvdW5kaW5nU3BoZXJlICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHR2YXIgY2VudGVyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHRcdGlmICggYm91bmRpbmdTcGhlcmUuY2VudGVyICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGNlbnRlci5mcm9tQXJyYXkoIGJvdW5kaW5nU3BoZXJlLmNlbnRlciApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Z2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgPSBuZXcgVEhSRUUuU3BoZXJlKCBjZW50ZXIsIGJvdW5kaW5nU3BoZXJlLnJhZGl1cyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZ2VvbWV0cnk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9sb2FkZXJzL01hdGVyaWFsTG9hZGVyLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5NYXRlcmlhbExvYWRlciA9IGZ1bmN0aW9uICggbWFuYWdlciApIHtcclxuXHJcblx0dGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBUSFJFRS5EZWZhdWx0TG9hZGluZ01hbmFnZXI7XHJcblx0dGhpcy50ZXh0dXJlcyA9IHt9O1xyXG5cclxufTtcclxuXHJcblRIUkVFLk1hdGVyaWFsTG9hZGVyLnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLk1hdGVyaWFsTG9hZGVyLFxyXG5cclxuXHRsb2FkOiBmdW5jdGlvbiAoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xyXG5cclxuXHRcdHZhciBzY29wZSA9IHRoaXM7XHJcblxyXG5cdFx0dmFyIGxvYWRlciA9IG5ldyBUSFJFRS5YSFJMb2FkZXIoIHNjb3BlLm1hbmFnZXIgKTtcclxuXHRcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggdGV4dCApIHtcclxuXHJcblx0XHRcdG9uTG9hZCggc2NvcGUucGFyc2UoIEpTT04ucGFyc2UoIHRleHQgKSApICk7XHJcblxyXG5cdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRUZXh0dXJlczogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0XHR0aGlzLnRleHR1cmVzID0gdmFsdWU7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldFRleHR1cmU6IGZ1bmN0aW9uICggbmFtZSApIHtcclxuXHJcblx0XHR2YXIgdGV4dHVyZXMgPSB0aGlzLnRleHR1cmVzO1xyXG5cclxuXHRcdGlmICggdGV4dHVyZXNbIG5hbWUgXSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0ZXJpYWxMb2FkZXI6IFVuZGVmaW5lZCB0ZXh0dXJlJywgbmFtZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGV4dHVyZXNbIG5hbWUgXTtcclxuXHJcblx0fSxcclxuXHJcblx0cGFyc2U6IGZ1bmN0aW9uICgganNvbiApIHtcclxuXHJcblx0XHR2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUVbIGpzb24udHlwZSBdO1xyXG5cclxuXHRcdGlmICgganNvbi51dWlkICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC51dWlkID0ganNvbi51dWlkO1xyXG5cdFx0aWYgKCBqc29uLm5hbWUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLm5hbWUgPSBqc29uLm5hbWU7XHJcblx0XHRpZiAoIGpzb24uY29sb3IgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmNvbG9yLnNldEhleCgganNvbi5jb2xvciApO1xyXG5cdFx0aWYgKCBqc29uLnJvdWdobmVzcyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwucm91Z2huZXNzID0ganNvbi5yb3VnaG5lc3M7XHJcblx0XHRpZiAoIGpzb24ubWV0YWxuZXNzICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5tZXRhbG5lc3MgPSBqc29uLm1ldGFsbmVzcztcclxuXHRcdGlmICgganNvbi5lbWlzc2l2ZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZW1pc3NpdmUuc2V0SGV4KCBqc29uLmVtaXNzaXZlICk7XHJcblx0XHRpZiAoIGpzb24uc3BlY3VsYXIgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnNwZWN1bGFyLnNldEhleCgganNvbi5zcGVjdWxhciApO1xyXG5cdFx0aWYgKCBqc29uLnNoaW5pbmVzcyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc2hpbmluZXNzID0ganNvbi5zaGluaW5lc3M7XHJcblx0XHRpZiAoIGpzb24udW5pZm9ybXMgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnVuaWZvcm1zID0ganNvbi51bmlmb3JtcztcclxuXHRcdGlmICgganNvbi52ZXJ0ZXhTaGFkZXIgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnZlcnRleFNoYWRlciA9IGpzb24udmVydGV4U2hhZGVyO1xyXG5cdFx0aWYgKCBqc29uLmZyYWdtZW50U2hhZGVyICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5mcmFnbWVudFNoYWRlciA9IGpzb24uZnJhZ21lbnRTaGFkZXI7XHJcblx0XHRpZiAoIGpzb24udmVydGV4Q29sb3JzICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgPSBqc29uLnZlcnRleENvbG9ycztcclxuXHRcdGlmICgganNvbi5zaGFkaW5nICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zaGFkaW5nID0ganNvbi5zaGFkaW5nO1xyXG5cdFx0aWYgKCBqc29uLmJsZW5kaW5nICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5ibGVuZGluZyA9IGpzb24uYmxlbmRpbmc7XHJcblx0XHRpZiAoIGpzb24uc2lkZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc2lkZSA9IGpzb24uc2lkZTtcclxuXHRcdGlmICgganNvbi5vcGFjaXR5ICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5vcGFjaXR5ID0ganNvbi5vcGFjaXR5O1xyXG5cdFx0aWYgKCBqc29uLnRyYW5zcGFyZW50ICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC50cmFuc3BhcmVudCA9IGpzb24udHJhbnNwYXJlbnQ7XHJcblx0XHRpZiAoIGpzb24uYWxwaGFUZXN0ICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5hbHBoYVRlc3QgPSBqc29uLmFscGhhVGVzdDtcclxuXHRcdGlmICgganNvbi5kZXB0aFRlc3QgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmRlcHRoVGVzdCA9IGpzb24uZGVwdGhUZXN0O1xyXG5cdFx0aWYgKCBqc29uLmRlcHRoV3JpdGUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmRlcHRoV3JpdGUgPSBqc29uLmRlcHRoV3JpdGU7XHJcblx0XHRpZiAoIGpzb24uY29sb3JXcml0ZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuY29sb3JXcml0ZSA9IGpzb24uY29sb3JXcml0ZTtcclxuXHRcdGlmICgganNvbi53aXJlZnJhbWUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLndpcmVmcmFtZSA9IGpzb24ud2lyZWZyYW1lO1xyXG5cdFx0aWYgKCBqc29uLndpcmVmcmFtZUxpbmV3aWR0aCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwud2lyZWZyYW1lTGluZXdpZHRoID0ganNvbi53aXJlZnJhbWVMaW5ld2lkdGg7XHJcblxyXG5cdFx0Ly8gZm9yIFBvaW50c01hdGVyaWFsXHJcblx0XHRpZiAoIGpzb24uc2l6ZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc2l6ZSA9IGpzb24uc2l6ZTtcclxuXHRcdGlmICgganNvbi5zaXplQXR0ZW51YXRpb24gIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnNpemVBdHRlbnVhdGlvbiA9IGpzb24uc2l6ZUF0dGVudWF0aW9uO1xyXG5cclxuXHRcdC8vIG1hcHNcclxuXHJcblx0XHRpZiAoIGpzb24ubWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5tYXAgPSB0aGlzLmdldFRleHR1cmUoIGpzb24ubWFwICk7XHJcblxyXG5cdFx0aWYgKCBqc29uLmFscGhhTWFwICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRtYXRlcmlhbC5hbHBoYU1hcCA9IHRoaXMuZ2V0VGV4dHVyZSgganNvbi5hbHBoYU1hcCApO1xyXG5cdFx0XHRtYXRlcmlhbC50cmFuc3BhcmVudCA9IHRydWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICgganNvbi5idW1wTWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5idW1wTWFwID0gdGhpcy5nZXRUZXh0dXJlKCBqc29uLmJ1bXBNYXAgKTtcclxuXHRcdGlmICgganNvbi5idW1wU2NhbGUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmJ1bXBTY2FsZSA9IGpzb24uYnVtcFNjYWxlO1xyXG5cclxuXHRcdGlmICgganNvbi5ub3JtYWxNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLm5vcm1hbE1hcCA9IHRoaXMuZ2V0VGV4dHVyZSgganNvbi5ub3JtYWxNYXAgKTtcclxuXHRcdGlmICgganNvbi5ub3JtYWxTY2FsZSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0dmFyIG5vcm1hbFNjYWxlID0ganNvbi5ub3JtYWxTY2FsZTtcclxuXHJcblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggbm9ybWFsU2NhbGUgKSA9PT0gZmFsc2UgKSB7XHJcblxyXG5cdFx0XHRcdC8vIEJsZW5kZXIgZXhwb3J0ZXIgdXNlZCB0byBleHBvcnQgYSBzY2FsYXIuIFNlZSAjNzQ1OVxyXG5cclxuXHRcdFx0XHRub3JtYWxTY2FsZSA9IFsgbm9ybWFsU2NhbGUsIG5vcm1hbFNjYWxlIF07XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRtYXRlcmlhbC5ub3JtYWxTY2FsZSA9IG5ldyBUSFJFRS5WZWN0b3IyKCkuZnJvbUFycmF5KCBub3JtYWxTY2FsZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGpzb24uZGlzcGxhY2VtZW50TWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXAgPSB0aGlzLmdldFRleHR1cmUoIGpzb24uZGlzcGxhY2VtZW50TWFwICk7XHJcblx0XHRpZiAoIGpzb24uZGlzcGxhY2VtZW50U2NhbGUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmRpc3BsYWNlbWVudFNjYWxlID0ganNvbi5kaXNwbGFjZW1lbnRTY2FsZTtcclxuXHRcdGlmICgganNvbi5kaXNwbGFjZW1lbnRCaWFzICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRCaWFzID0ganNvbi5kaXNwbGFjZW1lbnRCaWFzO1xyXG5cclxuXHRcdGlmICgganNvbi5yb3VnaG5lc3NNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnJvdWdobmVzc01hcCA9IHRoaXMuZ2V0VGV4dHVyZSgganNvbi5yb3VnaG5lc3NNYXAgKTtcclxuXHRcdGlmICgganNvbi5tZXRhbG5lc3NNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLm1ldGFsbmVzc01hcCA9IHRoaXMuZ2V0VGV4dHVyZSgganNvbi5tZXRhbG5lc3NNYXAgKTtcclxuXHJcblx0XHRpZiAoIGpzb24uZW1pc3NpdmVNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmVtaXNzaXZlTWFwID0gdGhpcy5nZXRUZXh0dXJlKCBqc29uLmVtaXNzaXZlTWFwICk7XHJcblx0XHRpZiAoIGpzb24uZW1pc3NpdmVJbnRlbnNpdHkgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmVtaXNzaXZlSW50ZW5zaXR5ID0ganNvbi5lbWlzc2l2ZUludGVuc2l0eTtcclxuXHJcblx0XHRpZiAoIGpzb24uc3BlY3VsYXJNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnNwZWN1bGFyTWFwID0gdGhpcy5nZXRUZXh0dXJlKCBqc29uLnNwZWN1bGFyTWFwICk7XHJcblxyXG5cdFx0aWYgKCBqc29uLmVudk1hcCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0bWF0ZXJpYWwuZW52TWFwID0gdGhpcy5nZXRUZXh0dXJlKCBqc29uLmVudk1hcCApO1xyXG5cdFx0XHRtYXRlcmlhbC5jb21iaW5lID0gVEhSRUUuTXVsdGlwbHlPcGVyYXRpb247XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICgganNvbi5yZWZsZWN0aXZpdHkgKSBtYXRlcmlhbC5yZWZsZWN0aXZpdHkgPSBqc29uLnJlZmxlY3Rpdml0eTtcclxuXHJcblx0XHRpZiAoIGpzb24ubGlnaHRNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmxpZ2h0TWFwID0gdGhpcy5nZXRUZXh0dXJlKCBqc29uLmxpZ2h0TWFwICk7XHJcblx0XHRpZiAoIGpzb24ubGlnaHRNYXBJbnRlbnNpdHkgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmxpZ2h0TWFwSW50ZW5zaXR5ID0ganNvbi5saWdodE1hcEludGVuc2l0eTtcclxuXHJcblx0XHRpZiAoIGpzb24uYW9NYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmFvTWFwID0gdGhpcy5nZXRUZXh0dXJlKCBqc29uLmFvTWFwICk7XHJcblx0XHRpZiAoIGpzb24uYW9NYXBJbnRlbnNpdHkgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmFvTWFwSW50ZW5zaXR5ID0ganNvbi5hb01hcEludGVuc2l0eTtcclxuXHJcblx0XHQvLyBNdWx0aU1hdGVyaWFsXHJcblxyXG5cdFx0aWYgKCBqc29uLm1hdGVyaWFscyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0ganNvbi5tYXRlcmlhbHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0bWF0ZXJpYWwubWF0ZXJpYWxzLnB1c2goIHRoaXMucGFyc2UoIGpzb24ubWF0ZXJpYWxzWyBpIF0gKSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbWF0ZXJpYWw7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9sb2FkZXJzL09iamVjdExvYWRlci5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuT2JqZWN0TG9hZGVyID0gZnVuY3Rpb24gKCBtYW5hZ2VyICkge1xyXG5cclxuXHR0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IFRIUkVFLkRlZmF1bHRMb2FkaW5nTWFuYWdlcjtcclxuXHR0aGlzLnRleHR1cmVQYXRoID0gJyc7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuT2JqZWN0TG9hZGVyLnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLk9iamVjdExvYWRlcixcclxuXHJcblx0bG9hZDogZnVuY3Rpb24gKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMudGV4dHVyZVBhdGggPT09ICcnICkge1xyXG5cclxuXHRcdFx0dGhpcy50ZXh0dXJlUGF0aCA9IHVybC5zdWJzdHJpbmcoIDAsIHVybC5sYXN0SW5kZXhPZiggJy8nICkgKyAxICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBzY29wZSA9IHRoaXM7XHJcblxyXG5cdFx0dmFyIGxvYWRlciA9IG5ldyBUSFJFRS5YSFJMb2FkZXIoIHNjb3BlLm1hbmFnZXIgKTtcclxuXHRcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggdGV4dCApIHtcclxuXHJcblx0XHRcdHNjb3BlLnBhcnNlKCBKU09OLnBhcnNlKCB0ZXh0ICksIG9uTG9hZCApO1xyXG5cclxuXHRcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0VGV4dHVyZVBhdGg6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdFx0dGhpcy50ZXh0dXJlUGF0aCA9IHZhbHVlO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRDcm9zc09yaWdpbjogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0XHR0aGlzLmNyb3NzT3JpZ2luID0gdmFsdWU7XHJcblxyXG5cdH0sXHJcblxyXG5cdHBhcnNlOiBmdW5jdGlvbiAoIGpzb24sIG9uTG9hZCApIHtcclxuXHJcblx0XHR2YXIgZ2VvbWV0cmllcyA9IHRoaXMucGFyc2VHZW9tZXRyaWVzKCBqc29uLmdlb21ldHJpZXMgKTtcclxuXHJcblx0XHR2YXIgaW1hZ2VzID0gdGhpcy5wYXJzZUltYWdlcygganNvbi5pbWFnZXMsIGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdGlmICggb25Mb2FkICE9PSB1bmRlZmluZWQgKSBvbkxvYWQoIG9iamVjdCApO1xyXG5cclxuXHRcdH0gKTtcclxuXHJcblx0XHR2YXIgdGV4dHVyZXMgID0gdGhpcy5wYXJzZVRleHR1cmVzKCBqc29uLnRleHR1cmVzLCBpbWFnZXMgKTtcclxuXHRcdHZhciBtYXRlcmlhbHMgPSB0aGlzLnBhcnNlTWF0ZXJpYWxzKCBqc29uLm1hdGVyaWFscywgdGV4dHVyZXMgKTtcclxuXHJcblx0XHR2YXIgb2JqZWN0ID0gdGhpcy5wYXJzZU9iamVjdCgganNvbi5vYmplY3QsIGdlb21ldHJpZXMsIG1hdGVyaWFscyApO1xyXG5cclxuXHRcdGlmICgganNvbi5hbmltYXRpb25zICkge1xyXG5cclxuXHRcdFx0b2JqZWN0LmFuaW1hdGlvbnMgPSB0aGlzLnBhcnNlQW5pbWF0aW9ucygganNvbi5hbmltYXRpb25zICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICgganNvbi5pbWFnZXMgPT09IHVuZGVmaW5lZCB8fCBqc29uLmltYWdlcy5sZW5ndGggPT09IDAgKSB7XHJcblxyXG5cdFx0XHRpZiAoIG9uTG9hZCAhPT0gdW5kZWZpbmVkICkgb25Mb2FkKCBvYmplY3QgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG9iamVjdDtcclxuXHJcblx0fSxcclxuXHJcblx0cGFyc2VHZW9tZXRyaWVzOiBmdW5jdGlvbiAoIGpzb24gKSB7XHJcblxyXG5cdFx0dmFyIGdlb21ldHJpZXMgPSB7fTtcclxuXHJcblx0XHRpZiAoIGpzb24gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHZhciBnZW9tZXRyeUxvYWRlciA9IG5ldyBUSFJFRS5KU09OTG9hZGVyKCk7XHJcblx0XHRcdHZhciBidWZmZXJHZW9tZXRyeUxvYWRlciA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeUxvYWRlcigpO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0ganNvbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgZ2VvbWV0cnk7XHJcblx0XHRcdFx0dmFyIGRhdGEgPSBqc29uWyBpIF07XHJcblxyXG5cdFx0XHRcdHN3aXRjaCAoIGRhdGEudHlwZSApIHtcclxuXHJcblx0XHRcdFx0XHRjYXNlICdQbGFuZUdlb21ldHJ5JzpcclxuXHRcdFx0XHRcdGNhc2UgJ1BsYW5lQnVmZmVyR2VvbWV0cnknOlxyXG5cclxuXHRcdFx0XHRcdFx0Z2VvbWV0cnkgPSBuZXcgVEhSRUVbIGRhdGEudHlwZSBdKFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEud2lkdGgsXHJcblx0XHRcdFx0XHRcdFx0ZGF0YS5oZWlnaHQsXHJcblx0XHRcdFx0XHRcdFx0ZGF0YS53aWR0aFNlZ21lbnRzLFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEuaGVpZ2h0U2VnbWVudHNcclxuXHRcdFx0XHRcdFx0KTtcclxuXHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgJ0JveEdlb21ldHJ5JzpcclxuXHRcdFx0XHRcdGNhc2UgJ0N1YmVHZW9tZXRyeSc6IC8vIGJhY2t3YXJkcyBjb21wYXRpYmxlXHJcblxyXG5cdFx0XHRcdFx0XHRnZW9tZXRyeSA9IG5ldyBUSFJFRS5Cb3hHZW9tZXRyeShcclxuXHRcdFx0XHRcdFx0XHRkYXRhLndpZHRoLFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEuaGVpZ2h0LFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEuZGVwdGgsXHJcblx0XHRcdFx0XHRcdFx0ZGF0YS53aWR0aFNlZ21lbnRzLFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEuaGVpZ2h0U2VnbWVudHMsXHJcblx0XHRcdFx0XHRcdFx0ZGF0YS5kZXB0aFNlZ21lbnRzXHJcblx0XHRcdFx0XHRcdCk7XHJcblxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlICdDaXJjbGVCdWZmZXJHZW9tZXRyeSc6XHJcblxyXG5cdFx0XHRcdFx0XHRnZW9tZXRyeSA9IG5ldyBUSFJFRS5DaXJjbGVCdWZmZXJHZW9tZXRyeShcclxuXHRcdFx0XHRcdFx0XHRkYXRhLnJhZGl1cyxcclxuXHRcdFx0XHRcdFx0XHRkYXRhLnNlZ21lbnRzLFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEudGhldGFTdGFydCxcclxuXHRcdFx0XHRcdFx0XHRkYXRhLnRoZXRhTGVuZ3RoXHJcblx0XHRcdFx0XHRcdCk7XHJcblxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlICdDaXJjbGVHZW9tZXRyeSc6XHJcblxyXG5cdFx0XHRcdFx0XHRnZW9tZXRyeSA9IG5ldyBUSFJFRS5DaXJjbGVHZW9tZXRyeShcclxuXHRcdFx0XHRcdFx0XHRkYXRhLnJhZGl1cyxcclxuXHRcdFx0XHRcdFx0XHRkYXRhLnNlZ21lbnRzLFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEudGhldGFTdGFydCxcclxuXHRcdFx0XHRcdFx0XHRkYXRhLnRoZXRhTGVuZ3RoXHJcblx0XHRcdFx0XHRcdCk7XHJcblxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlICdDeWxpbmRlckdlb21ldHJ5JzpcclxuXHJcblx0XHRcdFx0XHRcdGdlb21ldHJ5ID0gbmV3IFRIUkVFLkN5bGluZGVyR2VvbWV0cnkoXHJcblx0XHRcdFx0XHRcdFx0ZGF0YS5yYWRpdXNUb3AsXHJcblx0XHRcdFx0XHRcdFx0ZGF0YS5yYWRpdXNCb3R0b20sXHJcblx0XHRcdFx0XHRcdFx0ZGF0YS5oZWlnaHQsXHJcblx0XHRcdFx0XHRcdFx0ZGF0YS5yYWRpYWxTZWdtZW50cyxcclxuXHRcdFx0XHRcdFx0XHRkYXRhLmhlaWdodFNlZ21lbnRzLFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEub3BlbkVuZGVkLFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEudGhldGFTdGFydCxcclxuXHRcdFx0XHRcdFx0XHRkYXRhLnRoZXRhTGVuZ3RoXHJcblx0XHRcdFx0XHRcdCk7XHJcblxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlICdTcGhlcmVHZW9tZXRyeSc6XHJcblxyXG5cdFx0XHRcdFx0XHRnZW9tZXRyeSA9IG5ldyBUSFJFRS5TcGhlcmVHZW9tZXRyeShcclxuXHRcdFx0XHRcdFx0XHRkYXRhLnJhZGl1cyxcclxuXHRcdFx0XHRcdFx0XHRkYXRhLndpZHRoU2VnbWVudHMsXHJcblx0XHRcdFx0XHRcdFx0ZGF0YS5oZWlnaHRTZWdtZW50cyxcclxuXHRcdFx0XHRcdFx0XHRkYXRhLnBoaVN0YXJ0LFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEucGhpTGVuZ3RoLFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEudGhldGFTdGFydCxcclxuXHRcdFx0XHRcdFx0XHRkYXRhLnRoZXRhTGVuZ3RoXHJcblx0XHRcdFx0XHRcdCk7XHJcblxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlICdTcGhlcmVCdWZmZXJHZW9tZXRyeSc6XHJcblxyXG5cdFx0XHRcdFx0XHRnZW9tZXRyeSA9IG5ldyBUSFJFRS5TcGhlcmVCdWZmZXJHZW9tZXRyeShcclxuXHRcdFx0XHRcdFx0XHRkYXRhLnJhZGl1cyxcclxuXHRcdFx0XHRcdFx0XHRkYXRhLndpZHRoU2VnbWVudHMsXHJcblx0XHRcdFx0XHRcdFx0ZGF0YS5oZWlnaHRTZWdtZW50cyxcclxuXHRcdFx0XHRcdFx0XHRkYXRhLnBoaVN0YXJ0LFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEucGhpTGVuZ3RoLFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEudGhldGFTdGFydCxcclxuXHRcdFx0XHRcdFx0XHRkYXRhLnRoZXRhTGVuZ3RoXHJcblx0XHRcdFx0XHRcdCk7XHJcblxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlICdEb2RlY2FoZWRyb25HZW9tZXRyeSc6XHJcblxyXG5cdFx0XHRcdFx0XHRnZW9tZXRyeSA9IG5ldyBUSFJFRS5Eb2RlY2FoZWRyb25HZW9tZXRyeShcclxuXHRcdFx0XHRcdFx0XHRkYXRhLnJhZGl1cyxcclxuXHRcdFx0XHRcdFx0XHRkYXRhLmRldGFpbFxyXG5cdFx0XHRcdFx0XHQpO1xyXG5cclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSAnSWNvc2FoZWRyb25HZW9tZXRyeSc6XHJcblxyXG5cdFx0XHRcdFx0XHRnZW9tZXRyeSA9IG5ldyBUSFJFRS5JY29zYWhlZHJvbkdlb21ldHJ5KFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEucmFkaXVzLFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEuZGV0YWlsXHJcblx0XHRcdFx0XHRcdCk7XHJcblxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlICdPY3RhaGVkcm9uR2VvbWV0cnknOlxyXG5cclxuXHRcdFx0XHRcdFx0Z2VvbWV0cnkgPSBuZXcgVEhSRUUuT2N0YWhlZHJvbkdlb21ldHJ5KFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEucmFkaXVzLFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEuZGV0YWlsXHJcblx0XHRcdFx0XHRcdCk7XHJcblxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlICdUZXRyYWhlZHJvbkdlb21ldHJ5JzpcclxuXHJcblx0XHRcdFx0XHRcdGdlb21ldHJ5ID0gbmV3IFRIUkVFLlRldHJhaGVkcm9uR2VvbWV0cnkoXHJcblx0XHRcdFx0XHRcdFx0ZGF0YS5yYWRpdXMsXHJcblx0XHRcdFx0XHRcdFx0ZGF0YS5kZXRhaWxcclxuXHRcdFx0XHRcdFx0KTtcclxuXHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgJ1JpbmdHZW9tZXRyeSc6XHJcblxyXG5cdFx0XHRcdFx0XHRnZW9tZXRyeSA9IG5ldyBUSFJFRS5SaW5nR2VvbWV0cnkoXHJcblx0XHRcdFx0XHRcdFx0ZGF0YS5pbm5lclJhZGl1cyxcclxuXHRcdFx0XHRcdFx0XHRkYXRhLm91dGVyUmFkaXVzLFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEudGhldGFTZWdtZW50cyxcclxuXHRcdFx0XHRcdFx0XHRkYXRhLnBoaVNlZ21lbnRzLFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEudGhldGFTdGFydCxcclxuXHRcdFx0XHRcdFx0XHRkYXRhLnRoZXRhTGVuZ3RoXHJcblx0XHRcdFx0XHRcdCk7XHJcblxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlICdUb3J1c0dlb21ldHJ5JzpcclxuXHJcblx0XHRcdFx0XHRcdGdlb21ldHJ5ID0gbmV3IFRIUkVFLlRvcnVzR2VvbWV0cnkoXHJcblx0XHRcdFx0XHRcdFx0ZGF0YS5yYWRpdXMsXHJcblx0XHRcdFx0XHRcdFx0ZGF0YS50dWJlLFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEucmFkaWFsU2VnbWVudHMsXHJcblx0XHRcdFx0XHRcdFx0ZGF0YS50dWJ1bGFyU2VnbWVudHMsXHJcblx0XHRcdFx0XHRcdFx0ZGF0YS5hcmNcclxuXHRcdFx0XHRcdFx0KTtcclxuXHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgJ1RvcnVzS25vdEdlb21ldHJ5JzpcclxuXHJcblx0XHRcdFx0XHRcdGdlb21ldHJ5ID0gbmV3IFRIUkVFLlRvcnVzS25vdEdlb21ldHJ5KFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEucmFkaXVzLFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEudHViZSxcclxuXHRcdFx0XHRcdFx0XHRkYXRhLnJhZGlhbFNlZ21lbnRzLFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEudHVidWxhclNlZ21lbnRzLFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEucCxcclxuXHRcdFx0XHRcdFx0XHRkYXRhLnEsXHJcblx0XHRcdFx0XHRcdFx0ZGF0YS5oZWlnaHRTY2FsZVxyXG5cdFx0XHRcdFx0XHQpO1xyXG5cclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSAnTGF0aGVHZW9tZXRyeSc6XHJcblxyXG5cdFx0XHRcdFx0XHRnZW9tZXRyeSA9IG5ldyBUSFJFRS5MYXRoZUdlb21ldHJ5KFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEucG9pbnRzLFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEuc2VnbWVudHMsXHJcblx0XHRcdFx0XHRcdFx0ZGF0YS5waGlTdGFydCxcclxuXHRcdFx0XHRcdFx0XHRkYXRhLnBoaUxlbmd0aFxyXG5cdFx0XHRcdFx0XHQpO1xyXG5cclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSAnQnVmZmVyR2VvbWV0cnknOlxyXG5cclxuXHRcdFx0XHRcdFx0Z2VvbWV0cnkgPSBidWZmZXJHZW9tZXRyeUxvYWRlci5wYXJzZSggZGF0YSApO1xyXG5cclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSAnR2VvbWV0cnknOlxyXG5cclxuXHRcdFx0XHRcdFx0Z2VvbWV0cnkgPSBnZW9tZXRyeUxvYWRlci5wYXJzZSggZGF0YS5kYXRhLCB0aGlzLnRleHR1cmVQYXRoICkuZ2VvbWV0cnk7XHJcblxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRkZWZhdWx0OlxyXG5cclxuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0TG9hZGVyOiBVbnN1cHBvcnRlZCBnZW9tZXRyeSB0eXBlIFwiJyArIGRhdGEudHlwZSArICdcIicgKTtcclxuXHJcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGdlb21ldHJ5LnV1aWQgPSBkYXRhLnV1aWQ7XHJcblxyXG5cdFx0XHRcdGlmICggZGF0YS5uYW1lICE9PSB1bmRlZmluZWQgKSBnZW9tZXRyeS5uYW1lID0gZGF0YS5uYW1lO1xyXG5cclxuXHRcdFx0XHRnZW9tZXRyaWVzWyBkYXRhLnV1aWQgXSA9IGdlb21ldHJ5O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZ2VvbWV0cmllcztcclxuXHJcblx0fSxcclxuXHJcblx0cGFyc2VNYXRlcmlhbHM6IGZ1bmN0aW9uICgganNvbiwgdGV4dHVyZXMgKSB7XHJcblxyXG5cdFx0dmFyIG1hdGVyaWFscyA9IHt9O1xyXG5cclxuXHRcdGlmICgganNvbiAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0dmFyIGxvYWRlciA9IG5ldyBUSFJFRS5NYXRlcmlhbExvYWRlcigpO1xyXG5cdFx0XHRsb2FkZXIuc2V0VGV4dHVyZXMoIHRleHR1cmVzICk7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBqc29uLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBtYXRlcmlhbCA9IGxvYWRlci5wYXJzZSgganNvblsgaSBdICk7XHJcblx0XHRcdFx0bWF0ZXJpYWxzWyBtYXRlcmlhbC51dWlkIF0gPSBtYXRlcmlhbDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG1hdGVyaWFscztcclxuXHJcblx0fSxcclxuXHJcblx0cGFyc2VBbmltYXRpb25zOiBmdW5jdGlvbiAoIGpzb24gKSB7XHJcblxyXG5cdFx0dmFyIGFuaW1hdGlvbnMgPSBbXTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBqc29uLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciBjbGlwID0gVEhSRUUuQW5pbWF0aW9uQ2xpcC5wYXJzZSgganNvblsgaSBdICk7XHJcblxyXG5cdFx0XHRhbmltYXRpb25zLnB1c2goIGNsaXAgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGFuaW1hdGlvbnM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHBhcnNlSW1hZ2VzOiBmdW5jdGlvbiAoIGpzb24sIG9uTG9hZCApIHtcclxuXHJcblx0XHR2YXIgc2NvcGUgPSB0aGlzO1xyXG5cdFx0dmFyIGltYWdlcyA9IHt9O1xyXG5cclxuXHRcdGZ1bmN0aW9uIGxvYWRJbWFnZSggdXJsICkge1xyXG5cclxuXHRcdFx0c2NvcGUubWFuYWdlci5pdGVtU3RhcnQoIHVybCApO1xyXG5cclxuXHRcdFx0cmV0dXJuIGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRW5kKCB1cmwgKTtcclxuXHJcblx0XHRcdH0gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBqc29uICE9PSB1bmRlZmluZWQgJiYganNvbi5sZW5ndGggPiAwICkge1xyXG5cclxuXHRcdFx0dmFyIG1hbmFnZXIgPSBuZXcgVEhSRUUuTG9hZGluZ01hbmFnZXIoIG9uTG9hZCApO1xyXG5cclxuXHRcdFx0dmFyIGxvYWRlciA9IG5ldyBUSFJFRS5JbWFnZUxvYWRlciggbWFuYWdlciApO1xyXG5cdFx0XHRsb2FkZXIuc2V0Q3Jvc3NPcmlnaW4oIHRoaXMuY3Jvc3NPcmlnaW4gKTtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGpzb24ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0dmFyIGltYWdlID0ganNvblsgaSBdO1xyXG5cdFx0XHRcdHZhciBwYXRoID0gL14oXFwvXFwvKXwoW2Etel0rOihcXC9cXC8pPykvaS50ZXN0KCBpbWFnZS51cmwgKSA/IGltYWdlLnVybCA6IHNjb3BlLnRleHR1cmVQYXRoICsgaW1hZ2UudXJsO1xyXG5cclxuXHRcdFx0XHRpbWFnZXNbIGltYWdlLnV1aWQgXSA9IGxvYWRJbWFnZSggcGF0aCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gaW1hZ2VzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRwYXJzZVRleHR1cmVzOiBmdW5jdGlvbiAoIGpzb24sIGltYWdlcyApIHtcclxuXHJcblx0XHRmdW5jdGlvbiBwYXJzZUNvbnN0YW50KCB2YWx1ZSApIHtcclxuXHJcblx0XHRcdGlmICggdHlwZW9mKCB2YWx1ZSApID09PSAnbnVtYmVyJyApIHJldHVybiB2YWx1ZTtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdExvYWRlci5wYXJzZVRleHR1cmU6IENvbnN0YW50IHNob3VsZCBiZSBpbiBudW1lcmljIGZvcm0uJywgdmFsdWUgKTtcclxuXHJcblx0XHRcdHJldHVybiBUSFJFRVsgdmFsdWUgXTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHRleHR1cmVzID0ge307XHJcblxyXG5cdFx0aWYgKCBqc29uICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBqc29uLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBkYXRhID0ganNvblsgaSBdO1xyXG5cclxuXHRcdFx0XHRpZiAoIGRhdGEuaW1hZ2UgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3RMb2FkZXI6IE5vIFwiaW1hZ2VcIiBzcGVjaWZpZWQgZm9yJywgZGF0YS51dWlkICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCBpbWFnZXNbIGRhdGEuaW1hZ2UgXSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdExvYWRlcjogVW5kZWZpbmVkIGltYWdlJywgZGF0YS5pbWFnZSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHZhciB0ZXh0dXJlID0gbmV3IFRIUkVFLlRleHR1cmUoIGltYWdlc1sgZGF0YS5pbWFnZSBdICk7XHJcblx0XHRcdFx0dGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0XHRcdHRleHR1cmUudXVpZCA9IGRhdGEudXVpZDtcclxuXHJcblx0XHRcdFx0aWYgKCBkYXRhLm5hbWUgIT09IHVuZGVmaW5lZCApIHRleHR1cmUubmFtZSA9IGRhdGEubmFtZTtcclxuXHRcdFx0XHRpZiAoIGRhdGEubWFwcGluZyAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS5tYXBwaW5nID0gcGFyc2VDb25zdGFudCggZGF0YS5tYXBwaW5nICk7XHJcblx0XHRcdFx0aWYgKCBkYXRhLm9mZnNldCAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS5vZmZzZXQgPSBuZXcgVEhSRUUuVmVjdG9yMiggZGF0YS5vZmZzZXRbIDAgXSwgZGF0YS5vZmZzZXRbIDEgXSApO1xyXG5cdFx0XHRcdGlmICggZGF0YS5yZXBlYXQgIT09IHVuZGVmaW5lZCApIHRleHR1cmUucmVwZWF0ID0gbmV3IFRIUkVFLlZlY3RvcjIoIGRhdGEucmVwZWF0WyAwIF0sIGRhdGEucmVwZWF0WyAxIF0gKTtcclxuXHRcdFx0XHRpZiAoIGRhdGEubWluRmlsdGVyICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLm1pbkZpbHRlciA9IHBhcnNlQ29uc3RhbnQoIGRhdGEubWluRmlsdGVyICk7XHJcblx0XHRcdFx0aWYgKCBkYXRhLm1hZ0ZpbHRlciAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS5tYWdGaWx0ZXIgPSBwYXJzZUNvbnN0YW50KCBkYXRhLm1hZ0ZpbHRlciApO1xyXG5cdFx0XHRcdGlmICggZGF0YS5hbmlzb3Ryb3B5ICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLmFuaXNvdHJvcHkgPSBkYXRhLmFuaXNvdHJvcHk7XHJcblx0XHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBkYXRhLndyYXAgKSApIHtcclxuXHJcblx0XHRcdFx0XHR0ZXh0dXJlLndyYXBTID0gcGFyc2VDb25zdGFudCggZGF0YS53cmFwWyAwIF0gKTtcclxuXHRcdFx0XHRcdHRleHR1cmUud3JhcFQgPSBwYXJzZUNvbnN0YW50KCBkYXRhLndyYXBbIDEgXSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRleHR1cmVzWyBkYXRhLnV1aWQgXSA9IHRleHR1cmU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0ZXh0dXJlcztcclxuXHJcblx0fSxcclxuXHJcblx0cGFyc2VPYmplY3Q6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgbWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBkYXRhLCBnZW9tZXRyaWVzLCBtYXRlcmlhbHMgKSB7XHJcblxyXG5cdFx0XHR2YXIgb2JqZWN0O1xyXG5cclxuXHRcdFx0ZnVuY3Rpb24gZ2V0R2VvbWV0cnkoIG5hbWUgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggZ2VvbWV0cmllc1sgbmFtZSBdID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0TG9hZGVyOiBVbmRlZmluZWQgZ2VvbWV0cnknLCBuYW1lICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0cmV0dXJuIGdlb21ldHJpZXNbIG5hbWUgXTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZ1bmN0aW9uIGdldE1hdGVyaWFsKCBuYW1lICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIG5hbWUgPT09IHVuZGVmaW5lZCApIHJldHVybiB1bmRlZmluZWQ7XHJcblxyXG5cdFx0XHRcdGlmICggbWF0ZXJpYWxzWyBuYW1lIF0gPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3RMb2FkZXI6IFVuZGVmaW5lZCBtYXRlcmlhbCcsIG5hbWUgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXR1cm4gbWF0ZXJpYWxzWyBuYW1lIF07XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRzd2l0Y2ggKCBkYXRhLnR5cGUgKSB7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ1NjZW5lJzpcclxuXHJcblx0XHRcdFx0XHRvYmplY3QgPSBuZXcgVEhSRUUuU2NlbmUoKTtcclxuXHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnUGVyc3BlY3RpdmVDYW1lcmEnOlxyXG5cclxuXHRcdFx0XHRcdG9iamVjdCA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSggZGF0YS5mb3YsIGRhdGEuYXNwZWN0LCBkYXRhLm5lYXIsIGRhdGEuZmFyICk7XHJcblxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ09ydGhvZ3JhcGhpY0NhbWVyYSc6XHJcblxyXG5cdFx0XHRcdFx0b2JqZWN0ID0gbmV3IFRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYSggZGF0YS5sZWZ0LCBkYXRhLnJpZ2h0LCBkYXRhLnRvcCwgZGF0YS5ib3R0b20sIGRhdGEubmVhciwgZGF0YS5mYXIgKTtcclxuXHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnQW1iaWVudExpZ2h0JzpcclxuXHJcblx0XHRcdFx0XHRvYmplY3QgPSBuZXcgVEhSRUUuQW1iaWVudExpZ2h0KCBkYXRhLmNvbG9yLCBkYXRhLmludGVuc2l0eSApO1xyXG5cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICdEaXJlY3Rpb25hbExpZ2h0JzpcclxuXHJcblx0XHRcdFx0XHRvYmplY3QgPSBuZXcgVEhSRUUuRGlyZWN0aW9uYWxMaWdodCggZGF0YS5jb2xvciwgZGF0YS5pbnRlbnNpdHkgKTtcclxuXHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnUG9pbnRMaWdodCc6XHJcblxyXG5cdFx0XHRcdFx0b2JqZWN0ID0gbmV3IFRIUkVFLlBvaW50TGlnaHQoIGRhdGEuY29sb3IsIGRhdGEuaW50ZW5zaXR5LCBkYXRhLmRpc3RhbmNlLCBkYXRhLmRlY2F5ICk7XHJcblxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ1Nwb3RMaWdodCc6XHJcblxyXG5cdFx0XHRcdFx0b2JqZWN0ID0gbmV3IFRIUkVFLlNwb3RMaWdodCggZGF0YS5jb2xvciwgZGF0YS5pbnRlbnNpdHksIGRhdGEuZGlzdGFuY2UsIGRhdGEuYW5nbGUsIGRhdGEuZXhwb25lbnQsIGRhdGEuZGVjYXkgKTtcclxuXHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnSGVtaXNwaGVyZUxpZ2h0JzpcclxuXHJcblx0XHRcdFx0XHRvYmplY3QgPSBuZXcgVEhSRUUuSGVtaXNwaGVyZUxpZ2h0KCBkYXRhLmNvbG9yLCBkYXRhLmdyb3VuZENvbG9yLCBkYXRhLmludGVuc2l0eSApO1xyXG5cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICdNZXNoJzpcclxuXHJcblx0XHRcdFx0XHR2YXIgZ2VvbWV0cnkgPSBnZXRHZW9tZXRyeSggZGF0YS5nZW9tZXRyeSApO1xyXG5cdFx0XHRcdFx0dmFyIG1hdGVyaWFsID0gZ2V0TWF0ZXJpYWwoIGRhdGEubWF0ZXJpYWwgKTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGdlb21ldHJ5LmJvbmVzICYmIGdlb21ldHJ5LmJvbmVzLmxlbmd0aCA+IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRvYmplY3QgPSBuZXcgVEhSRUUuU2tpbm5lZE1lc2goIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRvYmplY3QgPSBuZXcgVEhSRUUuTWVzaCggZ2VvbWV0cnksIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICdMT0QnOlxyXG5cclxuXHRcdFx0XHRcdG9iamVjdCA9IG5ldyBUSFJFRS5MT0QoKTtcclxuXHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnTGluZSc6XHJcblxyXG5cdFx0XHRcdFx0b2JqZWN0ID0gbmV3IFRIUkVFLkxpbmUoIGdldEdlb21ldHJ5KCBkYXRhLmdlb21ldHJ5ICksIGdldE1hdGVyaWFsKCBkYXRhLm1hdGVyaWFsICksIGRhdGEubW9kZSApO1xyXG5cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICdQb2ludENsb3VkJzpcclxuXHRcdFx0XHRjYXNlICdQb2ludHMnOlxyXG5cclxuXHRcdFx0XHRcdG9iamVjdCA9IG5ldyBUSFJFRS5Qb2ludHMoIGdldEdlb21ldHJ5KCBkYXRhLmdlb21ldHJ5ICksIGdldE1hdGVyaWFsKCBkYXRhLm1hdGVyaWFsICkgKTtcclxuXHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnU3ByaXRlJzpcclxuXHJcblx0XHRcdFx0XHRvYmplY3QgPSBuZXcgVEhSRUUuU3ByaXRlKCBnZXRNYXRlcmlhbCggZGF0YS5tYXRlcmlhbCApICk7XHJcblxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ0dyb3VwJzpcclxuXHJcblx0XHRcdFx0XHRvYmplY3QgPSBuZXcgVEhSRUUuR3JvdXAoKTtcclxuXHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0ZGVmYXVsdDpcclxuXHJcblx0XHRcdFx0XHRvYmplY3QgPSBuZXcgVEhSRUUuT2JqZWN0M0QoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdG9iamVjdC51dWlkID0gZGF0YS51dWlkO1xyXG5cclxuXHRcdFx0aWYgKCBkYXRhLm5hbWUgIT09IHVuZGVmaW5lZCApIG9iamVjdC5uYW1lID0gZGF0YS5uYW1lO1xyXG5cdFx0XHRpZiAoIGRhdGEubWF0cml4ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdG1hdHJpeC5mcm9tQXJyYXkoIGRhdGEubWF0cml4ICk7XHJcblx0XHRcdFx0bWF0cml4LmRlY29tcG9zZSggb2JqZWN0LnBvc2l0aW9uLCBvYmplY3QucXVhdGVybmlvbiwgb2JqZWN0LnNjYWxlICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRpZiAoIGRhdGEucG9zaXRpb24gIT09IHVuZGVmaW5lZCApIG9iamVjdC5wb3NpdGlvbi5mcm9tQXJyYXkoIGRhdGEucG9zaXRpb24gKTtcclxuXHRcdFx0XHRpZiAoIGRhdGEucm90YXRpb24gIT09IHVuZGVmaW5lZCApIG9iamVjdC5yb3RhdGlvbi5mcm9tQXJyYXkoIGRhdGEucm90YXRpb24gKTtcclxuXHRcdFx0XHRpZiAoIGRhdGEuc2NhbGUgIT09IHVuZGVmaW5lZCApIG9iamVjdC5zY2FsZS5mcm9tQXJyYXkoIGRhdGEuc2NhbGUgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggZGF0YS5jYXN0U2hhZG93ICE9PSB1bmRlZmluZWQgKSBvYmplY3QuY2FzdFNoYWRvdyA9IGRhdGEuY2FzdFNoYWRvdztcclxuXHRcdFx0aWYgKCBkYXRhLnJlY2VpdmVTaGFkb3cgIT09IHVuZGVmaW5lZCApIG9iamVjdC5yZWNlaXZlU2hhZG93ID0gZGF0YS5yZWNlaXZlU2hhZG93O1xyXG5cclxuXHRcdFx0aWYgKCBkYXRhLnZpc2libGUgIT09IHVuZGVmaW5lZCApIG9iamVjdC52aXNpYmxlID0gZGF0YS52aXNpYmxlO1xyXG5cdFx0XHRpZiAoIGRhdGEudXNlckRhdGEgIT09IHVuZGVmaW5lZCApIG9iamVjdC51c2VyRGF0YSA9IGRhdGEudXNlckRhdGE7XHJcblxyXG5cdFx0XHRpZiAoIGRhdGEuY2hpbGRyZW4gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGNoaWxkIGluIGRhdGEuY2hpbGRyZW4gKSB7XHJcblxyXG5cdFx0XHRcdFx0b2JqZWN0LmFkZCggdGhpcy5wYXJzZU9iamVjdCggZGF0YS5jaGlsZHJlblsgY2hpbGQgXSwgZ2VvbWV0cmllcywgbWF0ZXJpYWxzICkgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBkYXRhLnR5cGUgPT09ICdMT0QnICkge1xyXG5cclxuXHRcdFx0XHR2YXIgbGV2ZWxzID0gZGF0YS5sZXZlbHM7XHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciBsID0gMDsgbCA8IGxldmVscy5sZW5ndGg7IGwgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIGxldmVsID0gbGV2ZWxzWyBsIF07XHJcblx0XHRcdFx0XHR2YXIgY2hpbGQgPSBvYmplY3QuZ2V0T2JqZWN0QnlQcm9wZXJ0eSggJ3V1aWQnLCBsZXZlbC5vYmplY3QgKTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGNoaWxkICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRvYmplY3QuYWRkTGV2ZWwoIGNoaWxkLCBsZXZlbC5kaXN0YW5jZSApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIG9iamVjdDtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0oKVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2xvYWRlcnMvVGV4dHVyZUxvYWRlci5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuVGV4dHVyZUxvYWRlciA9IGZ1bmN0aW9uICggbWFuYWdlciApIHtcclxuXHJcblx0dGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBUSFJFRS5EZWZhdWx0TG9hZGluZ01hbmFnZXI7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuVGV4dHVyZUxvYWRlci5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5UZXh0dXJlTG9hZGVyLFxyXG5cclxuXHRsb2FkOiBmdW5jdGlvbiAoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xyXG5cclxuXHRcdHZhciB0ZXh0dXJlID0gbmV3IFRIUkVFLlRleHR1cmUoKTtcclxuXHJcblx0XHR2YXIgbG9hZGVyID0gbmV3IFRIUkVFLkltYWdlTG9hZGVyKCB0aGlzLm1hbmFnZXIgKTtcclxuXHRcdGxvYWRlci5zZXRDcm9zc09yaWdpbiggdGhpcy5jcm9zc09yaWdpbiApO1xyXG5cdFx0bG9hZGVyLnNldFBhdGgoIHRoaXMucGF0aCApO1xyXG5cdFx0bG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCBpbWFnZSApIHtcclxuXHJcblx0XHRcdHRleHR1cmUuaW1hZ2UgPSBpbWFnZTtcclxuXHRcdFx0dGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0XHRpZiAoIG9uTG9hZCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRvbkxvYWQoIHRleHR1cmUgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XHJcblxyXG5cdFx0cmV0dXJuIHRleHR1cmU7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldENyb3NzT3JpZ2luOiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdHRoaXMuY3Jvc3NPcmlnaW4gPSB2YWx1ZTtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0UGF0aDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0XHR0aGlzLnBhdGggPSB2YWx1ZTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2xvYWRlcnMvQ3ViZVRleHR1cmVMb2FkZXIuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkN1YmVUZXh0dXJlTG9hZGVyID0gZnVuY3Rpb24gKCBtYW5hZ2VyICkge1xyXG5cclxuXHR0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IFRIUkVFLkRlZmF1bHRMb2FkaW5nTWFuYWdlcjtcclxuXHJcbn07XHJcblxyXG5USFJFRS5DdWJlVGV4dHVyZUxvYWRlci5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5DdWJlVGV4dHVyZUxvYWRlcixcclxuXHJcblx0bG9hZDogZnVuY3Rpb24gKCB1cmxzLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XHJcblxyXG5cdFx0dmFyIHRleHR1cmUgPSBuZXcgVEhSRUUuQ3ViZVRleHR1cmUoIFtdICk7XHJcblxyXG5cdFx0dmFyIGxvYWRlciA9IG5ldyBUSFJFRS5JbWFnZUxvYWRlciggdGhpcy5tYW5hZ2VyICk7XHJcblx0XHRsb2FkZXIuc2V0Q3Jvc3NPcmlnaW4oIHRoaXMuY3Jvc3NPcmlnaW4gKTtcclxuXHRcdGxvYWRlci5zZXRQYXRoKCB0aGlzLnBhdGggKTtcclxuXHJcblx0XHR2YXIgbG9hZGVkID0gMDtcclxuXHJcblx0XHRmdW5jdGlvbiBsb2FkVGV4dHVyZSggaSApIHtcclxuXHJcblx0XHRcdGxvYWRlci5sb2FkKCB1cmxzWyBpIF0sIGZ1bmN0aW9uICggaW1hZ2UgKSB7XHJcblxyXG5cdFx0XHRcdHRleHR1cmUuaW1hZ2VzWyBpIF0gPSBpbWFnZTtcclxuXHJcblx0XHRcdFx0bG9hZGVkICsrO1xyXG5cclxuXHRcdFx0XHRpZiAoIGxvYWRlZCA9PT0gNiApIHtcclxuXHJcblx0XHRcdFx0XHR0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIG9uTG9hZCApIG9uTG9hZCggdGV4dHVyZSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9LCB1bmRlZmluZWQsIG9uRXJyb3IgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdXJscy5sZW5ndGg7ICsrIGkgKSB7XHJcblxyXG5cdFx0XHRsb2FkVGV4dHVyZSggaSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGV4dHVyZTtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0Q3Jvc3NPcmlnaW46IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdFx0dGhpcy5jcm9zc09yaWdpbiA9IHZhbHVlO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRQYXRoOiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdHRoaXMucGF0aCA9IHZhbHVlO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbG9hZGVycy9CaW5hcnlUZXh0dXJlTG9hZGVyLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBOaWtvcyBNLiAvIGh0dHBzOi8vZ2l0aHViLmNvbS9mb28xMjMvXHJcbiAqXHJcbiAqIEFic3RyYWN0IEJhc2UgY2xhc3MgdG8gbG9hZCBnZW5lcmljIGJpbmFyeSB0ZXh0dXJlcyBmb3JtYXRzIChyZ2JlLCBoZHIsIC4uLilcclxuICovXHJcblxyXG5USFJFRS5EYXRhVGV4dHVyZUxvYWRlciA9IFRIUkVFLkJpbmFyeVRleHR1cmVMb2FkZXIgPSBmdW5jdGlvbiAoIG1hbmFnZXIgKSB7XHJcblxyXG5cdHRoaXMubWFuYWdlciA9ICggbWFuYWdlciAhPT0gdW5kZWZpbmVkICkgPyBtYW5hZ2VyIDogVEhSRUUuRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xyXG5cclxuXHQvLyBvdmVycmlkZSBpbiBzdWIgY2xhc3Nlc1xyXG5cdHRoaXMuX3BhcnNlciA9IG51bGw7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQmluYXJ5VGV4dHVyZUxvYWRlci5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5CaW5hcnlUZXh0dXJlTG9hZGVyLFxyXG5cclxuXHRsb2FkOiBmdW5jdGlvbiAoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xyXG5cclxuXHRcdHZhciBzY29wZSA9IHRoaXM7XHJcblxyXG5cdFx0dmFyIHRleHR1cmUgPSBuZXcgVEhSRUUuRGF0YVRleHR1cmUoKTtcclxuXHJcblx0XHR2YXIgbG9hZGVyID0gbmV3IFRIUkVFLlhIUkxvYWRlciggdGhpcy5tYW5hZ2VyICk7XHJcblx0XHRsb2FkZXIuc2V0UmVzcG9uc2VUeXBlKCAnYXJyYXlidWZmZXInICk7XHJcblxyXG5cdFx0bG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCBidWZmZXIgKSB7XHJcblxyXG5cdFx0XHR2YXIgdGV4RGF0YSA9IHNjb3BlLl9wYXJzZXIoIGJ1ZmZlciApO1xyXG5cclxuXHRcdFx0aWYgKCAhIHRleERhdGEgKSByZXR1cm47XHJcblxyXG5cdFx0XHRpZiAoIHVuZGVmaW5lZCAhPT0gdGV4RGF0YS5pbWFnZSApIHtcclxuXHJcblx0XHRcdFx0dGV4dHVyZS5pbWFnZSA9IHRleERhdGEuaW1hZ2U7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCB1bmRlZmluZWQgIT09IHRleERhdGEuZGF0YSApIHtcclxuXHJcblx0XHRcdFx0dGV4dHVyZS5pbWFnZS53aWR0aCA9IHRleERhdGEud2lkdGg7XHJcblx0XHRcdFx0dGV4dHVyZS5pbWFnZS5oZWlnaHQgPSB0ZXhEYXRhLmhlaWdodDtcclxuXHRcdFx0XHR0ZXh0dXJlLmltYWdlLmRhdGEgPSB0ZXhEYXRhLmRhdGE7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0ZXh0dXJlLndyYXBTID0gdW5kZWZpbmVkICE9PSB0ZXhEYXRhLndyYXBTID8gdGV4RGF0YS53cmFwUyA6IFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmc7XHJcblx0XHRcdHRleHR1cmUud3JhcFQgPSB1bmRlZmluZWQgIT09IHRleERhdGEud3JhcFQgPyB0ZXhEYXRhLndyYXBUIDogVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZztcclxuXHJcblx0XHRcdHRleHR1cmUubWFnRmlsdGVyID0gdW5kZWZpbmVkICE9PSB0ZXhEYXRhLm1hZ0ZpbHRlciA/IHRleERhdGEubWFnRmlsdGVyIDogVEhSRUUuTGluZWFyRmlsdGVyO1xyXG5cdFx0XHR0ZXh0dXJlLm1pbkZpbHRlciA9IHVuZGVmaW5lZCAhPT0gdGV4RGF0YS5taW5GaWx0ZXIgPyB0ZXhEYXRhLm1pbkZpbHRlciA6IFRIUkVFLkxpbmVhck1pcE1hcExpbmVhckZpbHRlcjtcclxuXHJcblx0XHRcdHRleHR1cmUuYW5pc290cm9weSA9IHVuZGVmaW5lZCAhPT0gdGV4RGF0YS5hbmlzb3Ryb3B5ID8gdGV4RGF0YS5hbmlzb3Ryb3B5IDogMTtcclxuXHJcblx0XHRcdGlmICggdW5kZWZpbmVkICE9PSB0ZXhEYXRhLmZvcm1hdCApIHtcclxuXHJcblx0XHRcdFx0dGV4dHVyZS5mb3JtYXQgPSB0ZXhEYXRhLmZvcm1hdDtcclxuXHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKCB1bmRlZmluZWQgIT09IHRleERhdGEudHlwZSApIHtcclxuXHJcblx0XHRcdFx0dGV4dHVyZS50eXBlID0gdGV4RGF0YS50eXBlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCB1bmRlZmluZWQgIT09IHRleERhdGEubWlwbWFwcyApIHtcclxuXHJcblx0XHRcdFx0dGV4dHVyZS5taXBtYXBzID0gdGV4RGF0YS5taXBtYXBzO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCAxID09PSB0ZXhEYXRhLm1pcG1hcENvdW50ICkge1xyXG5cclxuXHRcdFx0XHR0ZXh0dXJlLm1pbkZpbHRlciA9IFRIUkVFLkxpbmVhckZpbHRlcjtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdFx0aWYgKCBvbkxvYWQgKSBvbkxvYWQoIHRleHR1cmUsIHRleERhdGEgKTtcclxuXHJcblx0XHR9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XHJcblxyXG5cclxuXHRcdHJldHVybiB0ZXh0dXJlO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbG9hZGVycy9Db21wcmVzc2VkVGV4dHVyZUxvYWRlci5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqXHJcbiAqIEFic3RyYWN0IEJhc2UgY2xhc3MgdG8gYmxvY2sgYmFzZWQgdGV4dHVyZXMgbG9hZGVyIChkZHMsIHB2ciwgLi4uKVxyXG4gKi9cclxuXHJcblRIUkVFLkNvbXByZXNzZWRUZXh0dXJlTG9hZGVyID0gZnVuY3Rpb24gKCBtYW5hZ2VyICkge1xyXG5cclxuXHR0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IFRIUkVFLkRlZmF1bHRMb2FkaW5nTWFuYWdlcjtcclxuXHJcblx0Ly8gb3ZlcnJpZGUgaW4gc3ViIGNsYXNzZXNcclxuXHR0aGlzLl9wYXJzZXIgPSBudWxsO1xyXG5cclxufTtcclxuXHJcblxyXG5USFJFRS5Db21wcmVzc2VkVGV4dHVyZUxvYWRlci5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5Db21wcmVzc2VkVGV4dHVyZUxvYWRlcixcclxuXHJcblx0bG9hZDogZnVuY3Rpb24gKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcclxuXHJcblx0XHR2YXIgc2NvcGUgPSB0aGlzO1xyXG5cclxuXHRcdHZhciBpbWFnZXMgPSBbXTtcclxuXHJcblx0XHR2YXIgdGV4dHVyZSA9IG5ldyBUSFJFRS5Db21wcmVzc2VkVGV4dHVyZSgpO1xyXG5cdFx0dGV4dHVyZS5pbWFnZSA9IGltYWdlcztcclxuXHJcblx0XHR2YXIgbG9hZGVyID0gbmV3IFRIUkVFLlhIUkxvYWRlciggdGhpcy5tYW5hZ2VyICk7XHJcblx0XHRsb2FkZXIuc2V0UGF0aCggdGhpcy5wYXRoICk7XHJcblx0XHRsb2FkZXIuc2V0UmVzcG9uc2VUeXBlKCAnYXJyYXlidWZmZXInICk7XHJcblxyXG5cdFx0ZnVuY3Rpb24gbG9hZFRleHR1cmUoIGkgKSB7XHJcblxyXG5cdFx0XHRsb2FkZXIubG9hZCggdXJsWyBpIF0sIGZ1bmN0aW9uICggYnVmZmVyICkge1xyXG5cclxuXHRcdFx0XHR2YXIgdGV4RGF0YXMgPSBzY29wZS5fcGFyc2VyKCBidWZmZXIsIHRydWUgKTtcclxuXHJcblx0XHRcdFx0aW1hZ2VzWyBpIF0gPSB7XHJcblx0XHRcdFx0XHR3aWR0aDogdGV4RGF0YXMud2lkdGgsXHJcblx0XHRcdFx0XHRoZWlnaHQ6IHRleERhdGFzLmhlaWdodCxcclxuXHRcdFx0XHRcdGZvcm1hdDogdGV4RGF0YXMuZm9ybWF0LFxyXG5cdFx0XHRcdFx0bWlwbWFwczogdGV4RGF0YXMubWlwbWFwc1xyXG5cdFx0XHRcdH07XHJcblxyXG5cdFx0XHRcdGxvYWRlZCArPSAxO1xyXG5cclxuXHRcdFx0XHRpZiAoIGxvYWRlZCA9PT0gNiApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIHRleERhdGFzLm1pcG1hcENvdW50ID09PSAxIClcclxuXHRcdFx0XHRcdFx0dGV4dHVyZS5taW5GaWx0ZXIgPSBUSFJFRS5MaW5lYXJGaWx0ZXI7XHJcblxyXG5cdFx0XHRcdFx0dGV4dHVyZS5mb3JtYXQgPSB0ZXhEYXRhcy5mb3JtYXQ7XHJcblx0XHRcdFx0XHR0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIG9uTG9hZCApIG9uTG9hZCggdGV4dHVyZSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggQXJyYXkuaXNBcnJheSggdXJsICkgKSB7XHJcblxyXG5cdFx0XHR2YXIgbG9hZGVkID0gMDtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSB1cmwubGVuZ3RoOyBpIDwgaWw7ICsrIGkgKSB7XHJcblxyXG5cdFx0XHRcdGxvYWRUZXh0dXJlKCBpICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdC8vIGNvbXByZXNzZWQgY3ViZW1hcCB0ZXh0dXJlIHN0b3JlZCBpbiBhIHNpbmdsZSBERFMgZmlsZVxyXG5cclxuXHRcdFx0bG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCBidWZmZXIgKSB7XHJcblxyXG5cdFx0XHRcdHZhciB0ZXhEYXRhcyA9IHNjb3BlLl9wYXJzZXIoIGJ1ZmZlciwgdHJ1ZSApO1xyXG5cclxuXHRcdFx0XHRpZiAoIHRleERhdGFzLmlzQ3ViZW1hcCApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgZmFjZXMgPSB0ZXhEYXRhcy5taXBtYXBzLmxlbmd0aCAvIHRleERhdGFzLm1pcG1hcENvdW50O1xyXG5cclxuXHRcdFx0XHRcdGZvciAoIHZhciBmID0gMDsgZiA8IGZhY2VzOyBmICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0aW1hZ2VzWyBmIF0gPSB7IG1pcG1hcHMgOiBbXSB9O1xyXG5cclxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGV4RGF0YXMubWlwbWFwQ291bnQ7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGltYWdlc1sgZiBdLm1pcG1hcHMucHVzaCggdGV4RGF0YXMubWlwbWFwc1sgZiAqIHRleERhdGFzLm1pcG1hcENvdW50ICsgaSBdICk7XHJcblx0XHRcdFx0XHRcdFx0aW1hZ2VzWyBmIF0uZm9ybWF0ID0gdGV4RGF0YXMuZm9ybWF0O1xyXG5cdFx0XHRcdFx0XHRcdGltYWdlc1sgZiBdLndpZHRoID0gdGV4RGF0YXMud2lkdGg7XHJcblx0XHRcdFx0XHRcdFx0aW1hZ2VzWyBmIF0uaGVpZ2h0ID0gdGV4RGF0YXMuaGVpZ2h0O1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHR0ZXh0dXJlLmltYWdlLndpZHRoID0gdGV4RGF0YXMud2lkdGg7XHJcblx0XHRcdFx0XHR0ZXh0dXJlLmltYWdlLmhlaWdodCA9IHRleERhdGFzLmhlaWdodDtcclxuXHRcdFx0XHRcdHRleHR1cmUubWlwbWFwcyA9IHRleERhdGFzLm1pcG1hcHM7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCB0ZXhEYXRhcy5taXBtYXBDb3VudCA9PT0gMSApIHtcclxuXHJcblx0XHRcdFx0XHR0ZXh0dXJlLm1pbkZpbHRlciA9IFRIUkVFLkxpbmVhckZpbHRlcjtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR0ZXh0dXJlLmZvcm1hdCA9IHRleERhdGFzLmZvcm1hdDtcclxuXHRcdFx0XHR0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0aWYgKCBvbkxvYWQgKSBvbkxvYWQoIHRleHR1cmUgKTtcclxuXHJcblx0XHRcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRleHR1cmU7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldFBhdGg6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdFx0dGhpcy5wYXRoID0gdmFsdWU7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9tYXRlcmlhbHMvTWF0ZXJpYWwuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLk1hdGVyaWFsID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsICdpZCcsIHsgdmFsdWU6IFRIUkVFLk1hdGVyaWFsSWRDb3VudCArKyB9ICk7XHJcblxyXG5cdHRoaXMudXVpZCA9IFRIUkVFLk1hdGguZ2VuZXJhdGVVVUlEKCk7XHJcblxyXG5cdHRoaXMubmFtZSA9ICcnO1xyXG5cdHRoaXMudHlwZSA9ICdNYXRlcmlhbCc7XHJcblxyXG5cdHRoaXMuc2lkZSA9IFRIUkVFLkZyb250U2lkZTtcclxuXHJcblx0dGhpcy5vcGFjaXR5ID0gMTtcclxuXHR0aGlzLnRyYW5zcGFyZW50ID0gZmFsc2U7XHJcblxyXG5cdHRoaXMuYmxlbmRpbmcgPSBUSFJFRS5Ob3JtYWxCbGVuZGluZztcclxuXHJcblx0dGhpcy5ibGVuZFNyYyA9IFRIUkVFLlNyY0FscGhhRmFjdG9yO1xyXG5cdHRoaXMuYmxlbmREc3QgPSBUSFJFRS5PbmVNaW51c1NyY0FscGhhRmFjdG9yO1xyXG5cdHRoaXMuYmxlbmRFcXVhdGlvbiA9IFRIUkVFLkFkZEVxdWF0aW9uO1xyXG5cdHRoaXMuYmxlbmRTcmNBbHBoYSA9IG51bGw7XHJcblx0dGhpcy5ibGVuZERzdEFscGhhID0gbnVsbDtcclxuXHR0aGlzLmJsZW5kRXF1YXRpb25BbHBoYSA9IG51bGw7XHJcblxyXG5cdHRoaXMuZGVwdGhGdW5jID0gVEhSRUUuTGVzc0VxdWFsRGVwdGg7XHJcblx0dGhpcy5kZXB0aFRlc3QgPSB0cnVlO1xyXG5cdHRoaXMuZGVwdGhXcml0ZSA9IHRydWU7XHJcblxyXG5cdHRoaXMuY29sb3JXcml0ZSA9IHRydWU7XHJcblxyXG5cdHRoaXMucHJlY2lzaW9uID0gbnVsbDsgLy8gb3ZlcnJpZGUgdGhlIHJlbmRlcmVyJ3MgZGVmYXVsdCBwcmVjaXNpb24gZm9yIHRoaXMgbWF0ZXJpYWxcclxuXHJcblx0dGhpcy5wb2x5Z29uT2Zmc2V0ID0gZmFsc2U7XHJcblx0dGhpcy5wb2x5Z29uT2Zmc2V0RmFjdG9yID0gMDtcclxuXHR0aGlzLnBvbHlnb25PZmZzZXRVbml0cyA9IDA7XHJcblxyXG5cdHRoaXMuYWxwaGFUZXN0ID0gMDtcclxuXHJcblx0dGhpcy5vdmVyZHJhdyA9IDA7IC8vIE92ZXJkcmF3biBwaXhlbHMgKHR5cGljYWxseSBiZXR3ZWVuIDAgYW5kIDEpIGZvciBmaXhpbmcgYW50aWFsaWFzaW5nIGdhcHMgaW4gQ2FudmFzUmVuZGVyZXJcclxuXHJcblx0dGhpcy52aXNpYmxlID0gdHJ1ZTtcclxuXHJcblx0dGhpcy5fbmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxufTtcclxuXHJcblRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLk1hdGVyaWFsLFxyXG5cclxuXHRnZXQgbmVlZHNVcGRhdGUgKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLl9uZWVkc1VwZGF0ZTtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0IG5lZWRzVXBkYXRlICggdmFsdWUgKSB7XHJcblxyXG5cdFx0aWYgKCB2YWx1ZSA9PT0gdHJ1ZSApIHRoaXMudXBkYXRlKCk7XHJcblxyXG5cdFx0dGhpcy5fbmVlZHNVcGRhdGUgPSB2YWx1ZTtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0VmFsdWVzOiBmdW5jdGlvbiAoIHZhbHVlcyApIHtcclxuXHJcblx0XHRpZiAoIHZhbHVlcyA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xyXG5cclxuXHRcdGZvciAoIHZhciBrZXkgaW4gdmFsdWVzICkge1xyXG5cclxuXHRcdFx0dmFyIG5ld1ZhbHVlID0gdmFsdWVzWyBrZXkgXTtcclxuXHJcblx0XHRcdGlmICggbmV3VmFsdWUgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCBcIlRIUkVFLk1hdGVyaWFsOiAnXCIgKyBrZXkgKyBcIicgcGFyYW1ldGVyIGlzIHVuZGVmaW5lZC5cIiApO1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIGN1cnJlbnRWYWx1ZSA9IHRoaXNbIGtleSBdO1xyXG5cclxuXHRcdFx0aWYgKCBjdXJyZW50VmFsdWUgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCBcIlRIUkVFLlwiICsgdGhpcy50eXBlICsgXCI6ICdcIiArIGtleSArIFwiJyBpcyBub3QgYSBwcm9wZXJ0eSBvZiB0aGlzIG1hdGVyaWFsLlwiICk7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGN1cnJlbnRWYWx1ZSBpbnN0YW5jZW9mIFRIUkVFLkNvbG9yICkge1xyXG5cclxuXHRcdFx0XHRjdXJyZW50VmFsdWUuc2V0KCBuZXdWYWx1ZSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggY3VycmVudFZhbHVlIGluc3RhbmNlb2YgVEhSRUUuVmVjdG9yMyAmJiBuZXdWYWx1ZSBpbnN0YW5jZW9mIFRIUkVFLlZlY3RvcjMgKSB7XHJcblxyXG5cdFx0XHRcdGN1cnJlbnRWYWx1ZS5jb3B5KCBuZXdWYWx1ZSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICgga2V5ID09PSAnb3ZlcmRyYXcnICkge1xyXG5cclxuXHRcdFx0XHQvLyBlbnN1cmUgb3ZlcmRyYXcgaXMgYmFja3dhcmRzLWNvbXBhdGlibGUgd2l0aCBsZWdhY3kgYm9vbGVhbiB0eXBlXHJcblx0XHRcdFx0dGhpc1sga2V5IF0gPSBOdW1iZXIoIG5ld1ZhbHVlICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHR0aGlzWyBrZXkgXSA9IG5ld1ZhbHVlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0dG9KU09OOiBmdW5jdGlvbiAoIG1ldGEgKSB7XHJcblxyXG5cdFx0dmFyIGlzUm9vdCA9IG1ldGEgPT09IHVuZGVmaW5lZDtcclxuXHJcblx0XHRpZiAoIGlzUm9vdCApIHtcclxuXHJcblx0XHRcdG1ldGEgPSB7XHJcblx0XHRcdFx0dGV4dHVyZXM6IHt9LFxyXG5cdFx0XHRcdGltYWdlczoge31cclxuXHRcdFx0fTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGRhdGEgPSB7XHJcblx0XHRcdG1ldGFkYXRhOiB7XHJcblx0XHRcdFx0dmVyc2lvbjogNC40LFxyXG5cdFx0XHRcdHR5cGU6ICdNYXRlcmlhbCcsXHJcblx0XHRcdFx0Z2VuZXJhdG9yOiAnTWF0ZXJpYWwudG9KU09OJ1xyXG5cdFx0XHR9XHJcblx0XHR9O1xyXG5cclxuXHRcdC8vIHN0YW5kYXJkIE1hdGVyaWFsIHNlcmlhbGl6YXRpb25cclxuXHRcdGRhdGEudXVpZCA9IHRoaXMudXVpZDtcclxuXHRcdGRhdGEudHlwZSA9IHRoaXMudHlwZTtcclxuXHRcdGlmICggdGhpcy5uYW1lICE9PSAnJyApIGRhdGEubmFtZSA9IHRoaXMubmFtZTtcclxuXHJcblx0XHRpZiAoIHRoaXMuY29sb3IgaW5zdGFuY2VvZiBUSFJFRS5Db2xvciApIGRhdGEuY29sb3IgPSB0aGlzLmNvbG9yLmdldEhleCgpO1xyXG5cclxuXHRcdGlmICggdGhpcy5yb3VnaG5lc3MgIT09IDAuNSApIGRhdGEucm91Z2huZXNzID0gdGhpcy5yb3VnaG5lc3M7XHJcblx0XHRpZiAoIHRoaXMubWV0YWxuZXNzICE9PSAwLjUgKSBkYXRhLm1ldGFsbmVzcyA9IHRoaXMubWV0YWxuZXNzO1xyXG5cclxuXHRcdGlmICggdGhpcy5lbWlzc2l2ZSBpbnN0YW5jZW9mIFRIUkVFLkNvbG9yICkgZGF0YS5lbWlzc2l2ZSA9IHRoaXMuZW1pc3NpdmUuZ2V0SGV4KCk7XHJcblx0XHRpZiAoIHRoaXMuc3BlY3VsYXIgaW5zdGFuY2VvZiBUSFJFRS5Db2xvciApIGRhdGEuc3BlY3VsYXIgPSB0aGlzLnNwZWN1bGFyLmdldEhleCgpO1xyXG5cdFx0aWYgKCB0aGlzLnNoaW5pbmVzcyAhPT0gdW5kZWZpbmVkICkgZGF0YS5zaGluaW5lc3MgPSB0aGlzLnNoaW5pbmVzcztcclxuXHJcblx0XHRpZiAoIHRoaXMubWFwIGluc3RhbmNlb2YgVEhSRUUuVGV4dHVyZSApIGRhdGEubWFwID0gdGhpcy5tYXAudG9KU09OKCBtZXRhICkudXVpZDtcclxuXHRcdGlmICggdGhpcy5hbHBoYU1hcCBpbnN0YW5jZW9mIFRIUkVFLlRleHR1cmUgKSBkYXRhLmFscGhhTWFwID0gdGhpcy5hbHBoYU1hcC50b0pTT04oIG1ldGEgKS51dWlkO1xyXG5cdFx0aWYgKCB0aGlzLmxpZ2h0TWFwIGluc3RhbmNlb2YgVEhSRUUuVGV4dHVyZSApIGRhdGEubGlnaHRNYXAgPSB0aGlzLmxpZ2h0TWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XHJcblx0XHRpZiAoIHRoaXMuYnVtcE1hcCBpbnN0YW5jZW9mIFRIUkVFLlRleHR1cmUgKSB7XHJcblxyXG5cdFx0XHRkYXRhLmJ1bXBNYXAgPSB0aGlzLmJ1bXBNYXAudG9KU09OKCBtZXRhICkudXVpZDtcclxuXHRcdFx0ZGF0YS5idW1wU2NhbGUgPSB0aGlzLmJ1bXBTY2FsZTtcclxuXHJcblx0XHR9XHJcblx0XHRpZiAoIHRoaXMubm9ybWFsTWFwIGluc3RhbmNlb2YgVEhSRUUuVGV4dHVyZSApIHtcclxuXHJcblx0XHRcdGRhdGEubm9ybWFsTWFwID0gdGhpcy5ub3JtYWxNYXAudG9KU09OKCBtZXRhICkudXVpZDtcclxuXHRcdFx0ZGF0YS5ub3JtYWxTY2FsZSA9IHRoaXMubm9ybWFsU2NhbGUudG9BcnJheSgpO1xyXG5cclxuXHRcdH1cclxuXHRcdGlmICggdGhpcy5kaXNwbGFjZW1lbnRNYXAgaW5zdGFuY2VvZiBUSFJFRS5UZXh0dXJlICkge1xyXG5cclxuXHRcdFx0ZGF0YS5kaXNwbGFjZW1lbnRNYXAgPSB0aGlzLmRpc3BsYWNlbWVudE1hcC50b0pTT04oIG1ldGEgKS51dWlkO1xyXG5cdFx0XHRkYXRhLmRpc3BsYWNlbWVudFNjYWxlID0gdGhpcy5kaXNwbGFjZW1lbnRTY2FsZTtcclxuXHRcdFx0ZGF0YS5kaXNwbGFjZW1lbnRCaWFzID0gdGhpcy5kaXNwbGFjZW1lbnRCaWFzO1xyXG5cclxuXHRcdH1cclxuXHRcdGlmICggdGhpcy5yb3VnaG5lc3NNYXAgaW5zdGFuY2VvZiBUSFJFRS5UZXh0dXJlICkgZGF0YS5yb3VnaG5lc3NNYXAgPSB0aGlzLnJvdWdobmVzc01hcC50b0pTT04oIG1ldGEgKS51dWlkO1xyXG5cdFx0aWYgKCB0aGlzLm1ldGFsbmVzc01hcCBpbnN0YW5jZW9mIFRIUkVFLlRleHR1cmUgKSBkYXRhLm1ldGFsbmVzc01hcCA9IHRoaXMubWV0YWxuZXNzTWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XHJcblxyXG5cdFx0aWYgKCB0aGlzLmVtaXNzaXZlTWFwIGluc3RhbmNlb2YgVEhSRUUuVGV4dHVyZSApIGRhdGEuZW1pc3NpdmVNYXAgPSB0aGlzLmVtaXNzaXZlTWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XHJcblx0XHRpZiAoIHRoaXMuc3BlY3VsYXJNYXAgaW5zdGFuY2VvZiBUSFJFRS5UZXh0dXJlICkgZGF0YS5zcGVjdWxhck1hcCA9IHRoaXMuc3BlY3VsYXJNYXAudG9KU09OKCBtZXRhICkudXVpZDtcclxuXHJcblx0XHRpZiAoIHRoaXMuZW52TWFwIGluc3RhbmNlb2YgVEhSRUUuVGV4dHVyZSApIHtcclxuXHJcblx0XHRcdGRhdGEuZW52TWFwID0gdGhpcy5lbnZNYXAudG9KU09OKCBtZXRhICkudXVpZDtcclxuXHRcdFx0ZGF0YS5yZWZsZWN0aXZpdHkgPSB0aGlzLnJlZmxlY3Rpdml0eTsgLy8gU2NhbGUgYmVoaW5kIGVudk1hcFxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHRoaXMuc2l6ZSAhPT0gdW5kZWZpbmVkICkgZGF0YS5zaXplID0gdGhpcy5zaXplO1xyXG5cdFx0aWYgKCB0aGlzLnNpemVBdHRlbnVhdGlvbiAhPT0gdW5kZWZpbmVkICkgZGF0YS5zaXplQXR0ZW51YXRpb24gPSB0aGlzLnNpemVBdHRlbnVhdGlvbjtcclxuXHJcblx0XHRpZiAoIHRoaXMudmVydGV4Q29sb3JzICE9PSB1bmRlZmluZWQgJiYgdGhpcy52ZXJ0ZXhDb2xvcnMgIT09IFRIUkVFLk5vQ29sb3JzICkgZGF0YS52ZXJ0ZXhDb2xvcnMgPSB0aGlzLnZlcnRleENvbG9ycztcclxuXHRcdGlmICggdGhpcy5zaGFkaW5nICE9PSB1bmRlZmluZWQgJiYgdGhpcy5zaGFkaW5nICE9PSBUSFJFRS5TbW9vdGhTaGFkaW5nICkgZGF0YS5zaGFkaW5nID0gdGhpcy5zaGFkaW5nO1xyXG5cdFx0aWYgKCB0aGlzLmJsZW5kaW5nICE9PSB1bmRlZmluZWQgJiYgdGhpcy5ibGVuZGluZyAhPT0gVEhSRUUuTm9ybWFsQmxlbmRpbmcgKSBkYXRhLmJsZW5kaW5nID0gdGhpcy5ibGVuZGluZztcclxuXHRcdGlmICggdGhpcy5zaWRlICE9PSB1bmRlZmluZWQgJiYgdGhpcy5zaWRlICE9PSBUSFJFRS5Gcm9udFNpZGUgKSBkYXRhLnNpZGUgPSB0aGlzLnNpZGU7XHJcblxyXG5cdFx0aWYgKCB0aGlzLm9wYWNpdHkgPCAxICkgZGF0YS5vcGFjaXR5ID0gdGhpcy5vcGFjaXR5O1xyXG5cdFx0aWYgKCB0aGlzLnRyYW5zcGFyZW50ID09PSB0cnVlICkgZGF0YS50cmFuc3BhcmVudCA9IHRoaXMudHJhbnNwYXJlbnQ7XHJcblx0XHRpZiAoIHRoaXMuYWxwaGFUZXN0ID4gMCApIGRhdGEuYWxwaGFUZXN0ID0gdGhpcy5hbHBoYVRlc3Q7XHJcblx0XHRpZiAoIHRoaXMud2lyZWZyYW1lID09PSB0cnVlICkgZGF0YS53aXJlZnJhbWUgPSB0aGlzLndpcmVmcmFtZTtcclxuXHRcdGlmICggdGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPiAxICkgZGF0YS53aXJlZnJhbWVMaW5ld2lkdGggPSB0aGlzLndpcmVmcmFtZUxpbmV3aWR0aDtcclxuXHJcblx0XHQvLyBUT0RPOiBDb3BpZWQgZnJvbSBPYmplY3QzRC50b0pTT05cclxuXHJcblx0XHRmdW5jdGlvbiBleHRyYWN0RnJvbUNhY2hlICggY2FjaGUgKSB7XHJcblxyXG5cdFx0XHR2YXIgdmFsdWVzID0gW107XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIga2V5IGluIGNhY2hlICkge1xyXG5cclxuXHRcdFx0XHR2YXIgZGF0YSA9IGNhY2hlWyBrZXkgXTtcclxuXHRcdFx0XHRkZWxldGUgZGF0YS5tZXRhZGF0YTtcclxuXHRcdFx0XHR2YWx1ZXMucHVzaCggZGF0YSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHZhbHVlcztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBpc1Jvb3QgKSB7XHJcblxyXG5cdFx0XHR2YXIgdGV4dHVyZXMgPSBleHRyYWN0RnJvbUNhY2hlKCBtZXRhLnRleHR1cmVzICk7XHJcblx0XHRcdHZhciBpbWFnZXMgPSBleHRyYWN0RnJvbUNhY2hlKCBtZXRhLmltYWdlcyApO1xyXG5cclxuXHRcdFx0aWYgKCB0ZXh0dXJlcy5sZW5ndGggPiAwICkgZGF0YS50ZXh0dXJlcyA9IHRleHR1cmVzO1xyXG5cdFx0XHRpZiAoIGltYWdlcy5sZW5ndGggPiAwICkgZGF0YS5pbWFnZXMgPSBpbWFnZXM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBkYXRhO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG5cdFx0dGhpcy5uYW1lID0gc291cmNlLm5hbWU7XHJcblxyXG5cdFx0dGhpcy5zaWRlID0gc291cmNlLnNpZGU7XHJcblxyXG5cdFx0dGhpcy5vcGFjaXR5ID0gc291cmNlLm9wYWNpdHk7XHJcblx0XHR0aGlzLnRyYW5zcGFyZW50ID0gc291cmNlLnRyYW5zcGFyZW50O1xyXG5cclxuXHRcdHRoaXMuYmxlbmRpbmcgPSBzb3VyY2UuYmxlbmRpbmc7XHJcblxyXG5cdFx0dGhpcy5ibGVuZFNyYyA9IHNvdXJjZS5ibGVuZFNyYztcclxuXHRcdHRoaXMuYmxlbmREc3QgPSBzb3VyY2UuYmxlbmREc3Q7XHJcblx0XHR0aGlzLmJsZW5kRXF1YXRpb24gPSBzb3VyY2UuYmxlbmRFcXVhdGlvbjtcclxuXHRcdHRoaXMuYmxlbmRTcmNBbHBoYSA9IHNvdXJjZS5ibGVuZFNyY0FscGhhO1xyXG5cdFx0dGhpcy5ibGVuZERzdEFscGhhID0gc291cmNlLmJsZW5kRHN0QWxwaGE7XHJcblx0XHR0aGlzLmJsZW5kRXF1YXRpb25BbHBoYSA9IHNvdXJjZS5ibGVuZEVxdWF0aW9uQWxwaGE7XHJcblxyXG5cdFx0dGhpcy5kZXB0aEZ1bmMgPSBzb3VyY2UuZGVwdGhGdW5jO1xyXG5cdFx0dGhpcy5kZXB0aFRlc3QgPSBzb3VyY2UuZGVwdGhUZXN0O1xyXG5cdFx0dGhpcy5kZXB0aFdyaXRlID0gc291cmNlLmRlcHRoV3JpdGU7XHJcblxyXG5cdFx0dGhpcy5jb2xvcldyaXRlID0gc291cmNlLmNvbG9yV3JpdGU7XHJcblxyXG5cdFx0dGhpcy5wcmVjaXNpb24gPSBzb3VyY2UucHJlY2lzaW9uO1xyXG5cclxuXHRcdHRoaXMucG9seWdvbk9mZnNldCA9IHNvdXJjZS5wb2x5Z29uT2Zmc2V0O1xyXG5cdFx0dGhpcy5wb2x5Z29uT2Zmc2V0RmFjdG9yID0gc291cmNlLnBvbHlnb25PZmZzZXRGYWN0b3I7XHJcblx0XHR0aGlzLnBvbHlnb25PZmZzZXRVbml0cyA9IHNvdXJjZS5wb2x5Z29uT2Zmc2V0VW5pdHM7XHJcblxyXG5cdFx0dGhpcy5hbHBoYVRlc3QgPSBzb3VyY2UuYWxwaGFUZXN0O1xyXG5cclxuXHRcdHRoaXMub3ZlcmRyYXcgPSBzb3VyY2Uub3ZlcmRyYXc7XHJcblxyXG5cdFx0dGhpcy52aXNpYmxlID0gc291cmNlLnZpc2libGU7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAndXBkYXRlJyB9ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2Rpc3Bvc2UnIH0gKTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcblRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuYXBwbHkoIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSApO1xyXG5cclxuVEhSRUUuTWF0ZXJpYWxJZENvdW50ID0gMDtcclxuXHJcbi8vIEZpbGU6c3JjL21hdGVyaWFscy9MaW5lQmFzaWNNYXRlcmlhbC5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqXHJcbiAqIHBhcmFtZXRlcnMgPSB7XHJcbiAqICBjb2xvcjogPGhleD4sXHJcbiAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxyXG4gKlxyXG4gKiAgYmxlbmRpbmc6IFRIUkVFLk5vcm1hbEJsZW5kaW5nLFxyXG4gKiAgZGVwdGhUZXN0OiA8Ym9vbD4sXHJcbiAqICBkZXB0aFdyaXRlOiA8Ym9vbD4sXHJcbiAqXHJcbiAqICBsaW5ld2lkdGg6IDxmbG9hdD4sXHJcbiAqICBsaW5lY2FwOiBcInJvdW5kXCIsXHJcbiAqICBsaW5lam9pbjogXCJyb3VuZFwiLFxyXG4gKlxyXG4gKiAgdmVydGV4Q29sb3JzOiA8Ym9vbD5cclxuICpcclxuICogIGZvZzogPGJvb2w+XHJcbiAqIH1cclxuICovXHJcblxyXG5USFJFRS5MaW5lQmFzaWNNYXRlcmlhbCA9IGZ1bmN0aW9uICggcGFyYW1ldGVycyApIHtcclxuXHJcblx0VEhSRUUuTWF0ZXJpYWwuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLnR5cGUgPSAnTGluZUJhc2ljTWF0ZXJpYWwnO1xyXG5cclxuXHR0aGlzLmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCAweGZmZmZmZiApO1xyXG5cclxuXHR0aGlzLmxpbmV3aWR0aCA9IDE7XHJcblx0dGhpcy5saW5lY2FwID0gJ3JvdW5kJztcclxuXHR0aGlzLmxpbmVqb2luID0gJ3JvdW5kJztcclxuXHJcblx0dGhpcy52ZXJ0ZXhDb2xvcnMgPSBUSFJFRS5Ob0NvbG9ycztcclxuXHJcblx0dGhpcy5mb2cgPSB0cnVlO1xyXG5cclxuXHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkxpbmVCYXNpY01hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSApO1xyXG5USFJFRS5MaW5lQmFzaWNNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbDtcclxuXHJcblRIUkVFLkxpbmVCYXNpY01hdGVyaWFsLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG5cdFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xyXG5cclxuXHR0aGlzLmNvbG9yLmNvcHkoIHNvdXJjZS5jb2xvciApO1xyXG5cclxuXHR0aGlzLmxpbmV3aWR0aCA9IHNvdXJjZS5saW5ld2lkdGg7XHJcblx0dGhpcy5saW5lY2FwID0gc291cmNlLmxpbmVjYXA7XHJcblx0dGhpcy5saW5lam9pbiA9IHNvdXJjZS5saW5lam9pbjtcclxuXHJcblx0dGhpcy52ZXJ0ZXhDb2xvcnMgPSBzb3VyY2UudmVydGV4Q29sb3JzO1xyXG5cclxuXHR0aGlzLmZvZyA9IHNvdXJjZS5mb2c7XHJcblxyXG5cdHJldHVybiB0aGlzO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL21hdGVyaWFscy9MaW5lRGFzaGVkTWF0ZXJpYWwuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKlxyXG4gKiBwYXJhbWV0ZXJzID0ge1xyXG4gKiAgY29sb3I6IDxoZXg+LFxyXG4gKiAgb3BhY2l0eTogPGZsb2F0PixcclxuICpcclxuICogIGJsZW5kaW5nOiBUSFJFRS5Ob3JtYWxCbGVuZGluZyxcclxuICogIGRlcHRoVGVzdDogPGJvb2w+LFxyXG4gKiAgZGVwdGhXcml0ZTogPGJvb2w+LFxyXG4gKlxyXG4gKiAgbGluZXdpZHRoOiA8ZmxvYXQ+LFxyXG4gKlxyXG4gKiAgc2NhbGU6IDxmbG9hdD4sXHJcbiAqICBkYXNoU2l6ZTogPGZsb2F0PixcclxuICogIGdhcFNpemU6IDxmbG9hdD4sXHJcbiAqXHJcbiAqICB2ZXJ0ZXhDb2xvcnM6IFRIUkVFLk5vQ29sb3JzIC8gVEhSRUUuRmFjZUNvbG9ycyAvIFRIUkVFLlZlcnRleENvbG9yc1xyXG4gKlxyXG4gKiAgZm9nOiA8Ym9vbD5cclxuICogfVxyXG4gKi9cclxuXHJcblRIUkVFLkxpbmVEYXNoZWRNYXRlcmlhbCA9IGZ1bmN0aW9uICggcGFyYW1ldGVycyApIHtcclxuXHJcblx0VEhSRUUuTWF0ZXJpYWwuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLnR5cGUgPSAnTGluZURhc2hlZE1hdGVyaWFsJztcclxuXHJcblx0dGhpcy5jb2xvciA9IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKTtcclxuXHJcblx0dGhpcy5saW5ld2lkdGggPSAxO1xyXG5cclxuXHR0aGlzLnNjYWxlID0gMTtcclxuXHR0aGlzLmRhc2hTaXplID0gMztcclxuXHR0aGlzLmdhcFNpemUgPSAxO1xyXG5cclxuXHR0aGlzLnZlcnRleENvbG9ycyA9IFRIUkVFLk5vQ29sb3JzO1xyXG5cclxuXHR0aGlzLmZvZyA9IHRydWU7XHJcblxyXG5cdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTGluZURhc2hlZE1hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSApO1xyXG5USFJFRS5MaW5lRGFzaGVkTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuTGluZURhc2hlZE1hdGVyaWFsO1xyXG5cclxuVEhSRUUuTGluZURhc2hlZE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG5cdFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xyXG5cclxuXHR0aGlzLmNvbG9yLmNvcHkoIHNvdXJjZS5jb2xvciApO1xyXG5cdFxyXG5cdHRoaXMubGluZXdpZHRoID0gc291cmNlLmxpbmV3aWR0aDtcclxuXHJcblx0dGhpcy5zY2FsZSA9IHNvdXJjZS5zY2FsZTtcclxuXHR0aGlzLmRhc2hTaXplID0gc291cmNlLmRhc2hTaXplO1xyXG5cdHRoaXMuZ2FwU2l6ZSA9IHNvdXJjZS5nYXBTaXplO1xyXG5cclxuXHR0aGlzLnZlcnRleENvbG9ycyA9IHNvdXJjZS52ZXJ0ZXhDb2xvcnM7XHJcblxyXG5cdHRoaXMuZm9nID0gc291cmNlLmZvZztcclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbWF0ZXJpYWxzL01lc2hCYXNpY01hdGVyaWFsLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICpcclxuICogcGFyYW1ldGVycyA9IHtcclxuICogIGNvbG9yOiA8aGV4PixcclxuICogIG9wYWNpdHk6IDxmbG9hdD4sXHJcbiAqICBtYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXHJcbiAqXHJcbiAqICBhb01hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcclxuICogIGFvTWFwSW50ZW5zaXR5OiA8ZmxvYXQ+XHJcbiAqXHJcbiAqICBzcGVjdWxhck1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcclxuICpcclxuICogIGFscGhhTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxyXG4gKlxyXG4gKiAgZW52TWFwOiBuZXcgVEhSRUUuVGV4dHVyZUN1YmUoIFtwb3N4LCBuZWd4LCBwb3N5LCBuZWd5LCBwb3N6LCBuZWd6XSApLFxyXG4gKiAgY29tYmluZTogVEhSRUUuTXVsdGlwbHksXHJcbiAqICByZWZsZWN0aXZpdHk6IDxmbG9hdD4sXHJcbiAqICByZWZyYWN0aW9uUmF0aW86IDxmbG9hdD4sXHJcbiAqXHJcbiAqICBzaGFkaW5nOiBUSFJFRS5TbW9vdGhTaGFkaW5nLFxyXG4gKiAgYmxlbmRpbmc6IFRIUkVFLk5vcm1hbEJsZW5kaW5nLFxyXG4gKiAgZGVwdGhUZXN0OiA8Ym9vbD4sXHJcbiAqICBkZXB0aFdyaXRlOiA8Ym9vbD4sXHJcbiAqXHJcbiAqICB3aXJlZnJhbWU6IDxib29sZWFuPixcclxuICogIHdpcmVmcmFtZUxpbmV3aWR0aDogPGZsb2F0PixcclxuICpcclxuICogIHZlcnRleENvbG9yczogVEhSRUUuTm9Db2xvcnMgLyBUSFJFRS5WZXJ0ZXhDb2xvcnMgLyBUSFJFRS5GYWNlQ29sb3JzLFxyXG4gKlxyXG4gKiAgc2tpbm5pbmc6IDxib29sPixcclxuICogIG1vcnBoVGFyZ2V0czogPGJvb2w+LFxyXG4gKlxyXG4gKiAgZm9nOiA8Ym9vbD5cclxuICogfVxyXG4gKi9cclxuXHJcblRIUkVFLk1lc2hCYXNpY01hdGVyaWFsID0gZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xyXG5cclxuXHRUSFJFRS5NYXRlcmlhbC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMudHlwZSA9ICdNZXNoQmFzaWNNYXRlcmlhbCc7XHJcblxyXG5cdHRoaXMuY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmICk7IC8vIGVtaXNzaXZlXHJcblxyXG5cdHRoaXMubWFwID0gbnVsbDtcclxuXHJcblx0dGhpcy5hb01hcCA9IG51bGw7XHJcblx0dGhpcy5hb01hcEludGVuc2l0eSA9IDEuMDtcclxuXHJcblx0dGhpcy5zcGVjdWxhck1hcCA9IG51bGw7XHJcblxyXG5cdHRoaXMuYWxwaGFNYXAgPSBudWxsO1xyXG5cclxuXHR0aGlzLmVudk1hcCA9IG51bGw7XHJcblx0dGhpcy5jb21iaW5lID0gVEhSRUUuTXVsdGlwbHlPcGVyYXRpb247XHJcblx0dGhpcy5yZWZsZWN0aXZpdHkgPSAxO1xyXG5cdHRoaXMucmVmcmFjdGlvblJhdGlvID0gMC45ODtcclxuXHJcblx0dGhpcy5mb2cgPSB0cnVlO1xyXG5cclxuXHR0aGlzLnNoYWRpbmcgPSBUSFJFRS5TbW9vdGhTaGFkaW5nO1xyXG5cclxuXHR0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xyXG5cdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcclxuXHR0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSAncm91bmQnO1xyXG5cdHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSAncm91bmQnO1xyXG5cclxuXHR0aGlzLnZlcnRleENvbG9ycyA9IFRIUkVFLk5vQ29sb3JzO1xyXG5cclxuXHR0aGlzLnNraW5uaW5nID0gZmFsc2U7XHJcblx0dGhpcy5tb3JwaFRhcmdldHMgPSBmYWxzZTtcclxuXHJcblx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5NZXNoQmFzaWNNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUgKTtcclxuVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWw7XHJcblxyXG5USFJFRS5NZXNoQmFzaWNNYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuXHRUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcclxuXHJcblx0dGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcclxuXHJcblx0dGhpcy5tYXAgPSBzb3VyY2UubWFwO1xyXG5cclxuXHR0aGlzLmFvTWFwID0gc291cmNlLmFvTWFwO1xyXG5cdHRoaXMuYW9NYXBJbnRlbnNpdHkgPSBzb3VyY2UuYW9NYXBJbnRlbnNpdHk7XHJcblxyXG5cdHRoaXMuc3BlY3VsYXJNYXAgPSBzb3VyY2Uuc3BlY3VsYXJNYXA7XHJcblxyXG5cdHRoaXMuYWxwaGFNYXAgPSBzb3VyY2UuYWxwaGFNYXA7XHJcblxyXG5cdHRoaXMuZW52TWFwID0gc291cmNlLmVudk1hcDtcclxuXHR0aGlzLmNvbWJpbmUgPSBzb3VyY2UuY29tYmluZTtcclxuXHR0aGlzLnJlZmxlY3Rpdml0eSA9IHNvdXJjZS5yZWZsZWN0aXZpdHk7XHJcblx0dGhpcy5yZWZyYWN0aW9uUmF0aW8gPSBzb3VyY2UucmVmcmFjdGlvblJhdGlvO1xyXG5cclxuXHR0aGlzLmZvZyA9IHNvdXJjZS5mb2c7XHJcblxyXG5cdHRoaXMuc2hhZGluZyA9IHNvdXJjZS5zaGFkaW5nO1xyXG5cclxuXHR0aGlzLndpcmVmcmFtZSA9IHNvdXJjZS53aXJlZnJhbWU7XHJcblx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSBzb3VyY2Uud2lyZWZyYW1lTGluZXdpZHRoO1xyXG5cdHRoaXMud2lyZWZyYW1lTGluZWNhcCA9IHNvdXJjZS53aXJlZnJhbWVMaW5lY2FwO1xyXG5cdHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSBzb3VyY2Uud2lyZWZyYW1lTGluZWpvaW47XHJcblxyXG5cdHRoaXMudmVydGV4Q29sb3JzID0gc291cmNlLnZlcnRleENvbG9ycztcclxuXHJcblx0dGhpcy5za2lubmluZyA9IHNvdXJjZS5za2lubmluZztcclxuXHR0aGlzLm1vcnBoVGFyZ2V0cyA9IHNvdXJjZS5tb3JwaFRhcmdldHM7XHJcblxyXG5cdHJldHVybiB0aGlzO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL21hdGVyaWFscy9NZXNoTGFtYmVydE1hdGVyaWFsLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICpcclxuICogcGFyYW1ldGVycyA9IHtcclxuICogIGNvbG9yOiA8aGV4PixcclxuICogIG9wYWNpdHk6IDxmbG9hdD4sXHJcbiAqXHJcbiAqICBtYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXHJcbiAqXHJcbiAqICBsaWdodE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcclxuICogIGxpZ2h0TWFwSW50ZW5zaXR5OiA8ZmxvYXQ+XHJcbiAqXHJcbiAqICBhb01hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcclxuICogIGFvTWFwSW50ZW5zaXR5OiA8ZmxvYXQ+XHJcbiAqXHJcbiAqICBlbWlzc2l2ZTogPGhleD4sXHJcbiAqICBlbWlzc2l2ZUludGVuc2l0eTogPGZsb2F0PlxyXG4gKiAgZW1pc3NpdmVNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXHJcbiAqXHJcbiAqICBzcGVjdWxhck1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcclxuICpcclxuICogIGFscGhhTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxyXG4gKlxyXG4gKiAgZW52TWFwOiBuZXcgVEhSRUUuVGV4dHVyZUN1YmUoIFtwb3N4LCBuZWd4LCBwb3N5LCBuZWd5LCBwb3N6LCBuZWd6XSApLFxyXG4gKiAgY29tYmluZTogVEhSRUUuTXVsdGlwbHksXHJcbiAqICByZWZsZWN0aXZpdHk6IDxmbG9hdD4sXHJcbiAqICByZWZyYWN0aW9uUmF0aW86IDxmbG9hdD4sXHJcbiAqXHJcbiAqICBibGVuZGluZzogVEhSRUUuTm9ybWFsQmxlbmRpbmcsXHJcbiAqICBkZXB0aFRlc3Q6IDxib29sPixcclxuICogIGRlcHRoV3JpdGU6IDxib29sPixcclxuICpcclxuICogIHdpcmVmcmFtZTogPGJvb2xlYW4+LFxyXG4gKiAgd2lyZWZyYW1lTGluZXdpZHRoOiA8ZmxvYXQ+LFxyXG4gKlxyXG4gKiAgdmVydGV4Q29sb3JzOiBUSFJFRS5Ob0NvbG9ycyAvIFRIUkVFLlZlcnRleENvbG9ycyAvIFRIUkVFLkZhY2VDb2xvcnMsXHJcbiAqXHJcbiAqICBza2lubmluZzogPGJvb2w+LFxyXG4gKiAgbW9ycGhUYXJnZXRzOiA8Ym9vbD4sXHJcbiAqICBtb3JwaE5vcm1hbHM6IDxib29sPixcclxuICpcclxuICpcdGZvZzogPGJvb2w+XHJcbiAqIH1cclxuICovXHJcblxyXG5USFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsID0gZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xyXG5cclxuXHRUSFJFRS5NYXRlcmlhbC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMudHlwZSA9ICdNZXNoTGFtYmVydE1hdGVyaWFsJztcclxuXHJcblx0dGhpcy5jb2xvciA9IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKTsgLy8gZGlmZnVzZVxyXG5cclxuXHR0aGlzLm1hcCA9IG51bGw7XHJcblxyXG5cdHRoaXMubGlnaHRNYXAgPSBudWxsO1xyXG5cdHRoaXMubGlnaHRNYXBJbnRlbnNpdHkgPSAxLjA7XHJcblxyXG5cdHRoaXMuYW9NYXAgPSBudWxsO1xyXG5cdHRoaXMuYW9NYXBJbnRlbnNpdHkgPSAxLjA7XHJcblxyXG5cdHRoaXMuZW1pc3NpdmUgPSBuZXcgVEhSRUUuQ29sb3IoIDB4MDAwMDAwICk7XHJcblx0dGhpcy5lbWlzc2l2ZUludGVuc2l0eSA9IDEuMDtcclxuXHR0aGlzLmVtaXNzaXZlTWFwID0gbnVsbDtcclxuXHJcblx0dGhpcy5zcGVjdWxhck1hcCA9IG51bGw7XHJcblxyXG5cdHRoaXMuYWxwaGFNYXAgPSBudWxsO1xyXG5cclxuXHR0aGlzLmVudk1hcCA9IG51bGw7XHJcblx0dGhpcy5jb21iaW5lID0gVEhSRUUuTXVsdGlwbHlPcGVyYXRpb247XHJcblx0dGhpcy5yZWZsZWN0aXZpdHkgPSAxO1xyXG5cdHRoaXMucmVmcmFjdGlvblJhdGlvID0gMC45ODtcclxuXHJcblx0dGhpcy5mb2cgPSB0cnVlO1xyXG5cclxuXHR0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xyXG5cdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcclxuXHR0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSAncm91bmQnO1xyXG5cdHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSAncm91bmQnO1xyXG5cclxuXHR0aGlzLnZlcnRleENvbG9ycyA9IFRIUkVFLk5vQ29sb3JzO1xyXG5cclxuXHR0aGlzLnNraW5uaW5nID0gZmFsc2U7XHJcblx0dGhpcy5tb3JwaFRhcmdldHMgPSBmYWxzZTtcclxuXHR0aGlzLm1vcnBoTm9ybWFscyA9IGZhbHNlO1xyXG5cclxuXHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlICk7XHJcblRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbDtcclxuXHJcblRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcblx0VEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XHJcblxyXG5cdHRoaXMuY29sb3IuY29weSggc291cmNlLmNvbG9yICk7XHJcblxyXG5cdHRoaXMubWFwID0gc291cmNlLm1hcDtcclxuXHJcblx0dGhpcy5saWdodE1hcCA9IHNvdXJjZS5saWdodE1hcDtcclxuXHR0aGlzLmxpZ2h0TWFwSW50ZW5zaXR5ID0gc291cmNlLmxpZ2h0TWFwSW50ZW5zaXR5O1xyXG5cclxuXHR0aGlzLmFvTWFwID0gc291cmNlLmFvTWFwO1xyXG5cdHRoaXMuYW9NYXBJbnRlbnNpdHkgPSBzb3VyY2UuYW9NYXBJbnRlbnNpdHk7XHJcblxyXG5cdHRoaXMuZW1pc3NpdmUuY29weSggc291cmNlLmVtaXNzaXZlICk7XHJcblx0dGhpcy5lbWlzc2l2ZU1hcCA9IHNvdXJjZS5lbWlzc2l2ZU1hcDtcclxuXHR0aGlzLmVtaXNzaXZlSW50ZW5zaXR5ID0gc291cmNlLmVtaXNzaXZlSW50ZW5zaXR5O1xyXG5cclxuXHR0aGlzLnNwZWN1bGFyTWFwID0gc291cmNlLnNwZWN1bGFyTWFwO1xyXG5cclxuXHR0aGlzLmFscGhhTWFwID0gc291cmNlLmFscGhhTWFwO1xyXG5cclxuXHR0aGlzLmVudk1hcCA9IHNvdXJjZS5lbnZNYXA7XHJcblx0dGhpcy5jb21iaW5lID0gc291cmNlLmNvbWJpbmU7XHJcblx0dGhpcy5yZWZsZWN0aXZpdHkgPSBzb3VyY2UucmVmbGVjdGl2aXR5O1xyXG5cdHRoaXMucmVmcmFjdGlvblJhdGlvID0gc291cmNlLnJlZnJhY3Rpb25SYXRpbztcclxuXHJcblx0dGhpcy5mb2cgPSBzb3VyY2UuZm9nO1xyXG5cclxuXHR0aGlzLndpcmVmcmFtZSA9IHNvdXJjZS53aXJlZnJhbWU7XHJcblx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSBzb3VyY2Uud2lyZWZyYW1lTGluZXdpZHRoO1xyXG5cdHRoaXMud2lyZWZyYW1lTGluZWNhcCA9IHNvdXJjZS53aXJlZnJhbWVMaW5lY2FwO1xyXG5cdHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSBzb3VyY2Uud2lyZWZyYW1lTGluZWpvaW47XHJcblxyXG5cdHRoaXMudmVydGV4Q29sb3JzID0gc291cmNlLnZlcnRleENvbG9ycztcclxuXHJcblx0dGhpcy5za2lubmluZyA9IHNvdXJjZS5za2lubmluZztcclxuXHR0aGlzLm1vcnBoVGFyZ2V0cyA9IHNvdXJjZS5tb3JwaFRhcmdldHM7XHJcblx0dGhpcy5tb3JwaE5vcm1hbHMgPSBzb3VyY2UubW9ycGhOb3JtYWxzO1xyXG5cclxuXHRyZXR1cm4gdGhpcztcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9tYXRlcmlhbHMvTWVzaFBob25nTWF0ZXJpYWwuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKlxyXG4gKiBwYXJhbWV0ZXJzID0ge1xyXG4gKiAgY29sb3I6IDxoZXg+LFxyXG4gKiAgc3BlY3VsYXI6IDxoZXg+LFxyXG4gKiAgc2hpbmluZXNzOiA8ZmxvYXQ+LFxyXG4gKiAgb3BhY2l0eTogPGZsb2F0PixcclxuICpcclxuICogIG1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcclxuICpcclxuICogIGxpZ2h0TWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxyXG4gKiAgbGlnaHRNYXBJbnRlbnNpdHk6IDxmbG9hdD5cclxuICpcclxuICogIGFvTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxyXG4gKiAgYW9NYXBJbnRlbnNpdHk6IDxmbG9hdD5cclxuICpcclxuICogIGVtaXNzaXZlOiA8aGV4PixcclxuICogIGVtaXNzaXZlSW50ZW5zaXR5OiA8ZmxvYXQ+XHJcbiAqICBlbWlzc2l2ZU1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcclxuICpcclxuICogIGJ1bXBNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXHJcbiAqICBidW1wU2NhbGU6IDxmbG9hdD4sXHJcbiAqXHJcbiAqICBub3JtYWxNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXHJcbiAqICBub3JtYWxTY2FsZTogPFZlY3RvcjI+LFxyXG4gKlxyXG4gKiAgZGlzcGxhY2VtZW50TWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxyXG4gKiAgZGlzcGxhY2VtZW50U2NhbGU6IDxmbG9hdD4sXHJcbiAqICBkaXNwbGFjZW1lbnRCaWFzOiA8ZmxvYXQ+LFxyXG4gKlxyXG4gKiAgc3BlY3VsYXJNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXHJcbiAqXHJcbiAqICBhbHBoYU1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcclxuICpcclxuICogIGVudk1hcDogbmV3IFRIUkVFLlRleHR1cmVDdWJlKCBbcG9zeCwgbmVneCwgcG9zeSwgbmVneSwgcG9zeiwgbmVnel0gKSxcclxuICogIGNvbWJpbmU6IFRIUkVFLk11bHRpcGx5LFxyXG4gKiAgcmVmbGVjdGl2aXR5OiA8ZmxvYXQ+LFxyXG4gKiAgcmVmcmFjdGlvblJhdGlvOiA8ZmxvYXQ+LFxyXG4gKlxyXG4gKiAgc2hhZGluZzogVEhSRUUuU21vb3RoU2hhZGluZyxcclxuICogIGJsZW5kaW5nOiBUSFJFRS5Ob3JtYWxCbGVuZGluZyxcclxuICogIGRlcHRoVGVzdDogPGJvb2w+LFxyXG4gKiAgZGVwdGhXcml0ZTogPGJvb2w+LFxyXG4gKlxyXG4gKiAgd2lyZWZyYW1lOiA8Ym9vbGVhbj4sXHJcbiAqICB3aXJlZnJhbWVMaW5ld2lkdGg6IDxmbG9hdD4sXHJcbiAqXHJcbiAqICB2ZXJ0ZXhDb2xvcnM6IFRIUkVFLk5vQ29sb3JzIC8gVEhSRUUuVmVydGV4Q29sb3JzIC8gVEhSRUUuRmFjZUNvbG9ycyxcclxuICpcclxuICogIHNraW5uaW5nOiA8Ym9vbD4sXHJcbiAqICBtb3JwaFRhcmdldHM6IDxib29sPixcclxuICogIG1vcnBoTm9ybWFsczogPGJvb2w+LFxyXG4gKlxyXG4gKlx0Zm9nOiA8Ym9vbD5cclxuICogfVxyXG4gKi9cclxuXHJcblRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsID0gZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xyXG5cclxuXHRUSFJFRS5NYXRlcmlhbC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMudHlwZSA9ICdNZXNoUGhvbmdNYXRlcmlhbCc7XHJcblxyXG5cdHRoaXMuY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmICk7IC8vIGRpZmZ1c2VcclxuXHR0aGlzLnNwZWN1bGFyID0gbmV3IFRIUkVFLkNvbG9yKCAweDExMTExMSApO1xyXG5cdHRoaXMuc2hpbmluZXNzID0gMzA7XHJcblxyXG5cdHRoaXMubWFwID0gbnVsbDtcclxuXHJcblx0dGhpcy5saWdodE1hcCA9IG51bGw7XHJcblx0dGhpcy5saWdodE1hcEludGVuc2l0eSA9IDEuMDtcclxuXHJcblx0dGhpcy5hb01hcCA9IG51bGw7XHJcblx0dGhpcy5hb01hcEludGVuc2l0eSA9IDEuMDtcclxuXHJcblx0dGhpcy5lbWlzc2l2ZSA9IG5ldyBUSFJFRS5Db2xvciggMHgwMDAwMDAgKTtcclxuXHR0aGlzLmVtaXNzaXZlSW50ZW5zaXR5ID0gMS4wO1xyXG5cdHRoaXMuZW1pc3NpdmVNYXAgPSBudWxsO1xyXG5cclxuXHR0aGlzLmJ1bXBNYXAgPSBudWxsO1xyXG5cdHRoaXMuYnVtcFNjYWxlID0gMTtcclxuXHJcblx0dGhpcy5ub3JtYWxNYXAgPSBudWxsO1xyXG5cdHRoaXMubm9ybWFsU2NhbGUgPSBuZXcgVEhSRUUuVmVjdG9yMiggMSwgMSApO1xyXG5cclxuXHR0aGlzLmRpc3BsYWNlbWVudE1hcCA9IG51bGw7XHJcblx0dGhpcy5kaXNwbGFjZW1lbnRTY2FsZSA9IDE7XHJcblx0dGhpcy5kaXNwbGFjZW1lbnRCaWFzID0gMDtcclxuXHJcblx0dGhpcy5zcGVjdWxhck1hcCA9IG51bGw7XHJcblxyXG5cdHRoaXMuYWxwaGFNYXAgPSBudWxsO1xyXG5cclxuXHR0aGlzLmVudk1hcCA9IG51bGw7XHJcblx0dGhpcy5jb21iaW5lID0gVEhSRUUuTXVsdGlwbHlPcGVyYXRpb247XHJcblx0dGhpcy5yZWZsZWN0aXZpdHkgPSAxO1xyXG5cdHRoaXMucmVmcmFjdGlvblJhdGlvID0gMC45ODtcclxuXHJcblx0dGhpcy5mb2cgPSB0cnVlO1xyXG5cclxuXHR0aGlzLnNoYWRpbmcgPSBUSFJFRS5TbW9vdGhTaGFkaW5nO1xyXG5cclxuXHR0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xyXG5cdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcclxuXHR0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSAncm91bmQnO1xyXG5cdHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSAncm91bmQnO1xyXG5cclxuXHR0aGlzLnZlcnRleENvbG9ycyA9IFRIUkVFLk5vQ29sb3JzO1xyXG5cclxuXHR0aGlzLnNraW5uaW5nID0gZmFsc2U7XHJcblx0dGhpcy5tb3JwaFRhcmdldHMgPSBmYWxzZTtcclxuXHR0aGlzLm1vcnBoTm9ybWFscyA9IGZhbHNlO1xyXG5cclxuXHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSApO1xyXG5USFJFRS5NZXNoUGhvbmdNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbDtcclxuXHJcblRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG5cdFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xyXG5cclxuXHR0aGlzLmNvbG9yLmNvcHkoIHNvdXJjZS5jb2xvciApO1xyXG5cdHRoaXMuc3BlY3VsYXIuY29weSggc291cmNlLnNwZWN1bGFyICk7XHJcblx0dGhpcy5zaGluaW5lc3MgPSBzb3VyY2Uuc2hpbmluZXNzO1xyXG5cclxuXHR0aGlzLm1hcCA9IHNvdXJjZS5tYXA7XHJcblxyXG5cdHRoaXMubGlnaHRNYXAgPSBzb3VyY2UubGlnaHRNYXA7XHJcblx0dGhpcy5saWdodE1hcEludGVuc2l0eSA9IHNvdXJjZS5saWdodE1hcEludGVuc2l0eTtcclxuXHJcblx0dGhpcy5hb01hcCA9IHNvdXJjZS5hb01hcDtcclxuXHR0aGlzLmFvTWFwSW50ZW5zaXR5ID0gc291cmNlLmFvTWFwSW50ZW5zaXR5O1xyXG5cclxuXHR0aGlzLmVtaXNzaXZlLmNvcHkoIHNvdXJjZS5lbWlzc2l2ZSApO1xyXG5cdHRoaXMuZW1pc3NpdmVNYXAgPSBzb3VyY2UuZW1pc3NpdmVNYXA7XHJcblx0dGhpcy5lbWlzc2l2ZUludGVuc2l0eSA9IHNvdXJjZS5lbWlzc2l2ZUludGVuc2l0eTtcclxuXHJcblx0dGhpcy5idW1wTWFwID0gc291cmNlLmJ1bXBNYXA7XHJcblx0dGhpcy5idW1wU2NhbGUgPSBzb3VyY2UuYnVtcFNjYWxlO1xyXG5cclxuXHR0aGlzLm5vcm1hbE1hcCA9IHNvdXJjZS5ub3JtYWxNYXA7XHJcblx0dGhpcy5ub3JtYWxTY2FsZS5jb3B5KCBzb3VyY2Uubm9ybWFsU2NhbGUgKTtcclxuXHJcblx0dGhpcy5kaXNwbGFjZW1lbnRNYXAgPSBzb3VyY2UuZGlzcGxhY2VtZW50TWFwO1xyXG5cdHRoaXMuZGlzcGxhY2VtZW50U2NhbGUgPSBzb3VyY2UuZGlzcGxhY2VtZW50U2NhbGU7XHJcblx0dGhpcy5kaXNwbGFjZW1lbnRCaWFzID0gc291cmNlLmRpc3BsYWNlbWVudEJpYXM7XHJcblxyXG5cdHRoaXMuc3BlY3VsYXJNYXAgPSBzb3VyY2Uuc3BlY3VsYXJNYXA7XHJcblxyXG5cdHRoaXMuYWxwaGFNYXAgPSBzb3VyY2UuYWxwaGFNYXA7XHJcblxyXG5cdHRoaXMuZW52TWFwID0gc291cmNlLmVudk1hcDtcclxuXHR0aGlzLmNvbWJpbmUgPSBzb3VyY2UuY29tYmluZTtcclxuXHR0aGlzLnJlZmxlY3Rpdml0eSA9IHNvdXJjZS5yZWZsZWN0aXZpdHk7XHJcblx0dGhpcy5yZWZyYWN0aW9uUmF0aW8gPSBzb3VyY2UucmVmcmFjdGlvblJhdGlvO1xyXG5cclxuXHR0aGlzLmZvZyA9IHNvdXJjZS5mb2c7XHJcblxyXG5cdHRoaXMuc2hhZGluZyA9IHNvdXJjZS5zaGFkaW5nO1xyXG5cclxuXHR0aGlzLndpcmVmcmFtZSA9IHNvdXJjZS53aXJlZnJhbWU7XHJcblx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSBzb3VyY2Uud2lyZWZyYW1lTGluZXdpZHRoO1xyXG5cdHRoaXMud2lyZWZyYW1lTGluZWNhcCA9IHNvdXJjZS53aXJlZnJhbWVMaW5lY2FwO1xyXG5cdHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSBzb3VyY2Uud2lyZWZyYW1lTGluZWpvaW47XHJcblxyXG5cdHRoaXMudmVydGV4Q29sb3JzID0gc291cmNlLnZlcnRleENvbG9ycztcclxuXHJcblx0dGhpcy5za2lubmluZyA9IHNvdXJjZS5za2lubmluZztcclxuXHR0aGlzLm1vcnBoVGFyZ2V0cyA9IHNvdXJjZS5tb3JwaFRhcmdldHM7XHJcblx0dGhpcy5tb3JwaE5vcm1hbHMgPSBzb3VyY2UubW9ycGhOb3JtYWxzO1xyXG5cclxuXHRyZXR1cm4gdGhpcztcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9tYXRlcmlhbHMvTWVzaFN0YW5kYXJkTWF0ZXJpYWwuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcclxuICpcclxuICogcGFyYW1ldGVycyA9IHtcclxuICogIGNvbG9yOiA8aGV4PixcclxuICogIHJvdWdobmVzczogPGZsb2F0PixcclxuICogIG1ldGFsbmVzczogPGZsb2F0PixcclxuICogIG9wYWNpdHk6IDxmbG9hdD4sXHJcbiAqXHJcbiAqICBtYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXHJcbiAqXHJcbiAqICBsaWdodE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcclxuICogIGxpZ2h0TWFwSW50ZW5zaXR5OiA8ZmxvYXQ+XHJcbiAqXHJcbiAqICBhb01hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcclxuICogIGFvTWFwSW50ZW5zaXR5OiA8ZmxvYXQ+XHJcbiAqXHJcbiAqICBlbWlzc2l2ZTogPGhleD4sXHJcbiAqICBlbWlzc2l2ZUludGVuc2l0eTogPGZsb2F0PlxyXG4gKiAgZW1pc3NpdmVNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXHJcbiAqXHJcbiAqICBidW1wTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxyXG4gKiAgYnVtcFNjYWxlOiA8ZmxvYXQ+LFxyXG4gKlxyXG4gKiAgbm9ybWFsTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxyXG4gKiAgbm9ybWFsU2NhbGU6IDxWZWN0b3IyPixcclxuICpcclxuICogIGRpc3BsYWNlbWVudE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcclxuICogIGRpc3BsYWNlbWVudFNjYWxlOiA8ZmxvYXQ+LFxyXG4gKiAgZGlzcGxhY2VtZW50QmlhczogPGZsb2F0PixcclxuICpcclxuICogIHJvdWdobmVzc01hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcclxuICpcclxuICogIG1ldGFsbmVzc01hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcclxuICpcclxuICogIGFscGhhTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxyXG4gKlxyXG4gKiAgZW52TWFwOiBuZXcgVEhSRUUuQ3ViZVRleHR1cmUoIFtwb3N4LCBuZWd4LCBwb3N5LCBuZWd5LCBwb3N6LCBuZWd6XSApLFxyXG4gKiAgZW52TWFwSW50ZW5zaXR5OiA8ZmxvYXQ+XHJcbiAqXHJcbiAqICByZWZyYWN0aW9uUmF0aW86IDxmbG9hdD4sXHJcbiAqXHJcbiAqICBzaGFkaW5nOiBUSFJFRS5TbW9vdGhTaGFkaW5nLFxyXG4gKiAgYmxlbmRpbmc6IFRIUkVFLk5vcm1hbEJsZW5kaW5nLFxyXG4gKiAgZGVwdGhUZXN0OiA8Ym9vbD4sXHJcbiAqICBkZXB0aFdyaXRlOiA8Ym9vbD4sXHJcbiAqXHJcbiAqICB3aXJlZnJhbWU6IDxib29sZWFuPixcclxuICogIHdpcmVmcmFtZUxpbmV3aWR0aDogPGZsb2F0PixcclxuICpcclxuICogIHZlcnRleENvbG9yczogVEhSRUUuTm9Db2xvcnMgLyBUSFJFRS5WZXJ0ZXhDb2xvcnMgLyBUSFJFRS5GYWNlQ29sb3JzLFxyXG4gKlxyXG4gKiAgc2tpbm5pbmc6IDxib29sPixcclxuICogIG1vcnBoVGFyZ2V0czogPGJvb2w+LFxyXG4gKiAgbW9ycGhOb3JtYWxzOiA8Ym9vbD4sXHJcbiAqXHJcbiAqXHRmb2c6IDxib29sPlxyXG4gKiB9XHJcbiAqL1xyXG5cclxuVEhSRUUuTWVzaFN0YW5kYXJkTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XHJcblxyXG5cdFRIUkVFLk1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy50eXBlID0gJ01lc2hTdGFuZGFyZE1hdGVyaWFsJztcclxuXHJcblx0dGhpcy5jb2xvciA9IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKTsgLy8gZGlmZnVzZVxyXG5cdHRoaXMucm91Z2huZXNzID0gMC41O1xyXG5cdHRoaXMubWV0YWxuZXNzID0gMC41O1xyXG5cclxuXHR0aGlzLm1hcCA9IG51bGw7XHJcblxyXG5cdHRoaXMubGlnaHRNYXAgPSBudWxsO1xyXG5cdHRoaXMubGlnaHRNYXBJbnRlbnNpdHkgPSAxLjA7XHJcblxyXG5cdHRoaXMuYW9NYXAgPSBudWxsO1xyXG5cdHRoaXMuYW9NYXBJbnRlbnNpdHkgPSAxLjA7XHJcblxyXG5cdHRoaXMuZW1pc3NpdmUgPSBuZXcgVEhSRUUuQ29sb3IoIDB4MDAwMDAwICk7XHJcblx0dGhpcy5lbWlzc2l2ZUludGVuc2l0eSA9IDEuMDtcclxuXHR0aGlzLmVtaXNzaXZlTWFwID0gbnVsbDtcclxuXHJcblx0dGhpcy5idW1wTWFwID0gbnVsbDtcclxuXHR0aGlzLmJ1bXBTY2FsZSA9IDE7XHJcblxyXG5cdHRoaXMubm9ybWFsTWFwID0gbnVsbDtcclxuXHR0aGlzLm5vcm1hbFNjYWxlID0gbmV3IFRIUkVFLlZlY3RvcjIoIDEsIDEgKTtcclxuXHJcblx0dGhpcy5kaXNwbGFjZW1lbnRNYXAgPSBudWxsO1xyXG5cdHRoaXMuZGlzcGxhY2VtZW50U2NhbGUgPSAxO1xyXG5cdHRoaXMuZGlzcGxhY2VtZW50QmlhcyA9IDA7XHJcblxyXG5cdHRoaXMucm91Z2huZXNzTWFwID0gbnVsbDtcclxuXHJcblx0dGhpcy5tZXRhbG5lc3NNYXAgPSBudWxsO1xyXG5cclxuXHR0aGlzLmFscGhhTWFwID0gbnVsbDtcclxuXHJcblx0dGhpcy5lbnZNYXAgPSBudWxsO1xyXG5cdHRoaXMuZW52TWFwSW50ZW5zaXR5ID0gMS4wO1xyXG5cclxuXHR0aGlzLnJlZnJhY3Rpb25SYXRpbyA9IDAuOTg7XHJcblxyXG5cdHRoaXMuZm9nID0gdHJ1ZTtcclxuXHJcblx0dGhpcy5zaGFkaW5nID0gVEhSRUUuU21vb3RoU2hhZGluZztcclxuXHJcblx0dGhpcy53aXJlZnJhbWUgPSBmYWxzZTtcclxuXHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XHJcblx0dGhpcy53aXJlZnJhbWVMaW5lY2FwID0gJ3JvdW5kJztcclxuXHR0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gJ3JvdW5kJztcclxuXHJcblx0dGhpcy52ZXJ0ZXhDb2xvcnMgPSBUSFJFRS5Ob0NvbG9ycztcclxuXHJcblx0dGhpcy5za2lubmluZyA9IGZhbHNlO1xyXG5cdHRoaXMubW9ycGhUYXJnZXRzID0gZmFsc2U7XHJcblx0dGhpcy5tb3JwaE5vcm1hbHMgPSBmYWxzZTtcclxuXHJcblx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5NZXNoU3RhbmRhcmRNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUgKTtcclxuVEhSRUUuTWVzaFN0YW5kYXJkTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuTWVzaFN0YW5kYXJkTWF0ZXJpYWw7XHJcblxyXG5USFJFRS5NZXNoU3RhbmRhcmRNYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuXHRUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcclxuXHJcblx0dGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcclxuXHR0aGlzLnJvdWdobmVzcyA9IHNvdXJjZS5yb3VnaG5lc3M7XHJcblx0dGhpcy5tZXRhbG5lc3MgPSBzb3VyY2UubWV0YWxuZXNzO1xyXG5cclxuXHR0aGlzLm1hcCA9IHNvdXJjZS5tYXA7XHJcblxyXG5cdHRoaXMubGlnaHRNYXAgPSBzb3VyY2UubGlnaHRNYXA7XHJcblx0dGhpcy5saWdodE1hcEludGVuc2l0eSA9IHNvdXJjZS5saWdodE1hcEludGVuc2l0eTtcclxuXHJcblx0dGhpcy5hb01hcCA9IHNvdXJjZS5hb01hcDtcclxuXHR0aGlzLmFvTWFwSW50ZW5zaXR5ID0gc291cmNlLmFvTWFwSW50ZW5zaXR5O1xyXG5cclxuXHR0aGlzLmVtaXNzaXZlLmNvcHkoIHNvdXJjZS5lbWlzc2l2ZSApO1xyXG5cdHRoaXMuZW1pc3NpdmVNYXAgPSBzb3VyY2UuZW1pc3NpdmVNYXA7XHJcblx0dGhpcy5lbWlzc2l2ZUludGVuc2l0eSA9IHNvdXJjZS5lbWlzc2l2ZUludGVuc2l0eTtcclxuXHJcblx0dGhpcy5idW1wTWFwID0gc291cmNlLmJ1bXBNYXA7XHJcblx0dGhpcy5idW1wU2NhbGUgPSBzb3VyY2UuYnVtcFNjYWxlO1xyXG5cclxuXHR0aGlzLm5vcm1hbE1hcCA9IHNvdXJjZS5ub3JtYWxNYXA7XHJcblx0dGhpcy5ub3JtYWxTY2FsZS5jb3B5KCBzb3VyY2Uubm9ybWFsU2NhbGUgKTtcclxuXHJcblx0dGhpcy5kaXNwbGFjZW1lbnRNYXAgPSBzb3VyY2UuZGlzcGxhY2VtZW50TWFwO1xyXG5cdHRoaXMuZGlzcGxhY2VtZW50U2NhbGUgPSBzb3VyY2UuZGlzcGxhY2VtZW50U2NhbGU7XHJcblx0dGhpcy5kaXNwbGFjZW1lbnRCaWFzID0gc291cmNlLmRpc3BsYWNlbWVudEJpYXM7XHJcblxyXG5cdHRoaXMucm91Z2huZXNzTWFwID0gc291cmNlLnJvdWdobmVzc01hcDtcclxuXHJcblx0dGhpcy5tZXRhbG5lc3NNYXAgPSBzb3VyY2UubWV0YWxuZXNzTWFwO1xyXG5cclxuXHR0aGlzLmFscGhhTWFwID0gc291cmNlLmFscGhhTWFwO1xyXG5cclxuXHR0aGlzLmVudk1hcCA9IHNvdXJjZS5lbnZNYXA7XHJcblx0dGhpcy5lbnZNYXBJbnRlbnNpdHkgPSBzb3VyY2UuZW52TWFwSW50ZW5zaXR5O1xyXG5cclxuXHR0aGlzLnJlZnJhY3Rpb25SYXRpbyA9IHNvdXJjZS5yZWZyYWN0aW9uUmF0aW87XHJcblxyXG5cdHRoaXMuZm9nID0gc291cmNlLmZvZztcclxuXHJcblx0dGhpcy5zaGFkaW5nID0gc291cmNlLnNoYWRpbmc7XHJcblxyXG5cdHRoaXMud2lyZWZyYW1lID0gc291cmNlLndpcmVmcmFtZTtcclxuXHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IHNvdXJjZS53aXJlZnJhbWVMaW5ld2lkdGg7XHJcblx0dGhpcy53aXJlZnJhbWVMaW5lY2FwID0gc291cmNlLndpcmVmcmFtZUxpbmVjYXA7XHJcblx0dGhpcy53aXJlZnJhbWVMaW5lam9pbiA9IHNvdXJjZS53aXJlZnJhbWVMaW5lam9pbjtcclxuXHJcblx0dGhpcy52ZXJ0ZXhDb2xvcnMgPSBzb3VyY2UudmVydGV4Q29sb3JzO1xyXG5cclxuXHR0aGlzLnNraW5uaW5nID0gc291cmNlLnNraW5uaW5nO1xyXG5cdHRoaXMubW9ycGhUYXJnZXRzID0gc291cmNlLm1vcnBoVGFyZ2V0cztcclxuXHR0aGlzLm1vcnBoTm9ybWFscyA9IHNvdXJjZS5tb3JwaE5vcm1hbHM7XHJcblxyXG5cdHJldHVybiB0aGlzO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL21hdGVyaWFscy9NZXNoRGVwdGhNYXRlcmlhbC5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqXHJcbiAqIHBhcmFtZXRlcnMgPSB7XHJcbiAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxyXG4gKlxyXG4gKiAgYmxlbmRpbmc6IFRIUkVFLk5vcm1hbEJsZW5kaW5nLFxyXG4gKiAgZGVwdGhUZXN0OiA8Ym9vbD4sXHJcbiAqICBkZXB0aFdyaXRlOiA8Ym9vbD4sXHJcbiAqXHJcbiAqICB3aXJlZnJhbWU6IDxib29sZWFuPixcclxuICogIHdpcmVmcmFtZUxpbmV3aWR0aDogPGZsb2F0PlxyXG4gKiB9XHJcbiAqL1xyXG5cclxuVEhSRUUuTWVzaERlcHRoTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XHJcblxyXG5cdFRIUkVFLk1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy50eXBlID0gJ01lc2hEZXB0aE1hdGVyaWFsJztcclxuXHJcblx0dGhpcy5tb3JwaFRhcmdldHMgPSBmYWxzZTtcclxuXHR0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xyXG5cdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcclxuXHJcblx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5NZXNoRGVwdGhNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUgKTtcclxuVEhSRUUuTWVzaERlcHRoTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuTWVzaERlcHRoTWF0ZXJpYWw7XHJcblxyXG5USFJFRS5NZXNoRGVwdGhNYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuXHRUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcclxuXHJcblx0dGhpcy53aXJlZnJhbWUgPSBzb3VyY2Uud2lyZWZyYW1lO1xyXG5cdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gc291cmNlLndpcmVmcmFtZUxpbmV3aWR0aDtcclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbWF0ZXJpYWxzL01lc2hOb3JtYWxNYXRlcmlhbC5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqXHJcbiAqIHBhcmFtZXRlcnMgPSB7XHJcbiAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxyXG4gKlxyXG4gKiAgc2hhZGluZzogVEhSRUUuRmxhdFNoYWRpbmcsXHJcbiAqICBibGVuZGluZzogVEhSRUUuTm9ybWFsQmxlbmRpbmcsXHJcbiAqICBkZXB0aFRlc3Q6IDxib29sPixcclxuICogIGRlcHRoV3JpdGU6IDxib29sPixcclxuICpcclxuICogIHdpcmVmcmFtZTogPGJvb2xlYW4+LFxyXG4gKiAgd2lyZWZyYW1lTGluZXdpZHRoOiA8ZmxvYXQ+XHJcbiAqIH1cclxuICovXHJcblxyXG5USFJFRS5NZXNoTm9ybWFsTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XHJcblxyXG5cdFRIUkVFLk1hdGVyaWFsLmNhbGwoIHRoaXMsIHBhcmFtZXRlcnMgKTtcclxuXHJcblx0dGhpcy50eXBlID0gJ01lc2hOb3JtYWxNYXRlcmlhbCc7XHJcblxyXG5cdHRoaXMud2lyZWZyYW1lID0gZmFsc2U7XHJcblx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSAxO1xyXG5cclxuXHR0aGlzLm1vcnBoVGFyZ2V0cyA9IGZhbHNlO1xyXG5cclxuXHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLk1lc2hOb3JtYWxNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUgKTtcclxuVEhSRUUuTWVzaE5vcm1hbE1hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLk1lc2hOb3JtYWxNYXRlcmlhbDtcclxuXHJcblRIUkVFLk1lc2hOb3JtYWxNYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuXHRUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcclxuXHJcblx0dGhpcy53aXJlZnJhbWUgPSBzb3VyY2Uud2lyZWZyYW1lO1xyXG5cdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gc291cmNlLndpcmVmcmFtZUxpbmV3aWR0aDtcclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbWF0ZXJpYWxzL011bHRpTWF0ZXJpYWwuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLk11bHRpTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIG1hdGVyaWFscyApIHtcclxuXHJcblx0dGhpcy51dWlkID0gVEhSRUUuTWF0aC5nZW5lcmF0ZVVVSUQoKTtcclxuXHJcblx0dGhpcy50eXBlID0gJ011bHRpTWF0ZXJpYWwnO1xyXG5cclxuXHR0aGlzLm1hdGVyaWFscyA9IG1hdGVyaWFscyBpbnN0YW5jZW9mIEFycmF5ID8gbWF0ZXJpYWxzIDogW107XHJcblxyXG5cdHRoaXMudmlzaWJsZSA9IHRydWU7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTXVsdGlNYXRlcmlhbC5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5NdWx0aU1hdGVyaWFsLFxyXG5cclxuXHR0b0pTT046IGZ1bmN0aW9uICggbWV0YSApIHtcclxuXHJcblx0XHR2YXIgb3V0cHV0ID0ge1xyXG5cdFx0XHRtZXRhZGF0YToge1xyXG5cdFx0XHRcdHZlcnNpb246IDQuMixcclxuXHRcdFx0XHR0eXBlOiAnbWF0ZXJpYWwnLFxyXG5cdFx0XHRcdGdlbmVyYXRvcjogJ01hdGVyaWFsRXhwb3J0ZXInXHJcblx0XHRcdH0sXHJcblx0XHRcdHV1aWQ6IHRoaXMudXVpZCxcclxuXHRcdFx0dHlwZTogdGhpcy50eXBlLFxyXG5cdFx0XHRtYXRlcmlhbHM6IFtdXHJcblx0XHR9O1xyXG5cclxuXHRcdHZhciBtYXRlcmlhbHMgPSB0aGlzLm1hdGVyaWFscztcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBtYXRlcmlhbHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciBtYXRlcmlhbCA9IG1hdGVyaWFsc1sgaSBdLnRvSlNPTiggbWV0YSApO1xyXG5cdFx0XHRkZWxldGUgbWF0ZXJpYWwubWV0YWRhdGE7XHJcblxyXG5cdFx0XHRvdXRwdXQubWF0ZXJpYWxzLnB1c2goIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdG91dHB1dC52aXNpYmxlID0gdGhpcy52aXNpYmxlO1xyXG5cclxuXHRcdHJldHVybiBvdXRwdXQ7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIG1hdGVyaWFsID0gbmV3IHRoaXMuY29uc3RydWN0b3IoKTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLm1hdGVyaWFscy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRtYXRlcmlhbC5tYXRlcmlhbHMucHVzaCggdGhpcy5tYXRlcmlhbHNbIGkgXS5jbG9uZSgpICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdG1hdGVyaWFsLnZpc2libGUgPSB0aGlzLnZpc2libGU7XHJcblxyXG5cdFx0cmV0dXJuIG1hdGVyaWFsO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbWF0ZXJpYWxzL1BvaW50c01hdGVyaWFsLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICpcclxuICogcGFyYW1ldGVycyA9IHtcclxuICogIGNvbG9yOiA8aGV4PixcclxuICogIG9wYWNpdHk6IDxmbG9hdD4sXHJcbiAqICBtYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXHJcbiAqXHJcbiAqICBzaXplOiA8ZmxvYXQ+LFxyXG4gKiAgc2l6ZUF0dGVudWF0aW9uOiA8Ym9vbD4sXHJcbiAqXHJcbiAqICBibGVuZGluZzogVEhSRUUuTm9ybWFsQmxlbmRpbmcsXHJcbiAqICBkZXB0aFRlc3Q6IDxib29sPixcclxuICogIGRlcHRoV3JpdGU6IDxib29sPixcclxuICpcclxuICogIHZlcnRleENvbG9yczogPGJvb2w+LFxyXG4gKlxyXG4gKiAgZm9nOiA8Ym9vbD5cclxuICogfVxyXG4gKi9cclxuXHJcblRIUkVFLlBvaW50c01hdGVyaWFsID0gZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xyXG5cclxuXHRUSFJFRS5NYXRlcmlhbC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMudHlwZSA9ICdQb2ludHNNYXRlcmlhbCc7XHJcblxyXG5cdHRoaXMuY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmICk7XHJcblxyXG5cdHRoaXMubWFwID0gbnVsbDtcclxuXHJcblx0dGhpcy5zaXplID0gMTtcclxuXHR0aGlzLnNpemVBdHRlbnVhdGlvbiA9IHRydWU7XHJcblxyXG5cdHRoaXMudmVydGV4Q29sb3JzID0gVEhSRUUuTm9Db2xvcnM7XHJcblxyXG5cdHRoaXMuZm9nID0gdHJ1ZTtcclxuXHJcblx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Qb2ludHNNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUgKTtcclxuVEhSRUUuUG9pbnRzTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuUG9pbnRzTWF0ZXJpYWw7XHJcblxyXG5USFJFRS5Qb2ludHNNYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuXHRUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcclxuXHJcblx0dGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcclxuXHJcblx0dGhpcy5tYXAgPSBzb3VyY2UubWFwO1xyXG5cclxuXHR0aGlzLnNpemUgPSBzb3VyY2Uuc2l6ZTtcclxuXHR0aGlzLnNpemVBdHRlbnVhdGlvbiA9IHNvdXJjZS5zaXplQXR0ZW51YXRpb247XHJcblxyXG5cdHRoaXMudmVydGV4Q29sb3JzID0gc291cmNlLnZlcnRleENvbG9ycztcclxuXHJcblx0dGhpcy5mb2cgPSBzb3VyY2UuZm9nO1xyXG5cclxuXHRyZXR1cm4gdGhpcztcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9tYXRlcmlhbHMvU2hhZGVyTWF0ZXJpYWwuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKlxyXG4gKiBwYXJhbWV0ZXJzID0ge1xyXG4gKiAgZGVmaW5lczogeyBcImxhYmVsXCIgOiBcInZhbHVlXCIgfSxcclxuICogIHVuaWZvcm1zOiB7IFwicGFyYW1ldGVyMVwiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMS4wIH0sIFwicGFyYW1ldGVyMlwiOiB7IHR5cGU6IFwiaVwiIHZhbHVlMjogMiB9IH0sXHJcbiAqXHJcbiAqICBmcmFnbWVudFNoYWRlcjogPHN0cmluZz4sXHJcbiAqICB2ZXJ0ZXhTaGFkZXI6IDxzdHJpbmc+LFxyXG4gKlxyXG4gKiAgc2hhZGluZzogVEhSRUUuU21vb3RoU2hhZGluZyxcclxuICogIGJsZW5kaW5nOiBUSFJFRS5Ob3JtYWxCbGVuZGluZyxcclxuICogIGRlcHRoVGVzdDogPGJvb2w+LFxyXG4gKiAgZGVwdGhXcml0ZTogPGJvb2w+LFxyXG4gKlxyXG4gKiAgd2lyZWZyYW1lOiA8Ym9vbGVhbj4sXHJcbiAqICB3aXJlZnJhbWVMaW5ld2lkdGg6IDxmbG9hdD4sXHJcbiAqXHJcbiAqICBsaWdodHM6IDxib29sPixcclxuICpcclxuICogIHZlcnRleENvbG9yczogVEhSRUUuTm9Db2xvcnMgLyBUSFJFRS5WZXJ0ZXhDb2xvcnMgLyBUSFJFRS5GYWNlQ29sb3JzLFxyXG4gKlxyXG4gKiAgc2tpbm5pbmc6IDxib29sPixcclxuICogIG1vcnBoVGFyZ2V0czogPGJvb2w+LFxyXG4gKiAgbW9ycGhOb3JtYWxzOiA8Ym9vbD4sXHJcbiAqXHJcbiAqXHRmb2c6IDxib29sPlxyXG4gKiB9XHJcbiAqL1xyXG5cclxuVEhSRUUuU2hhZGVyTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XHJcblxyXG5cdFRIUkVFLk1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy50eXBlID0gJ1NoYWRlck1hdGVyaWFsJztcclxuXHJcblx0dGhpcy5kZWZpbmVzID0ge307XHJcblx0dGhpcy51bmlmb3JtcyA9IHt9O1xyXG5cclxuXHR0aGlzLnZlcnRleFNoYWRlciA9ICd2b2lkIG1haW4oKSB7XFxuXFx0Z2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1xcbn0nO1xyXG5cdHRoaXMuZnJhZ21lbnRTaGFkZXIgPSAndm9pZCBtYWluKCkge1xcblxcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIDEuMCwgMC4wLCAwLjAsIDEuMCApO1xcbn0nO1xyXG5cclxuXHR0aGlzLnNoYWRpbmcgPSBUSFJFRS5TbW9vdGhTaGFkaW5nO1xyXG5cclxuXHR0aGlzLmxpbmV3aWR0aCA9IDE7XHJcblxyXG5cdHRoaXMud2lyZWZyYW1lID0gZmFsc2U7XHJcblx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSAxO1xyXG5cclxuXHR0aGlzLmZvZyA9IGZhbHNlOyAvLyBzZXQgdG8gdXNlIHNjZW5lIGZvZ1xyXG5cclxuXHR0aGlzLmxpZ2h0cyA9IGZhbHNlOyAvLyBzZXQgdG8gdXNlIHNjZW5lIGxpZ2h0c1xyXG5cclxuXHR0aGlzLnZlcnRleENvbG9ycyA9IFRIUkVFLk5vQ29sb3JzOyAvLyBzZXQgdG8gdXNlIFwiY29sb3JcIiBhdHRyaWJ1dGUgc3RyZWFtXHJcblxyXG5cdHRoaXMuc2tpbm5pbmcgPSBmYWxzZTsgLy8gc2V0IHRvIHVzZSBza2lubmluZyBhdHRyaWJ1dGUgc3RyZWFtc1xyXG5cclxuXHR0aGlzLm1vcnBoVGFyZ2V0cyA9IGZhbHNlOyAvLyBzZXQgdG8gdXNlIG1vcnBoIHRhcmdldHNcclxuXHR0aGlzLm1vcnBoTm9ybWFscyA9IGZhbHNlOyAvLyBzZXQgdG8gdXNlIG1vcnBoIG5vcm1hbHNcclxuXHJcblx0dGhpcy5leHRlbnNpb25zID0ge1xyXG5cdFx0ZGVyaXZhdGl2ZXM6IGZhbHNlLCAvLyBzZXQgdG8gdXNlIGRlcml2YXRpdmVzXHJcblx0XHRmcmFnRGVwdGg6IGZhbHNlLCAvLyBzZXQgdG8gdXNlIGZyYWdtZW50IGRlcHRoIHZhbHVlc1xyXG5cdFx0ZHJhd0J1ZmZlcnM6IGZhbHNlLCAvLyBzZXQgdG8gdXNlIGRyYXcgYnVmZmVyc1xyXG5cdFx0c2hhZGVyVGV4dHVyZUxPRDogZmFsc2UgLy8gc2V0IHRvIHVzZSBzaGFkZXIgdGV4dHVyZSBMT0RcclxuXHR9O1xyXG5cclxuXHQvLyBXaGVuIHJlbmRlcmVkIGdlb21ldHJ5IGRvZXNuJ3QgaW5jbHVkZSB0aGVzZSBhdHRyaWJ1dGVzIGJ1dCB0aGUgbWF0ZXJpYWwgZG9lcyxcclxuXHQvLyB1c2UgdGhlc2UgZGVmYXVsdCB2YWx1ZXMgaW4gV2ViR0wuIFRoaXMgYXZvaWRzIGVycm9ycyB3aGVuIGJ1ZmZlciBkYXRhIGlzIG1pc3NpbmcuXHJcblx0dGhpcy5kZWZhdWx0QXR0cmlidXRlVmFsdWVzID0ge1xyXG5cdFx0J2NvbG9yJzogWyAxLCAxLCAxIF0sXHJcblx0XHQndXYnOiBbIDAsIDAgXSxcclxuXHRcdCd1djInOiBbIDAsIDAgXVxyXG5cdH07XHJcblxyXG5cdHRoaXMuaW5kZXgwQXR0cmlidXRlTmFtZSA9IHVuZGVmaW5lZDtcclxuXHJcblx0aWYgKCBwYXJhbWV0ZXJzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0aWYgKCBwYXJhbWV0ZXJzLmF0dHJpYnV0ZXMgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5TaGFkZXJNYXRlcmlhbDogYXR0cmlidXRlcyBzaG91bGQgbm93IGJlIGRlZmluZWQgaW4gVEhSRUUuQnVmZmVyR2VvbWV0cnkgaW5zdGVhZC4nICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5TaGFkZXJNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUgKTtcclxuVEhSRUUuU2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuU2hhZGVyTWF0ZXJpYWw7XHJcblxyXG5USFJFRS5TaGFkZXJNYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuXHRUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcclxuXHJcblx0dGhpcy5mcmFnbWVudFNoYWRlciA9IHNvdXJjZS5mcmFnbWVudFNoYWRlcjtcclxuXHR0aGlzLnZlcnRleFNoYWRlciA9IHNvdXJjZS52ZXJ0ZXhTaGFkZXI7XHJcblxyXG5cdHRoaXMudW5pZm9ybXMgPSBUSFJFRS5Vbmlmb3Jtc1V0aWxzLmNsb25lKCBzb3VyY2UudW5pZm9ybXMgKTtcclxuXHJcblx0dGhpcy5kZWZpbmVzID0gc291cmNlLmRlZmluZXM7XHJcblxyXG5cdHRoaXMuc2hhZGluZyA9IHNvdXJjZS5zaGFkaW5nO1xyXG5cclxuXHR0aGlzLndpcmVmcmFtZSA9IHNvdXJjZS53aXJlZnJhbWU7XHJcblx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSBzb3VyY2Uud2lyZWZyYW1lTGluZXdpZHRoO1xyXG5cclxuXHR0aGlzLmZvZyA9IHNvdXJjZS5mb2c7XHJcblxyXG5cdHRoaXMubGlnaHRzID0gc291cmNlLmxpZ2h0cztcclxuXHJcblx0dGhpcy52ZXJ0ZXhDb2xvcnMgPSBzb3VyY2UudmVydGV4Q29sb3JzO1xyXG5cclxuXHR0aGlzLnNraW5uaW5nID0gc291cmNlLnNraW5uaW5nO1xyXG5cclxuXHR0aGlzLm1vcnBoVGFyZ2V0cyA9IHNvdXJjZS5tb3JwaFRhcmdldHM7XHJcblx0dGhpcy5tb3JwaE5vcm1hbHMgPSBzb3VyY2UubW9ycGhOb3JtYWxzO1xyXG5cclxuXHR0aGlzLmV4dGVuc2lvbnMgPSBzb3VyY2UuZXh0ZW5zaW9ucztcclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuU2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICggbWV0YSApIHtcclxuXHJcblx0dmFyIGRhdGEgPSBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMsIG1ldGEgKTtcclxuXHJcblx0ZGF0YS51bmlmb3JtcyA9IHRoaXMudW5pZm9ybXM7XHJcblx0ZGF0YS52ZXJ0ZXhTaGFkZXIgPSB0aGlzLnZlcnRleFNoYWRlcjtcclxuXHRkYXRhLmZyYWdtZW50U2hhZGVyID0gdGhpcy5mcmFnbWVudFNoYWRlcjtcclxuXHJcblx0cmV0dXJuIGRhdGE7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvbWF0ZXJpYWxzL1Jhd1NoYWRlck1hdGVyaWFsLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5SYXdTaGFkZXJNYXRlcmlhbCA9IGZ1bmN0aW9uICggcGFyYW1ldGVycyApIHtcclxuXHJcblx0VEhSRUUuU2hhZGVyTWF0ZXJpYWwuY2FsbCggdGhpcywgcGFyYW1ldGVycyApO1xyXG5cclxuXHR0aGlzLnR5cGUgPSAnUmF3U2hhZGVyTWF0ZXJpYWwnO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlJhd1NoYWRlck1hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLlNoYWRlck1hdGVyaWFsLnByb3RvdHlwZSApO1xyXG5USFJFRS5SYXdTaGFkZXJNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5SYXdTaGFkZXJNYXRlcmlhbDtcclxuXHJcbi8vIEZpbGU6c3JjL21hdGVyaWFscy9TcHJpdGVNYXRlcmlhbC5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqXHJcbiAqIHBhcmFtZXRlcnMgPSB7XHJcbiAqICBjb2xvcjogPGhleD4sXHJcbiAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxyXG4gKiAgbWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxyXG4gKlxyXG4gKiAgYmxlbmRpbmc6IFRIUkVFLk5vcm1hbEJsZW5kaW5nLFxyXG4gKiAgZGVwdGhUZXN0OiA8Ym9vbD4sXHJcbiAqICBkZXB0aFdyaXRlOiA8Ym9vbD4sXHJcbiAqXHJcbiAqXHR1dk9mZnNldDogbmV3IFRIUkVFLlZlY3RvcjIoKSxcclxuICpcdHV2U2NhbGU6IG5ldyBUSFJFRS5WZWN0b3IyKCksXHJcbiAqXHJcbiAqICBmb2c6IDxib29sPlxyXG4gKiB9XHJcbiAqL1xyXG5cclxuVEhSRUUuU3ByaXRlTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XHJcblxyXG5cdFRIUkVFLk1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy50eXBlID0gJ1Nwcml0ZU1hdGVyaWFsJztcclxuXHJcblx0dGhpcy5jb2xvciA9IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKTtcclxuXHR0aGlzLm1hcCA9IG51bGw7XHJcblxyXG5cdHRoaXMucm90YXRpb24gPSAwO1xyXG5cclxuXHR0aGlzLmZvZyA9IGZhbHNlO1xyXG5cclxuXHQvLyBzZXQgcGFyYW1ldGVyc1xyXG5cclxuXHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlNwcml0ZU1hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSApO1xyXG5USFJFRS5TcHJpdGVNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5TcHJpdGVNYXRlcmlhbDtcclxuXHJcblRIUkVFLlNwcml0ZU1hdGVyaWFsLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG5cdFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xyXG5cclxuXHR0aGlzLmNvbG9yLmNvcHkoIHNvdXJjZS5jb2xvciApO1xyXG5cdHRoaXMubWFwID0gc291cmNlLm1hcDtcclxuXHJcblx0dGhpcy5yb3RhdGlvbiA9IHNvdXJjZS5yb3RhdGlvbjtcclxuXHJcblx0dGhpcy5mb2cgPSBzb3VyY2UuZm9nO1xyXG5cclxuXHRyZXR1cm4gdGhpcztcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy90ZXh0dXJlcy9UZXh0dXJlLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICogQGF1dGhvciBzemltZWsgLyBodHRwczovL2dpdGh1Yi5jb20vc3ppbWVrL1xyXG4gKi9cclxuXHJcblRIUkVFLlRleHR1cmUgPSBmdW5jdGlvbiAoIGltYWdlLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHkgKSB7XHJcblxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgJ2lkJywgeyB2YWx1ZTogVEhSRUUuVGV4dHVyZUlkQ291bnQgKysgfSApO1xyXG5cclxuXHR0aGlzLnV1aWQgPSBUSFJFRS5NYXRoLmdlbmVyYXRlVVVJRCgpO1xyXG5cclxuXHR0aGlzLm5hbWUgPSAnJztcclxuXHR0aGlzLnNvdXJjZUZpbGUgPSAnJztcclxuXHJcblx0dGhpcy5pbWFnZSA9IGltYWdlICE9PSB1bmRlZmluZWQgPyBpbWFnZSA6IFRIUkVFLlRleHR1cmUuREVGQVVMVF9JTUFHRTtcclxuXHR0aGlzLm1pcG1hcHMgPSBbXTtcclxuXHJcblx0dGhpcy5tYXBwaW5nID0gbWFwcGluZyAhPT0gdW5kZWZpbmVkID8gbWFwcGluZyA6IFRIUkVFLlRleHR1cmUuREVGQVVMVF9NQVBQSU5HO1xyXG5cclxuXHR0aGlzLndyYXBTID0gd3JhcFMgIT09IHVuZGVmaW5lZCA/IHdyYXBTIDogVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZztcclxuXHR0aGlzLndyYXBUID0gd3JhcFQgIT09IHVuZGVmaW5lZCA/IHdyYXBUIDogVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZztcclxuXHJcblx0dGhpcy5tYWdGaWx0ZXIgPSBtYWdGaWx0ZXIgIT09IHVuZGVmaW5lZCA/IG1hZ0ZpbHRlciA6IFRIUkVFLkxpbmVhckZpbHRlcjtcclxuXHR0aGlzLm1pbkZpbHRlciA9IG1pbkZpbHRlciAhPT0gdW5kZWZpbmVkID8gbWluRmlsdGVyIDogVEhSRUUuTGluZWFyTWlwTWFwTGluZWFyRmlsdGVyO1xyXG5cclxuXHR0aGlzLmFuaXNvdHJvcHkgPSBhbmlzb3Ryb3B5ICE9PSB1bmRlZmluZWQgPyBhbmlzb3Ryb3B5IDogMTtcclxuXHJcblx0dGhpcy5mb3JtYXQgPSBmb3JtYXQgIT09IHVuZGVmaW5lZCA/IGZvcm1hdCA6IFRIUkVFLlJHQkFGb3JtYXQ7XHJcblx0dGhpcy50eXBlID0gdHlwZSAhPT0gdW5kZWZpbmVkID8gdHlwZSA6IFRIUkVFLlVuc2lnbmVkQnl0ZVR5cGU7XHJcblxyXG5cdHRoaXMub2Zmc2V0ID0gbmV3IFRIUkVFLlZlY3RvcjIoIDAsIDAgKTtcclxuXHR0aGlzLnJlcGVhdCA9IG5ldyBUSFJFRS5WZWN0b3IyKCAxLCAxICk7XHJcblxyXG5cdHRoaXMuZ2VuZXJhdGVNaXBtYXBzID0gdHJ1ZTtcclxuXHR0aGlzLnByZW11bHRpcGx5QWxwaGEgPSBmYWxzZTtcclxuXHR0aGlzLmZsaXBZID0gdHJ1ZTtcclxuXHR0aGlzLnVucGFja0FsaWdubWVudCA9IDQ7IC8vIHZhbGlkIHZhbHVlczogMSwgMiwgNCwgOCAoc2VlIGh0dHA6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsZXMvc2RrL2RvY3MvbWFuL3hodG1sL2dsUGl4ZWxTdG9yZWkueG1sKVxyXG5cclxuXHR0aGlzLnZlcnNpb24gPSAwO1xyXG5cdHRoaXMub25VcGRhdGUgPSBudWxsO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlRleHR1cmUuREVGQVVMVF9JTUFHRSA9IHVuZGVmaW5lZDtcclxuVEhSRUUuVGV4dHVyZS5ERUZBVUxUX01BUFBJTkcgPSBUSFJFRS5VVk1hcHBpbmc7XHJcblxyXG5USFJFRS5UZXh0dXJlLnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLlRleHR1cmUsXHJcblxyXG5cdHNldCBuZWVkc1VwZGF0ZSAoIHZhbHVlICkge1xyXG5cclxuXHRcdGlmICggdmFsdWUgPT09IHRydWUgKSB0aGlzLnZlcnNpb24gKys7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcblx0XHR0aGlzLmltYWdlID0gc291cmNlLmltYWdlO1xyXG5cdFx0dGhpcy5taXBtYXBzID0gc291cmNlLm1pcG1hcHMuc2xpY2UoIDAgKTtcclxuXHJcblx0XHR0aGlzLm1hcHBpbmcgPSBzb3VyY2UubWFwcGluZztcclxuXHJcblx0XHR0aGlzLndyYXBTID0gc291cmNlLndyYXBTO1xyXG5cdFx0dGhpcy53cmFwVCA9IHNvdXJjZS53cmFwVDtcclxuXHJcblx0XHR0aGlzLm1hZ0ZpbHRlciA9IHNvdXJjZS5tYWdGaWx0ZXI7XHJcblx0XHR0aGlzLm1pbkZpbHRlciA9IHNvdXJjZS5taW5GaWx0ZXI7XHJcblxyXG5cdFx0dGhpcy5hbmlzb3Ryb3B5ID0gc291cmNlLmFuaXNvdHJvcHk7XHJcblxyXG5cdFx0dGhpcy5mb3JtYXQgPSBzb3VyY2UuZm9ybWF0O1xyXG5cdFx0dGhpcy50eXBlID0gc291cmNlLnR5cGU7XHJcblxyXG5cdFx0dGhpcy5vZmZzZXQuY29weSggc291cmNlLm9mZnNldCApO1xyXG5cdFx0dGhpcy5yZXBlYXQuY29weSggc291cmNlLnJlcGVhdCApO1xyXG5cclxuXHRcdHRoaXMuZ2VuZXJhdGVNaXBtYXBzID0gc291cmNlLmdlbmVyYXRlTWlwbWFwcztcclxuXHRcdHRoaXMucHJlbXVsdGlwbHlBbHBoYSA9IHNvdXJjZS5wcmVtdWx0aXBseUFscGhhO1xyXG5cdFx0dGhpcy5mbGlwWSA9IHNvdXJjZS5mbGlwWTtcclxuXHRcdHRoaXMudW5wYWNrQWxpZ25tZW50ID0gc291cmNlLnVucGFja0FsaWdubWVudDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0dG9KU09OOiBmdW5jdGlvbiAoIG1ldGEgKSB7XHJcblxyXG5cdFx0aWYgKCBtZXRhLnRleHR1cmVzWyB0aGlzLnV1aWQgXSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIG1ldGEudGV4dHVyZXNbIHRoaXMudXVpZCBdO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBnZXREYXRhVVJMKCBpbWFnZSApIHtcclxuXHJcblx0XHRcdHZhciBjYW52YXM7XHJcblxyXG5cdFx0XHRpZiAoIGltYWdlLnRvRGF0YVVSTCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRjYW52YXMgPSBpbWFnZTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdjYW52YXMnICk7XHJcblx0XHRcdFx0Y2FudmFzLndpZHRoID0gaW1hZ2Uud2lkdGg7XHJcblx0XHRcdFx0Y2FudmFzLmhlaWdodCA9IGltYWdlLmhlaWdodDtcclxuXHJcblx0XHRcdFx0Y2FudmFzLmdldENvbnRleHQoICcyZCcgKS5kcmF3SW1hZ2UoIGltYWdlLCAwLCAwLCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGNhbnZhcy53aWR0aCA+IDIwNDggfHwgY2FudmFzLmhlaWdodCA+IDIwNDggKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiBjYW52YXMudG9EYXRhVVJMKCAnaW1hZ2UvanBlZycsIDAuNiApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIGNhbnZhcy50b0RhdGFVUkwoICdpbWFnZS9wbmcnICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBvdXRwdXQgPSB7XHJcblx0XHRcdG1ldGFkYXRhOiB7XHJcblx0XHRcdFx0dmVyc2lvbjogNC40LFxyXG5cdFx0XHRcdHR5cGU6ICdUZXh0dXJlJyxcclxuXHRcdFx0XHRnZW5lcmF0b3I6ICdUZXh0dXJlLnRvSlNPTidcclxuXHRcdFx0fSxcclxuXHJcblx0XHRcdHV1aWQ6IHRoaXMudXVpZCxcclxuXHRcdFx0bmFtZTogdGhpcy5uYW1lLFxyXG5cclxuXHRcdFx0bWFwcGluZzogdGhpcy5tYXBwaW5nLFxyXG5cclxuXHRcdFx0cmVwZWF0OiBbIHRoaXMucmVwZWF0LngsIHRoaXMucmVwZWF0LnkgXSxcclxuXHRcdFx0b2Zmc2V0OiBbIHRoaXMub2Zmc2V0LngsIHRoaXMub2Zmc2V0LnkgXSxcclxuXHRcdFx0d3JhcDogWyB0aGlzLndyYXBTLCB0aGlzLndyYXBUIF0sXHJcblxyXG5cdFx0XHRtaW5GaWx0ZXI6IHRoaXMubWluRmlsdGVyLFxyXG5cdFx0XHRtYWdGaWx0ZXI6IHRoaXMubWFnRmlsdGVyLFxyXG5cdFx0XHRhbmlzb3Ryb3B5OiB0aGlzLmFuaXNvdHJvcHlcclxuXHRcdH07XHJcblxyXG5cdFx0aWYgKCB0aGlzLmltYWdlICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHQvLyBUT0RPOiBNb3ZlIHRvIFRIUkVFLkltYWdlXHJcblxyXG5cdFx0XHR2YXIgaW1hZ2UgPSB0aGlzLmltYWdlO1xyXG5cclxuXHRcdFx0aWYgKCBpbWFnZS51dWlkID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGltYWdlLnV1aWQgPSBUSFJFRS5NYXRoLmdlbmVyYXRlVVVJRCgpOyAvLyBVR0hcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggbWV0YS5pbWFnZXNbIGltYWdlLnV1aWQgXSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRtZXRhLmltYWdlc1sgaW1hZ2UudXVpZCBdID0ge1xyXG5cdFx0XHRcdFx0dXVpZDogaW1hZ2UudXVpZCxcclxuXHRcdFx0XHRcdHVybDogZ2V0RGF0YVVSTCggaW1hZ2UgKVxyXG5cdFx0XHRcdH07XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRvdXRwdXQuaW1hZ2UgPSBpbWFnZS51dWlkO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRtZXRhLnRleHR1cmVzWyB0aGlzLnV1aWQgXSA9IG91dHB1dDtcclxuXHJcblx0XHRyZXR1cm4gb3V0cHV0O1xyXG5cclxuXHR9LFxyXG5cclxuXHRkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdkaXNwb3NlJyB9ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHRyYW5zZm9ybVV2OiBmdW5jdGlvbiAoIHV2ICkge1xyXG5cclxuXHRcdGlmICggdGhpcy5tYXBwaW5nICE9PSBUSFJFRS5VVk1hcHBpbmcgKSAgcmV0dXJuO1xyXG5cclxuXHRcdHV2Lm11bHRpcGx5KCB0aGlzLnJlcGVhdCApO1xyXG5cdFx0dXYuYWRkKCB0aGlzLm9mZnNldCApO1xyXG5cclxuXHRcdGlmICggdXYueCA8IDAgfHwgdXYueCA+IDEgKSB7XHJcblxyXG5cdFx0XHRzd2l0Y2ggKCB0aGlzLndyYXBTICkge1xyXG5cclxuXHRcdFx0XHRjYXNlIFRIUkVFLlJlcGVhdFdyYXBwaW5nOlxyXG5cclxuXHRcdFx0XHRcdHV2LnggPSB1di54IC0gTWF0aC5mbG9vciggdXYueCApO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZzpcclxuXHJcblx0XHRcdFx0XHR1di54ID0gdXYueCA8IDAgPyAwIDogMTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlIFRIUkVFLk1pcnJvcmVkUmVwZWF0V3JhcHBpbmc6XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBNYXRoLmFicyggTWF0aC5mbG9vciggdXYueCApICUgMiApID09PSAxICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dXYueCA9IE1hdGguY2VpbCggdXYueCApIC0gdXYueDtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0dXYueCA9IHV2LnggLSBNYXRoLmZsb29yKCB1di54ICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdXYueSA8IDAgfHwgdXYueSA+IDEgKSB7XHJcblxyXG5cdFx0XHRzd2l0Y2ggKCB0aGlzLndyYXBUICkge1xyXG5cclxuXHRcdFx0XHRjYXNlIFRIUkVFLlJlcGVhdFdyYXBwaW5nOlxyXG5cclxuXHRcdFx0XHRcdHV2LnkgPSB1di55IC0gTWF0aC5mbG9vciggdXYueSApO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZzpcclxuXHJcblx0XHRcdFx0XHR1di55ID0gdXYueSA8IDAgPyAwIDogMTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlIFRIUkVFLk1pcnJvcmVkUmVwZWF0V3JhcHBpbmc6XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBNYXRoLmFicyggTWF0aC5mbG9vciggdXYueSApICUgMiApID09PSAxICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dXYueSA9IE1hdGguY2VpbCggdXYueSApIC0gdXYueTtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0dXYueSA9IHV2LnkgLSBNYXRoLmZsb29yKCB1di55ICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdGhpcy5mbGlwWSApIHtcclxuXHJcblx0XHRcdHV2LnkgPSAxIC0gdXYueTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmFwcGx5KCBUSFJFRS5UZXh0dXJlLnByb3RvdHlwZSApO1xyXG5cclxuVEhSRUUuVGV4dHVyZUlkQ291bnQgPSAwO1xyXG5cclxuLy8gRmlsZTpzcmMvdGV4dHVyZXMvQ2FudmFzVGV4dHVyZS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuQ2FudmFzVGV4dHVyZSA9IGZ1bmN0aW9uICggY2FudmFzLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHkgKSB7XHJcblxyXG5cdFRIUkVFLlRleHR1cmUuY2FsbCggdGhpcywgY2FudmFzLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHkgKTtcclxuXHJcblx0dGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQ2FudmFzVGV4dHVyZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5UZXh0dXJlLnByb3RvdHlwZSApO1xyXG5USFJFRS5DYW52YXNUZXh0dXJlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkNhbnZhc1RleHR1cmU7XHJcblxyXG4vLyBGaWxlOnNyYy90ZXh0dXJlcy9DdWJlVGV4dHVyZS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuQ3ViZVRleHR1cmUgPSBmdW5jdGlvbiAoIGltYWdlcywgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5ICkge1xyXG5cclxuXHRtYXBwaW5nID0gbWFwcGluZyAhPT0gdW5kZWZpbmVkID8gbWFwcGluZyA6IFRIUkVFLkN1YmVSZWZsZWN0aW9uTWFwcGluZztcclxuXHJcblx0VEhSRUUuVGV4dHVyZS5jYWxsKCB0aGlzLCBpbWFnZXMsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSApO1xyXG5cclxuXHR0aGlzLmltYWdlcyA9IGltYWdlcztcclxuXHR0aGlzLmZsaXBZID0gZmFsc2U7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQ3ViZVRleHR1cmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuVGV4dHVyZS5wcm90b3R5cGUgKTtcclxuVEhSRUUuQ3ViZVRleHR1cmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQ3ViZVRleHR1cmU7XHJcblxyXG5USFJFRS5DdWJlVGV4dHVyZS5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuXHRUSFJFRS5UZXh0dXJlLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xyXG5cclxuXHR0aGlzLmltYWdlcyA9IHNvdXJjZS5pbWFnZXM7XHJcblxyXG5cdHJldHVybiB0aGlzO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL3RleHR1cmVzL0NvbXByZXNzZWRUZXh0dXJlLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5Db21wcmVzc2VkVGV4dHVyZSA9IGZ1bmN0aW9uICggbWlwbWFwcywgd2lkdGgsIGhlaWdodCwgZm9ybWF0LCB0eXBlLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBhbmlzb3Ryb3B5ICkge1xyXG5cclxuXHRUSFJFRS5UZXh0dXJlLmNhbGwoIHRoaXMsIG51bGwsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSApO1xyXG5cclxuXHR0aGlzLmltYWdlID0geyB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH07XHJcblx0dGhpcy5taXBtYXBzID0gbWlwbWFwcztcclxuXHJcblx0Ly8gbm8gZmxpcHBpbmcgZm9yIGN1YmUgdGV4dHVyZXNcclxuXHQvLyAoYWxzbyBmbGlwcGluZyBkb2Vzbid0IHdvcmsgZm9yIGNvbXByZXNzZWQgdGV4dHVyZXMgKVxyXG5cclxuXHR0aGlzLmZsaXBZID0gZmFsc2U7XHJcblxyXG5cdC8vIGNhbid0IGdlbmVyYXRlIG1pcG1hcHMgZm9yIGNvbXByZXNzZWQgdGV4dHVyZXNcclxuXHQvLyBtaXBzIG11c3QgYmUgZW1iZWRkZWQgaW4gRERTIGZpbGVzXHJcblxyXG5cdHRoaXMuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQ29tcHJlc3NlZFRleHR1cmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuVGV4dHVyZS5wcm90b3R5cGUgKTtcclxuVEhSRUUuQ29tcHJlc3NlZFRleHR1cmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQ29tcHJlc3NlZFRleHR1cmU7XHJcblxyXG4vLyBGaWxlOnNyYy90ZXh0dXJlcy9EYXRhVGV4dHVyZS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuRGF0YVRleHR1cmUgPSBmdW5jdGlvbiAoIGRhdGEsIHdpZHRoLCBoZWlnaHQsIGZvcm1hdCwgdHlwZSwgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgYW5pc290cm9weSApIHtcclxuXHJcblx0VEhSRUUuVGV4dHVyZS5jYWxsKCB0aGlzLCBudWxsLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHkgKTtcclxuXHJcblx0dGhpcy5pbWFnZSA9IHsgZGF0YTogZGF0YSwgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9O1xyXG5cclxuXHR0aGlzLm1hZ0ZpbHRlciA9IG1hZ0ZpbHRlciAhPT0gdW5kZWZpbmVkID8gbWFnRmlsdGVyIDogVEhSRUUuTmVhcmVzdEZpbHRlcjtcclxuXHR0aGlzLm1pbkZpbHRlciA9IG1pbkZpbHRlciAhPT0gdW5kZWZpbmVkID8gbWluRmlsdGVyIDogVEhSRUUuTmVhcmVzdEZpbHRlcjtcclxuXHRcclxuXHR0aGlzLmZsaXBZID0gZmFsc2U7XHJcblx0dGhpcy5nZW5lcmF0ZU1pcG1hcHMgID0gZmFsc2U7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuRGF0YVRleHR1cmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuVGV4dHVyZS5wcm90b3R5cGUgKTtcclxuVEhSRUUuRGF0YVRleHR1cmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuRGF0YVRleHR1cmU7XHJcblxyXG4vLyBGaWxlOnNyYy90ZXh0dXJlcy9WaWRlb1RleHR1cmUuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLlZpZGVvVGV4dHVyZSA9IGZ1bmN0aW9uICggdmlkZW8sIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSApIHtcclxuXHJcblx0VEhSRUUuVGV4dHVyZS5jYWxsKCB0aGlzLCB2aWRlbywgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5ICk7XHJcblxyXG5cdHRoaXMuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XHJcblxyXG5cdHZhciBzY29wZSA9IHRoaXM7XHJcblxyXG5cdGZ1bmN0aW9uIHVwZGF0ZSgpIHtcclxuXHJcblx0XHRyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIHVwZGF0ZSApO1xyXG5cclxuXHRcdGlmICggdmlkZW8ucmVhZHlTdGF0ZSA9PT0gdmlkZW8uSEFWRV9FTk9VR0hfREFUQSApIHtcclxuXHJcblx0XHRcdHNjb3BlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0dXBkYXRlKCk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuVmlkZW9UZXh0dXJlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLlRleHR1cmUucHJvdG90eXBlICk7XHJcblRIUkVFLlZpZGVvVGV4dHVyZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5WaWRlb1RleHR1cmU7XHJcblxyXG4vLyBGaWxlOnNyYy9vYmplY3RzL0dyb3VwLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5Hcm91cCA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0VEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLnR5cGUgPSAnR3JvdXAnO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkdyb3VwLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xyXG5USFJFRS5Hcm91cC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Hcm91cDtcclxuLy8gRmlsZTpzcmMvb2JqZWN0cy9Qb2ludHMuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLlBvaW50cyA9IGZ1bmN0aW9uICggZ2VvbWV0cnksIG1hdGVyaWFsICkge1xyXG5cclxuXHRUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMudHlwZSA9ICdQb2ludHMnO1xyXG5cclxuXHR0aGlzLmdlb21ldHJ5ID0gZ2VvbWV0cnkgIT09IHVuZGVmaW5lZCA/IGdlb21ldHJ5IDogbmV3IFRIUkVFLkdlb21ldHJ5KCk7XHJcblx0dGhpcy5tYXRlcmlhbCA9IG1hdGVyaWFsICE9PSB1bmRlZmluZWQgPyBtYXRlcmlhbCA6IG5ldyBUSFJFRS5Qb2ludHNNYXRlcmlhbCggeyBjb2xvcjogTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmIH0gKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Qb2ludHMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XHJcblRIUkVFLlBvaW50cy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Qb2ludHM7XHJcblxyXG5USFJFRS5Qb2ludHMucHJvdG90eXBlLnJheWNhc3QgPSAoIGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dmFyIGludmVyc2VNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xyXG5cdHZhciByYXkgPSBuZXcgVEhSRUUuUmF5KCk7XHJcblx0dmFyIHNwaGVyZSA9IG5ldyBUSFJFRS5TcGhlcmUoKTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uIHJheWNhc3QoIHJheWNhc3RlciwgaW50ZXJzZWN0cyApIHtcclxuXHJcblx0XHR2YXIgb2JqZWN0ID0gdGhpcztcclxuXHRcdHZhciBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XHJcblx0XHR2YXIgbWF0cml4V29ybGQgPSB0aGlzLm1hdHJpeFdvcmxkO1xyXG5cdFx0dmFyIHRocmVzaG9sZCA9IHJheWNhc3Rlci5wYXJhbXMuUG9pbnRzLnRocmVzaG9sZDtcclxuXHJcblx0XHQvLyBDaGVja2luZyBib3VuZGluZ1NwaGVyZSBkaXN0YW5jZSB0byByYXlcclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlID09PSBudWxsICkgZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XHJcblxyXG5cdFx0c3BoZXJlLmNvcHkoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlICk7XHJcblx0XHRzcGhlcmUuYXBwbHlNYXRyaXg0KCBtYXRyaXhXb3JsZCApO1xyXG5cclxuXHRcdGlmICggcmF5Y2FzdGVyLnJheS5pbnRlcnNlY3RzU3BoZXJlKCBzcGhlcmUgKSA9PT0gZmFsc2UgKSByZXR1cm47XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHRpbnZlcnNlTWF0cml4LmdldEludmVyc2UoIG1hdHJpeFdvcmxkICk7XHJcblx0XHRyYXkuY29weSggcmF5Y2FzdGVyLnJheSApLmFwcGx5TWF0cml4NCggaW52ZXJzZU1hdHJpeCApO1xyXG5cclxuXHRcdHZhciBsb2NhbFRocmVzaG9sZCA9IHRocmVzaG9sZCAvICggKCB0aGlzLnNjYWxlLnggKyB0aGlzLnNjYWxlLnkgKyB0aGlzLnNjYWxlLnogKSAvIDMgKTtcclxuXHRcdHZhciBsb2NhbFRocmVzaG9sZFNxID0gbG9jYWxUaHJlc2hvbGQgKiBsb2NhbFRocmVzaG9sZDtcclxuXHRcdHZhciBwb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0ZnVuY3Rpb24gdGVzdFBvaW50KCBwb2ludCwgaW5kZXggKSB7XHJcblxyXG5cdFx0XHR2YXIgcmF5UG9pbnREaXN0YW5jZVNxID0gcmF5LmRpc3RhbmNlU3FUb1BvaW50KCBwb2ludCApO1xyXG5cclxuXHRcdFx0aWYgKCByYXlQb2ludERpc3RhbmNlU3EgPCBsb2NhbFRocmVzaG9sZFNxICkge1xyXG5cclxuXHRcdFx0XHR2YXIgaW50ZXJzZWN0UG9pbnQgPSByYXkuY2xvc2VzdFBvaW50VG9Qb2ludCggcG9pbnQgKTtcclxuXHRcdFx0XHRpbnRlcnNlY3RQb2ludC5hcHBseU1hdHJpeDQoIG1hdHJpeFdvcmxkICk7XHJcblxyXG5cdFx0XHRcdHZhciBkaXN0YW5jZSA9IHJheWNhc3Rlci5yYXkub3JpZ2luLmRpc3RhbmNlVG8oIGludGVyc2VjdFBvaW50ICk7XHJcblxyXG5cdFx0XHRcdGlmICggZGlzdGFuY2UgPCByYXljYXN0ZXIubmVhciB8fCBkaXN0YW5jZSA+IHJheWNhc3Rlci5mYXIgKSByZXR1cm47XHJcblxyXG5cdFx0XHRcdGludGVyc2VjdHMucHVzaCgge1xyXG5cclxuXHRcdFx0XHRcdGRpc3RhbmNlOiBkaXN0YW5jZSxcclxuXHRcdFx0XHRcdGRpc3RhbmNlVG9SYXk6IE1hdGguc3FydCggcmF5UG9pbnREaXN0YW5jZVNxICksXHJcblx0XHRcdFx0XHRwb2ludDogaW50ZXJzZWN0UG9pbnQuY2xvbmUoKSxcclxuXHRcdFx0XHRcdGluZGV4OiBpbmRleCxcclxuXHRcdFx0XHRcdGZhY2U6IG51bGwsXHJcblx0XHRcdFx0XHRvYmplY3Q6IG9iamVjdFxyXG5cclxuXHRcdFx0XHR9ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSApIHtcclxuXHJcblx0XHRcdHZhciBpbmRleCA9IGdlb21ldHJ5LmluZGV4O1xyXG5cdFx0XHR2YXIgYXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XHJcblx0XHRcdHZhciBwb3NpdGlvbnMgPSBhdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xyXG5cclxuXHRcdFx0aWYgKCBpbmRleCAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0dmFyIGluZGljZXMgPSBpbmRleC5hcnJheTtcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IGluZGljZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIGEgPSBpbmRpY2VzWyBpIF07XHJcblxyXG5cdFx0XHRcdFx0cG9zaXRpb24uZnJvbUFycmF5KCBwb3NpdGlvbnMsIGEgKiAzICk7XHJcblxyXG5cdFx0XHRcdFx0dGVzdFBvaW50KCBwb3NpdGlvbiwgYSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBwb3NpdGlvbnMubGVuZ3RoIC8gMzsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0cG9zaXRpb24uZnJvbUFycmF5KCBwb3NpdGlvbnMsIGkgKiAzICk7XHJcblxyXG5cdFx0XHRcdFx0dGVzdFBvaW50KCBwb3NpdGlvbiwgaSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHZhciB2ZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gdmVydGljZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0dGVzdFBvaW50KCB2ZXJ0aWNlc1sgaSBdLCBpICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxufSgpICk7XHJcblxyXG5USFJFRS5Qb2ludHMucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMuZ2VvbWV0cnksIHRoaXMubWF0ZXJpYWwgKS5jb3B5KCB0aGlzICk7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvb2JqZWN0cy9MaW5lLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5MaW5lID0gZnVuY3Rpb24gKCBnZW9tZXRyeSwgbWF0ZXJpYWwsIG1vZGUgKSB7XHJcblxyXG5cdGlmICggbW9kZSA9PT0gMSApIHtcclxuXHJcblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5MaW5lOiBwYXJhbWV0ZXIgVEhSRUUuTGluZVBpZWNlcyBubyBsb25nZXIgc3VwcG9ydGVkLiBDcmVhdGVkIFRIUkVFLkxpbmVTZWdtZW50cyBpbnN0ZWFkLicgKTtcclxuXHRcdHJldHVybiBuZXcgVEhSRUUuTGluZVNlZ21lbnRzKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcclxuXHJcblx0fVxyXG5cclxuXHRUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMudHlwZSA9ICdMaW5lJztcclxuXHJcblx0dGhpcy5nZW9tZXRyeSA9IGdlb21ldHJ5ICE9PSB1bmRlZmluZWQgPyBnZW9tZXRyeSA6IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xyXG5cdHRoaXMubWF0ZXJpYWwgPSBtYXRlcmlhbCAhPT0gdW5kZWZpbmVkID8gbWF0ZXJpYWwgOiBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZiB9ICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTGluZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcclxuVEhSRUUuTGluZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5MaW5lO1xyXG5cclxuVEhSRUUuTGluZS5wcm90b3R5cGUucmF5Y2FzdCA9ICggZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgaW52ZXJzZU1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblx0dmFyIHJheSA9IG5ldyBUSFJFRS5SYXkoKTtcclxuXHR2YXIgc3BoZXJlID0gbmV3IFRIUkVFLlNwaGVyZSgpO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gcmF5Y2FzdCggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICkge1xyXG5cclxuXHRcdHZhciBwcmVjaXNpb24gPSByYXljYXN0ZXIubGluZVByZWNpc2lvbjtcclxuXHRcdHZhciBwcmVjaXNpb25TcSA9IHByZWNpc2lvbiAqIHByZWNpc2lvbjtcclxuXHJcblx0XHR2YXIgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xyXG5cdFx0dmFyIG1hdHJpeFdvcmxkID0gdGhpcy5tYXRyaXhXb3JsZDtcclxuXHJcblx0XHQvLyBDaGVja2luZyBib3VuZGluZ1NwaGVyZSBkaXN0YW5jZSB0byByYXlcclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlID09PSBudWxsICkgZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XHJcblxyXG5cdFx0c3BoZXJlLmNvcHkoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlICk7XHJcblx0XHRzcGhlcmUuYXBwbHlNYXRyaXg0KCBtYXRyaXhXb3JsZCApO1xyXG5cclxuXHRcdGlmICggcmF5Y2FzdGVyLnJheS5pbnRlcnNlY3RzU3BoZXJlKCBzcGhlcmUgKSA9PT0gZmFsc2UgKSByZXR1cm47XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHRpbnZlcnNlTWF0cml4LmdldEludmVyc2UoIG1hdHJpeFdvcmxkICk7XHJcblx0XHRyYXkuY29weSggcmF5Y2FzdGVyLnJheSApLmFwcGx5TWF0cml4NCggaW52ZXJzZU1hdHJpeCApO1xyXG5cclxuXHRcdHZhciB2U3RhcnQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0dmFyIHZFbmQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0dmFyIGludGVyU2VnbWVudCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHR2YXIgaW50ZXJSYXkgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0dmFyIHN0ZXAgPSB0aGlzIGluc3RhbmNlb2YgVEhSRUUuTGluZVNlZ21lbnRzID8gMiA6IDE7XHJcblxyXG5cdFx0aWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkJ1ZmZlckdlb21ldHJ5ICkge1xyXG5cclxuXHRcdFx0dmFyIGluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XHJcblx0XHRcdHZhciBhdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcclxuXHRcdFx0dmFyIHBvc2l0aW9ucyA9IGF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XHJcblxyXG5cdFx0XHRpZiAoIGluZGV4ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHR2YXIgaW5kaWNlcyA9IGluZGV4LmFycmF5O1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBpbmRpY2VzLmxlbmd0aCAtIDE7IGkgPCBsOyBpICs9IHN0ZXAgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIGEgPSBpbmRpY2VzWyBpIF07XHJcblx0XHRcdFx0XHR2YXIgYiA9IGluZGljZXNbIGkgKyAxIF07XHJcblxyXG5cdFx0XHRcdFx0dlN0YXJ0LmZyb21BcnJheSggcG9zaXRpb25zLCBhICogMyApO1xyXG5cdFx0XHRcdFx0dkVuZC5mcm9tQXJyYXkoIHBvc2l0aW9ucywgYiAqIDMgKTtcclxuXHJcblx0XHRcdFx0XHR2YXIgZGlzdFNxID0gcmF5LmRpc3RhbmNlU3FUb1NlZ21lbnQoIHZTdGFydCwgdkVuZCwgaW50ZXJSYXksIGludGVyU2VnbWVudCApO1xyXG5cclxuXHRcdFx0XHRcdGlmICggZGlzdFNxID4gcHJlY2lzaW9uU3EgKSBjb250aW51ZTtcclxuXHJcblx0XHRcdFx0XHRpbnRlclJheS5hcHBseU1hdHJpeDQoIHRoaXMubWF0cml4V29ybGQgKTsgLy9Nb3ZlIGJhY2sgdG8gd29ybGQgc3BhY2UgZm9yIGRpc3RhbmNlIGNhbGN1bGF0aW9uXHJcblxyXG5cdFx0XHRcdFx0dmFyIGRpc3RhbmNlID0gcmF5Y2FzdGVyLnJheS5vcmlnaW4uZGlzdGFuY2VUbyggaW50ZXJSYXkgKTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGRpc3RhbmNlIDwgcmF5Y2FzdGVyLm5lYXIgfHwgZGlzdGFuY2UgPiByYXljYXN0ZXIuZmFyICkgY29udGludWU7XHJcblxyXG5cdFx0XHRcdFx0aW50ZXJzZWN0cy5wdXNoKCB7XHJcblxyXG5cdFx0XHRcdFx0XHRkaXN0YW5jZTogZGlzdGFuY2UsXHJcblx0XHRcdFx0XHRcdC8vIFdoYXQgZG8gd2Ugd2FudD8gaW50ZXJzZWN0aW9uIHBvaW50IG9uIHRoZSByYXkgb3Igb24gdGhlIHNlZ21lbnQ/P1xyXG5cdFx0XHRcdFx0XHQvLyBwb2ludDogcmF5Y2FzdGVyLnJheS5hdCggZGlzdGFuY2UgKSxcclxuXHRcdFx0XHRcdFx0cG9pbnQ6IGludGVyU2VnbWVudC5jbG9uZSgpLmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApLFxyXG5cdFx0XHRcdFx0XHRpbmRleDogaSxcclxuXHRcdFx0XHRcdFx0ZmFjZTogbnVsbCxcclxuXHRcdFx0XHRcdFx0ZmFjZUluZGV4OiBudWxsLFxyXG5cdFx0XHRcdFx0XHRvYmplY3Q6IHRoaXNcclxuXHJcblx0XHRcdFx0XHR9ICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHBvc2l0aW9ucy5sZW5ndGggLyAzIC0gMTsgaSA8IGw7IGkgKz0gc3RlcCApIHtcclxuXHJcblx0XHRcdFx0XHR2U3RhcnQuZnJvbUFycmF5KCBwb3NpdGlvbnMsIDMgKiBpICk7XHJcblx0XHRcdFx0XHR2RW5kLmZyb21BcnJheSggcG9zaXRpb25zLCAzICogaSArIDMgKTtcclxuXHJcblx0XHRcdFx0XHR2YXIgZGlzdFNxID0gcmF5LmRpc3RhbmNlU3FUb1NlZ21lbnQoIHZTdGFydCwgdkVuZCwgaW50ZXJSYXksIGludGVyU2VnbWVudCApO1xyXG5cclxuXHRcdFx0XHRcdGlmICggZGlzdFNxID4gcHJlY2lzaW9uU3EgKSBjb250aW51ZTtcclxuXHJcblx0XHRcdFx0XHRpbnRlclJheS5hcHBseU1hdHJpeDQoIHRoaXMubWF0cml4V29ybGQgKTsgLy9Nb3ZlIGJhY2sgdG8gd29ybGQgc3BhY2UgZm9yIGRpc3RhbmNlIGNhbGN1bGF0aW9uXHJcblxyXG5cdFx0XHRcdFx0dmFyIGRpc3RhbmNlID0gcmF5Y2FzdGVyLnJheS5vcmlnaW4uZGlzdGFuY2VUbyggaW50ZXJSYXkgKTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGRpc3RhbmNlIDwgcmF5Y2FzdGVyLm5lYXIgfHwgZGlzdGFuY2UgPiByYXljYXN0ZXIuZmFyICkgY29udGludWU7XHJcblxyXG5cdFx0XHRcdFx0aW50ZXJzZWN0cy5wdXNoKCB7XHJcblxyXG5cdFx0XHRcdFx0XHRkaXN0YW5jZTogZGlzdGFuY2UsXHJcblx0XHRcdFx0XHRcdC8vIFdoYXQgZG8gd2Ugd2FudD8gaW50ZXJzZWN0aW9uIHBvaW50IG9uIHRoZSByYXkgb3Igb24gdGhlIHNlZ21lbnQ/P1xyXG5cdFx0XHRcdFx0XHQvLyBwb2ludDogcmF5Y2FzdGVyLnJheS5hdCggZGlzdGFuY2UgKSxcclxuXHRcdFx0XHRcdFx0cG9pbnQ6IGludGVyU2VnbWVudC5jbG9uZSgpLmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApLFxyXG5cdFx0XHRcdFx0XHRpbmRleDogaSxcclxuXHRcdFx0XHRcdFx0ZmFjZTogbnVsbCxcclxuXHRcdFx0XHRcdFx0ZmFjZUluZGV4OiBudWxsLFxyXG5cdFx0XHRcdFx0XHRvYmplY3Q6IHRoaXNcclxuXHJcblx0XHRcdFx0XHR9ICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2UgaWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkdlb21ldHJ5ICkge1xyXG5cclxuXHRcdFx0dmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXM7XHJcblx0XHRcdHZhciBuYlZlcnRpY2VzID0gdmVydGljZXMubGVuZ3RoO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbmJWZXJ0aWNlcyAtIDE7IGkgKz0gc3RlcCApIHtcclxuXHJcblx0XHRcdFx0dmFyIGRpc3RTcSA9IHJheS5kaXN0YW5jZVNxVG9TZWdtZW50KCB2ZXJ0aWNlc1sgaSBdLCB2ZXJ0aWNlc1sgaSArIDEgXSwgaW50ZXJSYXksIGludGVyU2VnbWVudCApO1xyXG5cclxuXHRcdFx0XHRpZiAoIGRpc3RTcSA+IHByZWNpc2lvblNxICkgY29udGludWU7XHJcblxyXG5cdFx0XHRcdGludGVyUmF5LmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApOyAvL01vdmUgYmFjayB0byB3b3JsZCBzcGFjZSBmb3IgZGlzdGFuY2UgY2FsY3VsYXRpb25cclxuXHJcblx0XHRcdFx0dmFyIGRpc3RhbmNlID0gcmF5Y2FzdGVyLnJheS5vcmlnaW4uZGlzdGFuY2VUbyggaW50ZXJSYXkgKTtcclxuXHJcblx0XHRcdFx0aWYgKCBkaXN0YW5jZSA8IHJheWNhc3Rlci5uZWFyIHx8IGRpc3RhbmNlID4gcmF5Y2FzdGVyLmZhciApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0XHRpbnRlcnNlY3RzLnB1c2goIHtcclxuXHJcblx0XHRcdFx0XHRkaXN0YW5jZTogZGlzdGFuY2UsXHJcblx0XHRcdFx0XHQvLyBXaGF0IGRvIHdlIHdhbnQ/IGludGVyc2VjdGlvbiBwb2ludCBvbiB0aGUgcmF5IG9yIG9uIHRoZSBzZWdtZW50Pz9cclxuXHRcdFx0XHRcdC8vIHBvaW50OiByYXljYXN0ZXIucmF5LmF0KCBkaXN0YW5jZSApLFxyXG5cdFx0XHRcdFx0cG9pbnQ6IGludGVyU2VnbWVudC5jbG9uZSgpLmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApLFxyXG5cdFx0XHRcdFx0aW5kZXg6IGksXHJcblx0XHRcdFx0XHRmYWNlOiBudWxsLFxyXG5cdFx0XHRcdFx0ZmFjZUluZGV4OiBudWxsLFxyXG5cdFx0XHRcdFx0b2JqZWN0OiB0aGlzXHJcblxyXG5cdFx0XHRcdH0gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG59KCkgKTtcclxuXHJcblRIUkVFLkxpbmUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMuZ2VvbWV0cnksIHRoaXMubWF0ZXJpYWwgKS5jb3B5KCB0aGlzICk7XHJcblxyXG59O1xyXG5cclxuLy8gREVQUkVDQVRFRFxyXG5cclxuVEhSRUUuTGluZVN0cmlwID0gMDtcclxuVEhSRUUuTGluZVBpZWNlcyA9IDE7XHJcblxyXG4vLyBGaWxlOnNyYy9vYmplY3RzL0xpbmVTZWdtZW50cy5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuTGluZVNlZ21lbnRzID0gZnVuY3Rpb24gKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKSB7XHJcblxyXG5cdFRIUkVFLkxpbmUuY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsICk7XHJcblxyXG5cdHRoaXMudHlwZSA9ICdMaW5lU2VnbWVudHMnO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkxpbmVTZWdtZW50cy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaW5lLnByb3RvdHlwZSApO1xyXG5USFJFRS5MaW5lU2VnbWVudHMucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuTGluZVNlZ21lbnRzO1xyXG5cclxuLy8gRmlsZTpzcmMvb2JqZWN0cy9NZXNoLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cclxuICogQGF1dGhvciBqb25vYnIxIC8gaHR0cDovL2pvbm9icjEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLk1lc2ggPSBmdW5jdGlvbiAoIGdlb21ldHJ5LCBtYXRlcmlhbCApIHtcclxuXHJcblx0VEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLnR5cGUgPSAnTWVzaCc7XHJcblxyXG5cdHRoaXMuZ2VvbWV0cnkgPSBnZW9tZXRyeSAhPT0gdW5kZWZpbmVkID8gZ2VvbWV0cnkgOiBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcclxuXHR0aGlzLm1hdGVyaWFsID0gbWF0ZXJpYWwgIT09IHVuZGVmaW5lZCA/IG1hdGVyaWFsIDogbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmYgfSApO1xyXG5cclxuXHR0aGlzLmRyYXdNb2RlID0gVEhSRUUuVHJpYW5nbGVzRHJhd01vZGU7XHJcblxyXG5cdHRoaXMudXBkYXRlTW9ycGhUYXJnZXRzKCk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTWVzaC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcclxuVEhSRUUuTWVzaC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5NZXNoO1xyXG5cclxuVEhSRUUuTWVzaC5wcm90b3R5cGUuc2V0RHJhd01vZGUgPSBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHR0aGlzLmRyYXdNb2RlID0gdmFsdWU7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTWVzaC5wcm90b3R5cGUudXBkYXRlTW9ycGhUYXJnZXRzID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRpZiAoIHRoaXMuZ2VvbWV0cnkubW9ycGhUYXJnZXRzICE9PSB1bmRlZmluZWQgJiYgdGhpcy5nZW9tZXRyeS5tb3JwaFRhcmdldHMubGVuZ3RoID4gMCApIHtcclxuXHJcblx0XHR0aGlzLm1vcnBoVGFyZ2V0QmFzZSA9IC0gMTtcclxuXHRcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzID0gW107XHJcblx0XHR0aGlzLm1vcnBoVGFyZ2V0RGljdGlvbmFyeSA9IHt9O1xyXG5cclxuXHRcdGZvciAoIHZhciBtID0gMCwgbWwgPSB0aGlzLmdlb21ldHJ5Lm1vcnBoVGFyZ2V0cy5sZW5ndGg7IG0gPCBtbDsgbSArKyApIHtcclxuXHJcblx0XHRcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzLnB1c2goIDAgKTtcclxuXHRcdFx0dGhpcy5tb3JwaFRhcmdldERpY3Rpb25hcnlbIHRoaXMuZ2VvbWV0cnkubW9ycGhUYXJnZXRzWyBtIF0ubmFtZSBdID0gbTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5NZXNoLnByb3RvdHlwZS5nZXRNb3JwaFRhcmdldEluZGV4QnlOYW1lID0gZnVuY3Rpb24gKCBuYW1lICkge1xyXG5cclxuXHRpZiAoIHRoaXMubW9ycGhUYXJnZXREaWN0aW9uYXJ5WyBuYW1lIF0gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5tb3JwaFRhcmdldERpY3Rpb25hcnlbIG5hbWUgXTtcclxuXHJcblx0fVxyXG5cclxuXHRjb25zb2xlLndhcm4oICdUSFJFRS5NZXNoLmdldE1vcnBoVGFyZ2V0SW5kZXhCeU5hbWU6IG1vcnBoIHRhcmdldCAnICsgbmFtZSArICcgZG9lcyBub3QgZXhpc3QuIFJldHVybmluZyAwLicgKTtcclxuXHJcblx0cmV0dXJuIDA7XHJcblxyXG59O1xyXG5cclxuXHJcblRIUkVFLk1lc2gucHJvdG90eXBlLnJheWNhc3QgPSAoIGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dmFyIGludmVyc2VNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xyXG5cdHZhciByYXkgPSBuZXcgVEhSRUUuUmF5KCk7XHJcblx0dmFyIHNwaGVyZSA9IG5ldyBUSFJFRS5TcGhlcmUoKTtcclxuXHJcblx0dmFyIHZBID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHR2YXIgdkIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdHZhciB2QyA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdHZhciB0ZW1wQSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0dmFyIHRlbXBCID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHR2YXIgdGVtcEMgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHR2YXIgdXZBID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcclxuXHR2YXIgdXZCID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcclxuXHR2YXIgdXZDID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcclxuXHJcblx0dmFyIGJhcnljb29yZCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdHZhciBpbnRlcnNlY3Rpb25Qb2ludCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0dmFyIGludGVyc2VjdGlvblBvaW50V29ybGQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRmdW5jdGlvbiB1dkludGVyc2VjdGlvbiggcG9pbnQsIHAxLCBwMiwgcDMsIHV2MSwgdXYyLCB1djMgKSB7XHJcblxyXG5cdFx0VEhSRUUuVHJpYW5nbGUuYmFyeWNvb3JkRnJvbVBvaW50KCBwb2ludCwgcDEsIHAyLCBwMywgYmFyeWNvb3JkICk7XHJcblxyXG5cdFx0dXYxLm11bHRpcGx5U2NhbGFyKCBiYXJ5Y29vcmQueCApO1xyXG5cdFx0dXYyLm11bHRpcGx5U2NhbGFyKCBiYXJ5Y29vcmQueSApO1xyXG5cdFx0dXYzLm11bHRpcGx5U2NhbGFyKCBiYXJ5Y29vcmQueiApO1xyXG5cclxuXHRcdHV2MS5hZGQoIHV2MiApLmFkZCggdXYzICk7XHJcblxyXG5cdFx0cmV0dXJuIHV2MS5jbG9uZSgpO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGNoZWNrSW50ZXJzZWN0aW9uKCBvYmplY3QsIHJheWNhc3RlciwgcmF5LCBwQSwgcEIsIHBDLCBwb2ludCApIHtcclxuXHJcblx0XHR2YXIgaW50ZXJzZWN0O1xyXG5cdFx0dmFyIG1hdGVyaWFsID0gb2JqZWN0Lm1hdGVyaWFsO1xyXG5cclxuXHRcdGlmICggbWF0ZXJpYWwuc2lkZSA9PT0gVEhSRUUuQmFja1NpZGUgKSB7XHJcblxyXG5cdFx0XHRpbnRlcnNlY3QgPSByYXkuaW50ZXJzZWN0VHJpYW5nbGUoIHBDLCBwQiwgcEEsIHRydWUsIHBvaW50ICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdGludGVyc2VjdCA9IHJheS5pbnRlcnNlY3RUcmlhbmdsZSggcEEsIHBCLCBwQywgbWF0ZXJpYWwuc2lkZSAhPT0gVEhSRUUuRG91YmxlU2lkZSwgcG9pbnQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBpbnRlcnNlY3QgPT09IG51bGwgKSByZXR1cm4gbnVsbDtcclxuXHJcblx0XHRpbnRlcnNlY3Rpb25Qb2ludFdvcmxkLmNvcHkoIHBvaW50ICk7XHJcblx0XHRpbnRlcnNlY3Rpb25Qb2ludFdvcmxkLmFwcGx5TWF0cml4NCggb2JqZWN0Lm1hdHJpeFdvcmxkICk7XHJcblxyXG5cdFx0dmFyIGRpc3RhbmNlID0gcmF5Y2FzdGVyLnJheS5vcmlnaW4uZGlzdGFuY2VUbyggaW50ZXJzZWN0aW9uUG9pbnRXb3JsZCApO1xyXG5cclxuXHRcdGlmICggZGlzdGFuY2UgPCByYXljYXN0ZXIubmVhciB8fCBkaXN0YW5jZSA+IHJheWNhc3Rlci5mYXIgKSByZXR1cm4gbnVsbDtcclxuXHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHRkaXN0YW5jZTogZGlzdGFuY2UsXHJcblx0XHRcdHBvaW50OiBpbnRlcnNlY3Rpb25Qb2ludFdvcmxkLmNsb25lKCksXHJcblx0XHRcdG9iamVjdDogb2JqZWN0XHJcblx0XHR9O1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGNoZWNrQnVmZmVyR2VvbWV0cnlJbnRlcnNlY3Rpb24oIG9iamVjdCwgcmF5Y2FzdGVyLCByYXksIHBvc2l0aW9ucywgdXZzLCBhLCBiLCBjICkge1xyXG5cclxuXHRcdHZBLmZyb21BcnJheSggcG9zaXRpb25zLCBhICogMyApO1xyXG5cdFx0dkIuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGIgKiAzICk7XHJcblx0XHR2Qy5mcm9tQXJyYXkoIHBvc2l0aW9ucywgYyAqIDMgKTtcclxuXHJcblx0XHR2YXIgaW50ZXJzZWN0aW9uID0gY2hlY2tJbnRlcnNlY3Rpb24oIG9iamVjdCwgcmF5Y2FzdGVyLCByYXksIHZBLCB2QiwgdkMsIGludGVyc2VjdGlvblBvaW50ICk7XHJcblxyXG5cdFx0aWYgKCBpbnRlcnNlY3Rpb24gKSB7XHJcblxyXG5cdFx0XHRpZiAoIHV2cyApIHtcclxuXHJcblx0XHRcdFx0dXZBLmZyb21BcnJheSggdXZzLCBhICogMiApO1xyXG5cdFx0XHRcdHV2Qi5mcm9tQXJyYXkoIHV2cywgYiAqIDIgKTtcclxuXHRcdFx0XHR1dkMuZnJvbUFycmF5KCB1dnMsIGMgKiAyICk7XHJcblxyXG5cdFx0XHRcdGludGVyc2VjdGlvbi51diA9IHV2SW50ZXJzZWN0aW9uKCBpbnRlcnNlY3Rpb25Qb2ludCwgIHZBLCB2QiwgdkMsICB1dkEsIHV2QiwgdXZDICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpbnRlcnNlY3Rpb24uZmFjZSA9IG5ldyBUSFJFRS5GYWNlMyggYSwgYiwgYywgVEhSRUUuVHJpYW5nbGUubm9ybWFsKCB2QSwgdkIsIHZDICkgKTtcclxuXHRcdFx0aW50ZXJzZWN0aW9uLmZhY2VJbmRleCA9IGE7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBpbnRlcnNlY3Rpb247XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uIHJheWNhc3QoIHJheWNhc3RlciwgaW50ZXJzZWN0cyApIHtcclxuXHJcblx0XHR2YXIgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xyXG5cdFx0dmFyIG1hdGVyaWFsID0gdGhpcy5tYXRlcmlhbDtcclxuXHRcdHZhciBtYXRyaXhXb3JsZCA9IHRoaXMubWF0cml4V29ybGQ7XHJcblxyXG5cdFx0aWYgKCBtYXRlcmlhbCA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xyXG5cclxuXHRcdC8vIENoZWNraW5nIGJvdW5kaW5nU3BoZXJlIGRpc3RhbmNlIHRvIHJheVxyXG5cclxuXHRcdGlmICggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgPT09IG51bGwgKSBnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcclxuXHJcblx0XHRzcGhlcmUuY29weSggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgKTtcclxuXHRcdHNwaGVyZS5hcHBseU1hdHJpeDQoIG1hdHJpeFdvcmxkICk7XHJcblxyXG5cdFx0aWYgKCByYXljYXN0ZXIucmF5LmludGVyc2VjdHNTcGhlcmUoIHNwaGVyZSApID09PSBmYWxzZSApIHJldHVybjtcclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdGludmVyc2VNYXRyaXguZ2V0SW52ZXJzZSggbWF0cml4V29ybGQgKTtcclxuXHRcdHJheS5jb3B5KCByYXljYXN0ZXIucmF5ICkuYXBwbHlNYXRyaXg0KCBpbnZlcnNlTWF0cml4ICk7XHJcblxyXG5cdFx0Ly8gQ2hlY2sgYm91bmRpbmdCb3ggYmVmb3JlIGNvbnRpbnVpbmdcclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nQm94ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0aWYgKCByYXkuaW50ZXJzZWN0c0JveCggZ2VvbWV0cnkuYm91bmRpbmdCb3ggKSA9PT0gZmFsc2UgKSByZXR1cm47XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciB1dnMsIGludGVyc2VjdGlvbjtcclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuQnVmZmVyR2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0XHR2YXIgYSwgYiwgYztcclxuXHRcdFx0dmFyIGluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XHJcblx0XHRcdHZhciBhdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcclxuXHRcdFx0dmFyIHBvc2l0aW9ucyA9IGF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XHJcblxyXG5cdFx0XHRpZiAoIGF0dHJpYnV0ZXMudXYgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0dXZzID0gYXR0cmlidXRlcy51di5hcnJheTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggaW5kZXggIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBpbmRpY2VzID0gaW5kZXguYXJyYXk7XHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGluZGljZXMubGVuZ3RoOyBpIDwgbDsgaSArPSAzICkge1xyXG5cclxuXHRcdFx0XHRcdGEgPSBpbmRpY2VzWyBpIF07XHJcblx0XHRcdFx0XHRiID0gaW5kaWNlc1sgaSArIDEgXTtcclxuXHRcdFx0XHRcdGMgPSBpbmRpY2VzWyBpICsgMiBdO1xyXG5cclxuXHRcdFx0XHRcdGludGVyc2VjdGlvbiA9IGNoZWNrQnVmZmVyR2VvbWV0cnlJbnRlcnNlY3Rpb24oIHRoaXMsIHJheWNhc3RlciwgcmF5LCBwb3NpdGlvbnMsIHV2cywgYSwgYiwgYyApO1xyXG5cclxuXHRcdFx0XHRcdGlmICggaW50ZXJzZWN0aW9uICkge1xyXG5cclxuXHRcdFx0XHRcdFx0aW50ZXJzZWN0aW9uLmZhY2VJbmRleCA9IE1hdGguZmxvb3IoIGkgLyAzICk7IC8vIHRyaWFuZ2xlIG51bWJlciBpbiBpbmRpY2VzIGJ1ZmZlciBzZW1hbnRpY3NcclxuXHRcdFx0XHRcdFx0aW50ZXJzZWN0cy5wdXNoKCBpbnRlcnNlY3Rpb24gKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBwb3NpdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSArPSA5ICkge1xyXG5cclxuXHRcdFx0XHRcdGEgPSBpIC8gMztcclxuXHRcdFx0XHRcdGIgPSBhICsgMTtcclxuXHRcdFx0XHRcdGMgPSBhICsgMjtcclxuXHJcblx0XHRcdFx0XHRpbnRlcnNlY3Rpb24gPSBjaGVja0J1ZmZlckdlb21ldHJ5SW50ZXJzZWN0aW9uKCB0aGlzLCByYXljYXN0ZXIsIHJheSwgcG9zaXRpb25zLCB1dnMsIGEsIGIsIGMgKTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGludGVyc2VjdGlvbiApIHtcclxuXHJcblx0XHRcdFx0XHRcdGludGVyc2VjdGlvbi5pbmRleCA9IGE7IC8vIHRyaWFuZ2xlIG51bWJlciBpbiBwb3NpdGlvbnMgYnVmZmVyIHNlbWFudGljc1xyXG5cdFx0XHRcdFx0XHRpbnRlcnNlY3RzLnB1c2goIGludGVyc2VjdGlvbiApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSBpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuR2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0XHR2YXIgZnZBLCBmdkIsIGZ2QztcclxuXHRcdFx0dmFyIGlzRmFjZU1hdGVyaWFsID0gbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NdWx0aU1hdGVyaWFsO1xyXG5cdFx0XHR2YXIgbWF0ZXJpYWxzID0gaXNGYWNlTWF0ZXJpYWwgPT09IHRydWUgPyBtYXRlcmlhbC5tYXRlcmlhbHMgOiBudWxsO1xyXG5cclxuXHRcdFx0dmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXM7XHJcblx0XHRcdHZhciBmYWNlcyA9IGdlb21ldHJ5LmZhY2VzO1xyXG5cdFx0XHR2YXIgZmFjZVZlcnRleFV2cyA9IGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIDAgXTtcclxuXHRcdFx0aWYgKCBmYWNlVmVydGV4VXZzLmxlbmd0aCA+IDAgKSB1dnMgPSBmYWNlVmVydGV4VXZzO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGYgPSAwLCBmbCA9IGZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgZmFjZSA9IGZhY2VzWyBmIF07XHJcblx0XHRcdFx0dmFyIGZhY2VNYXRlcmlhbCA9IGlzRmFjZU1hdGVyaWFsID09PSB0cnVlID8gbWF0ZXJpYWxzWyBmYWNlLm1hdGVyaWFsSW5kZXggXSA6IG1hdGVyaWFsO1xyXG5cclxuXHRcdFx0XHRpZiAoIGZhY2VNYXRlcmlhbCA9PT0gdW5kZWZpbmVkICkgY29udGludWU7XHJcblxyXG5cdFx0XHRcdGZ2QSA9IHZlcnRpY2VzWyBmYWNlLmEgXTtcclxuXHRcdFx0XHRmdkIgPSB2ZXJ0aWNlc1sgZmFjZS5iIF07XHJcblx0XHRcdFx0ZnZDID0gdmVydGljZXNbIGZhY2UuYyBdO1xyXG5cclxuXHRcdFx0XHRpZiAoIGZhY2VNYXRlcmlhbC5tb3JwaFRhcmdldHMgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIG1vcnBoVGFyZ2V0cyA9IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0cztcclxuXHRcdFx0XHRcdHZhciBtb3JwaEluZmx1ZW5jZXMgPSB0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcztcclxuXHJcblx0XHRcdFx0XHR2QS5zZXQoIDAsIDAsIDAgKTtcclxuXHRcdFx0XHRcdHZCLnNldCggMCwgMCwgMCApO1xyXG5cdFx0XHRcdFx0dkMuc2V0KCAwLCAwLCAwICk7XHJcblxyXG5cdFx0XHRcdFx0Zm9yICggdmFyIHQgPSAwLCB0bCA9IG1vcnBoVGFyZ2V0cy5sZW5ndGg7IHQgPCB0bDsgdCArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdHZhciBpbmZsdWVuY2UgPSBtb3JwaEluZmx1ZW5jZXNbIHQgXTtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggaW5mbHVlbmNlID09PSAwICkgY29udGludWU7XHJcblxyXG5cdFx0XHRcdFx0XHR2YXIgdGFyZ2V0cyA9IG1vcnBoVGFyZ2V0c1sgdCBdLnZlcnRpY2VzO1xyXG5cclxuXHRcdFx0XHRcdFx0dkEuYWRkU2NhbGVkVmVjdG9yKCB0ZW1wQS5zdWJWZWN0b3JzKCB0YXJnZXRzWyBmYWNlLmEgXSwgZnZBICksIGluZmx1ZW5jZSApO1xyXG5cdFx0XHRcdFx0XHR2Qi5hZGRTY2FsZWRWZWN0b3IoIHRlbXBCLnN1YlZlY3RvcnMoIHRhcmdldHNbIGZhY2UuYiBdLCBmdkIgKSwgaW5mbHVlbmNlICk7XHJcblx0XHRcdFx0XHRcdHZDLmFkZFNjYWxlZFZlY3RvciggdGVtcEMuc3ViVmVjdG9ycyggdGFyZ2V0c1sgZmFjZS5jIF0sIGZ2QyApLCBpbmZsdWVuY2UgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0dkEuYWRkKCBmdkEgKTtcclxuXHRcdFx0XHRcdHZCLmFkZCggZnZCICk7XHJcblx0XHRcdFx0XHR2Qy5hZGQoIGZ2QyApO1xyXG5cclxuXHRcdFx0XHRcdGZ2QSA9IHZBO1xyXG5cdFx0XHRcdFx0ZnZCID0gdkI7XHJcblx0XHRcdFx0XHRmdkMgPSB2QztcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpbnRlcnNlY3Rpb24gPSBjaGVja0ludGVyc2VjdGlvbiggdGhpcywgcmF5Y2FzdGVyLCByYXksIGZ2QSwgZnZCLCBmdkMsIGludGVyc2VjdGlvblBvaW50ICk7XHJcblxyXG5cdFx0XHRcdGlmICggaW50ZXJzZWN0aW9uICkge1xyXG5cclxuXHRcdFx0XHRcdGlmICggdXZzICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dmFyIHV2c19mID0gdXZzWyBmIF07XHJcblx0XHRcdFx0XHRcdHV2QS5jb3B5KCB1dnNfZlsgMCBdICk7XHJcblx0XHRcdFx0XHRcdHV2Qi5jb3B5KCB1dnNfZlsgMSBdICk7XHJcblx0XHRcdFx0XHRcdHV2Qy5jb3B5KCB1dnNfZlsgMiBdICk7XHJcblxyXG5cdFx0XHRcdFx0XHRpbnRlcnNlY3Rpb24udXYgPSB1dkludGVyc2VjdGlvbiggaW50ZXJzZWN0aW9uUG9pbnQsIGZ2QSwgZnZCLCBmdkMsIHV2QSwgdXZCLCB1dkMgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aW50ZXJzZWN0aW9uLmZhY2UgPSBmYWNlO1xyXG5cdFx0XHRcdFx0aW50ZXJzZWN0aW9uLmZhY2VJbmRleCA9IGY7XHJcblx0XHRcdFx0XHRpbnRlcnNlY3RzLnB1c2goIGludGVyc2VjdGlvbiApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxufSgpICk7XHJcblxyXG5USFJFRS5NZXNoLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLmdlb21ldHJ5LCB0aGlzLm1hdGVyaWFsICkuY29weSggdGhpcyApO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL29iamVjdHMvQm9uZS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqIEBhdXRob3IgaWtlcnIgLyBodHRwOi8vdmVyb2xkLmNvbVxyXG4gKi9cclxuXHJcblRIUkVFLkJvbmUgPSBmdW5jdGlvbiAoIHNraW4gKSB7XHJcblxyXG5cdFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy50eXBlID0gJ0JvbmUnO1xyXG5cclxuXHR0aGlzLnNraW4gPSBza2luO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkJvbmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XHJcblRIUkVFLkJvbmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQm9uZTtcclxuXHJcblRIUkVFLkJvbmUucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHRcclxuXHRUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcclxuXHRcclxuXHR0aGlzLnNraW4gPSBzb3VyY2Uuc2tpbjtcclxuXHRcclxuXHRyZXR1cm4gdGhpcztcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9vYmplY3RzL1NrZWxldG9uLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICogQGF1dGhvciBtaWNoYWVsIGd1ZXJyZXJvIC8gaHR0cDovL3JlYWxpdHltZWx0ZG93bi5jb21cclxuICogQGF1dGhvciBpa2VyciAvIGh0dHA6Ly92ZXJvbGQuY29tXHJcbiAqL1xyXG5cclxuVEhSRUUuU2tlbGV0b24gPSBmdW5jdGlvbiAoIGJvbmVzLCBib25lSW52ZXJzZXMsIHVzZVZlcnRleFRleHR1cmUgKSB7XHJcblxyXG5cdHRoaXMudXNlVmVydGV4VGV4dHVyZSA9IHVzZVZlcnRleFRleHR1cmUgIT09IHVuZGVmaW5lZCA/IHVzZVZlcnRleFRleHR1cmUgOiB0cnVlO1xyXG5cclxuXHR0aGlzLmlkZW50aXR5TWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHJcblx0Ly8gY29weSB0aGUgYm9uZSBhcnJheVxyXG5cclxuXHRib25lcyA9IGJvbmVzIHx8IFtdO1xyXG5cclxuXHR0aGlzLmJvbmVzID0gYm9uZXMuc2xpY2UoIDAgKTtcclxuXHJcblx0Ly8gY3JlYXRlIGEgYm9uZSB0ZXh0dXJlIG9yIGFuIGFycmF5IG9mIGZsb2F0c1xyXG5cclxuXHRpZiAoIHRoaXMudXNlVmVydGV4VGV4dHVyZSApIHtcclxuXHJcblx0XHQvLyBsYXlvdXQgKDEgbWF0cml4ID0gNCBwaXhlbHMpXHJcblx0XHQvLyAgICAgIFJHQkEgUkdCQSBSR0JBIFJHQkEgKD0+IGNvbHVtbjEsIGNvbHVtbjIsIGNvbHVtbjMsIGNvbHVtbjQpXHJcblx0XHQvLyAgd2l0aCAgOHg4ICBwaXhlbCB0ZXh0dXJlIG1heCAgIDE2IGJvbmVzICogNCBwaXhlbHMgPSAgKDggKiA4KVxyXG5cdFx0Ly8gICAgICAgMTZ4MTYgcGl4ZWwgdGV4dHVyZSBtYXggICA2NCBib25lcyAqIDQgcGl4ZWxzID0gKDE2ICogMTYpXHJcblx0XHQvLyAgICAgICAzMngzMiBwaXhlbCB0ZXh0dXJlIG1heCAgMjU2IGJvbmVzICogNCBwaXhlbHMgPSAoMzIgKiAzMilcclxuXHRcdC8vICAgICAgIDY0eDY0IHBpeGVsIHRleHR1cmUgbWF4IDEwMjQgYm9uZXMgKiA0IHBpeGVscyA9ICg2NCAqIDY0KVxyXG5cclxuXHRcdFxyXG5cdFx0dmFyIHNpemUgPSBNYXRoLnNxcnQoIHRoaXMuYm9uZXMubGVuZ3RoICogNCApOyAvLyA0IHBpeGVscyBuZWVkZWQgZm9yIDEgbWF0cml4XHJcblx0XHRzaXplID0gVEhSRUUuTWF0aC5uZXh0UG93ZXJPZlR3byggTWF0aC5jZWlsKCBzaXplICkgKTtcclxuXHRcdHNpemUgPSBNYXRoLm1heCggc2l6ZSwgNCApO1xyXG5cclxuXHRcdHRoaXMuYm9uZVRleHR1cmVXaWR0aCA9IHNpemU7XHJcblx0XHR0aGlzLmJvbmVUZXh0dXJlSGVpZ2h0ID0gc2l6ZTtcclxuXHJcblx0XHR0aGlzLmJvbmVNYXRyaWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIHRoaXMuYm9uZVRleHR1cmVXaWR0aCAqIHRoaXMuYm9uZVRleHR1cmVIZWlnaHQgKiA0ICk7IC8vIDQgZmxvYXRzIHBlciBSR0JBIHBpeGVsXHJcblx0XHR0aGlzLmJvbmVUZXh0dXJlID0gbmV3IFRIUkVFLkRhdGFUZXh0dXJlKCB0aGlzLmJvbmVNYXRyaWNlcywgdGhpcy5ib25lVGV4dHVyZVdpZHRoLCB0aGlzLmJvbmVUZXh0dXJlSGVpZ2h0LCBUSFJFRS5SR0JBRm9ybWF0LCBUSFJFRS5GbG9hdFR5cGUgKTtcclxuXHJcblx0fSBlbHNlIHtcclxuXHJcblx0XHR0aGlzLmJvbmVNYXRyaWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIDE2ICogdGhpcy5ib25lcy5sZW5ndGggKTtcclxuXHJcblx0fVxyXG5cclxuXHQvLyB1c2UgdGhlIHN1cHBsaWVkIGJvbmUgaW52ZXJzZXMgb3IgY2FsY3VsYXRlIHRoZSBpbnZlcnNlc1xyXG5cclxuXHRpZiAoIGJvbmVJbnZlcnNlcyA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdHRoaXMuY2FsY3VsYXRlSW52ZXJzZXMoKTtcclxuXHJcblx0fSBlbHNlIHtcclxuXHJcblx0XHRpZiAoIHRoaXMuYm9uZXMubGVuZ3RoID09PSBib25lSW52ZXJzZXMubGVuZ3RoICkge1xyXG5cclxuXHRcdFx0dGhpcy5ib25lSW52ZXJzZXMgPSBib25lSW52ZXJzZXMuc2xpY2UoIDAgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuU2tlbGV0b24gYm9uSW52ZXJzZXMgaXMgdGhlIHdyb25nIGxlbmd0aC4nICk7XHJcblxyXG5cdFx0XHR0aGlzLmJvbmVJbnZlcnNlcyA9IFtdO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGIgPSAwLCBibCA9IHRoaXMuYm9uZXMubGVuZ3RoOyBiIDwgYmw7IGIgKysgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuYm9uZUludmVyc2VzLnB1c2goIG5ldyBUSFJFRS5NYXRyaXg0KCkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5Ta2VsZXRvbi5wcm90b3R5cGUuY2FsY3VsYXRlSW52ZXJzZXMgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHRoaXMuYm9uZUludmVyc2VzID0gW107XHJcblxyXG5cdGZvciAoIHZhciBiID0gMCwgYmwgPSB0aGlzLmJvbmVzLmxlbmd0aDsgYiA8IGJsOyBiICsrICkge1xyXG5cclxuXHRcdHZhciBpbnZlcnNlID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHJcblx0XHRpZiAoIHRoaXMuYm9uZXNbIGIgXSApIHtcclxuXHJcblx0XHRcdGludmVyc2UuZ2V0SW52ZXJzZSggdGhpcy5ib25lc1sgYiBdLm1hdHJpeFdvcmxkICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuYm9uZUludmVyc2VzLnB1c2goIGludmVyc2UgKTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcblRIUkVFLlNrZWxldG9uLnByb3RvdHlwZS5wb3NlID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgYm9uZTtcclxuXHJcblx0Ly8gcmVjb3ZlciB0aGUgYmluZC10aW1lIHdvcmxkIG1hdHJpY2VzXHJcblxyXG5cdGZvciAoIHZhciBiID0gMCwgYmwgPSB0aGlzLmJvbmVzLmxlbmd0aDsgYiA8IGJsOyBiICsrICkge1xyXG5cclxuXHRcdGJvbmUgPSB0aGlzLmJvbmVzWyBiIF07XHJcblxyXG5cdFx0aWYgKCBib25lICkge1xyXG5cclxuXHRcdFx0Ym9uZS5tYXRyaXhXb3JsZC5nZXRJbnZlcnNlKCB0aGlzLmJvbmVJbnZlcnNlc1sgYiBdICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdC8vIGNvbXB1dGUgdGhlIGxvY2FsIG1hdHJpY2VzLCBwb3NpdGlvbnMsIHJvdGF0aW9ucyBhbmQgc2NhbGVzXHJcblxyXG5cdGZvciAoIHZhciBiID0gMCwgYmwgPSB0aGlzLmJvbmVzLmxlbmd0aDsgYiA8IGJsOyBiICsrICkge1xyXG5cclxuXHRcdGJvbmUgPSB0aGlzLmJvbmVzWyBiIF07XHJcblxyXG5cdFx0aWYgKCBib25lICkge1xyXG5cclxuXHRcdFx0aWYgKCBib25lLnBhcmVudCApIHtcclxuXHJcblx0XHRcdFx0Ym9uZS5tYXRyaXguZ2V0SW52ZXJzZSggYm9uZS5wYXJlbnQubWF0cml4V29ybGQgKTtcclxuXHRcdFx0XHRib25lLm1hdHJpeC5tdWx0aXBseSggYm9uZS5tYXRyaXhXb3JsZCApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Ym9uZS5tYXRyaXguY29weSggYm9uZS5tYXRyaXhXb3JsZCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ym9uZS5tYXRyaXguZGVjb21wb3NlKCBib25lLnBvc2l0aW9uLCBib25lLnF1YXRlcm5pb24sIGJvbmUuc2NhbGUgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5Ta2VsZXRvbi5wcm90b3R5cGUudXBkYXRlID0gKCBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHZhciBvZmZzZXRNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlKCkge1xyXG5cclxuXHRcdC8vIGZsYXR0ZW4gYm9uZSBtYXRyaWNlcyB0byBhcnJheVxyXG5cclxuXHRcdGZvciAoIHZhciBiID0gMCwgYmwgPSB0aGlzLmJvbmVzLmxlbmd0aDsgYiA8IGJsOyBiICsrICkge1xyXG5cclxuXHRcdFx0Ly8gY29tcHV0ZSB0aGUgb2Zmc2V0IGJldHdlZW4gdGhlIGN1cnJlbnQgYW5kIHRoZSBvcmlnaW5hbCB0cmFuc2Zvcm1cclxuXHJcblx0XHRcdHZhciBtYXRyaXggPSB0aGlzLmJvbmVzWyBiIF0gPyB0aGlzLmJvbmVzWyBiIF0ubWF0cml4V29ybGQgOiB0aGlzLmlkZW50aXR5TWF0cml4O1xyXG5cclxuXHRcdFx0b2Zmc2V0TWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIG1hdHJpeCwgdGhpcy5ib25lSW52ZXJzZXNbIGIgXSApO1xyXG5cdFx0XHRvZmZzZXRNYXRyaXguZmxhdHRlblRvQXJyYXlPZmZzZXQoIHRoaXMuYm9uZU1hdHJpY2VzLCBiICogMTYgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0aGlzLnVzZVZlcnRleFRleHR1cmUgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmJvbmVUZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG59ICkoKTtcclxuXHJcblRIUkVFLlNrZWxldG9uLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0cmV0dXJuIG5ldyBUSFJFRS5Ta2VsZXRvbiggdGhpcy5ib25lcywgdGhpcy5ib25lSW52ZXJzZXMsIHRoaXMudXNlVmVydGV4VGV4dHVyZSApO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL29iamVjdHMvU2tpbm5lZE1lc2guanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKiBAYXV0aG9yIGlrZXJyIC8gaHR0cDovL3Zlcm9sZC5jb21cclxuICovXHJcblxyXG5USFJFRS5Ta2lubmVkTWVzaCA9IGZ1bmN0aW9uICggZ2VvbWV0cnksIG1hdGVyaWFsLCB1c2VWZXJ0ZXhUZXh0dXJlICkge1xyXG5cclxuXHRUSFJFRS5NZXNoLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xyXG5cclxuXHR0aGlzLnR5cGUgPSAnU2tpbm5lZE1lc2gnO1xyXG5cclxuXHR0aGlzLmJpbmRNb2RlID0gXCJhdHRhY2hlZFwiO1xyXG5cdHRoaXMuYmluZE1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblx0dGhpcy5iaW5kTWF0cml4SW52ZXJzZSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblxyXG5cdC8vIGluaXQgYm9uZXNcclxuXHJcblx0Ly8gVE9ETzogcmVtb3ZlIGJvbmUgY3JlYXRpb24gYXMgdGhlcmUgaXMgbm8gcmVhc29uIChvdGhlciB0aGFuXHJcblx0Ly8gY29udmVuaWVuY2UpIGZvciBUSFJFRS5Ta2lubmVkTWVzaCB0byBkbyB0aGlzLlxyXG5cclxuXHR2YXIgYm9uZXMgPSBbXTtcclxuXHJcblx0aWYgKCB0aGlzLmdlb21ldHJ5ICYmIHRoaXMuZ2VvbWV0cnkuYm9uZXMgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHR2YXIgYm9uZSwgZ2JvbmU7XHJcblxyXG5cdFx0Zm9yICggdmFyIGIgPSAwLCBibCA9IHRoaXMuZ2VvbWV0cnkuYm9uZXMubGVuZ3RoOyBiIDwgYmw7ICsrIGIgKSB7XHJcblxyXG5cdFx0XHRnYm9uZSA9IHRoaXMuZ2VvbWV0cnkuYm9uZXNbIGIgXTtcclxuXHJcblx0XHRcdGJvbmUgPSBuZXcgVEhSRUUuQm9uZSggdGhpcyApO1xyXG5cdFx0XHRib25lcy5wdXNoKCBib25lICk7XHJcblxyXG5cdFx0XHRib25lLm5hbWUgPSBnYm9uZS5uYW1lO1xyXG5cdFx0XHRib25lLnBvc2l0aW9uLmZyb21BcnJheSggZ2JvbmUucG9zICk7XHJcblx0XHRcdGJvbmUucXVhdGVybmlvbi5mcm9tQXJyYXkoIGdib25lLnJvdHEgKTtcclxuXHRcdFx0aWYgKCBnYm9uZS5zY2wgIT09IHVuZGVmaW5lZCApIGJvbmUuc2NhbGUuZnJvbUFycmF5KCBnYm9uZS5zY2wgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICggdmFyIGIgPSAwLCBibCA9IHRoaXMuZ2VvbWV0cnkuYm9uZXMubGVuZ3RoOyBiIDwgYmw7ICsrIGIgKSB7XHJcblxyXG5cdFx0XHRnYm9uZSA9IHRoaXMuZ2VvbWV0cnkuYm9uZXNbIGIgXTtcclxuXHJcblx0XHRcdGlmICggZ2JvbmUucGFyZW50ICE9PSAtIDEgJiYgZ2JvbmUucGFyZW50ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHRib25lc1sgZ2JvbmUucGFyZW50IF0uYWRkKCBib25lc1sgYiBdICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHR0aGlzLmFkZCggYm9uZXNbIGIgXSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHR0aGlzLm5vcm1hbGl6ZVNraW5XZWlnaHRzKCk7XHJcblxyXG5cdHRoaXMudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcclxuXHR0aGlzLmJpbmQoIG5ldyBUSFJFRS5Ta2VsZXRvbiggYm9uZXMsIHVuZGVmaW5lZCwgdXNlVmVydGV4VGV4dHVyZSApLCB0aGlzLm1hdHJpeFdvcmxkICk7XHJcblxyXG59O1xyXG5cclxuXHJcblRIUkVFLlNraW5uZWRNZXNoLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1lc2gucHJvdG90eXBlICk7XHJcblRIUkVFLlNraW5uZWRNZXNoLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlNraW5uZWRNZXNoO1xyXG5cclxuVEhSRUUuU2tpbm5lZE1lc2gucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiggc2tlbGV0b24sIGJpbmRNYXRyaXggKSB7XHJcblxyXG5cdHRoaXMuc2tlbGV0b24gPSBza2VsZXRvbjtcclxuXHJcblx0aWYgKCBiaW5kTWF0cml4ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0dGhpcy51cGRhdGVNYXRyaXhXb3JsZCggdHJ1ZSApO1xyXG5cclxuXHRcdHRoaXMuc2tlbGV0b24uY2FsY3VsYXRlSW52ZXJzZXMoKTtcclxuXHJcblx0XHRiaW5kTWF0cml4ID0gdGhpcy5tYXRyaXhXb3JsZDtcclxuXHJcblx0fVxyXG5cclxuXHR0aGlzLmJpbmRNYXRyaXguY29weSggYmluZE1hdHJpeCApO1xyXG5cdHRoaXMuYmluZE1hdHJpeEludmVyc2UuZ2V0SW52ZXJzZSggYmluZE1hdHJpeCApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlNraW5uZWRNZXNoLnByb3RvdHlwZS5wb3NlID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR0aGlzLnNrZWxldG9uLnBvc2UoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Ta2lubmVkTWVzaC5wcm90b3R5cGUubm9ybWFsaXplU2tpbldlaWdodHMgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdGlmICggdGhpcy5nZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkdlb21ldHJ5ICkge1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMuZ2VvbWV0cnkuc2tpbldlaWdodHMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIHN3ID0gdGhpcy5nZW9tZXRyeS5za2luV2VpZ2h0c1sgaSBdO1xyXG5cclxuXHRcdFx0dmFyIHNjYWxlID0gMS4wIC8gc3cubGVuZ3RoTWFuaGF0dGFuKCk7XHJcblxyXG5cdFx0XHRpZiAoIHNjYWxlICE9PSBJbmZpbml0eSApIHtcclxuXHJcblx0XHRcdFx0c3cubXVsdGlwbHlTY2FsYXIoIHNjYWxlICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRzdy5zZXQoIDEsIDAsIDAsIDAgKTsgLy8gZG8gc29tZXRoaW5nIHJlYXNvbmFibGVcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH0gZWxzZSBpZiAoIHRoaXMuZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSApIHtcclxuXHJcblx0XHR2YXIgdmVjID0gbmV3IFRIUkVFLlZlY3RvcjQoKTtcclxuXHJcblx0XHR2YXIgc2tpbldlaWdodCA9IHRoaXMuZ2VvbWV0cnkuYXR0cmlidXRlcy5za2luV2VpZ2h0O1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHNraW5XZWlnaHQuY291bnQ7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2ZWMueCA9IHNraW5XZWlnaHQuZ2V0WCggaSApO1xyXG5cdFx0XHR2ZWMueSA9IHNraW5XZWlnaHQuZ2V0WSggaSApO1xyXG5cdFx0XHR2ZWMueiA9IHNraW5XZWlnaHQuZ2V0WiggaSApO1xyXG5cdFx0XHR2ZWMudyA9IHNraW5XZWlnaHQuZ2V0VyggaSApO1xyXG5cclxuXHRcdFx0dmFyIHNjYWxlID0gMS4wIC8gdmVjLmxlbmd0aE1hbmhhdHRhbigpO1xyXG5cclxuXHRcdFx0aWYgKCBzY2FsZSAhPT0gSW5maW5pdHkgKSB7XHJcblxyXG5cdFx0XHRcdHZlYy5tdWx0aXBseVNjYWxhciggc2NhbGUgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHZlYy5zZXQoIDEsIDAsIDAsIDAgKTsgLy8gZG8gc29tZXRoaW5nIHJlYXNvbmFibGVcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHNraW5XZWlnaHQuc2V0WFlaVyggaSwgdmVjLngsIHZlYy55LCB2ZWMueiwgdmVjLncgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5Ta2lubmVkTWVzaC5wcm90b3R5cGUudXBkYXRlTWF0cml4V29ybGQgPSBmdW5jdGlvbiggZm9yY2UgKSB7XHJcblxyXG5cdFRIUkVFLk1lc2gucHJvdG90eXBlLnVwZGF0ZU1hdHJpeFdvcmxkLmNhbGwoIHRoaXMsIHRydWUgKTtcclxuXHJcblx0aWYgKCB0aGlzLmJpbmRNb2RlID09PSBcImF0dGFjaGVkXCIgKSB7XHJcblxyXG5cdFx0dGhpcy5iaW5kTWF0cml4SW52ZXJzZS5nZXRJbnZlcnNlKCB0aGlzLm1hdHJpeFdvcmxkICk7XHJcblxyXG5cdH0gZWxzZSBpZiAoIHRoaXMuYmluZE1vZGUgPT09IFwiZGV0YWNoZWRcIiApIHtcclxuXHJcblx0XHR0aGlzLmJpbmRNYXRyaXhJbnZlcnNlLmdldEludmVyc2UoIHRoaXMuYmluZE1hdHJpeCApO1xyXG5cclxuXHR9IGVsc2Uge1xyXG5cclxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlNraW5uZWRNZXNoIHVucmVjb2duaXplZCBiaW5kTW9kZTogJyArIHRoaXMuYmluZE1vZGUgKTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcblRIUkVFLlNraW5uZWRNZXNoLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xyXG5cclxuXHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMuZ2VvbWV0cnksIHRoaXMubWF0ZXJpYWwsIHRoaXMudXNlVmVydGV4VGV4dHVyZSApLmNvcHkoIHRoaXMgKTtcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9vYmplY3RzL0xPRC5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuTE9EID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMudHlwZSA9ICdMT0QnO1xyXG5cclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyggdGhpcywge1xyXG5cdFx0bGV2ZWxzOiB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdHZhbHVlOiBbXVxyXG5cdFx0fSxcclxuXHRcdG9iamVjdHM6IHtcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkxPRDogLm9iamVjdHMgaGFzIGJlZW4gcmVuYW1lZCB0byAubGV2ZWxzLicgKTtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5sZXZlbHM7XHJcblxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSApO1xyXG5cclxufTtcclxuXHJcblxyXG5USFJFRS5MT0QucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XHJcblRIUkVFLkxPRC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5MT0Q7XHJcblxyXG5USFJFRS5MT0QucHJvdG90eXBlLmFkZExldmVsID0gZnVuY3Rpb24gKCBvYmplY3QsIGRpc3RhbmNlICkge1xyXG5cclxuXHRpZiAoIGRpc3RhbmNlID09PSB1bmRlZmluZWQgKSBkaXN0YW5jZSA9IDA7XHJcblxyXG5cdGRpc3RhbmNlID0gTWF0aC5hYnMoIGRpc3RhbmNlICk7XHJcblxyXG5cdHZhciBsZXZlbHMgPSB0aGlzLmxldmVscztcclxuXHJcblx0Zm9yICggdmFyIGwgPSAwOyBsIDwgbGV2ZWxzLmxlbmd0aDsgbCArKyApIHtcclxuXHJcblx0XHRpZiAoIGRpc3RhbmNlIDwgbGV2ZWxzWyBsIF0uZGlzdGFuY2UgKSB7XHJcblxyXG5cdFx0XHRicmVhaztcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0bGV2ZWxzLnNwbGljZSggbCwgMCwgeyBkaXN0YW5jZTogZGlzdGFuY2UsIG9iamVjdDogb2JqZWN0IH0gKTtcclxuXHJcblx0dGhpcy5hZGQoIG9iamVjdCApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkxPRC5wcm90b3R5cGUuZ2V0T2JqZWN0Rm9yRGlzdGFuY2UgPSBmdW5jdGlvbiAoIGRpc3RhbmNlICkge1xyXG5cclxuXHR2YXIgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XHJcblxyXG5cdGZvciAoIHZhciBpID0gMSwgbCA9IGxldmVscy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdGlmICggZGlzdGFuY2UgPCBsZXZlbHNbIGkgXS5kaXN0YW5jZSApIHtcclxuXHJcblx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gbGV2ZWxzWyBpIC0gMSBdLm9iamVjdDtcclxuXHJcbn07XHJcblxyXG5USFJFRS5MT0QucHJvdG90eXBlLnJheWNhc3QgPSAoIGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dmFyIG1hdHJpeFBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uIHJheWNhc3QoIHJheWNhc3RlciwgaW50ZXJzZWN0cyApIHtcclxuXHJcblx0XHRtYXRyaXhQb3NpdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubWF0cml4V29ybGQgKTtcclxuXHJcblx0XHR2YXIgZGlzdGFuY2UgPSByYXljYXN0ZXIucmF5Lm9yaWdpbi5kaXN0YW5jZVRvKCBtYXRyaXhQb3NpdGlvbiApO1xyXG5cclxuXHRcdHRoaXMuZ2V0T2JqZWN0Rm9yRGlzdGFuY2UoIGRpc3RhbmNlICkucmF5Y2FzdCggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICk7XHJcblxyXG5cdH07XHJcblxyXG59KCkgKTtcclxuXHJcblRIUkVFLkxPRC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdHZhciB2MiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGUoIGNhbWVyYSApIHtcclxuXHJcblx0XHR2YXIgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XHJcblxyXG5cdFx0aWYgKCBsZXZlbHMubGVuZ3RoID4gMSApIHtcclxuXHJcblx0XHRcdHYxLnNldEZyb21NYXRyaXhQb3NpdGlvbiggY2FtZXJhLm1hdHJpeFdvcmxkICk7XHJcblx0XHRcdHYyLnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5tYXRyaXhXb3JsZCApO1xyXG5cclxuXHRcdFx0dmFyIGRpc3RhbmNlID0gdjEuZGlzdGFuY2VUbyggdjIgKTtcclxuXHJcblx0XHRcdGxldmVsc1sgMCBdLm9iamVjdC52aXNpYmxlID0gdHJ1ZTtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMSwgbCA9IGxldmVscy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIGRpc3RhbmNlID49IGxldmVsc1sgaSBdLmRpc3RhbmNlICkge1xyXG5cclxuXHRcdFx0XHRcdGxldmVsc1sgaSAtIDEgXS5vYmplY3QudmlzaWJsZSA9IGZhbHNlO1xyXG5cdFx0XHRcdFx0bGV2ZWxzWyBpIF0ub2JqZWN0LnZpc2libGUgPSB0cnVlO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRsZXZlbHNbIGkgXS5vYmplY3QudmlzaWJsZSA9IGZhbHNlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcbn0oKTtcclxuXHJcblRIUkVFLkxPRC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuXHRUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UsIGZhbHNlICk7XHJcblxyXG5cdHZhciBsZXZlbHMgPSBzb3VyY2UubGV2ZWxzO1xyXG5cclxuXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBsZXZlbHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHR2YXIgbGV2ZWwgPSBsZXZlbHNbIGkgXTtcclxuXHJcblx0XHR0aGlzLmFkZExldmVsKCBsZXZlbC5vYmplY3QuY2xvbmUoKSwgbGV2ZWwuZGlzdGFuY2UgKTtcclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gdGhpcztcclxuXHJcbn07XHJcblxyXG5USFJFRS5MT0QucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICggbWV0YSApIHtcclxuXHJcblx0dmFyIGRhdGEgPSBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMsIG1ldGEgKTtcclxuXHJcblx0ZGF0YS5vYmplY3QubGV2ZWxzID0gW107XHJcblxyXG5cdHZhciBsZXZlbHMgPSB0aGlzLmxldmVscztcclxuXHJcblx0Zm9yICggdmFyIGkgPSAwLCBsID0gbGV2ZWxzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0dmFyIGxldmVsID0gbGV2ZWxzWyBpIF07XHJcblxyXG5cdFx0ZGF0YS5vYmplY3QubGV2ZWxzLnB1c2goIHtcclxuXHRcdFx0b2JqZWN0OiBsZXZlbC5vYmplY3QudXVpZCxcclxuXHRcdFx0ZGlzdGFuY2U6IGxldmVsLmRpc3RhbmNlXHJcblx0XHR9ICk7XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIGRhdGE7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvb2JqZWN0cy9TcHJpdGUuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLlNwcml0ZSA9ICggZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgaW5kaWNlcyA9IG5ldyBVaW50MTZBcnJheSggWyAwLCAxLCAyLCAgMCwgMiwgMyBdICk7XHJcblx0dmFyIHZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheSggWyAtIDAuNSwgLSAwLjUsIDAsICAgMC41LCAtIDAuNSwgMCwgICAwLjUsIDAuNSwgMCwgICAtIDAuNSwgMC41LCAwIF0gKTtcclxuXHR2YXIgdXZzID0gbmV3IEZsb2F0MzJBcnJheSggWyAwLCAwLCAgIDEsIDAsICAgMSwgMSwgICAwLCAxIF0gKTtcclxuXHJcblx0dmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCk7XHJcblx0Z2VvbWV0cnkuc2V0SW5kZXgoIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIGluZGljZXMsIDEgKSApO1xyXG5cdGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xyXG5cdGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ3V2JywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uIFNwcml0ZSggbWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0VEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xyXG5cclxuXHRcdHRoaXMudHlwZSA9ICdTcHJpdGUnO1xyXG5cclxuXHRcdHRoaXMuZ2VvbWV0cnkgPSBnZW9tZXRyeTtcclxuXHRcdHRoaXMubWF0ZXJpYWwgPSAoIG1hdGVyaWFsICE9PSB1bmRlZmluZWQgKSA/IG1hdGVyaWFsIDogbmV3IFRIUkVFLlNwcml0ZU1hdGVyaWFsKCk7XHJcblxyXG5cdH07XHJcblxyXG59ICkoKTtcclxuXHJcblRIUkVFLlNwcml0ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcclxuVEhSRUUuU3ByaXRlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlNwcml0ZTtcclxuXHJcblRIUkVFLlNwcml0ZS5wcm90b3R5cGUucmF5Y2FzdCA9ICggZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgbWF0cml4UG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gcmF5Y2FzdCggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICkge1xyXG5cclxuXHRcdG1hdHJpeFBvc2l0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5tYXRyaXhXb3JsZCApO1xyXG5cclxuXHRcdHZhciBkaXN0YW5jZVNxID0gcmF5Y2FzdGVyLnJheS5kaXN0YW5jZVNxVG9Qb2ludCggbWF0cml4UG9zaXRpb24gKTtcclxuXHRcdHZhciBndWVzc1NpemVTcSA9IHRoaXMuc2NhbGUueCAqIHRoaXMuc2NhbGUueTtcclxuXHJcblx0XHRpZiAoIGRpc3RhbmNlU3EgPiBndWVzc1NpemVTcSApIHtcclxuXHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aW50ZXJzZWN0cy5wdXNoKCB7XHJcblxyXG5cdFx0XHRkaXN0YW5jZTogTWF0aC5zcXJ0KCBkaXN0YW5jZVNxICksXHJcblx0XHRcdHBvaW50OiB0aGlzLnBvc2l0aW9uLFxyXG5cdFx0XHRmYWNlOiBudWxsLFxyXG5cdFx0XHRvYmplY3Q6IHRoaXNcclxuXHJcblx0XHR9ICk7XHJcblxyXG5cdH07XHJcblxyXG59KCkgKTtcclxuXHJcblRIUkVFLlNwcml0ZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5tYXRlcmlhbCApLmNvcHkoIHRoaXMgKTtcclxuXHJcbn07XHJcblxyXG4vLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxyXG5cclxuVEhSRUUuUGFydGljbGUgPSBUSFJFRS5TcHJpdGU7XHJcblxyXG4vLyBGaWxlOnNyYy9vYmplY3RzL0xlbnNGbGFyZS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuTGVuc0ZsYXJlID0gZnVuY3Rpb24gKCB0ZXh0dXJlLCBzaXplLCBkaXN0YW5jZSwgYmxlbmRpbmcsIGNvbG9yICkge1xyXG5cclxuXHRUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMubGVuc0ZsYXJlcyA9IFtdO1xyXG5cclxuXHR0aGlzLnBvc2l0aW9uU2NyZWVuID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHR0aGlzLmN1c3RvbVVwZGF0ZUNhbGxiYWNrID0gdW5kZWZpbmVkO1xyXG5cclxuXHRpZiAoIHRleHR1cmUgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHR0aGlzLmFkZCggdGV4dHVyZSwgc2l6ZSwgZGlzdGFuY2UsIGJsZW5kaW5nLCBjb2xvciApO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTGVuc0ZsYXJlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xyXG5USFJFRS5MZW5zRmxhcmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuTGVuc0ZsYXJlO1xyXG5cclxuXHJcbi8qXHJcbiAqIEFkZDogYWRkcyBhbm90aGVyIGZsYXJlXHJcbiAqL1xyXG5cclxuVEhSRUUuTGVuc0ZsYXJlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoIHRleHR1cmUsIHNpemUsIGRpc3RhbmNlLCBibGVuZGluZywgY29sb3IsIG9wYWNpdHkgKSB7XHJcblxyXG5cdGlmICggc2l6ZSA9PT0gdW5kZWZpbmVkICkgc2l6ZSA9IC0gMTtcclxuXHRpZiAoIGRpc3RhbmNlID09PSB1bmRlZmluZWQgKSBkaXN0YW5jZSA9IDA7XHJcblx0aWYgKCBvcGFjaXR5ID09PSB1bmRlZmluZWQgKSBvcGFjaXR5ID0gMTtcclxuXHRpZiAoIGNvbG9yID09PSB1bmRlZmluZWQgKSBjb2xvciA9IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKTtcclxuXHRpZiAoIGJsZW5kaW5nID09PSB1bmRlZmluZWQgKSBibGVuZGluZyA9IFRIUkVFLk5vcm1hbEJsZW5kaW5nO1xyXG5cclxuXHRkaXN0YW5jZSA9IE1hdGgubWluKCBkaXN0YW5jZSwgTWF0aC5tYXgoIDAsIGRpc3RhbmNlICkgKTtcclxuXHJcblx0dGhpcy5sZW5zRmxhcmVzLnB1c2goIHtcclxuXHRcdHRleHR1cmU6IHRleHR1cmUsXHQvLyBUSFJFRS5UZXh0dXJlXHJcblx0XHRzaXplOiBzaXplLCBcdFx0Ly8gc2l6ZSBpbiBwaXhlbHMgKC0xID0gdXNlIHRleHR1cmUud2lkdGgpXHJcblx0XHRkaXN0YW5jZTogZGlzdGFuY2UsIFx0Ly8gZGlzdGFuY2UgKDAtMSkgZnJvbSBsaWdodCBzb3VyY2UgKDA9YXQgbGlnaHQgc291cmNlKVxyXG5cdFx0eDogMCwgeTogMCwgejogMCxcdC8vIHNjcmVlbiBwb3NpdGlvbiAoLTEgPT4gMSkgeiA9IDAgaXMgaW4gZnJvbnQgeiA9IDEgaXMgYmFja1xyXG5cdFx0c2NhbGU6IDEsIFx0XHQvLyBzY2FsZVxyXG5cdFx0cm90YXRpb246IDAsIFx0XHQvLyByb3RhdGlvblxyXG5cdFx0b3BhY2l0eTogb3BhY2l0eSxcdC8vIG9wYWNpdHlcclxuXHRcdGNvbG9yOiBjb2xvcixcdFx0Ly8gY29sb3JcclxuXHRcdGJsZW5kaW5nOiBibGVuZGluZ1x0Ly8gYmxlbmRpbmdcclxuXHR9ICk7XHJcblxyXG59O1xyXG5cclxuLypcclxuICogVXBkYXRlIGxlbnMgZmxhcmVzIHVwZGF0ZSBwb3NpdGlvbnMgb24gYWxsIGZsYXJlcyBiYXNlZCBvbiB0aGUgc2NyZWVuIHBvc2l0aW9uXHJcbiAqIFNldCBteUxlbnNGbGFyZS5jdXN0b21VcGRhdGVDYWxsYmFjayB0byBhbHRlciB0aGUgZmxhcmVzIGluIHlvdXIgcHJvamVjdCBzcGVjaWZpYyB3YXkuXHJcbiAqL1xyXG5cclxuVEhSRUUuTGVuc0ZsYXJlLnByb3RvdHlwZS51cGRhdGVMZW5zRmxhcmVzID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgZiwgZmwgPSB0aGlzLmxlbnNGbGFyZXMubGVuZ3RoO1xyXG5cdHZhciBmbGFyZTtcclxuXHR2YXIgdmVjWCA9IC0gdGhpcy5wb3NpdGlvblNjcmVlbi54ICogMjtcclxuXHR2YXIgdmVjWSA9IC0gdGhpcy5wb3NpdGlvblNjcmVlbi55ICogMjtcclxuXHJcblx0Zm9yICggZiA9IDA7IGYgPCBmbDsgZiArKyApIHtcclxuXHJcblx0XHRmbGFyZSA9IHRoaXMubGVuc0ZsYXJlc1sgZiBdO1xyXG5cclxuXHRcdGZsYXJlLnggPSB0aGlzLnBvc2l0aW9uU2NyZWVuLnggKyB2ZWNYICogZmxhcmUuZGlzdGFuY2U7XHJcblx0XHRmbGFyZS55ID0gdGhpcy5wb3NpdGlvblNjcmVlbi55ICsgdmVjWSAqIGZsYXJlLmRpc3RhbmNlO1xyXG5cclxuXHRcdGZsYXJlLndhbnRlZFJvdGF0aW9uID0gZmxhcmUueCAqIE1hdGguUEkgKiAwLjI1O1xyXG5cdFx0ZmxhcmUucm90YXRpb24gKz0gKCBmbGFyZS53YW50ZWRSb3RhdGlvbiAtIGZsYXJlLnJvdGF0aW9uICkgKiAwLjI1O1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTGVuc0ZsYXJlLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG5cdFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xyXG5cclxuXHR0aGlzLnBvc2l0aW9uU2NyZWVuLmNvcHkoIHNvdXJjZS5wb3NpdGlvblNjcmVlbiApO1xyXG5cdHRoaXMuY3VzdG9tVXBkYXRlQ2FsbGJhY2sgPSBzb3VyY2UuY3VzdG9tVXBkYXRlQ2FsbGJhY2s7XHJcblxyXG5cdGZvciAoIHZhciBpID0gMCwgbCA9IHNvdXJjZS5sZW5zRmxhcmVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0dGhpcy5sZW5zRmxhcmVzLnB1c2goIHNvdXJjZS5sZW5zRmxhcmVzWyBpIF0gKTtcclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gdGhpcztcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9zY2VuZXMvU2NlbmUuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLlNjZW5lID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMudHlwZSA9ICdTY2VuZSc7XHJcblxyXG5cdHRoaXMuZm9nID0gbnVsbDtcclxuXHR0aGlzLm92ZXJyaWRlTWF0ZXJpYWwgPSBudWxsO1xyXG5cclxuXHR0aGlzLmF1dG9VcGRhdGUgPSB0cnVlOyAvLyBjaGVja2VkIGJ5IHRoZSByZW5kZXJlclxyXG5cclxufTtcclxuXHJcblRIUkVFLlNjZW5lLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xyXG5USFJFRS5TY2VuZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5TY2VuZTtcclxuXHJcblRIUkVFLlNjZW5lLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG5cdFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xyXG5cclxuXHRpZiAoIHNvdXJjZS5mb2cgIT09IG51bGwgKSB0aGlzLmZvZyA9IHNvdXJjZS5mb2cuY2xvbmUoKTtcclxuXHRpZiAoIHNvdXJjZS5vdmVycmlkZU1hdGVyaWFsICE9PSBudWxsICkgdGhpcy5vdmVycmlkZU1hdGVyaWFsID0gc291cmNlLm92ZXJyaWRlTWF0ZXJpYWwuY2xvbmUoKTtcclxuXHJcblx0dGhpcy5hdXRvVXBkYXRlID0gc291cmNlLmF1dG9VcGRhdGU7XHJcblx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gc291cmNlLm1hdHJpeEF1dG9VcGRhdGU7XHJcblxyXG5cdHJldHVybiB0aGlzO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL3NjZW5lcy9Gb2cuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkZvZyA9IGZ1bmN0aW9uICggY29sb3IsIG5lYXIsIGZhciApIHtcclxuXHJcblx0dGhpcy5uYW1lID0gJyc7XHJcblxyXG5cdHRoaXMuY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIGNvbG9yICk7XHJcblxyXG5cdHRoaXMubmVhciA9ICggbmVhciAhPT0gdW5kZWZpbmVkICkgPyBuZWFyIDogMTtcclxuXHR0aGlzLmZhciA9ICggZmFyICE9PSB1bmRlZmluZWQgKSA/IGZhciA6IDEwMDA7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuRm9nLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0cmV0dXJuIG5ldyBUSFJFRS5Gb2coIHRoaXMuY29sb3IuZ2V0SGV4KCksIHRoaXMubmVhciwgdGhpcy5mYXIgKTtcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9zY2VuZXMvRm9nRXhwMi5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuRm9nRXhwMiA9IGZ1bmN0aW9uICggY29sb3IsIGRlbnNpdHkgKSB7XHJcblxyXG5cdHRoaXMubmFtZSA9ICcnO1xyXG5cclxuXHR0aGlzLmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCBjb2xvciApO1xyXG5cdHRoaXMuZGVuc2l0eSA9ICggZGVuc2l0eSAhPT0gdW5kZWZpbmVkICkgPyBkZW5zaXR5IDogMC4wMDAyNTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Gb2dFeHAyLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0cmV0dXJuIG5ldyBUSFJFRS5Gb2dFeHAyKCB0aGlzLmNvbG9yLmdldEhleCgpLCB0aGlzLmRlbnNpdHkgKTtcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay5qc1xyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmsgPSB7fTtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2FscGhhbWFwX2ZyYWdtZW50Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnYWxwaGFtYXBfZnJhZ21lbnQnIF0gPSBcIiNpZmRlZiBVU0VfQUxQSEFNQVBcXG5cdGRpZmZ1c2VDb2xvci5hICo9IHRleHR1cmUyRCggYWxwaGFNYXAsIHZVdiApLmc7XFxuI2VuZGlmXFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9hbHBoYW1hcF9wYXJzX2ZyYWdtZW50Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnYWxwaGFtYXBfcGFyc19mcmFnbWVudCcgXSA9IFwiI2lmZGVmIFVTRV9BTFBIQU1BUFxcblx0dW5pZm9ybSBzYW1wbGVyMkQgYWxwaGFNYXA7XFxuI2VuZGlmXFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9hbHBoYXRlc3RfZnJhZ21lbnQuZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdhbHBoYXRlc3RfZnJhZ21lbnQnIF0gPSBcIiNpZmRlZiBBTFBIQVRFU1RcXG5cdGlmICggZGlmZnVzZUNvbG9yLmEgPCBBTFBIQVRFU1QgKSBkaXNjYXJkO1xcbiNlbmRpZlxcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvYW1iaWVudF9wYXJzLmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnYW1iaWVudF9wYXJzJyBdID0gXCJ1bmlmb3JtIHZlYzMgYW1iaWVudExpZ2h0Q29sb3I7XFxudmVjMyBnZXRBbWJpZW50TGlnaHRJcnJhZGlhbmNlKCBjb25zdCBpbiB2ZWMzIGFtYmllbnRMaWdodENvbG9yICkge1xcblx0cmV0dXJuIFBJICogYW1iaWVudExpZ2h0Q29sb3I7XFxufVxcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvYW9tYXBfZnJhZ21lbnQuZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdhb21hcF9mcmFnbWVudCcgXSA9IFwiI2lmZGVmIFVTRV9BT01BUFxcblx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICo9ICggdGV4dHVyZTJEKCBhb01hcCwgdlV2MiApLnIgLSAxLjAgKSAqIGFvTWFwSW50ZW5zaXR5ICsgMS4wO1xcbiNlbmRpZlxcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvYW9tYXBfcGFyc19mcmFnbWVudC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ2FvbWFwX3BhcnNfZnJhZ21lbnQnIF0gPSBcIiNpZmRlZiBVU0VfQU9NQVBcXG5cdHVuaWZvcm0gc2FtcGxlcjJEIGFvTWFwO1xcblx0dW5pZm9ybSBmbG9hdCBhb01hcEludGVuc2l0eTtcXG4jZW5kaWZcIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2JlZ2luX3ZlcnRleC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ2JlZ2luX3ZlcnRleCcgXSA9IFwiXFxudmVjMyB0cmFuc2Zvcm1lZCA9IHZlYzMoIHBvc2l0aW9uICk7XFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9iZWdpbm5vcm1hbF92ZXJ0ZXguZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdiZWdpbm5vcm1hbF92ZXJ0ZXgnIF0gPSBcIlxcbnZlYzMgb2JqZWN0Tm9ybWFsID0gdmVjMyggbm9ybWFsICk7XFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9ic2Rmcy5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ2JzZGZzJyBdID0gXCJmbG9hdCBjYWxjTGlnaHRBdHRlbnVhdGlvbiggY29uc3QgaW4gZmxvYXQgbGlnaHREaXN0YW5jZSwgY29uc3QgaW4gZmxvYXQgY3V0b2ZmRGlzdGFuY2UsIGNvbnN0IGluIGZsb2F0IGRlY2F5RXhwb25lbnQgKSB7XFxuXHRpZiAoIGRlY2F5RXhwb25lbnQgPiAwLjAgKSB7XFxuXHQgIHJldHVybiBwb3coIHNhdHVyYXRlKCAtbGlnaHREaXN0YW5jZSAvIGN1dG9mZkRpc3RhbmNlICsgMS4wICksIGRlY2F5RXhwb25lbnQgKTtcXG5cdH1cXG5cdHJldHVybiAxLjA7XFxufVxcbnZlYzMgQlJERl9EaWZmdXNlX0xhbWJlcnQoIGNvbnN0IGluIHZlYzMgZGlmZnVzZUNvbG9yICkge1xcblx0cmV0dXJuIFJFQ0lQUk9DQUxfUEkgKiBkaWZmdXNlQ29sb3I7XFxufVxcbnZlYzMgRl9TY2hsaWNrKCBjb25zdCBpbiB2ZWMzIHNwZWN1bGFyQ29sb3IsIGNvbnN0IGluIGZsb2F0IGRvdExIICkge1xcblx0ZmxvYXQgZnJlc25lbCA9IGV4cDIoICggLTUuNTU0NzMgKiBkb3RMSCAtIDYuOTgzMTYgKSAqIGRvdExIICk7XFxuXHRyZXR1cm4gKCAxLjAgLSBzcGVjdWxhckNvbG9yICkgKiBmcmVzbmVsICsgc3BlY3VsYXJDb2xvcjtcXG59XFxuZmxvYXQgR19HR1hfU21pdGgoIGNvbnN0IGluIGZsb2F0IGFscGhhLCBjb25zdCBpbiBmbG9hdCBkb3ROTCwgY29uc3QgaW4gZmxvYXQgZG90TlYgKSB7XFxuXHRmbG9hdCBhMiA9IGFscGhhICogYWxwaGE7XFxuXHRmbG9hdCBnbCA9IGRvdE5MICsgcG93KCBhMiArICggMS4wIC0gYTIgKSAqIGRvdE5MICogZG90TkwsIDAuNSApO1xcblx0ZmxvYXQgZ3YgPSBkb3ROViArIHBvdyggYTIgKyAoIDEuMCAtIGEyICkgKiBkb3ROViAqIGRvdE5WLCAwLjUgKTtcXG5cdHJldHVybiAxLjAgLyAoIGdsICogZ3YgKTtcXG59XFxuZmxvYXQgRF9HR1goIGNvbnN0IGluIGZsb2F0IGFscGhhLCBjb25zdCBpbiBmbG9hdCBkb3ROSCApIHtcXG5cdGZsb2F0IGEyID0gYWxwaGEgKiBhbHBoYTtcXG5cdGZsb2F0IGRlbm9tID0gZG90TkggKiBkb3ROSCAqICggYTIgLSAxLjAgKSArIDEuMDtcXG5cdHJldHVybiBSRUNJUFJPQ0FMX1BJICogYTIgLyAoIGRlbm9tICogZGVub20gKTtcXG59XFxudmVjMyBCUkRGX1NwZWN1bGFyX0dHWCggY29uc3QgaW4gSW5jaWRlbnRMaWdodCBpbmNpZGVudExpZ2h0LCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBjb25zdCBpbiB2ZWMzIHNwZWN1bGFyQ29sb3IsIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcyApIHtcXG5cdGZsb2F0IGFscGhhID0gcm91Z2huZXNzICogcm91Z2huZXNzO1xcblx0dmVjMyBoYWxmRGlyID0gbm9ybWFsaXplKCBpbmNpZGVudExpZ2h0LmRpcmVjdGlvbiArIGdlb21ldHJ5LnZpZXdEaXIgKTtcXG5cdGZsb2F0IGRvdE5MID0gc2F0dXJhdGUoIGRvdCggZ2VvbWV0cnkubm9ybWFsLCBpbmNpZGVudExpZ2h0LmRpcmVjdGlvbiApICk7XFxuXHRmbG9hdCBkb3ROViA9IHNhdHVyYXRlKCBkb3QoIGdlb21ldHJ5Lm5vcm1hbCwgZ2VvbWV0cnkudmlld0RpciApICk7XFxuXHRmbG9hdCBkb3ROSCA9IHNhdHVyYXRlKCBkb3QoIGdlb21ldHJ5Lm5vcm1hbCwgaGFsZkRpciApICk7XFxuXHRmbG9hdCBkb3RMSCA9IHNhdHVyYXRlKCBkb3QoIGluY2lkZW50TGlnaHQuZGlyZWN0aW9uLCBoYWxmRGlyICkgKTtcXG5cdHZlYzMgRiA9IEZfU2NobGljayggc3BlY3VsYXJDb2xvciwgZG90TEggKTtcXG5cdGZsb2F0IEcgPSBHX0dHWF9TbWl0aCggYWxwaGEsIGRvdE5MLCBkb3ROViApO1xcblx0ZmxvYXQgRCA9IERfR0dYKCBhbHBoYSwgZG90TkggKTtcXG5cdHJldHVybiBGICogKCBHICogRCApO1xcbn1cXG52ZWMzIEJSREZfU3BlY3VsYXJfR0dYX0Vudmlyb25tZW50KCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBjb25zdCBpbiB2ZWMzIHNwZWN1bGFyQ29sb3IsIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcyApIHtcXG5cdGZsb2F0IGRvdE5WID0gc2F0dXJhdGUoIGRvdCggZ2VvbWV0cnkubm9ybWFsLCBnZW9tZXRyeS52aWV3RGlyICkgKTtcXG5cdGNvbnN0IHZlYzQgYzAgPSB2ZWM0KCAtIDEsIC0gMC4wMjc1LCAtIDAuNTcyLCAwLjAyMiApO1xcblx0Y29uc3QgdmVjNCBjMSA9IHZlYzQoIDEsIDAuMDQyNSwgMS4wNCwgLSAwLjA0ICk7XFxuXHR2ZWM0IHIgPSByb3VnaG5lc3MgKiBjMCArIGMxO1xcblx0ZmxvYXQgYTAwNCA9IG1pbiggci54ICogci54LCBleHAyKCAtIDkuMjggKiBkb3ROViApICkgKiByLnggKyByLnk7XFxuXHR2ZWMyIEFCID0gdmVjMiggLTEuMDQsIDEuMDQgKSAqIGEwMDQgKyByLnp3O1xcblx0cmV0dXJuIHNwZWN1bGFyQ29sb3IgKiBBQi54ICsgQUIueTtcXG59XFxuZmxvYXQgR19CbGlublBob25nX0ltcGxpY2l0KCApIHtcXG5cdHJldHVybiAwLjI1O1xcbn1cXG5mbG9hdCBEX0JsaW5uUGhvbmcoIGNvbnN0IGluIGZsb2F0IHNoaW5pbmVzcywgY29uc3QgaW4gZmxvYXQgZG90TkggKSB7XFxuXHRyZXR1cm4gUkVDSVBST0NBTF9QSSAqICggc2hpbmluZXNzICogMC41ICsgMS4wICkgKiBwb3coIGRvdE5ILCBzaGluaW5lc3MgKTtcXG59XFxudmVjMyBCUkRGX1NwZWN1bGFyX0JsaW5uUGhvbmcoIGNvbnN0IGluIEluY2lkZW50TGlnaHQgaW5jaWRlbnRMaWdodCwgY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgY29uc3QgaW4gdmVjMyBzcGVjdWxhckNvbG9yLCBjb25zdCBpbiBmbG9hdCBzaGluaW5lc3MgKSB7XFxuXHR2ZWMzIGhhbGZEaXIgPSBub3JtYWxpemUoIGluY2lkZW50TGlnaHQuZGlyZWN0aW9uICsgZ2VvbWV0cnkudmlld0RpciApO1xcblx0ZmxvYXQgZG90TkggPSBzYXR1cmF0ZSggZG90KCBnZW9tZXRyeS5ub3JtYWwsIGhhbGZEaXIgKSApO1xcblx0ZmxvYXQgZG90TEggPSBzYXR1cmF0ZSggZG90KCBpbmNpZGVudExpZ2h0LmRpcmVjdGlvbiwgaGFsZkRpciApICk7XFxuXHR2ZWMzIEYgPSBGX1NjaGxpY2soIHNwZWN1bGFyQ29sb3IsIGRvdExIICk7XFxuXHRmbG9hdCBHID0gR19CbGlublBob25nX0ltcGxpY2l0KCApO1xcblx0ZmxvYXQgRCA9IERfQmxpbm5QaG9uZyggc2hpbmluZXNzLCBkb3ROSCApO1xcblx0cmV0dXJuIEYgKiAoIEcgKiBEICk7XFxufVxcbmZsb2F0IEdHWFJvdWdobmVzc1RvQmxpbm5FeHBvbmVudCggY29uc3QgaW4gZmxvYXQgZ2d4Um91Z2huZXNzICkge1xcblx0cmV0dXJuICggMi4wIC8gc3F1YXJlKCBnZ3hSb3VnaG5lc3MgKyAwLjAwMDEgKSAtIDIuMCApO1xcbn1cIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2J1bXBtYXBfcGFyc19mcmFnbWVudC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ2J1bXBtYXBfcGFyc19mcmFnbWVudCcgXSA9IFwiI2lmZGVmIFVTRV9CVU1QTUFQXFxuXHR1bmlmb3JtIHNhbXBsZXIyRCBidW1wTWFwO1xcblx0dW5pZm9ybSBmbG9hdCBidW1wU2NhbGU7XFxuXHR2ZWMyIGRIZHh5X2Z3ZCgpIHtcXG5cdFx0dmVjMiBkU1RkeCA9IGRGZHgoIHZVdiApO1xcblx0XHR2ZWMyIGRTVGR5ID0gZEZkeSggdlV2ICk7XFxuXHRcdGZsb2F0IEhsbCA9IGJ1bXBTY2FsZSAqIHRleHR1cmUyRCggYnVtcE1hcCwgdlV2ICkueDtcXG5cdFx0ZmxvYXQgZEJ4ID0gYnVtcFNjYWxlICogdGV4dHVyZTJEKCBidW1wTWFwLCB2VXYgKyBkU1RkeCApLnggLSBIbGw7XFxuXHRcdGZsb2F0IGRCeSA9IGJ1bXBTY2FsZSAqIHRleHR1cmUyRCggYnVtcE1hcCwgdlV2ICsgZFNUZHkgKS54IC0gSGxsO1xcblx0XHRyZXR1cm4gdmVjMiggZEJ4LCBkQnkgKTtcXG5cdH1cXG5cdHZlYzMgcGVydHVyYk5vcm1hbEFyYiggdmVjMyBzdXJmX3BvcywgdmVjMyBzdXJmX25vcm0sIHZlYzIgZEhkeHkgKSB7XFxuXHRcdHZlYzMgdlNpZ21hWCA9IGRGZHgoIHN1cmZfcG9zICk7XFxuXHRcdHZlYzMgdlNpZ21hWSA9IGRGZHkoIHN1cmZfcG9zICk7XFxuXHRcdHZlYzMgdk4gPSBzdXJmX25vcm07XFxuXHRcdHZlYzMgUjEgPSBjcm9zcyggdlNpZ21hWSwgdk4gKTtcXG5cdFx0dmVjMyBSMiA9IGNyb3NzKCB2TiwgdlNpZ21hWCApO1xcblx0XHRmbG9hdCBmRGV0ID0gZG90KCB2U2lnbWFYLCBSMSApO1xcblx0XHR2ZWMzIHZHcmFkID0gc2lnbiggZkRldCApICogKCBkSGR4eS54ICogUjEgKyBkSGR4eS55ICogUjIgKTtcXG5cdFx0cmV0dXJuIG5vcm1hbGl6ZSggYWJzKCBmRGV0ICkgKiBzdXJmX25vcm0gLSB2R3JhZCApO1xcblx0fVxcbiNlbmRpZlxcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvY29sb3JfZnJhZ21lbnQuZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdjb2xvcl9mcmFnbWVudCcgXSA9IFwiI2lmZGVmIFVTRV9DT0xPUlxcblx0ZGlmZnVzZUNvbG9yLnJnYiAqPSB2Q29sb3I7XFxuI2VuZGlmXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9jb2xvcl9wYXJzX2ZyYWdtZW50Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnY29sb3JfcGFyc19mcmFnbWVudCcgXSA9IFwiI2lmZGVmIFVTRV9DT0xPUlxcblx0dmFyeWluZyB2ZWMzIHZDb2xvcjtcXG4jZW5kaWZcXG5cIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2NvbG9yX3BhcnNfdmVydGV4Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnY29sb3JfcGFyc192ZXJ0ZXgnIF0gPSBcIiNpZmRlZiBVU0VfQ09MT1JcXG5cdHZhcnlpbmcgdmVjMyB2Q29sb3I7XFxuI2VuZGlmXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9jb2xvcl92ZXJ0ZXguZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdjb2xvcl92ZXJ0ZXgnIF0gPSBcIiNpZmRlZiBVU0VfQ09MT1JcXG5cdHZDb2xvci54eXogPSBjb2xvci54eXo7XFxuI2VuZGlmXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9jb21tb24uZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdjb21tb24nIF0gPSBcIiNkZWZpbmUgUEkgMy4xNDE1OVxcbiNkZWZpbmUgUEkyIDYuMjgzMThcXG4jZGVmaW5lIFJFQ0lQUk9DQUxfUEkgMC4zMTgzMDk4ODYxOFxcbiNkZWZpbmUgUkVDSVBST0NBTF9QSTIgMC4xNTkxNTQ5NFxcbiNkZWZpbmUgTE9HMiAxLjQ0MjY5NVxcbiNkZWZpbmUgRVBTSUxPTiAxZS02XFxuI2RlZmluZSBzYXR1cmF0ZShhKSBjbGFtcCggYSwgMC4wLCAxLjAgKVxcbiNkZWZpbmUgd2hpdGVDb21wbGltZW50KGEpICggMS4wIC0gc2F0dXJhdGUoIGEgKSApXFxuZmxvYXQgc3F1YXJlKCBjb25zdCBpbiBmbG9hdCB4ICkgeyByZXR1cm4geCp4OyB9XFxuZmxvYXQgYXZlcmFnZSggY29uc3QgaW4gdmVjMyBjb2xvciApIHsgcmV0dXJuIGRvdCggY29sb3IsIHZlYzMoIDAuMzMzMyApICk7IH1cXG5zdHJ1Y3QgSW5jaWRlbnRMaWdodCB7XFxuXHR2ZWMzIGNvbG9yO1xcblx0dmVjMyBkaXJlY3Rpb247XFxufTtcXG5zdHJ1Y3QgUmVmbGVjdGVkTGlnaHQge1xcblx0dmVjMyBkaXJlY3REaWZmdXNlO1xcblx0dmVjMyBkaXJlY3RTcGVjdWxhcjtcXG5cdHZlYzMgaW5kaXJlY3REaWZmdXNlO1xcblx0dmVjMyBpbmRpcmVjdFNwZWN1bGFyO1xcbn07XFxuc3RydWN0IEdlb21ldHJpY0NvbnRleHQge1xcblx0dmVjMyBwb3NpdGlvbjtcXG5cdHZlYzMgbm9ybWFsO1xcblx0dmVjMyB2aWV3RGlyO1xcbn07XFxudmVjMyB0cmFuc2Zvcm1EaXJlY3Rpb24oIGluIHZlYzMgZGlyLCBpbiBtYXQ0IG1hdHJpeCApIHtcXG5cdHJldHVybiBub3JtYWxpemUoICggbWF0cml4ICogdmVjNCggZGlyLCAwLjAgKSApLnh5eiApO1xcbn1cXG52ZWMzIGludmVyc2VUcmFuc2Zvcm1EaXJlY3Rpb24oIGluIHZlYzMgZGlyLCBpbiBtYXQ0IG1hdHJpeCApIHtcXG5cdHJldHVybiBub3JtYWxpemUoICggdmVjNCggZGlyLCAwLjAgKSAqIG1hdHJpeCApLnh5eiApO1xcbn1cXG52ZWMzIHByb2plY3RPblBsYW5lKGluIHZlYzMgcG9pbnQsIGluIHZlYzMgcG9pbnRPblBsYW5lLCBpbiB2ZWMzIHBsYW5lTm9ybWFsICkge1xcblx0ZmxvYXQgZGlzdGFuY2UgPSBkb3QoIHBsYW5lTm9ybWFsLCBwb2ludCAtIHBvaW50T25QbGFuZSApO1xcblx0cmV0dXJuIC0gZGlzdGFuY2UgKiBwbGFuZU5vcm1hbCArIHBvaW50O1xcbn1cXG5mbG9hdCBzaWRlT2ZQbGFuZSggaW4gdmVjMyBwb2ludCwgaW4gdmVjMyBwb2ludE9uUGxhbmUsIGluIHZlYzMgcGxhbmVOb3JtYWwgKSB7XFxuXHRyZXR1cm4gc2lnbiggZG90KCBwb2ludCAtIHBvaW50T25QbGFuZSwgcGxhbmVOb3JtYWwgKSApO1xcbn1cXG52ZWMzIGxpbmVQbGFuZUludGVyc2VjdCggaW4gdmVjMyBwb2ludE9uTGluZSwgaW4gdmVjMyBsaW5lRGlyZWN0aW9uLCBpbiB2ZWMzIHBvaW50T25QbGFuZSwgaW4gdmVjMyBwbGFuZU5vcm1hbCApIHtcXG5cdHJldHVybiBsaW5lRGlyZWN0aW9uICogKCBkb3QoIHBsYW5lTm9ybWFsLCBwb2ludE9uUGxhbmUgLSBwb2ludE9uTGluZSApIC8gZG90KCBwbGFuZU5vcm1hbCwgbGluZURpcmVjdGlvbiApICkgKyBwb2ludE9uTGluZTtcXG59XFxudmVjMyBpbnB1dFRvTGluZWFyKCBpbiB2ZWMzIGEgKSB7XFxuXHQjaWZkZWYgR0FNTUFfSU5QVVRcXG5cdFx0cmV0dXJuIHBvdyggYSwgdmVjMyggZmxvYXQoIEdBTU1BX0ZBQ1RPUiApICkgKTtcXG5cdCNlbHNlXFxuXHRcdHJldHVybiBhO1xcblx0I2VuZGlmXFxufVxcbnZlYzMgbGluZWFyVG9PdXRwdXQoIGluIHZlYzMgYSApIHtcXG5cdCNpZmRlZiBHQU1NQV9PVVRQVVRcXG5cdFx0cmV0dXJuIHBvdyggYSwgdmVjMyggMS4wIC8gZmxvYXQoIEdBTU1BX0ZBQ1RPUiApICkgKTtcXG5cdCNlbHNlXFxuXHRcdHJldHVybiBhO1xcblx0I2VuZGlmXFxufVxcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvZGVmYXVsdG5vcm1hbF92ZXJ0ZXguZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdkZWZhdWx0bm9ybWFsX3ZlcnRleCcgXSA9IFwiI2lmZGVmIEZMSVBfU0lERURcXG5cdG9iamVjdE5vcm1hbCA9IC1vYmplY3ROb3JtYWw7XFxuI2VuZGlmXFxudmVjMyB0cmFuc2Zvcm1lZE5vcm1hbCA9IG5vcm1hbE1hdHJpeCAqIG9iamVjdE5vcm1hbDtcXG5cIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2Rpc3BsYWNlbWVudG1hcF92ZXJ0ZXguZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdkaXNwbGFjZW1lbnRtYXBfdmVydGV4JyBdID0gXCIjaWZkZWYgVVNFX0RJU1BMQUNFTUVOVE1BUFxcblx0dHJhbnNmb3JtZWQgKz0gbm9ybWFsICogKCB0ZXh0dXJlMkQoIGRpc3BsYWNlbWVudE1hcCwgdXYgKS54ICogZGlzcGxhY2VtZW50U2NhbGUgKyBkaXNwbGFjZW1lbnRCaWFzICk7XFxuI2VuZGlmXFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9kaXNwbGFjZW1lbnRtYXBfcGFyc192ZXJ0ZXguZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdkaXNwbGFjZW1lbnRtYXBfcGFyc192ZXJ0ZXgnIF0gPSBcIiNpZmRlZiBVU0VfRElTUExBQ0VNRU5UTUFQXFxuXHR1bmlmb3JtIHNhbXBsZXIyRCBkaXNwbGFjZW1lbnRNYXA7XFxuXHR1bmlmb3JtIGZsb2F0IGRpc3BsYWNlbWVudFNjYWxlO1xcblx0dW5pZm9ybSBmbG9hdCBkaXNwbGFjZW1lbnRCaWFzO1xcbiNlbmRpZlxcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvZW1pc3NpdmVtYXBfZnJhZ21lbnQuZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdlbWlzc2l2ZW1hcF9mcmFnbWVudCcgXSA9IFwiI2lmZGVmIFVTRV9FTUlTU0lWRU1BUFxcblx0dmVjNCBlbWlzc2l2ZUNvbG9yID0gdGV4dHVyZTJEKCBlbWlzc2l2ZU1hcCwgdlV2ICk7XFxuXHRlbWlzc2l2ZUNvbG9yLnJnYiA9IGlucHV0VG9MaW5lYXIoIGVtaXNzaXZlQ29sb3IucmdiICk7XFxuXHR0b3RhbEVtaXNzaXZlTGlnaHQgKj0gZW1pc3NpdmVDb2xvci5yZ2I7XFxuI2VuZGlmXFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9lbWlzc2l2ZW1hcF9wYXJzX2ZyYWdtZW50Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnZW1pc3NpdmVtYXBfcGFyc19mcmFnbWVudCcgXSA9IFwiI2lmZGVmIFVTRV9FTUlTU0lWRU1BUFxcblx0dW5pZm9ybSBzYW1wbGVyMkQgZW1pc3NpdmVNYXA7XFxuI2VuZGlmXFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9lbnZtYXBfZnJhZ21lbnQuZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdlbnZtYXBfZnJhZ21lbnQnIF0gPSBcIiNpZmRlZiBVU0VfRU5WTUFQXFxuXHQjaWYgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQICkgfHwgZGVmaW5lZCggUEhPTkcgKVxcblx0XHR2ZWMzIGNhbWVyYVRvVmVydGV4ID0gbm9ybWFsaXplKCB2V29ybGRQb3NpdGlvbiAtIGNhbWVyYVBvc2l0aW9uICk7XFxuXHRcdHZlYzMgd29ybGROb3JtYWwgPSBpbnZlcnNlVHJhbnNmb3JtRGlyZWN0aW9uKCBub3JtYWwsIHZpZXdNYXRyaXggKTtcXG5cdFx0I2lmZGVmIEVOVk1BUF9NT0RFX1JFRkxFQ1RJT05cXG5cdFx0XHR2ZWMzIHJlZmxlY3RWZWMgPSByZWZsZWN0KCBjYW1lcmFUb1ZlcnRleCwgd29ybGROb3JtYWwgKTtcXG5cdFx0I2Vsc2VcXG5cdFx0XHR2ZWMzIHJlZmxlY3RWZWMgPSByZWZyYWN0KCBjYW1lcmFUb1ZlcnRleCwgd29ybGROb3JtYWwsIHJlZnJhY3Rpb25SYXRpbyApO1xcblx0XHQjZW5kaWZcXG5cdCNlbHNlXFxuXHRcdHZlYzMgcmVmbGVjdFZlYyA9IHZSZWZsZWN0O1xcblx0I2VuZGlmXFxuXHQjaWZkZWYgRE9VQkxFX1NJREVEXFxuXHRcdGZsb2F0IGZsaXBOb3JtYWwgPSAoIGZsb2F0KCBnbF9Gcm9udEZhY2luZyApICogMi4wIC0gMS4wICk7XFxuXHQjZWxzZVxcblx0XHRmbG9hdCBmbGlwTm9ybWFsID0gMS4wO1xcblx0I2VuZGlmXFxuXHQjaWZkZWYgRU5WTUFQX1RZUEVfQ1VCRVxcblx0XHR2ZWM0IGVudkNvbG9yID0gdGV4dHVyZUN1YmUoIGVudk1hcCwgZmxpcE5vcm1hbCAqIHZlYzMoIGZsaXBFbnZNYXAgKiByZWZsZWN0VmVjLngsIHJlZmxlY3RWZWMueXogKSApO1xcblx0I2VsaWYgZGVmaW5lZCggRU5WTUFQX1RZUEVfRVFVSVJFQyApXFxuXHRcdHZlYzIgc2FtcGxlVVY7XFxuXHRcdHNhbXBsZVVWLnkgPSBzYXR1cmF0ZSggZmxpcE5vcm1hbCAqIHJlZmxlY3RWZWMueSAqIDAuNSArIDAuNSApO1xcblx0XHRzYW1wbGVVVi54ID0gYXRhbiggZmxpcE5vcm1hbCAqIHJlZmxlY3RWZWMueiwgZmxpcE5vcm1hbCAqIHJlZmxlY3RWZWMueCApICogUkVDSVBST0NBTF9QSTIgKyAwLjU7XFxuXHRcdHZlYzQgZW52Q29sb3IgPSB0ZXh0dXJlMkQoIGVudk1hcCwgc2FtcGxlVVYgKTtcXG5cdCNlbGlmIGRlZmluZWQoIEVOVk1BUF9UWVBFX1NQSEVSRSApXFxuXHRcdHZlYzMgcmVmbGVjdFZpZXcgPSBmbGlwTm9ybWFsICogbm9ybWFsaXplKCh2aWV3TWF0cml4ICogdmVjNCggcmVmbGVjdFZlYywgMC4wICkpLnh5eiArIHZlYzMoMC4wLDAuMCwxLjApKTtcXG5cdFx0dmVjNCBlbnZDb2xvciA9IHRleHR1cmUyRCggZW52TWFwLCByZWZsZWN0Vmlldy54eSAqIDAuNSArIDAuNSApO1xcblx0I2VuZGlmXFxuXHRlbnZDb2xvci54eXogPSBpbnB1dFRvTGluZWFyKCBlbnZDb2xvci54eXogKTtcXG5cdCNpZmRlZiBFTlZNQVBfQkxFTkRJTkdfTVVMVElQTFlcXG5cdFx0b3V0Z29pbmdMaWdodCA9IG1peCggb3V0Z29pbmdMaWdodCwgb3V0Z29pbmdMaWdodCAqIGVudkNvbG9yLnh5eiwgc3BlY3VsYXJTdHJlbmd0aCAqIHJlZmxlY3Rpdml0eSApO1xcblx0I2VsaWYgZGVmaW5lZCggRU5WTUFQX0JMRU5ESU5HX01JWCApXFxuXHRcdG91dGdvaW5nTGlnaHQgPSBtaXgoIG91dGdvaW5nTGlnaHQsIGVudkNvbG9yLnh5eiwgc3BlY3VsYXJTdHJlbmd0aCAqIHJlZmxlY3Rpdml0eSApO1xcblx0I2VsaWYgZGVmaW5lZCggRU5WTUFQX0JMRU5ESU5HX0FERCApXFxuXHRcdG91dGdvaW5nTGlnaHQgKz0gZW52Q29sb3IueHl6ICogc3BlY3VsYXJTdHJlbmd0aCAqIHJlZmxlY3Rpdml0eTtcXG5cdCNlbmRpZlxcbiNlbmRpZlxcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvZW52bWFwX3BhcnNfZnJhZ21lbnQuZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdlbnZtYXBfcGFyc19mcmFnbWVudCcgXSA9IFwiI2lmIGRlZmluZWQoIFVTRV9FTlZNQVAgKSB8fCBkZWZpbmVkKCBTVEFOREFSRCApXFxuXHR1bmlmb3JtIGZsb2F0IHJlZmxlY3Rpdml0eTtcXG5cdHVuaWZvcm0gZmxvYXQgZW52TWFwSW50ZW5zdGl5O1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfRU5WTUFQXFxuXHQjaWZkZWYgRU5WTUFQX1RZUEVfQ1VCRVxcblx0XHR1bmlmb3JtIHNhbXBsZXJDdWJlIGVudk1hcDtcXG5cdCNlbHNlXFxuXHRcdHVuaWZvcm0gc2FtcGxlcjJEIGVudk1hcDtcXG5cdCNlbmRpZlxcblx0dW5pZm9ybSBmbG9hdCBmbGlwRW52TWFwO1xcblx0I2lmIGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApIHx8IGRlZmluZWQoIFBIT05HICkgfHwgZGVmaW5lZCggU1RBTkRBUkQgKVxcblx0XHR1bmlmb3JtIGZsb2F0IHJlZnJhY3Rpb25SYXRpbztcXG5cdCNlbHNlXFxuXHRcdHZhcnlpbmcgdmVjMyB2UmVmbGVjdDtcXG5cdCNlbmRpZlxcbiNlbmRpZlxcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvZW52bWFwX3BhcnNfdmVydGV4Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnZW52bWFwX3BhcnNfdmVydGV4JyBdID0gXCIjaWYgZGVmaW5lZCggVVNFX0VOVk1BUCApICYmICEgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSAmJiAhIGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKSAmJiAhIGRlZmluZWQoIFBIT05HICkgJiYgISBkZWZpbmVkKCBTVEFOREFSRCApXFxuXHR2YXJ5aW5nIHZlYzMgdlJlZmxlY3Q7XFxuXHR1bmlmb3JtIGZsb2F0IHJlZnJhY3Rpb25SYXRpbztcXG4jZW5kaWZcXG5cIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2Vudm1hcF92ZXJ0ZXguZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdlbnZtYXBfdmVydGV4JyBdID0gXCIjaWYgZGVmaW5lZCggVVNFX0VOVk1BUCApICYmICEgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSAmJiAhIGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKSAmJiAhIGRlZmluZWQoIFBIT05HICkgJiYgISBkZWZpbmVkKCBTVEFOREFSRCApXFxuXHR2ZWMzIGNhbWVyYVRvVmVydGV4ID0gbm9ybWFsaXplKCB3b3JsZFBvc2l0aW9uLnh5eiAtIGNhbWVyYVBvc2l0aW9uICk7XFxuXHR2ZWMzIHdvcmxkTm9ybWFsID0gaW52ZXJzZVRyYW5zZm9ybURpcmVjdGlvbiggdHJhbnNmb3JtZWROb3JtYWwsIHZpZXdNYXRyaXggKTtcXG5cdCNpZmRlZiBFTlZNQVBfTU9ERV9SRUZMRUNUSU9OXFxuXHRcdHZSZWZsZWN0ID0gcmVmbGVjdCggY2FtZXJhVG9WZXJ0ZXgsIHdvcmxkTm9ybWFsICk7XFxuXHQjZWxzZVxcblx0XHR2UmVmbGVjdCA9IHJlZnJhY3QoIGNhbWVyYVRvVmVydGV4LCB3b3JsZE5vcm1hbCwgcmVmcmFjdGlvblJhdGlvICk7XFxuXHQjZW5kaWZcXG4jZW5kaWZcXG5cIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2ZvZ19mcmFnbWVudC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ2ZvZ19mcmFnbWVudCcgXSA9IFwiI2lmZGVmIFVTRV9GT0dcXG5cdCNpZmRlZiBVU0VfTE9HREVQVEhCVUZfRVhUXFxuXHRcdGZsb2F0IGRlcHRoID0gZ2xfRnJhZ0RlcHRoRVhUIC8gZ2xfRnJhZ0Nvb3JkLnc7XFxuXHQjZWxzZVxcblx0XHRmbG9hdCBkZXB0aCA9IGdsX0ZyYWdDb29yZC56IC8gZ2xfRnJhZ0Nvb3JkLnc7XFxuXHQjZW5kaWZcXG5cdCNpZmRlZiBGT0dfRVhQMlxcblx0XHRmbG9hdCBmb2dGYWN0b3IgPSB3aGl0ZUNvbXBsaW1lbnQoIGV4cDIoIC0gZm9nRGVuc2l0eSAqIGZvZ0RlbnNpdHkgKiBkZXB0aCAqIGRlcHRoICogTE9HMiApICk7XFxuXHQjZWxzZVxcblx0XHRmbG9hdCBmb2dGYWN0b3IgPSBzbW9vdGhzdGVwKCBmb2dOZWFyLCBmb2dGYXIsIGRlcHRoICk7XFxuXHQjZW5kaWZcXG5cdFxcblx0b3V0Z29pbmdMaWdodCA9IG1peCggb3V0Z29pbmdMaWdodCwgZm9nQ29sb3IsIGZvZ0ZhY3RvciApO1xcbiNlbmRpZlwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvZm9nX3BhcnNfZnJhZ21lbnQuZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdmb2dfcGFyc19mcmFnbWVudCcgXSA9IFwiI2lmZGVmIFVTRV9GT0dcXG5cdHVuaWZvcm0gdmVjMyBmb2dDb2xvcjtcXG5cdCNpZmRlZiBGT0dfRVhQMlxcblx0XHR1bmlmb3JtIGZsb2F0IGZvZ0RlbnNpdHk7XFxuXHQjZWxzZVxcblx0XHR1bmlmb3JtIGZsb2F0IGZvZ05lYXI7XFxuXHRcdHVuaWZvcm0gZmxvYXQgZm9nRmFyO1xcblx0I2VuZGlmXFxuI2VuZGlmXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9saWdodG1hcF9mcmFnbWVudC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ2xpZ2h0bWFwX2ZyYWdtZW50JyBdID0gXCIjaWZkZWYgVVNFX0xJR0hUTUFQXFxuXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKz0gUEkgKiB0ZXh0dXJlMkQoIGxpZ2h0TWFwLCB2VXYyICkueHl6ICogbGlnaHRNYXBJbnRlbnNpdHk7XFxuI2VuZGlmXFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9saWdodG1hcF9wYXJzX2ZyYWdtZW50Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnbGlnaHRtYXBfcGFyc19mcmFnbWVudCcgXSA9IFwiI2lmZGVmIFVTRV9MSUdIVE1BUFxcblx0dW5pZm9ybSBzYW1wbGVyMkQgbGlnaHRNYXA7XFxuXHR1bmlmb3JtIGZsb2F0IGxpZ2h0TWFwSW50ZW5zaXR5O1xcbiNlbmRpZlwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbGlnaHRzX2xhbWJlcnRfdmVydGV4Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnbGlnaHRzX2xhbWJlcnRfdmVydGV4JyBdID0gXCJ2ZWMzIGRpZmZ1c2UgPSB2ZWMzKCAxLjAgKTtcXG5HZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5O1xcbmdlb21ldHJ5LnBvc2l0aW9uID0gbXZQb3NpdGlvbi54eXo7XFxuZ2VvbWV0cnkubm9ybWFsID0gbm9ybWFsaXplKCB0cmFuc2Zvcm1lZE5vcm1hbCApO1xcbmdlb21ldHJ5LnZpZXdEaXIgPSBub3JtYWxpemUoIC1tdlBvc2l0aW9uLnh5eiApO1xcbkdlb21ldHJpY0NvbnRleHQgYmFja0dlb21ldHJ5O1xcbmJhY2tHZW9tZXRyeS5wb3NpdGlvbiA9IGdlb21ldHJ5LnBvc2l0aW9uO1xcbmJhY2tHZW9tZXRyeS5ub3JtYWwgPSAtZ2VvbWV0cnkubm9ybWFsO1xcbmJhY2tHZW9tZXRyeS52aWV3RGlyID0gZ2VvbWV0cnkudmlld0RpcjtcXG52TGlnaHRGcm9udCA9IHZlYzMoIDAuMCApO1xcbiNpZmRlZiBET1VCTEVfU0lERURcXG5cdHZMaWdodEJhY2sgPSB2ZWMzKCAwLjAgKTtcXG4jZW5kaWZcXG5JbmNpZGVudExpZ2h0IGRpcmVjdExpZ2h0O1xcbmZsb2F0IGRvdE5MO1xcbnZlYzMgZGlyZWN0TGlnaHRDb2xvcl9EaWZmdXNlO1xcbiNpZiBOVU1fUE9JTlRfTElHSFRTID4gMFxcblx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX1BPSU5UX0xJR0hUUzsgaSArKyApIHtcXG5cdFx0ZGlyZWN0TGlnaHQgPSBnZXRQb2ludERpcmVjdExpZ2h0KCBwb2ludExpZ2h0c1sgaSBdLCBnZW9tZXRyeSApO1xcblx0XHRkb3ROTCA9IGRvdCggZ2VvbWV0cnkubm9ybWFsLCBkaXJlY3RMaWdodC5kaXJlY3Rpb24gKTtcXG5cdFx0ZGlyZWN0TGlnaHRDb2xvcl9EaWZmdXNlID0gUEkgKiBkaXJlY3RMaWdodC5jb2xvcjtcXG5cdFx0dkxpZ2h0RnJvbnQgKz0gc2F0dXJhdGUoIGRvdE5MICkgKiBkaXJlY3RMaWdodENvbG9yX0RpZmZ1c2U7XFxuXHRcdCNpZmRlZiBET1VCTEVfU0lERURcXG5cdFx0XHR2TGlnaHRCYWNrICs9IHNhdHVyYXRlKCAtZG90TkwgKSAqIGRpcmVjdExpZ2h0Q29sb3JfRGlmZnVzZTtcXG5cdFx0I2VuZGlmXFxuXHR9XFxuI2VuZGlmXFxuI2lmIE5VTV9TUE9UX0xJR0hUUyA+IDBcXG5cdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9TUE9UX0xJR0hUUzsgaSArKyApIHtcXG5cdFx0ZGlyZWN0TGlnaHQgPSBnZXRTcG90RGlyZWN0TGlnaHQoIHNwb3RMaWdodHNbIGkgXSwgZ2VvbWV0cnkgKTtcXG5cdFx0ZG90TkwgPSBkb3QoIGdlb21ldHJ5Lm5vcm1hbCwgZGlyZWN0TGlnaHQuZGlyZWN0aW9uICk7XFxuXHRcdGRpcmVjdExpZ2h0Q29sb3JfRGlmZnVzZSA9IFBJICogZGlyZWN0TGlnaHQuY29sb3I7XFxuXHRcdHZMaWdodEZyb250ICs9IHNhdHVyYXRlKCBkb3ROTCApICogZGlyZWN0TGlnaHRDb2xvcl9EaWZmdXNlO1xcblx0XHQjaWZkZWYgRE9VQkxFX1NJREVEXFxuXHRcdFx0dkxpZ2h0QmFjayArPSBzYXR1cmF0ZSggLWRvdE5MICkgKiBkaXJlY3RMaWdodENvbG9yX0RpZmZ1c2U7XFxuXHRcdCNlbmRpZlxcblx0fVxcbiNlbmRpZlxcbiNpZiBOVU1fRElSX0xJR0hUUyA+IDBcXG5cdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9ESVJfTElHSFRTOyBpICsrICkge1xcblx0XHRkaXJlY3RMaWdodCA9IGdldERpcmVjdGlvbmFsRGlyZWN0TGlnaHQoIGRpcmVjdGlvbmFsTGlnaHRzWyBpIF0sIGdlb21ldHJ5ICk7XFxuXHRcdGRvdE5MID0gZG90KCBnZW9tZXRyeS5ub3JtYWwsIGRpcmVjdExpZ2h0LmRpcmVjdGlvbiApO1xcblx0XHRkaXJlY3RMaWdodENvbG9yX0RpZmZ1c2UgPSBQSSAqIGRpcmVjdExpZ2h0LmNvbG9yO1xcblx0XHR2TGlnaHRGcm9udCArPSBzYXR1cmF0ZSggZG90TkwgKSAqIGRpcmVjdExpZ2h0Q29sb3JfRGlmZnVzZTtcXG5cdFx0I2lmZGVmIERPVUJMRV9TSURFRFxcblx0XHRcdHZMaWdodEJhY2sgKz0gc2F0dXJhdGUoIC1kb3ROTCApICogZGlyZWN0TGlnaHRDb2xvcl9EaWZmdXNlO1xcblx0XHQjZW5kaWZcXG5cdH1cXG4jZW5kaWZcXG4jaWYgTlVNX0hFTUlfTElHSFRTID4gMFxcblx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX0hFTUlfTElHSFRTOyBpICsrICkge1xcblx0XHR2TGlnaHRGcm9udCArPSBnZXRIZW1pc3BoZXJlTGlnaHRJcnJhZGlhbmNlKCBoZW1pc3BoZXJlTGlnaHRzWyBpIF0sIGdlb21ldHJ5ICk7XFxuXHRcdCNpZmRlZiBET1VCTEVfU0lERURcXG5cdFx0XHR2TGlnaHRCYWNrICs9IGdldEhlbWlzcGhlcmVMaWdodElycmFkaWFuY2UoIGhlbWlzcGhlcmVMaWdodHNbIGkgXSwgYmFja0dlb21ldHJ5ICk7XFxuXHRcdCNlbmRpZlxcblx0fVxcbiNlbmRpZlxcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbGlnaHRzX3BhcnMuZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdsaWdodHNfcGFycycgXSA9IFwiI2lmIE5VTV9ESVJfTElHSFRTID4gMFxcblx0c3RydWN0IERpcmVjdGlvbmFsTGlnaHQge1xcblx0XHR2ZWMzIGRpcmVjdGlvbjtcXG5cdFx0dmVjMyBjb2xvcjtcXG5cdFx0aW50IHNoYWRvdztcXG5cdFx0ZmxvYXQgc2hhZG93QmlhcztcXG5cdFx0ZmxvYXQgc2hhZG93UmFkaXVzO1xcblx0XHR2ZWMyIHNoYWRvd01hcFNpemU7XFxuXHR9O1xcblx0dW5pZm9ybSBEaXJlY3Rpb25hbExpZ2h0IGRpcmVjdGlvbmFsTGlnaHRzWyBOVU1fRElSX0xJR0hUUyBdO1xcblx0SW5jaWRlbnRMaWdodCBnZXREaXJlY3Rpb25hbERpcmVjdExpZ2h0KCBjb25zdCBpbiBEaXJlY3Rpb25hbExpZ2h0IGRpcmVjdGlvbmFsTGlnaHQsIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnkgKSB7XFxuXHRcdEluY2lkZW50TGlnaHQgZGlyZWN0TGlnaHQ7XFxuXHRcdGRpcmVjdExpZ2h0LmNvbG9yID0gZGlyZWN0aW9uYWxMaWdodC5jb2xvcjtcXG5cdFx0ZGlyZWN0TGlnaHQuZGlyZWN0aW9uID0gZGlyZWN0aW9uYWxMaWdodC5kaXJlY3Rpb247XFxuXHRcdHJldHVybiBkaXJlY3RMaWdodDtcXG5cdH1cXG4jZW5kaWZcXG4jaWYgTlVNX1BPSU5UX0xJR0hUUyA+IDBcXG5cdHN0cnVjdCBQb2ludExpZ2h0IHtcXG5cdFx0dmVjMyBwb3NpdGlvbjtcXG5cdFx0dmVjMyBjb2xvcjtcXG5cdFx0ZmxvYXQgZGlzdGFuY2U7XFxuXHRcdGZsb2F0IGRlY2F5O1xcblx0XHRpbnQgc2hhZG93O1xcblx0XHRmbG9hdCBzaGFkb3dCaWFzO1xcblx0XHRmbG9hdCBzaGFkb3dSYWRpdXM7XFxuXHRcdHZlYzIgc2hhZG93TWFwU2l6ZTtcXG5cdH07XFxuXHR1bmlmb3JtIFBvaW50TGlnaHQgcG9pbnRMaWdodHNbIE5VTV9QT0lOVF9MSUdIVFMgXTtcXG5cdEluY2lkZW50TGlnaHQgZ2V0UG9pbnREaXJlY3RMaWdodCggY29uc3QgaW4gUG9pbnRMaWdodCBwb2ludExpZ2h0LCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5ICkge1xcblx0XHRJbmNpZGVudExpZ2h0IGRpcmVjdExpZ2h0O1xcblx0XHR2ZWMzIGxWZWN0b3IgPSBwb2ludExpZ2h0LnBvc2l0aW9uIC0gZ2VvbWV0cnkucG9zaXRpb247XFxuXHRcdGRpcmVjdExpZ2h0LmRpcmVjdGlvbiA9IG5vcm1hbGl6ZSggbFZlY3RvciApO1xcblx0XHRkaXJlY3RMaWdodC5jb2xvciA9IHBvaW50TGlnaHQuY29sb3I7XFxuXHRcdGRpcmVjdExpZ2h0LmNvbG9yICo9IGNhbGNMaWdodEF0dGVudWF0aW9uKCBsZW5ndGgoIGxWZWN0b3IgKSwgcG9pbnRMaWdodC5kaXN0YW5jZSwgcG9pbnRMaWdodC5kZWNheSApO1xcblx0XHRyZXR1cm4gZGlyZWN0TGlnaHQ7XFxuXHR9XFxuI2VuZGlmXFxuI2lmIE5VTV9TUE9UX0xJR0hUUyA+IDBcXG5cdHN0cnVjdCBTcG90TGlnaHQge1xcblx0XHR2ZWMzIHBvc2l0aW9uO1xcblx0XHR2ZWMzIGRpcmVjdGlvbjtcXG5cdFx0dmVjMyBjb2xvcjtcXG5cdFx0ZmxvYXQgZGlzdGFuY2U7XFxuXHRcdGZsb2F0IGRlY2F5O1xcblx0XHRmbG9hdCBhbmdsZUNvcztcXG5cdFx0ZmxvYXQgZXhwb25lbnQ7XFxuXHRcdGludCBzaGFkb3c7XFxuXHRcdGZsb2F0IHNoYWRvd0JpYXM7XFxuXHRcdGZsb2F0IHNoYWRvd1JhZGl1cztcXG5cdFx0dmVjMiBzaGFkb3dNYXBTaXplO1xcblx0fTtcXG5cdHVuaWZvcm0gU3BvdExpZ2h0IHNwb3RMaWdodHNbIE5VTV9TUE9UX0xJR0hUUyBdO1xcblx0SW5jaWRlbnRMaWdodCBnZXRTcG90RGlyZWN0TGlnaHQoIGNvbnN0IGluIFNwb3RMaWdodCBzcG90TGlnaHQsIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnkgKSB7XFxuXHRcdEluY2lkZW50TGlnaHQgZGlyZWN0TGlnaHQ7XFxuXHRcdHZlYzMgbFZlY3RvciA9IHNwb3RMaWdodC5wb3NpdGlvbiAtIGdlb21ldHJ5LnBvc2l0aW9uO1xcblx0XHRkaXJlY3RMaWdodC5kaXJlY3Rpb24gPSBub3JtYWxpemUoIGxWZWN0b3IgKTtcXG5cdFx0ZmxvYXQgc3BvdEVmZmVjdCA9IGRvdCggZGlyZWN0TGlnaHQuZGlyZWN0aW9uLCBzcG90TGlnaHQuZGlyZWN0aW9uICk7XFxuXHRcdGlmICggc3BvdEVmZmVjdCA+IHNwb3RMaWdodC5hbmdsZUNvcyApIHtcXG5cdFx0XHRmbG9hdCBzcG90RWZmZWN0ID0gZG90KCBzcG90TGlnaHQuZGlyZWN0aW9uLCBkaXJlY3RMaWdodC5kaXJlY3Rpb24gKTtcXG5cdFx0XHRzcG90RWZmZWN0ID0gc2F0dXJhdGUoIHBvdyggc2F0dXJhdGUoIHNwb3RFZmZlY3QgKSwgc3BvdExpZ2h0LmV4cG9uZW50ICkgKTtcXG5cdFx0XHRkaXJlY3RMaWdodC5jb2xvciA9IHNwb3RMaWdodC5jb2xvcjtcXG5cdFx0XHRkaXJlY3RMaWdodC5jb2xvciAqPSAoIHNwb3RFZmZlY3QgKiBjYWxjTGlnaHRBdHRlbnVhdGlvbiggbGVuZ3RoKCBsVmVjdG9yICksIHNwb3RMaWdodC5kaXN0YW5jZSwgc3BvdExpZ2h0LmRlY2F5ICkgKTtcXG5cdFx0fSBlbHNlIHtcXG5cdFx0XHRkaXJlY3RMaWdodC5jb2xvciA9IHZlYzMoIDAuMCApO1xcblx0XHR9XFxuXHRcdHJldHVybiBkaXJlY3RMaWdodDtcXG5cdH1cXG4jZW5kaWZcXG4jaWYgTlVNX0hFTUlfTElHSFRTID4gMFxcblx0c3RydWN0IEhlbWlzcGhlcmVMaWdodCB7XFxuXHRcdHZlYzMgZGlyZWN0aW9uO1xcblx0XHR2ZWMzIHNreUNvbG9yO1xcblx0XHR2ZWMzIGdyb3VuZENvbG9yO1xcblx0fTtcXG5cdHVuaWZvcm0gSGVtaXNwaGVyZUxpZ2h0IGhlbWlzcGhlcmVMaWdodHNbIE5VTV9IRU1JX0xJR0hUUyBdO1xcblx0dmVjMyBnZXRIZW1pc3BoZXJlTGlnaHRJcnJhZGlhbmNlKCBjb25zdCBpbiBIZW1pc3BoZXJlTGlnaHQgaGVtaUxpZ2h0LCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5ICkge1xcblx0XHRmbG9hdCBkb3ROTCA9IGRvdCggZ2VvbWV0cnkubm9ybWFsLCBoZW1pTGlnaHQuZGlyZWN0aW9uICk7XFxuXHRcdGZsb2F0IGhlbWlEaWZmdXNlV2VpZ2h0ID0gMC41ICogZG90TkwgKyAwLjU7XFxuXHRcdHJldHVybiBQSSAqIG1peCggaGVtaUxpZ2h0Lmdyb3VuZENvbG9yLCBoZW1pTGlnaHQuc2t5Q29sb3IsIGhlbWlEaWZmdXNlV2VpZ2h0ICk7XFxuXHR9XFxuI2VuZGlmXFxuI2lmIGRlZmluZWQoIFVTRV9FTlZNQVAgKSAmJiBkZWZpbmVkKCBTVEFOREFSRCApXFxuXHR2ZWMzIGdldExpZ2h0UHJvYmVJbmRpcmVjdElycmFkaWFuY2UoIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnksIGNvbnN0IGluIGludCBtYXhNSVBMZXZlbCApIHtcXG5cdFx0I2lmZGVmIERPVUJMRV9TSURFRFxcblx0XHRcdGZsb2F0IGZsaXBOb3JtYWwgPSAoIGZsb2F0KCBnbF9Gcm9udEZhY2luZyApICogMi4wIC0gMS4wICk7XFxuXHRcdCNlbHNlXFxuXHRcdFx0ZmxvYXQgZmxpcE5vcm1hbCA9IDEuMDtcXG5cdFx0I2VuZGlmXFxuXHRcdHZlYzMgd29ybGROb3JtYWwgPSBpbnZlcnNlVHJhbnNmb3JtRGlyZWN0aW9uKCBnZW9tZXRyeS5ub3JtYWwsIHZpZXdNYXRyaXggKTtcXG5cdFx0I2lmZGVmIEVOVk1BUF9UWVBFX0NVQkVcXG5cdFx0XHR2ZWMzIHF1ZXJ5VmVjID0gZmxpcE5vcm1hbCAqIHZlYzMoIGZsaXBFbnZNYXAgKiB3b3JsZE5vcm1hbC54LCB3b3JsZE5vcm1hbC55eiApO1xcblx0XHRcdCNpZmRlZiBURVhUVVJFX0xPRF9FWFRcXG5cdFx0XHRcdHZlYzQgZW52TWFwQ29sb3IgPSB0ZXh0dXJlQ3ViZUxvZEVYVCggZW52TWFwLCBxdWVyeVZlYywgZmxvYXQoIG1heE1JUExldmVsICkgKTtcXG5cdFx0XHQjZWxzZVxcblx0XHRcdFx0dmVjNCBlbnZNYXBDb2xvciA9IHRleHR1cmVDdWJlKCBlbnZNYXAsIHF1ZXJ5VmVjLCBmbG9hdCggbWF4TUlQTGV2ZWwgKSApO1xcblx0XHRcdCNlbmRpZlxcblx0XHQjZWxzZVxcblx0XHRcdHZlYzMgZW52TWFwQ29sb3IgPSB2ZWMzKCAwLjAgKTtcXG5cdFx0I2VuZGlmXFxuXHRcdGVudk1hcENvbG9yLnJnYiA9IGlucHV0VG9MaW5lYXIoIGVudk1hcENvbG9yLnJnYiApO1xcblx0XHRyZXR1cm4gUEkgKiBlbnZNYXBDb2xvci5yZ2IgKiBlbnZNYXBJbnRlbnNpdHk7XFxuXHR9XFxuXHRmbG9hdCBnZXRTcGVjdWxhck1JUExldmVsKCBjb25zdCBpbiBmbG9hdCBibGlublNoaW5pbmVzc0V4cG9uZW50LCBjb25zdCBpbiBpbnQgbWF4TUlQTGV2ZWwgKSB7XFxuXHRcdGZsb2F0IG1heE1JUExldmVsU2NhbGFyID0gZmxvYXQoIG1heE1JUExldmVsICk7XFxuXHRcdGZsb2F0IGRlc2lyZWRNSVBMZXZlbCA9IG1heE1JUExldmVsU2NhbGFyIC0gMC43OTI0OCAtIDAuNSAqIGxvZzIoIHNxdWFyZSggYmxpbm5TaGluaW5lc3NFeHBvbmVudCApICsgMS4wICk7XFxuXHRcdHJldHVybiBjbGFtcCggZGVzaXJlZE1JUExldmVsLCAwLjAsIG1heE1JUExldmVsU2NhbGFyICk7XFxuXHR9XFxuXHR2ZWMzIGdldExpZ2h0UHJvYmVJbmRpcmVjdFJhZGlhbmNlKCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBjb25zdCBpbiBmbG9hdCBibGlublNoaW5pbmVzc0V4cG9uZW50LCBjb25zdCBpbiBpbnQgbWF4TUlQTGV2ZWwgKSB7XFxuXHRcdCNpZmRlZiBFTlZNQVBfTU9ERV9SRUZMRUNUSU9OXFxuXHRcdFx0dmVjMyByZWZsZWN0VmVjID0gcmVmbGVjdCggLWdlb21ldHJ5LnZpZXdEaXIsIGdlb21ldHJ5Lm5vcm1hbCApO1xcblx0XHQjZWxzZVxcblx0XHRcdHZlYzMgcmVmbGVjdFZlYyA9IHJlZnJhY3QoIC1nZW9tZXRyeS52aWV3RGlyLCBnZW9tZXRyeS5ub3JtYWwsIHJlZnJhY3Rpb25SYXRpbyApO1xcblx0XHQjZW5kaWZcXG5cdFx0I2lmZGVmIERPVUJMRV9TSURFRFxcblx0XHRcdGZsb2F0IGZsaXBOb3JtYWwgPSAoIGZsb2F0KCBnbF9Gcm9udEZhY2luZyApICogMi4wIC0gMS4wICk7XFxuXHRcdCNlbHNlXFxuXHRcdFx0ZmxvYXQgZmxpcE5vcm1hbCA9IDEuMDtcXG5cdFx0I2VuZGlmXFxuXHRcdHJlZmxlY3RWZWMgPSBpbnZlcnNlVHJhbnNmb3JtRGlyZWN0aW9uKCByZWZsZWN0VmVjLCB2aWV3TWF0cml4ICk7XFxuXHRcdGZsb2F0IHNwZWN1bGFyTUlQTGV2ZWwgPSBnZXRTcGVjdWxhck1JUExldmVsKCBibGlublNoaW5pbmVzc0V4cG9uZW50LCBtYXhNSVBMZXZlbCApO1xcblx0XHQjaWZkZWYgRU5WTUFQX1RZUEVfQ1VCRVxcblx0XHRcdHZlYzMgcXVlcnlSZWZsZWN0VmVjID0gZmxpcE5vcm1hbCAqIHZlYzMoIGZsaXBFbnZNYXAgKiByZWZsZWN0VmVjLngsIHJlZmxlY3RWZWMueXogKTtcXG5cdFx0XHQjaWZkZWYgVEVYVFVSRV9MT0RfRVhUXFxuXHRcdFx0XHR2ZWM0IGVudk1hcENvbG9yID0gdGV4dHVyZUN1YmVMb2RFWFQoIGVudk1hcCwgcXVlcnlSZWZsZWN0VmVjLCBzcGVjdWxhck1JUExldmVsICk7XFxuXHRcdFx0I2Vsc2VcXG5cdFx0XHRcdHZlYzQgZW52TWFwQ29sb3IgPSB0ZXh0dXJlQ3ViZSggZW52TWFwLCBxdWVyeVJlZmxlY3RWZWMsIHNwZWN1bGFyTUlQTGV2ZWwgKTtcXG5cdFx0XHQjZW5kaWZcXG5cdFx0I2VsaWYgZGVmaW5lZCggRU5WTUFQX1RZUEVfRVFVSVJFQyApXFxuXHRcdFx0dmVjMiBzYW1wbGVVVjtcXG5cdFx0XHRzYW1wbGVVVi55ID0gc2F0dXJhdGUoIGZsaXBOb3JtYWwgKiByZWZsZWN0VmVjLnkgKiAwLjUgKyAwLjUgKTtcXG5cdFx0XHRzYW1wbGVVVi54ID0gYXRhbiggZmxpcE5vcm1hbCAqIHJlZmxlY3RWZWMueiwgZmxpcE5vcm1hbCAqIHJlZmxlY3RWZWMueCApICogUkVDSVBST0NBTF9QSTIgKyAwLjU7XFxuXHRcdFx0I2lmZGVmIFRFWFRVUkVfTE9EX0VYVFxcblx0XHRcdFx0dmVjNCBlbnZNYXBDb2xvciA9IHRleHR1cmUyRExvZEVYVCggZW52TWFwLCBzYW1wbGVVViwgc3BlY3VsYXJNSVBMZXZlbCApO1xcblx0XHRcdCNlbHNlXFxuXHRcdFx0XHR2ZWM0IGVudk1hcENvbG9yID0gdGV4dHVyZTJEKCBlbnZNYXAsIHNhbXBsZVVWLCBzcGVjdWxhck1JUExldmVsICk7XFxuXHRcdFx0I2VuZGlmXFxuXHRcdCNlbGlmIGRlZmluZWQoIEVOVk1BUF9UWVBFX1NQSEVSRSApXFxuXHRcdFx0dmVjMyByZWZsZWN0VmlldyA9IGZsaXBOb3JtYWwgKiBub3JtYWxpemUoKHZpZXdNYXRyaXggKiB2ZWM0KCByZWZsZWN0VmVjLCAwLjAgKSkueHl6ICsgdmVjMygwLjAsMC4wLDEuMCkpO1xcblx0XHRcdCNpZmRlZiBURVhUVVJFX0xPRF9FWFRcXG5cdFx0XHRcdHZlYzQgZW52TWFwQ29sb3IgPSB0ZXh0dXJlMkRMb2RFWFQoIGVudk1hcCwgcmVmbGVjdFZpZXcueHkgKiAwLjUgKyAwLjUsIHNwZWN1bGFyTUlQTGV2ZWwgKTtcXG5cdFx0XHQjZWxzZVxcblx0XHRcdFx0dmVjNCBlbnZNYXBDb2xvciA9IHRleHR1cmUyRCggZW52TWFwLCByZWZsZWN0Vmlldy54eSAqIDAuNSArIDAuNSwgc3BlY3VsYXJNSVBMZXZlbCApO1xcblx0XHRcdCNlbmRpZlxcblx0XHQjZW5kaWZcXG5cdFx0ZW52TWFwQ29sb3IucmdiID0gaW5wdXRUb0xpbmVhciggZW52TWFwQ29sb3IucmdiICk7XFxuXHRcdHJldHVybiBlbnZNYXBDb2xvci5yZ2IgKiBlbnZNYXBJbnRlbnNpdHk7XFxuXHR9XFxuI2VuZGlmXFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9saWdodHNfcGhvbmdfZnJhZ21lbnQuZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdsaWdodHNfcGhvbmdfZnJhZ21lbnQnIF0gPSBcIkJsaW5uUGhvbmdNYXRlcmlhbCBtYXRlcmlhbDtcXG5tYXRlcmlhbC5kaWZmdXNlQ29sb3IgPSBkaWZmdXNlQ29sb3IucmdiO1xcbm1hdGVyaWFsLnNwZWN1bGFyQ29sb3IgPSBzcGVjdWxhcjtcXG5tYXRlcmlhbC5zcGVjdWxhclNoaW5pbmVzcyA9IHNoaW5pbmVzcztcXG5tYXRlcmlhbC5zcGVjdWxhclN0cmVuZ3RoID0gc3BlY3VsYXJTdHJlbmd0aDtcXG5cIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2xpZ2h0c19waG9uZ19wYXJzX2ZyYWdtZW50Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnbGlnaHRzX3Bob25nX3BhcnNfZnJhZ21lbnQnIF0gPSBcIiNpZmRlZiBVU0VfRU5WTUFQXFxuXHR2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XFxuI2VuZGlmXFxudmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247XFxuI2lmbmRlZiBGTEFUX1NIQURFRFxcblx0dmFyeWluZyB2ZWMzIHZOb3JtYWw7XFxuI2VuZGlmXFxuc3RydWN0IEJsaW5uUGhvbmdNYXRlcmlhbCB7XFxuXHR2ZWMzXHRkaWZmdXNlQ29sb3I7XFxuXHR2ZWMzXHRzcGVjdWxhckNvbG9yO1xcblx0ZmxvYXRcdHNwZWN1bGFyU2hpbmluZXNzO1xcblx0ZmxvYXRcdHNwZWN1bGFyU3RyZW5ndGg7XFxufTtcXG52b2lkIFJFX0RpcmVjdF9CbGlublBob25nKCBjb25zdCBpbiBJbmNpZGVudExpZ2h0IGRpcmVjdExpZ2h0LCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBjb25zdCBpbiBCbGlublBob25nTWF0ZXJpYWwgbWF0ZXJpYWwsIGlub3V0IFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ICkge1xcblx0ZmxvYXQgZG90TkwgPSBzYXR1cmF0ZSggZG90KCBnZW9tZXRyeS5ub3JtYWwsIGRpcmVjdExpZ2h0LmRpcmVjdGlvbiApICk7XFxuXHR2ZWMzIGlycmFkaWFuY2UgPSBkb3ROTCAqIFBJICogZGlyZWN0TGlnaHQuY29sb3I7XFxuXHRyZWZsZWN0ZWRMaWdodC5kaXJlY3REaWZmdXNlICs9IGlycmFkaWFuY2UgKiBCUkRGX0RpZmZ1c2VfTGFtYmVydCggbWF0ZXJpYWwuZGlmZnVzZUNvbG9yICk7XFxuXHRyZWZsZWN0ZWRMaWdodC5kaXJlY3RTcGVjdWxhciArPSBpcnJhZGlhbmNlICogQlJERl9TcGVjdWxhcl9CbGlublBob25nKCBkaXJlY3RMaWdodCwgZ2VvbWV0cnksIG1hdGVyaWFsLnNwZWN1bGFyQ29sb3IsIG1hdGVyaWFsLnNwZWN1bGFyU2hpbmluZXNzICkgKiBtYXRlcmlhbC5zcGVjdWxhclN0cmVuZ3RoO1xcbn1cXG52b2lkIFJFX0luZGlyZWN0RGlmZnVzZV9CbGlublBob25nKCBjb25zdCBpbiB2ZWMzIGlycmFkaWFuY2UsIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnksIGNvbnN0IGluIEJsaW5uUGhvbmdNYXRlcmlhbCBtYXRlcmlhbCwgaW5vdXQgUmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgKSB7XFxuXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKz0gaXJyYWRpYW5jZSAqIEJSREZfRGlmZnVzZV9MYW1iZXJ0KCBtYXRlcmlhbC5kaWZmdXNlQ29sb3IgKTtcXG59XFxuI2RlZmluZSBSRV9EaXJlY3RcdFx0XHRcdFJFX0RpcmVjdF9CbGlublBob25nXFxuI2RlZmluZSBSRV9JbmRpcmVjdERpZmZ1c2VcdFx0UkVfSW5kaXJlY3REaWZmdXNlX0JsaW5uUGhvbmdcXG4jZGVmaW5lIE1hdGVyaWFsX0xpZ2h0UHJvYmVMT0QoIG1hdGVyaWFsIClcdCgwKVxcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbGlnaHRzX3Bob25nX3BhcnNfdmVydGV4Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnbGlnaHRzX3Bob25nX3BhcnNfdmVydGV4JyBdID0gXCIjaWZkZWYgVVNFX0VOVk1BUFxcblx0dmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1xcbiNlbmRpZlxcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbGlnaHRzX3Bob25nX3ZlcnRleC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ2xpZ2h0c19waG9uZ192ZXJ0ZXgnIF0gPSBcIiNpZmRlZiBVU0VfRU5WTUFQXFxuXHR2V29ybGRQb3NpdGlvbiA9IHdvcmxkUG9zaXRpb24ueHl6O1xcbiNlbmRpZlxcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbGlnaHRzX3N0YW5kYXJkX2ZyYWdtZW50Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnbGlnaHRzX3N0YW5kYXJkX2ZyYWdtZW50JyBdID0gXCJTdGFuZGFyZE1hdGVyaWFsIG1hdGVyaWFsO1xcbm1hdGVyaWFsLmRpZmZ1c2VDb2xvciA9IGRpZmZ1c2VDb2xvci5yZ2IgKiAoIDEuMCAtIG1ldGFsbmVzc0ZhY3RvciApO1xcbm1hdGVyaWFsLnNwZWN1bGFyUm91Z2huZXNzID0gY2xhbXAoIHJvdWdobmVzc0ZhY3RvciwgMC4wNCwgMS4wICk7XFxubWF0ZXJpYWwuc3BlY3VsYXJDb2xvciA9IG1peCggdmVjMyggMC4wNCApLCBkaWZmdXNlQ29sb3IucmdiLCBtZXRhbG5lc3NGYWN0b3IgKTtcXG5cIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2xpZ2h0c19zdGFuZGFyZF9wYXJzX2ZyYWdtZW50Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnbGlnaHRzX3N0YW5kYXJkX3BhcnNfZnJhZ21lbnQnIF0gPSBcInN0cnVjdCBTdGFuZGFyZE1hdGVyaWFsIHtcXG5cdHZlYzNcdGRpZmZ1c2VDb2xvcjtcXG5cdGZsb2F0XHRzcGVjdWxhclJvdWdobmVzcztcXG5cdHZlYzNcdHNwZWN1bGFyQ29sb3I7XFxufTtcXG52b2lkIFJFX0RpcmVjdF9TdGFuZGFyZCggY29uc3QgaW4gSW5jaWRlbnRMaWdodCBkaXJlY3RMaWdodCwgY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgY29uc3QgaW4gU3RhbmRhcmRNYXRlcmlhbCBtYXRlcmlhbCwgaW5vdXQgUmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgKSB7XFxuXHRmbG9hdCBkb3ROTCA9IHNhdHVyYXRlKCBkb3QoIGdlb21ldHJ5Lm5vcm1hbCwgZGlyZWN0TGlnaHQuZGlyZWN0aW9uICkgKTtcXG5cdHZlYzMgaXJyYWRpYW5jZSA9IGRvdE5MICogUEkgKiBkaXJlY3RMaWdodC5jb2xvcjtcXG5cdHJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgKz0gaXJyYWRpYW5jZSAqIEJSREZfRGlmZnVzZV9MYW1iZXJ0KCBtYXRlcmlhbC5kaWZmdXNlQ29sb3IgKTtcXG5cdHJlZmxlY3RlZExpZ2h0LmRpcmVjdFNwZWN1bGFyICs9IGlycmFkaWFuY2UgKiBCUkRGX1NwZWN1bGFyX0dHWCggZGlyZWN0TGlnaHQsIGdlb21ldHJ5LCBtYXRlcmlhbC5zcGVjdWxhckNvbG9yLCBtYXRlcmlhbC5zcGVjdWxhclJvdWdobmVzcyApO1xcbn1cXG52b2lkIFJFX0luZGlyZWN0RGlmZnVzZV9TdGFuZGFyZCggY29uc3QgaW4gdmVjMyBpcnJhZGlhbmNlLCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBjb25zdCBpbiBTdGFuZGFyZE1hdGVyaWFsIG1hdGVyaWFsLCBpbm91dCBSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCApIHtcXG5cdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSArPSBpcnJhZGlhbmNlICogQlJERl9EaWZmdXNlX0xhbWJlcnQoIG1hdGVyaWFsLmRpZmZ1c2VDb2xvciApO1xcbn1cXG52b2lkIFJFX0luZGlyZWN0U3BlY3VsYXJfU3RhbmRhcmQoIGNvbnN0IGluIHZlYzMgcmFkaWFuY2UsIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnksIGNvbnN0IGluIFN0YW5kYXJkTWF0ZXJpYWwgbWF0ZXJpYWwsIGlub3V0IFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ICkge1xcblx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3RTcGVjdWxhciArPSByYWRpYW5jZSAqIEJSREZfU3BlY3VsYXJfR0dYX0Vudmlyb25tZW50KCBnZW9tZXRyeSwgbWF0ZXJpYWwuc3BlY3VsYXJDb2xvciwgbWF0ZXJpYWwuc3BlY3VsYXJSb3VnaG5lc3MgKTtcXG59XFxuI2RlZmluZSBSRV9EaXJlY3RcdFx0XHRcdFJFX0RpcmVjdF9TdGFuZGFyZFxcbiNkZWZpbmUgUkVfSW5kaXJlY3REaWZmdXNlXHRcdFJFX0luZGlyZWN0RGlmZnVzZV9TdGFuZGFyZFxcbiNkZWZpbmUgUkVfSW5kaXJlY3RTcGVjdWxhclx0XHRSRV9JbmRpcmVjdFNwZWN1bGFyX1N0YW5kYXJkXFxuI2RlZmluZSBNYXRlcmlhbF9CbGlublNoaW5pbmVzc0V4cG9uZW50KCBtYXRlcmlhbCApICAgR0dYUm91Z2huZXNzVG9CbGlubkV4cG9uZW50KCBtYXRlcmlhbC5zcGVjdWxhclJvdWdobmVzcyApXFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9saWdodHNfdGVtcGxhdGUuZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdsaWdodHNfdGVtcGxhdGUnIF0gPSBcIlxcbkdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnk7XFxuZ2VvbWV0cnkucG9zaXRpb24gPSAtIHZWaWV3UG9zaXRpb247XFxuZ2VvbWV0cnkubm9ybWFsID0gbm9ybWFsO1xcbmdlb21ldHJ5LnZpZXdEaXIgPSBub3JtYWxpemUoIHZWaWV3UG9zaXRpb24gKTtcXG5JbmNpZGVudExpZ2h0IGRpcmVjdExpZ2h0O1xcbiNpZiAoIE5VTV9QT0lOVF9MSUdIVFMgPiAwICkgJiYgZGVmaW5lZCggUkVfRGlyZWN0IClcXG5cdFBvaW50TGlnaHQgcG9pbnRMaWdodDtcXG5cdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9QT0lOVF9MSUdIVFM7IGkgKysgKSB7XFxuXHRcdHBvaW50TGlnaHQgPSBwb2ludExpZ2h0c1sgaSBdO1xcblx0XHRkaXJlY3RMaWdodCA9IGdldFBvaW50RGlyZWN0TGlnaHQoIHBvaW50TGlnaHQsIGdlb21ldHJ5ICk7XFxuXHRcdCNpZmRlZiBVU0VfU0hBRE9XTUFQXFxuXHRcdGRpcmVjdExpZ2h0LmNvbG9yICo9IGJvb2woIHBvaW50TGlnaHQuc2hhZG93ICkgPyBnZXRQb2ludFNoYWRvdyggcG9pbnRTaGFkb3dNYXBbIGkgXSwgcG9pbnRMaWdodC5zaGFkb3dNYXBTaXplLCBwb2ludExpZ2h0LnNoYWRvd0JpYXMsIHBvaW50TGlnaHQuc2hhZG93UmFkaXVzLCB2UG9pbnRTaGFkb3dDb29yZFsgaSBdICkgOiAxLjA7XFxuXHRcdCNlbmRpZlxcblx0XHRSRV9EaXJlY3QoIGRpcmVjdExpZ2h0LCBnZW9tZXRyeSwgbWF0ZXJpYWwsIHJlZmxlY3RlZExpZ2h0ICk7XFxuXHR9XFxuI2VuZGlmXFxuI2lmICggTlVNX1NQT1RfTElHSFRTID4gMCApICYmIGRlZmluZWQoIFJFX0RpcmVjdCApXFxuXHRTcG90TGlnaHQgc3BvdExpZ2h0O1xcblx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX1NQT1RfTElHSFRTOyBpICsrICkge1xcblx0XHRzcG90TGlnaHQgPSBzcG90TGlnaHRzWyBpIF07XFxuXHRcdGRpcmVjdExpZ2h0ID0gZ2V0U3BvdERpcmVjdExpZ2h0KCBzcG90TGlnaHQsIGdlb21ldHJ5ICk7XFxuXHRcdCNpZmRlZiBVU0VfU0hBRE9XTUFQXFxuXHRcdGRpcmVjdExpZ2h0LmNvbG9yICo9IGJvb2woIHNwb3RMaWdodC5zaGFkb3cgKSA/IGdldFNoYWRvdyggc3BvdFNoYWRvd01hcFsgaSBdLCBzcG90TGlnaHQuc2hhZG93TWFwU2l6ZSwgc3BvdExpZ2h0LnNoYWRvd0JpYXMsIHNwb3RMaWdodC5zaGFkb3dSYWRpdXMsIHZTcG90U2hhZG93Q29vcmRbIGkgXSApIDogMS4wO1xcblx0XHQjZW5kaWZcXG5cdFx0UkVfRGlyZWN0KCBkaXJlY3RMaWdodCwgZ2VvbWV0cnksIG1hdGVyaWFsLCByZWZsZWN0ZWRMaWdodCApO1xcblx0fVxcbiNlbmRpZlxcbiNpZiAoIE5VTV9ESVJfTElHSFRTID4gMCApICYmIGRlZmluZWQoIFJFX0RpcmVjdCApXFxuXHREaXJlY3Rpb25hbExpZ2h0IGRpcmVjdGlvbmFsTGlnaHQ7XFxuXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fRElSX0xJR0hUUzsgaSArKyApIHtcXG5cdFx0ZGlyZWN0aW9uYWxMaWdodCA9IGRpcmVjdGlvbmFsTGlnaHRzWyBpIF07XFxuXHRcdGRpcmVjdExpZ2h0ID0gZ2V0RGlyZWN0aW9uYWxEaXJlY3RMaWdodCggZGlyZWN0aW9uYWxMaWdodCwgZ2VvbWV0cnkgKTtcXG5cdFx0I2lmZGVmIFVTRV9TSEFET1dNQVBcXG5cdFx0ZGlyZWN0TGlnaHQuY29sb3IgKj0gYm9vbCggZGlyZWN0aW9uYWxMaWdodC5zaGFkb3cgKSA/IGdldFNoYWRvdyggZGlyZWN0aW9uYWxTaGFkb3dNYXBbIGkgXSwgZGlyZWN0aW9uYWxMaWdodC5zaGFkb3dNYXBTaXplLCBkaXJlY3Rpb25hbExpZ2h0LnNoYWRvd0JpYXMsIGRpcmVjdGlvbmFsTGlnaHQuc2hhZG93UmFkaXVzLCB2RGlyZWN0aW9uYWxTaGFkb3dDb29yZFsgaSBdICkgOiAxLjA7XFxuXHRcdCNlbmRpZlxcblx0XHRSRV9EaXJlY3QoIGRpcmVjdExpZ2h0LCBnZW9tZXRyeSwgbWF0ZXJpYWwsIHJlZmxlY3RlZExpZ2h0ICk7XFxuXHR9XFxuI2VuZGlmXFxuI2lmIGRlZmluZWQoIFJFX0luZGlyZWN0RGlmZnVzZSApXFxuXHR2ZWMzIGlycmFkaWFuY2UgPSBnZXRBbWJpZW50TGlnaHRJcnJhZGlhbmNlKCBhbWJpZW50TGlnaHRDb2xvciApO1xcblx0I2lmZGVmIFVTRV9MSUdIVE1BUFxcblx0XHRpcnJhZGlhbmNlICs9IFBJICogdGV4dHVyZTJEKCBsaWdodE1hcCwgdlV2MiApLnh5eiAqIGxpZ2h0TWFwSW50ZW5zaXR5O1xcblx0I2VuZGlmXFxuXHQjaWYgKCBOVU1fSEVNSV9MSUdIVFMgPiAwIClcXG5cdFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX0hFTUlfTElHSFRTOyBpICsrICkge1xcblx0XHRcdGlycmFkaWFuY2UgKz0gZ2V0SGVtaXNwaGVyZUxpZ2h0SXJyYWRpYW5jZSggaGVtaXNwaGVyZUxpZ2h0c1sgaSBdLCBnZW9tZXRyeSApO1xcblx0XHR9XFxuXHQjZW5kaWZcXG5cdFJFX0luZGlyZWN0RGlmZnVzZSggaXJyYWRpYW5jZSwgZ2VvbWV0cnksIG1hdGVyaWFsLCByZWZsZWN0ZWRMaWdodCApO1xcbiNlbmRpZlxcbiNpZiBkZWZpbmVkKCBVU0VfRU5WTUFQICkgJiYgZGVmaW5lZCggUkVfSW5kaXJlY3RTcGVjdWxhciApXFxuXHR2ZWMzIHJhZGlhbmNlID0gZ2V0TGlnaHRQcm9iZUluZGlyZWN0UmFkaWFuY2UoIGdlb21ldHJ5LCBNYXRlcmlhbF9CbGlublNoaW5pbmVzc0V4cG9uZW50KCBtYXRlcmlhbCApLCA4ICk7XFxuXHRSRV9JbmRpcmVjdFNwZWN1bGFyKCByYWRpYW5jZSwgZ2VvbWV0cnksIG1hdGVyaWFsLCByZWZsZWN0ZWRMaWdodCApO1xcbiNlbmRpZlxcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbGluZWFyX3RvX2dhbW1hX2ZyYWdtZW50Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnbGluZWFyX3RvX2dhbW1hX2ZyYWdtZW50JyBdID0gXCJcXG5cdG91dGdvaW5nTGlnaHQgPSBsaW5lYXJUb091dHB1dCggb3V0Z29pbmdMaWdodCApO1xcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbG9nZGVwdGhidWZfZnJhZ21lbnQuZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdsb2dkZXB0aGJ1Zl9mcmFnbWVudCcgXSA9IFwiI2lmIGRlZmluZWQoVVNFX0xPR0RFUFRIQlVGKSAmJiBkZWZpbmVkKFVTRV9MT0dERVBUSEJVRl9FWFQpXFxuXHRnbF9GcmFnRGVwdGhFWFQgPSBsb2cyKHZGcmFnRGVwdGgpICogbG9nRGVwdGhCdWZGQyAqIDAuNTtcXG4jZW5kaWZcIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2xvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQuZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50JyBdID0gXCIjaWZkZWYgVVNFX0xPR0RFUFRIQlVGXFxuXHR1bmlmb3JtIGZsb2F0IGxvZ0RlcHRoQnVmRkM7XFxuXHQjaWZkZWYgVVNFX0xPR0RFUFRIQlVGX0VYVFxcblx0XHR2YXJ5aW5nIGZsb2F0IHZGcmFnRGVwdGg7XFxuXHQjZW5kaWZcXG4jZW5kaWZcXG5cIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2xvZ2RlcHRoYnVmX3BhcnNfdmVydGV4Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnbG9nZGVwdGhidWZfcGFyc192ZXJ0ZXgnIF0gPSBcIiNpZmRlZiBVU0VfTE9HREVQVEhCVUZcXG5cdCNpZmRlZiBVU0VfTE9HREVQVEhCVUZfRVhUXFxuXHRcdHZhcnlpbmcgZmxvYXQgdkZyYWdEZXB0aDtcXG5cdCNlbmRpZlxcblx0dW5pZm9ybSBmbG9hdCBsb2dEZXB0aEJ1ZkZDO1xcbiNlbmRpZlwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbG9nZGVwdGhidWZfdmVydGV4Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnbG9nZGVwdGhidWZfdmVydGV4JyBdID0gXCIjaWZkZWYgVVNFX0xPR0RFUFRIQlVGXFxuXHRnbF9Qb3NpdGlvbi56ID0gbG9nMihtYXgoIEVQU0lMT04sIGdsX1Bvc2l0aW9uLncgKyAxLjAgKSkgKiBsb2dEZXB0aEJ1ZkZDO1xcblx0I2lmZGVmIFVTRV9MT0dERVBUSEJVRl9FWFRcXG5cdFx0dkZyYWdEZXB0aCA9IDEuMCArIGdsX1Bvc2l0aW9uLnc7XFxuXHQjZWxzZVxcblx0XHRnbF9Qb3NpdGlvbi56ID0gKGdsX1Bvc2l0aW9uLnogLSAxLjApICogZ2xfUG9zaXRpb24udztcXG5cdCNlbmRpZlxcbiNlbmRpZlxcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbWFwX2ZyYWdtZW50Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnbWFwX2ZyYWdtZW50JyBdID0gXCIjaWZkZWYgVVNFX01BUFxcblx0dmVjNCB0ZXhlbENvbG9yID0gdGV4dHVyZTJEKCBtYXAsIHZVdiApO1xcblx0dGV4ZWxDb2xvci54eXogPSBpbnB1dFRvTGluZWFyKCB0ZXhlbENvbG9yLnh5eiApO1xcblx0ZGlmZnVzZUNvbG9yICo9IHRleGVsQ29sb3I7XFxuI2VuZGlmXFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9tYXBfcGFyc19mcmFnbWVudC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ21hcF9wYXJzX2ZyYWdtZW50JyBdID0gXCIjaWZkZWYgVVNFX01BUFxcblx0dW5pZm9ybSBzYW1wbGVyMkQgbWFwO1xcbiNlbmRpZlwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbWFwX3BhcnRpY2xlX2ZyYWdtZW50Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnbWFwX3BhcnRpY2xlX2ZyYWdtZW50JyBdID0gXCIjaWZkZWYgVVNFX01BUFxcblx0ZGlmZnVzZUNvbG9yICo9IHRleHR1cmUyRCggbWFwLCB2ZWMyKCBnbF9Qb2ludENvb3JkLngsIDEuMCAtIGdsX1BvaW50Q29vcmQueSApICogb2Zmc2V0UmVwZWF0Lnp3ICsgb2Zmc2V0UmVwZWF0Lnh5ICk7XFxuI2VuZGlmXFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9tYXBfcGFydGljbGVfcGFyc19mcmFnbWVudC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ21hcF9wYXJ0aWNsZV9wYXJzX2ZyYWdtZW50JyBdID0gXCIjaWZkZWYgVVNFX01BUFxcblx0dW5pZm9ybSB2ZWM0IG9mZnNldFJlcGVhdDtcXG5cdHVuaWZvcm0gc2FtcGxlcjJEIG1hcDtcXG4jZW5kaWZcXG5cIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL21ldGFsbmVzc21hcF9mcmFnbWVudC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ21ldGFsbmVzc21hcF9mcmFnbWVudCcgXSA9IFwiZmxvYXQgbWV0YWxuZXNzRmFjdG9yID0gbWV0YWxuZXNzO1xcbiNpZmRlZiBVU0VfTUVUQUxORVNTTUFQXFxuXHR2ZWM0IHRleGVsTWV0YWxuZXNzID0gdGV4dHVyZTJEKCBtZXRhbG5lc3NNYXAsIHZVdiApO1xcblx0bWV0YWxuZXNzRmFjdG9yICo9IHRleGVsTWV0YWxuZXNzLnI7XFxuI2VuZGlmXFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9tZXRhbG5lc3NtYXBfcGFyc19mcmFnbWVudC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ21ldGFsbmVzc21hcF9wYXJzX2ZyYWdtZW50JyBdID0gXCIjaWZkZWYgVVNFX01FVEFMTkVTU01BUFxcblx0dW5pZm9ybSBzYW1wbGVyMkQgbWV0YWxuZXNzTWFwO1xcbiNlbmRpZlwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbW9ycGhub3JtYWxfdmVydGV4Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnbW9ycGhub3JtYWxfdmVydGV4JyBdID0gXCIjaWZkZWYgVVNFX01PUlBITk9STUFMU1xcblx0b2JqZWN0Tm9ybWFsICs9ICggbW9ycGhOb3JtYWwwIC0gbm9ybWFsICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDAgXTtcXG5cdG9iamVjdE5vcm1hbCArPSAoIG1vcnBoTm9ybWFsMSAtIG5vcm1hbCApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAxIF07XFxuXHRvYmplY3ROb3JtYWwgKz0gKCBtb3JwaE5vcm1hbDIgLSBub3JtYWwgKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMiBdO1xcblx0b2JqZWN0Tm9ybWFsICs9ICggbW9ycGhOb3JtYWwzIC0gbm9ybWFsICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDMgXTtcXG4jZW5kaWZcXG5cIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL21vcnBodGFyZ2V0X3BhcnNfdmVydGV4Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnbW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXgnIF0gPSBcIiNpZmRlZiBVU0VfTU9SUEhUQVJHRVRTXFxuXHQjaWZuZGVmIFVTRV9NT1JQSE5PUk1BTFNcXG5cdHVuaWZvcm0gZmxvYXQgbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyA4IF07XFxuXHQjZWxzZVxcblx0dW5pZm9ybSBmbG9hdCBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDQgXTtcXG5cdCNlbmRpZlxcbiNlbmRpZlwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbW9ycGh0YXJnZXRfdmVydGV4Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnbW9ycGh0YXJnZXRfdmVydGV4JyBdID0gXCIjaWZkZWYgVVNFX01PUlBIVEFSR0VUU1xcblx0dHJhbnNmb3JtZWQgKz0gKCBtb3JwaFRhcmdldDAgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAwIF07XFxuXHR0cmFuc2Zvcm1lZCArPSAoIG1vcnBoVGFyZ2V0MSAtIHBvc2l0aW9uICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDEgXTtcXG5cdHRyYW5zZm9ybWVkICs9ICggbW9ycGhUYXJnZXQyIC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMiBdO1xcblx0dHJhbnNmb3JtZWQgKz0gKCBtb3JwaFRhcmdldDMgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAzIF07XFxuXHQjaWZuZGVmIFVTRV9NT1JQSE5PUk1BTFNcXG5cdHRyYW5zZm9ybWVkICs9ICggbW9ycGhUYXJnZXQ0IC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgNCBdO1xcblx0dHJhbnNmb3JtZWQgKz0gKCBtb3JwaFRhcmdldDUgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyA1IF07XFxuXHR0cmFuc2Zvcm1lZCArPSAoIG1vcnBoVGFyZ2V0NiAtIHBvc2l0aW9uICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDYgXTtcXG5cdHRyYW5zZm9ybWVkICs9ICggbW9ycGhUYXJnZXQ3IC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgNyBdO1xcblx0I2VuZGlmXFxuI2VuZGlmXFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9ub3JtYWxfZnJhZ21lbnQuZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdub3JtYWxfZnJhZ21lbnQnIF0gPSBcIiNpZmRlZiBGTEFUX1NIQURFRFxcblx0dmVjMyBmZHggPSBkRmR4KCB2Vmlld1Bvc2l0aW9uICk7XFxuXHR2ZWMzIGZkeSA9IGRGZHkoIHZWaWV3UG9zaXRpb24gKTtcXG5cdHZlYzMgbm9ybWFsID0gbm9ybWFsaXplKCBjcm9zcyggZmR4LCBmZHkgKSApO1xcbiNlbHNlXFxuXHR2ZWMzIG5vcm1hbCA9IG5vcm1hbGl6ZSggdk5vcm1hbCApO1xcblx0I2lmZGVmIERPVUJMRV9TSURFRFxcblx0XHRub3JtYWwgPSBub3JtYWwgKiAoIC0xLjAgKyAyLjAgKiBmbG9hdCggZ2xfRnJvbnRGYWNpbmcgKSApO1xcblx0I2VuZGlmXFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9OT1JNQUxNQVBcXG5cdG5vcm1hbCA9IHBlcnR1cmJOb3JtYWwyQXJiKCAtdlZpZXdQb3NpdGlvbiwgbm9ybWFsICk7XFxuI2VsaWYgZGVmaW5lZCggVVNFX0JVTVBNQVAgKVxcblx0bm9ybWFsID0gcGVydHVyYk5vcm1hbEFyYiggLXZWaWV3UG9zaXRpb24sIG5vcm1hbCwgZEhkeHlfZndkKCkgKTtcXG4jZW5kaWZcXG5cIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL25vcm1hbG1hcF9wYXJzX2ZyYWdtZW50Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnbm9ybWFsbWFwX3BhcnNfZnJhZ21lbnQnIF0gPSBcIiNpZmRlZiBVU0VfTk9STUFMTUFQXFxuXHR1bmlmb3JtIHNhbXBsZXIyRCBub3JtYWxNYXA7XFxuXHR1bmlmb3JtIHZlYzIgbm9ybWFsU2NhbGU7XFxuXHR2ZWMzIHBlcnR1cmJOb3JtYWwyQXJiKCB2ZWMzIGV5ZV9wb3MsIHZlYzMgc3VyZl9ub3JtICkge1xcblx0XHR2ZWMzIHEwID0gZEZkeCggZXllX3Bvcy54eXogKTtcXG5cdFx0dmVjMyBxMSA9IGRGZHkoIGV5ZV9wb3MueHl6ICk7XFxuXHRcdHZlYzIgc3QwID0gZEZkeCggdlV2LnN0ICk7XFxuXHRcdHZlYzIgc3QxID0gZEZkeSggdlV2LnN0ICk7XFxuXHRcdHZlYzMgUyA9IG5vcm1hbGl6ZSggcTAgKiBzdDEudCAtIHExICogc3QwLnQgKTtcXG5cdFx0dmVjMyBUID0gbm9ybWFsaXplKCAtcTAgKiBzdDEucyArIHExICogc3QwLnMgKTtcXG5cdFx0dmVjMyBOID0gbm9ybWFsaXplKCBzdXJmX25vcm0gKTtcXG5cdFx0dmVjMyBtYXBOID0gdGV4dHVyZTJEKCBub3JtYWxNYXAsIHZVdiApLnh5eiAqIDIuMCAtIDEuMDtcXG5cdFx0bWFwTi54eSA9IG5vcm1hbFNjYWxlICogbWFwTi54eTtcXG5cdFx0bWF0MyB0c24gPSBtYXQzKCBTLCBULCBOICk7XFxuXHRcdHJldHVybiBub3JtYWxpemUoIHRzbiAqIG1hcE4gKTtcXG5cdH1cXG4jZW5kaWZcXG5cIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3Byb2plY3RfdmVydGV4Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAncHJvamVjdF92ZXJ0ZXgnIF0gPSBcIiNpZmRlZiBVU0VfU0tJTk5JTkdcXG5cdHZlYzQgbXZQb3NpdGlvbiA9IG1vZGVsVmlld01hdHJpeCAqIHNraW5uZWQ7XFxuI2Vsc2VcXG5cdHZlYzQgbXZQb3NpdGlvbiA9IG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHRyYW5zZm9ybWVkLCAxLjAgKTtcXG4jZW5kaWZcXG5nbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtdlBvc2l0aW9uO1xcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvcm91Z2huZXNzbWFwX2ZyYWdtZW50Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAncm91Z2huZXNzbWFwX2ZyYWdtZW50JyBdID0gXCJmbG9hdCByb3VnaG5lc3NGYWN0b3IgPSByb3VnaG5lc3M7XFxuI2lmZGVmIFVTRV9ST1VHSE5FU1NNQVBcXG5cdHZlYzQgdGV4ZWxSb3VnaG5lc3MgPSB0ZXh0dXJlMkQoIHJvdWdobmVzc01hcCwgdlV2ICk7XFxuXHRyb3VnaG5lc3NGYWN0b3IgKj0gdGV4ZWxSb3VnaG5lc3MucjtcXG4jZW5kaWZcXG5cIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3JvdWdobmVzc21hcF9wYXJzX2ZyYWdtZW50Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAncm91Z2huZXNzbWFwX3BhcnNfZnJhZ21lbnQnIF0gPSBcIiNpZmRlZiBVU0VfUk9VR0hORVNTTUFQXFxuXHR1bmlmb3JtIHNhbXBsZXIyRCByb3VnaG5lc3NNYXA7XFxuI2VuZGlmXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9zaGFkb3dtYXBfcGFyc19mcmFnbWVudC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ3NoYWRvd21hcF9wYXJzX2ZyYWdtZW50JyBdID0gXCIjaWZkZWYgVVNFX1NIQURPV01BUFxcblx0I2lmIE5VTV9ESVJfTElHSFRTID4gMFxcblx0XHR1bmlmb3JtIHNhbXBsZXIyRCBkaXJlY3Rpb25hbFNoYWRvd01hcFsgTlVNX0RJUl9MSUdIVFMgXTtcXG5cdFx0dmFyeWluZyB2ZWM0IHZEaXJlY3Rpb25hbFNoYWRvd0Nvb3JkWyBOVU1fRElSX0xJR0hUUyBdO1xcblx0I2VuZGlmXFxuXHQjaWYgTlVNX1NQT1RfTElHSFRTID4gMFxcblx0XHR1bmlmb3JtIHNhbXBsZXIyRCBzcG90U2hhZG93TWFwWyBOVU1fU1BPVF9MSUdIVFMgXTtcXG5cdFx0dmFyeWluZyB2ZWM0IHZTcG90U2hhZG93Q29vcmRbIE5VTV9TUE9UX0xJR0hUUyBdO1xcblx0I2VuZGlmXFxuXHQjaWYgTlVNX1BPSU5UX0xJR0hUUyA+IDBcXG5cdFx0dW5pZm9ybSBzYW1wbGVyMkQgcG9pbnRTaGFkb3dNYXBbIE5VTV9QT0lOVF9MSUdIVFMgXTtcXG5cdFx0dmFyeWluZyB2ZWM0IHZQb2ludFNoYWRvd0Nvb3JkWyBOVU1fUE9JTlRfTElHSFRTIF07XFxuXHQjZW5kaWZcXG5cdGZsb2F0IHVucGFja0RlcHRoKCBjb25zdCBpbiB2ZWM0IHJnYmFfZGVwdGggKSB7XFxuXHRcdGNvbnN0IHZlYzQgYml0X3NoaWZ0ID0gdmVjNCggMS4wIC8gKCAyNTYuMCAqIDI1Ni4wICogMjU2LjAgKSwgMS4wIC8gKCAyNTYuMCAqIDI1Ni4wICksIDEuMCAvIDI1Ni4wLCAxLjAgKTtcXG5cdFx0cmV0dXJuIGRvdCggcmdiYV9kZXB0aCwgYml0X3NoaWZ0ICk7XFxuXHR9XFxuXHRmbG9hdCB0ZXh0dXJlMkRDb21wYXJlKCBzYW1wbGVyMkQgZGVwdGhzLCB2ZWMyIHV2LCBmbG9hdCBjb21wYXJlICkge1xcblx0XHRyZXR1cm4gc3RlcCggY29tcGFyZSwgdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggZGVwdGhzLCB1diApICkgKTtcXG5cdH1cXG5cdGZsb2F0IHRleHR1cmUyRFNoYWRvd0xlcnAoIHNhbXBsZXIyRCBkZXB0aHMsIHZlYzIgc2l6ZSwgdmVjMiB1diwgZmxvYXQgY29tcGFyZSApIHtcXG5cdFx0Y29uc3QgdmVjMiBvZmZzZXQgPSB2ZWMyKCAwLjAsIDEuMCApO1xcblx0XHR2ZWMyIHRleGVsU2l6ZSA9IHZlYzIoIDEuMCApIC8gc2l6ZTtcXG5cdFx0dmVjMiBjZW50cm9pZFVWID0gZmxvb3IoIHV2ICogc2l6ZSArIDAuNSApIC8gc2l6ZTtcXG5cdFx0ZmxvYXQgbGIgPSB0ZXh0dXJlMkRDb21wYXJlKCBkZXB0aHMsIGNlbnRyb2lkVVYgKyB0ZXhlbFNpemUgKiBvZmZzZXQueHgsIGNvbXBhcmUgKTtcXG5cdFx0ZmxvYXQgbHQgPSB0ZXh0dXJlMkRDb21wYXJlKCBkZXB0aHMsIGNlbnRyb2lkVVYgKyB0ZXhlbFNpemUgKiBvZmZzZXQueHksIGNvbXBhcmUgKTtcXG5cdFx0ZmxvYXQgcmIgPSB0ZXh0dXJlMkRDb21wYXJlKCBkZXB0aHMsIGNlbnRyb2lkVVYgKyB0ZXhlbFNpemUgKiBvZmZzZXQueXgsIGNvbXBhcmUgKTtcXG5cdFx0ZmxvYXQgcnQgPSB0ZXh0dXJlMkRDb21wYXJlKCBkZXB0aHMsIGNlbnRyb2lkVVYgKyB0ZXhlbFNpemUgKiBvZmZzZXQueXksIGNvbXBhcmUgKTtcXG5cdFx0dmVjMiBmID0gZnJhY3QoIHV2ICogc2l6ZSArIDAuNSApO1xcblx0XHRmbG9hdCBhID0gbWl4KCBsYiwgbHQsIGYueSApO1xcblx0XHRmbG9hdCBiID0gbWl4KCByYiwgcnQsIGYueSApO1xcblx0XHRmbG9hdCBjID0gbWl4KCBhLCBiLCBmLnggKTtcXG5cdFx0cmV0dXJuIGM7XFxuXHR9XFxuXHRmbG9hdCBnZXRTaGFkb3coIHNhbXBsZXIyRCBzaGFkb3dNYXAsIHZlYzIgc2hhZG93TWFwU2l6ZSwgZmxvYXQgc2hhZG93QmlhcywgZmxvYXQgc2hhZG93UmFkaXVzLCB2ZWM0IHNoYWRvd0Nvb3JkICkge1xcblx0XHRzaGFkb3dDb29yZC54eXogLz0gc2hhZG93Q29vcmQudztcXG5cdFx0c2hhZG93Q29vcmQueiArPSBzaGFkb3dCaWFzO1xcblx0XHRidmVjNCBpbkZydXN0dW1WZWMgPSBidmVjNCAoIHNoYWRvd0Nvb3JkLnggPj0gMC4wLCBzaGFkb3dDb29yZC54IDw9IDEuMCwgc2hhZG93Q29vcmQueSA+PSAwLjAsIHNoYWRvd0Nvb3JkLnkgPD0gMS4wICk7XFxuXHRcdGJvb2wgaW5GcnVzdHVtID0gYWxsKCBpbkZydXN0dW1WZWMgKTtcXG5cdFx0YnZlYzIgZnJ1c3R1bVRlc3RWZWMgPSBidmVjMiggaW5GcnVzdHVtLCBzaGFkb3dDb29yZC56IDw9IDEuMCApO1xcblx0XHRib29sIGZydXN0dW1UZXN0ID0gYWxsKCBmcnVzdHVtVGVzdFZlYyApO1xcblx0XHRpZiAoIGZydXN0dW1UZXN0ICkge1xcblx0XHQjaWYgZGVmaW5lZCggU0hBRE9XTUFQX1RZUEVfUENGIClcXG5cdFx0XHR2ZWMyIHRleGVsU2l6ZSA9IHZlYzIoIDEuMCApIC8gc2hhZG93TWFwU2l6ZTtcXG5cdFx0XHRmbG9hdCBkeDAgPSAtIHRleGVsU2l6ZS54ICogc2hhZG93UmFkaXVzO1xcblx0XHRcdGZsb2F0IGR5MCA9IC0gdGV4ZWxTaXplLnkgKiBzaGFkb3dSYWRpdXM7XFxuXHRcdFx0ZmxvYXQgZHgxID0gKyB0ZXhlbFNpemUueCAqIHNoYWRvd1JhZGl1cztcXG5cdFx0XHRmbG9hdCBkeTEgPSArIHRleGVsU2l6ZS55ICogc2hhZG93UmFkaXVzO1xcblx0XHRcdHJldHVybiAoXFxuXHRcdFx0XHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgwLCBkeTAgKSwgc2hhZG93Q29vcmQueiApICtcXG5cdFx0XHRcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCAwLjAsIGR5MCApLCBzaGFkb3dDb29yZC56ICkgK1xcblx0XHRcdFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MSwgZHkwICksIHNoYWRvd0Nvb3JkLnogKSArXFxuXHRcdFx0XHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgwLCAwLjAgKSwgc2hhZG93Q29vcmQueiApICtcXG5cdFx0XHRcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHksIHNoYWRvd0Nvb3JkLnogKSArXFxuXHRcdFx0XHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCAwLjAgKSwgc2hhZG93Q29vcmQueiApICtcXG5cdFx0XHRcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDAsIGR5MSApLCBzaGFkb3dDb29yZC56ICkgK1xcblx0XHRcdFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIDAuMCwgZHkxICksIHNoYWRvd0Nvb3JkLnogKSArXFxuXHRcdFx0XHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCBkeTEgKSwgc2hhZG93Q29vcmQueiApXFxuXHRcdFx0KSAqICggMS4wIC8gOS4wICk7XFxuXHRcdCNlbGlmIGRlZmluZWQoIFNIQURPV01BUF9UWVBFX1BDRl9TT0ZUIClcXG5cdFx0XHR2ZWMyIHRleGVsU2l6ZSA9IHZlYzIoIDEuMCApIC8gc2hhZG93TWFwU2l6ZTtcXG5cdFx0XHRmbG9hdCBkeDAgPSAtIHRleGVsU2l6ZS54ICogc2hhZG93UmFkaXVzO1xcblx0XHRcdGZsb2F0IGR5MCA9IC0gdGV4ZWxTaXplLnkgKiBzaGFkb3dSYWRpdXM7XFxuXHRcdFx0ZmxvYXQgZHgxID0gKyB0ZXhlbFNpemUueCAqIHNoYWRvd1JhZGl1cztcXG5cdFx0XHRmbG9hdCBkeTEgPSArIHRleGVsU2l6ZS55ICogc2hhZG93UmFkaXVzO1xcblx0XHRcdHJldHVybiAoXFxuXHRcdFx0XHR0ZXh0dXJlMkRTaGFkb3dMZXJwKCBzaGFkb3dNYXAsIHNoYWRvd01hcFNpemUsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgwLCBkeTAgKSwgc2hhZG93Q29vcmQueiApICtcXG5cdFx0XHRcdHRleHR1cmUyRFNoYWRvd0xlcnAoIHNoYWRvd01hcCwgc2hhZG93TWFwU2l6ZSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCAwLjAsIGR5MCApLCBzaGFkb3dDb29yZC56ICkgK1xcblx0XHRcdFx0dGV4dHVyZTJEU2hhZG93TGVycCggc2hhZG93TWFwLCBzaGFkb3dNYXBTaXplLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MSwgZHkwICksIHNoYWRvd0Nvb3JkLnogKSArXFxuXHRcdFx0XHR0ZXh0dXJlMkRTaGFkb3dMZXJwKCBzaGFkb3dNYXAsIHNoYWRvd01hcFNpemUsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgwLCAwLjAgKSwgc2hhZG93Q29vcmQueiApICtcXG5cdFx0XHRcdHRleHR1cmUyRFNoYWRvd0xlcnAoIHNoYWRvd01hcCwgc2hhZG93TWFwU2l6ZSwgc2hhZG93Q29vcmQueHksIHNoYWRvd0Nvb3JkLnogKSArXFxuXHRcdFx0XHR0ZXh0dXJlMkRTaGFkb3dMZXJwKCBzaGFkb3dNYXAsIHNoYWRvd01hcFNpemUsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCAwLjAgKSwgc2hhZG93Q29vcmQueiApICtcXG5cdFx0XHRcdHRleHR1cmUyRFNoYWRvd0xlcnAoIHNoYWRvd01hcCwgc2hhZG93TWFwU2l6ZSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDAsIGR5MSApLCBzaGFkb3dDb29yZC56ICkgK1xcblx0XHRcdFx0dGV4dHVyZTJEU2hhZG93TGVycCggc2hhZG93TWFwLCBzaGFkb3dNYXBTaXplLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIDAuMCwgZHkxICksIHNoYWRvd0Nvb3JkLnogKSArXFxuXHRcdFx0XHR0ZXh0dXJlMkRTaGFkb3dMZXJwKCBzaGFkb3dNYXAsIHNoYWRvd01hcFNpemUsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCBkeTEgKSwgc2hhZG93Q29vcmQueiApXFxuXHRcdFx0KSAqICggMS4wIC8gOS4wICk7XFxuXHRcdCNlbHNlXFxuXHRcdFx0cmV0dXJuIHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHksIHNoYWRvd0Nvb3JkLnogKTtcXG5cdFx0I2VuZGlmXFxuXHRcdH1cXG5cdFx0cmV0dXJuIDEuMDtcXG5cdH1cXG5cdHZlYzIgY3ViZVRvVVYoIHZlYzMgdiwgZmxvYXQgdGV4ZWxTaXplWSApIHtcXG5cdFx0dmVjMyBhYnNWID0gYWJzKCB2ICk7XFxuXHRcdGZsb2F0IHNjYWxlVG9DdWJlID0gMS4wIC8gbWF4KCBhYnNWLngsIG1heCggYWJzVi55LCBhYnNWLnogKSApO1xcblx0XHRhYnNWICo9IHNjYWxlVG9DdWJlO1xcblx0XHR2ICo9IHNjYWxlVG9DdWJlICogKCAxLjAgLSAyLjAgKiB0ZXhlbFNpemVZICk7XFxuXHRcdHZlYzIgcGxhbmFyID0gdi54eTtcXG5cdFx0ZmxvYXQgYWxtb3N0QVRleGVsID0gMS41ICogdGV4ZWxTaXplWTtcXG5cdFx0ZmxvYXQgYWxtb3N0T25lID0gMS4wIC0gYWxtb3N0QVRleGVsO1xcblx0XHRpZiAoIGFic1YueiA+PSBhbG1vc3RPbmUgKSB7XFxuXHRcdFx0aWYgKCB2LnogPiAwLjAgKVxcblx0XHRcdFx0cGxhbmFyLnggPSA0LjAgLSB2Lng7XFxuXHRcdH0gZWxzZSBpZiAoIGFic1YueCA+PSBhbG1vc3RPbmUgKSB7XFxuXHRcdFx0ZmxvYXQgc2lnblggPSBzaWduKCB2LnggKTtcXG5cdFx0XHRwbGFuYXIueCA9IHYueiAqIHNpZ25YICsgMi4wICogc2lnblg7XFxuXHRcdH0gZWxzZSBpZiAoIGFic1YueSA+PSBhbG1vc3RPbmUgKSB7XFxuXHRcdFx0ZmxvYXQgc2lnblkgPSBzaWduKCB2LnkgKTtcXG5cdFx0XHRwbGFuYXIueCA9IHYueCArIDIuMCAqIHNpZ25ZICsgMi4wO1xcblx0XHRcdHBsYW5hci55ID0gdi56ICogc2lnblkgLSAyLjA7XFxuXHRcdH1cXG5cdFx0cmV0dXJuIHZlYzIoIDAuMTI1LCAwLjI1ICkgKiBwbGFuYXIgKyB2ZWMyKCAwLjM3NSwgMC43NSApO1xcblx0fVxcblx0ZmxvYXQgZ2V0UG9pbnRTaGFkb3coIHNhbXBsZXIyRCBzaGFkb3dNYXAsIHZlYzIgc2hhZG93TWFwU2l6ZSwgZmxvYXQgc2hhZG93QmlhcywgZmxvYXQgc2hhZG93UmFkaXVzLCB2ZWM0IHNoYWRvd0Nvb3JkICkge1xcblx0XHR2ZWMyIHRleGVsU2l6ZSA9IHZlYzIoIDEuMCApIC8gc2hhZG93TWFwU2l6ZTtcXG5cdFx0dmVjMyBsaWdodFRvUG9zaXRpb24gPSBzaGFkb3dDb29yZC54eXo7XFxuXHRcdHZlYzMgYmQzRCA9IG5vcm1hbGl6ZSggbGlnaHRUb1Bvc2l0aW9uICk7XFxuXHRcdGZsb2F0IGRwID0gKCBsZW5ndGgoIGxpZ2h0VG9Qb3NpdGlvbiApIC0gc2hhZG93QmlhcyApIC8gMTAwMC4wO1xcblx0XHQjaWYgZGVmaW5lZCggU0hBRE9XTUFQX1RZUEVfUENGICkgfHwgZGVmaW5lZCggU0hBRE9XTUFQX1RZUEVfUENGX1NPRlQgKVxcblx0XHRcdHZlYzMgb2Zmc2V0ID0gdmVjMyggLSAxLCAwLCAxICkgKiBzaGFkb3dSYWRpdXMgKiAyLjAgKiB0ZXhlbFNpemUueTtcXG5cdFx0XHRyZXR1cm4gKFxcblx0XHRcdFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC56enosIHRleGVsU2l6ZS55ICksIGRwICkgK1xcblx0XHRcdFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC56eHosIHRleGVsU2l6ZS55ICksIGRwICkgK1xcblx0XHRcdFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC54eHosIHRleGVsU2l6ZS55ICksIGRwICkgK1xcblx0XHRcdFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC54enosIHRleGVsU2l6ZS55ICksIGRwICkgK1xcblx0XHRcdFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC56engsIHRleGVsU2l6ZS55ICksIGRwICkgK1xcblx0XHRcdFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC56eHgsIHRleGVsU2l6ZS55ICksIGRwICkgK1xcblx0XHRcdFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC54eHgsIHRleGVsU2l6ZS55ICksIGRwICkgK1xcblx0XHRcdFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC54engsIHRleGVsU2l6ZS55ICksIGRwICkgK1xcblx0XHRcdFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC56enksIHRleGVsU2l6ZS55ICksIGRwICkgK1xcblx0XHRcdFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC56eHksIHRleGVsU2l6ZS55ICksIGRwICkgK1xcblx0XHRcdFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCwgdGV4ZWxTaXplLnkgKSwgZHAgKSArXFxuXHRcdFx0XHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNEICsgb2Zmc2V0Lnh4eSwgdGV4ZWxTaXplLnkgKSwgZHAgKSArXFxuXHRcdFx0XHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNEICsgb2Zmc2V0Lnh6eSwgdGV4ZWxTaXplLnkgKSwgZHAgKSArXFxuXHRcdFx0XHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNEICsgb2Zmc2V0Lnp5eiwgdGV4ZWxTaXplLnkgKSwgZHAgKSArXFxuXHRcdFx0XHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNEICsgb2Zmc2V0Lnh5eiwgdGV4ZWxTaXplLnkgKSwgZHAgKSArXFxuXHRcdFx0XHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNEICsgb2Zmc2V0Lnp5eCwgdGV4ZWxTaXplLnkgKSwgZHAgKSArXFxuXHRcdFx0XHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNEICsgb2Zmc2V0Lnh5eCwgdGV4ZWxTaXplLnkgKSwgZHAgKSArXFxuXHRcdFx0XHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNEICsgb2Zmc2V0Lnl6eiwgdGV4ZWxTaXplLnkgKSwgZHAgKSArXFxuXHRcdFx0XHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNEICsgb2Zmc2V0Lnl4eiwgdGV4ZWxTaXplLnkgKSwgZHAgKSArXFxuXHRcdFx0XHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNEICsgb2Zmc2V0Lnl4eCwgdGV4ZWxTaXplLnkgKSwgZHAgKSArXFxuXHRcdFx0XHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNEICsgb2Zmc2V0Lnl6eCwgdGV4ZWxTaXplLnkgKSwgZHAgKVxcblx0XHRcdCkgKiAoIDEuMCAvIDIxLjAgKTtcXG5cdFx0I2Vsc2VcXG5cdFx0XHRyZXR1cm4gdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCwgdGV4ZWxTaXplLnkgKSwgZHAgKTtcXG5cdFx0I2VuZGlmXFxuXHR9XFxuI2VuZGlmXFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9zaGFkb3dtYXBfcGFyc192ZXJ0ZXguZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdzaGFkb3dtYXBfcGFyc192ZXJ0ZXgnIF0gPSBcIiNpZmRlZiBVU0VfU0hBRE9XTUFQXFxuXHQjaWYgTlVNX0RJUl9MSUdIVFMgPiAwXFxuXHRcdHVuaWZvcm0gbWF0NCBkaXJlY3Rpb25hbFNoYWRvd01hdHJpeFsgTlVNX0RJUl9MSUdIVFMgXTtcXG5cdFx0dmFyeWluZyB2ZWM0IHZEaXJlY3Rpb25hbFNoYWRvd0Nvb3JkWyBOVU1fRElSX0xJR0hUUyBdO1xcblx0I2VuZGlmXFxuXHQjaWYgTlVNX1NQT1RfTElHSFRTID4gMFxcblx0XHR1bmlmb3JtIG1hdDQgc3BvdFNoYWRvd01hdHJpeFsgTlVNX1NQT1RfTElHSFRTIF07XFxuXHRcdHZhcnlpbmcgdmVjNCB2U3BvdFNoYWRvd0Nvb3JkWyBOVU1fU1BPVF9MSUdIVFMgXTtcXG5cdCNlbmRpZlxcblx0I2lmIE5VTV9QT0lOVF9MSUdIVFMgPiAwXFxuXHRcdHVuaWZvcm0gbWF0NCBwb2ludFNoYWRvd01hdHJpeFsgTlVNX1BPSU5UX0xJR0hUUyBdO1xcblx0XHR2YXJ5aW5nIHZlYzQgdlBvaW50U2hhZG93Q29vcmRbIE5VTV9QT0lOVF9MSUdIVFMgXTtcXG5cdCNlbmRpZlxcbiNlbmRpZlxcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvc2hhZG93bWFwX3ZlcnRleC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ3NoYWRvd21hcF92ZXJ0ZXgnIF0gPSBcIiNpZmRlZiBVU0VfU0hBRE9XTUFQXFxuXHQjaWYgTlVNX0RJUl9MSUdIVFMgPiAwXFxuXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fRElSX0xJR0hUUzsgaSArKyApIHtcXG5cdFx0dkRpcmVjdGlvbmFsU2hhZG93Q29vcmRbIGkgXSA9IGRpcmVjdGlvbmFsU2hhZG93TWF0cml4WyBpIF0gKiB3b3JsZFBvc2l0aW9uO1xcblx0fVxcblx0I2VuZGlmXFxuXHQjaWYgTlVNX1NQT1RfTElHSFRTID4gMFxcblx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX1NQT1RfTElHSFRTOyBpICsrICkge1xcblx0XHR2U3BvdFNoYWRvd0Nvb3JkWyBpIF0gPSBzcG90U2hhZG93TWF0cml4WyBpIF0gKiB3b3JsZFBvc2l0aW9uO1xcblx0fVxcblx0I2VuZGlmXFxuXHQjaWYgTlVNX1BPSU5UX0xJR0hUUyA+IDBcXG5cdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9QT0lOVF9MSUdIVFM7IGkgKysgKSB7XFxuXHRcdHZQb2ludFNoYWRvd0Nvb3JkWyBpIF0gPSBwb2ludFNoYWRvd01hdHJpeFsgaSBdICogd29ybGRQb3NpdGlvbjtcXG5cdH1cXG5cdCNlbmRpZlxcbiNlbmRpZlxcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvc2hhZG93bWFza19wYXJzX2ZyYWdtZW50Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnc2hhZG93bWFza19wYXJzX2ZyYWdtZW50JyBdID0gXCJmbG9hdCBnZXRTaGFkb3dNYXNrKCkge1xcblx0ZmxvYXQgc2hhZG93ID0gMS4wO1xcblx0I2lmZGVmIFVTRV9TSEFET1dNQVBcXG5cdCNpZiBOVU1fRElSX0xJR0hUUyA+IDBcXG5cdERpcmVjdGlvbmFsTGlnaHQgZGlyZWN0aW9uYWxMaWdodDtcXG5cdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9ESVJfTElHSFRTOyBpICsrICkge1xcblx0XHRkaXJlY3Rpb25hbExpZ2h0ID0gZGlyZWN0aW9uYWxMaWdodHNbIGkgXTtcXG5cdFx0c2hhZG93ICo9IGJvb2woIGRpcmVjdGlvbmFsTGlnaHQuc2hhZG93ICkgPyBnZXRTaGFkb3coIGRpcmVjdGlvbmFsU2hhZG93TWFwWyBpIF0sIGRpcmVjdGlvbmFsTGlnaHQuc2hhZG93TWFwU2l6ZSwgZGlyZWN0aW9uYWxMaWdodC5zaGFkb3dCaWFzLCBkaXJlY3Rpb25hbExpZ2h0LnNoYWRvd1JhZGl1cywgdkRpcmVjdGlvbmFsU2hhZG93Q29vcmRbIGkgXSApIDogMS4wO1xcblx0fVxcblx0I2VuZGlmXFxuXHQjaWYgTlVNX1NQT1RfTElHSFRTID4gMFxcblx0U3BvdExpZ2h0IHNwb3RMaWdodDtcXG5cdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9TUE9UX0xJR0hUUzsgaSArKyApIHtcXG5cdFx0c3BvdExpZ2h0ID0gc3BvdExpZ2h0c1sgaSBdO1xcblx0XHRzaGFkb3cgKj0gYm9vbCggc3BvdExpZ2h0LnNoYWRvdyApID8gZ2V0U2hhZG93KCBzcG90U2hhZG93TWFwWyBpIF0sIHNwb3RMaWdodC5zaGFkb3dNYXBTaXplLCBzcG90TGlnaHQuc2hhZG93Qmlhcywgc3BvdExpZ2h0LnNoYWRvd1JhZGl1cywgdlNwb3RTaGFkb3dDb29yZFsgaSBdICkgOiAxLjA7XFxuXHR9XFxuXHQjZW5kaWZcXG5cdCNpZiBOVU1fUE9JTlRfTElHSFRTID4gMFxcblx0UG9pbnRMaWdodCBwb2ludExpZ2h0O1xcblx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX1BPSU5UX0xJR0hUUzsgaSArKyApIHtcXG5cdFx0cG9pbnRMaWdodCA9IHBvaW50TGlnaHRzWyBpIF07XFxuXHRcdHNoYWRvdyAqPSBib29sKCBwb2ludExpZ2h0LnNoYWRvdyApID8gZ2V0UG9pbnRTaGFkb3coIHBvaW50U2hhZG93TWFwWyBpIF0sIHBvaW50TGlnaHQuc2hhZG93TWFwU2l6ZSwgcG9pbnRMaWdodC5zaGFkb3dCaWFzLCBwb2ludExpZ2h0LnNoYWRvd1JhZGl1cywgdlBvaW50U2hhZG93Q29vcmRbIGkgXSApIDogMS4wO1xcblx0fVxcblx0I2VuZGlmXFxuXHQjZW5kaWZcXG5cdHJldHVybiBzaGFkb3c7XFxufVxcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvc2tpbmJhc2VfdmVydGV4Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnc2tpbmJhc2VfdmVydGV4JyBdID0gXCIjaWZkZWYgVVNFX1NLSU5OSU5HXFxuXHRtYXQ0IGJvbmVNYXRYID0gZ2V0Qm9uZU1hdHJpeCggc2tpbkluZGV4LnggKTtcXG5cdG1hdDQgYm9uZU1hdFkgPSBnZXRCb25lTWF0cml4KCBza2luSW5kZXgueSApO1xcblx0bWF0NCBib25lTWF0WiA9IGdldEJvbmVNYXRyaXgoIHNraW5JbmRleC56ICk7XFxuXHRtYXQ0IGJvbmVNYXRXID0gZ2V0Qm9uZU1hdHJpeCggc2tpbkluZGV4LncgKTtcXG4jZW5kaWZcIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3NraW5uaW5nX3BhcnNfdmVydGV4Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnc2tpbm5pbmdfcGFyc192ZXJ0ZXgnIF0gPSBcIiNpZmRlZiBVU0VfU0tJTk5JTkdcXG5cdHVuaWZvcm0gbWF0NCBiaW5kTWF0cml4O1xcblx0dW5pZm9ybSBtYXQ0IGJpbmRNYXRyaXhJbnZlcnNlO1xcblx0I2lmZGVmIEJPTkVfVEVYVFVSRVxcblx0XHR1bmlmb3JtIHNhbXBsZXIyRCBib25lVGV4dHVyZTtcXG5cdFx0dW5pZm9ybSBpbnQgYm9uZVRleHR1cmVXaWR0aDtcXG5cdFx0dW5pZm9ybSBpbnQgYm9uZVRleHR1cmVIZWlnaHQ7XFxuXHRcdG1hdDQgZ2V0Qm9uZU1hdHJpeCggY29uc3QgaW4gZmxvYXQgaSApIHtcXG5cdFx0XHRmbG9hdCBqID0gaSAqIDQuMDtcXG5cdFx0XHRmbG9hdCB4ID0gbW9kKCBqLCBmbG9hdCggYm9uZVRleHR1cmVXaWR0aCApICk7XFxuXHRcdFx0ZmxvYXQgeSA9IGZsb29yKCBqIC8gZmxvYXQoIGJvbmVUZXh0dXJlV2lkdGggKSApO1xcblx0XHRcdGZsb2F0IGR4ID0gMS4wIC8gZmxvYXQoIGJvbmVUZXh0dXJlV2lkdGggKTtcXG5cdFx0XHRmbG9hdCBkeSA9IDEuMCAvIGZsb2F0KCBib25lVGV4dHVyZUhlaWdodCApO1xcblx0XHRcdHkgPSBkeSAqICggeSArIDAuNSApO1xcblx0XHRcdHZlYzQgdjEgPSB0ZXh0dXJlMkQoIGJvbmVUZXh0dXJlLCB2ZWMyKCBkeCAqICggeCArIDAuNSApLCB5ICkgKTtcXG5cdFx0XHR2ZWM0IHYyID0gdGV4dHVyZTJEKCBib25lVGV4dHVyZSwgdmVjMiggZHggKiAoIHggKyAxLjUgKSwgeSApICk7XFxuXHRcdFx0dmVjNCB2MyA9IHRleHR1cmUyRCggYm9uZVRleHR1cmUsIHZlYzIoIGR4ICogKCB4ICsgMi41ICksIHkgKSApO1xcblx0XHRcdHZlYzQgdjQgPSB0ZXh0dXJlMkQoIGJvbmVUZXh0dXJlLCB2ZWMyKCBkeCAqICggeCArIDMuNSApLCB5ICkgKTtcXG5cdFx0XHRtYXQ0IGJvbmUgPSBtYXQ0KCB2MSwgdjIsIHYzLCB2NCApO1xcblx0XHRcdHJldHVybiBib25lO1xcblx0XHR9XFxuXHQjZWxzZVxcblx0XHR1bmlmb3JtIG1hdDQgYm9uZUdsb2JhbE1hdHJpY2VzWyBNQVhfQk9ORVMgXTtcXG5cdFx0bWF0NCBnZXRCb25lTWF0cml4KCBjb25zdCBpbiBmbG9hdCBpICkge1xcblx0XHRcdG1hdDQgYm9uZSA9IGJvbmVHbG9iYWxNYXRyaWNlc1sgaW50KGkpIF07XFxuXHRcdFx0cmV0dXJuIGJvbmU7XFxuXHRcdH1cXG5cdCNlbmRpZlxcbiNlbmRpZlxcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvc2tpbm5pbmdfdmVydGV4Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAnc2tpbm5pbmdfdmVydGV4JyBdID0gXCIjaWZkZWYgVVNFX1NLSU5OSU5HXFxuXHR2ZWM0IHNraW5WZXJ0ZXggPSBiaW5kTWF0cml4ICogdmVjNCggdHJhbnNmb3JtZWQsIDEuMCApO1xcblx0dmVjNCBza2lubmVkID0gdmVjNCggMC4wICk7XFxuXHRza2lubmVkICs9IGJvbmVNYXRYICogc2tpblZlcnRleCAqIHNraW5XZWlnaHQueDtcXG5cdHNraW5uZWQgKz0gYm9uZU1hdFkgKiBza2luVmVydGV4ICogc2tpbldlaWdodC55O1xcblx0c2tpbm5lZCArPSBib25lTWF0WiAqIHNraW5WZXJ0ZXggKiBza2luV2VpZ2h0Lno7XFxuXHRza2lubmVkICs9IGJvbmVNYXRXICogc2tpblZlcnRleCAqIHNraW5XZWlnaHQudztcXG5cdHNraW5uZWQgID0gYmluZE1hdHJpeEludmVyc2UgKiBza2lubmVkO1xcbiNlbmRpZlxcblwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvc2tpbm5vcm1hbF92ZXJ0ZXguZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdza2lubm9ybWFsX3ZlcnRleCcgXSA9IFwiI2lmZGVmIFVTRV9TS0lOTklOR1xcblx0bWF0NCBza2luTWF0cml4ID0gbWF0NCggMC4wICk7XFxuXHRza2luTWF0cml4ICs9IHNraW5XZWlnaHQueCAqIGJvbmVNYXRYO1xcblx0c2tpbk1hdHJpeCArPSBza2luV2VpZ2h0LnkgKiBib25lTWF0WTtcXG5cdHNraW5NYXRyaXggKz0gc2tpbldlaWdodC56ICogYm9uZU1hdFo7XFxuXHRza2luTWF0cml4ICs9IHNraW5XZWlnaHQudyAqIGJvbmVNYXRXO1xcblx0c2tpbk1hdHJpeCAgPSBiaW5kTWF0cml4SW52ZXJzZSAqIHNraW5NYXRyaXggKiBiaW5kTWF0cml4O1xcblx0b2JqZWN0Tm9ybWFsID0gdmVjNCggc2tpbk1hdHJpeCAqIHZlYzQoIG9iamVjdE5vcm1hbCwgMC4wICkgKS54eXo7XFxuI2VuZGlmXFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9zcGVjdWxhcm1hcF9mcmFnbWVudC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ3NwZWN1bGFybWFwX2ZyYWdtZW50JyBdID0gXCJmbG9hdCBzcGVjdWxhclN0cmVuZ3RoO1xcbiNpZmRlZiBVU0VfU1BFQ1VMQVJNQVBcXG5cdHZlYzQgdGV4ZWxTcGVjdWxhciA9IHRleHR1cmUyRCggc3BlY3VsYXJNYXAsIHZVdiApO1xcblx0c3BlY3VsYXJTdHJlbmd0aCA9IHRleGVsU3BlY3VsYXIucjtcXG4jZWxzZVxcblx0c3BlY3VsYXJTdHJlbmd0aCA9IDEuMDtcXG4jZW5kaWZcIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3NwZWN1bGFybWFwX3BhcnNfZnJhZ21lbnQuZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICdzcGVjdWxhcm1hcF9wYXJzX2ZyYWdtZW50JyBdID0gXCIjaWZkZWYgVVNFX1NQRUNVTEFSTUFQXFxuXHR1bmlmb3JtIHNhbXBsZXIyRCBzcGVjdWxhck1hcDtcXG4jZW5kaWZcIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3V2Ml9wYXJzX2ZyYWdtZW50Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAndXYyX3BhcnNfZnJhZ21lbnQnIF0gPSBcIiNpZiBkZWZpbmVkKCBVU0VfTElHSFRNQVAgKSB8fCBkZWZpbmVkKCBVU0VfQU9NQVAgKVxcblx0dmFyeWluZyB2ZWMyIHZVdjI7XFxuI2VuZGlmXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay91djJfcGFyc192ZXJ0ZXguZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICd1djJfcGFyc192ZXJ0ZXgnIF0gPSBcIiNpZiBkZWZpbmVkKCBVU0VfTElHSFRNQVAgKSB8fCBkZWZpbmVkKCBVU0VfQU9NQVAgKVxcblx0YXR0cmlidXRlIHZlYzIgdXYyO1xcblx0dmFyeWluZyB2ZWMyIHZVdjI7XFxuI2VuZGlmXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay91djJfdmVydGV4Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAndXYyX3ZlcnRleCcgXSA9IFwiI2lmIGRlZmluZWQoIFVTRV9MSUdIVE1BUCApIHx8IGRlZmluZWQoIFVTRV9BT01BUCApXFxuXHR2VXYyID0gdXYyO1xcbiNlbmRpZlwiO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvdXZfcGFyc19mcmFnbWVudC5nbHNsXHJcblxyXG5USFJFRS5TaGFkZXJDaHVua1sgJ3V2X3BhcnNfZnJhZ21lbnQnIF0gPSBcIiNpZiBkZWZpbmVkKCBVU0VfTUFQICkgfHwgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQICkgfHwgZGVmaW5lZCggVVNFX1NQRUNVTEFSTUFQICkgfHwgZGVmaW5lZCggVVNFX0FMUEhBTUFQICkgfHwgZGVmaW5lZCggVVNFX0VNSVNTSVZFTUFQICkgfHwgZGVmaW5lZCggVVNFX1JPVUdITkVTU01BUCApIHx8IGRlZmluZWQoIFVTRV9NRVRBTE5FU1NNQVAgKVxcblx0dmFyeWluZyB2ZWMyIHZVdjtcXG4jZW5kaWZcIjtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3V2X3BhcnNfdmVydGV4Lmdsc2xcclxuXHJcblRIUkVFLlNoYWRlckNodW5rWyAndXZfcGFyc192ZXJ0ZXgnIF0gPSBcIiNpZiBkZWZpbmVkKCBVU0VfTUFQICkgfHwgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQICkgfHwgZGVmaW5lZCggVVNFX1NQRUNVTEFSTUFQICkgfHwgZGVmaW5lZCggVVNFX0FMUEhBTUFQICkgfHwgZGVmaW5lZCggVVNFX0VNSVNTSVZFTUFQICkgfHwgZGVmaW5lZCggVVNFX1JPVUdITkVTU01BUCApIHx8IGRlZmluZWQoIFVTRV9NRVRBTE5FU1NNQVAgKVxcblx0dmFyeWluZyB2ZWMyIHZVdjtcXG5cdHVuaWZvcm0gdmVjNCBvZmZzZXRSZXBlYXQ7XFxuI2VuZGlmXFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay91dl92ZXJ0ZXguZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICd1dl92ZXJ0ZXgnIF0gPSBcIiNpZiBkZWZpbmVkKCBVU0VfTUFQICkgfHwgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQICkgfHwgZGVmaW5lZCggVVNFX1NQRUNVTEFSTUFQICkgfHwgZGVmaW5lZCggVVNFX0FMUEhBTUFQICkgfHwgZGVmaW5lZCggVVNFX0VNSVNTSVZFTUFQICkgfHwgZGVmaW5lZCggVVNFX1JPVUdITkVTU01BUCApIHx8IGRlZmluZWQoIFVTRV9NRVRBTE5FU1NNQVAgKVxcblx0dlV2ID0gdXYgKiBvZmZzZXRSZXBlYXQuencgKyBvZmZzZXRSZXBlYXQueHk7XFxuI2VuZGlmXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay93b3JsZHBvc192ZXJ0ZXguZ2xzbFxyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmtbICd3b3JsZHBvc192ZXJ0ZXgnIF0gPSBcIiNpZiBkZWZpbmVkKCBVU0VfRU5WTUFQICkgfHwgZGVmaW5lZCggUEhPTkcgKSB8fCBkZWZpbmVkKCBTVEFOREFSRCApIHx8IGRlZmluZWQoIExBTUJFUlQgKSB8fCBkZWZpbmVkICggVVNFX1NIQURPV01BUCApXFxuXHQjaWZkZWYgVVNFX1NLSU5OSU5HXFxuXHRcdHZlYzQgd29ybGRQb3NpdGlvbiA9IG1vZGVsTWF0cml4ICogc2tpbm5lZDtcXG5cdCNlbHNlXFxuXHRcdHZlYzQgd29ybGRQb3NpdGlvbiA9IG1vZGVsTWF0cml4ICogdmVjNCggdHJhbnNmb3JtZWQsIDEuMCApO1xcblx0I2VuZGlmXFxuI2VuZGlmXFxuXCI7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9Vbmlmb3Jtc1V0aWxzLmpzXHJcblxyXG4vKipcclxuICogVW5pZm9ybSBVdGlsaXRpZXNcclxuICovXHJcblxyXG5USFJFRS5Vbmlmb3Jtc1V0aWxzID0ge1xyXG5cclxuXHRtZXJnZTogZnVuY3Rpb24gKCB1bmlmb3JtcyApIHtcclxuXHJcblx0XHR2YXIgbWVyZ2VkID0ge307XHJcblxyXG5cdFx0Zm9yICggdmFyIHUgPSAwOyB1IDwgdW5pZm9ybXMubGVuZ3RoOyB1ICsrICkge1xyXG5cclxuXHRcdFx0dmFyIHRtcCA9IHRoaXMuY2xvbmUoIHVuaWZvcm1zWyB1IF0gKTtcclxuXHJcblx0XHRcdGZvciAoIHZhciBwIGluIHRtcCApIHtcclxuXHJcblx0XHRcdFx0bWVyZ2VkWyBwIF0gPSB0bXBbIHAgXTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG1lcmdlZDtcclxuXHJcblx0fSxcclxuXHJcblx0Y2xvbmU6IGZ1bmN0aW9uICggdW5pZm9ybXNfc3JjICkge1xyXG5cclxuXHRcdHZhciB1bmlmb3Jtc19kc3QgPSB7fTtcclxuXHJcblx0XHRmb3IgKCB2YXIgdSBpbiB1bmlmb3Jtc19zcmMgKSB7XHJcblxyXG5cdFx0XHR1bmlmb3Jtc19kc3RbIHUgXSA9IHt9O1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIHAgaW4gdW5pZm9ybXNfc3JjWyB1IF0gKSB7XHJcblxyXG5cdFx0XHRcdHZhciBwYXJhbWV0ZXJfc3JjID0gdW5pZm9ybXNfc3JjWyB1IF1bIHAgXTtcclxuXHJcblx0XHRcdFx0aWYgKCBwYXJhbWV0ZXJfc3JjIGluc3RhbmNlb2YgVEhSRUUuQ29sb3IgfHxcclxuXHRcdFx0XHRcdCBwYXJhbWV0ZXJfc3JjIGluc3RhbmNlb2YgVEhSRUUuVmVjdG9yMiB8fFxyXG5cdFx0XHRcdFx0IHBhcmFtZXRlcl9zcmMgaW5zdGFuY2VvZiBUSFJFRS5WZWN0b3IzIHx8XHJcblx0XHRcdFx0XHQgcGFyYW1ldGVyX3NyYyBpbnN0YW5jZW9mIFRIUkVFLlZlY3RvcjQgfHxcclxuXHRcdFx0XHRcdCBwYXJhbWV0ZXJfc3JjIGluc3RhbmNlb2YgVEhSRUUuTWF0cml4MyB8fFxyXG5cdFx0XHRcdFx0IHBhcmFtZXRlcl9zcmMgaW5zdGFuY2VvZiBUSFJFRS5NYXRyaXg0IHx8XHJcblx0XHRcdFx0XHQgcGFyYW1ldGVyX3NyYyBpbnN0YW5jZW9mIFRIUkVFLlRleHR1cmUgKSB7XHJcblxyXG5cdFx0XHRcdFx0dW5pZm9ybXNfZHN0WyB1IF1bIHAgXSA9IHBhcmFtZXRlcl9zcmMuY2xvbmUoKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggQXJyYXkuaXNBcnJheSggcGFyYW1ldGVyX3NyYyApICkge1xyXG5cclxuXHRcdFx0XHRcdHVuaWZvcm1zX2RzdFsgdSBdWyBwIF0gPSBwYXJhbWV0ZXJfc3JjLnNsaWNlKCk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0dW5pZm9ybXNfZHN0WyB1IF1bIHAgXSA9IHBhcmFtZXRlcl9zcmM7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHVuaWZvcm1zX2RzdDtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1VuaWZvcm1zTGliLmpzXHJcblxyXG4vKipcclxuICogVW5pZm9ybXMgbGlicmFyeSBmb3Igc2hhcmVkIHdlYmdsIHNoYWRlcnNcclxuICovXHJcblxyXG5USFJFRS5Vbmlmb3Jtc0xpYiA9IHtcclxuXHJcblx0Y29tbW9uOiB7XHJcblxyXG5cdFx0XCJkaWZmdXNlXCI6IHsgdHlwZTogXCJjXCIsIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoIDB4ZWVlZWVlICkgfSxcclxuXHRcdFwib3BhY2l0eVwiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMS4wIH0sXHJcblxyXG5cdFx0XCJtYXBcIjogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSxcclxuXHRcdFwib2Zmc2V0UmVwZWF0XCI6IHsgdHlwZTogXCJ2NFwiLCB2YWx1ZTogbmV3IFRIUkVFLlZlY3RvcjQoIDAsIDAsIDEsIDEgKSB9LFxyXG5cclxuXHRcdFwic3BlY3VsYXJNYXBcIjogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSxcclxuXHRcdFwiYWxwaGFNYXBcIjogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSxcclxuXHJcblx0XHRcImVudk1hcFwiOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxyXG5cdFx0XCJmbGlwRW52TWFwXCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAtIDEgfSxcclxuXHRcdFwicmVmbGVjdGl2aXR5XCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxLjAgfSxcclxuXHRcdFwicmVmcmFjdGlvblJhdGlvXCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAwLjk4IH1cclxuXHJcblx0fSxcclxuXHJcblx0YW9tYXA6IHtcclxuXHJcblx0XHRcImFvTWFwXCI6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXHJcblx0XHRcImFvTWFwSW50ZW5zaXR5XCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxIH1cclxuXHJcblx0fSxcclxuXHJcblx0bGlnaHRtYXA6IHtcclxuXHJcblx0XHRcImxpZ2h0TWFwXCI6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXHJcblx0XHRcImxpZ2h0TWFwSW50ZW5zaXR5XCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxIH1cclxuXHJcblx0fSxcclxuXHJcblx0ZW1pc3NpdmVtYXA6IHtcclxuXHJcblx0XHRcImVtaXNzaXZlTWFwXCI6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH1cclxuXHJcblx0fSxcclxuXHJcblx0YnVtcG1hcDoge1xyXG5cclxuXHRcdFwiYnVtcE1hcFwiOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxyXG5cdFx0XCJidW1wU2NhbGVcIjogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEgfVxyXG5cclxuXHR9LFxyXG5cclxuXHRub3JtYWxtYXA6IHtcclxuXHJcblx0XHRcIm5vcm1hbE1hcFwiOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxyXG5cdFx0XCJub3JtYWxTY2FsZVwiOiB7IHR5cGU6IFwidjJcIiwgdmFsdWU6IG5ldyBUSFJFRS5WZWN0b3IyKCAxLCAxICkgfVxyXG5cclxuXHR9LFxyXG5cclxuXHRkaXNwbGFjZW1lbnRtYXA6IHtcclxuXHJcblx0XHRcImRpc3BsYWNlbWVudE1hcFwiOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxyXG5cdFx0XCJkaXNwbGFjZW1lbnRTY2FsZVwiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMSB9LFxyXG5cdFx0XCJkaXNwbGFjZW1lbnRCaWFzXCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAwIH1cclxuXHJcblx0fSxcclxuXHJcblx0cm91Z2huZXNzbWFwOiB7XHJcblxyXG5cdFx0XCJyb3VnaG5lc3NNYXBcIjogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfVxyXG5cclxuXHR9LFxyXG5cclxuXHRtZXRhbG5lc3NtYXA6IHtcclxuXHJcblx0XHRcIm1ldGFsbmVzc01hcFwiOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9XHJcblxyXG5cdH0sXHJcblxyXG5cdGZvZzoge1xyXG5cclxuXHRcdFwiZm9nRGVuc2l0eVwiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMC4wMDAyNSB9LFxyXG5cdFx0XCJmb2dOZWFyXCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxIH0sXHJcblx0XHRcImZvZ0ZhclwiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMjAwMCB9LFxyXG5cdFx0XCJmb2dDb2xvclwiOiB7IHR5cGU6IFwiY1wiLCB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKCAweGZmZmZmZiApIH1cclxuXHJcblx0fSxcclxuXHJcblx0YW1iaWVudDoge1xyXG5cclxuXHRcdFwiYW1iaWVudExpZ2h0Q29sb3JcIjogeyB0eXBlOiBcImZ2XCIsIHZhbHVlOiBbXSB9XHJcblxyXG5cdH0sXHJcblxyXG5cdGxpZ2h0czoge1xyXG5cclxuXHRcdFwiZGlyZWN0aW9uYWxMaWdodHNcIjogeyB0eXBlOiBcInNhXCIsIHZhbHVlOiBbXSwgcHJvcGVydGllczoge1xyXG5cdFx0XHRcImRpcmVjdGlvblwiOiB7IHR5cGU6IFwidjNcIiB9LFxyXG5cdFx0XHRcImNvbG9yXCI6IHsgdHlwZTogXCJjXCIgfSxcclxuXHJcblx0XHRcdFwic2hhZG93XCI6IHsgdHlwZTogXCJpXCIgfSxcclxuXHRcdFx0XCJzaGFkb3dCaWFzXCI6IHsgdHlwZTogXCJmXCIgfSxcclxuXHRcdFx0XCJzaGFkb3dSYWRpdXNcIjogeyB0eXBlOiBcImZcIiB9LFxyXG5cdFx0XHRcInNoYWRvd01hcFNpemVcIjogeyB0eXBlOiBcInYyXCIgfVxyXG5cdFx0fSB9LFxyXG5cclxuXHRcdFwiZGlyZWN0aW9uYWxTaGFkb3dNYXBcIjogeyB0eXBlOiBcInR2XCIsIHZhbHVlOiBbXSB9LFxyXG5cdFx0XCJkaXJlY3Rpb25hbFNoYWRvd01hdHJpeFwiOiB7IHR5cGU6IFwibTR2XCIsIHZhbHVlOiBbXSB9LFxyXG5cclxuXHRcdFwic3BvdExpZ2h0c1wiOiB7IHR5cGU6IFwic2FcIiwgdmFsdWU6IFtdLCBwcm9wZXJ0aWVzOiB7XHJcblx0XHRcdFwiY29sb3JcIjogeyB0eXBlOiBcImNcIiB9LFxyXG5cdFx0XHRcInBvc2l0aW9uXCI6IHsgdHlwZTogXCJ2M1wiIH0sXHJcblx0XHRcdFwiZGlyZWN0aW9uXCI6IHsgdHlwZTogXCJ2M1wiIH0sXHJcblx0XHRcdFwiZGlzdGFuY2VcIjogeyB0eXBlOiBcImZcIiB9LFxyXG5cdFx0XHRcImFuZ2xlQ29zXCI6IHsgdHlwZTogXCJmXCIgfSxcclxuXHRcdFx0XCJleHBvbmVudFwiOiB7IHR5cGU6IFwiZlwiIH0sXHJcblx0XHRcdFwiZGVjYXlcIjogeyB0eXBlOiBcImZcIiB9LFxyXG5cclxuXHRcdFx0XCJzaGFkb3dcIjogeyB0eXBlOiBcImlcIiB9LFxyXG5cdFx0XHRcInNoYWRvd0JpYXNcIjogeyB0eXBlOiBcImZcIiB9LFxyXG5cdFx0XHRcInNoYWRvd1JhZGl1c1wiOiB7IHR5cGU6IFwiZlwiIH0sXHJcblx0XHRcdFwic2hhZG93TWFwU2l6ZVwiOiB7IHR5cGU6IFwidjJcIiB9XHJcblx0XHR9IH0sXHJcblxyXG5cdFx0XCJzcG90U2hhZG93TWFwXCI6IHsgdHlwZTogXCJ0dlwiLCB2YWx1ZTogW10gfSxcclxuXHRcdFwic3BvdFNoYWRvd01hdHJpeFwiOiB7IHR5cGU6IFwibTR2XCIsIHZhbHVlOiBbXSB9LFxyXG5cclxuXHRcdFwicG9pbnRMaWdodHNcIjogeyB0eXBlOiBcInNhXCIsIHZhbHVlOiBbXSwgcHJvcGVydGllczoge1xyXG5cdFx0XHRcImNvbG9yXCI6IHsgdHlwZTogXCJjXCIgfSxcclxuXHRcdFx0XCJwb3NpdGlvblwiOiB7IHR5cGU6IFwidjNcIiB9LFxyXG5cdFx0XHRcImRlY2F5XCI6IHsgdHlwZTogXCJmXCIgfSxcclxuXHRcdFx0XCJkaXN0YW5jZVwiOiB7IHR5cGU6IFwiZlwiIH0sXHJcblxyXG5cdFx0XHRcInNoYWRvd1wiOiB7IHR5cGU6IFwiaVwiIH0sXHJcblx0XHRcdFwic2hhZG93Qmlhc1wiOiB7IHR5cGU6IFwiZlwiIH0sXHJcblx0XHRcdFwic2hhZG93UmFkaXVzXCI6IHsgdHlwZTogXCJmXCIgfSxcclxuXHRcdFx0XCJzaGFkb3dNYXBTaXplXCI6IHsgdHlwZTogXCJ2MlwiIH1cclxuXHRcdH0gfSxcclxuXHJcblx0XHRcInBvaW50U2hhZG93TWFwXCI6IHsgdHlwZTogXCJ0dlwiLCB2YWx1ZTogW10gfSxcclxuXHRcdFwicG9pbnRTaGFkb3dNYXRyaXhcIjogeyB0eXBlOiBcIm00dlwiLCB2YWx1ZTogW10gfSxcclxuXHJcblx0XHRcImhlbWlzcGhlcmVMaWdodHNcIjogeyB0eXBlOiBcInNhXCIsIHZhbHVlOiBbXSwgcHJvcGVydGllczoge1xyXG5cdFx0XHRcImRpcmVjdGlvblwiOiB7IHR5cGU6IFwidjNcIiB9LFxyXG5cdFx0XHRcInNreUNvbG9yXCI6IHsgdHlwZTogXCJjXCIgfSxcclxuXHRcdFx0XCJncm91bmRDb2xvclwiOiB7IHR5cGU6IFwiY1wiIH1cclxuXHRcdH0gfVxyXG5cclxuXHR9LFxyXG5cclxuXHRwb2ludHM6IHtcclxuXHJcblx0XHRcImRpZmZ1c2VcIjogeyB0eXBlOiBcImNcIiwgdmFsdWU6IG5ldyBUSFJFRS5Db2xvciggMHhlZWVlZWUgKSB9LFxyXG5cdFx0XCJvcGFjaXR5XCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxLjAgfSxcclxuXHRcdFwic2l6ZVwiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMS4wIH0sXHJcblx0XHRcInNjYWxlXCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxLjAgfSxcclxuXHRcdFwibWFwXCI6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXHJcblx0XHRcIm9mZnNldFJlcGVhdFwiOiB7IHR5cGU6IFwidjRcIiwgdmFsdWU6IG5ldyBUSFJFRS5WZWN0b3I0KCAwLCAwLCAxLCAxICkgfVxyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyTGliLmpzXHJcblxyXG4vKipcclxuICogV2ViZ2wgU2hhZGVyIExpYnJhcnkgZm9yIHRocmVlLmpzXHJcbiAqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXHJcbiAqL1xyXG5cclxuXHJcblRIUkVFLlNoYWRlckxpYiA9IHtcclxuXHJcblx0J2Jhc2ljJzoge1xyXG5cclxuXHRcdHVuaWZvcm1zOiBUSFJFRS5Vbmlmb3Jtc1V0aWxzLm1lcmdlKCBbXHJcblxyXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJjb21tb25cIiBdLFxyXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJhb21hcFwiIF0sXHJcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcImZvZ1wiIF1cclxuXHJcblx0XHRdICksXHJcblxyXG5cdFx0dmVydGV4U2hhZGVyOiBbXHJcblxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJ1dl9wYXJzX3ZlcnRleFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInV2Ml9wYXJzX3ZlcnRleFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF9wYXJzX3ZlcnRleFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3BhcnNfdmVydGV4XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubmluZ19wYXJzX3ZlcnRleFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9wYXJzX3ZlcnRleFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4XCIgXSxcclxuXHJcblx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxyXG5cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJ1dl92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInV2Ml92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbmJhc2VfdmVydGV4XCIgXSxcclxuXHJcblx0XHRcdFwiXHQjaWZkZWYgVVNFX0VOVk1BUFwiLFxyXG5cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJiZWdpbm5vcm1hbF92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBobm9ybWFsX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbm5vcm1hbF92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImRlZmF1bHRub3JtYWxfdmVydGV4XCIgXSxcclxuXHJcblx0XHRcdFwiXHQjZW5kaWZcIixcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYmVnaW5fdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5uaW5nX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwicHJvamVjdF92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3ZlcnRleFwiIF0sXHJcblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIndvcmxkcG9zX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW52bWFwX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX3ZlcnRleFwiIF0sXHJcblxyXG5cdFx0XHRcIn1cIlxyXG5cclxuXHRcdF0uam9pbiggXCJcXG5cIiApLFxyXG5cclxuXHRcdGZyYWdtZW50U2hhZGVyOiBbXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gdmVjMyBkaWZmdXNlO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcIixcclxuXHJcblx0XHRcdFwiI2lmbmRlZiBGTEFUX1NIQURFRFwiLFxyXG5cclxuXHRcdFx0XCJcdHZhcnlpbmcgdmVjMyB2Tm9ybWFsO1wiLFxyXG5cclxuXHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJ1dl9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwidXYyX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtYXBfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImFscGhhbWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJhb21hcF9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW52bWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJmb2dfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic3BlY3VsYXJtYXBfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cclxuXHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXHJcblxyXG5cdFx0XHRcIlx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7XCIsXHJcblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtYXBfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJhbHBoYW1hcF9mcmFnbWVudFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYWxwaGF0ZXN0X2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzcGVjdWxhcm1hcF9mcmFnbWVudFwiIF0sXHJcblxyXG5cdFx0XHRcIlx0UmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQ7XCIsXHJcblx0XHRcdFwiXHRyZWZsZWN0ZWRMaWdodC5kaXJlY3REaWZmdXNlID0gdmVjMyggMC4wICk7XCIsXHJcblx0XHRcdFwiXHRyZWZsZWN0ZWRMaWdodC5kaXJlY3RTcGVjdWxhciA9IHZlYzMoIDAuMCApO1wiLFxyXG5cdFx0XHRcIlx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlID0gZGlmZnVzZUNvbG9yLnJnYjtcIixcclxuXHRcdFx0XCJcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0U3BlY3VsYXIgPSB2ZWMzKCAwLjAgKTtcIixcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYW9tYXBfZnJhZ21lbnRcIiBdLFxyXG5cclxuXHRcdFx0XCJcdHZlYzMgb3V0Z29pbmdMaWdodCA9IHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZTtcIixcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW52bWFwX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsaW5lYXJfdG9fZ2FtbWFfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImZvZ19mcmFnbWVudFwiIF0sXHJcblxyXG5cdFx0XHRcIlx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggb3V0Z29pbmdMaWdodCwgZGlmZnVzZUNvbG9yLmEgKTtcIixcclxuXHJcblx0XHRcdFwifVwiXHJcblxyXG5cdFx0XS5qb2luKCBcIlxcblwiIClcclxuXHJcblx0fSxcclxuXHJcblx0J2xhbWJlcnQnOiB7XHJcblxyXG5cdFx0dW5pZm9ybXM6IFRIUkVFLlVuaWZvcm1zVXRpbHMubWVyZ2UoIFtcclxuXHJcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcImNvbW1vblwiIF0sXHJcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcImFvbWFwXCIgXSxcclxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwibGlnaHRtYXBcIiBdLFxyXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJlbWlzc2l2ZW1hcFwiIF0sXHJcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcImZvZ1wiIF0sXHJcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcImFtYmllbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJsaWdodHNcIiBdLFxyXG5cclxuXHRcdFx0e1xyXG5cdFx0XHRcdFwiZW1pc3NpdmVcIiA6IHsgdHlwZTogXCJjXCIsIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoIDB4MDAwMDAwICkgfVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XSApLFxyXG5cclxuXHRcdHZlcnRleFNoYWRlcjogW1xyXG5cclxuXHRcdFx0XCIjZGVmaW5lIExBTUJFUlRcIixcclxuXHJcblx0XHRcdFwidmFyeWluZyB2ZWMzIHZMaWdodEZyb250O1wiLFxyXG5cclxuXHRcdFx0XCIjaWZkZWYgRE9VQkxFX1NJREVEXCIsXHJcblxyXG5cdFx0XHRcIlx0dmFyeWluZyB2ZWMzIHZMaWdodEJhY2s7XCIsXHJcblxyXG5cdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwidXZfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJ1djJfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJic2Rmc1wiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0c19wYXJzXCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF9wYXJzX3ZlcnRleFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5uaW5nX3BhcnNfdmVydGV4XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX3BhcnNfdmVydGV4XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cclxuXHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXHJcblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInV2X3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwidXYyX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfdmVydGV4XCIgXSxcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYmVnaW5ub3JtYWxfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaG5vcm1hbF92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5iYXNlX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbm5vcm1hbF92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImRlZmF1bHRub3JtYWxfdmVydGV4XCIgXSxcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYmVnaW5fdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5uaW5nX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwicHJvamVjdF92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3ZlcnRleFwiIF0sXHJcblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIndvcmxkcG9zX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW52bWFwX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRzX2xhbWJlcnRfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfdmVydGV4XCIgXSxcclxuXHJcblx0XHRcdFwifVwiXHJcblxyXG5cdFx0XS5qb2luKCBcIlxcblwiICksXHJcblxyXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IFtcclxuXHJcblx0XHRcdFwidW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XCIsXHJcblx0XHRcdFwidW5pZm9ybSB2ZWMzIGVtaXNzaXZlO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcIixcclxuXHJcblx0XHRcdFwidmFyeWluZyB2ZWMzIHZMaWdodEZyb250O1wiLFxyXG5cclxuXHRcdFx0XCIjaWZkZWYgRE9VQkxFX1NJREVEXCIsXHJcblxyXG5cdFx0XHRcIlx0dmFyeWluZyB2ZWMzIHZMaWdodEJhY2s7XCIsXHJcblxyXG5cdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInV2X3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJ1djJfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYWxwaGFtYXBfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImFvbWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodG1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW1pc3NpdmVtYXBfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYnNkZnNcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJhbWJpZW50X3BhcnNcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodHNfcGFyc1wiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImZvZ19wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXNrX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzcGVjdWxhcm1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc19mcmFnbWVudFwiIF0sXHJcblxyXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcclxuXHJcblx0XHRcdFwiXHR2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTtcIixcclxuXHRcdFx0XCJcdFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ID0gUmVmbGVjdGVkTGlnaHQoIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICksIHZlYzMoIDAuMCApICk7XCIsXHJcblx0XHRcdFwiXHR2ZWMzIHRvdGFsRW1pc3NpdmVMaWdodCA9IGVtaXNzaXZlO1wiLFxyXG5cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9mcmFnbWVudFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibWFwX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9mcmFnbWVudFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYWxwaGFtYXBfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImFscGhhdGVzdF9mcmFnbWVudFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic3BlY3VsYXJtYXBfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImVtaXNzaXZlbWFwX2ZyYWdtZW50XCIgXSxcclxuXHJcblx0XHRcdFx0Ly8gYWNjdW11bGF0aW9uXHJcblx0XHRcdFwiXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgPSBnZXRBbWJpZW50TGlnaHRJcnJhZGlhbmNlKCBhbWJpZW50TGlnaHRDb2xvciApO1wiLFxyXG5cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodG1hcF9mcmFnbWVudFwiIF0sXHJcblxyXG5cdFx0XHRcIlx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICo9IEJSREZfRGlmZnVzZV9MYW1iZXJ0KCBkaWZmdXNlQ29sb3IucmdiICk7XCIsXHJcblxyXG5cdFx0XHRcIlx0I2lmZGVmIERPVUJMRV9TSURFRFwiLFxyXG5cclxuXHRcdFx0XCJcdFx0cmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSA9ICggZ2xfRnJvbnRGYWNpbmcgKSA/IHZMaWdodEZyb250IDogdkxpZ2h0QmFjaztcIixcclxuXHJcblx0XHRcdFwiXHQjZWxzZVwiLFxyXG5cclxuXHRcdFx0XCJcdFx0cmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSA9IHZMaWdodEZyb250O1wiLFxyXG5cclxuXHRcdFx0XCJcdCNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XCJcdHJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgKj0gQlJERl9EaWZmdXNlX0xhbWJlcnQoIGRpZmZ1c2VDb2xvci5yZ2IgKSAqIGdldFNoYWRvd01hc2soKTtcIixcclxuXHJcblx0XHRcdFx0Ly8gbW9kdWxhdGlvblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImFvbWFwX2ZyYWdtZW50XCIgXSxcclxuXHJcblx0XHRcdFwiXHR2ZWMzIG91dGdvaW5nTGlnaHQgPSByZWZsZWN0ZWRMaWdodC5kaXJlY3REaWZmdXNlICsgcmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICsgdG90YWxFbWlzc2l2ZUxpZ2h0O1wiLFxyXG5cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfZnJhZ21lbnRcIiBdLFxyXG5cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsaW5lYXJfdG9fZ2FtbWFfZnJhZ21lbnRcIiBdLFxyXG5cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJmb2dfZnJhZ21lbnRcIiBdLFxyXG5cclxuXHRcdFx0XCJcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIG91dGdvaW5nTGlnaHQsIGRpZmZ1c2VDb2xvci5hICk7XCIsXHJcblxyXG5cdFx0XHRcIn1cIlxyXG5cclxuXHRcdF0uam9pbiggXCJcXG5cIiApXHJcblxyXG5cdH0sXHJcblxyXG5cdCdwaG9uZyc6IHtcclxuXHJcblx0XHR1bmlmb3JtczogVEhSRUUuVW5pZm9ybXNVdGlscy5tZXJnZSggW1xyXG5cclxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwiY29tbW9uXCIgXSxcclxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwiYW9tYXBcIiBdLFxyXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJsaWdodG1hcFwiIF0sXHJcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcImVtaXNzaXZlbWFwXCIgXSxcclxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwiYnVtcG1hcFwiIF0sXHJcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcIm5vcm1hbG1hcFwiIF0sXHJcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcImRpc3BsYWNlbWVudG1hcFwiIF0sXHJcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcImZvZ1wiIF0sXHJcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcImFtYmllbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJsaWdodHNcIiBdLFxyXG5cclxuXHRcdFx0e1xyXG5cdFx0XHRcdFwiZW1pc3NpdmVcIiA6IHsgdHlwZTogXCJjXCIsIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoIDB4MDAwMDAwICkgfSxcclxuXHRcdFx0XHRcInNwZWN1bGFyXCIgOiB7IHR5cGU6IFwiY1wiLCB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKCAweDExMTExMSApIH0sXHJcblx0XHRcdFx0XCJzaGluaW5lc3NcIjogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDMwIH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdF0gKSxcclxuXHJcblx0XHR2ZXJ0ZXhTaGFkZXI6IFtcclxuXHJcblx0XHRcdFwiI2RlZmluZSBQSE9OR1wiLFxyXG5cclxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcIixcclxuXHJcblx0XHRcdFwiI2lmbmRlZiBGTEFUX1NIQURFRFwiLFxyXG5cclxuXHRcdFx0XCJcdHZhcnlpbmcgdmVjMyB2Tm9ybWFsO1wiLFxyXG5cclxuXHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInV2X3BhcnNfdmVydGV4XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwidXYyX3BhcnNfdmVydGV4XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZGlzcGxhY2VtZW50bWFwX3BhcnNfdmVydGV4XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW52bWFwX3BhcnNfdmVydGV4XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRzX3Bob25nX3BhcnNfdmVydGV4XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF9wYXJzX3ZlcnRleFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5uaW5nX3BhcnNfdmVydGV4XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX3BhcnNfdmVydGV4XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cclxuXHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXHJcblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInV2X3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwidXYyX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfdmVydGV4XCIgXSxcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYmVnaW5ub3JtYWxfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaG5vcm1hbF92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5iYXNlX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbm5vcm1hbF92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImRlZmF1bHRub3JtYWxfdmVydGV4XCIgXSxcclxuXHJcblx0XHRcdFwiI2lmbmRlZiBGTEFUX1NIQURFRFwiLCAvLyBOb3JtYWwgY29tcHV0ZWQgd2l0aCBkZXJpdmF0aXZlcyB3aGVuIEZMQVRfU0hBREVEXHJcblxyXG5cdFx0XHRcIlx0dk5vcm1hbCA9IG5vcm1hbGl6ZSggdHJhbnNmb3JtZWROb3JtYWwgKTtcIixcclxuXHJcblx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImJlZ2luX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZGlzcGxhY2VtZW50bWFwX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGh0YXJnZXRfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubmluZ192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInByb2plY3RfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl92ZXJ0ZXhcIiBdLFxyXG5cclxuXHRcdFx0XCJcdHZWaWV3UG9zaXRpb24gPSAtIG12UG9zaXRpb24ueHl6O1wiLFxyXG5cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJ3b3JsZHBvc192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0c19waG9uZ192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF92ZXJ0ZXhcIiBdLFxyXG5cclxuXHRcdFx0XCJ9XCJcclxuXHJcblx0XHRdLmpvaW4oIFwiXFxuXCIgKSxcclxuXHJcblx0XHRmcmFnbWVudFNoYWRlcjogW1xyXG5cclxuXHRcdFx0XCIjZGVmaW5lIFBIT05HXCIsXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gdmVjMyBkaWZmdXNlO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gdmVjMyBlbWlzc2l2ZTtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIHZlYzMgc3BlY3VsYXI7XCIsXHJcblx0XHRcdFwidW5pZm9ybSBmbG9hdCBzaGluaW5lc3M7XCIsXHJcblx0XHRcdFwidW5pZm9ybSBmbG9hdCBvcGFjaXR5O1wiLFxyXG5cclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInV2X3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJ1djJfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYWxwaGFtYXBfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImFvbWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodG1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW1pc3NpdmVtYXBfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZm9nX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJic2Rmc1wiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImFtYmllbnRfcGFyc1wiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0c19wYXJzXCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRzX3Bob25nX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImJ1bXBtYXBfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm5vcm1hbG1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic3BlY3VsYXJtYXBfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cclxuXHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXHJcblxyXG5cdFx0XHRcIlx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7XCIsXHJcblx0XHRcdFwiXHRSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCA9IFJlZmxlY3RlZExpZ2h0KCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICksIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSApO1wiLFxyXG5cdFx0XHRcIlx0dmVjMyB0b3RhbEVtaXNzaXZlTGlnaHQgPSBlbWlzc2l2ZTtcIixcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1hcF9mcmFnbWVudFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImFscGhhbWFwX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJhbHBoYXRlc3RfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNwZWN1bGFybWFwX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJub3JtYWxfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImVtaXNzaXZlbWFwX2ZyYWdtZW50XCIgXSxcclxuXHJcblx0XHRcdFx0Ly8gYWNjdW11bGF0aW9uXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRzX3Bob25nX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodHNfdGVtcGxhdGVcIiBdLFxyXG5cclxuXHRcdFx0XHQvLyBtb2R1bGF0aW9uXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYW9tYXBfZnJhZ21lbnRcIiBdLFxyXG5cclxuXHRcdFx0XHRcInZlYzMgb3V0Z29pbmdMaWdodCA9IHJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgKyByZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKyByZWZsZWN0ZWRMaWdodC5kaXJlY3RTcGVjdWxhciArIHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0U3BlY3VsYXIgKyB0b3RhbEVtaXNzaXZlTGlnaHQ7XCIsXHJcblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF9mcmFnbWVudFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibGluZWFyX3RvX2dhbW1hX2ZyYWdtZW50XCIgXSxcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZm9nX2ZyYWdtZW50XCIgXSxcclxuXHJcblx0XHRcdFwiXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCBvdXRnb2luZ0xpZ2h0LCBkaWZmdXNlQ29sb3IuYSApO1wiLFxyXG5cclxuXHRcdFx0XCJ9XCJcclxuXHJcblx0XHRdLmpvaW4oIFwiXFxuXCIgKVxyXG5cclxuXHR9LFxyXG5cclxuXHQnc3RhbmRhcmQnOiB7XHJcblxyXG5cdFx0dW5pZm9ybXM6IFRIUkVFLlVuaWZvcm1zVXRpbHMubWVyZ2UoIFtcclxuXHJcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcImNvbW1vblwiIF0sXHJcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcImFvbWFwXCIgXSxcclxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwibGlnaHRtYXBcIiBdLFxyXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJlbWlzc2l2ZW1hcFwiIF0sXHJcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcImJ1bXBtYXBcIiBdLFxyXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJub3JtYWxtYXBcIiBdLFxyXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJkaXNwbGFjZW1lbnRtYXBcIiBdLFxyXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJyb3VnaG5lc3NtYXBcIiBdLFxyXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJtZXRhbG5lc3NtYXBcIiBdLFxyXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJmb2dcIiBdLFxyXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJhbWJpZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwibGlnaHRzXCIgXSxcclxuXHJcblx0XHRcdHtcclxuXHRcdFx0XHRcImVtaXNzaXZlXCIgOiB7IHR5cGU6IFwiY1wiLCB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKCAweDAwMDAwMCApIH0sXHJcblx0XHRcdFx0XCJyb3VnaG5lc3NcIjogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDAuNSB9LFxyXG5cdFx0XHRcdFwibWV0YWxuZXNzXCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAwIH0sXHJcblx0XHRcdFx0XCJlbnZNYXBJbnRlbnNpdHlcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxIH0gLy8gdGVtcG9yYXJ5XHJcblx0XHRcdH1cclxuXHJcblx0XHRdICksXHJcblxyXG5cdFx0dmVydGV4U2hhZGVyOiBbXHJcblxyXG5cdFx0XHRcIiNkZWZpbmUgU1RBTkRBUkRcIixcclxuXHJcblx0XHRcdFwidmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247XCIsXHJcblxyXG5cdFx0XHRcIiNpZm5kZWYgRkxBVF9TSEFERURcIixcclxuXHJcblx0XHRcdFwiXHR2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcIixcclxuXHJcblx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJ1dl9wYXJzX3ZlcnRleFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInV2Ml9wYXJzX3ZlcnRleFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImRpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF9wYXJzX3ZlcnRleFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3BhcnNfdmVydGV4XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubmluZ19wYXJzX3ZlcnRleFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9wYXJzX3ZlcnRleFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNwZWN1bGFybWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleFwiIF0sXHJcblxyXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIiwgLy8gU1RBTkRBUkRcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwidXZfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJ1djJfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl92ZXJ0ZXhcIiBdLFxyXG5cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJiZWdpbm5vcm1hbF92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBobm9ybWFsX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbmJhc2VfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubm9ybWFsX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZGVmYXVsdG5vcm1hbF92ZXJ0ZXhcIiBdLFxyXG5cclxuXHRcdFx0XCIjaWZuZGVmIEZMQVRfU0hBREVEXCIsIC8vIE5vcm1hbCBjb21wdXRlZCB3aXRoIGRlcml2YXRpdmVzIHdoZW4gRkxBVF9TSEFERURcclxuXHJcblx0XHRcdFwiXHR2Tm9ybWFsID0gbm9ybWFsaXplKCB0cmFuc2Zvcm1lZE5vcm1hbCApO1wiLFxyXG5cclxuXHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYmVnaW5fdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJkaXNwbGFjZW1lbnRtYXBfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5uaW5nX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwicHJvamVjdF92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3ZlcnRleFwiIF0sXHJcblxyXG5cdFx0XHRcIlx0dlZpZXdQb3NpdGlvbiA9IC0gbXZQb3NpdGlvbi54eXo7XCIsXHJcblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIndvcmxkcG9zX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW52bWFwX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX3ZlcnRleFwiIF0sXHJcblxyXG5cdFx0XHRcIn1cIlxyXG5cclxuXHRcdF0uam9pbiggXCJcXG5cIiApLFxyXG5cclxuXHRcdGZyYWdtZW50U2hhZGVyOiBbXHJcblxyXG5cdFx0XHRcIiNkZWZpbmUgU1RBTkRBUkRcIixcclxuXHJcblx0XHRcdFwidW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XCIsXHJcblx0XHRcdFwidW5pZm9ybSB2ZWMzIGVtaXNzaXZlO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgcm91Z2huZXNzO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgbWV0YWxuZXNzO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcIixcclxuXHJcblx0XHRcdFwidW5pZm9ybSBmbG9hdCBlbnZNYXBJbnRlbnNpdHk7XCIsIC8vIHRlbXBvcmFyeVxyXG5cclxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcIixcclxuXHJcblx0XHRcdFwiI2lmbmRlZiBGTEFUX1NIQURFRFwiLFxyXG5cclxuXHRcdFx0XCJcdHZhcnlpbmcgdmVjMyB2Tm9ybWFsO1wiLFxyXG5cclxuXHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJ1dl9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwidXYyX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtYXBfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImFscGhhbWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJhb21hcF9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRtYXBfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImVtaXNzaXZlbWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImZvZ19wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYnNkZnNcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJhbWJpZW50X3BhcnNcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodHNfcGFyc1wiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0c19zdGFuZGFyZF9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJidW1wbWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJub3JtYWxtYXBfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInJvdWdobmVzc21hcF9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibWV0YWxuZXNzbWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHJcblx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxyXG5cclxuXHRcdFx0XCJcdHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApO1wiLFxyXG5cdFx0XHRcIlx0UmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgPSBSZWZsZWN0ZWRMaWdodCggdmVjMyggMC4wICksIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICkgKTtcIixcclxuXHRcdFx0XCJcdHZlYzMgdG90YWxFbWlzc2l2ZUxpZ2h0ID0gZW1pc3NpdmU7XCIsXHJcblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtYXBfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJhbHBoYW1hcF9mcmFnbWVudFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYWxwaGF0ZXN0X2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzcGVjdWxhcm1hcF9mcmFnbWVudFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwicm91Z2huZXNzbWFwX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtZXRhbG5lc3NtYXBfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm5vcm1hbF9mcmFnbWVudFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW1pc3NpdmVtYXBfZnJhZ21lbnRcIiBdLFxyXG5cclxuXHRcdFx0XHQvLyBhY2N1bXVsYXRpb25cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodHNfc3RhbmRhcmRfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0c190ZW1wbGF0ZVwiIF0sXHJcblxyXG5cdFx0XHRcdC8vIG1vZHVsYXRpb25cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJhb21hcF9mcmFnbWVudFwiIF0sXHJcblxyXG5cdFx0XHRcdFwidmVjMyBvdXRnb2luZ0xpZ2h0ID0gcmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSArIHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSArIHJlZmxlY3RlZExpZ2h0LmRpcmVjdFNwZWN1bGFyICsgcmVmbGVjdGVkTGlnaHQuaW5kaXJlY3RTcGVjdWxhciArIHRvdGFsRW1pc3NpdmVMaWdodDtcIixcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibGluZWFyX3RvX2dhbW1hX2ZyYWdtZW50XCIgXSxcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZm9nX2ZyYWdtZW50XCIgXSxcclxuXHJcblx0XHRcdFwiXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCBvdXRnb2luZ0xpZ2h0LCBkaWZmdXNlQ29sb3IuYSApO1wiLFxyXG5cclxuXHRcdFx0XCJ9XCJcclxuXHJcblx0XHRdLmpvaW4oIFwiXFxuXCIgKVxyXG5cclxuXHR9LFxyXG5cclxuXHQncG9pbnRzJzoge1xyXG5cclxuXHRcdHVuaWZvcm1zOiBUSFJFRS5Vbmlmb3Jtc1V0aWxzLm1lcmdlKCBbXHJcblxyXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJwb2ludHNcIiBdLFxyXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJmb2dcIiBdXHJcblxyXG5cdFx0XSApLFxyXG5cclxuXHRcdHZlcnRleFNoYWRlcjogW1xyXG5cclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IHNpemU7XCIsXHJcblx0XHRcdFwidW5pZm9ybSBmbG9hdCBzY2FsZTtcIixcclxuXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3BhcnNfdmVydGV4XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX3BhcnNfdmVydGV4XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cclxuXHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXHJcblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYmVnaW5fdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJwcm9qZWN0X3ZlcnRleFwiIF0sXHJcblxyXG5cdFx0XHRcIlx0I2lmZGVmIFVTRV9TSVpFQVRURU5VQVRJT05cIixcclxuXHRcdFx0XCJcdFx0Z2xfUG9pbnRTaXplID0gc2l6ZSAqICggc2NhbGUgLyAtIG12UG9zaXRpb24ueiApO1wiLFxyXG5cdFx0XHRcIlx0I2Vsc2VcIixcclxuXHRcdFx0XCJcdFx0Z2xfUG9pbnRTaXplID0gc2l6ZTtcIixcclxuXHRcdFx0XCJcdCNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIndvcmxkcG9zX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX3ZlcnRleFwiIF0sXHJcblxyXG5cdFx0XHRcIn1cIlxyXG5cclxuXHRcdF0uam9pbiggXCJcXG5cIiApLFxyXG5cclxuXHRcdGZyYWdtZW50U2hhZGVyOiBbXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gdmVjMyBkaWZmdXNlO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcIixcclxuXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtYXBfcGFydGljbGVfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImZvZ19wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHJcblx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxyXG5cclxuXHRcdFx0XCJcdHZlYzMgb3V0Z29pbmdMaWdodCA9IHZlYzMoIDAuMCApO1wiLFxyXG5cdFx0XHRcIlx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7XCIsXHJcblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtYXBfcGFydGljbGVfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJhbHBoYXRlc3RfZnJhZ21lbnRcIiBdLFxyXG5cclxuXHRcdFx0XCJcdG91dGdvaW5nTGlnaHQgPSBkaWZmdXNlQ29sb3IucmdiO1wiLFxyXG5cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJmb2dfZnJhZ21lbnRcIiBdLFxyXG5cclxuXHRcdFx0XCJcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIG91dGdvaW5nTGlnaHQsIGRpZmZ1c2VDb2xvci5hICk7XCIsXHJcblxyXG5cdFx0XHRcIn1cIlxyXG5cclxuXHRcdF0uam9pbiggXCJcXG5cIiApXHJcblxyXG5cdH0sXHJcblxyXG5cdCdkYXNoZWQnOiB7XHJcblxyXG5cdFx0dW5pZm9ybXM6IFRIUkVFLlVuaWZvcm1zVXRpbHMubWVyZ2UoIFtcclxuXHJcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcImNvbW1vblwiIF0sXHJcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcImZvZ1wiIF0sXHJcblxyXG5cdFx0XHR7XHJcblx0XHRcdFx0XCJzY2FsZVwiICAgIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEgfSxcclxuXHRcdFx0XHRcImRhc2hTaXplXCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMSB9LFxyXG5cdFx0XHRcdFwidG90YWxTaXplXCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAyIH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdF0gKSxcclxuXHJcblx0XHR2ZXJ0ZXhTaGFkZXI6IFtcclxuXHJcblx0XHRcdFwidW5pZm9ybSBmbG9hdCBzY2FsZTtcIixcclxuXHRcdFx0XCJhdHRyaWJ1dGUgZmxvYXQgbGluZURpc3RhbmNlO1wiLFxyXG5cclxuXHRcdFx0XCJ2YXJ5aW5nIGZsb2F0IHZMaW5lRGlzdGFuY2U7XCIsXHJcblxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9wYXJzX3ZlcnRleFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4XCIgXSxcclxuXHJcblx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxyXG5cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl92ZXJ0ZXhcIiBdLFxyXG5cclxuXHRcdFx0XCJcdHZMaW5lRGlzdGFuY2UgPSBzY2FsZSAqIGxpbmVEaXN0YW5jZTtcIixcclxuXHJcblx0XHRcdFwiXHR2ZWM0IG12UG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XCIsXHJcblx0XHRcdFwiXHRnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtdlBvc2l0aW9uO1wiLFxyXG5cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl92ZXJ0ZXhcIiBdLFxyXG5cclxuXHRcdFx0XCJ9XCJcclxuXHJcblx0XHRdLmpvaW4oIFwiXFxuXCIgKSxcclxuXHJcblx0XHRmcmFnbWVudFNoYWRlcjogW1xyXG5cclxuXHRcdFx0XCJ1bmlmb3JtIHZlYzMgZGlmZnVzZTtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IG9wYWNpdHk7XCIsXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgZGFzaFNpemU7XCIsXHJcblx0XHRcdFwidW5pZm9ybSBmbG9hdCB0b3RhbFNpemU7XCIsXHJcblxyXG5cdFx0XHRcInZhcnlpbmcgZmxvYXQgdkxpbmVEaXN0YW5jZTtcIixcclxuXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJmb2dfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cclxuXHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXHJcblxyXG5cdFx0XHRcIlx0aWYgKCBtb2QoIHZMaW5lRGlzdGFuY2UsIHRvdGFsU2l6ZSApID4gZGFzaFNpemUgKSB7XCIsXHJcblxyXG5cdFx0XHRcIlx0XHRkaXNjYXJkO1wiLFxyXG5cclxuXHRcdFx0XCJcdH1cIixcclxuXHJcblx0XHRcdFwiXHR2ZWMzIG91dGdvaW5nTGlnaHQgPSB2ZWMzKCAwLjAgKTtcIixcclxuXHRcdFx0XCJcdHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApO1wiLFxyXG5cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9mcmFnbWVudFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfZnJhZ21lbnRcIiBdLFxyXG5cclxuXHRcdFx0XCJcdG91dGdvaW5nTGlnaHQgPSBkaWZmdXNlQ29sb3IucmdiO1wiLCAvLyBzaW1wbGUgc2hhZGVyXHJcblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImZvZ19mcmFnbWVudFwiIF0sXHJcblxyXG5cdFx0XHRcIlx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggb3V0Z29pbmdMaWdodCwgZGlmZnVzZUNvbG9yLmEgKTtcIixcclxuXHJcblx0XHRcdFwifVwiXHJcblxyXG5cdFx0XS5qb2luKCBcIlxcblwiIClcclxuXHJcblx0fSxcclxuXHJcblx0J2RlcHRoJzoge1xyXG5cclxuXHRcdHVuaWZvcm1zOiB7XHJcblxyXG5cdFx0XHRcIm1OZWFyXCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxLjAgfSxcclxuXHRcdFx0XCJtRmFyXCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMjAwMC4wIH0sXHJcblx0XHRcdFwib3BhY2l0eVwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEuMCB9XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHR2ZXJ0ZXhTaGFkZXI6IFtcclxuXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBodGFyZ2V0X3BhcnNfdmVydGV4XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cclxuXHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXHJcblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImJlZ2luX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGh0YXJnZXRfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJwcm9qZWN0X3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfdmVydGV4XCIgXSxcclxuXHJcblx0XHRcdFwifVwiXHJcblxyXG5cdFx0XS5qb2luKCBcIlxcblwiICksXHJcblxyXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IFtcclxuXHJcblx0XHRcdFwidW5pZm9ybSBmbG9hdCBtTmVhcjtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IG1GYXI7XCIsXHJcblx0XHRcdFwidW5pZm9ybSBmbG9hdCBvcGFjaXR5O1wiLFxyXG5cclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc19mcmFnbWVudFwiIF0sXHJcblxyXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfZnJhZ21lbnRcIiBdLFxyXG5cclxuXHRcdFx0XCJcdCNpZmRlZiBVU0VfTE9HREVQVEhCVUZfRVhUXCIsXHJcblxyXG5cdFx0XHRcIlx0XHRmbG9hdCBkZXB0aCA9IGdsX0ZyYWdEZXB0aEVYVCAvIGdsX0ZyYWdDb29yZC53O1wiLFxyXG5cclxuXHRcdFx0XCJcdCNlbHNlXCIsXHJcblxyXG5cdFx0XHRcIlx0XHRmbG9hdCBkZXB0aCA9IGdsX0ZyYWdDb29yZC56IC8gZ2xfRnJhZ0Nvb3JkLnc7XCIsXHJcblxyXG5cdFx0XHRcIlx0I2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcIlx0ZmxvYXQgY29sb3IgPSAxLjAgLSBzbW9vdGhzdGVwKCBtTmVhciwgbUZhciwgZGVwdGggKTtcIixcclxuXHRcdFx0XCJcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIHZlYzMoIGNvbG9yICksIG9wYWNpdHkgKTtcIixcclxuXHJcblx0XHRcdFwifVwiXHJcblxyXG5cdFx0XS5qb2luKCBcIlxcblwiIClcclxuXHJcblx0fSxcclxuXHJcblx0J25vcm1hbCc6IHtcclxuXHJcblx0XHR1bmlmb3Jtczoge1xyXG5cclxuXHRcdFx0XCJvcGFjaXR5XCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMS4wIH1cclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHZlcnRleFNoYWRlcjogW1xyXG5cclxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcIixcclxuXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBodGFyZ2V0X3BhcnNfdmVydGV4XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cclxuXHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXHJcblxyXG5cdFx0XHRcIlx0dk5vcm1hbCA9IG5vcm1hbGl6ZSggbm9ybWFsTWF0cml4ICogbm9ybWFsICk7XCIsXHJcblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImJlZ2luX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGh0YXJnZXRfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJwcm9qZWN0X3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfdmVydGV4XCIgXSxcclxuXHJcblx0XHRcdFwifVwiXHJcblxyXG5cdFx0XS5qb2luKCBcIlxcblwiICksXHJcblxyXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IFtcclxuXHJcblx0XHRcdFwidW5pZm9ybSBmbG9hdCBvcGFjaXR5O1wiLFxyXG5cdFx0XHRcInZhcnlpbmcgdmVjMyB2Tm9ybWFsO1wiLFxyXG5cclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc19mcmFnbWVudFwiIF0sXHJcblxyXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcclxuXHJcblx0XHRcdFwiXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCAwLjUgKiBub3JtYWxpemUoIHZOb3JtYWwgKSArIDAuNSwgb3BhY2l0eSApO1wiLFxyXG5cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9mcmFnbWVudFwiIF0sXHJcblxyXG5cdFx0XHRcIn1cIlxyXG5cclxuXHRcdF0uam9pbiggXCJcXG5cIiApXHJcblxyXG5cdH0sXHJcblxyXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHQvL1x0Q3ViZSBtYXAgc2hhZGVyXHJcblx0IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cclxuXHJcblx0J2N1YmUnOiB7XHJcblxyXG5cdFx0dW5pZm9ybXM6IHtcclxuXHRcdFx0XCJ0Q3ViZVwiOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxyXG5cdFx0XHRcInRGbGlwXCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAtIDEgfVxyXG5cdFx0fSxcclxuXHJcblx0XHR2ZXJ0ZXhTaGFkZXI6IFtcclxuXHJcblx0XHRcdFwidmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1wiLFxyXG5cclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cclxuXHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXHJcblxyXG5cdFx0XHRcIlx0dldvcmxkUG9zaXRpb24gPSB0cmFuc2Zvcm1EaXJlY3Rpb24oIHBvc2l0aW9uLCBtb2RlbE1hdHJpeCApO1wiLFxyXG5cclxuXHRcdFx0XCJcdGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcIixcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfdmVydGV4XCIgXSxcclxuXHJcblx0XHRcdFwifVwiXHJcblxyXG5cdFx0XS5qb2luKCBcIlxcblwiICksXHJcblxyXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IFtcclxuXHJcblx0XHRcdFwidW5pZm9ybSBzYW1wbGVyQ3ViZSB0Q3ViZTtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IHRGbGlwO1wiLFxyXG5cclxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XCIsXHJcblxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHJcblx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxyXG5cclxuXHRcdFx0XCJcdGdsX0ZyYWdDb2xvciA9IHRleHR1cmVDdWJlKCB0Q3ViZSwgdmVjMyggdEZsaXAgKiB2V29ybGRQb3NpdGlvbi54LCB2V29ybGRQb3NpdGlvbi55eiApICk7XCIsXHJcblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX2ZyYWdtZW50XCIgXSxcclxuXHJcblx0XHRcdFwifVwiXHJcblxyXG5cdFx0XS5qb2luKCBcIlxcblwiIClcclxuXHJcblx0fSxcclxuXHJcblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cdC8vXHRDdWJlIG1hcCBzaGFkZXJcclxuXHQgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG5cclxuXHQnZXF1aXJlY3QnOiB7XHJcblxyXG5cdFx0dW5pZm9ybXM6IHtcclxuXHRcdFx0XCJ0RXF1aXJlY3RcIjogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSxcclxuXHRcdFx0XCJ0RmxpcFwiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogLSAxIH1cclxuXHRcdH0sXHJcblxyXG5cdFx0dmVydGV4U2hhZGVyOiBbXHJcblxyXG5cdFx0XHRcInZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcIixcclxuXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4XCIgXSxcclxuXHJcblx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxyXG5cclxuXHRcdFx0XCJcdHZXb3JsZFBvc2l0aW9uID0gdHJhbnNmb3JtRGlyZWN0aW9uKCBwb3NpdGlvbiwgbW9kZWxNYXRyaXggKTtcIixcclxuXHJcblx0XHRcdFwiXHRnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XCIsXHJcblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3ZlcnRleFwiIF0sXHJcblxyXG5cdFx0XHRcIn1cIlxyXG5cclxuXHRcdF0uam9pbiggXCJcXG5cIiApLFxyXG5cclxuXHRcdGZyYWdtZW50U2hhZGVyOiBbXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gc2FtcGxlcjJEIHRFcXVpcmVjdDtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IHRGbGlwO1wiLFxyXG5cclxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XCIsXHJcblxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHJcblx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxyXG5cclxuXHRcdFx0XHQvLyBcIlx0Z2xfRnJhZ0NvbG9yID0gdGV4dHVyZUN1YmUoIHRDdWJlLCB2ZWMzKCB0RmxpcCAqIHZXb3JsZFBvc2l0aW9uLngsIHZXb3JsZFBvc2l0aW9uLnl6ICkgKTtcIixcclxuXHRcdFx0XHRcInZlYzMgZGlyZWN0aW9uID0gbm9ybWFsaXplKCB2V29ybGRQb3NpdGlvbiApO1wiLFxyXG5cdFx0XHRcdFwidmVjMiBzYW1wbGVVVjtcIixcclxuXHRcdFx0XHRcInNhbXBsZVVWLnkgPSBzYXR1cmF0ZSggdEZsaXAgKiBkaXJlY3Rpb24ueSAqIC0wLjUgKyAwLjUgKTtcIixcclxuXHRcdFx0XHRcInNhbXBsZVVWLnggPSBhdGFuKCBkaXJlY3Rpb24ueiwgZGlyZWN0aW9uLnggKSAqIFJFQ0lQUk9DQUxfUEkyICsgMC41O1wiLFxyXG5cdFx0XHRcdFwiZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKCB0RXF1aXJlY3QsIHNhbXBsZVVWICk7XCIsXHJcblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX2ZyYWdtZW50XCIgXSxcclxuXHJcblx0XHRcdFwifVwiXHJcblxyXG5cdFx0XS5qb2luKCBcIlxcblwiIClcclxuXHJcblx0fSxcclxuXHJcblx0LyogRGVwdGggZW5jb2RpbmcgaW50byBSR0JBIHRleHR1cmVcclxuXHQgKlxyXG5cdCAqIGJhc2VkIG9uIFNwaWRlckdMIHNoYWRvdyBtYXAgZXhhbXBsZVxyXG5cdCAqIGh0dHA6Ly9zcGlkZXJnbC5vcmcvZXhhbXBsZS5waHA/aWQ9NlxyXG5cdCAqXHJcblx0ICogb3JpZ2luYWxseSBmcm9tXHJcblx0ICogaHR0cDovL3d3dy5nYW1lZGV2Lm5ldC90b3BpYy80NDIxMzgtcGFja2luZy1hLWZsb2F0LWludG8tYS1hOHI4ZzhiOC10ZXh0dXJlLXNoYWRlci9wYWdlX193aGljaHBhZ2VfXzElMjVFRiUyNUJGJTI1QkRcclxuXHQgKlxyXG5cdCAqIHNlZSBhbHNvXHJcblx0ICogaHR0cDovL2FyYXMtcC5pbmZvL2Jsb2cvMjAwOS8wNy8zMC9lbmNvZGluZy1mbG9hdHMtdG8tcmdiYS10aGUtZmluYWwvXHJcblx0ICovXHJcblxyXG5cdCdkZXB0aFJHQkEnOiB7XHJcblxyXG5cdFx0dW5pZm9ybXM6IHt9LFxyXG5cclxuXHRcdHZlcnRleFNoYWRlcjogW1xyXG5cclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubmluZ19wYXJzX3ZlcnRleFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4XCIgXSxcclxuXHJcblx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxyXG5cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2luYmFzZV92ZXJ0ZXhcIiBdLFxyXG5cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJiZWdpbl92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBodGFyZ2V0X3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbm5pbmdfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJwcm9qZWN0X3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfdmVydGV4XCIgXSxcclxuXHJcblx0XHRcdFwifVwiXHJcblxyXG5cdFx0XS5qb2luKCBcIlxcblwiICksXHJcblxyXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IFtcclxuXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cclxuXHRcdFx0XCJ2ZWM0IHBhY2tfZGVwdGgoIGNvbnN0IGluIGZsb2F0IGRlcHRoICkge1wiLFxyXG5cclxuXHRcdFx0XCJcdGNvbnN0IHZlYzQgYml0X3NoaWZ0ID0gdmVjNCggMjU2LjAgKiAyNTYuMCAqIDI1Ni4wLCAyNTYuMCAqIDI1Ni4wLCAyNTYuMCwgMS4wICk7XCIsXHJcblx0XHRcdFwiXHRjb25zdCB2ZWM0IGJpdF9tYXNrID0gdmVjNCggMC4wLCAxLjAgLyAyNTYuMCwgMS4wIC8gMjU2LjAsIDEuMCAvIDI1Ni4wICk7XCIsXHJcblx0XHRcdFwiXHR2ZWM0IHJlcyA9IG1vZCggZGVwdGggKiBiaXRfc2hpZnQgKiB2ZWM0KCAyNTUgKSwgdmVjNCggMjU2ICkgKSAvIHZlYzQoIDI1NSApO1wiLFxyXG5cdFx0XHRcIlx0cmVzIC09IHJlcy54eHl6ICogYml0X21hc2s7XCIsXHJcblx0XHRcdFwiXHRyZXR1cm4gcmVzO1wiLFxyXG5cclxuXHRcdFx0XCJ9XCIsXHJcblxyXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfZnJhZ21lbnRcIiBdLFxyXG5cclxuXHRcdFx0XCJcdCNpZmRlZiBVU0VfTE9HREVQVEhCVUZfRVhUXCIsXHJcblxyXG5cdFx0XHRcIlx0XHRnbF9GcmFnRGF0YVsgMCBdID0gcGFja19kZXB0aCggZ2xfRnJhZ0RlcHRoRVhUICk7XCIsXHJcblxyXG5cdFx0XHRcIlx0I2Vsc2VcIixcclxuXHJcblx0XHRcdFwiXHRcdGdsX0ZyYWdEYXRhWyAwIF0gPSBwYWNrX2RlcHRoKCBnbF9GcmFnQ29vcmQueiApO1wiLFxyXG5cclxuXHRcdFx0XCJcdCNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XHQvL1wiZ2xfRnJhZ0RhdGFbIDAgXSA9IHBhY2tfZGVwdGgoIGdsX0ZyYWdDb29yZC56IC8gZ2xfRnJhZ0Nvb3JkLncgKTtcIixcclxuXHRcdFx0XHQvL1wiZmxvYXQgeiA9ICggKCBnbF9GcmFnQ29vcmQueiAvIGdsX0ZyYWdDb29yZC53ICkgLSAzLjAgKSAvICggNDAwMC4wIC0gMy4wICk7XCIsXHJcblx0XHRcdFx0Ly9cImdsX0ZyYWdEYXRhWyAwIF0gPSBwYWNrX2RlcHRoKCB6ICk7XCIsXHJcblx0XHRcdFx0Ly9cImdsX0ZyYWdEYXRhWyAwIF0gPSB2ZWM0KCB6LCB6LCB6LCAxLjAgKTtcIixcclxuXHJcblx0XHRcdFwifVwiXHJcblxyXG5cdFx0XS5qb2luKCBcIlxcblwiIClcclxuXHJcblx0fSxcclxuXHJcblxyXG5cdCdkaXN0YW5jZVJHQkEnOiB7XHJcblxyXG5cdFx0dW5pZm9ybXM6IHtcclxuXHJcblx0XHRcdFwibGlnaHRQb3NcIjogeyB0eXBlOiBcInYzXCIsIHZhbHVlOiBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMCwgMCApIH1cclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHZlcnRleFNoYWRlcjogW1xyXG5cclxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzQgdldvcmxkUG9zaXRpb247XCIsXHJcblxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF9wYXJzX3ZlcnRleFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5uaW5nX3BhcnNfdmVydGV4XCIgXSxcclxuXHJcblx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxyXG5cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2luYmFzZV92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImJlZ2luX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGh0YXJnZXRfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubmluZ192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInByb2plY3RfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJ3b3JsZHBvc192ZXJ0ZXhcIiBdLFxyXG5cclxuXHRcdFx0XHRcInZXb3JsZFBvc2l0aW9uID0gd29ybGRQb3NpdGlvbjtcIixcclxuXHJcblx0XHRcdFwifVwiXHJcblxyXG5cdFx0XS5qb2luKCBcIlxcblwiICksXHJcblxyXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IFtcclxuXHJcblx0XHRcdFwidW5pZm9ybSB2ZWMzIGxpZ2h0UG9zO1wiLFxyXG5cdFx0XHRcInZhcnlpbmcgdmVjNCB2V29ybGRQb3NpdGlvbjtcIixcclxuXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXHJcblxyXG5cdFx0XHRcInZlYzQgcGFjazFLICggZmxvYXQgZGVwdGggKSB7XCIsXHJcblxyXG5cdFx0XHRcIlx0ZGVwdGggLz0gMTAwMC4wO1wiLFxyXG5cdFx0XHRcIlx0Y29uc3QgdmVjNCBiaXRTaCA9IHZlYzQoIDI1Ni4wICogMjU2LjAgKiAyNTYuMCwgMjU2LjAgKiAyNTYuMCwgMjU2LjAsIDEuMCApO1wiLFxyXG5cdFx0XHRcIlx0Y29uc3QgdmVjNCBiaXRNc2sgPSB2ZWM0KCAwLjAsIDEuMCAvIDI1Ni4wLCAxLjAgLyAyNTYuMCwgMS4wIC8gMjU2LjAgKTtcIixcclxuXHRcdFx0XCJcdHZlYzQgcmVzID0gbW9kKCBkZXB0aCAqIGJpdFNoICogdmVjNCggMjU1ICksIHZlYzQoIDI1NiApICkgLyB2ZWM0KCAyNTUgKTtcIixcclxuXHRcdFx0XCJcdHJlcyAtPSByZXMueHh5eiAqIGJpdE1zaztcIixcclxuXHRcdFx0XCJcdHJldHVybiByZXM7IFwiLFxyXG5cclxuXHRcdFx0XCJ9XCIsXHJcblxyXG5cdFx0XHRcImZsb2F0IHVucGFjazFLICggdmVjNCBjb2xvciApIHtcIixcclxuXHJcblx0XHRcdFwiXHRjb25zdCB2ZWM0IGJpdFNoID0gdmVjNCggMS4wIC8gKCAyNTYuMCAqIDI1Ni4wICogMjU2LjAgKSwgMS4wIC8gKCAyNTYuMCAqIDI1Ni4wICksIDEuMCAvIDI1Ni4wLCAxLjAgKTtcIixcclxuXHRcdFx0XCJcdHJldHVybiBkb3QoIGNvbG9yLCBiaXRTaCApICogMTAwMC4wO1wiLFxyXG5cclxuXHRcdFx0XCJ9XCIsXHJcblxyXG5cdFx0XHRcInZvaWQgbWFpbiAoKSB7XCIsXHJcblxyXG5cdFx0XHRcIlx0Z2xfRnJhZ0NvbG9yID0gcGFjazFLKCBsZW5ndGgoIHZXb3JsZFBvc2l0aW9uLnh5eiAtIGxpZ2h0UG9zLnh5eiApICk7XCIsXHJcblxyXG5cdFx0XHRcIn1cIlxyXG5cclxuXHRcdF0uam9pbiggXCJcXG5cIiApXHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvV2ViR0xSZW5kZXJlci5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3Igc3VwZXJlZ2diZXJ0IC8gaHR0cDovL3d3dy5wYXVsYnJ1bnQuY28udWsvXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqIEBhdXRob3Igc3ppbWVrIC8gaHR0cHM6Ly9naXRodWIuY29tL3N6aW1lay9cclxuICovXHJcblxyXG5USFJFRS5XZWJHTFJlbmRlcmVyID0gZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xyXG5cclxuXHRjb25zb2xlLmxvZyggJ1RIUkVFLldlYkdMUmVuZGVyZXInLCBUSFJFRS5SRVZJU0lPTiApO1xyXG5cclxuXHRwYXJhbWV0ZXJzID0gcGFyYW1ldGVycyB8fCB7fTtcclxuXHJcblx0dmFyIF9jYW52YXMgPSBwYXJhbWV0ZXJzLmNhbnZhcyAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5jYW52YXMgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnY2FudmFzJyApLFxyXG5cdF9jb250ZXh0ID0gcGFyYW1ldGVycy5jb250ZXh0ICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmNvbnRleHQgOiBudWxsLFxyXG5cclxuXHRfYWxwaGEgPSBwYXJhbWV0ZXJzLmFscGhhICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmFscGhhIDogZmFsc2UsXHJcblx0X2RlcHRoID0gcGFyYW1ldGVycy5kZXB0aCAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5kZXB0aCA6IHRydWUsXHJcblx0X3N0ZW5jaWwgPSBwYXJhbWV0ZXJzLnN0ZW5jaWwgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuc3RlbmNpbCA6IHRydWUsXHJcblx0X2FudGlhbGlhcyA9IHBhcmFtZXRlcnMuYW50aWFsaWFzICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmFudGlhbGlhcyA6IGZhbHNlLFxyXG5cdF9wcmVtdWx0aXBsaWVkQWxwaGEgPSBwYXJhbWV0ZXJzLnByZW11bHRpcGxpZWRBbHBoYSAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5wcmVtdWx0aXBsaWVkQWxwaGEgOiB0cnVlLFxyXG5cdF9wcmVzZXJ2ZURyYXdpbmdCdWZmZXIgPSBwYXJhbWV0ZXJzLnByZXNlcnZlRHJhd2luZ0J1ZmZlciAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5wcmVzZXJ2ZURyYXdpbmdCdWZmZXIgOiBmYWxzZTtcclxuXHJcblx0dmFyIGxpZ2h0cyA9IFtdO1xyXG5cclxuXHR2YXIgb3BhcXVlT2JqZWN0cyA9IFtdO1xyXG5cdHZhciBvcGFxdWVPYmplY3RzTGFzdEluZGV4ID0gLSAxO1xyXG5cdHZhciB0cmFuc3BhcmVudE9iamVjdHMgPSBbXTtcclxuXHR2YXIgdHJhbnNwYXJlbnRPYmplY3RzTGFzdEluZGV4ID0gLSAxO1xyXG5cclxuXHR2YXIgbW9ycGhJbmZsdWVuY2VzID0gbmV3IEZsb2F0MzJBcnJheSggOCApO1xyXG5cclxuXHR2YXIgc3ByaXRlcyA9IFtdO1xyXG5cdHZhciBsZW5zRmxhcmVzID0gW107XHJcblxyXG5cdC8vIHB1YmxpYyBwcm9wZXJ0aWVzXHJcblxyXG5cdHRoaXMuZG9tRWxlbWVudCA9IF9jYW52YXM7XHJcblx0dGhpcy5jb250ZXh0ID0gbnVsbDtcclxuXHJcblx0Ly8gY2xlYXJpbmdcclxuXHJcblx0dGhpcy5hdXRvQ2xlYXIgPSB0cnVlO1xyXG5cdHRoaXMuYXV0b0NsZWFyQ29sb3IgPSB0cnVlO1xyXG5cdHRoaXMuYXV0b0NsZWFyRGVwdGggPSB0cnVlO1xyXG5cdHRoaXMuYXV0b0NsZWFyU3RlbmNpbCA9IHRydWU7XHJcblxyXG5cdC8vIHNjZW5lIGdyYXBoXHJcblxyXG5cdHRoaXMuc29ydE9iamVjdHMgPSB0cnVlO1xyXG5cclxuXHQvLyBwaHlzaWNhbGx5IGJhc2VkIHNoYWRpbmdcclxuXHJcblx0dGhpcy5nYW1tYUZhY3RvciA9IDIuMDtcdC8vIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxyXG5cdHRoaXMuZ2FtbWFJbnB1dCA9IGZhbHNlO1xyXG5cdHRoaXMuZ2FtbWFPdXRwdXQgPSBmYWxzZTtcclxuXHJcblx0Ly8gbW9ycGhzXHJcblxyXG5cdHRoaXMubWF4TW9ycGhUYXJnZXRzID0gODtcclxuXHR0aGlzLm1heE1vcnBoTm9ybWFscyA9IDQ7XHJcblxyXG5cdC8vIGZsYWdzXHJcblxyXG5cdHRoaXMuYXV0b1NjYWxlQ3ViZW1hcHMgPSB0cnVlO1xyXG5cclxuXHQvLyBpbnRlcm5hbCBwcm9wZXJ0aWVzXHJcblxyXG5cdHZhciBfdGhpcyA9IHRoaXMsXHJcblxyXG5cdC8vIGludGVybmFsIHN0YXRlIGNhY2hlXHJcblxyXG5cdF9jdXJyZW50UHJvZ3JhbSA9IG51bGwsXHJcblx0X2N1cnJlbnRSZW5kZXJUYXJnZXQgPSBudWxsLFxyXG5cdF9jdXJyZW50RnJhbWVidWZmZXIgPSBudWxsLFxyXG5cdF9jdXJyZW50TWF0ZXJpYWxJZCA9IC0gMSxcclxuXHRfY3VycmVudEdlb21ldHJ5UHJvZ3JhbSA9ICcnLFxyXG5cdF9jdXJyZW50Q2FtZXJhID0gbnVsbCxcclxuXHJcblx0X2N1cnJlbnRTY2lzc29yID0gbmV3IFRIUkVFLlZlY3RvcjQoKSxcclxuXHRfY3VycmVudFNjaXNzb3JUZXN0ID0gbnVsbCxcclxuXHJcblx0X2N1cnJlbnRWaWV3cG9ydCA9IG5ldyBUSFJFRS5WZWN0b3I0KCksXHJcblxyXG5cdC8vXHJcblxyXG5cdF91c2VkVGV4dHVyZVVuaXRzID0gMCxcclxuXHJcblx0Ly9cclxuXHJcblx0X2NsZWFyQ29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIDB4MDAwMDAwICksXHJcblx0X2NsZWFyQWxwaGEgPSAwLFxyXG5cclxuXHRfd2lkdGggPSBfY2FudmFzLndpZHRoLFxyXG5cdF9oZWlnaHQgPSBfY2FudmFzLmhlaWdodCxcclxuXHJcblx0X3BpeGVsUmF0aW8gPSAxLFxyXG5cclxuXHRfc2Npc3NvciA9IG5ldyBUSFJFRS5WZWN0b3I0KCAwLCAwLCBfd2lkdGgsIF9oZWlnaHQgKSxcclxuXHRfc2Npc3NvclRlc3QgPSBmYWxzZSxcclxuXHJcblx0X3ZpZXdwb3J0ID0gbmV3IFRIUkVFLlZlY3RvcjQoIDAsIDAsIF93aWR0aCwgX2hlaWdodCApLFxyXG5cclxuXHQvLyBmcnVzdHVtXHJcblxyXG5cdF9mcnVzdHVtID0gbmV3IFRIUkVFLkZydXN0dW0oKSxcclxuXHJcblx0Ly8gY2FtZXJhIG1hdHJpY2VzIGNhY2hlXHJcblxyXG5cdF9wcm9qU2NyZWVuTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKSxcclxuXHJcblx0X3ZlY3RvcjMgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG5cclxuXHQvLyBsaWdodCBhcnJheXMgY2FjaGVcclxuXHJcblx0X2xpZ2h0cyA9IHtcclxuXHJcblx0XHRoYXNoOiAnJyxcclxuXHJcblx0XHRhbWJpZW50OiBbIDAsIDAsIDAgXSxcclxuXHRcdGRpcmVjdGlvbmFsOiBbXSxcclxuXHRcdGRpcmVjdGlvbmFsU2hhZG93TWFwOiBbXSxcclxuXHRcdGRpcmVjdGlvbmFsU2hhZG93TWF0cml4OiBbXSxcclxuXHRcdHNwb3Q6IFtdLFxyXG5cdFx0c3BvdFNoYWRvd01hcDogW10sXHJcblx0XHRzcG90U2hhZG93TWF0cml4OiBbXSxcclxuXHRcdHBvaW50OiBbXSxcclxuXHRcdHBvaW50U2hhZG93TWFwOiBbXSxcclxuXHRcdHBvaW50U2hhZG93TWF0cml4OiBbXSxcclxuXHRcdGhlbWk6IFtdLFxyXG5cclxuXHRcdHNoYWRvd3M6IFtdLFxyXG5cdFx0c2hhZG93c1BvaW50TGlnaHQ6IDBcclxuXHJcblx0fSxcclxuXHJcblx0Ly8gaW5mb1xyXG5cclxuXHRfaW5mb01lbW9yeSA9IHtcclxuXHJcblx0XHRnZW9tZXRyaWVzOiAwLFxyXG5cdFx0dGV4dHVyZXM6IDBcclxuXHJcblx0fSxcclxuXHJcblx0X2luZm9SZW5kZXIgPSB7XHJcblxyXG5cdFx0Y2FsbHM6IDAsXHJcblx0XHR2ZXJ0aWNlczogMCxcclxuXHRcdGZhY2VzOiAwLFxyXG5cdFx0cG9pbnRzOiAwXHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuaW5mbyA9IHtcclxuXHJcblx0XHRyZW5kZXI6IF9pbmZvUmVuZGVyLFxyXG5cdFx0bWVtb3J5OiBfaW5mb01lbW9yeSxcclxuXHRcdHByb2dyYW1zOiBudWxsXHJcblxyXG5cdH07XHJcblxyXG5cclxuXHQvLyBpbml0aWFsaXplXHJcblxyXG5cdHZhciBfZ2w7XHJcblxyXG5cdHRyeSB7XHJcblxyXG5cdFx0dmFyIGF0dHJpYnV0ZXMgPSB7XHJcblx0XHRcdGFscGhhOiBfYWxwaGEsXHJcblx0XHRcdGRlcHRoOiBfZGVwdGgsXHJcblx0XHRcdHN0ZW5jaWw6IF9zdGVuY2lsLFxyXG5cdFx0XHRhbnRpYWxpYXM6IF9hbnRpYWxpYXMsXHJcblx0XHRcdHByZW11bHRpcGxpZWRBbHBoYTogX3ByZW11bHRpcGxpZWRBbHBoYSxcclxuXHRcdFx0cHJlc2VydmVEcmF3aW5nQnVmZmVyOiBfcHJlc2VydmVEcmF3aW5nQnVmZmVyXHJcblx0XHR9O1xyXG5cclxuXHRcdF9nbCA9IF9jb250ZXh0IHx8IF9jYW52YXMuZ2V0Q29udGV4dCggJ3dlYmdsJywgYXR0cmlidXRlcyApIHx8IF9jYW52YXMuZ2V0Q29udGV4dCggJ2V4cGVyaW1lbnRhbC13ZWJnbCcsIGF0dHJpYnV0ZXMgKTtcclxuXHJcblx0XHRpZiAoIF9nbCA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdGlmICggX2NhbnZhcy5nZXRDb250ZXh0KCAnd2ViZ2wnICkgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdHRocm93ICdFcnJvciBjcmVhdGluZyBXZWJHTCBjb250ZXh0IHdpdGggeW91ciBzZWxlY3RlZCBhdHRyaWJ1dGVzLic7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHR0aHJvdyAnRXJyb3IgY3JlYXRpbmcgV2ViR0wgY29udGV4dC4nO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRfY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoICd3ZWJnbGNvbnRleHRsb3N0Jywgb25Db250ZXh0TG9zdCwgZmFsc2UgKTtcclxuXHJcblx0fSBjYXRjaCAoIGVycm9yICkge1xyXG5cclxuXHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAnICsgZXJyb3IgKTtcclxuXHJcblx0fVxyXG5cclxuXHR2YXIgZXh0ZW5zaW9ucyA9IG5ldyBUSFJFRS5XZWJHTEV4dGVuc2lvbnMoIF9nbCApO1xyXG5cclxuXHRleHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2Zsb2F0JyApO1xyXG5cdGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyJyApO1xyXG5cdGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3RleHR1cmVfaGFsZl9mbG9hdCcgKTtcclxuXHRleHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2hhbGZfZmxvYXRfbGluZWFyJyApO1xyXG5cdGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzJyApO1xyXG5cdGV4dGVuc2lvbnMuZ2V0KCAnQU5HTEVfaW5zdGFuY2VkX2FycmF5cycgKTtcclxuXHJcblx0aWYgKCBleHRlbnNpb25zLmdldCggJ09FU19lbGVtZW50X2luZGV4X3VpbnQnICkgKSB7XHJcblxyXG5cdFx0VEhSRUUuQnVmZmVyR2VvbWV0cnkuTWF4SW5kZXggPSA0Mjk0OTY3Mjk2O1xyXG5cclxuXHR9XHJcblxyXG5cdHZhciBjYXBhYmlsaXRpZXMgPSBuZXcgVEhSRUUuV2ViR0xDYXBhYmlsaXRpZXMoIF9nbCwgZXh0ZW5zaW9ucywgcGFyYW1ldGVycyApO1xyXG5cclxuXHR2YXIgc3RhdGUgPSBuZXcgVEhSRUUuV2ViR0xTdGF0ZSggX2dsLCBleHRlbnNpb25zLCBwYXJhbVRocmVlVG9HTCApO1xyXG5cdHZhciBwcm9wZXJ0aWVzID0gbmV3IFRIUkVFLldlYkdMUHJvcGVydGllcygpO1xyXG5cdHZhciBvYmplY3RzID0gbmV3IFRIUkVFLldlYkdMT2JqZWN0cyggX2dsLCBwcm9wZXJ0aWVzLCB0aGlzLmluZm8gKTtcclxuXHR2YXIgcHJvZ3JhbUNhY2hlID0gbmV3IFRIUkVFLldlYkdMUHJvZ3JhbXMoIHRoaXMsIGNhcGFiaWxpdGllcyApO1xyXG5cdHZhciBsaWdodENhY2hlID0gbmV3IFRIUkVFLldlYkdMTGlnaHRzKCk7XHJcblxyXG5cdHRoaXMuaW5mby5wcm9ncmFtcyA9IHByb2dyYW1DYWNoZS5wcm9ncmFtcztcclxuXHJcblx0dmFyIGJ1ZmZlclJlbmRlcmVyID0gbmV3IFRIUkVFLldlYkdMQnVmZmVyUmVuZGVyZXIoIF9nbCwgZXh0ZW5zaW9ucywgX2luZm9SZW5kZXIgKTtcclxuXHR2YXIgaW5kZXhlZEJ1ZmZlclJlbmRlcmVyID0gbmV3IFRIUkVFLldlYkdMSW5kZXhlZEJ1ZmZlclJlbmRlcmVyKCBfZ2wsIGV4dGVuc2lvbnMsIF9pbmZvUmVuZGVyICk7XHJcblxyXG5cdC8vXHJcblxyXG5cdGZ1bmN0aW9uIGdldFRhcmdldFBpeGVsUmF0aW8oKSB7XHJcblxyXG5cdFx0cmV0dXJuIF9jdXJyZW50UmVuZGVyVGFyZ2V0ID09PSBudWxsID8gX3BpeGVsUmF0aW8gOiAxO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGdsQ2xlYXJDb2xvciggciwgZywgYiwgYSApIHtcclxuXHJcblx0XHRpZiAoIF9wcmVtdWx0aXBsaWVkQWxwaGEgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRyICo9IGE7IGcgKj0gYTsgYiAqPSBhO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRzdGF0ZS5jbGVhckNvbG9yKCByLCBnLCBiLCBhICk7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gc2V0RGVmYXVsdEdMU3RhdGUoKSB7XHJcblxyXG5cdFx0c3RhdGUuaW5pdCgpO1xyXG5cclxuXHRcdHN0YXRlLnNjaXNzb3IoIF9jdXJyZW50U2Npc3Nvci5jb3B5KCBfc2Npc3NvciApLm11bHRpcGx5U2NhbGFyKCBfcGl4ZWxSYXRpbyApICk7XHJcblx0XHRzdGF0ZS52aWV3cG9ydCggX2N1cnJlbnRWaWV3cG9ydC5jb3B5KCBfdmlld3BvcnQgKS5tdWx0aXBseVNjYWxhciggX3BpeGVsUmF0aW8gKSApO1xyXG5cclxuXHRcdGdsQ2xlYXJDb2xvciggX2NsZWFyQ29sb3IuciwgX2NsZWFyQ29sb3IuZywgX2NsZWFyQ29sb3IuYiwgX2NsZWFyQWxwaGEgKTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiByZXNldEdMU3RhdGUoKSB7XHJcblxyXG5cdFx0X2N1cnJlbnRQcm9ncmFtID0gbnVsbDtcclxuXHRcdF9jdXJyZW50Q2FtZXJhID0gbnVsbDtcclxuXHJcblx0XHRfY3VycmVudEdlb21ldHJ5UHJvZ3JhbSA9ICcnO1xyXG5cdFx0X2N1cnJlbnRNYXRlcmlhbElkID0gLSAxO1xyXG5cclxuXHRcdHN0YXRlLnJlc2V0KCk7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0RGVmYXVsdEdMU3RhdGUoKTtcclxuXHJcblx0dGhpcy5jb250ZXh0ID0gX2dsO1xyXG5cdHRoaXMuY2FwYWJpbGl0aWVzID0gY2FwYWJpbGl0aWVzO1xyXG5cdHRoaXMuZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnM7XHJcblx0dGhpcy5wcm9wZXJ0aWVzID0gcHJvcGVydGllcztcclxuXHR0aGlzLnN0YXRlID0gc3RhdGU7XHJcblxyXG5cdC8vIHNoYWRvdyBtYXBcclxuXHJcblx0dmFyIHNoYWRvd01hcCA9IG5ldyBUSFJFRS5XZWJHTFNoYWRvd01hcCggdGhpcywgX2xpZ2h0cywgb2JqZWN0cyApO1xyXG5cclxuXHR0aGlzLnNoYWRvd01hcCA9IHNoYWRvd01hcDtcclxuXHJcblxyXG5cdC8vIFBsdWdpbnNcclxuXHJcblx0dmFyIHNwcml0ZVBsdWdpbiA9IG5ldyBUSFJFRS5TcHJpdGVQbHVnaW4oIHRoaXMsIHNwcml0ZXMgKTtcclxuXHR2YXIgbGVuc0ZsYXJlUGx1Z2luID0gbmV3IFRIUkVFLkxlbnNGbGFyZVBsdWdpbiggdGhpcywgbGVuc0ZsYXJlcyApO1xyXG5cclxuXHQvLyBBUElcclxuXHJcblx0dGhpcy5nZXRDb250ZXh0ID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBfZ2w7XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuZ2V0Q29udGV4dEF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIF9nbC5nZXRDb250ZXh0QXR0cmlidXRlcygpO1xyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLmZvcmNlQ29udGV4dExvc3MgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0ZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9sb3NlX2NvbnRleHQnICkubG9zZUNvbnRleHQoKTtcclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5nZXRNYXhBbmlzb3Ryb3B5ID0gKCBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHZhbHVlO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiBnZXRNYXhBbmlzb3Ryb3B5KCkge1xyXG5cclxuXHRcdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkgcmV0dXJuIHZhbHVlO1xyXG5cclxuXHRcdFx0dmFyIGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJyApO1xyXG5cclxuXHRcdFx0aWYgKCBleHRlbnNpb24gIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdHZhbHVlID0gX2dsLmdldFBhcmFtZXRlciggZXh0ZW5zaW9uLk1BWF9URVhUVVJFX01BWF9BTklTT1RST1BZX0VYVCApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0dmFsdWUgPSAwO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHZhbHVlO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0gKSgpO1xyXG5cclxuXHR0aGlzLmdldFByZWNpc2lvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gY2FwYWJpbGl0aWVzLnByZWNpc2lvbjtcclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5nZXRQaXhlbFJhdGlvID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBfcGl4ZWxSYXRpbztcclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5zZXRQaXhlbFJhdGlvID0gZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0XHRpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgKSByZXR1cm47XHJcblxyXG5cdFx0X3BpeGVsUmF0aW8gPSB2YWx1ZTtcclxuXHJcblx0XHR0aGlzLnNldFNpemUoIF92aWV3cG9ydC56LCBfdmlld3BvcnQudywgZmFsc2UgKTtcclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5nZXRTaXplID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiB7XHJcblx0XHRcdHdpZHRoOiBfd2lkdGgsXHJcblx0XHRcdGhlaWdodDogX2hlaWdodFxyXG5cdFx0fTtcclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5zZXRTaXplID0gZnVuY3Rpb24gKCB3aWR0aCwgaGVpZ2h0LCB1cGRhdGVTdHlsZSApIHtcclxuXHJcblx0XHRfd2lkdGggPSB3aWR0aDtcclxuXHRcdF9oZWlnaHQgPSBoZWlnaHQ7XHJcblxyXG5cdFx0X2NhbnZhcy53aWR0aCA9IHdpZHRoICogX3BpeGVsUmF0aW87XHJcblx0XHRfY2FudmFzLmhlaWdodCA9IGhlaWdodCAqIF9waXhlbFJhdGlvO1xyXG5cclxuXHRcdGlmICggdXBkYXRlU3R5bGUgIT09IGZhbHNlICkge1xyXG5cclxuXHRcdFx0X2NhbnZhcy5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcclxuXHRcdFx0X2NhbnZhcy5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnNldFZpZXdwb3J0KCAwLCAwLCB3aWR0aCwgaGVpZ2h0ICk7XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuc2V0Vmlld3BvcnQgPSBmdW5jdGlvbiAoIHgsIHksIHdpZHRoLCBoZWlnaHQgKSB7XHJcblxyXG5cdFx0c3RhdGUudmlld3BvcnQoIF92aWV3cG9ydC5zZXQoIHgsIHksIHdpZHRoLCBoZWlnaHQgKSApO1xyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLnNldFNjaXNzb3IgPSBmdW5jdGlvbiAoIHgsIHksIHdpZHRoLCBoZWlnaHQgKSB7XHJcblxyXG5cdFx0c3RhdGUuc2Npc3NvciggX3NjaXNzb3Iuc2V0KCB4LCB5LCB3aWR0aCwgaGVpZ2h0ICkgKTtcclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5zZXRTY2lzc29yVGVzdCA9IGZ1bmN0aW9uICggYm9vbGVhbiApIHtcclxuXHJcblx0XHRzdGF0ZS5zZXRTY2lzc29yVGVzdCggX3NjaXNzb3JUZXN0ID0gYm9vbGVhbiApO1xyXG5cclxuXHR9O1xyXG5cclxuXHQvLyBDbGVhcmluZ1xyXG5cclxuXHR0aGlzLmdldENsZWFyQ29sb3IgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIF9jbGVhckNvbG9yO1xyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLnNldENsZWFyQ29sb3IgPSBmdW5jdGlvbiAoIGNvbG9yLCBhbHBoYSApIHtcclxuXHJcblx0XHRfY2xlYXJDb2xvci5zZXQoIGNvbG9yICk7XHJcblxyXG5cdFx0X2NsZWFyQWxwaGEgPSBhbHBoYSAhPT0gdW5kZWZpbmVkID8gYWxwaGEgOiAxO1xyXG5cclxuXHRcdGdsQ2xlYXJDb2xvciggX2NsZWFyQ29sb3IuciwgX2NsZWFyQ29sb3IuZywgX2NsZWFyQ29sb3IuYiwgX2NsZWFyQWxwaGEgKTtcclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5nZXRDbGVhckFscGhhID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBfY2xlYXJBbHBoYTtcclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5zZXRDbGVhckFscGhhID0gZnVuY3Rpb24gKCBhbHBoYSApIHtcclxuXHJcblx0XHRfY2xlYXJBbHBoYSA9IGFscGhhO1xyXG5cclxuXHRcdGdsQ2xlYXJDb2xvciggX2NsZWFyQ29sb3IuciwgX2NsZWFyQ29sb3IuZywgX2NsZWFyQ29sb3IuYiwgX2NsZWFyQWxwaGEgKTtcclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5jbGVhciA9IGZ1bmN0aW9uICggY29sb3IsIGRlcHRoLCBzdGVuY2lsICkge1xyXG5cclxuXHRcdHZhciBiaXRzID0gMDtcclxuXHJcblx0XHRpZiAoIGNvbG9yID09PSB1bmRlZmluZWQgfHwgY29sb3IgKSBiaXRzIHw9IF9nbC5DT0xPUl9CVUZGRVJfQklUO1xyXG5cdFx0aWYgKCBkZXB0aCA9PT0gdW5kZWZpbmVkIHx8IGRlcHRoICkgYml0cyB8PSBfZ2wuREVQVEhfQlVGRkVSX0JJVDtcclxuXHRcdGlmICggc3RlbmNpbCA9PT0gdW5kZWZpbmVkIHx8IHN0ZW5jaWwgKSBiaXRzIHw9IF9nbC5TVEVOQ0lMX0JVRkZFUl9CSVQ7XHJcblxyXG5cdFx0X2dsLmNsZWFyKCBiaXRzICk7XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuY2xlYXJDb2xvciA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLmNsZWFyKCB0cnVlLCBmYWxzZSwgZmFsc2UgKTtcclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5jbGVhckRlcHRoID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMuY2xlYXIoIGZhbHNlLCB0cnVlLCBmYWxzZSApO1xyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLmNsZWFyU3RlbmNpbCA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLmNsZWFyKCBmYWxzZSwgZmFsc2UsIHRydWUgKTtcclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5jbGVhclRhcmdldCA9IGZ1bmN0aW9uICggcmVuZGVyVGFyZ2V0LCBjb2xvciwgZGVwdGgsIHN0ZW5jaWwgKSB7XHJcblxyXG5cdFx0dGhpcy5zZXRSZW5kZXJUYXJnZXQoIHJlbmRlclRhcmdldCApO1xyXG5cdFx0dGhpcy5jbGVhciggY29sb3IsIGRlcHRoLCBzdGVuY2lsICk7XHJcblxyXG5cdH07XHJcblxyXG5cdC8vIFJlc2V0XHJcblxyXG5cdHRoaXMucmVzZXRHTFN0YXRlID0gcmVzZXRHTFN0YXRlO1xyXG5cclxuXHR0aGlzLmRpc3Bvc2UgPSBmdW5jdGlvbigpIHtcclxuXHJcblx0XHRfY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoICd3ZWJnbGNvbnRleHRsb3N0Jywgb25Db250ZXh0TG9zdCwgZmFsc2UgKTtcclxuXHJcblx0fTtcclxuXHJcblx0Ly8gRXZlbnRzXHJcblxyXG5cdGZ1bmN0aW9uIG9uQ29udGV4dExvc3QoIGV2ZW50ICkge1xyXG5cclxuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG5cdFx0cmVzZXRHTFN0YXRlKCk7XHJcblx0XHRzZXREZWZhdWx0R0xTdGF0ZSgpO1xyXG5cclxuXHRcdHByb3BlcnRpZXMuY2xlYXIoKTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBvblRleHR1cmVEaXNwb3NlKCBldmVudCApIHtcclxuXHJcblx0XHR2YXIgdGV4dHVyZSA9IGV2ZW50LnRhcmdldDtcclxuXHJcblx0XHR0ZXh0dXJlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25UZXh0dXJlRGlzcG9zZSApO1xyXG5cclxuXHRcdGRlYWxsb2NhdGVUZXh0dXJlKCB0ZXh0dXJlICk7XHJcblxyXG5cdFx0X2luZm9NZW1vcnkudGV4dHVyZXMgLS07XHJcblxyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIG9uUmVuZGVyVGFyZ2V0RGlzcG9zZSggZXZlbnQgKSB7XHJcblxyXG5cdFx0dmFyIHJlbmRlclRhcmdldCA9IGV2ZW50LnRhcmdldDtcclxuXHJcblx0XHRyZW5kZXJUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvblJlbmRlclRhcmdldERpc3Bvc2UgKTtcclxuXHJcblx0XHRkZWFsbG9jYXRlUmVuZGVyVGFyZ2V0KCByZW5kZXJUYXJnZXQgKTtcclxuXHJcblx0XHRfaW5mb01lbW9yeS50ZXh0dXJlcyAtLTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBvbk1hdGVyaWFsRGlzcG9zZSggZXZlbnQgKSB7XHJcblxyXG5cdFx0dmFyIG1hdGVyaWFsID0gZXZlbnQudGFyZ2V0O1xyXG5cclxuXHRcdG1hdGVyaWFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25NYXRlcmlhbERpc3Bvc2UgKTtcclxuXHJcblx0XHRkZWFsbG9jYXRlTWF0ZXJpYWwoIG1hdGVyaWFsICk7XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gQnVmZmVyIGRlYWxsb2NhdGlvblxyXG5cclxuXHRmdW5jdGlvbiBkZWFsbG9jYXRlVGV4dHVyZSggdGV4dHVyZSApIHtcclxuXHJcblx0XHR2YXIgdGV4dHVyZVByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggdGV4dHVyZSApO1xyXG5cclxuXHRcdGlmICggdGV4dHVyZS5pbWFnZSAmJiB0ZXh0dXJlUHJvcGVydGllcy5fX2ltYWdlX193ZWJnbFRleHR1cmVDdWJlICkge1xyXG5cclxuXHRcdFx0Ly8gY3ViZSB0ZXh0dXJlXHJcblxyXG5cdFx0XHRfZ2wuZGVsZXRlVGV4dHVyZSggdGV4dHVyZVByb3BlcnRpZXMuX19pbWFnZV9fd2ViZ2xUZXh0dXJlQ3ViZSApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHQvLyAyRCB0ZXh0dXJlXHJcblxyXG5cdFx0XHRpZiAoIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xJbml0ID09PSB1bmRlZmluZWQgKSByZXR1cm47XHJcblxyXG5cdFx0XHRfZ2wuZGVsZXRlVGV4dHVyZSggdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gcmVtb3ZlIGFsbCB3ZWJnbCBwcm9wZXJ0aWVzXHJcblx0XHRwcm9wZXJ0aWVzLmRlbGV0ZSggdGV4dHVyZSApO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGRlYWxsb2NhdGVSZW5kZXJUYXJnZXQoIHJlbmRlclRhcmdldCApIHtcclxuXHJcblx0XHR2YXIgcmVuZGVyVGFyZ2V0UHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQgKTtcclxuXHRcdHZhciB0ZXh0dXJlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQudGV4dHVyZSApO1xyXG5cclxuXHRcdGlmICggISByZW5kZXJUYXJnZXQgfHwgdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgPT09IHVuZGVmaW5lZCApIHJldHVybjtcclxuXHJcblx0XHRfZ2wuZGVsZXRlVGV4dHVyZSggdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgKTtcclxuXHJcblx0XHRpZiAoIHJlbmRlclRhcmdldCBpbnN0YW5jZW9mIFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZSApIHtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IDY7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdF9nbC5kZWxldGVGcmFtZWJ1ZmZlciggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXJbIGkgXSApO1xyXG5cdFx0XHRcdF9nbC5kZWxldGVSZW5kZXJidWZmZXIoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbERlcHRoYnVmZmVyWyBpIF0gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0X2dsLmRlbGV0ZUZyYW1lYnVmZmVyKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlciApO1xyXG5cdFx0XHRfZ2wuZGVsZXRlUmVuZGVyYnVmZmVyKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xEZXB0aGJ1ZmZlciApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRwcm9wZXJ0aWVzLmRlbGV0ZSggcmVuZGVyVGFyZ2V0LnRleHR1cmUgKTtcclxuXHRcdHByb3BlcnRpZXMuZGVsZXRlKCByZW5kZXJUYXJnZXQgKTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBkZWFsbG9jYXRlTWF0ZXJpYWwoIG1hdGVyaWFsICkge1xyXG5cclxuXHRcdHJlbGVhc2VNYXRlcmlhbFByb2dyYW1SZWZlcmVuY2UoIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0cHJvcGVydGllcy5kZWxldGUoIG1hdGVyaWFsICk7XHJcblxyXG5cdH1cclxuXHJcblxyXG5cdGZ1bmN0aW9uIHJlbGVhc2VNYXRlcmlhbFByb2dyYW1SZWZlcmVuY2UoIG1hdGVyaWFsICkge1xyXG5cclxuXHRcdHZhciBwcm9ncmFtSW5mbyA9IHByb3BlcnRpZXMuZ2V0KCBtYXRlcmlhbCApLnByb2dyYW07XHJcblxyXG5cdFx0bWF0ZXJpYWwucHJvZ3JhbSA9IHVuZGVmaW5lZDtcclxuXHJcblx0XHRpZiAoIHByb2dyYW1JbmZvICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRwcm9ncmFtQ2FjaGUucmVsZWFzZVByb2dyYW0oIHByb2dyYW1JbmZvICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdC8vIEJ1ZmZlciByZW5kZXJpbmdcclxuXHJcblx0dGhpcy5yZW5kZXJCdWZmZXJJbW1lZGlhdGUgPSBmdW5jdGlvbiAoIG9iamVjdCwgcHJvZ3JhbSwgbWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0c3RhdGUuaW5pdEF0dHJpYnV0ZXMoKTtcclxuXHJcblx0XHR2YXIgYnVmZmVycyA9IHByb3BlcnRpZXMuZ2V0KCBvYmplY3QgKTtcclxuXHJcblx0XHRpZiAoIG9iamVjdC5oYXNQb3NpdGlvbnMgJiYgISBidWZmZXJzLnBvc2l0aW9uICkgYnVmZmVycy5wb3NpdGlvbiA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcclxuXHRcdGlmICggb2JqZWN0Lmhhc05vcm1hbHMgJiYgISBidWZmZXJzLm5vcm1hbCApIGJ1ZmZlcnMubm9ybWFsID0gX2dsLmNyZWF0ZUJ1ZmZlcigpO1xyXG5cdFx0aWYgKCBvYmplY3QuaGFzVXZzICYmICEgYnVmZmVycy51diApIGJ1ZmZlcnMudXYgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XHJcblx0XHRpZiAoIG9iamVjdC5oYXNDb2xvcnMgJiYgISBidWZmZXJzLmNvbG9yICkgYnVmZmVycy5jb2xvciA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcclxuXHJcblx0XHR2YXIgYXR0cmlidXRlcyA9IHByb2dyYW0uZ2V0QXR0cmlidXRlcygpO1xyXG5cclxuXHRcdGlmICggb2JqZWN0Lmhhc1Bvc2l0aW9ucyApIHtcclxuXHJcblx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXJzLnBvc2l0aW9uICk7XHJcblx0XHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCBvYmplY3QucG9zaXRpb25BcnJheSwgX2dsLkRZTkFNSUNfRFJBVyApO1xyXG5cclxuXHRcdFx0c3RhdGUuZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLnBvc2l0aW9uICk7XHJcblx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLnBvc2l0aW9uLCAzLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCAwICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggb2JqZWN0Lmhhc05vcm1hbHMgKSB7XHJcblxyXG5cdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgYnVmZmVycy5ub3JtYWwgKTtcclxuXHJcblx0XHRcdGlmICggbWF0ZXJpYWwudHlwZSAhPT0gJ01lc2hQaG9uZ01hdGVyaWFsJyAmJiBtYXRlcmlhbC50eXBlICE9PSAnTWVzaFN0YW5kYXJkTWF0ZXJpYWwnICYmIG1hdGVyaWFsLnNoYWRpbmcgPT09IFRIUkVFLkZsYXRTaGFkaW5nICkge1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBvYmplY3QuY291bnQgKiAzOyBpIDwgbDsgaSArPSA5ICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciBhcnJheSA9IG9iamVjdC5ub3JtYWxBcnJheTtcclxuXHJcblx0XHRcdFx0XHR2YXIgbnggPSAoIGFycmF5WyBpICsgMCBdICsgYXJyYXlbIGkgKyAzIF0gKyBhcnJheVsgaSArIDYgXSApIC8gMztcclxuXHRcdFx0XHRcdHZhciBueSA9ICggYXJyYXlbIGkgKyAxIF0gKyBhcnJheVsgaSArIDQgXSArIGFycmF5WyBpICsgNyBdICkgLyAzO1xyXG5cdFx0XHRcdFx0dmFyIG56ID0gKCBhcnJheVsgaSArIDIgXSArIGFycmF5WyBpICsgNSBdICsgYXJyYXlbIGkgKyA4IF0gKSAvIDM7XHJcblxyXG5cdFx0XHRcdFx0YXJyYXlbIGkgKyAwIF0gPSBueDtcclxuXHRcdFx0XHRcdGFycmF5WyBpICsgMSBdID0gbnk7XHJcblx0XHRcdFx0XHRhcnJheVsgaSArIDIgXSA9IG56O1xyXG5cclxuXHRcdFx0XHRcdGFycmF5WyBpICsgMyBdID0gbng7XHJcblx0XHRcdFx0XHRhcnJheVsgaSArIDQgXSA9IG55O1xyXG5cdFx0XHRcdFx0YXJyYXlbIGkgKyA1IF0gPSBuejtcclxuXHJcblx0XHRcdFx0XHRhcnJheVsgaSArIDYgXSA9IG54O1xyXG5cdFx0XHRcdFx0YXJyYXlbIGkgKyA3IF0gPSBueTtcclxuXHRcdFx0XHRcdGFycmF5WyBpICsgOCBdID0gbno7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCBvYmplY3Qubm9ybWFsQXJyYXksIF9nbC5EWU5BTUlDX0RSQVcgKTtcclxuXHJcblx0XHRcdHN0YXRlLmVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlcy5ub3JtYWwgKTtcclxuXHJcblx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLm5vcm1hbCwgMywgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG9iamVjdC5oYXNVdnMgJiYgbWF0ZXJpYWwubWFwICkge1xyXG5cclxuXHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcnMudXYgKTtcclxuXHRcdFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIG9iamVjdC51dkFycmF5LCBfZ2wuRFlOQU1JQ19EUkFXICk7XHJcblxyXG5cdFx0XHRzdGF0ZS5lbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXMudXYgKTtcclxuXHJcblx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLnV2LCAyLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCAwICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggb2JqZWN0Lmhhc0NvbG9ycyAmJiBtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgIT09IFRIUkVFLk5vQ29sb3JzICkge1xyXG5cclxuXHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcnMuY29sb3IgKTtcclxuXHRcdFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIG9iamVjdC5jb2xvckFycmF5LCBfZ2wuRFlOQU1JQ19EUkFXICk7XHJcblxyXG5cdFx0XHRzdGF0ZS5lbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXMuY29sb3IgKTtcclxuXHJcblx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLmNvbG9yLCAzLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCAwICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHN0YXRlLmRpc2FibGVVbnVzZWRBdHRyaWJ1dGVzKCk7XHJcblxyXG5cdFx0X2dsLmRyYXdBcnJheXMoIF9nbC5UUklBTkdMRVMsIDAsIG9iamVjdC5jb3VudCApO1xyXG5cclxuXHRcdG9iamVjdC5jb3VudCA9IDA7XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMucmVuZGVyQnVmZmVyRGlyZWN0ID0gZnVuY3Rpb24gKCBjYW1lcmEsIGZvZywgZ2VvbWV0cnksIG1hdGVyaWFsLCBvYmplY3QsIGdyb3VwICkge1xyXG5cclxuXHRcdHNldE1hdGVyaWFsKCBtYXRlcmlhbCApO1xyXG5cclxuXHRcdHZhciBwcm9ncmFtID0gc2V0UHJvZ3JhbSggY2FtZXJhLCBmb2csIG1hdGVyaWFsLCBvYmplY3QgKTtcclxuXHJcblx0XHR2YXIgdXBkYXRlQnVmZmVycyA9IGZhbHNlO1xyXG5cdFx0dmFyIGdlb21ldHJ5UHJvZ3JhbSA9IGdlb21ldHJ5LmlkICsgJ18nICsgcHJvZ3JhbS5pZCArICdfJyArIG1hdGVyaWFsLndpcmVmcmFtZTtcclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5UHJvZ3JhbSAhPT0gX2N1cnJlbnRHZW9tZXRyeVByb2dyYW0gKSB7XHJcblxyXG5cdFx0XHRfY3VycmVudEdlb21ldHJ5UHJvZ3JhbSA9IGdlb21ldHJ5UHJvZ3JhbTtcclxuXHRcdFx0dXBkYXRlQnVmZmVycyA9IHRydWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIG1vcnBoIHRhcmdldHNcclxuXHJcblx0XHR2YXIgbW9ycGhUYXJnZXRJbmZsdWVuY2VzID0gb2JqZWN0Lm1vcnBoVGFyZ2V0SW5mbHVlbmNlcztcclxuXHJcblx0XHRpZiAoIG1vcnBoVGFyZ2V0SW5mbHVlbmNlcyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0dmFyIGFjdGl2ZUluZmx1ZW5jZXMgPSBbXTtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IG1vcnBoVGFyZ2V0SW5mbHVlbmNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgaW5mbHVlbmNlID0gbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBpIF07XHJcblx0XHRcdFx0YWN0aXZlSW5mbHVlbmNlcy5wdXNoKCBbIGluZmx1ZW5jZSwgaSBdICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRhY3RpdmVJbmZsdWVuY2VzLnNvcnQoIGFic051bWVyaWNhbFNvcnQgKTtcclxuXHJcblx0XHRcdGlmICggYWN0aXZlSW5mbHVlbmNlcy5sZW5ndGggPiA4ICkge1xyXG5cclxuXHRcdFx0XHRhY3RpdmVJbmZsdWVuY2VzLmxlbmd0aCA9IDg7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgbW9ycGhBdHRyaWJ1dGVzID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gYWN0aXZlSW5mbHVlbmNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgaW5mbHVlbmNlID0gYWN0aXZlSW5mbHVlbmNlc1sgaSBdO1xyXG5cdFx0XHRcdG1vcnBoSW5mbHVlbmNlc1sgaSBdID0gaW5mbHVlbmNlWyAwIF07XHJcblxyXG5cdFx0XHRcdGlmICggaW5mbHVlbmNlWyAwIF0gIT09IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIGluZGV4ID0gaW5mbHVlbmNlWyAxIF07XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBtYXRlcmlhbC5tb3JwaFRhcmdldHMgPT09IHRydWUgJiYgbW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uICkgZ2VvbWV0cnkuYWRkQXR0cmlidXRlKCAnbW9ycGhUYXJnZXQnICsgaSwgbW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uWyBpbmRleCBdICk7XHJcblx0XHRcdFx0XHRpZiAoIG1hdGVyaWFsLm1vcnBoTm9ybWFscyA9PT0gdHJ1ZSAmJiBtb3JwaEF0dHJpYnV0ZXMubm9ybWFsICkgZ2VvbWV0cnkuYWRkQXR0cmlidXRlKCAnbW9ycGhOb3JtYWwnICsgaSwgbW9ycGhBdHRyaWJ1dGVzLm5vcm1hbFsgaW5kZXggXSApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdGlmICggbWF0ZXJpYWwubW9ycGhUYXJnZXRzID09PSB0cnVlICkgZ2VvbWV0cnkucmVtb3ZlQXR0cmlidXRlKCAnbW9ycGhUYXJnZXQnICsgaSApO1xyXG5cdFx0XHRcdFx0aWYgKCBtYXRlcmlhbC5tb3JwaE5vcm1hbHMgPT09IHRydWUgKSBnZW9tZXRyeS5yZW1vdmVBdHRyaWJ1dGUoICdtb3JwaE5vcm1hbCcgKyBpICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciB1bmlmb3JtcyA9IHByb2dyYW0uZ2V0VW5pZm9ybXMoKTtcclxuXHJcblx0XHRcdGlmICggdW5pZm9ybXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHRfZ2wudW5pZm9ybTFmdiggdW5pZm9ybXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzLCBtb3JwaEluZmx1ZW5jZXMgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHVwZGF0ZUJ1ZmZlcnMgPSB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdHZhciBpbmRleCA9IGdlb21ldHJ5LmluZGV4O1xyXG5cdFx0dmFyIHBvc2l0aW9uID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsLndpcmVmcmFtZSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdGluZGV4ID0gb2JqZWN0cy5nZXRXaXJlZnJhbWVBdHRyaWJ1dGUoIGdlb21ldHJ5ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciByZW5kZXJlcjtcclxuXHJcblx0XHRpZiAoIGluZGV4ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0cmVuZGVyZXIgPSBpbmRleGVkQnVmZmVyUmVuZGVyZXI7XHJcblx0XHRcdHJlbmRlcmVyLnNldEluZGV4KCBpbmRleCApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRyZW5kZXJlciA9IGJ1ZmZlclJlbmRlcmVyO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHVwZGF0ZUJ1ZmZlcnMgKSB7XHJcblxyXG5cdFx0XHRzZXR1cFZlcnRleEF0dHJpYnV0ZXMoIG1hdGVyaWFsLCBwcm9ncmFtLCBnZW9tZXRyeSApO1xyXG5cclxuXHRcdFx0aWYgKCBpbmRleCAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgb2JqZWN0cy5nZXRBdHRyaWJ1dGVCdWZmZXIoIGluZGV4ICkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHR2YXIgZGF0YVN0YXJ0ID0gMDtcclxuXHRcdHZhciBkYXRhQ291bnQgPSBJbmZpbml0eTtcclxuXHJcblx0XHRpZiAoIGluZGV4ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0ZGF0YUNvdW50ID0gaW5kZXguY291bnQ7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggcG9zaXRpb24gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGRhdGFDb3VudCA9IHBvc2l0aW9uLmNvdW50O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgcmFuZ2VTdGFydCA9IGdlb21ldHJ5LmRyYXdSYW5nZS5zdGFydDtcclxuXHRcdHZhciByYW5nZUNvdW50ID0gZ2VvbWV0cnkuZHJhd1JhbmdlLmNvdW50O1xyXG5cclxuXHRcdHZhciBncm91cFN0YXJ0ID0gZ3JvdXAgIT09IG51bGwgPyBncm91cC5zdGFydCA6IDA7XHJcblx0XHR2YXIgZ3JvdXBDb3VudCA9IGdyb3VwICE9PSBudWxsID8gZ3JvdXAuY291bnQgOiBJbmZpbml0eTtcclxuXHJcblx0XHR2YXIgZHJhd1N0YXJ0ID0gTWF0aC5tYXgoIGRhdGFTdGFydCwgcmFuZ2VTdGFydCwgZ3JvdXBTdGFydCApO1xyXG5cdFx0dmFyIGRyYXdFbmQgPSBNYXRoLm1pbiggZGF0YVN0YXJ0ICsgZGF0YUNvdW50LCByYW5nZVN0YXJ0ICsgcmFuZ2VDb3VudCwgZ3JvdXBTdGFydCArIGdyb3VwQ291bnQgKSAtIDE7XHJcblxyXG5cdFx0dmFyIGRyYXdDb3VudCA9IE1hdGgubWF4KCAwLCBkcmF3RW5kIC0gZHJhd1N0YXJ0ICsgMSApO1xyXG5cclxuXHRcdC8vXHJcblxyXG5cdFx0aWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5NZXNoICkge1xyXG5cclxuXHRcdFx0aWYgKCBtYXRlcmlhbC53aXJlZnJhbWUgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdHN0YXRlLnNldExpbmVXaWR0aCggbWF0ZXJpYWwud2lyZWZyYW1lTGluZXdpZHRoICogZ2V0VGFyZ2V0UGl4ZWxSYXRpbygpICk7XHJcblx0XHRcdFx0cmVuZGVyZXIuc2V0TW9kZSggX2dsLkxJTkVTICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRzd2l0Y2ggKCBvYmplY3QuZHJhd01vZGUgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSBUSFJFRS5UcmlhbmdsZXNEcmF3TW9kZTpcclxuXHRcdFx0XHRcdFx0cmVuZGVyZXIuc2V0TW9kZSggX2dsLlRSSUFOR0xFUyApO1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlIFRIUkVFLlRyaWFuZ2xlU3RyaXBEcmF3TW9kZTpcclxuXHRcdFx0XHRcdFx0cmVuZGVyZXIuc2V0TW9kZSggX2dsLlRSSUFOR0xFX1NUUklQICk7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgVEhSRUUuVHJpYW5nbGVGYW5EcmF3TW9kZTpcclxuXHRcdFx0XHRcdFx0cmVuZGVyZXIuc2V0TW9kZSggX2dsLlRSSUFOR0xFX0ZBTiApO1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHJcblx0XHR9IGVsc2UgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5MaW5lICkge1xyXG5cclxuXHRcdFx0dmFyIGxpbmVXaWR0aCA9IG1hdGVyaWFsLmxpbmV3aWR0aDtcclxuXHJcblx0XHRcdGlmICggbGluZVdpZHRoID09PSB1bmRlZmluZWQgKSBsaW5lV2lkdGggPSAxOyAvLyBOb3QgdXNpbmcgTGluZSpNYXRlcmlhbFxyXG5cclxuXHRcdFx0c3RhdGUuc2V0TGluZVdpZHRoKCBsaW5lV2lkdGggKiBnZXRUYXJnZXRQaXhlbFJhdGlvKCkgKTtcclxuXHJcblx0XHRcdGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTGluZVNlZ21lbnRzICkge1xyXG5cclxuXHRcdFx0XHRyZW5kZXJlci5zZXRNb2RlKCBfZ2wuTElORVMgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHJlbmRlcmVyLnNldE1vZGUoIF9nbC5MSU5FX1NUUklQICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuUG9pbnRzICkge1xyXG5cclxuXHRcdFx0cmVuZGVyZXIuc2V0TW9kZSggX2dsLlBPSU5UUyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkgJiYgZ2VvbWV0cnkubWF4SW5zdGFuY2VkQ291bnQgPiAwICkge1xyXG5cclxuXHRcdFx0cmVuZGVyZXIucmVuZGVySW5zdGFuY2VzKCBnZW9tZXRyeSwgZHJhd1N0YXJ0LCBkcmF3Q291bnQgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0cmVuZGVyZXIucmVuZGVyKCBkcmF3U3RhcnQsIGRyYXdDb3VudCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gc2V0dXBWZXJ0ZXhBdHRyaWJ1dGVzKCBtYXRlcmlhbCwgcHJvZ3JhbSwgZ2VvbWV0cnksIHN0YXJ0SW5kZXggKSB7XHJcblxyXG5cdFx0dmFyIGV4dGVuc2lvbjtcclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0XHRleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ0FOR0xFX2luc3RhbmNlZF9hcnJheXMnICk7XHJcblxyXG5cdFx0XHRpZiAoIGV4dGVuc2lvbiA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMUmVuZGVyZXIuc2V0dXBWZXJ0ZXhBdHRyaWJ1dGVzOiB1c2luZyBUSFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSBidXQgaGFyZHdhcmUgZG9lcyBub3Qgc3VwcG9ydCBleHRlbnNpb24gQU5HTEVfaW5zdGFuY2VkX2FycmF5cy4nICk7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHN0YXJ0SW5kZXggPT09IHVuZGVmaW5lZCApIHN0YXJ0SW5kZXggPSAwO1xyXG5cclxuXHRcdHN0YXRlLmluaXRBdHRyaWJ1dGVzKCk7XHJcblxyXG5cdFx0dmFyIGdlb21ldHJ5QXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XHJcblxyXG5cdFx0dmFyIHByb2dyYW1BdHRyaWJ1dGVzID0gcHJvZ3JhbS5nZXRBdHRyaWJ1dGVzKCk7XHJcblxyXG5cdFx0dmFyIG1hdGVyaWFsRGVmYXVsdEF0dHJpYnV0ZVZhbHVlcyA9IG1hdGVyaWFsLmRlZmF1bHRBdHRyaWJ1dGVWYWx1ZXM7XHJcblxyXG5cdFx0Zm9yICggdmFyIG5hbWUgaW4gcHJvZ3JhbUF0dHJpYnV0ZXMgKSB7XHJcblxyXG5cdFx0XHR2YXIgcHJvZ3JhbUF0dHJpYnV0ZSA9IHByb2dyYW1BdHRyaWJ1dGVzWyBuYW1lIF07XHJcblxyXG5cdFx0XHRpZiAoIHByb2dyYW1BdHRyaWJ1dGUgPj0gMCApIHtcclxuXHJcblx0XHRcdFx0dmFyIGdlb21ldHJ5QXR0cmlidXRlID0gZ2VvbWV0cnlBdHRyaWJ1dGVzWyBuYW1lIF07XHJcblxyXG5cdFx0XHRcdGlmICggZ2VvbWV0cnlBdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgc2l6ZSA9IGdlb21ldHJ5QXR0cmlidXRlLml0ZW1TaXplO1xyXG5cdFx0XHRcdFx0dmFyIGJ1ZmZlciA9IG9iamVjdHMuZ2V0QXR0cmlidXRlQnVmZmVyKCBnZW9tZXRyeUF0dHJpYnV0ZSApO1xyXG5cclxuXHRcdFx0XHRcdGlmICggZ2VvbWV0cnlBdHRyaWJ1dGUgaW5zdGFuY2VvZiBUSFJFRS5JbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSApIHtcclxuXHJcblx0XHRcdFx0XHRcdHZhciBkYXRhID0gZ2VvbWV0cnlBdHRyaWJ1dGUuZGF0YTtcclxuXHRcdFx0XHRcdFx0dmFyIHN0cmlkZSA9IGRhdGEuc3RyaWRlO1xyXG5cdFx0XHRcdFx0XHR2YXIgb2Zmc2V0ID0gZ2VvbWV0cnlBdHRyaWJ1dGUub2Zmc2V0O1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCBkYXRhIGluc3RhbmNlb2YgVEhSRUUuSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHN0YXRlLmVuYWJsZUF0dHJpYnV0ZUFuZERpdmlzb3IoIHByb2dyYW1BdHRyaWJ1dGUsIGRhdGEubWVzaFBlckF0dHJpYnV0ZSwgZXh0ZW5zaW9uICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGlmICggZ2VvbWV0cnkubWF4SW5zdGFuY2VkQ291bnQgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRnZW9tZXRyeS5tYXhJbnN0YW5jZWRDb3VudCA9IGRhdGEubWVzaFBlckF0dHJpYnV0ZSAqIGRhdGEuY291bnQ7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHN0YXRlLmVuYWJsZUF0dHJpYnV0ZSggcHJvZ3JhbUF0dHJpYnV0ZSApO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlciApO1xyXG5cdFx0XHRcdFx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggcHJvZ3JhbUF0dHJpYnV0ZSwgc2l6ZSwgX2dsLkZMT0FULCBmYWxzZSwgc3RyaWRlICogZGF0YS5hcnJheS5CWVRFU19QRVJfRUxFTUVOVCwgKCBzdGFydEluZGV4ICogc3RyaWRlICsgb2Zmc2V0ICkgKiBkYXRhLmFycmF5LkJZVEVTX1BFUl9FTEVNRU5UICk7XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggZ2VvbWV0cnlBdHRyaWJ1dGUgaW5zdGFuY2VvZiBUSFJFRS5JbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHN0YXRlLmVuYWJsZUF0dHJpYnV0ZUFuZERpdmlzb3IoIHByb2dyYW1BdHRyaWJ1dGUsIGdlb21ldHJ5QXR0cmlidXRlLm1lc2hQZXJBdHRyaWJ1dGUsIGV4dGVuc2lvbiApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRpZiAoIGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0Z2VvbWV0cnkubWF4SW5zdGFuY2VkQ291bnQgPSBnZW9tZXRyeUF0dHJpYnV0ZS5tZXNoUGVyQXR0cmlidXRlICogZ2VvbWV0cnlBdHRyaWJ1dGUuY291bnQ7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHN0YXRlLmVuYWJsZUF0dHJpYnV0ZSggcHJvZ3JhbUF0dHJpYnV0ZSApO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlciApO1xyXG5cdFx0XHRcdFx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggcHJvZ3JhbUF0dHJpYnV0ZSwgc2l6ZSwgX2dsLkZMT0FULCBmYWxzZSwgMCwgc3RhcnRJbmRleCAqIHNpemUgKiA0ICk7IC8vIDQgYnl0ZXMgcGVyIEZsb2F0MzJcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsRGVmYXVsdEF0dHJpYnV0ZVZhbHVlcyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciB2YWx1ZSA9IG1hdGVyaWFsRGVmYXVsdEF0dHJpYnV0ZVZhbHVlc1sgbmFtZSBdO1xyXG5cclxuXHRcdFx0XHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRcdHN3aXRjaCAoIHZhbHVlLmxlbmd0aCApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0Y2FzZSAyOlxyXG5cdFx0XHRcdFx0XHRcdFx0X2dsLnZlcnRleEF0dHJpYjJmdiggcHJvZ3JhbUF0dHJpYnV0ZSwgdmFsdWUgKTtcclxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjYXNlIDM6XHJcblx0XHRcdFx0XHRcdFx0XHRfZ2wudmVydGV4QXR0cmliM2Z2KCBwcm9ncmFtQXR0cmlidXRlLCB2YWx1ZSApO1xyXG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGNhc2UgNDpcclxuXHRcdFx0XHRcdFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWI0ZnYoIHByb2dyYW1BdHRyaWJ1dGUsIHZhbHVlICk7XHJcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRcdFx0ZGVmYXVsdDpcclxuXHRcdFx0XHRcdFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWIxZnYoIHByb2dyYW1BdHRyaWJ1dGUsIHZhbHVlICk7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHN0YXRlLmRpc2FibGVVbnVzZWRBdHRyaWJ1dGVzKCk7XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gU29ydGluZ1xyXG5cclxuXHRmdW5jdGlvbiBhYnNOdW1lcmljYWxTb3J0KCBhLCBiICkge1xyXG5cclxuXHRcdHJldHVybiBNYXRoLmFicyggYlsgMCBdICkgLSBNYXRoLmFicyggYVsgMCBdICk7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gcGFpbnRlclNvcnRTdGFibGUgKCBhLCBiICkge1xyXG5cclxuXHRcdGlmICggYS5vYmplY3QucmVuZGVyT3JkZXIgIT09IGIub2JqZWN0LnJlbmRlck9yZGVyICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIGEub2JqZWN0LnJlbmRlck9yZGVyIC0gYi5vYmplY3QucmVuZGVyT3JkZXI7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggYS5tYXRlcmlhbC5pZCAhPT0gYi5tYXRlcmlhbC5pZCApIHtcclxuXHJcblx0XHRcdHJldHVybiBhLm1hdGVyaWFsLmlkIC0gYi5tYXRlcmlhbC5pZDtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBhLnogIT09IGIueiApIHtcclxuXHJcblx0XHRcdHJldHVybiBhLnogLSBiLno7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHJldHVybiBhLmlkIC0gYi5pZDtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gcmV2ZXJzZVBhaW50ZXJTb3J0U3RhYmxlICggYSwgYiApIHtcclxuXHJcblx0XHRpZiAoIGEub2JqZWN0LnJlbmRlck9yZGVyICE9PSBiLm9iamVjdC5yZW5kZXJPcmRlciApIHtcclxuXHJcblx0XHRcdHJldHVybiBhLm9iamVjdC5yZW5kZXJPcmRlciAtIGIub2JqZWN0LnJlbmRlck9yZGVyO1xyXG5cclxuXHRcdH0gaWYgKCBhLnogIT09IGIueiApIHtcclxuXHJcblx0XHRcdHJldHVybiBiLnogLSBhLno7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHJldHVybiBhLmlkIC0gYi5pZDtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gUmVuZGVyaW5nXHJcblxyXG5cdHRoaXMucmVuZGVyID0gZnVuY3Rpb24gKCBzY2VuZSwgY2FtZXJhLCByZW5kZXJUYXJnZXQsIGZvcmNlQ2xlYXIgKSB7XHJcblxyXG5cdFx0aWYgKCBjYW1lcmEgaW5zdGFuY2VvZiBUSFJFRS5DYW1lcmEgPT09IGZhbHNlICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMUmVuZGVyZXIucmVuZGVyOiBjYW1lcmEgaXMgbm90IGFuIGluc3RhbmNlIG9mIFRIUkVFLkNhbWVyYS4nICk7XHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGZvZyA9IHNjZW5lLmZvZztcclxuXHJcblx0XHQvLyByZXNldCBjYWNoaW5nIGZvciB0aGlzIGZyYW1lXHJcblxyXG5cdFx0X2N1cnJlbnRHZW9tZXRyeVByb2dyYW0gPSAnJztcclxuXHRcdF9jdXJyZW50TWF0ZXJpYWxJZCA9IC0gMTtcclxuXHRcdF9jdXJyZW50Q2FtZXJhID0gbnVsbDtcclxuXHJcblx0XHQvLyB1cGRhdGUgc2NlbmUgZ3JhcGhcclxuXHJcblx0XHRpZiAoIHNjZW5lLmF1dG9VcGRhdGUgPT09IHRydWUgKSBzY2VuZS51cGRhdGVNYXRyaXhXb3JsZCgpO1xyXG5cclxuXHRcdC8vIHVwZGF0ZSBjYW1lcmEgbWF0cmljZXMgYW5kIGZydXN0dW1cclxuXHJcblx0XHRpZiAoIGNhbWVyYS5wYXJlbnQgPT09IG51bGwgKSBjYW1lcmEudXBkYXRlTWF0cml4V29ybGQoKTtcclxuXHJcblx0XHRjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLmdldEludmVyc2UoIGNhbWVyYS5tYXRyaXhXb3JsZCApO1xyXG5cclxuXHRcdF9wcm9qU2NyZWVuTWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4LCBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlICk7XHJcblx0XHRfZnJ1c3R1bS5zZXRGcm9tTWF0cml4KCBfcHJvalNjcmVlbk1hdHJpeCApO1xyXG5cclxuXHRcdGxpZ2h0cy5sZW5ndGggPSAwO1xyXG5cclxuXHRcdG9wYXF1ZU9iamVjdHNMYXN0SW5kZXggPSAtIDE7XHJcblx0XHR0cmFuc3BhcmVudE9iamVjdHNMYXN0SW5kZXggPSAtIDE7XHJcblxyXG5cdFx0c3ByaXRlcy5sZW5ndGggPSAwO1xyXG5cdFx0bGVuc0ZsYXJlcy5sZW5ndGggPSAwO1xyXG5cclxuXHRcdHByb2plY3RPYmplY3QoIHNjZW5lLCBjYW1lcmEgKTtcclxuXHJcblx0XHRvcGFxdWVPYmplY3RzLmxlbmd0aCA9IG9wYXF1ZU9iamVjdHNMYXN0SW5kZXggKyAxO1xyXG5cdFx0dHJhbnNwYXJlbnRPYmplY3RzLmxlbmd0aCA9IHRyYW5zcGFyZW50T2JqZWN0c0xhc3RJbmRleCArIDE7XHJcblxyXG5cdFx0aWYgKCBfdGhpcy5zb3J0T2JqZWN0cyA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdG9wYXF1ZU9iamVjdHMuc29ydCggcGFpbnRlclNvcnRTdGFibGUgKTtcclxuXHRcdFx0dHJhbnNwYXJlbnRPYmplY3RzLnNvcnQoIHJldmVyc2VQYWludGVyU29ydFN0YWJsZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRzZXR1cExpZ2h0cyggbGlnaHRzLCBjYW1lcmEgKTtcclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdHNoYWRvd01hcC5yZW5kZXIoIHNjZW5lLCBjYW1lcmEgKTtcclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdF9pbmZvUmVuZGVyLmNhbGxzID0gMDtcclxuXHRcdF9pbmZvUmVuZGVyLnZlcnRpY2VzID0gMDtcclxuXHRcdF9pbmZvUmVuZGVyLmZhY2VzID0gMDtcclxuXHRcdF9pbmZvUmVuZGVyLnBvaW50cyA9IDA7XHJcblxyXG5cdFx0aWYgKCByZW5kZXJUYXJnZXQgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHJlbmRlclRhcmdldCA9IG51bGw7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuc2V0UmVuZGVyVGFyZ2V0KCByZW5kZXJUYXJnZXQgKTtcclxuXHJcblx0XHRpZiAoIHRoaXMuYXV0b0NsZWFyIHx8IGZvcmNlQ2xlYXIgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmNsZWFyKCB0aGlzLmF1dG9DbGVhckNvbG9yLCB0aGlzLmF1dG9DbGVhckRlcHRoLCB0aGlzLmF1dG9DbGVhclN0ZW5jaWwgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHRpZiAoIHNjZW5lLm92ZXJyaWRlTWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHR2YXIgb3ZlcnJpZGVNYXRlcmlhbCA9IHNjZW5lLm92ZXJyaWRlTWF0ZXJpYWw7XHJcblxyXG5cdFx0XHRyZW5kZXJPYmplY3RzKCBvcGFxdWVPYmplY3RzLCBjYW1lcmEsIGZvZywgb3ZlcnJpZGVNYXRlcmlhbCApO1xyXG5cdFx0XHRyZW5kZXJPYmplY3RzKCB0cmFuc3BhcmVudE9iamVjdHMsIGNhbWVyYSwgZm9nLCBvdmVycmlkZU1hdGVyaWFsICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdC8vIG9wYXF1ZSBwYXNzIChmcm9udC10by1iYWNrIG9yZGVyKVxyXG5cclxuXHRcdFx0c3RhdGUuc2V0QmxlbmRpbmcoIFRIUkVFLk5vQmxlbmRpbmcgKTtcclxuXHRcdFx0cmVuZGVyT2JqZWN0cyggb3BhcXVlT2JqZWN0cywgY2FtZXJhLCBmb2cgKTtcclxuXHJcblx0XHRcdC8vIHRyYW5zcGFyZW50IHBhc3MgKGJhY2stdG8tZnJvbnQgb3JkZXIpXHJcblxyXG5cdFx0XHRyZW5kZXJPYmplY3RzKCB0cmFuc3BhcmVudE9iamVjdHMsIGNhbWVyYSwgZm9nICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGN1c3RvbSByZW5kZXIgcGx1Z2lucyAocG9zdCBwYXNzKVxyXG5cclxuXHRcdHNwcml0ZVBsdWdpbi5yZW5kZXIoIHNjZW5lLCBjYW1lcmEgKTtcclxuXHRcdGxlbnNGbGFyZVBsdWdpbi5yZW5kZXIoIHNjZW5lLCBjYW1lcmEsIF9jdXJyZW50Vmlld3BvcnQgKTtcclxuXHJcblx0XHQvLyBHZW5lcmF0ZSBtaXBtYXAgaWYgd2UncmUgdXNpbmcgYW55IGtpbmQgb2YgbWlwbWFwIGZpbHRlcmluZ1xyXG5cclxuXHRcdGlmICggcmVuZGVyVGFyZ2V0ICkge1xyXG5cclxuXHRcdFx0dmFyIHRleHR1cmUgPSByZW5kZXJUYXJnZXQudGV4dHVyZTtcclxuXHJcblx0XHRcdGlmICggdGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgJiYgaXNQb3dlck9mVHdvKCByZW5kZXJUYXJnZXQgKSAmJlxyXG5cdFx0XHRcdFx0dGV4dHVyZS5taW5GaWx0ZXIgIT09IFRIUkVFLk5lYXJlc3RGaWx0ZXIgJiZcclxuXHRcdFx0XHRcdHRleHR1cmUubWluRmlsdGVyICE9PSBUSFJFRS5MaW5lYXJGaWx0ZXIgKSB7XHJcblxyXG5cdFx0XHRcdHVwZGF0ZVJlbmRlclRhcmdldE1pcG1hcCggcmVuZGVyVGFyZ2V0ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEVuc3VyZSBkZXB0aCBidWZmZXIgd3JpdGluZyBpcyBlbmFibGVkIHNvIGl0IGNhbiBiZSBjbGVhcmVkIG9uIG5leHQgcmVuZGVyXHJcblxyXG5cdFx0c3RhdGUuc2V0RGVwdGhUZXN0KCB0cnVlICk7XHJcblx0XHRzdGF0ZS5zZXREZXB0aFdyaXRlKCB0cnVlICk7XHJcblx0XHRzdGF0ZS5zZXRDb2xvcldyaXRlKCB0cnVlICk7XHJcblxyXG5cdFx0Ly8gX2dsLmZpbmlzaCgpO1xyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBwdXNoUmVuZGVySXRlbSggb2JqZWN0LCBnZW9tZXRyeSwgbWF0ZXJpYWwsIHosIGdyb3VwICkge1xyXG5cclxuXHRcdHZhciBhcnJheSwgaW5kZXg7XHJcblxyXG5cdFx0Ly8gYWxsb2NhdGUgdGhlIG5leHQgcG9zaXRpb24gaW4gdGhlIGFwcHJvcHJpYXRlIGFycmF5XHJcblxyXG5cdFx0aWYgKCBtYXRlcmlhbC50cmFuc3BhcmVudCApIHtcclxuXHJcblx0XHRcdGFycmF5ID0gdHJhbnNwYXJlbnRPYmplY3RzO1xyXG5cdFx0XHRpbmRleCA9ICsrIHRyYW5zcGFyZW50T2JqZWN0c0xhc3RJbmRleDtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0YXJyYXkgPSBvcGFxdWVPYmplY3RzO1xyXG5cdFx0XHRpbmRleCA9ICsrIG9wYXF1ZU9iamVjdHNMYXN0SW5kZXg7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHJlY3ljbGUgZXhpc3RpbmcgcmVuZGVyIGl0ZW0gb3IgZ3JvdyB0aGUgYXJyYXlcclxuXHJcblx0XHR2YXIgcmVuZGVySXRlbSA9IGFycmF5WyBpbmRleCBdO1xyXG5cclxuXHRcdGlmICggcmVuZGVySXRlbSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0cmVuZGVySXRlbS5pZCA9IG9iamVjdC5pZDtcclxuXHRcdFx0cmVuZGVySXRlbS5vYmplY3QgPSBvYmplY3Q7XHJcblx0XHRcdHJlbmRlckl0ZW0uZ2VvbWV0cnkgPSBnZW9tZXRyeTtcclxuXHRcdFx0cmVuZGVySXRlbS5tYXRlcmlhbCA9IG1hdGVyaWFsO1xyXG5cdFx0XHRyZW5kZXJJdGVtLnogPSBfdmVjdG9yMy56O1xyXG5cdFx0XHRyZW5kZXJJdGVtLmdyb3VwID0gZ3JvdXA7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHJlbmRlckl0ZW0gPSB7XHJcblx0XHRcdFx0aWQ6IG9iamVjdC5pZCxcclxuXHRcdFx0XHRvYmplY3Q6IG9iamVjdCxcclxuXHRcdFx0XHRnZW9tZXRyeTogZ2VvbWV0cnksXHJcblx0XHRcdFx0bWF0ZXJpYWw6IG1hdGVyaWFsLFxyXG5cdFx0XHRcdHo6IF92ZWN0b3IzLnosXHJcblx0XHRcdFx0Z3JvdXA6IGdyb3VwXHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHQvLyBhc3NlcnQoIGluZGV4ID09PSBhcnJheS5sZW5ndGggKTtcclxuXHRcdFx0YXJyYXkucHVzaCggcmVuZGVySXRlbSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBwcm9qZWN0T2JqZWN0KCBvYmplY3QsIGNhbWVyYSApIHtcclxuXHJcblx0XHRpZiAoIG9iamVjdC52aXNpYmxlID09PSBmYWxzZSApIHJldHVybjtcclxuXHJcblx0XHRpZiAoIG9iamVjdC5sYXllcnMudGVzdCggY2FtZXJhLmxheWVycyApICkge1xyXG5cclxuXHRcdFx0aWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5MaWdodCApIHtcclxuXHJcblx0XHRcdFx0bGlnaHRzLnB1c2goIG9iamVjdCApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuU3ByaXRlICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIG9iamVjdC5mcnVzdHVtQ3VsbGVkID09PSBmYWxzZSB8fCBfZnJ1c3R1bS5pbnRlcnNlY3RzT2JqZWN0KCBvYmplY3QgKSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdFx0XHRzcHJpdGVzLnB1c2goIG9iamVjdCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5MZW5zRmxhcmUgKSB7XHJcblxyXG5cdFx0XHRcdGxlbnNGbGFyZXMucHVzaCggb2JqZWN0ICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5JbW1lZGlhdGVSZW5kZXJPYmplY3QgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggX3RoaXMuc29ydE9iamVjdHMgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdFx0X3ZlY3RvcjMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBvYmplY3QubWF0cml4V29ybGQgKTtcclxuXHRcdFx0XHRcdF92ZWN0b3IzLmFwcGx5UHJvamVjdGlvbiggX3Byb2pTY3JlZW5NYXRyaXggKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRwdXNoUmVuZGVySXRlbSggb2JqZWN0LCBudWxsLCBvYmplY3QubWF0ZXJpYWwsIF92ZWN0b3IzLnosIG51bGwgKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLk1lc2ggfHwgb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTGluZSB8fCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5Qb2ludHMgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuU2tpbm5lZE1lc2ggKSB7XHJcblxyXG5cdFx0XHRcdFx0b2JqZWN0LnNrZWxldG9uLnVwZGF0ZSgpO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggb2JqZWN0LmZydXN0dW1DdWxsZWQgPT09IGZhbHNlIHx8IF9mcnVzdHVtLmludGVyc2VjdHNPYmplY3QoIG9iamVjdCApID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciBtYXRlcmlhbCA9IG9iamVjdC5tYXRlcmlhbDtcclxuXHJcblx0XHRcdFx0XHRpZiAoIG1hdGVyaWFsLnZpc2libGUgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIF90aGlzLnNvcnRPYmplY3RzID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRfdmVjdG9yMy5zZXRGcm9tTWF0cml4UG9zaXRpb24oIG9iamVjdC5tYXRyaXhXb3JsZCApO1xyXG5cdFx0XHRcdFx0XHRcdF92ZWN0b3IzLmFwcGx5UHJvamVjdGlvbiggX3Byb2pTY3JlZW5NYXRyaXggKTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdHZhciBnZW9tZXRyeSA9IG9iamVjdHMudXBkYXRlKCBvYmplY3QgKTtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NdWx0aU1hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHR2YXIgZ3JvdXBzID0gZ2VvbWV0cnkuZ3JvdXBzO1xyXG5cdFx0XHRcdFx0XHRcdHZhciBtYXRlcmlhbHMgPSBtYXRlcmlhbC5tYXRlcmlhbHM7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdHZhciBncm91cCA9IGdyb3Vwc1sgaSBdO1xyXG5cdFx0XHRcdFx0XHRcdFx0dmFyIGdyb3VwTWF0ZXJpYWwgPSBtYXRlcmlhbHNbIGdyb3VwLm1hdGVyaWFsSW5kZXggXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGdyb3VwTWF0ZXJpYWwudmlzaWJsZSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRcdHB1c2hSZW5kZXJJdGVtKCBvYmplY3QsIGdlb21ldHJ5LCBncm91cE1hdGVyaWFsLCBfdmVjdG9yMy56LCBncm91cCApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0cHVzaFJlbmRlckl0ZW0oIG9iamVjdCwgZ2VvbWV0cnksIG1hdGVyaWFsLCBfdmVjdG9yMy56LCBudWxsICk7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBjaGlsZHJlbiA9IG9iamVjdC5jaGlsZHJlbjtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0cHJvamVjdE9iamVjdCggY2hpbGRyZW5bIGkgXSwgY2FtZXJhICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHJlbmRlck9iamVjdHMoIHJlbmRlckxpc3QsIGNhbWVyYSwgZm9nLCBvdmVycmlkZU1hdGVyaWFsICkge1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHJlbmRlckxpc3QubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciByZW5kZXJJdGVtID0gcmVuZGVyTGlzdFsgaSBdO1xyXG5cclxuXHRcdFx0dmFyIG9iamVjdCA9IHJlbmRlckl0ZW0ub2JqZWN0O1xyXG5cdFx0XHR2YXIgZ2VvbWV0cnkgPSByZW5kZXJJdGVtLmdlb21ldHJ5O1xyXG5cdFx0XHR2YXIgbWF0ZXJpYWwgPSBvdmVycmlkZU1hdGVyaWFsID09PSB1bmRlZmluZWQgPyByZW5kZXJJdGVtLm1hdGVyaWFsIDogb3ZlcnJpZGVNYXRlcmlhbDtcclxuXHRcdFx0dmFyIGdyb3VwID0gcmVuZGVySXRlbS5ncm91cDtcclxuXHJcblx0XHRcdG9iamVjdC5tb2RlbFZpZXdNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSwgb2JqZWN0Lm1hdHJpeFdvcmxkICk7XHJcblx0XHRcdG9iamVjdC5ub3JtYWxNYXRyaXguZ2V0Tm9ybWFsTWF0cml4KCBvYmplY3QubW9kZWxWaWV3TWF0cml4ICk7XHJcblxyXG5cdFx0XHRpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkltbWVkaWF0ZVJlbmRlck9iamVjdCApIHtcclxuXHJcblx0XHRcdFx0c2V0TWF0ZXJpYWwoIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0XHRcdHZhciBwcm9ncmFtID0gc2V0UHJvZ3JhbSggY2FtZXJhLCBmb2csIG1hdGVyaWFsLCBvYmplY3QgKTtcclxuXHJcblx0XHRcdFx0X2N1cnJlbnRHZW9tZXRyeVByb2dyYW0gPSAnJztcclxuXHJcblx0XHRcdFx0b2JqZWN0LnJlbmRlciggZnVuY3Rpb24gKCBvYmplY3QgKSB7XHJcblxyXG5cdFx0XHRcdFx0X3RoaXMucmVuZGVyQnVmZmVySW1tZWRpYXRlKCBvYmplY3QsIHByb2dyYW0sIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0XHRcdH0gKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdF90aGlzLnJlbmRlckJ1ZmZlckRpcmVjdCggY2FtZXJhLCBmb2csIGdlb21ldHJ5LCBtYXRlcmlhbCwgb2JqZWN0LCBncm91cCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBpbml0TWF0ZXJpYWwoIG1hdGVyaWFsLCBmb2csIG9iamVjdCApIHtcclxuXHJcblx0XHR2YXIgbWF0ZXJpYWxQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0dmFyIHBhcmFtZXRlcnMgPSBwcm9ncmFtQ2FjaGUuZ2V0UGFyYW1ldGVycyggbWF0ZXJpYWwsIF9saWdodHMsIGZvZywgb2JqZWN0ICk7XHJcblx0XHR2YXIgY29kZSA9IHByb2dyYW1DYWNoZS5nZXRQcm9ncmFtQ29kZSggbWF0ZXJpYWwsIHBhcmFtZXRlcnMgKTtcclxuXHJcblx0XHR2YXIgcHJvZ3JhbSA9IG1hdGVyaWFsUHJvcGVydGllcy5wcm9ncmFtO1xyXG5cdFx0dmFyIHByb2dyYW1DaGFuZ2UgPSB0cnVlO1xyXG5cclxuXHRcdGlmICggcHJvZ3JhbSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Ly8gbmV3IG1hdGVyaWFsXHJcblx0XHRcdG1hdGVyaWFsLmFkZEV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25NYXRlcmlhbERpc3Bvc2UgKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBwcm9ncmFtLmNvZGUgIT09IGNvZGUgKSB7XHJcblxyXG5cdFx0XHQvLyBjaGFuZ2VkIGdsc2wgb3IgcGFyYW1ldGVyc1xyXG5cdFx0XHRyZWxlYXNlTWF0ZXJpYWxQcm9ncmFtUmVmZXJlbmNlKCBtYXRlcmlhbCApO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIHBhcmFtZXRlcnMuc2hhZGVySUQgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdC8vIHNhbWUgZ2xzbCBhbmQgdW5pZm9ybSBsaXN0XHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0Ly8gb25seSByZWJ1aWxkIHVuaWZvcm0gbGlzdFxyXG5cdFx0XHRwcm9ncmFtQ2hhbmdlID0gZmFsc2U7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggcHJvZ3JhbUNoYW5nZSApIHtcclxuXHJcblx0XHRcdGlmICggcGFyYW1ldGVycy5zaGFkZXJJRCApIHtcclxuXHJcblx0XHRcdFx0dmFyIHNoYWRlciA9IFRIUkVFLlNoYWRlckxpYlsgcGFyYW1ldGVycy5zaGFkZXJJRCBdO1xyXG5cclxuXHRcdFx0XHRtYXRlcmlhbFByb3BlcnRpZXMuX193ZWJnbFNoYWRlciA9IHtcclxuXHRcdFx0XHRcdG5hbWU6IG1hdGVyaWFsLnR5cGUsXHJcblx0XHRcdFx0XHR1bmlmb3JtczogVEhSRUUuVW5pZm9ybXNVdGlscy5jbG9uZSggc2hhZGVyLnVuaWZvcm1zICksXHJcblx0XHRcdFx0XHR2ZXJ0ZXhTaGFkZXI6IHNoYWRlci52ZXJ0ZXhTaGFkZXIsXHJcblx0XHRcdFx0XHRmcmFnbWVudFNoYWRlcjogc2hhZGVyLmZyYWdtZW50U2hhZGVyXHJcblx0XHRcdFx0fTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdG1hdGVyaWFsUHJvcGVydGllcy5fX3dlYmdsU2hhZGVyID0ge1xyXG5cdFx0XHRcdFx0bmFtZTogbWF0ZXJpYWwudHlwZSxcclxuXHRcdFx0XHRcdHVuaWZvcm1zOiBtYXRlcmlhbC51bmlmb3JtcyxcclxuXHRcdFx0XHRcdHZlcnRleFNoYWRlcjogbWF0ZXJpYWwudmVydGV4U2hhZGVyLFxyXG5cdFx0XHRcdFx0ZnJhZ21lbnRTaGFkZXI6IG1hdGVyaWFsLmZyYWdtZW50U2hhZGVyXHJcblx0XHRcdFx0fTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdG1hdGVyaWFsLl9fd2ViZ2xTaGFkZXIgPSBtYXRlcmlhbFByb3BlcnRpZXMuX193ZWJnbFNoYWRlcjtcclxuXHJcblx0XHRcdHByb2dyYW0gPSBwcm9ncmFtQ2FjaGUuYWNxdWlyZVByb2dyYW0oIG1hdGVyaWFsLCBwYXJhbWV0ZXJzLCBjb2RlICk7XHJcblxyXG5cdFx0XHRtYXRlcmlhbFByb3BlcnRpZXMucHJvZ3JhbSA9IHByb2dyYW07XHJcblx0XHRcdG1hdGVyaWFsLnByb2dyYW0gPSBwcm9ncmFtO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgYXR0cmlidXRlcyA9IHByb2dyYW0uZ2V0QXR0cmlidXRlcygpO1xyXG5cclxuXHRcdGlmICggbWF0ZXJpYWwubW9ycGhUYXJnZXRzICkge1xyXG5cclxuXHRcdFx0bWF0ZXJpYWwubnVtU3VwcG9ydGVkTW9ycGhUYXJnZXRzID0gMDtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IF90aGlzLm1heE1vcnBoVGFyZ2V0czsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBhdHRyaWJ1dGVzWyAnbW9ycGhUYXJnZXQnICsgaSBdID49IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0bWF0ZXJpYWwubnVtU3VwcG9ydGVkTW9ycGhUYXJnZXRzICsrO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggbWF0ZXJpYWwubW9ycGhOb3JtYWxzICkge1xyXG5cclxuXHRcdFx0bWF0ZXJpYWwubnVtU3VwcG9ydGVkTW9ycGhOb3JtYWxzID0gMDtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IF90aGlzLm1heE1vcnBoTm9ybWFsczsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBhdHRyaWJ1dGVzWyAnbW9ycGhOb3JtYWwnICsgaSBdID49IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0bWF0ZXJpYWwubnVtU3VwcG9ydGVkTW9ycGhOb3JtYWxzICsrO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdG1hdGVyaWFsUHJvcGVydGllcy51bmlmb3Jtc0xpc3QgPSBbXTtcclxuXHJcblx0XHR2YXIgdW5pZm9ybXMgPSBtYXRlcmlhbFByb3BlcnRpZXMuX193ZWJnbFNoYWRlci51bmlmb3JtcyxcclxuXHRcdFx0dW5pZm9ybUxvY2F0aW9ucyA9IG1hdGVyaWFsUHJvcGVydGllcy5wcm9ncmFtLmdldFVuaWZvcm1zKCk7XHJcblxyXG5cdFx0Zm9yICggdmFyIHUgaW4gdW5pZm9ybXMgKSB7XHJcblxyXG5cdFx0XHR2YXIgbG9jYXRpb24gPSB1bmlmb3JtTG9jYXRpb25zWyB1IF07XHJcblxyXG5cdFx0XHRpZiAoIGxvY2F0aW9uICkge1xyXG5cclxuXHRcdFx0XHRtYXRlcmlhbFByb3BlcnRpZXMudW5pZm9ybXNMaXN0LnB1c2goIFsgbWF0ZXJpYWxQcm9wZXJ0aWVzLl9fd2ViZ2xTaGFkZXIudW5pZm9ybXNbIHUgXSwgbG9jYXRpb24gXSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwgfHxcclxuXHRcdFx0XHRtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwgfHxcclxuXHRcdFx0XHRtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hTdGFuZGFyZE1hdGVyaWFsIHx8XHJcblx0XHRcdFx0bWF0ZXJpYWwubGlnaHRzICkge1xyXG5cclxuXHRcdFx0Ly8gc3RvcmUgdGhlIGxpZ2h0IHNldHVwIGl0IHdhcyBjcmVhdGVkIGZvclxyXG5cclxuXHRcdFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLmxpZ2h0c0hhc2ggPSBfbGlnaHRzLmhhc2g7XHJcblxyXG5cdFx0XHQvLyB3aXJlIHVwIHRoZSBtYXRlcmlhbCB0byB0aGlzIHJlbmRlcmVyJ3MgbGlnaHRpbmcgc3RhdGVcclxuXHJcblx0XHRcdHVuaWZvcm1zLmFtYmllbnRMaWdodENvbG9yLnZhbHVlID0gX2xpZ2h0cy5hbWJpZW50O1xyXG5cdFx0XHR1bmlmb3Jtcy5kaXJlY3Rpb25hbExpZ2h0cy52YWx1ZSA9IF9saWdodHMuZGlyZWN0aW9uYWw7XHJcblx0XHRcdHVuaWZvcm1zLnNwb3RMaWdodHMudmFsdWUgPSBfbGlnaHRzLnNwb3Q7XHJcblx0XHRcdHVuaWZvcm1zLnBvaW50TGlnaHRzLnZhbHVlID0gX2xpZ2h0cy5wb2ludDtcclxuXHRcdFx0dW5pZm9ybXMuaGVtaXNwaGVyZUxpZ2h0cy52YWx1ZSA9IF9saWdodHMuaGVtaTtcclxuXHJcblx0XHRcdHVuaWZvcm1zLmRpcmVjdGlvbmFsU2hhZG93TWFwLnZhbHVlID0gX2xpZ2h0cy5kaXJlY3Rpb25hbFNoYWRvd01hcDtcclxuXHRcdFx0dW5pZm9ybXMuZGlyZWN0aW9uYWxTaGFkb3dNYXRyaXgudmFsdWUgPSBfbGlnaHRzLmRpcmVjdGlvbmFsU2hhZG93TWF0cml4O1xyXG5cdFx0XHR1bmlmb3Jtcy5zcG90U2hhZG93TWFwLnZhbHVlID0gX2xpZ2h0cy5zcG90U2hhZG93TWFwO1xyXG5cdFx0XHR1bmlmb3Jtcy5zcG90U2hhZG93TWF0cml4LnZhbHVlID0gX2xpZ2h0cy5zcG90U2hhZG93TWF0cml4O1xyXG5cdFx0XHR1bmlmb3Jtcy5wb2ludFNoYWRvd01hcC52YWx1ZSA9IF9saWdodHMucG9pbnRTaGFkb3dNYXA7XHJcblx0XHRcdHVuaWZvcm1zLnBvaW50U2hhZG93TWF0cml4LnZhbHVlID0gX2xpZ2h0cy5wb2ludFNoYWRvd01hdHJpeDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gZGV0ZWN0IGR5bmFtaWMgdW5pZm9ybXNcclxuXHJcblx0XHRtYXRlcmlhbFByb3BlcnRpZXMuaGFzRHluYW1pY1VuaWZvcm1zID0gZmFsc2U7XHJcblxyXG5cdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IG1hdGVyaWFsUHJvcGVydGllcy51bmlmb3Jtc0xpc3QubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgdW5pZm9ybSA9IG1hdGVyaWFsUHJvcGVydGllcy51bmlmb3Jtc0xpc3RbIGogXVsgMCBdO1xyXG5cclxuXHRcdFx0aWYgKCB1bmlmb3JtLmR5bmFtaWMgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdG1hdGVyaWFsUHJvcGVydGllcy5oYXNEeW5hbWljVW5pZm9ybXMgPSB0cnVlO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBzZXRNYXRlcmlhbCggbWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0c2V0TWF0ZXJpYWxGYWNlcyggbWF0ZXJpYWwgKTtcclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsLnRyYW5zcGFyZW50ID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0c3RhdGUuc2V0QmxlbmRpbmcoIG1hdGVyaWFsLmJsZW5kaW5nLCBtYXRlcmlhbC5ibGVuZEVxdWF0aW9uLCBtYXRlcmlhbC5ibGVuZFNyYywgbWF0ZXJpYWwuYmxlbmREc3QsIG1hdGVyaWFsLmJsZW5kRXF1YXRpb25BbHBoYSwgbWF0ZXJpYWwuYmxlbmRTcmNBbHBoYSwgbWF0ZXJpYWwuYmxlbmREc3RBbHBoYSApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRzdGF0ZS5zZXRCbGVuZGluZyggVEhSRUUuTm9CbGVuZGluZyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRzdGF0ZS5zZXREZXB0aEZ1bmMoIG1hdGVyaWFsLmRlcHRoRnVuYyApO1xyXG5cdFx0c3RhdGUuc2V0RGVwdGhUZXN0KCBtYXRlcmlhbC5kZXB0aFRlc3QgKTtcclxuXHRcdHN0YXRlLnNldERlcHRoV3JpdGUoIG1hdGVyaWFsLmRlcHRoV3JpdGUgKTtcclxuXHRcdHN0YXRlLnNldENvbG9yV3JpdGUoIG1hdGVyaWFsLmNvbG9yV3JpdGUgKTtcclxuXHRcdHN0YXRlLnNldFBvbHlnb25PZmZzZXQoIG1hdGVyaWFsLnBvbHlnb25PZmZzZXQsIG1hdGVyaWFsLnBvbHlnb25PZmZzZXRGYWN0b3IsIG1hdGVyaWFsLnBvbHlnb25PZmZzZXRVbml0cyApO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHNldE1hdGVyaWFsRmFjZXMoIG1hdGVyaWFsICkge1xyXG5cclxuXHRcdG1hdGVyaWFsLnNpZGUgIT09IFRIUkVFLkRvdWJsZVNpZGUgPyBzdGF0ZS5lbmFibGUoIF9nbC5DVUxMX0ZBQ0UgKSA6IHN0YXRlLmRpc2FibGUoIF9nbC5DVUxMX0ZBQ0UgKTtcclxuXHRcdHN0YXRlLnNldEZsaXBTaWRlZCggbWF0ZXJpYWwuc2lkZSA9PT0gVEhSRUUuQmFja1NpZGUgKTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBzZXRQcm9ncmFtKCBjYW1lcmEsIGZvZywgbWF0ZXJpYWwsIG9iamVjdCApIHtcclxuXHJcblx0XHRfdXNlZFRleHR1cmVVbml0cyA9IDA7XHJcblxyXG5cdFx0dmFyIG1hdGVyaWFsUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCBtYXRlcmlhbCApO1xyXG5cclxuXHRcdGlmICggbWF0ZXJpYWxQcm9wZXJ0aWVzLnByb2dyYW0gPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdG1hdGVyaWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBtYXRlcmlhbFByb3BlcnRpZXMubGlnaHRzSGFzaCAhPT0gdW5kZWZpbmVkICYmXHJcblx0XHRcdG1hdGVyaWFsUHJvcGVydGllcy5saWdodHNIYXNoICE9PSBfbGlnaHRzLmhhc2ggKSB7XHJcblxyXG5cdFx0XHRtYXRlcmlhbC5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggbWF0ZXJpYWwubmVlZHNVcGRhdGUgKSB7XHJcblxyXG5cdFx0XHRpbml0TWF0ZXJpYWwoIG1hdGVyaWFsLCBmb2csIG9iamVjdCApO1xyXG5cdFx0XHRtYXRlcmlhbC5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgcmVmcmVzaFByb2dyYW0gPSBmYWxzZTtcclxuXHRcdHZhciByZWZyZXNoTWF0ZXJpYWwgPSBmYWxzZTtcclxuXHRcdHZhciByZWZyZXNoTGlnaHRzID0gZmFsc2U7XHJcblxyXG5cdFx0dmFyIHByb2dyYW0gPSBtYXRlcmlhbFByb3BlcnRpZXMucHJvZ3JhbSxcclxuXHRcdFx0cF91bmlmb3JtcyA9IHByb2dyYW0uZ2V0VW5pZm9ybXMoKSxcclxuXHRcdFx0bV91bmlmb3JtcyA9IG1hdGVyaWFsUHJvcGVydGllcy5fX3dlYmdsU2hhZGVyLnVuaWZvcm1zO1xyXG5cclxuXHRcdGlmICggcHJvZ3JhbS5pZCAhPT0gX2N1cnJlbnRQcm9ncmFtICkge1xyXG5cclxuXHRcdFx0X2dsLnVzZVByb2dyYW0oIHByb2dyYW0ucHJvZ3JhbSApO1xyXG5cdFx0XHRfY3VycmVudFByb2dyYW0gPSBwcm9ncmFtLmlkO1xyXG5cclxuXHRcdFx0cmVmcmVzaFByb2dyYW0gPSB0cnVlO1xyXG5cdFx0XHRyZWZyZXNoTWF0ZXJpYWwgPSB0cnVlO1xyXG5cdFx0XHRyZWZyZXNoTGlnaHRzID0gdHJ1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBtYXRlcmlhbC5pZCAhPT0gX2N1cnJlbnRNYXRlcmlhbElkICkge1xyXG5cclxuXHRcdFx0X2N1cnJlbnRNYXRlcmlhbElkID0gbWF0ZXJpYWwuaWQ7XHJcblxyXG5cdFx0XHRyZWZyZXNoTWF0ZXJpYWwgPSB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHJlZnJlc2hQcm9ncmFtIHx8IGNhbWVyYSAhPT0gX2N1cnJlbnRDYW1lcmEgKSB7XHJcblxyXG5cdFx0XHRfZ2wudW5pZm9ybU1hdHJpeDRmdiggcF91bmlmb3Jtcy5wcm9qZWN0aW9uTWF0cml4LCBmYWxzZSwgY2FtZXJhLnByb2plY3Rpb25NYXRyaXguZWxlbWVudHMgKTtcclxuXHJcblx0XHRcdGlmICggY2FwYWJpbGl0aWVzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgKSB7XHJcblxyXG5cdFx0XHRcdF9nbC51bmlmb3JtMWYoIHBfdW5pZm9ybXMubG9nRGVwdGhCdWZGQywgMi4wIC8gKCBNYXRoLmxvZyggY2FtZXJhLmZhciArIDEuMCApIC8gTWF0aC5MTjIgKSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHJcblx0XHRcdGlmICggY2FtZXJhICE9PSBfY3VycmVudENhbWVyYSApIHtcclxuXHJcblx0XHRcdFx0X2N1cnJlbnRDYW1lcmEgPSBjYW1lcmE7XHJcblxyXG5cdFx0XHRcdC8vIGxpZ2h0aW5nIHVuaWZvcm1zIGRlcGVuZCBvbiB0aGUgY2FtZXJhIHNvIGVuZm9yY2UgYW4gdXBkYXRlXHJcblx0XHRcdFx0Ly8gbm93LCBpbiBjYXNlIHRoaXMgbWF0ZXJpYWwgc3VwcG9ydHMgbGlnaHRzIC0gb3IgbGF0ZXIsIHdoZW5cclxuXHRcdFx0XHQvLyB0aGUgbmV4dCBtYXRlcmlhbCB0aGF0IGRvZXMgZ2V0cyBhY3RpdmF0ZWQ6XHJcblxyXG5cdFx0XHRcdHJlZnJlc2hNYXRlcmlhbCA9IHRydWU7XHRcdC8vIHNldCB0byB0cnVlIG9uIG1hdGVyaWFsIGNoYW5nZVxyXG5cdFx0XHRcdHJlZnJlc2hMaWdodHMgPSB0cnVlO1x0XHQvLyByZW1haW5zIHNldCB1bnRpbCB1cGRhdGUgZG9uZVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gbG9hZCBtYXRlcmlhbCBzcGVjaWZpYyB1bmlmb3Jtc1xyXG5cdFx0XHQvLyAoc2hhZGVyIG1hdGVyaWFsIGFsc28gZ2V0cyB0aGVtIGZvciB0aGUgc2FrZSBvZiBnZW5lcmljaXR5KVxyXG5cclxuXHRcdFx0aWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLlNoYWRlck1hdGVyaWFsIHx8XHJcblx0XHRcdFx0IG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwgfHxcclxuXHRcdFx0XHQgbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoU3RhbmRhcmRNYXRlcmlhbCB8fFxyXG5cdFx0XHRcdCBtYXRlcmlhbC5lbnZNYXAgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggcF91bmlmb3Jtcy5jYW1lcmFQb3NpdGlvbiAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdF92ZWN0b3IzLnNldEZyb21NYXRyaXhQb3NpdGlvbiggY2FtZXJhLm1hdHJpeFdvcmxkICk7XHJcblx0XHRcdFx0XHRfZ2wudW5pZm9ybTNmKCBwX3VuaWZvcm1zLmNhbWVyYVBvc2l0aW9uLCBfdmVjdG9yMy54LCBfdmVjdG9yMy55LCBfdmVjdG9yMy56ICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbCB8fFxyXG5cdFx0XHRcdCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwgfHxcclxuXHRcdFx0XHQgbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCB8fFxyXG5cdFx0XHRcdCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hTdGFuZGFyZE1hdGVyaWFsIHx8XHJcblx0XHRcdFx0IG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuU2hhZGVyTWF0ZXJpYWwgfHxcclxuXHRcdFx0XHQgbWF0ZXJpYWwuc2tpbm5pbmcgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggcF91bmlmb3Jtcy52aWV3TWF0cml4ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0X2dsLnVuaWZvcm1NYXRyaXg0ZnYoIHBfdW5pZm9ybXMudmlld01hdHJpeCwgZmFsc2UsIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UuZWxlbWVudHMgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBza2lubmluZyB1bmlmb3JtcyBtdXN0IGJlIHNldCBldmVuIGlmIG1hdGVyaWFsIGRpZG4ndCBjaGFuZ2VcclxuXHRcdC8vIGF1dG8tc2V0dGluZyBvZiB0ZXh0dXJlIHVuaXQgZm9yIGJvbmUgdGV4dHVyZSBtdXN0IGdvIGJlZm9yZSBvdGhlciB0ZXh0dXJlc1xyXG5cdFx0Ly8gbm90IHN1cmUgd2h5LCBidXQgb3RoZXJ3aXNlIHdlaXJkIHRoaW5ncyBoYXBwZW5cclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsLnNraW5uaW5nICkge1xyXG5cclxuXHRcdFx0aWYgKCBvYmplY3QuYmluZE1hdHJpeCAmJiBwX3VuaWZvcm1zLmJpbmRNYXRyaXggIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0X2dsLnVuaWZvcm1NYXRyaXg0ZnYoIHBfdW5pZm9ybXMuYmluZE1hdHJpeCwgZmFsc2UsIG9iamVjdC5iaW5kTWF0cml4LmVsZW1lbnRzICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIG9iamVjdC5iaW5kTWF0cml4SW52ZXJzZSAmJiBwX3VuaWZvcm1zLmJpbmRNYXRyaXhJbnZlcnNlICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdF9nbC51bmlmb3JtTWF0cml4NGZ2KCBwX3VuaWZvcm1zLmJpbmRNYXRyaXhJbnZlcnNlLCBmYWxzZSwgb2JqZWN0LmJpbmRNYXRyaXhJbnZlcnNlLmVsZW1lbnRzICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGNhcGFiaWxpdGllcy5mbG9hdFZlcnRleFRleHR1cmVzICYmIG9iamVjdC5za2VsZXRvbiAmJiBvYmplY3Quc2tlbGV0b24udXNlVmVydGV4VGV4dHVyZSApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBwX3VuaWZvcm1zLmJvbmVUZXh0dXJlICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIHRleHR1cmVVbml0ID0gZ2V0VGV4dHVyZVVuaXQoKTtcclxuXHJcblx0XHRcdFx0XHRfZ2wudW5pZm9ybTFpKCBwX3VuaWZvcm1zLmJvbmVUZXh0dXJlLCB0ZXh0dXJlVW5pdCApO1xyXG5cdFx0XHRcdFx0X3RoaXMuc2V0VGV4dHVyZSggb2JqZWN0LnNrZWxldG9uLmJvbmVUZXh0dXJlLCB0ZXh0dXJlVW5pdCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggcF91bmlmb3Jtcy5ib25lVGV4dHVyZVdpZHRoICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0X2dsLnVuaWZvcm0xaSggcF91bmlmb3Jtcy5ib25lVGV4dHVyZVdpZHRoLCBvYmplY3Quc2tlbGV0b24uYm9uZVRleHR1cmVXaWR0aCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggcF91bmlmb3Jtcy5ib25lVGV4dHVyZUhlaWdodCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdF9nbC51bmlmb3JtMWkoIHBfdW5pZm9ybXMuYm9uZVRleHR1cmVIZWlnaHQsIG9iamVjdC5za2VsZXRvbi5ib25lVGV4dHVyZUhlaWdodCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBvYmplY3Quc2tlbGV0b24gJiYgb2JqZWN0LnNrZWxldG9uLmJvbmVNYXRyaWNlcyApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBwX3VuaWZvcm1zLmJvbmVHbG9iYWxNYXRyaWNlcyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdF9nbC51bmlmb3JtTWF0cml4NGZ2KCBwX3VuaWZvcm1zLmJvbmVHbG9iYWxNYXRyaWNlcywgZmFsc2UsIG9iamVjdC5za2VsZXRvbi5ib25lTWF0cmljZXMgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHJlZnJlc2hNYXRlcmlhbCApIHtcclxuXHJcblx0XHRcdGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbCB8fFxyXG5cdFx0XHRcdCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwgfHxcclxuXHRcdFx0XHQgbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoU3RhbmRhcmRNYXRlcmlhbCB8fFxyXG5cdFx0XHRcdCBtYXRlcmlhbC5saWdodHMgKSB7XHJcblxyXG5cdFx0XHRcdC8vIHRoZSBjdXJyZW50IG1hdGVyaWFsIHJlcXVpcmVzIGxpZ2h0aW5nIGluZm9cclxuXHJcblx0XHRcdFx0Ly8gbm90ZTogYWxsIGxpZ2h0aW5nIHVuaWZvcm1zIGFyZSBhbHdheXMgc2V0IGNvcnJlY3RseVxyXG5cdFx0XHRcdC8vIHRoZXkgc2ltcGx5IHJlZmVyZW5jZSB0aGUgcmVuZGVyZXIncyBzdGF0ZSBmb3IgdGhlaXJcclxuXHRcdFx0XHQvLyB2YWx1ZXNcclxuXHRcdFx0XHQvL1xyXG5cdFx0XHRcdC8vIHVzZSB0aGUgY3VycmVudCBtYXRlcmlhbCdzIC5uZWVkc1VwZGF0ZSBmbGFncyB0byBzZXRcclxuXHRcdFx0XHQvLyB0aGUgR0wgc3RhdGUgd2hlbiByZXF1aXJlZFxyXG5cclxuXHRcdFx0XHRtYXJrVW5pZm9ybXNMaWdodHNOZWVkc1VwZGF0ZSggbV91bmlmb3JtcywgcmVmcmVzaExpZ2h0cyApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gcmVmcmVzaCB1bmlmb3JtcyBjb21tb24gdG8gc2V2ZXJhbCBtYXRlcmlhbHNcclxuXHJcblx0XHRcdGlmICggZm9nICYmIG1hdGVyaWFsLmZvZyApIHtcclxuXHJcblx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zRm9nKCBtX3VuaWZvcm1zLCBmb2cgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCB8fFxyXG5cdFx0XHRcdCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwgfHxcclxuXHRcdFx0XHQgbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbCB8fFxyXG5cdFx0XHRcdCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hTdGFuZGFyZE1hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNDb21tb24oIG1fdW5pZm9ybXMsIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyByZWZyZXNoIHNpbmdsZSBtYXRlcmlhbCBzcGVjaWZpYyB1bmlmb3Jtc1xyXG5cclxuXHRcdFx0aWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNMaW5lKCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5MaW5lRGFzaGVkTWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHRcdHJlZnJlc2hVbmlmb3Jtc0xpbmUoIG1fdW5pZm9ybXMsIG1hdGVyaWFsICk7XHJcblx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zRGFzaCggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuUG9pbnRzTWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHRcdHJlZnJlc2hVbmlmb3Jtc1BvaW50cyggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbCApIHtcclxuXHJcblx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zTGFtYmVydCggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHRcdHJlZnJlc2hVbmlmb3Jtc1Bob25nKCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoU3RhbmRhcmRNYXRlcmlhbCApIHtcclxuXHJcblx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zU3RhbmRhcmQoIG1fdW5pZm9ybXMsIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hEZXB0aE1hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0XHRtX3VuaWZvcm1zLm1OZWFyLnZhbHVlID0gY2FtZXJhLm5lYXI7XHJcblx0XHRcdFx0bV91bmlmb3Jtcy5tRmFyLnZhbHVlID0gY2FtZXJhLmZhcjtcclxuXHRcdFx0XHRtX3VuaWZvcm1zLm9wYWNpdHkudmFsdWUgPSBtYXRlcmlhbC5vcGFjaXR5O1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoTm9ybWFsTWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHRcdG1fdW5pZm9ybXMub3BhY2l0eS52YWx1ZSA9IG1hdGVyaWFsLm9wYWNpdHk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBsb2FkIGNvbW1vbiB1bmlmb3Jtc1xyXG5cclxuXHRcdFx0bG9hZFVuaWZvcm1zR2VuZXJpYyggbWF0ZXJpYWxQcm9wZXJ0aWVzLnVuaWZvcm1zTGlzdCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRsb2FkVW5pZm9ybXNNYXRyaWNlcyggcF91bmlmb3Jtcywgb2JqZWN0ICk7XHJcblxyXG5cdFx0aWYgKCBwX3VuaWZvcm1zLm1vZGVsTWF0cml4ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRfZ2wudW5pZm9ybU1hdHJpeDRmdiggcF91bmlmb3Jtcy5tb2RlbE1hdHJpeCwgZmFsc2UsIG9iamVjdC5tYXRyaXhXb3JsZC5lbGVtZW50cyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsUHJvcGVydGllcy5oYXNEeW5hbWljVW5pZm9ybXMgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHR1cGRhdGVEeW5hbWljVW5pZm9ybXMoIG1hdGVyaWFsUHJvcGVydGllcy51bmlmb3Jtc0xpc3QsIG9iamVjdCwgY2FtZXJhICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBwcm9ncmFtO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHVwZGF0ZUR5bmFtaWNVbmlmb3JtcyAoIHVuaWZvcm1zLCBvYmplY3QsIGNhbWVyYSApIHtcclxuXHJcblx0XHR2YXIgZHluYW1pY1VuaWZvcm1zID0gW107XHJcblxyXG5cdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IHVuaWZvcm1zLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xyXG5cclxuXHRcdFx0dmFyIHVuaWZvcm0gPSB1bmlmb3Jtc1sgaiBdWyAwIF07XHJcblx0XHRcdHZhciBvblVwZGF0ZUNhbGxiYWNrID0gdW5pZm9ybS5vblVwZGF0ZUNhbGxiYWNrO1xyXG5cclxuXHRcdFx0aWYgKCBvblVwZGF0ZUNhbGxiYWNrICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdG9uVXBkYXRlQ2FsbGJhY2suYmluZCggdW5pZm9ybSApKCBvYmplY3QsIGNhbWVyYSApO1xyXG5cdFx0XHRcdGR5bmFtaWNVbmlmb3Jtcy5wdXNoKCB1bmlmb3Jtc1sgaiBdICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGxvYWRVbmlmb3Jtc0dlbmVyaWMoIGR5bmFtaWNVbmlmb3JtcyApO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIFVuaWZvcm1zIChyZWZyZXNoIHVuaWZvcm1zIG9iamVjdHMpXHJcblxyXG5cdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc0NvbW1vbiAoIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcclxuXHJcblx0XHR1bmlmb3Jtcy5vcGFjaXR5LnZhbHVlID0gbWF0ZXJpYWwub3BhY2l0eTtcclxuXHJcblx0XHR1bmlmb3Jtcy5kaWZmdXNlLnZhbHVlID0gbWF0ZXJpYWwuY29sb3I7XHJcblxyXG5cdFx0aWYgKCBtYXRlcmlhbC5lbWlzc2l2ZSApIHtcclxuXHJcblx0XHRcdHVuaWZvcm1zLmVtaXNzaXZlLnZhbHVlLmNvcHkoIG1hdGVyaWFsLmVtaXNzaXZlICkubXVsdGlwbHlTY2FsYXIoIG1hdGVyaWFsLmVtaXNzaXZlSW50ZW5zaXR5ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHVuaWZvcm1zLm1hcC52YWx1ZSA9IG1hdGVyaWFsLm1hcDtcclxuXHRcdHVuaWZvcm1zLnNwZWN1bGFyTWFwLnZhbHVlID0gbWF0ZXJpYWwuc3BlY3VsYXJNYXA7XHJcblx0XHR1bmlmb3Jtcy5hbHBoYU1hcC52YWx1ZSA9IG1hdGVyaWFsLmFscGhhTWFwO1xyXG5cclxuXHRcdGlmICggbWF0ZXJpYWwuYW9NYXAgKSB7XHJcblxyXG5cdFx0XHR1bmlmb3Jtcy5hb01hcC52YWx1ZSA9IG1hdGVyaWFsLmFvTWFwO1xyXG5cdFx0XHR1bmlmb3Jtcy5hb01hcEludGVuc2l0eS52YWx1ZSA9IG1hdGVyaWFsLmFvTWFwSW50ZW5zaXR5O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyB1diByZXBlYXQgYW5kIG9mZnNldCBzZXR0aW5nIHByaW9yaXRpZXNcclxuXHRcdC8vIDEuIGNvbG9yIG1hcFxyXG5cdFx0Ly8gMi4gc3BlY3VsYXIgbWFwXHJcblx0XHQvLyAzLiBub3JtYWwgbWFwXHJcblx0XHQvLyA0LiBidW1wIG1hcFxyXG5cdFx0Ly8gNS4gYWxwaGEgbWFwXHJcblx0XHQvLyA2LiBlbWlzc2l2ZSBtYXBcclxuXHJcblx0XHR2YXIgdXZTY2FsZU1hcDtcclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsLm1hcCApIHtcclxuXHJcblx0XHRcdHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5tYXA7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuc3BlY3VsYXJNYXAgKSB7XHJcblxyXG5cdFx0XHR1dlNjYWxlTWFwID0gbWF0ZXJpYWwuc3BlY3VsYXJNYXA7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwICkge1xyXG5cclxuXHRcdFx0dXZTY2FsZU1hcCA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcDtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5ub3JtYWxNYXAgKSB7XHJcblxyXG5cdFx0XHR1dlNjYWxlTWFwID0gbWF0ZXJpYWwubm9ybWFsTWFwO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLmJ1bXBNYXAgKSB7XHJcblxyXG5cdFx0XHR1dlNjYWxlTWFwID0gbWF0ZXJpYWwuYnVtcE1hcDtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5yb3VnaG5lc3NNYXAgKSB7XHJcblxyXG5cdFx0XHR1dlNjYWxlTWFwID0gbWF0ZXJpYWwucm91Z2huZXNzTWFwO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLm1ldGFsbmVzc01hcCApIHtcclxuXHJcblx0XHRcdHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5tZXRhbG5lc3NNYXA7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuYWxwaGFNYXAgKSB7XHJcblxyXG5cdFx0XHR1dlNjYWxlTWFwID0gbWF0ZXJpYWwuYWxwaGFNYXA7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuZW1pc3NpdmVNYXAgKSB7XHJcblxyXG5cdFx0XHR1dlNjYWxlTWFwID0gbWF0ZXJpYWwuZW1pc3NpdmVNYXA7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdXZTY2FsZU1hcCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0aWYgKCB1dlNjYWxlTWFwIGluc3RhbmNlb2YgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQgKSB7XHJcblxyXG5cdFx0XHRcdHV2U2NhbGVNYXAgPSB1dlNjYWxlTWFwLnRleHR1cmU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgb2Zmc2V0ID0gdXZTY2FsZU1hcC5vZmZzZXQ7XHJcblx0XHRcdHZhciByZXBlYXQgPSB1dlNjYWxlTWFwLnJlcGVhdDtcclxuXHJcblx0XHRcdHVuaWZvcm1zLm9mZnNldFJlcGVhdC52YWx1ZS5zZXQoIG9mZnNldC54LCBvZmZzZXQueSwgcmVwZWF0LngsIHJlcGVhdC55ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHVuaWZvcm1zLmVudk1hcC52YWx1ZSA9IG1hdGVyaWFsLmVudk1hcDtcclxuXHRcdHVuaWZvcm1zLmZsaXBFbnZNYXAudmFsdWUgPSAoIG1hdGVyaWFsLmVudk1hcCBpbnN0YW5jZW9mIFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZSApID8gMSA6IC0gMTtcclxuXHJcblx0XHR1bmlmb3Jtcy5yZWZsZWN0aXZpdHkudmFsdWUgPSBtYXRlcmlhbC5yZWZsZWN0aXZpdHk7XHJcblx0XHR1bmlmb3Jtcy5yZWZyYWN0aW9uUmF0aW8udmFsdWUgPSBtYXRlcmlhbC5yZWZyYWN0aW9uUmF0aW87XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zTGluZSAoIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcclxuXHJcblx0XHR1bmlmb3Jtcy5kaWZmdXNlLnZhbHVlID0gbWF0ZXJpYWwuY29sb3I7XHJcblx0XHR1bmlmb3Jtcy5vcGFjaXR5LnZhbHVlID0gbWF0ZXJpYWwub3BhY2l0eTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNEYXNoICggdW5pZm9ybXMsIG1hdGVyaWFsICkge1xyXG5cclxuXHRcdHVuaWZvcm1zLmRhc2hTaXplLnZhbHVlID0gbWF0ZXJpYWwuZGFzaFNpemU7XHJcblx0XHR1bmlmb3Jtcy50b3RhbFNpemUudmFsdWUgPSBtYXRlcmlhbC5kYXNoU2l6ZSArIG1hdGVyaWFsLmdhcFNpemU7XHJcblx0XHR1bmlmb3Jtcy5zY2FsZS52YWx1ZSA9IG1hdGVyaWFsLnNjYWxlO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc1BvaW50cyAoIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcclxuXHJcblx0XHR1bmlmb3Jtcy5kaWZmdXNlLnZhbHVlID0gbWF0ZXJpYWwuY29sb3I7XHJcblx0XHR1bmlmb3Jtcy5vcGFjaXR5LnZhbHVlID0gbWF0ZXJpYWwub3BhY2l0eTtcclxuXHRcdHVuaWZvcm1zLnNpemUudmFsdWUgPSBtYXRlcmlhbC5zaXplICogX3BpeGVsUmF0aW87XHJcblx0XHR1bmlmb3Jtcy5zY2FsZS52YWx1ZSA9IF9jYW52YXMuY2xpZW50SGVpZ2h0IC8gMi4wOyAvLyBUT0RPOiBDYWNoZSB0aGlzLlxyXG5cclxuXHRcdHVuaWZvcm1zLm1hcC52YWx1ZSA9IG1hdGVyaWFsLm1hcDtcclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsLm1hcCAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdHZhciBvZmZzZXQgPSBtYXRlcmlhbC5tYXAub2Zmc2V0O1xyXG5cdFx0XHR2YXIgcmVwZWF0ID0gbWF0ZXJpYWwubWFwLnJlcGVhdDtcclxuXHJcblx0XHRcdHVuaWZvcm1zLm9mZnNldFJlcGVhdC52YWx1ZS5zZXQoIG9mZnNldC54LCBvZmZzZXQueSwgcmVwZWF0LngsIHJlcGVhdC55ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc0ZvZyAoIHVuaWZvcm1zLCBmb2cgKSB7XHJcblxyXG5cdFx0dW5pZm9ybXMuZm9nQ29sb3IudmFsdWUgPSBmb2cuY29sb3I7XHJcblxyXG5cdFx0aWYgKCBmb2cgaW5zdGFuY2VvZiBUSFJFRS5Gb2cgKSB7XHJcblxyXG5cdFx0XHR1bmlmb3Jtcy5mb2dOZWFyLnZhbHVlID0gZm9nLm5lYXI7XHJcblx0XHRcdHVuaWZvcm1zLmZvZ0Zhci52YWx1ZSA9IGZvZy5mYXI7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggZm9nIGluc3RhbmNlb2YgVEhSRUUuRm9nRXhwMiApIHtcclxuXHJcblx0XHRcdHVuaWZvcm1zLmZvZ0RlbnNpdHkudmFsdWUgPSBmb2cuZGVuc2l0eTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zTGFtYmVydCAoIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsLmxpZ2h0TWFwICkge1xyXG5cclxuXHRcdFx0dW5pZm9ybXMubGlnaHRNYXAudmFsdWUgPSBtYXRlcmlhbC5saWdodE1hcDtcclxuXHRcdFx0dW5pZm9ybXMubGlnaHRNYXBJbnRlbnNpdHkudmFsdWUgPSBtYXRlcmlhbC5saWdodE1hcEludGVuc2l0eTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBtYXRlcmlhbC5lbWlzc2l2ZU1hcCApIHtcclxuXHJcblx0XHRcdHVuaWZvcm1zLmVtaXNzaXZlTWFwLnZhbHVlID0gbWF0ZXJpYWwuZW1pc3NpdmVNYXA7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc1Bob25nICggdW5pZm9ybXMsIG1hdGVyaWFsICkge1xyXG5cclxuXHRcdHVuaWZvcm1zLnNwZWN1bGFyLnZhbHVlID0gbWF0ZXJpYWwuc3BlY3VsYXI7XHJcblx0XHR1bmlmb3Jtcy5zaGluaW5lc3MudmFsdWUgPSBNYXRoLm1heCggbWF0ZXJpYWwuc2hpbmluZXNzLCAxZS00ICk7IC8vIHRvIHByZXZlbnQgcG93KCAwLjAsIDAuMCApXHJcblxyXG5cdFx0aWYgKCBtYXRlcmlhbC5saWdodE1hcCApIHtcclxuXHJcblx0XHRcdHVuaWZvcm1zLmxpZ2h0TWFwLnZhbHVlID0gbWF0ZXJpYWwubGlnaHRNYXA7XHJcblx0XHRcdHVuaWZvcm1zLmxpZ2h0TWFwSW50ZW5zaXR5LnZhbHVlID0gbWF0ZXJpYWwubGlnaHRNYXBJbnRlbnNpdHk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggbWF0ZXJpYWwuZW1pc3NpdmVNYXAgKSB7XHJcblxyXG5cdFx0XHR1bmlmb3Jtcy5lbWlzc2l2ZU1hcC52YWx1ZSA9IG1hdGVyaWFsLmVtaXNzaXZlTWFwO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsLmJ1bXBNYXAgKSB7XHJcblxyXG5cdFx0XHR1bmlmb3Jtcy5idW1wTWFwLnZhbHVlID0gbWF0ZXJpYWwuYnVtcE1hcDtcclxuXHRcdFx0dW5pZm9ybXMuYnVtcFNjYWxlLnZhbHVlID0gbWF0ZXJpYWwuYnVtcFNjYWxlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsLm5vcm1hbE1hcCApIHtcclxuXHJcblx0XHRcdHVuaWZvcm1zLm5vcm1hbE1hcC52YWx1ZSA9IG1hdGVyaWFsLm5vcm1hbE1hcDtcclxuXHRcdFx0dW5pZm9ybXMubm9ybWFsU2NhbGUudmFsdWUuY29weSggbWF0ZXJpYWwubm9ybWFsU2NhbGUgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXAgKSB7XHJcblxyXG5cdFx0XHR1bmlmb3Jtcy5kaXNwbGFjZW1lbnRNYXAudmFsdWUgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXA7XHJcblx0XHRcdHVuaWZvcm1zLmRpc3BsYWNlbWVudFNjYWxlLnZhbHVlID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50U2NhbGU7XHJcblx0XHRcdHVuaWZvcm1zLmRpc3BsYWNlbWVudEJpYXMudmFsdWUgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRCaWFzO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNTdGFuZGFyZCAoIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcclxuXHJcblx0XHR1bmlmb3Jtcy5yb3VnaG5lc3MudmFsdWUgPSBtYXRlcmlhbC5yb3VnaG5lc3M7XHJcblx0XHR1bmlmb3Jtcy5tZXRhbG5lc3MudmFsdWUgPSBtYXRlcmlhbC5tZXRhbG5lc3M7XHJcblxyXG5cdFx0aWYgKCBtYXRlcmlhbC5yb3VnaG5lc3NNYXAgKSB7XHJcblxyXG5cdFx0XHR1bmlmb3Jtcy5yb3VnaG5lc3NNYXAudmFsdWUgPSBtYXRlcmlhbC5yb3VnaG5lc3NNYXA7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggbWF0ZXJpYWwubWV0YWxuZXNzTWFwICkge1xyXG5cclxuXHRcdFx0dW5pZm9ybXMubWV0YWxuZXNzTWFwLnZhbHVlID0gbWF0ZXJpYWwubWV0YWxuZXNzTWFwO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsLmxpZ2h0TWFwICkge1xyXG5cclxuXHRcdFx0dW5pZm9ybXMubGlnaHRNYXAudmFsdWUgPSBtYXRlcmlhbC5saWdodE1hcDtcclxuXHRcdFx0dW5pZm9ybXMubGlnaHRNYXBJbnRlbnNpdHkudmFsdWUgPSBtYXRlcmlhbC5saWdodE1hcEludGVuc2l0eTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBtYXRlcmlhbC5lbWlzc2l2ZU1hcCApIHtcclxuXHJcblx0XHRcdHVuaWZvcm1zLmVtaXNzaXZlTWFwLnZhbHVlID0gbWF0ZXJpYWwuZW1pc3NpdmVNYXA7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggbWF0ZXJpYWwuYnVtcE1hcCApIHtcclxuXHJcblx0XHRcdHVuaWZvcm1zLmJ1bXBNYXAudmFsdWUgPSBtYXRlcmlhbC5idW1wTWFwO1xyXG5cdFx0XHR1bmlmb3Jtcy5idW1wU2NhbGUudmFsdWUgPSBtYXRlcmlhbC5idW1wU2NhbGU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggbWF0ZXJpYWwubm9ybWFsTWFwICkge1xyXG5cclxuXHRcdFx0dW5pZm9ybXMubm9ybWFsTWFwLnZhbHVlID0gbWF0ZXJpYWwubm9ybWFsTWFwO1xyXG5cdFx0XHR1bmlmb3Jtcy5ub3JtYWxTY2FsZS52YWx1ZS5jb3B5KCBtYXRlcmlhbC5ub3JtYWxTY2FsZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcCApIHtcclxuXHJcblx0XHRcdHVuaWZvcm1zLmRpc3BsYWNlbWVudE1hcC52YWx1ZSA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcDtcclxuXHRcdFx0dW5pZm9ybXMuZGlzcGxhY2VtZW50U2NhbGUudmFsdWUgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRTY2FsZTtcclxuXHRcdFx0dW5pZm9ybXMuZGlzcGxhY2VtZW50Qmlhcy52YWx1ZSA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudEJpYXM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggbWF0ZXJpYWwuZW52TWFwICkge1xyXG5cclxuXHRcdFx0Ly91bmlmb3Jtcy5lbnZNYXAudmFsdWUgPSBtYXRlcmlhbC5lbnZNYXA7IC8vIHBhcnQgb2YgdW5pZm9ybXMgY29tbW9uXHJcblx0XHRcdHVuaWZvcm1zLmVudk1hcEludGVuc2l0eS52YWx1ZSA9IG1hdGVyaWFsLmVudk1hcEludGVuc2l0eTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gSWYgdW5pZm9ybXMgYXJlIG1hcmtlZCBhcyBjbGVhbiwgdGhleSBkb24ndCBuZWVkIHRvIGJlIGxvYWRlZCB0byB0aGUgR1BVLlxyXG5cclxuXHRmdW5jdGlvbiBtYXJrVW5pZm9ybXNMaWdodHNOZWVkc1VwZGF0ZSAoIHVuaWZvcm1zLCB2YWx1ZSApIHtcclxuXHJcblx0XHR1bmlmb3Jtcy5hbWJpZW50TGlnaHRDb2xvci5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xyXG5cclxuXHRcdHVuaWZvcm1zLmRpcmVjdGlvbmFsTGlnaHRzLm5lZWRzVXBkYXRlID0gdmFsdWU7XHJcblx0XHR1bmlmb3Jtcy5wb2ludExpZ2h0cy5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xyXG5cdFx0dW5pZm9ybXMuc3BvdExpZ2h0cy5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xyXG5cdFx0dW5pZm9ybXMuaGVtaXNwaGVyZUxpZ2h0cy5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIFVuaWZvcm1zIChsb2FkIHRvIEdQVSlcclxuXHJcblx0ZnVuY3Rpb24gbG9hZFVuaWZvcm1zTWF0cmljZXMgKCB1bmlmb3Jtcywgb2JqZWN0ICkge1xyXG5cclxuXHRcdF9nbC51bmlmb3JtTWF0cml4NGZ2KCB1bmlmb3Jtcy5tb2RlbFZpZXdNYXRyaXgsIGZhbHNlLCBvYmplY3QubW9kZWxWaWV3TWF0cml4LmVsZW1lbnRzICk7XHJcblxyXG5cdFx0aWYgKCB1bmlmb3Jtcy5ub3JtYWxNYXRyaXggKSB7XHJcblxyXG5cdFx0XHRfZ2wudW5pZm9ybU1hdHJpeDNmdiggdW5pZm9ybXMubm9ybWFsTWF0cml4LCBmYWxzZSwgb2JqZWN0Lm5vcm1hbE1hdHJpeC5lbGVtZW50cyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBnZXRUZXh0dXJlVW5pdCgpIHtcclxuXHJcblx0XHR2YXIgdGV4dHVyZVVuaXQgPSBfdXNlZFRleHR1cmVVbml0cztcclxuXHJcblx0XHRpZiAoIHRleHR1cmVVbml0ID49IGNhcGFiaWxpdGllcy5tYXhUZXh0dXJlcyApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1dlYkdMUmVuZGVyZXI6IHRyeWluZyB0byB1c2UgJyArIHRleHR1cmVVbml0ICsgJyB0ZXh0dXJlIHVuaXRzIHdoaWxlIHRoaXMgR1BVIHN1cHBvcnRzIG9ubHkgJyArIGNhcGFiaWxpdGllcy5tYXhUZXh0dXJlcyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRfdXNlZFRleHR1cmVVbml0cyArPSAxO1xyXG5cclxuXHRcdHJldHVybiB0ZXh0dXJlVW5pdDtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBsb2FkVW5pZm9ybXNHZW5lcmljICggdW5pZm9ybXMgKSB7XHJcblxyXG5cdFx0dmFyIHRleHR1cmUsIHRleHR1cmVVbml0O1xyXG5cclxuXHRcdGZvciAoIHZhciBqID0gMCwgamwgPSB1bmlmb3Jtcy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcclxuXHJcblx0XHRcdHZhciB1bmlmb3JtID0gdW5pZm9ybXNbIGogXVsgMCBdO1xyXG5cclxuXHRcdFx0Ly8gbmVlZHNVcGRhdGUgcHJvcGVydHkgaXMgbm90IGFkZGVkIHRvIGFsbCB1bmlmb3Jtcy5cclxuXHRcdFx0aWYgKCB1bmlmb3JtLm5lZWRzVXBkYXRlID09PSBmYWxzZSApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0dmFyIHR5cGUgPSB1bmlmb3JtLnR5cGU7XHJcblx0XHRcdHZhciB2YWx1ZSA9IHVuaWZvcm0udmFsdWU7XHJcblx0XHRcdHZhciBsb2NhdGlvbiA9IHVuaWZvcm1zWyBqIF1bIDEgXTtcclxuXHJcblx0XHRcdHN3aXRjaCAoIHR5cGUgKSB7XHJcblxyXG5cdFx0XHRcdGNhc2UgJzFpJzpcclxuXHRcdFx0XHRcdF9nbC51bmlmb3JtMWkoIGxvY2F0aW9uLCB2YWx1ZSApO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgJzFmJzpcclxuXHRcdFx0XHRcdF9nbC51bmlmb3JtMWYoIGxvY2F0aW9uLCB2YWx1ZSApO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgJzJmJzpcclxuXHRcdFx0XHRcdF9nbC51bmlmb3JtMmYoIGxvY2F0aW9uLCB2YWx1ZVsgMCBdLCB2YWx1ZVsgMSBdICk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnM2YnOlxyXG5cdFx0XHRcdFx0X2dsLnVuaWZvcm0zZiggbG9jYXRpb24sIHZhbHVlWyAwIF0sIHZhbHVlWyAxIF0sIHZhbHVlWyAyIF0gKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICc0Zic6XHJcblx0XHRcdFx0XHRfZ2wudW5pZm9ybTRmKCBsb2NhdGlvbiwgdmFsdWVbIDAgXSwgdmFsdWVbIDEgXSwgdmFsdWVbIDIgXSwgdmFsdWVbIDMgXSApO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgJzFpdic6XHJcblx0XHRcdFx0XHRfZ2wudW5pZm9ybTFpdiggbG9jYXRpb24sIHZhbHVlICk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnM2l2JzpcclxuXHRcdFx0XHRcdF9nbC51bmlmb3JtM2l2KCBsb2NhdGlvbiwgdmFsdWUgKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICcxZnYnOlxyXG5cdFx0XHRcdFx0X2dsLnVuaWZvcm0xZnYoIGxvY2F0aW9uLCB2YWx1ZSApO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgJzJmdic6XHJcblx0XHRcdFx0XHRfZ2wudW5pZm9ybTJmdiggbG9jYXRpb24sIHZhbHVlICk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnM2Z2JzpcclxuXHRcdFx0XHRcdF9nbC51bmlmb3JtM2Z2KCBsb2NhdGlvbiwgdmFsdWUgKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICc0ZnYnOlxyXG5cdFx0XHRcdFx0X2dsLnVuaWZvcm00ZnYoIGxvY2F0aW9uLCB2YWx1ZSApO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ01hdHJpeDJmdic6XHJcblx0XHRcdFx0XHRfZ2wudW5pZm9ybU1hdHJpeDJmdiggbG9jYXRpb24sIGZhbHNlLCB2YWx1ZSApO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ01hdHJpeDNmdic6XHJcblx0XHRcdFx0XHRfZ2wudW5pZm9ybU1hdHJpeDNmdiggbG9jYXRpb24sIGZhbHNlLCB2YWx1ZSApO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ01hdHJpeDRmdic6XHJcblx0XHRcdFx0XHRfZ2wudW5pZm9ybU1hdHJpeDRmdiggbG9jYXRpb24sIGZhbHNlLCB2YWx1ZSApO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdC8vXHJcblxyXG5cdFx0XHRcdGNhc2UgJ2knOlxyXG5cclxuXHRcdFx0XHRcdC8vIHNpbmdsZSBpbnRlZ2VyXHJcblx0XHRcdFx0XHRfZ2wudW5pZm9ybTFpKCBsb2NhdGlvbiwgdmFsdWUgKTtcclxuXHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnZic6XHJcblxyXG5cdFx0XHRcdFx0Ly8gc2luZ2xlIGZsb2F0XHJcblx0XHRcdFx0XHRfZ2wudW5pZm9ybTFmKCBsb2NhdGlvbiwgdmFsdWUgKTtcclxuXHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAndjInOlxyXG5cclxuXHRcdFx0XHRcdC8vIHNpbmdsZSBUSFJFRS5WZWN0b3IyXHJcblx0XHRcdFx0XHRfZ2wudW5pZm9ybTJmKCBsb2NhdGlvbiwgdmFsdWUueCwgdmFsdWUueSApO1xyXG5cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICd2Myc6XHJcblxyXG5cdFx0XHRcdFx0Ly8gc2luZ2xlIFRIUkVFLlZlY3RvcjNcclxuXHRcdFx0XHRcdF9nbC51bmlmb3JtM2YoIGxvY2F0aW9uLCB2YWx1ZS54LCB2YWx1ZS55LCB2YWx1ZS56ICk7XHJcblxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ3Y0JzpcclxuXHJcblx0XHRcdFx0XHQvLyBzaW5nbGUgVEhSRUUuVmVjdG9yNFxyXG5cdFx0XHRcdFx0X2dsLnVuaWZvcm00ZiggbG9jYXRpb24sIHZhbHVlLngsIHZhbHVlLnksIHZhbHVlLnosIHZhbHVlLncgKTtcclxuXHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnYyc6XHJcblxyXG5cdFx0XHRcdFx0Ly8gc2luZ2xlIFRIUkVFLkNvbG9yXHJcblx0XHRcdFx0XHRfZ2wudW5pZm9ybTNmKCBsb2NhdGlvbiwgdmFsdWUuciwgdmFsdWUuZywgdmFsdWUuYiApO1xyXG5cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHQvKlxyXG5cdFx0XHRcdGNhc2UgJ3MnOlxyXG5cclxuXHRcdFx0XHRcdC8vIFRPRE86IE9wdGltaXplIHRoaXMuXHJcblx0XHRcdFx0XHRmb3IoIHZhciBwcm9wZXJ0eU5hbWUgaW4gdW5pZm9ybS5wcm9wZXJ0aWVzICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dmFyIHByb3BlcnR5ID0gdW5pZm9ybS5wcm9wZXJ0aWVzWyBwcm9wZXJ0eU5hbWUgXTtcclxuXHRcdFx0XHRcdFx0dmFyIGxvY2F0aW9uUHJvcGVydHkgPSAgbG9jYXRpb25bIHByb3BlcnR5TmFtZSBdO1xyXG5cdFx0XHRcdFx0XHR2YXIgdmFsdWVQcm9wZXJ0eSA9IHZhbHVlWyBwcm9wZXJ0eU5hbWUgXTtcclxuXHJcblx0XHRcdFx0XHRcdHN3aXRjaCggcHJvcGVydHkudHlwZSApIHtcclxuXHRcdFx0XHRcdFx0XHRjYXNlICdpJzpcclxuXHRcdFx0XHRcdFx0XHRcdF9nbC51bmlmb3JtMWkoIGxvY2F0aW9uUHJvcGVydHksIHZhbHVlUHJvcGVydHkgKTtcclxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRcdGNhc2UgJ2YnOlxyXG5cdFx0XHRcdFx0XHRcdFx0X2dsLnVuaWZvcm0xZiggbG9jYXRpb25Qcm9wZXJ0eSwgdmFsdWVQcm9wZXJ0eSApO1xyXG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdFx0Y2FzZSAndjInOlxyXG5cdFx0XHRcdFx0XHRcdFx0X2dsLnVuaWZvcm0yZiggbG9jYXRpb25Qcm9wZXJ0eSwgdmFsdWVQcm9wZXJ0eS54LCB2YWx1ZVByb3BlcnR5LnkgKTtcclxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRcdGNhc2UgJ3YzJzpcclxuXHRcdFx0XHRcdFx0XHRcdF9nbC51bmlmb3JtM2YoIGxvY2F0aW9uUHJvcGVydHksIHZhbHVlUHJvcGVydHkueCwgdmFsdWVQcm9wZXJ0eS55LCB2YWx1ZVByb3BlcnR5LnogKTtcclxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRcdGNhc2UgJ3Y0JzpcclxuXHRcdFx0XHRcdFx0XHRcdF9nbC51bmlmb3JtNGYoIGxvY2F0aW9uUHJvcGVydHksIHZhbHVlUHJvcGVydHkueCwgdmFsdWVQcm9wZXJ0eS55LCB2YWx1ZVByb3BlcnR5LnosIHZhbHVlUHJvcGVydHkudyApO1xyXG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdFx0Y2FzZSAnYyc6XHJcblx0XHRcdFx0XHRcdFx0XHRfZ2wudW5pZm9ybTNmKCBsb2NhdGlvblByb3BlcnR5LCB2YWx1ZVByb3BlcnR5LnIsIHZhbHVlUHJvcGVydHkuZywgdmFsdWVQcm9wZXJ0eS5iICk7XHJcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0fTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0Ki9cclxuXHJcblx0XHRcdFx0Y2FzZSAnc2EnOlxyXG5cclxuXHRcdFx0XHRcdC8vIFRPRE86IE9wdGltaXplIHRoaXMuXHJcblx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgcHJvcGVydHlOYW1lIGluIHVuaWZvcm0ucHJvcGVydGllcyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0dmFyIHByb3BlcnR5ID0gdW5pZm9ybS5wcm9wZXJ0aWVzWyBwcm9wZXJ0eU5hbWUgXTtcclxuXHRcdFx0XHRcdFx0XHR2YXIgbG9jYXRpb25Qcm9wZXJ0eSA9ICBsb2NhdGlvblsgaSBdWyBwcm9wZXJ0eU5hbWUgXTtcclxuXHRcdFx0XHRcdFx0XHR2YXIgdmFsdWVQcm9wZXJ0eSA9IHZhbHVlWyBpIF1bIHByb3BlcnR5TmFtZSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRzd2l0Y2ggKCBwcm9wZXJ0eS50eXBlICkge1xyXG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSAnaSc6XHJcblx0XHRcdFx0XHRcdFx0XHRcdF9nbC51bmlmb3JtMWkoIGxvY2F0aW9uUHJvcGVydHksIHZhbHVlUHJvcGVydHkgKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdFx0XHRjYXNlICdmJzpcclxuXHRcdFx0XHRcdFx0XHRcdFx0X2dsLnVuaWZvcm0xZiggbG9jYXRpb25Qcm9wZXJ0eSwgdmFsdWVQcm9wZXJ0eSApO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0XHRcdGNhc2UgJ3YyJzpcclxuXHRcdFx0XHRcdFx0XHRcdFx0X2dsLnVuaWZvcm0yZiggbG9jYXRpb25Qcm9wZXJ0eSwgdmFsdWVQcm9wZXJ0eS54LCB2YWx1ZVByb3BlcnR5LnkgKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdFx0XHRjYXNlICd2Myc6XHJcblx0XHRcdFx0XHRcdFx0XHRcdF9nbC51bmlmb3JtM2YoIGxvY2F0aW9uUHJvcGVydHksIHZhbHVlUHJvcGVydHkueCwgdmFsdWVQcm9wZXJ0eS55LCB2YWx1ZVByb3BlcnR5LnogKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdFx0XHRjYXNlICd2NCc6XHJcblx0XHRcdFx0XHRcdFx0XHRcdF9nbC51bmlmb3JtNGYoIGxvY2F0aW9uUHJvcGVydHksIHZhbHVlUHJvcGVydHkueCwgdmFsdWVQcm9wZXJ0eS55LCB2YWx1ZVByb3BlcnR5LnosIHZhbHVlUHJvcGVydHkudyApO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0XHRcdGNhc2UgJ2MnOlxyXG5cdFx0XHRcdFx0XHRcdFx0XHRfZ2wudW5pZm9ybTNmKCBsb2NhdGlvblByb3BlcnR5LCB2YWx1ZVByb3BlcnR5LnIsIHZhbHVlUHJvcGVydHkuZywgdmFsdWVQcm9wZXJ0eS5iICk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSAnbTQnOlxyXG5cdFx0XHRcdFx0XHRcdFx0XHRfZ2wudW5pZm9ybU1hdHJpeDRmdiggbG9jYXRpb25Qcm9wZXJ0eSwgZmFsc2UsIHZhbHVlUHJvcGVydHkuZWxlbWVudHMgKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnaXYxJzpcclxuXHJcblx0XHRcdFx0XHQvLyBmbGF0IGFycmF5IG9mIGludGVnZXJzIChKUyBvciB0eXBlZCBhcnJheSlcclxuXHRcdFx0XHRcdF9nbC51bmlmb3JtMWl2KCBsb2NhdGlvbiwgdmFsdWUgKTtcclxuXHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnaXYnOlxyXG5cclxuXHRcdFx0XHRcdC8vIGZsYXQgYXJyYXkgb2YgaW50ZWdlcnMgd2l0aCAzIHggTiBzaXplIChKUyBvciB0eXBlZCBhcnJheSlcclxuXHRcdFx0XHRcdF9nbC51bmlmb3JtM2l2KCBsb2NhdGlvbiwgdmFsdWUgKTtcclxuXHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnZnYxJzpcclxuXHJcblx0XHRcdFx0XHQvLyBmbGF0IGFycmF5IG9mIGZsb2F0cyAoSlMgb3IgdHlwZWQgYXJyYXkpXHJcblx0XHRcdFx0XHRfZ2wudW5pZm9ybTFmdiggbG9jYXRpb24sIHZhbHVlICk7XHJcblxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ2Z2JzpcclxuXHJcblx0XHRcdFx0XHQvLyBmbGF0IGFycmF5IG9mIGZsb2F0cyB3aXRoIDMgeCBOIHNpemUgKEpTIG9yIHR5cGVkIGFycmF5KVxyXG5cdFx0XHRcdFx0X2dsLnVuaWZvcm0zZnYoIGxvY2F0aW9uLCB2YWx1ZSApO1xyXG5cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICd2MnYnOlxyXG5cclxuXHRcdFx0XHRcdC8vIGFycmF5IG9mIFRIUkVFLlZlY3RvcjJcclxuXHJcblx0XHRcdFx0XHRpZiAoIHVuaWZvcm0uX2FycmF5ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR1bmlmb3JtLl9hcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIDIgKiB2YWx1ZS5sZW5ndGggKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpMiA9IDAsIGlsID0gdmFsdWUubGVuZ3RoOyBpIDwgaWw7IGkgKyssIGkyICs9IDIgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR1bmlmb3JtLl9hcnJheVsgaTIgKyAwIF0gPSB2YWx1ZVsgaSBdLng7XHJcblx0XHRcdFx0XHRcdHVuaWZvcm0uX2FycmF5WyBpMiArIDEgXSA9IHZhbHVlWyBpIF0ueTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0X2dsLnVuaWZvcm0yZnYoIGxvY2F0aW9uLCB1bmlmb3JtLl9hcnJheSApO1xyXG5cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICd2M3YnOlxyXG5cclxuXHRcdFx0XHRcdC8vIGFycmF5IG9mIFRIUkVFLlZlY3RvcjNcclxuXHJcblx0XHRcdFx0XHRpZiAoIHVuaWZvcm0uX2FycmF5ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR1bmlmb3JtLl9hcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIDMgKiB2YWx1ZS5sZW5ndGggKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpMyA9IDAsIGlsID0gdmFsdWUubGVuZ3RoOyBpIDwgaWw7IGkgKyssIGkzICs9IDMgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR1bmlmb3JtLl9hcnJheVsgaTMgKyAwIF0gPSB2YWx1ZVsgaSBdLng7XHJcblx0XHRcdFx0XHRcdHVuaWZvcm0uX2FycmF5WyBpMyArIDEgXSA9IHZhbHVlWyBpIF0ueTtcclxuXHRcdFx0XHRcdFx0dW5pZm9ybS5fYXJyYXlbIGkzICsgMiBdID0gdmFsdWVbIGkgXS56O1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRfZ2wudW5pZm9ybTNmdiggbG9jYXRpb24sIHVuaWZvcm0uX2FycmF5ICk7XHJcblxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ3Y0dic6XHJcblxyXG5cdFx0XHRcdFx0Ly8gYXJyYXkgb2YgVEhSRUUuVmVjdG9yNFxyXG5cclxuXHRcdFx0XHRcdGlmICggdW5pZm9ybS5fYXJyYXkgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRcdHVuaWZvcm0uX2FycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggNCAqIHZhbHVlLmxlbmd0aCApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGk0ID0gMCwgaWwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBpbDsgaSArKywgaTQgKz0gNCApIHtcclxuXHJcblx0XHRcdFx0XHRcdHVuaWZvcm0uX2FycmF5WyBpNCArIDAgXSA9IHZhbHVlWyBpIF0ueDtcclxuXHRcdFx0XHRcdFx0dW5pZm9ybS5fYXJyYXlbIGk0ICsgMSBdID0gdmFsdWVbIGkgXS55O1xyXG5cdFx0XHRcdFx0XHR1bmlmb3JtLl9hcnJheVsgaTQgKyAyIF0gPSB2YWx1ZVsgaSBdLno7XHJcblx0XHRcdFx0XHRcdHVuaWZvcm0uX2FycmF5WyBpNCArIDMgXSA9IHZhbHVlWyBpIF0udztcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0X2dsLnVuaWZvcm00ZnYoIGxvY2F0aW9uLCB1bmlmb3JtLl9hcnJheSApO1xyXG5cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICdtMic6XHJcblxyXG5cdFx0XHRcdFx0Ly8gc2luZ2xlIFRIUkVFLk1hdHJpeDJcclxuXHRcdFx0XHRcdF9nbC51bmlmb3JtTWF0cml4MmZ2KCBsb2NhdGlvbiwgZmFsc2UsIHZhbHVlLmVsZW1lbnRzICk7XHJcblxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ20zJzpcclxuXHJcblx0XHRcdFx0XHQvLyBzaW5nbGUgVEhSRUUuTWF0cml4M1xyXG5cdFx0XHRcdFx0X2dsLnVuaWZvcm1NYXRyaXgzZnYoIGxvY2F0aW9uLCBmYWxzZSwgdmFsdWUuZWxlbWVudHMgKTtcclxuXHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnbTN2JzpcclxuXHJcblx0XHRcdFx0XHQvLyBhcnJheSBvZiBUSFJFRS5NYXRyaXgzXHJcblxyXG5cdFx0XHRcdFx0aWYgKCB1bmlmb3JtLl9hcnJheSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dW5pZm9ybS5fYXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCA5ICogdmFsdWUubGVuZ3RoICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdHZhbHVlWyBpIF0uZmxhdHRlblRvQXJyYXlPZmZzZXQoIHVuaWZvcm0uX2FycmF5LCBpICogOSApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRfZ2wudW5pZm9ybU1hdHJpeDNmdiggbG9jYXRpb24sIGZhbHNlLCB1bmlmb3JtLl9hcnJheSApO1xyXG5cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICdtNCc6XHJcblxyXG5cdFx0XHRcdFx0Ly8gc2luZ2xlIFRIUkVFLk1hdHJpeDRcclxuXHRcdFx0XHRcdF9nbC51bmlmb3JtTWF0cml4NGZ2KCBsb2NhdGlvbiwgZmFsc2UsIHZhbHVlLmVsZW1lbnRzICk7XHJcblxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ200dic6XHJcblxyXG5cdFx0XHRcdFx0Ly8gYXJyYXkgb2YgVEhSRUUuTWF0cml4NFxyXG5cclxuXHRcdFx0XHRcdGlmICggdW5pZm9ybS5fYXJyYXkgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRcdHVuaWZvcm0uX2FycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggMTYgKiB2YWx1ZS5sZW5ndGggKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dmFsdWVbIGkgXS5mbGF0dGVuVG9BcnJheU9mZnNldCggdW5pZm9ybS5fYXJyYXksIGkgKiAxNiApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRfZ2wudW5pZm9ybU1hdHJpeDRmdiggbG9jYXRpb24sIGZhbHNlLCB1bmlmb3JtLl9hcnJheSApO1xyXG5cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICd0JzpcclxuXHJcblx0XHRcdFx0XHQvLyBzaW5nbGUgVEhSRUUuVGV4dHVyZSAoMmQgb3IgY3ViZSlcclxuXHJcblx0XHRcdFx0XHR0ZXh0dXJlID0gdmFsdWU7XHJcblx0XHRcdFx0XHR0ZXh0dXJlVW5pdCA9IGdldFRleHR1cmVVbml0KCk7XHJcblxyXG5cdFx0XHRcdFx0X2dsLnVuaWZvcm0xaSggbG9jYXRpb24sIHRleHR1cmVVbml0ICk7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCAhIHRleHR1cmUgKSBjb250aW51ZTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIHRleHR1cmUgaW5zdGFuY2VvZiBUSFJFRS5DdWJlVGV4dHVyZSB8fFxyXG5cdFx0XHRcdFx0XHQgKCBBcnJheS5pc0FycmF5KCB0ZXh0dXJlLmltYWdlICkgJiYgdGV4dHVyZS5pbWFnZS5sZW5ndGggPT09IDYgKSApIHtcclxuXHJcblx0XHRcdFx0XHRcdC8vIENvbXByZXNzZWRUZXh0dXJlIGNhbiBoYXZlIEFycmF5IGluIGltYWdlIDovXHJcblxyXG5cdFx0XHRcdFx0XHRzZXRDdWJlVGV4dHVyZSggdGV4dHVyZSwgdGV4dHVyZVVuaXQgKTtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCB0ZXh0dXJlIGluc3RhbmNlb2YgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXRDdWJlICkge1xyXG5cclxuXHRcdFx0XHRcdFx0c2V0Q3ViZVRleHR1cmVEeW5hbWljKCB0ZXh0dXJlLnRleHR1cmUsIHRleHR1cmVVbml0ICk7XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggdGV4dHVyZSBpbnN0YW5jZW9mIFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0ICkge1xyXG5cclxuXHRcdFx0XHRcdFx0X3RoaXMuc2V0VGV4dHVyZSggdGV4dHVyZS50ZXh0dXJlLCB0ZXh0dXJlVW5pdCApO1xyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRfdGhpcy5zZXRUZXh0dXJlKCB0ZXh0dXJlLCB0ZXh0dXJlVW5pdCApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAndHYnOlxyXG5cclxuXHRcdFx0XHRcdC8vIGFycmF5IG9mIFRIUkVFLlRleHR1cmUgKDJkIG9yIGN1YmUpXHJcblxyXG5cdFx0XHRcdFx0aWYgKCB1bmlmb3JtLl9hcnJheSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dW5pZm9ybS5fYXJyYXkgPSBbXTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHVuaWZvcm0udmFsdWUubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR1bmlmb3JtLl9hcnJheVsgaSBdID0gZ2V0VGV4dHVyZVVuaXQoKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0X2dsLnVuaWZvcm0xaXYoIGxvY2F0aW9uLCB1bmlmb3JtLl9hcnJheSApO1xyXG5cclxuXHRcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSB1bmlmb3JtLnZhbHVlLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dGV4dHVyZSA9IHVuaWZvcm0udmFsdWVbIGkgXTtcclxuXHRcdFx0XHRcdFx0dGV4dHVyZVVuaXQgPSB1bmlmb3JtLl9hcnJheVsgaSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCAhIHRleHR1cmUgKSBjb250aW51ZTtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggdGV4dHVyZSBpbnN0YW5jZW9mIFRIUkVFLkN1YmVUZXh0dXJlIHx8XHJcblx0XHRcdFx0XHRcdFx0ICggdGV4dHVyZS5pbWFnZSBpbnN0YW5jZW9mIEFycmF5ICYmIHRleHR1cmUuaW1hZ2UubGVuZ3RoID09PSA2ICkgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdC8vIENvbXByZXNzZWRUZXh0dXJlIGNhbiBoYXZlIEFycmF5IGluIGltYWdlIDovXHJcblxyXG5cdFx0XHRcdFx0XHRcdHNldEN1YmVUZXh0dXJlKCB0ZXh0dXJlLCB0ZXh0dXJlVW5pdCApO1xyXG5cclxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICggdGV4dHVyZSBpbnN0YW5jZW9mIFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0ICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRfdGhpcy5zZXRUZXh0dXJlKCB0ZXh0dXJlLnRleHR1cmUsIHRleHR1cmVVbml0ICk7XHJcblxyXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCB0ZXh0dXJlIGluc3RhbmNlb2YgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXRDdWJlICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRzZXRDdWJlVGV4dHVyZUR5bmFtaWMoIHRleHR1cmUudGV4dHVyZSwgdGV4dHVyZVVuaXQgKTtcclxuXHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdF90aGlzLnNldFRleHR1cmUoIHRleHR1cmUsIHRleHR1cmVVbml0ICk7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRkZWZhdWx0OlxyXG5cclxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IFVua25vd24gdW5pZm9ybSB0eXBlOiAnICsgdHlwZSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBzZXR1cExpZ2h0cyAoIGxpZ2h0cywgY2FtZXJhICkge1xyXG5cclxuXHRcdHZhciBsLCBsbCwgbGlnaHQsXHJcblx0XHRyID0gMCwgZyA9IDAsIGIgPSAwLFxyXG5cdFx0Y29sb3IsXHJcblx0XHRpbnRlbnNpdHksXHJcblx0XHRkaXN0YW5jZSxcclxuXHJcblx0XHR2aWV3TWF0cml4ID0gY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSxcclxuXHJcblx0XHRkaXJlY3Rpb25hbExlbmd0aCA9IDAsXHJcblx0XHRwb2ludExlbmd0aCA9IDAsXHJcblx0XHRzcG90TGVuZ3RoID0gMCxcclxuXHRcdGhlbWlMZW5ndGggPSAwLFxyXG5cclxuXHRcdHNoYWRvd3NMZW5ndGggPSAwO1xyXG5cclxuXHRcdF9saWdodHMuc2hhZG93c1BvaW50TGlnaHQgPSAwO1xyXG5cclxuXHRcdGZvciAoIGwgPSAwLCBsbCA9IGxpZ2h0cy5sZW5ndGg7IGwgPCBsbDsgbCArKyApIHtcclxuXHJcblx0XHRcdGxpZ2h0ID0gbGlnaHRzWyBsIF07XHJcblxyXG5cdFx0XHRjb2xvciA9IGxpZ2h0LmNvbG9yO1xyXG5cdFx0XHRpbnRlbnNpdHkgPSBsaWdodC5pbnRlbnNpdHk7XHJcblx0XHRcdGRpc3RhbmNlID0gbGlnaHQuZGlzdGFuY2U7XHJcblxyXG5cdFx0XHRpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuQW1iaWVudExpZ2h0ICkge1xyXG5cclxuXHRcdFx0XHRyICs9IGNvbG9yLnIgKiBpbnRlbnNpdHk7XHJcblx0XHRcdFx0ZyArPSBjb2xvci5nICogaW50ZW5zaXR5O1xyXG5cdFx0XHRcdGIgKz0gY29sb3IuYiAqIGludGVuc2l0eTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuRGlyZWN0aW9uYWxMaWdodCApIHtcclxuXHJcblx0XHRcdFx0dmFyIHVuaWZvcm1zID0gbGlnaHRDYWNoZS5nZXQoIGxpZ2h0ICk7XHJcblxyXG5cdFx0XHRcdHVuaWZvcm1zLmNvbG9yLmNvcHkoIGxpZ2h0LmNvbG9yICkubXVsdGlwbHlTY2FsYXIoIGxpZ2h0LmludGVuc2l0eSApO1xyXG5cdFx0XHRcdHVuaWZvcm1zLmRpcmVjdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0Lm1hdHJpeFdvcmxkICk7XHJcblx0XHRcdFx0X3ZlY3RvcjMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC50YXJnZXQubWF0cml4V29ybGQgKTtcclxuXHRcdFx0XHR1bmlmb3Jtcy5kaXJlY3Rpb24uc3ViKCBfdmVjdG9yMyApO1xyXG5cdFx0XHRcdHVuaWZvcm1zLmRpcmVjdGlvbi50cmFuc2Zvcm1EaXJlY3Rpb24oIHZpZXdNYXRyaXggKTtcclxuXHJcblx0XHRcdFx0dW5pZm9ybXMuc2hhZG93ID0gbGlnaHQuY2FzdFNoYWRvdztcclxuXHJcblx0XHRcdFx0aWYgKCBsaWdodC5jYXN0U2hhZG93ICkge1xyXG5cclxuXHRcdFx0XHRcdHVuaWZvcm1zLnNoYWRvd0JpYXMgPSBsaWdodC5zaGFkb3cuYmlhcztcclxuXHRcdFx0XHRcdHVuaWZvcm1zLnNoYWRvd1JhZGl1cyA9IGxpZ2h0LnNoYWRvdy5yYWRpdXM7XHJcblx0XHRcdFx0XHR1bmlmb3Jtcy5zaGFkb3dNYXBTaXplID0gbGlnaHQuc2hhZG93Lm1hcFNpemU7XHJcblxyXG5cdFx0XHRcdFx0X2xpZ2h0cy5zaGFkb3dzWyBzaGFkb3dzTGVuZ3RoICsrIF0gPSBsaWdodDtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRfbGlnaHRzLmRpcmVjdGlvbmFsU2hhZG93TWFwWyBkaXJlY3Rpb25hbExlbmd0aCBdID0gbGlnaHQuc2hhZG93Lm1hcDtcclxuXHRcdFx0XHRfbGlnaHRzLmRpcmVjdGlvbmFsU2hhZG93TWF0cml4WyBkaXJlY3Rpb25hbExlbmd0aCBdID0gbGlnaHQuc2hhZG93Lm1hdHJpeDtcclxuXHRcdFx0XHRfbGlnaHRzLmRpcmVjdGlvbmFsWyBkaXJlY3Rpb25hbExlbmd0aCArKyBdID0gdW5pZm9ybXM7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLlNwb3RMaWdodCApIHtcclxuXHJcblx0XHRcdFx0dmFyIHVuaWZvcm1zID0gbGlnaHRDYWNoZS5nZXQoIGxpZ2h0ICk7XHJcblxyXG5cdFx0XHRcdHVuaWZvcm1zLnBvc2l0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQubWF0cml4V29ybGQgKTtcclxuXHRcdFx0XHR1bmlmb3Jtcy5wb3NpdGlvbi5hcHBseU1hdHJpeDQoIHZpZXdNYXRyaXggKTtcclxuXHJcblx0XHRcdFx0dW5pZm9ybXMuY29sb3IuY29weSggY29sb3IgKS5tdWx0aXBseVNjYWxhciggaW50ZW5zaXR5ICk7XHJcblx0XHRcdFx0dW5pZm9ybXMuZGlzdGFuY2UgPSBkaXN0YW5jZTtcclxuXHJcblx0XHRcdFx0dW5pZm9ybXMuZGlyZWN0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQubWF0cml4V29ybGQgKTtcclxuXHRcdFx0XHRfdmVjdG9yMy5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0LnRhcmdldC5tYXRyaXhXb3JsZCApO1xyXG5cdFx0XHRcdHVuaWZvcm1zLmRpcmVjdGlvbi5zdWIoIF92ZWN0b3IzICk7XHJcblx0XHRcdFx0dW5pZm9ybXMuZGlyZWN0aW9uLnRyYW5zZm9ybURpcmVjdGlvbiggdmlld01hdHJpeCApO1xyXG5cclxuXHRcdFx0XHR1bmlmb3Jtcy5hbmdsZUNvcyA9IE1hdGguY29zKCBsaWdodC5hbmdsZSApO1xyXG5cdFx0XHRcdHVuaWZvcm1zLmV4cG9uZW50ID0gbGlnaHQuZXhwb25lbnQ7XHJcblx0XHRcdFx0dW5pZm9ybXMuZGVjYXkgPSAoIGxpZ2h0LmRpc3RhbmNlID09PSAwICkgPyAwLjAgOiBsaWdodC5kZWNheTtcclxuXHJcblx0XHRcdFx0dW5pZm9ybXMuc2hhZG93ID0gbGlnaHQuY2FzdFNoYWRvdztcclxuXHJcblx0XHRcdFx0aWYgKCBsaWdodC5jYXN0U2hhZG93ICkge1xyXG5cclxuXHRcdFx0XHRcdHVuaWZvcm1zLnNoYWRvd0JpYXMgPSBsaWdodC5zaGFkb3cuYmlhcztcclxuXHRcdFx0XHRcdHVuaWZvcm1zLnNoYWRvd1JhZGl1cyA9IGxpZ2h0LnNoYWRvdy5yYWRpdXM7XHJcblx0XHRcdFx0XHR1bmlmb3Jtcy5zaGFkb3dNYXBTaXplID0gbGlnaHQuc2hhZG93Lm1hcFNpemU7XHJcblxyXG5cdFx0XHRcdFx0X2xpZ2h0cy5zaGFkb3dzWyBzaGFkb3dzTGVuZ3RoICsrIF0gPSBsaWdodDtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRfbGlnaHRzLnNwb3RTaGFkb3dNYXBbIHNwb3RMZW5ndGggXSA9IGxpZ2h0LnNoYWRvdy5tYXA7XHJcblx0XHRcdFx0X2xpZ2h0cy5zcG90U2hhZG93TWF0cml4WyBzcG90TGVuZ3RoIF0gPSBsaWdodC5zaGFkb3cubWF0cml4O1xyXG5cdFx0XHRcdF9saWdodHMuc3BvdFsgc3BvdExlbmd0aCArKyBdID0gdW5pZm9ybXM7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLlBvaW50TGlnaHQgKSB7XHJcblxyXG5cdFx0XHRcdHZhciB1bmlmb3JtcyA9IGxpZ2h0Q2FjaGUuZ2V0KCBsaWdodCApO1xyXG5cclxuXHRcdFx0XHR1bmlmb3Jtcy5wb3NpdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0Lm1hdHJpeFdvcmxkICk7XHJcblx0XHRcdFx0dW5pZm9ybXMucG9zaXRpb24uYXBwbHlNYXRyaXg0KCB2aWV3TWF0cml4ICk7XHJcblxyXG5cdFx0XHRcdHVuaWZvcm1zLmNvbG9yLmNvcHkoIGxpZ2h0LmNvbG9yICkubXVsdGlwbHlTY2FsYXIoIGxpZ2h0LmludGVuc2l0eSApO1xyXG5cdFx0XHRcdHVuaWZvcm1zLmRpc3RhbmNlID0gbGlnaHQuZGlzdGFuY2U7XHJcblx0XHRcdFx0dW5pZm9ybXMuZGVjYXkgPSAoIGxpZ2h0LmRpc3RhbmNlID09PSAwICkgPyAwLjAgOiBsaWdodC5kZWNheTtcclxuXHJcblx0XHRcdFx0dW5pZm9ybXMuc2hhZG93ID0gbGlnaHQuY2FzdFNoYWRvdztcclxuXHJcblx0XHRcdFx0aWYgKCBsaWdodC5jYXN0U2hhZG93ICkge1xyXG5cclxuXHRcdFx0XHRcdHVuaWZvcm1zLnNoYWRvd0JpYXMgPSBsaWdodC5zaGFkb3cuYmlhcztcclxuXHRcdFx0XHRcdHVuaWZvcm1zLnNoYWRvd1JhZGl1cyA9IGxpZ2h0LnNoYWRvdy5yYWRpdXM7XHJcblx0XHRcdFx0XHR1bmlmb3Jtcy5zaGFkb3dNYXBTaXplID0gbGlnaHQuc2hhZG93Lm1hcFNpemU7XHJcblxyXG5cdFx0XHRcdFx0X2xpZ2h0cy5zaGFkb3dzWyBzaGFkb3dzTGVuZ3RoICsrIF0gPSBsaWdodDtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRfbGlnaHRzLnBvaW50U2hhZG93TWFwWyBwb2ludExlbmd0aCBdID0gbGlnaHQuc2hhZG93Lm1hcDtcclxuXHJcblx0XHRcdFx0aWYgKCBfbGlnaHRzLnBvaW50U2hhZG93TWF0cml4WyBwb2ludExlbmd0aCBdID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0X2xpZ2h0cy5wb2ludFNoYWRvd01hdHJpeFsgcG9pbnRMZW5ndGggXSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gZm9yIHBvaW50IGxpZ2h0cyB3ZSBzZXQgdGhlIHNoYWRvdyBtYXRyaXggdG8gYmUgYSB0cmFuc2xhdGlvbi1vbmx5IG1hdHJpeFxyXG5cdFx0XHRcdC8vIGVxdWFsIHRvIGludmVyc2Ugb2YgdGhlIGxpZ2h0J3MgcG9zaXRpb25cclxuXHRcdFx0XHRfdmVjdG9yMy5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0Lm1hdHJpeFdvcmxkICkubmVnYXRlKCk7XHJcblx0XHRcdFx0X2xpZ2h0cy5wb2ludFNoYWRvd01hdHJpeFsgcG9pbnRMZW5ndGggXS5pZGVudGl0eSgpLnNldFBvc2l0aW9uKCBfdmVjdG9yMyApO1xyXG5cclxuXHRcdFx0XHRfbGlnaHRzLnBvaW50WyBwb2ludExlbmd0aCArKyBdID0gdW5pZm9ybXM7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLkhlbWlzcGhlcmVMaWdodCApIHtcclxuXHJcblx0XHRcdFx0dmFyIHVuaWZvcm1zID0gbGlnaHRDYWNoZS5nZXQoIGxpZ2h0ICk7XHJcblxyXG5cdFx0XHRcdHVuaWZvcm1zLmRpcmVjdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0Lm1hdHJpeFdvcmxkICk7XHJcblx0XHRcdFx0dW5pZm9ybXMuZGlyZWN0aW9uLnRyYW5zZm9ybURpcmVjdGlvbiggdmlld01hdHJpeCApO1xyXG5cdFx0XHRcdHVuaWZvcm1zLmRpcmVjdGlvbi5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRcdFx0dW5pZm9ybXMuc2t5Q29sb3IuY29weSggbGlnaHQuY29sb3IgKS5tdWx0aXBseVNjYWxhciggaW50ZW5zaXR5ICk7XHJcblx0XHRcdFx0dW5pZm9ybXMuZ3JvdW5kQ29sb3IuY29weSggbGlnaHQuZ3JvdW5kQ29sb3IgKS5tdWx0aXBseVNjYWxhciggaW50ZW5zaXR5ICk7XHJcblxyXG5cdFx0XHRcdF9saWdodHMuaGVtaVsgaGVtaUxlbmd0aCArKyBdID0gdW5pZm9ybXM7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdF9saWdodHMuYW1iaWVudFsgMCBdID0gcjtcclxuXHRcdF9saWdodHMuYW1iaWVudFsgMSBdID0gZztcclxuXHRcdF9saWdodHMuYW1iaWVudFsgMiBdID0gYjtcclxuXHJcblx0XHRfbGlnaHRzLmRpcmVjdGlvbmFsLmxlbmd0aCA9IGRpcmVjdGlvbmFsTGVuZ3RoO1xyXG5cdFx0X2xpZ2h0cy5zcG90Lmxlbmd0aCA9IHNwb3RMZW5ndGg7XHJcblx0XHRfbGlnaHRzLnBvaW50Lmxlbmd0aCA9IHBvaW50TGVuZ3RoO1xyXG5cdFx0X2xpZ2h0cy5oZW1pLmxlbmd0aCA9IGhlbWlMZW5ndGg7XHJcblxyXG5cdFx0X2xpZ2h0cy5zaGFkb3dzLmxlbmd0aCA9IHNoYWRvd3NMZW5ndGg7XHJcblxyXG5cdFx0X2xpZ2h0cy5oYXNoID0gZGlyZWN0aW9uYWxMZW5ndGggKyAnLCcgKyBwb2ludExlbmd0aCArICcsJyArIHNwb3RMZW5ndGggKyAnLCcgKyBoZW1pTGVuZ3RoICsgJywnICsgc2hhZG93c0xlbmd0aDtcclxuXHJcblx0fVxyXG5cclxuXHQvLyBHTCBzdGF0ZSBzZXR0aW5nXHJcblxyXG5cdHRoaXMuc2V0RmFjZUN1bGxpbmcgPSBmdW5jdGlvbiAoIGN1bGxGYWNlLCBmcm9udEZhY2VEaXJlY3Rpb24gKSB7XHJcblxyXG5cdFx0aWYgKCBjdWxsRmFjZSA9PT0gVEhSRUUuQ3VsbEZhY2VOb25lICkge1xyXG5cclxuXHRcdFx0c3RhdGUuZGlzYWJsZSggX2dsLkNVTExfRkFDRSApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRpZiAoIGZyb250RmFjZURpcmVjdGlvbiA9PT0gVEhSRUUuRnJvbnRGYWNlRGlyZWN0aW9uQ1cgKSB7XHJcblxyXG5cdFx0XHRcdF9nbC5mcm9udEZhY2UoIF9nbC5DVyApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0X2dsLmZyb250RmFjZSggX2dsLkNDVyApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBjdWxsRmFjZSA9PT0gVEhSRUUuQ3VsbEZhY2VCYWNrICkge1xyXG5cclxuXHRcdFx0XHRfZ2wuY3VsbEZhY2UoIF9nbC5CQUNLICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBjdWxsRmFjZSA9PT0gVEhSRUUuQ3VsbEZhY2VGcm9udCApIHtcclxuXHJcblx0XHRcdFx0X2dsLmN1bGxGYWNlKCBfZ2wuRlJPTlQgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdF9nbC5jdWxsRmFjZSggX2dsLkZST05UX0FORF9CQUNLICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRzdGF0ZS5lbmFibGUoIF9nbC5DVUxMX0ZBQ0UgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdC8vIFRleHR1cmVzXHJcblxyXG5cdGZ1bmN0aW9uIHNldFRleHR1cmVQYXJhbWV0ZXJzICggdGV4dHVyZVR5cGUsIHRleHR1cmUsIGlzUG93ZXJPZlR3b0ltYWdlICkge1xyXG5cclxuXHRcdHZhciBleHRlbnNpb247XHJcblxyXG5cdFx0aWYgKCBpc1Bvd2VyT2ZUd29JbWFnZSApIHtcclxuXHJcblx0XHRcdF9nbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfV1JBUF9TLCBwYXJhbVRocmVlVG9HTCggdGV4dHVyZS53cmFwUyApICk7XHJcblx0XHRcdF9nbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfV1JBUF9ULCBwYXJhbVRocmVlVG9HTCggdGV4dHVyZS53cmFwVCApICk7XHJcblxyXG5cdFx0XHRfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX01BR19GSUxURVIsIHBhcmFtVGhyZWVUb0dMKCB0ZXh0dXJlLm1hZ0ZpbHRlciApICk7XHJcblx0XHRcdF9nbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgcGFyYW1UaHJlZVRvR0woIHRleHR1cmUubWluRmlsdGVyICkgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0X2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9XUkFQX1MsIF9nbC5DTEFNUF9UT19FREdFICk7XHJcblx0XHRcdF9nbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfV1JBUF9ULCBfZ2wuQ0xBTVBfVE9fRURHRSApO1xyXG5cclxuXHRcdFx0aWYgKCB0ZXh0dXJlLndyYXBTICE9PSBUSFJFRS5DbGFtcFRvRWRnZVdyYXBwaW5nIHx8IHRleHR1cmUud3JhcFQgIT09IFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmcgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IFRleHR1cmUgaXMgbm90IHBvd2VyIG9mIHR3by4gVGV4dHVyZS53cmFwUyBhbmQgVGV4dHVyZS53cmFwVCBzaG91bGQgYmUgc2V0IHRvIFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmcuJywgdGV4dHVyZSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0X2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBmaWx0ZXJGYWxsYmFjayggdGV4dHVyZS5tYWdGaWx0ZXIgKSApO1xyXG5cdFx0XHRfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX01JTl9GSUxURVIsIGZpbHRlckZhbGxiYWNrKCB0ZXh0dXJlLm1pbkZpbHRlciApICk7XHJcblxyXG5cdFx0XHRpZiAoIHRleHR1cmUubWluRmlsdGVyICE9PSBUSFJFRS5OZWFyZXN0RmlsdGVyICYmIHRleHR1cmUubWluRmlsdGVyICE9PSBUSFJFRS5MaW5lYXJGaWx0ZXIgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IFRleHR1cmUgaXMgbm90IHBvd2VyIG9mIHR3by4gVGV4dHVyZS5taW5GaWx0ZXIgc2hvdWxkIGJlIHNldCB0byBUSFJFRS5OZWFyZXN0RmlsdGVyIG9yIFRIUkVFLkxpbmVhckZpbHRlci4nLCB0ZXh0dXJlICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJyApO1xyXG5cclxuXHRcdGlmICggZXh0ZW5zaW9uICkge1xyXG5cclxuXHRcdFx0aWYgKCB0ZXh0dXJlLnR5cGUgPT09IFRIUkVFLkZsb2F0VHlwZSAmJiBleHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2Zsb2F0X2xpbmVhcicgKSA9PT0gbnVsbCApIHJldHVybjtcclxuXHRcdFx0aWYgKCB0ZXh0dXJlLnR5cGUgPT09IFRIUkVFLkhhbGZGbG9hdFR5cGUgJiYgZXh0ZW5zaW9ucy5nZXQoICdPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0X2xpbmVhcicgKSA9PT0gbnVsbCApIHJldHVybjtcclxuXHJcblx0XHRcdGlmICggdGV4dHVyZS5hbmlzb3Ryb3B5ID4gMSB8fCBwcm9wZXJ0aWVzLmdldCggdGV4dHVyZSApLl9fY3VycmVudEFuaXNvdHJvcHkgKSB7XHJcblxyXG5cdFx0XHRcdF9nbC50ZXhQYXJhbWV0ZXJmKCB0ZXh0dXJlVHlwZSwgZXh0ZW5zaW9uLlRFWFRVUkVfTUFYX0FOSVNPVFJPUFlfRVhULCBNYXRoLm1pbiggdGV4dHVyZS5hbmlzb3Ryb3B5LCBfdGhpcy5nZXRNYXhBbmlzb3Ryb3B5KCkgKSApO1xyXG5cdFx0XHRcdHByb3BlcnRpZXMuZ2V0KCB0ZXh0dXJlICkuX19jdXJyZW50QW5pc290cm9weSA9IHRleHR1cmUuYW5pc290cm9weTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gdXBsb2FkVGV4dHVyZSggdGV4dHVyZVByb3BlcnRpZXMsIHRleHR1cmUsIHNsb3QgKSB7XHJcblxyXG5cdFx0aWYgKCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsSW5pdCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0dGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbEluaXQgPSB0cnVlO1xyXG5cclxuXHRcdFx0dGV4dHVyZS5hZGRFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uVGV4dHVyZURpc3Bvc2UgKTtcclxuXHJcblx0XHRcdHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlID0gX2dsLmNyZWF0ZVRleHR1cmUoKTtcclxuXHJcblx0XHRcdF9pbmZvTWVtb3J5LnRleHR1cmVzICsrO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRzdGF0ZS5hY3RpdmVUZXh0dXJlKCBfZ2wuVEVYVFVSRTAgKyBzbG90ICk7XHJcblx0XHRzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfMkQsIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlICk7XHJcblxyXG5cdFx0X2dsLnBpeGVsU3RvcmVpKCBfZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgdGV4dHVyZS5mbGlwWSApO1xyXG5cdFx0X2dsLnBpeGVsU3RvcmVpKCBfZ2wuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLCB0ZXh0dXJlLnByZW11bHRpcGx5QWxwaGEgKTtcclxuXHRcdF9nbC5waXhlbFN0b3JlaSggX2dsLlVOUEFDS19BTElHTk1FTlQsIHRleHR1cmUudW5wYWNrQWxpZ25tZW50ICk7XHJcblxyXG5cdFx0dmFyIGltYWdlID0gY2xhbXBUb01heFNpemUoIHRleHR1cmUuaW1hZ2UsIGNhcGFiaWxpdGllcy5tYXhUZXh0dXJlU2l6ZSApO1xyXG5cclxuXHRcdGlmICggdGV4dHVyZU5lZWRzUG93ZXJPZlR3byggdGV4dHVyZSApICYmIGlzUG93ZXJPZlR3byggaW1hZ2UgKSA9PT0gZmFsc2UgKSB7XHJcblxyXG5cdFx0XHRpbWFnZSA9IG1ha2VQb3dlck9mVHdvKCBpbWFnZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgaXNQb3dlck9mVHdvSW1hZ2UgPSBpc1Bvd2VyT2ZUd28oIGltYWdlICksXHJcblx0XHRnbEZvcm1hdCA9IHBhcmFtVGhyZWVUb0dMKCB0ZXh0dXJlLmZvcm1hdCApLFxyXG5cdFx0Z2xUeXBlID0gcGFyYW1UaHJlZVRvR0woIHRleHR1cmUudHlwZSApO1xyXG5cclxuXHRcdHNldFRleHR1cmVQYXJhbWV0ZXJzKCBfZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSwgaXNQb3dlck9mVHdvSW1hZ2UgKTtcclxuXHJcblx0XHR2YXIgbWlwbWFwLCBtaXBtYXBzID0gdGV4dHVyZS5taXBtYXBzO1xyXG5cclxuXHRcdGlmICggdGV4dHVyZSBpbnN0YW5jZW9mIFRIUkVFLkRhdGFUZXh0dXJlICkge1xyXG5cclxuXHRcdFx0Ly8gdXNlIG1hbnVhbGx5IGNyZWF0ZWQgbWlwbWFwcyBpZiBhdmFpbGFibGVcclxuXHRcdFx0Ly8gaWYgdGhlcmUgYXJlIG5vIG1hbnVhbCBtaXBtYXBzXHJcblx0XHRcdC8vIHNldCAwIGxldmVsIG1pcG1hcCBhbmQgdGhlbiB1c2UgR0wgdG8gZ2VuZXJhdGUgb3RoZXIgbWlwbWFwIGxldmVsc1xyXG5cclxuXHRcdFx0aWYgKCBtaXBtYXBzLmxlbmd0aCA+IDAgJiYgaXNQb3dlck9mVHdvSW1hZ2UgKSB7XHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBtaXBtYXBzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdG1pcG1hcCA9IG1pcG1hcHNbIGkgXTtcclxuXHRcdFx0XHRcdHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCBpLCBnbEZvcm1hdCwgbWlwbWFwLndpZHRoLCBtaXBtYXAuaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBtaXBtYXAuZGF0YSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRzdGF0ZS50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgMCwgZ2xGb3JtYXQsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIGltYWdlLmRhdGEgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2UgaWYgKCB0ZXh0dXJlIGluc3RhbmNlb2YgVEhSRUUuQ29tcHJlc3NlZFRleHR1cmUgKSB7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gbWlwbWFwcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0bWlwbWFwID0gbWlwbWFwc1sgaSBdO1xyXG5cclxuXHRcdFx0XHRpZiAoIHRleHR1cmUuZm9ybWF0ICE9PSBUSFJFRS5SR0JBRm9ybWF0ICYmIHRleHR1cmUuZm9ybWF0ICE9PSBUSFJFRS5SR0JGb3JtYXQgKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBzdGF0ZS5nZXRDb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMoKS5pbmRleE9mKCBnbEZvcm1hdCApID4gLSAxICkge1xyXG5cclxuXHRcdFx0XHRcdFx0c3RhdGUuY29tcHJlc3NlZFRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCBpLCBnbEZvcm1hdCwgbWlwbWFwLndpZHRoLCBtaXBtYXAuaGVpZ2h0LCAwLCBtaXBtYXAuZGF0YSApO1xyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oIFwiVEhSRUUuV2ViR0xSZW5kZXJlcjogQXR0ZW1wdCB0byBsb2FkIHVuc3VwcG9ydGVkIGNvbXByZXNzZWQgdGV4dHVyZSBmb3JtYXQgaW4gLnVwbG9hZFRleHR1cmUoKVwiICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCBpLCBnbEZvcm1hdCwgbWlwbWFwLndpZHRoLCBtaXBtYXAuaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBtaXBtYXAuZGF0YSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdC8vIHJlZ3VsYXIgVGV4dHVyZSAoaW1hZ2UsIHZpZGVvLCBjYW52YXMpXHJcblxyXG5cdFx0XHQvLyB1c2UgbWFudWFsbHkgY3JlYXRlZCBtaXBtYXBzIGlmIGF2YWlsYWJsZVxyXG5cdFx0XHQvLyBpZiB0aGVyZSBhcmUgbm8gbWFudWFsIG1pcG1hcHNcclxuXHRcdFx0Ly8gc2V0IDAgbGV2ZWwgbWlwbWFwIGFuZCB0aGVuIHVzZSBHTCB0byBnZW5lcmF0ZSBvdGhlciBtaXBtYXAgbGV2ZWxzXHJcblxyXG5cdFx0XHRpZiAoIG1pcG1hcHMubGVuZ3RoID4gMCAmJiBpc1Bvd2VyT2ZUd29JbWFnZSApIHtcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IG1pcG1hcHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0bWlwbWFwID0gbWlwbWFwc1sgaSBdO1xyXG5cdFx0XHRcdFx0c3RhdGUudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfMkQsIGksIGdsRm9ybWF0LCBnbEZvcm1hdCwgZ2xUeXBlLCBtaXBtYXAgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR0ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0c3RhdGUudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfMkQsIDAsIGdsRm9ybWF0LCBnbEZvcm1hdCwgZ2xUeXBlLCBpbWFnZSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzICYmIGlzUG93ZXJPZlR3b0ltYWdlICkgX2dsLmdlbmVyYXRlTWlwbWFwKCBfZ2wuVEVYVFVSRV8yRCApO1xyXG5cclxuXHRcdHRleHR1cmVQcm9wZXJ0aWVzLl9fdmVyc2lvbiA9IHRleHR1cmUudmVyc2lvbjtcclxuXHJcblx0XHRpZiAoIHRleHR1cmUub25VcGRhdGUgKSB0ZXh0dXJlLm9uVXBkYXRlKCB0ZXh0dXJlICk7XHJcblxyXG5cdH1cclxuXHJcblx0dGhpcy5zZXRUZXh0dXJlID0gZnVuY3Rpb24gKCB0ZXh0dXJlLCBzbG90ICkge1xyXG5cclxuXHRcdHZhciB0ZXh0dXJlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCB0ZXh0dXJlICk7XHJcblxyXG5cdFx0aWYgKCB0ZXh0dXJlLnZlcnNpb24gPiAwICYmIHRleHR1cmVQcm9wZXJ0aWVzLl9fdmVyc2lvbiAhPT0gdGV4dHVyZS52ZXJzaW9uICkge1xyXG5cclxuXHRcdFx0dmFyIGltYWdlID0gdGV4dHVyZS5pbWFnZTtcclxuXHJcblx0XHRcdGlmICggaW1hZ2UgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogVGV4dHVyZSBtYXJrZWQgZm9yIHVwZGF0ZSBidXQgaW1hZ2UgaXMgdW5kZWZpbmVkJywgdGV4dHVyZSApO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggaW1hZ2UuY29tcGxldGUgPT09IGZhbHNlICkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBUZXh0dXJlIG1hcmtlZCBmb3IgdXBkYXRlIGJ1dCBpbWFnZSBpcyBpbmNvbXBsZXRlJywgdGV4dHVyZSApO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHVwbG9hZFRleHR1cmUoIHRleHR1cmVQcm9wZXJ0aWVzLCB0ZXh0dXJlLCBzbG90ICk7XHJcblxyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHN0YXRlLmFjdGl2ZVRleHR1cmUoIF9nbC5URVhUVVJFMCArIHNsb3QgKTtcclxuXHRcdHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgKTtcclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gY2xhbXBUb01heFNpemUgKCBpbWFnZSwgbWF4U2l6ZSApIHtcclxuXHJcblx0XHRpZiAoIGltYWdlLndpZHRoID4gbWF4U2l6ZSB8fCBpbWFnZS5oZWlnaHQgPiBtYXhTaXplICkge1xyXG5cclxuXHRcdFx0Ly8gV2FybmluZzogU2NhbGluZyB0aHJvdWdoIHRoZSBjYW52YXMgd2lsbCBvbmx5IHdvcmsgd2l0aCBpbWFnZXMgdGhhdCB1c2VcclxuXHRcdFx0Ly8gcHJlbXVsdGlwbGllZCBhbHBoYS5cclxuXHJcblx0XHRcdHZhciBzY2FsZSA9IG1heFNpemUgLyBNYXRoLm1heCggaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCApO1xyXG5cclxuXHRcdFx0dmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdjYW52YXMnICk7XHJcblx0XHRcdGNhbnZhcy53aWR0aCA9IE1hdGguZmxvb3IoIGltYWdlLndpZHRoICogc2NhbGUgKTtcclxuXHRcdFx0Y2FudmFzLmhlaWdodCA9IE1hdGguZmxvb3IoIGltYWdlLmhlaWdodCAqIHNjYWxlICk7XHJcblxyXG5cdFx0XHR2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCAnMmQnICk7XHJcblx0XHRcdGNvbnRleHQuZHJhd0ltYWdlKCBpbWFnZSwgMCwgMCwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCwgMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0ICk7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBpbWFnZSBpcyB0b28gYmlnICgnICsgaW1hZ2Uud2lkdGggKyAneCcgKyBpbWFnZS5oZWlnaHQgKyAnKS4gUmVzaXplZCB0byAnICsgY2FudmFzLndpZHRoICsgJ3gnICsgY2FudmFzLmhlaWdodCwgaW1hZ2UgKTtcclxuXHJcblx0XHRcdHJldHVybiBjYW52YXM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBpbWFnZTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBpc1Bvd2VyT2ZUd28oIGltYWdlICkge1xyXG5cclxuXHRcdHJldHVybiBUSFJFRS5NYXRoLmlzUG93ZXJPZlR3byggaW1hZ2Uud2lkdGggKSAmJiBUSFJFRS5NYXRoLmlzUG93ZXJPZlR3byggaW1hZ2UuaGVpZ2h0ICk7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gdGV4dHVyZU5lZWRzUG93ZXJPZlR3byggdGV4dHVyZSApIHtcclxuXHJcblx0XHRpZiAoIHRleHR1cmUud3JhcFMgIT09IFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmcgfHwgdGV4dHVyZS53cmFwVCAhPT0gVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZyApIHJldHVybiB0cnVlO1xyXG5cdFx0aWYgKCB0ZXh0dXJlLm1pbkZpbHRlciAhPT0gVEhSRUUuTmVhcmVzdEZpbHRlciAmJiB0ZXh0dXJlLm1pbkZpbHRlciAhPT0gVEhSRUUuTGluZWFyRmlsdGVyICkgcmV0dXJuIHRydWU7XHJcblxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIG1ha2VQb3dlck9mVHdvKCBpbWFnZSApIHtcclxuXHJcblx0XHRpZiAoIGltYWdlIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCB8fCBpbWFnZSBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50ICkge1xyXG5cclxuXHRcdFx0dmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdjYW52YXMnICk7XHJcblx0XHRcdGNhbnZhcy53aWR0aCA9IFRIUkVFLk1hdGgubmVhcmVzdFBvd2VyT2ZUd28oIGltYWdlLndpZHRoICk7XHJcblx0XHRcdGNhbnZhcy5oZWlnaHQgPSBUSFJFRS5NYXRoLm5lYXJlc3RQb3dlck9mVHdvKCBpbWFnZS5oZWlnaHQgKTtcclxuXHJcblx0XHRcdHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoICcyZCcgKTtcclxuXHRcdFx0Y29udGV4dC5kcmF3SW1hZ2UoIGltYWdlLCAwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQgKTtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IGltYWdlIGlzIG5vdCBwb3dlciBvZiB0d28gKCcgKyBpbWFnZS53aWR0aCArICd4JyArIGltYWdlLmhlaWdodCArICcpLiBSZXNpemVkIHRvICcgKyBjYW52YXMud2lkdGggKyAneCcgKyBjYW52YXMuaGVpZ2h0LCBpbWFnZSApO1xyXG5cclxuXHRcdFx0cmV0dXJuIGNhbnZhcztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGltYWdlO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHNldEN1YmVUZXh0dXJlICggdGV4dHVyZSwgc2xvdCApIHtcclxuXHJcblx0XHR2YXIgdGV4dHVyZVByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggdGV4dHVyZSApO1xyXG5cclxuXHRcdGlmICggdGV4dHVyZS5pbWFnZS5sZW5ndGggPT09IDYgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHRleHR1cmUudmVyc2lvbiA+IDAgJiYgdGV4dHVyZVByb3BlcnRpZXMuX192ZXJzaW9uICE9PSB0ZXh0dXJlLnZlcnNpb24gKSB7XHJcblxyXG5cdFx0XHRcdGlmICggISB0ZXh0dXJlUHJvcGVydGllcy5fX2ltYWdlX193ZWJnbFRleHR1cmVDdWJlICkge1xyXG5cclxuXHRcdFx0XHRcdHRleHR1cmUuYWRkRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvblRleHR1cmVEaXNwb3NlICk7XHJcblxyXG5cdFx0XHRcdFx0dGV4dHVyZVByb3BlcnRpZXMuX19pbWFnZV9fd2ViZ2xUZXh0dXJlQ3ViZSA9IF9nbC5jcmVhdGVUZXh0dXJlKCk7XHJcblxyXG5cdFx0XHRcdFx0X2luZm9NZW1vcnkudGV4dHVyZXMgKys7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0c3RhdGUuYWN0aXZlVGV4dHVyZSggX2dsLlRFWFRVUkUwICsgc2xvdCApO1xyXG5cdFx0XHRcdHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCwgdGV4dHVyZVByb3BlcnRpZXMuX19pbWFnZV9fd2ViZ2xUZXh0dXJlQ3ViZSApO1xyXG5cclxuXHRcdFx0XHRfZ2wucGl4ZWxTdG9yZWkoIF9nbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCB0ZXh0dXJlLmZsaXBZICk7XHJcblxyXG5cdFx0XHRcdHZhciBpc0NvbXByZXNzZWQgPSB0ZXh0dXJlIGluc3RhbmNlb2YgVEhSRUUuQ29tcHJlc3NlZFRleHR1cmU7XHJcblx0XHRcdFx0dmFyIGlzRGF0YVRleHR1cmUgPSB0ZXh0dXJlLmltYWdlWyAwIF0gaW5zdGFuY2VvZiBUSFJFRS5EYXRhVGV4dHVyZTtcclxuXHJcblx0XHRcdFx0dmFyIGN1YmVJbWFnZSA9IFtdO1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCA2OyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdGlmICggX3RoaXMuYXV0b1NjYWxlQ3ViZW1hcHMgJiYgISBpc0NvbXByZXNzZWQgJiYgISBpc0RhdGFUZXh0dXJlICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Y3ViZUltYWdlWyBpIF0gPSBjbGFtcFRvTWF4U2l6ZSggdGV4dHVyZS5pbWFnZVsgaSBdLCBjYXBhYmlsaXRpZXMubWF4Q3ViZW1hcFNpemUgKTtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0Y3ViZUltYWdlWyBpIF0gPSBpc0RhdGFUZXh0dXJlID8gdGV4dHVyZS5pbWFnZVsgaSBdLmltYWdlIDogdGV4dHVyZS5pbWFnZVsgaSBdO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR2YXIgaW1hZ2UgPSBjdWJlSW1hZ2VbIDAgXSxcclxuXHRcdFx0XHRpc1Bvd2VyT2ZUd29JbWFnZSA9IGlzUG93ZXJPZlR3byggaW1hZ2UgKSxcclxuXHRcdFx0XHRnbEZvcm1hdCA9IHBhcmFtVGhyZWVUb0dMKCB0ZXh0dXJlLmZvcm1hdCApLFxyXG5cdFx0XHRcdGdsVHlwZSA9IHBhcmFtVGhyZWVUb0dMKCB0ZXh0dXJlLnR5cGUgKTtcclxuXHJcblx0XHRcdFx0c2V0VGV4dHVyZVBhcmFtZXRlcnMoIF9nbC5URVhUVVJFX0NVQkVfTUFQLCB0ZXh0dXJlLCBpc1Bvd2VyT2ZUd29JbWFnZSApO1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCA2OyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdGlmICggISBpc0NvbXByZXNzZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIGlzRGF0YVRleHR1cmUgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpLCAwLCBnbEZvcm1hdCwgY3ViZUltYWdlWyBpIF0ud2lkdGgsIGN1YmVJbWFnZVsgaSBdLmhlaWdodCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgY3ViZUltYWdlWyBpIF0uZGF0YSApO1xyXG5cclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0c3RhdGUudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGksIDAsIGdsRm9ybWF0LCBnbEZvcm1hdCwgZ2xUeXBlLCBjdWJlSW1hZ2VbIGkgXSApO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHR2YXIgbWlwbWFwLCBtaXBtYXBzID0gY3ViZUltYWdlWyBpIF0ubWlwbWFwcztcclxuXHJcblx0XHRcdFx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSBtaXBtYXBzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRtaXBtYXAgPSBtaXBtYXBzWyBqIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdGlmICggdGV4dHVyZS5mb3JtYXQgIT09IFRIUkVFLlJHQkFGb3JtYXQgJiYgdGV4dHVyZS5mb3JtYXQgIT09IFRIUkVFLlJHQkZvcm1hdCApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRpZiAoIHN0YXRlLmdldENvbXByZXNzZWRUZXh0dXJlRm9ybWF0cygpLmluZGV4T2YoIGdsRm9ybWF0ICkgPiAtIDEgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XHRzdGF0ZS5jb21wcmVzc2VkVGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGksIGosIGdsRm9ybWF0LCBtaXBtYXAud2lkdGgsIG1pcG1hcC5oZWlnaHQsIDAsIG1pcG1hcC5kYXRhICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggXCJUSFJFRS5XZWJHTFJlbmRlcmVyOiBBdHRlbXB0IHRvIGxvYWQgdW5zdXBwb3J0ZWQgY29tcHJlc3NlZCB0ZXh0dXJlIGZvcm1hdCBpbiAuc2V0Q3ViZVRleHR1cmUoKVwiICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpLCBqLCBnbEZvcm1hdCwgbWlwbWFwLndpZHRoLCBtaXBtYXAuaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBtaXBtYXAuZGF0YSApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggdGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgJiYgaXNQb3dlck9mVHdvSW1hZ2UgKSB7XHJcblxyXG5cdFx0XHRcdFx0X2dsLmdlbmVyYXRlTWlwbWFwKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRleHR1cmVQcm9wZXJ0aWVzLl9fdmVyc2lvbiA9IHRleHR1cmUudmVyc2lvbjtcclxuXHJcblx0XHRcdFx0aWYgKCB0ZXh0dXJlLm9uVXBkYXRlICkgdGV4dHVyZS5vblVwZGF0ZSggdGV4dHVyZSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0c3RhdGUuYWN0aXZlVGV4dHVyZSggX2dsLlRFWFRVUkUwICsgc2xvdCApO1xyXG5cdFx0XHRcdHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCwgdGV4dHVyZVByb3BlcnRpZXMuX19pbWFnZV9fd2ViZ2xUZXh0dXJlQ3ViZSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBzZXRDdWJlVGV4dHVyZUR5bmFtaWMgKCB0ZXh0dXJlLCBzbG90ICkge1xyXG5cclxuXHRcdHN0YXRlLmFjdGl2ZVRleHR1cmUoIF9nbC5URVhUVVJFMCArIHNsb3QgKTtcclxuXHRcdHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCwgcHJvcGVydGllcy5nZXQoIHRleHR1cmUgKS5fX3dlYmdsVGV4dHVyZSApO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIFJlbmRlciB0YXJnZXRzXHJcblxyXG5cdC8vIFNldHVwIHN0b3JhZ2UgZm9yIHRhcmdldCB0ZXh0dXJlIGFuZCBiaW5kIGl0IHRvIGNvcnJlY3QgZnJhbWVidWZmZXJcclxuXHRmdW5jdGlvbiBzZXR1cEZyYW1lQnVmZmVyVGV4dHVyZSAoIGZyYW1lYnVmZmVyLCByZW5kZXJUYXJnZXQsIGF0dGFjaG1lbnQsIHRleHR1cmVUYXJnZXQgKSB7XHJcblxyXG5cdFx0dmFyIGdsRm9ybWF0ID0gcGFyYW1UaHJlZVRvR0woIHJlbmRlclRhcmdldC50ZXh0dXJlLmZvcm1hdCApO1xyXG5cdFx0dmFyIGdsVHlwZSA9IHBhcmFtVGhyZWVUb0dMKCByZW5kZXJUYXJnZXQudGV4dHVyZS50eXBlICk7XHJcblx0XHRzdGF0ZS50ZXhJbWFnZTJEKCB0ZXh0dXJlVGFyZ2V0LCAwLCBnbEZvcm1hdCwgcmVuZGVyVGFyZ2V0LndpZHRoLCByZW5kZXJUYXJnZXQuaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBudWxsICk7XHJcblx0XHRfZ2wuYmluZEZyYW1lYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyICk7XHJcblx0XHRfZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoIF9nbC5GUkFNRUJVRkZFUiwgYXR0YWNobWVudCwgdGV4dHVyZVRhcmdldCwgcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldC50ZXh0dXJlICkuX193ZWJnbFRleHR1cmUsIDAgKTtcclxuXHRcdF9nbC5iaW5kRnJhbWVidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgbnVsbCApO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIFNldHVwIHN0b3JhZ2UgZm9yIGludGVybmFsIGRlcHRoL3N0ZW5jaWwgYnVmZmVycyBhbmQgYmluZCB0byBjb3JyZWN0IGZyYW1lYnVmZmVyXHJcblx0ZnVuY3Rpb24gc2V0dXBSZW5kZXJCdWZmZXJTdG9yYWdlICggcmVuZGVyYnVmZmVyLCByZW5kZXJUYXJnZXQgKSB7XHJcblxyXG5cdFx0X2dsLmJpbmRSZW5kZXJidWZmZXIoIF9nbC5SRU5ERVJCVUZGRVIsIHJlbmRlcmJ1ZmZlciApO1xyXG5cclxuXHRcdGlmICggcmVuZGVyVGFyZ2V0LmRlcHRoQnVmZmVyICYmICEgcmVuZGVyVGFyZ2V0LnN0ZW5jaWxCdWZmZXIgKSB7XHJcblxyXG5cdFx0XHRfZ2wucmVuZGVyYnVmZmVyU3RvcmFnZSggX2dsLlJFTkRFUkJVRkZFUiwgX2dsLkRFUFRIX0NPTVBPTkVOVDE2LCByZW5kZXJUYXJnZXQud2lkdGgsIHJlbmRlclRhcmdldC5oZWlnaHQgKTtcclxuXHRcdFx0X2dsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIF9nbC5ERVBUSF9BVFRBQ0hNRU5ULCBfZ2wuUkVOREVSQlVGRkVSLCByZW5kZXJidWZmZXIgKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCByZW5kZXJUYXJnZXQuZGVwdGhCdWZmZXIgJiYgcmVuZGVyVGFyZ2V0LnN0ZW5jaWxCdWZmZXIgKSB7XHJcblxyXG5cdFx0XHRfZ2wucmVuZGVyYnVmZmVyU3RvcmFnZSggX2dsLlJFTkRFUkJVRkZFUiwgX2dsLkRFUFRIX1NURU5DSUwsIHJlbmRlclRhcmdldC53aWR0aCwgcmVuZGVyVGFyZ2V0LmhlaWdodCApO1xyXG5cdFx0XHRfZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgX2dsLkRFUFRIX1NURU5DSUxfQVRUQUNITUVOVCwgX2dsLlJFTkRFUkJVRkZFUiwgcmVuZGVyYnVmZmVyICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdC8vIEZJWE1FOiBXZSBkb24ndCBzdXBwb3J0ICFkZXB0aCAhc3RlbmNpbFxyXG5cdFx0XHRfZ2wucmVuZGVyYnVmZmVyU3RvcmFnZSggX2dsLlJFTkRFUkJVRkZFUiwgX2dsLlJHQkE0LCByZW5kZXJUYXJnZXQud2lkdGgsIHJlbmRlclRhcmdldC5oZWlnaHQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0X2dsLmJpbmRSZW5kZXJidWZmZXIoIF9nbC5SRU5ERVJCVUZGRVIsIG51bGwgKTtcclxuXHJcblx0fVxyXG5cclxuXHQvLyBTZXR1cCBHTCByZXNvdXJjZXMgZm9yIGEgbm9uLXRleHR1cmUgZGVwdGggYnVmZmVyXHJcblx0ZnVuY3Rpb24gc2V0dXBEZXB0aFJlbmRlcmJ1ZmZlciggcmVuZGVyVGFyZ2V0ICkge1xyXG5cclxuXHRcdHZhciByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldCApO1xyXG5cclxuXHRcdHZhciBpc0N1YmUgPSAoIHJlbmRlclRhcmdldCBpbnN0YW5jZW9mIFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZSApO1xyXG5cclxuXHRcdGlmICggaXNDdWJlICkge1xyXG5cclxuXHRcdFx0cmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRGVwdGhidWZmZXIgPSBbXTtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IDY7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdF9nbC5iaW5kRnJhbWVidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXJbIGkgXSApO1xyXG5cdFx0XHRcdHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbERlcHRoYnVmZmVyWyBpIF0gPSBfZ2wuY3JlYXRlUmVuZGVyYnVmZmVyKCk7XHJcblx0XHRcdFx0c2V0dXBSZW5kZXJCdWZmZXJTdG9yYWdlKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xEZXB0aGJ1ZmZlclsgaSBdLCByZW5kZXJUYXJnZXQgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0X2dsLmJpbmRGcmFtZWJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlciApO1xyXG5cdFx0XHRyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xEZXB0aGJ1ZmZlciA9IF9nbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcclxuXHRcdFx0c2V0dXBSZW5kZXJCdWZmZXJTdG9yYWdlKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xEZXB0aGJ1ZmZlciwgcmVuZGVyVGFyZ2V0ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdF9nbC5iaW5kRnJhbWVidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgbnVsbCApO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIFNldCB1cCBHTCByZXNvdXJjZXMgZm9yIHRoZSByZW5kZXIgdGFyZ2V0XHJcblx0ZnVuY3Rpb24gc2V0dXBSZW5kZXJUYXJnZXQoIHJlbmRlclRhcmdldCApIHtcclxuXHJcblx0XHR2YXIgcmVuZGVyVGFyZ2V0UHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQgKTtcclxuXHRcdHZhciB0ZXh0dXJlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQudGV4dHVyZSApO1xyXG5cclxuXHRcdHJlbmRlclRhcmdldC5hZGRFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uUmVuZGVyVGFyZ2V0RGlzcG9zZSApO1xyXG5cclxuXHRcdHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlID0gX2dsLmNyZWF0ZVRleHR1cmUoKTtcclxuXHJcblx0XHRfaW5mb01lbW9yeS50ZXh0dXJlcyArKztcclxuXHJcblx0XHR2YXIgaXNDdWJlID0gKCByZW5kZXJUYXJnZXQgaW5zdGFuY2VvZiBUSFJFRS5XZWJHTFJlbmRlclRhcmdldEN1YmUgKTtcclxuXHRcdHZhciBpc1RhcmdldFBvd2VyT2ZUd28gPSBUSFJFRS5NYXRoLmlzUG93ZXJPZlR3byggcmVuZGVyVGFyZ2V0LndpZHRoICkgJiYgVEhSRUUuTWF0aC5pc1Bvd2VyT2ZUd28oIHJlbmRlclRhcmdldC5oZWlnaHQgKTtcclxuXHJcblx0XHQvLyBTZXR1cCBmcmFtZWJ1ZmZlclxyXG5cclxuXHRcdGlmICggaXNDdWJlICkge1xyXG5cclxuXHRcdFx0cmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXIgPSBbXTtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IDY7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyWyBpIF0gPSBfZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0cmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXIgPSBfZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gU2V0dXAgY29sb3IgYnVmZmVyXHJcblxyXG5cdFx0aWYgKCBpc0N1YmUgKSB7XHJcblxyXG5cdFx0XHRzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlICk7XHJcblx0XHRcdHNldFRleHR1cmVQYXJhbWV0ZXJzKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCwgcmVuZGVyVGFyZ2V0LnRleHR1cmUsIGlzVGFyZ2V0UG93ZXJPZlR3byApO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgNjsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0c2V0dXBGcmFtZUJ1ZmZlclRleHR1cmUoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyWyBpIF0sIHJlbmRlclRhcmdldCwgX2dsLkNPTE9SX0FUVEFDSE1FTlQwLCBfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCByZW5kZXJUYXJnZXQudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgJiYgaXNUYXJnZXRQb3dlck9mVHdvICkgX2dsLmdlbmVyYXRlTWlwbWFwKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCApO1xyXG5cdFx0XHRzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIG51bGwgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0c3RhdGUuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFXzJELCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSApO1xyXG5cdFx0XHRzZXRUZXh0dXJlUGFyYW1ldGVycyggX2dsLlRFWFRVUkVfMkQsIHJlbmRlclRhcmdldC50ZXh0dXJlLCBpc1RhcmdldFBvd2VyT2ZUd28gKTtcclxuXHRcdFx0c2V0dXBGcmFtZUJ1ZmZlclRleHR1cmUoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyLCByZW5kZXJUYXJnZXQsIF9nbC5DT0xPUl9BVFRBQ0hNRU5UMCwgX2dsLlRFWFRVUkVfMkQgKTtcclxuXHJcblx0XHRcdGlmICggcmVuZGVyVGFyZ2V0LnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzICYmIGlzVGFyZ2V0UG93ZXJPZlR3byApIF9nbC5nZW5lcmF0ZU1pcG1hcCggX2dsLlRFWFRVUkVfMkQgKTtcclxuXHRcdFx0c3RhdGUuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFXzJELCBudWxsICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFNldHVwIGRlcHRoIGFuZCBzdGVuY2lsIGJ1ZmZlcnNcclxuXHJcblx0XHRpZiAoIHJlbmRlclRhcmdldC5kZXB0aEJ1ZmZlciApIHtcclxuXHJcblx0XHRcdHNldHVwRGVwdGhSZW5kZXJidWZmZXIoIHJlbmRlclRhcmdldCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHR0aGlzLnNldFJlbmRlclRhcmdldCA9IGZ1bmN0aW9uICggcmVuZGVyVGFyZ2V0ICkge1xyXG5cclxuXHRcdF9jdXJyZW50UmVuZGVyVGFyZ2V0ID0gcmVuZGVyVGFyZ2V0O1xyXG5cclxuXHRcdGlmICggcmVuZGVyVGFyZ2V0ICYmIHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQgKS5fX3dlYmdsRnJhbWVidWZmZXIgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHNldHVwUmVuZGVyVGFyZ2V0KCByZW5kZXJUYXJnZXQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGlzQ3ViZSA9ICggcmVuZGVyVGFyZ2V0IGluc3RhbmNlb2YgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXRDdWJlICk7XHJcblx0XHR2YXIgZnJhbWVidWZmZXI7XHJcblxyXG5cdFx0aWYgKCByZW5kZXJUYXJnZXQgKSB7XHJcblxyXG5cdFx0XHR2YXIgcmVuZGVyVGFyZ2V0UHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQgKTtcclxuXHJcblx0XHRcdGlmICggaXNDdWJlICkge1xyXG5cclxuXHRcdFx0XHRmcmFtZWJ1ZmZlciA9IHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyWyByZW5kZXJUYXJnZXQuYWN0aXZlQ3ViZUZhY2UgXTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGZyYW1lYnVmZmVyID0gcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXI7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRfY3VycmVudFNjaXNzb3IuY29weSggcmVuZGVyVGFyZ2V0LnNjaXNzb3IgKTtcclxuXHRcdFx0X2N1cnJlbnRTY2lzc29yVGVzdCA9IHJlbmRlclRhcmdldC5zY2lzc29yVGVzdDtcclxuXHJcblx0XHRcdF9jdXJyZW50Vmlld3BvcnQuY29weSggcmVuZGVyVGFyZ2V0LnZpZXdwb3J0ICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdGZyYW1lYnVmZmVyID0gbnVsbDtcclxuXHJcblx0XHRcdF9jdXJyZW50U2Npc3Nvci5jb3B5KCBfc2Npc3NvciApLm11bHRpcGx5U2NhbGFyKCBfcGl4ZWxSYXRpbyApO1xyXG5cdFx0XHRfY3VycmVudFNjaXNzb3JUZXN0ID0gX3NjaXNzb3JUZXN0O1xyXG5cclxuXHRcdFx0X2N1cnJlbnRWaWV3cG9ydC5jb3B5KCBfdmlld3BvcnQgKS5tdWx0aXBseVNjYWxhciggX3BpeGVsUmF0aW8gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBfY3VycmVudEZyYW1lYnVmZmVyICE9PSBmcmFtZWJ1ZmZlciApIHtcclxuXHJcblx0XHRcdF9nbC5iaW5kRnJhbWVidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgZnJhbWVidWZmZXIgKTtcclxuXHRcdFx0X2N1cnJlbnRGcmFtZWJ1ZmZlciA9IGZyYW1lYnVmZmVyO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRzdGF0ZS5zY2lzc29yKCBfY3VycmVudFNjaXNzb3IgKTtcclxuXHRcdHN0YXRlLnNldFNjaXNzb3JUZXN0KCBfY3VycmVudFNjaXNzb3JUZXN0ICk7XHJcblxyXG5cdFx0c3RhdGUudmlld3BvcnQoIF9jdXJyZW50Vmlld3BvcnQgKTtcclxuXHJcblx0XHRpZiAoIGlzQ3ViZSApIHtcclxuXHJcblx0XHRcdHZhciB0ZXh0dXJlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQudGV4dHVyZSApO1xyXG5cdFx0XHRfZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoIF9nbC5GUkFNRUJVRkZFUiwgX2dsLkNPTE9SX0FUVEFDSE1FTlQwLCBfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgcmVuZGVyVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlLCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSwgMCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5yZWFkUmVuZGVyVGFyZ2V0UGl4ZWxzID0gZnVuY3Rpb24gKCByZW5kZXJUYXJnZXQsIHgsIHksIHdpZHRoLCBoZWlnaHQsIGJ1ZmZlciApIHtcclxuXHJcblx0XHRpZiAoIHJlbmRlclRhcmdldCBpbnN0YW5jZW9mIFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0ID09PSBmYWxzZSApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFJlbmRlcmVyLnJlYWRSZW5kZXJUYXJnZXRQaXhlbHM6IHJlbmRlclRhcmdldCBpcyBub3QgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQuJyApO1xyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBmcmFtZWJ1ZmZlciA9IHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQgKS5fX3dlYmdsRnJhbWVidWZmZXI7XHJcblxyXG5cdFx0aWYgKCBmcmFtZWJ1ZmZlciApIHtcclxuXHJcblx0XHRcdHZhciByZXN0b3JlID0gZmFsc2U7XHJcblxyXG5cdFx0XHRpZiAoIGZyYW1lYnVmZmVyICE9PSBfY3VycmVudEZyYW1lYnVmZmVyICkge1xyXG5cclxuXHRcdFx0XHRfZ2wuYmluZEZyYW1lYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyICk7XHJcblxyXG5cdFx0XHRcdHJlc3RvcmUgPSB0cnVlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dHJ5IHtcclxuXHJcblx0XHRcdFx0dmFyIHRleHR1cmUgPSByZW5kZXJUYXJnZXQudGV4dHVyZTtcclxuXHJcblx0XHRcdFx0aWYgKCB0ZXh0dXJlLmZvcm1hdCAhPT0gVEhSRUUuUkdCQUZvcm1hdFxyXG5cdFx0XHRcdFx0JiYgcGFyYW1UaHJlZVRvR0woIHRleHR1cmUuZm9ybWF0ICkgIT09IF9nbC5nZXRQYXJhbWV0ZXIoIF9nbC5JTVBMRU1FTlRBVElPTl9DT0xPUl9SRUFEX0ZPUk1BVCApICkge1xyXG5cclxuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFJlbmRlcmVyLnJlYWRSZW5kZXJUYXJnZXRQaXhlbHM6IHJlbmRlclRhcmdldCBpcyBub3QgaW4gUkdCQSBvciBpbXBsZW1lbnRhdGlvbiBkZWZpbmVkIGZvcm1hdC4nICk7XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCB0ZXh0dXJlLnR5cGUgIT09IFRIUkVFLlVuc2lnbmVkQnl0ZVR5cGVcclxuXHRcdFx0XHRcdCYmIHBhcmFtVGhyZWVUb0dMKCB0ZXh0dXJlLnR5cGUgKSAhPT0gX2dsLmdldFBhcmFtZXRlciggX2dsLklNUExFTUVOVEFUSU9OX0NPTE9SX1JFQURfVFlQRSApXHJcblx0XHRcdFx0XHQmJiAhICggdGV4dHVyZS50eXBlID09PSBUSFJFRS5GbG9hdFR5cGUgJiYgZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb2xvcl9idWZmZXJfZmxvYXQnICkgKVxyXG5cdFx0XHRcdFx0JiYgISAoIHRleHR1cmUudHlwZSA9PT0gVEhSRUUuSGFsZkZsb2F0VHlwZSAmJiBleHRlbnNpb25zLmdldCggJ0VYVF9jb2xvcl9idWZmZXJfaGFsZl9mbG9hdCcgKSApICkge1xyXG5cclxuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFJlbmRlcmVyLnJlYWRSZW5kZXJUYXJnZXRQaXhlbHM6IHJlbmRlclRhcmdldCBpcyBub3QgaW4gVW5zaWduZWRCeXRlVHlwZSBvciBpbXBsZW1lbnRhdGlvbiBkZWZpbmVkIHR5cGUuJyApO1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggX2dsLmNoZWNrRnJhbWVidWZmZXJTdGF0dXMoIF9nbC5GUkFNRUJVRkZFUiApID09PSBfZ2wuRlJBTUVCVUZGRVJfQ09NUExFVEUgKSB7XHJcblxyXG5cdFx0XHRcdFx0X2dsLnJlYWRQaXhlbHMoIHgsIHksIHdpZHRoLCBoZWlnaHQsIHBhcmFtVGhyZWVUb0dMKCB0ZXh0dXJlLmZvcm1hdCApLCBwYXJhbVRocmVlVG9HTCggdGV4dHVyZS50eXBlICksIGJ1ZmZlciApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFJlbmRlcmVyLnJlYWRSZW5kZXJUYXJnZXRQaXhlbHM6IHJlYWRQaXhlbHMgZnJvbSByZW5kZXJUYXJnZXQgZmFpbGVkLiBGcmFtZWJ1ZmZlciBub3QgY29tcGxldGUuJyApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGZpbmFsbHkge1xyXG5cclxuXHRcdFx0XHRpZiAoIHJlc3RvcmUgKSB7XHJcblxyXG5cdFx0XHRcdFx0X2dsLmJpbmRGcmFtZWJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBfY3VycmVudEZyYW1lYnVmZmVyICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIHVwZGF0ZVJlbmRlclRhcmdldE1pcG1hcCggcmVuZGVyVGFyZ2V0ICkge1xyXG5cclxuXHRcdHZhciB0YXJnZXQgPSByZW5kZXJUYXJnZXQgaW5zdGFuY2VvZiBUSFJFRS5XZWJHTFJlbmRlclRhcmdldEN1YmUgPyBfZ2wuVEVYVFVSRV9DVUJFX01BUCA6IF9nbC5URVhUVVJFXzJEO1xyXG5cdFx0dmFyIHRleHR1cmUgPSBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0LnRleHR1cmUgKS5fX3dlYmdsVGV4dHVyZTtcclxuXHJcblx0XHRzdGF0ZS5iaW5kVGV4dHVyZSggdGFyZ2V0LCB0ZXh0dXJlICk7XHJcblx0XHRfZ2wuZ2VuZXJhdGVNaXBtYXAoIHRhcmdldCApO1xyXG5cdFx0c3RhdGUuYmluZFRleHR1cmUoIHRhcmdldCwgbnVsbCApO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIEZhbGxiYWNrIGZpbHRlcnMgZm9yIG5vbi1wb3dlci1vZi0yIHRleHR1cmVzXHJcblxyXG5cdGZ1bmN0aW9uIGZpbHRlckZhbGxiYWNrICggZiApIHtcclxuXHJcblx0XHRpZiAoIGYgPT09IFRIUkVFLk5lYXJlc3RGaWx0ZXIgfHwgZiA9PT0gVEhSRUUuTmVhcmVzdE1pcE1hcE5lYXJlc3RGaWx0ZXIgfHwgZiA9PT0gVEhSRUUuTmVhcmVzdE1pcE1hcExpbmVhckZpbHRlciApIHtcclxuXHJcblx0XHRcdHJldHVybiBfZ2wuTkVBUkVTVDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIF9nbC5MSU5FQVI7XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gTWFwIHRocmVlLmpzIGNvbnN0YW50cyB0byBXZWJHTCBjb25zdGFudHNcclxuXHJcblx0ZnVuY3Rpb24gcGFyYW1UaHJlZVRvR0wgKCBwICkge1xyXG5cclxuXHRcdHZhciBleHRlbnNpb247XHJcblxyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5SZXBlYXRXcmFwcGluZyApIHJldHVybiBfZ2wuUkVQRUFUO1xyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5DbGFtcFRvRWRnZVdyYXBwaW5nICkgcmV0dXJuIF9nbC5DTEFNUF9UT19FREdFO1xyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5NaXJyb3JlZFJlcGVhdFdyYXBwaW5nICkgcmV0dXJuIF9nbC5NSVJST1JFRF9SRVBFQVQ7XHJcblxyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5OZWFyZXN0RmlsdGVyICkgcmV0dXJuIF9nbC5ORUFSRVNUO1xyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5OZWFyZXN0TWlwTWFwTmVhcmVzdEZpbHRlciApIHJldHVybiBfZ2wuTkVBUkVTVF9NSVBNQVBfTkVBUkVTVDtcclxuXHRcdGlmICggcCA9PT0gVEhSRUUuTmVhcmVzdE1pcE1hcExpbmVhckZpbHRlciApIHJldHVybiBfZ2wuTkVBUkVTVF9NSVBNQVBfTElORUFSO1xyXG5cclxuXHRcdGlmICggcCA9PT0gVEhSRUUuTGluZWFyRmlsdGVyICkgcmV0dXJuIF9nbC5MSU5FQVI7XHJcblx0XHRpZiAoIHAgPT09IFRIUkVFLkxpbmVhck1pcE1hcE5lYXJlc3RGaWx0ZXIgKSByZXR1cm4gX2dsLkxJTkVBUl9NSVBNQVBfTkVBUkVTVDtcclxuXHRcdGlmICggcCA9PT0gVEhSRUUuTGluZWFyTWlwTWFwTGluZWFyRmlsdGVyICkgcmV0dXJuIF9nbC5MSU5FQVJfTUlQTUFQX0xJTkVBUjtcclxuXHJcblx0XHRpZiAoIHAgPT09IFRIUkVFLlVuc2lnbmVkQnl0ZVR5cGUgKSByZXR1cm4gX2dsLlVOU0lHTkVEX0JZVEU7XHJcblx0XHRpZiAoIHAgPT09IFRIUkVFLlVuc2lnbmVkU2hvcnQ0NDQ0VHlwZSApIHJldHVybiBfZ2wuVU5TSUdORURfU0hPUlRfNF80XzRfNDtcclxuXHRcdGlmICggcCA9PT0gVEhSRUUuVW5zaWduZWRTaG9ydDU1NTFUeXBlICkgcmV0dXJuIF9nbC5VTlNJR05FRF9TSE9SVF81XzVfNV8xO1xyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5VbnNpZ25lZFNob3J0NTY1VHlwZSApIHJldHVybiBfZ2wuVU5TSUdORURfU0hPUlRfNV82XzU7XHJcblxyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5CeXRlVHlwZSApIHJldHVybiBfZ2wuQllURTtcclxuXHRcdGlmICggcCA9PT0gVEhSRUUuU2hvcnRUeXBlICkgcmV0dXJuIF9nbC5TSE9SVDtcclxuXHRcdGlmICggcCA9PT0gVEhSRUUuVW5zaWduZWRTaG9ydFR5cGUgKSByZXR1cm4gX2dsLlVOU0lHTkVEX1NIT1JUO1xyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5JbnRUeXBlICkgcmV0dXJuIF9nbC5JTlQ7XHJcblx0XHRpZiAoIHAgPT09IFRIUkVFLlVuc2lnbmVkSW50VHlwZSApIHJldHVybiBfZ2wuVU5TSUdORURfSU5UO1xyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5GbG9hdFR5cGUgKSByZXR1cm4gX2dsLkZMT0FUO1xyXG5cclxuXHRcdGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3RleHR1cmVfaGFsZl9mbG9hdCcgKTtcclxuXHJcblx0XHRpZiAoIGV4dGVuc2lvbiAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdGlmICggcCA9PT0gVEhSRUUuSGFsZkZsb2F0VHlwZSApIHJldHVybiBleHRlbnNpb24uSEFMRl9GTE9BVF9PRVM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggcCA9PT0gVEhSRUUuQWxwaGFGb3JtYXQgKSByZXR1cm4gX2dsLkFMUEhBO1xyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5SR0JGb3JtYXQgKSByZXR1cm4gX2dsLlJHQjtcclxuXHRcdGlmICggcCA9PT0gVEhSRUUuUkdCQUZvcm1hdCApIHJldHVybiBfZ2wuUkdCQTtcclxuXHRcdGlmICggcCA9PT0gVEhSRUUuTHVtaW5hbmNlRm9ybWF0ICkgcmV0dXJuIF9nbC5MVU1JTkFOQ0U7XHJcblx0XHRpZiAoIHAgPT09IFRIUkVFLkx1bWluYW5jZUFscGhhRm9ybWF0ICkgcmV0dXJuIF9nbC5MVU1JTkFOQ0VfQUxQSEE7XHJcblxyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5BZGRFcXVhdGlvbiApIHJldHVybiBfZ2wuRlVOQ19BREQ7XHJcblx0XHRpZiAoIHAgPT09IFRIUkVFLlN1YnRyYWN0RXF1YXRpb24gKSByZXR1cm4gX2dsLkZVTkNfU1VCVFJBQ1Q7XHJcblx0XHRpZiAoIHAgPT09IFRIUkVFLlJldmVyc2VTdWJ0cmFjdEVxdWF0aW9uICkgcmV0dXJuIF9nbC5GVU5DX1JFVkVSU0VfU1VCVFJBQ1Q7XHJcblxyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5aZXJvRmFjdG9yICkgcmV0dXJuIF9nbC5aRVJPO1xyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5PbmVGYWN0b3IgKSByZXR1cm4gX2dsLk9ORTtcclxuXHRcdGlmICggcCA9PT0gVEhSRUUuU3JjQ29sb3JGYWN0b3IgKSByZXR1cm4gX2dsLlNSQ19DT0xPUjtcclxuXHRcdGlmICggcCA9PT0gVEhSRUUuT25lTWludXNTcmNDb2xvckZhY3RvciApIHJldHVybiBfZ2wuT05FX01JTlVTX1NSQ19DT0xPUjtcclxuXHRcdGlmICggcCA9PT0gVEhSRUUuU3JjQWxwaGFGYWN0b3IgKSByZXR1cm4gX2dsLlNSQ19BTFBIQTtcclxuXHRcdGlmICggcCA9PT0gVEhSRUUuT25lTWludXNTcmNBbHBoYUZhY3RvciApIHJldHVybiBfZ2wuT05FX01JTlVTX1NSQ19BTFBIQTtcclxuXHRcdGlmICggcCA9PT0gVEhSRUUuRHN0QWxwaGFGYWN0b3IgKSByZXR1cm4gX2dsLkRTVF9BTFBIQTtcclxuXHRcdGlmICggcCA9PT0gVEhSRUUuT25lTWludXNEc3RBbHBoYUZhY3RvciApIHJldHVybiBfZ2wuT05FX01JTlVTX0RTVF9BTFBIQTtcclxuXHJcblx0XHRpZiAoIHAgPT09IFRIUkVFLkRzdENvbG9yRmFjdG9yICkgcmV0dXJuIF9nbC5EU1RfQ09MT1I7XHJcblx0XHRpZiAoIHAgPT09IFRIUkVFLk9uZU1pbnVzRHN0Q29sb3JGYWN0b3IgKSByZXR1cm4gX2dsLk9ORV9NSU5VU19EU1RfQ09MT1I7XHJcblx0XHRpZiAoIHAgPT09IFRIUkVFLlNyY0FscGhhU2F0dXJhdGVGYWN0b3IgKSByZXR1cm4gX2dsLlNSQ19BTFBIQV9TQVRVUkFURTtcclxuXHJcblx0XHRleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJyApO1xyXG5cclxuXHRcdGlmICggZXh0ZW5zaW9uICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0aWYgKCBwID09PSBUSFJFRS5SR0JfUzNUQ19EWFQxX0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JfUzNUQ19EWFQxX0VYVDtcclxuXHRcdFx0aWYgKCBwID09PSBUSFJFRS5SR0JBX1MzVENfRFhUMV9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDFfRVhUO1xyXG5cdFx0XHRpZiAoIHAgPT09IFRIUkVFLlJHQkFfUzNUQ19EWFQzX0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUM19FWFQ7XHJcblx0XHRcdGlmICggcCA9PT0gVEhSRUUuUkdCQV9TM1RDX0RYVDVfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQ1X0VYVDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMnICk7XHJcblxyXG5cdFx0aWYgKCBleHRlbnNpb24gIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHAgPT09IFRIUkVFLlJHQl9QVlJUQ180QlBQVjFfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQl9QVlJUQ180QlBQVjFfSU1HO1xyXG5cdFx0XHRpZiAoIHAgPT09IFRIUkVFLlJHQl9QVlJUQ18yQlBQVjFfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQl9QVlJUQ18yQlBQVjFfSU1HO1xyXG5cdFx0XHRpZiAoIHAgPT09IFRIUkVFLlJHQkFfUFZSVENfNEJQUFYxX0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX1BWUlRDXzRCUFBWMV9JTUc7XHJcblx0XHRcdGlmICggcCA9PT0gVEhSRUUuUkdCQV9QVlJUQ18yQlBQVjFfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfUFZSVENfMkJQUFYxX0lNRztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfZXRjMScgKTtcclxuXHJcblx0XHRpZiAoIGV4dGVuc2lvbiAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdGlmICggcCA9PT0gVEhSRUUuUkdCX0VUQzFfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQl9FVEMxX1dFQkdMO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ0VYVF9ibGVuZF9taW5tYXgnICk7XHJcblxyXG5cdFx0aWYgKCBleHRlbnNpb24gIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHAgPT09IFRIUkVFLk1pbkVxdWF0aW9uICkgcmV0dXJuIGV4dGVuc2lvbi5NSU5fRVhUO1xyXG5cdFx0XHRpZiAoIHAgPT09IFRIUkVFLk1heEVxdWF0aW9uICkgcmV0dXJuIGV4dGVuc2lvbi5NQVhfRVhUO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gMDtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9XZWJHTFJlbmRlclRhcmdldC5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3Igc3ppbWVrIC8gaHR0cHM6Ly9naXRodWIuY29tL3N6aW1lay9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICogQGF1dGhvciBNYXJpdXMgS2ludGVsIC8gaHR0cHM6Ly9naXRodWIuY29tL2tpbnRlbFxyXG4gKi9cclxuXHJcbi8qXHJcbiBJbiBvcHRpb25zLCB3ZSBjYW4gc3BlY2lmeTpcclxuICogVGV4dHVyZSBwYXJhbWV0ZXJzIGZvciBhbiBhdXRvLWdlbmVyYXRlZCB0YXJnZXQgdGV4dHVyZVxyXG4gKiBkZXB0aEJ1ZmZlci9zdGVuY2lsQnVmZmVyOiBCb29sZWFucyB0byBpbmRpY2F0ZSBpZiB3ZSBzaG91bGQgZ2VuZXJhdGUgdGhlc2UgYnVmZmVyc1xyXG4qL1xyXG5USFJFRS5XZWJHTFJlbmRlclRhcmdldCA9IGZ1bmN0aW9uICggd2lkdGgsIGhlaWdodCwgb3B0aW9ucyApIHtcclxuXHJcblx0dGhpcy51dWlkID0gVEhSRUUuTWF0aC5nZW5lcmF0ZVVVSUQoKTtcclxuXHJcblx0dGhpcy53aWR0aCA9IHdpZHRoO1xyXG5cdHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG5cclxuXHR0aGlzLnNjaXNzb3IgPSBuZXcgVEhSRUUuVmVjdG9yNCggMCwgMCwgd2lkdGgsIGhlaWdodCApO1xyXG5cdHRoaXMuc2Npc3NvclRlc3QgPSBmYWxzZTtcclxuXHJcblx0dGhpcy52aWV3cG9ydCA9IG5ldyBUSFJFRS5WZWN0b3I0KCAwLCAwLCB3aWR0aCwgaGVpZ2h0ICk7XHJcblxyXG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuXHRpZiAoIG9wdGlvbnMubWluRmlsdGVyID09PSB1bmRlZmluZWQgKSBvcHRpb25zLm1pbkZpbHRlciA9IFRIUkVFLkxpbmVhckZpbHRlcjtcclxuXHJcblx0dGhpcy50ZXh0dXJlID0gbmV3IFRIUkVFLlRleHR1cmUoIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBvcHRpb25zLndyYXBTLCBvcHRpb25zLndyYXBULCBvcHRpb25zLm1hZ0ZpbHRlciwgb3B0aW9ucy5taW5GaWx0ZXIsIG9wdGlvbnMuZm9ybWF0LCBvcHRpb25zLnR5cGUsIG9wdGlvbnMuYW5pc290cm9weSApO1xyXG5cclxuXHR0aGlzLmRlcHRoQnVmZmVyID0gb3B0aW9ucy5kZXB0aEJ1ZmZlciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kZXB0aEJ1ZmZlciA6IHRydWU7XHJcblx0dGhpcy5zdGVuY2lsQnVmZmVyID0gb3B0aW9ucy5zdGVuY2lsQnVmZmVyICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnN0ZW5jaWxCdWZmZXIgOiB0cnVlO1xyXG5cclxufTtcclxuXHJcblRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0LnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0LFxyXG5cclxuXHRzZXRTaXplOiBmdW5jdGlvbiAoIHdpZHRoLCBoZWlnaHQgKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLndpZHRoICE9PSB3aWR0aCB8fCB0aGlzLmhlaWdodCAhPT0gaGVpZ2h0ICkge1xyXG5cclxuXHRcdFx0dGhpcy53aWR0aCA9IHdpZHRoO1xyXG5cdFx0XHR0aGlzLmhlaWdodCA9IGhlaWdodDtcclxuXHJcblx0XHRcdHRoaXMuZGlzcG9zZSgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnZpZXdwb3J0LnNldCggMCwgMCwgd2lkdGgsIGhlaWdodCApO1xyXG5cdFx0dGhpcy5zY2lzc29yLnNldCggMCwgMCwgd2lkdGgsIGhlaWdodCApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG5cdFx0dGhpcy53aWR0aCA9IHNvdXJjZS53aWR0aDtcclxuXHRcdHRoaXMuaGVpZ2h0ID0gc291cmNlLmhlaWdodDtcclxuXHJcblx0XHR0aGlzLnZpZXdwb3J0LmNvcHkoIHNvdXJjZS52aWV3cG9ydCApO1xyXG5cclxuXHRcdHRoaXMudGV4dHVyZSA9IHNvdXJjZS50ZXh0dXJlLmNsb25lKCk7XHJcblxyXG5cdFx0dGhpcy5kZXB0aEJ1ZmZlciA9IHNvdXJjZS5kZXB0aEJ1ZmZlcjtcclxuXHRcdHRoaXMuc3RlbmNpbEJ1ZmZlciA9IHNvdXJjZS5zdGVuY2lsQnVmZmVyO1xyXG5cclxuXHRcdHRoaXMuc2hhcmVEZXB0aEZyb20gPSBzb3VyY2Uuc2hhcmVEZXB0aEZyb207XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2Rpc3Bvc2UnIH0gKTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcblRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuYXBwbHkoIFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0LnByb3RvdHlwZSApO1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL1dlYkdMUmVuZGVyVGFyZ2V0Q3ViZS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb21cclxuICovXHJcblxyXG5USFJFRS5XZWJHTFJlbmRlclRhcmdldEN1YmUgPSBmdW5jdGlvbiAoIHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMgKSB7XHJcblxyXG5cdFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0LmNhbGwoIHRoaXMsIHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMgKTtcclxuXHJcblx0dGhpcy5hY3RpdmVDdWJlRmFjZSA9IDA7IC8vIFBYIDAsIE5YIDEsIFBZIDIsIE5ZIDMsIFBaIDQsIE5aIDVcclxuXHJcbn07XHJcblxyXG5USFJFRS5XZWJHTFJlbmRlclRhcmdldEN1YmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQucHJvdG90eXBlICk7XHJcblRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5XZWJHTFJlbmRlclRhcmdldEN1YmU7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xCdWZmZXJSZW5kZXJlci5qc1xyXG5cclxuLyoqXHJcbiogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuKi9cclxuXHJcblRIUkVFLldlYkdMQnVmZmVyUmVuZGVyZXIgPSBmdW5jdGlvbiAoIF9nbCwgZXh0ZW5zaW9ucywgX2luZm9SZW5kZXIgKSB7XHJcblxyXG5cdHZhciBtb2RlO1xyXG5cclxuXHRmdW5jdGlvbiBzZXRNb2RlKCB2YWx1ZSApIHtcclxuXHJcblx0XHRtb2RlID0gdmFsdWU7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gcmVuZGVyKCBzdGFydCwgY291bnQgKSB7XHJcblxyXG5cdFx0X2dsLmRyYXdBcnJheXMoIG1vZGUsIHN0YXJ0LCBjb3VudCApO1xyXG5cclxuXHRcdF9pbmZvUmVuZGVyLmNhbGxzICsrO1xyXG5cdFx0X2luZm9SZW5kZXIudmVydGljZXMgKz0gY291bnQ7XHJcblx0XHRpZiAoIG1vZGUgPT09IF9nbC5UUklBTkdMRVMgKSBfaW5mb1JlbmRlci5mYWNlcyArPSBjb3VudCAvIDM7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gcmVuZGVySW5zdGFuY2VzKCBnZW9tZXRyeSApIHtcclxuXHJcblx0XHR2YXIgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJyApO1xyXG5cclxuXHRcdGlmICggZXh0ZW5zaW9uID09PSBudWxsICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMQnVmZmVyUmVuZGVyZXI6IHVzaW5nIFRIUkVFLkluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5IGJ1dCBoYXJkd2FyZSBkb2VzIG5vdCBzdXBwb3J0IGV4dGVuc2lvbiBBTkdMRV9pbnN0YW5jZWRfYXJyYXlzLicgKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgcG9zaXRpb24gPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xyXG5cclxuXHRcdHZhciBjb3VudCA9IDA7XHJcblxyXG5cdFx0aWYgKCBwb3NpdGlvbiBpbnN0YW5jZW9mIFRIUkVFLkludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlICkge1xyXG5cclxuXHRcdFx0Y291bnQgPSBwb3NpdGlvbi5kYXRhLmNvdW50O1xyXG5cclxuXHRcdFx0ZXh0ZW5zaW9uLmRyYXdBcnJheXNJbnN0YW5jZWRBTkdMRSggbW9kZSwgMCwgY291bnQsIGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50ICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdGNvdW50ID0gcG9zaXRpb24uY291bnQ7XHJcblxyXG5cdFx0XHRleHRlbnNpb24uZHJhd0FycmF5c0luc3RhbmNlZEFOR0xFKCBtb2RlLCAwLCBjb3VudCwgZ2VvbWV0cnkubWF4SW5zdGFuY2VkQ291bnQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0X2luZm9SZW5kZXIuY2FsbHMgKys7XHJcblx0XHRfaW5mb1JlbmRlci52ZXJ0aWNlcyArPSBjb3VudCAqIGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50O1xyXG5cdFx0aWYgKCBtb2RlID09PSBfZ2wuVFJJQU5HTEVTICkgX2luZm9SZW5kZXIuZmFjZXMgKz0gZ2VvbWV0cnkubWF4SW5zdGFuY2VkQ291bnQgKiBjb3VudCAvIDM7XHJcblxyXG5cdH1cclxuXHJcblx0dGhpcy5zZXRNb2RlID0gc2V0TW9kZTtcclxuXHR0aGlzLnJlbmRlciA9IHJlbmRlcjtcclxuXHR0aGlzLnJlbmRlckluc3RhbmNlcyA9IHJlbmRlckluc3RhbmNlcztcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xJbmRleGVkQnVmZmVyUmVuZGVyZXIuanNcclxuXHJcbi8qKlxyXG4qIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiovXHJcblxyXG5USFJFRS5XZWJHTEluZGV4ZWRCdWZmZXJSZW5kZXJlciA9IGZ1bmN0aW9uICggX2dsLCBleHRlbnNpb25zLCBfaW5mb1JlbmRlciApIHtcclxuXHJcblx0dmFyIG1vZGU7XHJcblxyXG5cdGZ1bmN0aW9uIHNldE1vZGUoIHZhbHVlICkge1xyXG5cclxuXHRcdG1vZGUgPSB2YWx1ZTtcclxuXHJcblx0fVxyXG5cclxuXHR2YXIgdHlwZSwgc2l6ZTtcclxuXHJcblx0ZnVuY3Rpb24gc2V0SW5kZXgoIGluZGV4ICkge1xyXG5cclxuXHRcdGlmICggaW5kZXguYXJyYXkgaW5zdGFuY2VvZiBVaW50MzJBcnJheSAmJiBleHRlbnNpb25zLmdldCggJ09FU19lbGVtZW50X2luZGV4X3VpbnQnICkgKSB7XHJcblxyXG5cdFx0XHR0eXBlID0gX2dsLlVOU0lHTkVEX0lOVDtcclxuXHRcdFx0c2l6ZSA9IDQ7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHR5cGUgPSBfZ2wuVU5TSUdORURfU0hPUlQ7XHJcblx0XHRcdHNpemUgPSAyO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiByZW5kZXIoIHN0YXJ0LCBjb3VudCApIHtcclxuXHJcblx0XHRfZ2wuZHJhd0VsZW1lbnRzKCBtb2RlLCBjb3VudCwgdHlwZSwgc3RhcnQgKiBzaXplICk7XHJcblxyXG5cdFx0X2luZm9SZW5kZXIuY2FsbHMgKys7XHJcblx0XHRfaW5mb1JlbmRlci52ZXJ0aWNlcyArPSBjb3VudDtcclxuXHRcdGlmICggbW9kZSA9PT0gX2dsLlRSSUFOR0xFUyApIF9pbmZvUmVuZGVyLmZhY2VzICs9IGNvdW50IC8gMztcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiByZW5kZXJJbnN0YW5jZXMoIGdlb21ldHJ5LCBzdGFydCwgY291bnQgKSB7XHJcblxyXG5cdFx0dmFyIGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnQU5HTEVfaW5zdGFuY2VkX2FycmF5cycgKTtcclxuXHJcblx0XHRpZiAoIGV4dGVuc2lvbiA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTEJ1ZmZlclJlbmRlcmVyOiB1c2luZyBUSFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSBidXQgaGFyZHdhcmUgZG9lcyBub3Qgc3VwcG9ydCBleHRlbnNpb24gQU5HTEVfaW5zdGFuY2VkX2FycmF5cy4nICk7XHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZXh0ZW5zaW9uLmRyYXdFbGVtZW50c0luc3RhbmNlZEFOR0xFKCBtb2RlLCBjb3VudCwgdHlwZSwgc3RhcnQgKiBzaXplLCBnZW9tZXRyeS5tYXhJbnN0YW5jZWRDb3VudCApO1xyXG5cclxuXHRcdF9pbmZvUmVuZGVyLmNhbGxzICsrO1xyXG5cdFx0X2luZm9SZW5kZXIudmVydGljZXMgKz0gY291bnQgKiBnZW9tZXRyeS5tYXhJbnN0YW5jZWRDb3VudDtcclxuXHRcdGlmICggbW9kZSA9PT0gX2dsLlRSSUFOR0xFUyApIF9pbmZvUmVuZGVyLmZhY2VzICs9IGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50ICogY291bnQgLyAzO1xyXG5cdH1cclxuXHJcblx0dGhpcy5zZXRNb2RlID0gc2V0TW9kZTtcclxuXHR0aGlzLnNldEluZGV4ID0gc2V0SW5kZXg7XHJcblx0dGhpcy5yZW5kZXIgPSByZW5kZXI7XHJcblx0dGhpcy5yZW5kZXJJbnN0YW5jZXMgPSByZW5kZXJJbnN0YW5jZXM7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3dlYmdsL1dlYkdMRXh0ZW5zaW9ucy5qc1xyXG5cclxuLyoqXHJcbiogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuKi9cclxuXHJcblRIUkVFLldlYkdMRXh0ZW5zaW9ucyA9IGZ1bmN0aW9uICggZ2wgKSB7XHJcblxyXG5cdHZhciBleHRlbnNpb25zID0ge307XHJcblxyXG5cdHRoaXMuZ2V0ID0gZnVuY3Rpb24gKCBuYW1lICkge1xyXG5cclxuXHRcdGlmICggZXh0ZW5zaW9uc1sgbmFtZSBdICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gZXh0ZW5zaW9uc1sgbmFtZSBdO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZXh0ZW5zaW9uO1xyXG5cclxuXHRcdHN3aXRjaCAoIG5hbWUgKSB7XHJcblxyXG5cdFx0XHRjYXNlICdFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnOlxyXG5cdFx0XHRcdGV4dGVuc2lvbiA9IGdsLmdldEV4dGVuc2lvbiggJ0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYycgKSB8fCBnbC5nZXRFeHRlbnNpb24oICdNT1pfRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJyApIHx8IGdsLmdldEV4dGVuc2lvbiggJ1dFQktJVF9FWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnICk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRjYXNlICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0Yyc6XHJcblx0XHRcdFx0ZXh0ZW5zaW9uID0gZ2wuZ2V0RXh0ZW5zaW9uKCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMnICkgfHwgZ2wuZ2V0RXh0ZW5zaW9uKCAnTU9aX1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJyApIHx8IGdsLmdldEV4dGVuc2lvbiggJ1dFQktJVF9XRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0YycgKTtcclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGNhc2UgJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0Yyc6XHJcblx0XHRcdFx0ZXh0ZW5zaW9uID0gZ2wuZ2V0RXh0ZW5zaW9uKCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjJyApIHx8IGdsLmdldEV4dGVuc2lvbiggJ1dFQktJVF9XRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMnICk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRjYXNlICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfZXRjMSc6XHJcblx0XHRcdFx0ZXh0ZW5zaW9uID0gZ2wuZ2V0RXh0ZW5zaW9uKCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX2V0YzEnICk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRkZWZhdWx0OlxyXG5cdFx0XHRcdGV4dGVuc2lvbiA9IGdsLmdldEV4dGVuc2lvbiggbmFtZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGV4dGVuc2lvbiA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6ICcgKyBuYW1lICsgJyBleHRlbnNpb24gbm90IHN1cHBvcnRlZC4nICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGV4dGVuc2lvbnNbIG5hbWUgXSA9IGV4dGVuc2lvbjtcclxuXHJcblx0XHRyZXR1cm4gZXh0ZW5zaW9uO1xyXG5cclxuXHR9O1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy93ZWJnbC9XZWJHTENhcGFiaWxpdGllcy5qc1xyXG5cclxuVEhSRUUuV2ViR0xDYXBhYmlsaXRpZXMgPSBmdW5jdGlvbiAoIGdsLCBleHRlbnNpb25zLCBwYXJhbWV0ZXJzICkge1xyXG5cclxuXHRmdW5jdGlvbiBnZXRNYXhQcmVjaXNpb24oIHByZWNpc2lvbiApIHtcclxuXHJcblx0XHRpZiAoIHByZWNpc2lvbiA9PT0gJ2hpZ2hwJyApIHtcclxuXHJcblx0XHRcdGlmICggZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KCBnbC5WRVJURVhfU0hBREVSLCBnbC5ISUdIX0ZMT0FUICkucHJlY2lzaW9uID4gMCAmJlxyXG5cdFx0XHQgICAgIGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdCggZ2wuRlJBR01FTlRfU0hBREVSLCBnbC5ISUdIX0ZMT0FUICkucHJlY2lzaW9uID4gMCApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuICdoaWdocCc7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRwcmVjaXNpb24gPSAnbWVkaXVtcCc7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggcHJlY2lzaW9uID09PSAnbWVkaXVtcCcgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdCggZ2wuVkVSVEVYX1NIQURFUiwgZ2wuTUVESVVNX0ZMT0FUICkucHJlY2lzaW9uID4gMCAmJlxyXG5cdFx0XHQgICAgIGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdCggZ2wuRlJBR01FTlRfU0hBREVSLCBnbC5NRURJVU1fRkxPQVQgKS5wcmVjaXNpb24gPiAwICkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gJ21lZGl1bXAnO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gJ2xvd3AnO1xyXG5cclxuXHR9XHJcblxyXG5cdHRoaXMuZ2V0TWF4UHJlY2lzaW9uID0gZ2V0TWF4UHJlY2lzaW9uO1xyXG5cclxuXHR0aGlzLnByZWNpc2lvbiA9IHBhcmFtZXRlcnMucHJlY2lzaW9uICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLnByZWNpc2lvbiA6ICdoaWdocCcsXHJcblx0dGhpcy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyID0gcGFyYW1ldGVycy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgOiBmYWxzZTtcclxuXHJcblx0dGhpcy5tYXhUZXh0dXJlcyA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX1RFWFRVUkVfSU1BR0VfVU5JVFMgKTtcclxuXHR0aGlzLm1heFZlcnRleFRleHR1cmVzID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5NQVhfVkVSVEVYX1RFWFRVUkVfSU1BR0VfVU5JVFMgKTtcclxuXHR0aGlzLm1heFRleHR1cmVTaXplID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5NQVhfVEVYVFVSRV9TSVpFICk7XHJcblx0dGhpcy5tYXhDdWJlbWFwU2l6ZSA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX0NVQkVfTUFQX1RFWFRVUkVfU0laRSApO1xyXG5cclxuXHR0aGlzLm1heEF0dHJpYnV0ZXMgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLk1BWF9WRVJURVhfQVRUUklCUyApO1xyXG5cdHRoaXMubWF4VmVydGV4VW5pZm9ybXMgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLk1BWF9WRVJURVhfVU5JRk9STV9WRUNUT1JTICk7XHJcblx0dGhpcy5tYXhWYXJ5aW5ncyA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX1ZBUllJTkdfVkVDVE9SUyApO1xyXG5cdHRoaXMubWF4RnJhZ21lbnRVbmlmb3JtcyA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX0ZSQUdNRU5UX1VOSUZPUk1fVkVDVE9SUyApO1xyXG5cclxuXHR0aGlzLnZlcnRleFRleHR1cmVzID0gdGhpcy5tYXhWZXJ0ZXhUZXh0dXJlcyA+IDA7XHJcblx0dGhpcy5mbG9hdEZyYWdtZW50VGV4dHVyZXMgPSAhISBleHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2Zsb2F0JyApO1xyXG5cdHRoaXMuZmxvYXRWZXJ0ZXhUZXh0dXJlcyA9IHRoaXMudmVydGV4VGV4dHVyZXMgJiYgdGhpcy5mbG9hdEZyYWdtZW50VGV4dHVyZXM7XHJcblxyXG5cdHZhciBfbWF4UHJlY2lzaW9uID0gZ2V0TWF4UHJlY2lzaW9uKCB0aGlzLnByZWNpc2lvbiApO1xyXG5cclxuXHRpZiAoIF9tYXhQcmVjaXNpb24gIT09IHRoaXMucHJlY2lzaW9uICkge1xyXG5cclxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6JywgdGhpcy5wcmVjaXNpb24sICdub3Qgc3VwcG9ydGVkLCB1c2luZycsIF9tYXhQcmVjaXNpb24sICdpbnN0ZWFkLicgKTtcclxuXHRcdHRoaXMucHJlY2lzaW9uID0gX21heFByZWNpc2lvbjtcclxuXHJcblx0fVxyXG5cclxuXHRpZiAoIHRoaXMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciApIHtcclxuXHJcblx0XHR0aGlzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgPSAhISBleHRlbnNpb25zLmdldCggJ0VYVF9mcmFnX2RlcHRoJyApO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3dlYmdsL1dlYkdMR2VvbWV0cmllcy5qc1xyXG5cclxuLyoqXHJcbiogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuKi9cclxuXHJcblRIUkVFLldlYkdMR2VvbWV0cmllcyA9IGZ1bmN0aW9uICggZ2wsIHByb3BlcnRpZXMsIGluZm8gKSB7XHJcblxyXG5cdHZhciBnZW9tZXRyaWVzID0ge307XHJcblxyXG5cdGZ1bmN0aW9uIGdldCggb2JqZWN0ICkge1xyXG5cclxuXHRcdHZhciBnZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeTtcclxuXHJcblx0XHRpZiAoIGdlb21ldHJpZXNbIGdlb21ldHJ5LmlkIF0gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHJldHVybiBnZW9tZXRyaWVzWyBnZW9tZXRyeS5pZCBdO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRnZW9tZXRyeS5hZGRFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uR2VvbWV0cnlEaXNwb3NlICk7XHJcblxyXG5cdFx0dmFyIGJ1ZmZlcmdlb21ldHJ5O1xyXG5cclxuXHRcdGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSApIHtcclxuXHJcblx0XHRcdGJ1ZmZlcmdlb21ldHJ5ID0gZ2VvbWV0cnk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5HZW9tZXRyeSApIHtcclxuXHJcblx0XHRcdGlmICggZ2VvbWV0cnkuX2J1ZmZlckdlb21ldHJ5ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGdlb21ldHJ5Ll9idWZmZXJHZW9tZXRyeSA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpLnNldEZyb21PYmplY3QoIG9iamVjdCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0YnVmZmVyZ2VvbWV0cnkgPSBnZW9tZXRyeS5fYnVmZmVyR2VvbWV0cnk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGdlb21ldHJpZXNbIGdlb21ldHJ5LmlkIF0gPSBidWZmZXJnZW9tZXRyeTtcclxuXHJcblx0XHRpbmZvLm1lbW9yeS5nZW9tZXRyaWVzICsrO1xyXG5cclxuXHRcdHJldHVybiBidWZmZXJnZW9tZXRyeTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBvbkdlb21ldHJ5RGlzcG9zZSggZXZlbnQgKSB7XHJcblxyXG5cdFx0dmFyIGdlb21ldHJ5ID0gZXZlbnQudGFyZ2V0O1xyXG5cdFx0dmFyIGJ1ZmZlcmdlb21ldHJ5ID0gZ2VvbWV0cmllc1sgZ2VvbWV0cnkuaWQgXTtcclxuXHJcblx0XHRpZiAoIGJ1ZmZlcmdlb21ldHJ5LmluZGV4ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0ZGVsZXRlQXR0cmlidXRlKCBidWZmZXJnZW9tZXRyeS5pbmRleCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRkZWxldGVBdHRyaWJ1dGVzKCBidWZmZXJnZW9tZXRyeS5hdHRyaWJ1dGVzICk7XHJcblxyXG5cdFx0Z2VvbWV0cnkucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvbkdlb21ldHJ5RGlzcG9zZSApO1xyXG5cclxuXHRcdGRlbGV0ZSBnZW9tZXRyaWVzWyBnZW9tZXRyeS5pZCBdO1xyXG5cclxuXHRcdC8vIFRPRE9cclxuXHJcblx0XHR2YXIgcHJvcGVydHkgPSBwcm9wZXJ0aWVzLmdldCggZ2VvbWV0cnkgKTtcclxuXHJcblx0XHRpZiAoIHByb3BlcnR5LndpcmVmcmFtZSApIHtcclxuXHJcblx0XHRcdGRlbGV0ZUF0dHJpYnV0ZSggcHJvcGVydHkud2lyZWZyYW1lICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHByb3BlcnRpZXMuZGVsZXRlKCBnZW9tZXRyeSApO1xyXG5cclxuXHRcdHZhciBidWZmZXJwcm9wZXJ0eSA9IHByb3BlcnRpZXMuZ2V0KCBidWZmZXJnZW9tZXRyeSApO1xyXG5cclxuXHRcdGlmICggYnVmZmVycHJvcGVydHkud2lyZWZyYW1lICkge1xyXG5cclxuXHRcdFx0ZGVsZXRlQXR0cmlidXRlKCBidWZmZXJwcm9wZXJ0eS53aXJlZnJhbWUgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cHJvcGVydGllcy5kZWxldGUoIGJ1ZmZlcmdlb21ldHJ5ICk7XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHRpbmZvLm1lbW9yeS5nZW9tZXRyaWVzIC0tO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGdldEF0dHJpYnV0ZUJ1ZmZlciggYXR0cmlidXRlICkge1xyXG5cclxuXHRcdGlmICggYXR0cmlidXRlIGluc3RhbmNlb2YgVEhSRUUuSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gcHJvcGVydGllcy5nZXQoIGF0dHJpYnV0ZS5kYXRhICkuX193ZWJnbEJ1ZmZlcjtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHByb3BlcnRpZXMuZ2V0KCBhdHRyaWJ1dGUgKS5fX3dlYmdsQnVmZmVyO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGRlbGV0ZUF0dHJpYnV0ZSggYXR0cmlidXRlICkge1xyXG5cclxuXHRcdHZhciBidWZmZXIgPSBnZXRBdHRyaWJ1dGVCdWZmZXIoIGF0dHJpYnV0ZSApO1xyXG5cclxuXHRcdGlmICggYnVmZmVyICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRnbC5kZWxldGVCdWZmZXIoIGJ1ZmZlciApO1xyXG5cdFx0XHRyZW1vdmVBdHRyaWJ1dGVCdWZmZXIoIGF0dHJpYnV0ZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBkZWxldGVBdHRyaWJ1dGVzKCBhdHRyaWJ1dGVzICkge1xyXG5cclxuXHRcdGZvciAoIHZhciBuYW1lIGluIGF0dHJpYnV0ZXMgKSB7XHJcblxyXG5cdFx0XHRkZWxldGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXNbIG5hbWUgXSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiByZW1vdmVBdHRyaWJ1dGVCdWZmZXIoIGF0dHJpYnV0ZSApIHtcclxuXHJcblx0XHRpZiAoIGF0dHJpYnV0ZSBpbnN0YW5jZW9mIFRIUkVFLkludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlICkge1xyXG5cclxuXHRcdFx0cHJvcGVydGllcy5kZWxldGUoIGF0dHJpYnV0ZS5kYXRhICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHByb3BlcnRpZXMuZGVsZXRlKCBhdHRyaWJ1dGUgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0dGhpcy5nZXQgPSBnZXQ7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3dlYmdsL1dlYkdMTGlnaHRzLmpzXHJcblxyXG4vKipcclxuKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4qL1xyXG5cclxuVEhSRUUuV2ViR0xMaWdodHMgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHZhciBsaWdodHMgPSB7fTtcclxuXHJcblx0dGhpcy5nZXQgPSBmdW5jdGlvbiAoIGxpZ2h0ICkge1xyXG5cclxuXHRcdGlmICggbGlnaHRzWyBsaWdodC5pZCBdICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gbGlnaHRzWyBsaWdodC5pZCBdO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgdW5pZm9ybXM7XHJcblxyXG5cdFx0c3dpdGNoICggbGlnaHQudHlwZSApIHtcclxuXHJcblx0XHRcdGNhc2UgJ0RpcmVjdGlvbmFsTGlnaHQnOlxyXG5cdFx0XHRcdHVuaWZvcm1zID0ge1xyXG5cdFx0XHRcdFx0ZGlyZWN0aW9uOiBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG5cdFx0XHRcdFx0Y29sb3I6IG5ldyBUSFJFRS5Db2xvcigpLFxyXG5cclxuXHRcdFx0XHRcdHNoYWRvdzogZmFsc2UsXHJcblx0XHRcdFx0XHRzaGFkb3dCaWFzOiAwLFxyXG5cdFx0XHRcdFx0c2hhZG93UmFkaXVzOiAxLFxyXG5cdFx0XHRcdFx0c2hhZG93TWFwU2l6ZTogbmV3IFRIUkVFLlZlY3RvcjIoKVxyXG5cdFx0XHRcdH07XHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRjYXNlICdTcG90TGlnaHQnOlxyXG5cdFx0XHRcdHVuaWZvcm1zID0ge1xyXG5cdFx0XHRcdFx0cG9zaXRpb246IG5ldyBUSFJFRS5WZWN0b3IzKCksXHJcblx0XHRcdFx0XHRkaXJlY3Rpb246IG5ldyBUSFJFRS5WZWN0b3IzKCksXHJcblx0XHRcdFx0XHRjb2xvcjogbmV3IFRIUkVFLkNvbG9yKCksXHJcblx0XHRcdFx0XHRkaXN0YW5jZTogMCxcclxuXHRcdFx0XHRcdGFuZ2xlQ29zOiAwLFxyXG5cdFx0XHRcdFx0ZXhwb25lbnQ6IDAsXHJcblx0XHRcdFx0XHRkZWNheTogMCxcclxuXHJcblx0XHRcdFx0XHRzaGFkb3c6IGZhbHNlLFxyXG5cdFx0XHRcdFx0c2hhZG93QmlhczogMCxcclxuXHRcdFx0XHRcdHNoYWRvd1JhZGl1czogMSxcclxuXHRcdFx0XHRcdHNoYWRvd01hcFNpemU6IG5ldyBUSFJFRS5WZWN0b3IyKClcclxuXHRcdFx0XHR9O1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0Y2FzZSAnUG9pbnRMaWdodCc6XHJcblx0XHRcdFx0dW5pZm9ybXMgPSB7XHJcblx0XHRcdFx0XHRwb3NpdGlvbjogbmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHRcdFx0XHRcdGNvbG9yOiBuZXcgVEhSRUUuQ29sb3IoKSxcclxuXHRcdFx0XHRcdGRpc3RhbmNlOiAwLFxyXG5cdFx0XHRcdFx0ZGVjYXk6IDAsXHJcblxyXG5cdFx0XHRcdFx0c2hhZG93OiBmYWxzZSxcclxuXHRcdFx0XHRcdHNoYWRvd0JpYXM6IDAsXHJcblx0XHRcdFx0XHRzaGFkb3dSYWRpdXM6IDEsXHJcblx0XHRcdFx0XHRzaGFkb3dNYXBTaXplOiBuZXcgVEhSRUUuVmVjdG9yMigpXHJcblx0XHRcdFx0fTtcclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGNhc2UgJ0hlbWlzcGhlcmVMaWdodCc6XHJcblx0XHRcdFx0dW5pZm9ybXMgPSB7XHJcblx0XHRcdFx0XHRkaXJlY3Rpb246IG5ldyBUSFJFRS5WZWN0b3IzKCksXHJcblx0XHRcdFx0XHRza3lDb2xvcjogbmV3IFRIUkVFLkNvbG9yKCksXHJcblx0XHRcdFx0XHRncm91bmRDb2xvcjogbmV3IFRIUkVFLkNvbG9yKClcclxuXHRcdFx0XHR9O1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRsaWdodHNbIGxpZ2h0LmlkIF0gPSB1bmlmb3JtcztcclxuXHJcblx0XHRyZXR1cm4gdW5pZm9ybXM7XHJcblxyXG5cdH07XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3dlYmdsL1dlYkdMT2JqZWN0cy5qc1xyXG5cclxuLyoqXHJcbiogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuKi9cclxuXHJcblRIUkVFLldlYkdMT2JqZWN0cyA9IGZ1bmN0aW9uICggZ2wsIHByb3BlcnRpZXMsIGluZm8gKSB7XHJcblxyXG5cdHZhciBnZW9tZXRyaWVzID0gbmV3IFRIUkVFLldlYkdMR2VvbWV0cmllcyggZ2wsIHByb3BlcnRpZXMsIGluZm8gKTtcclxuXHJcblx0Ly9cclxuXHJcblx0ZnVuY3Rpb24gdXBkYXRlKCBvYmplY3QgKSB7XHJcblxyXG5cdFx0Ly8gVE9ETzogQXZvaWQgdXBkYXRpbmcgdHdpY2UgKHdoZW4gdXNpbmcgc2hhZG93TWFwKS4gTWF5YmUgYWRkIGZyYW1lIGNvdW50ZXIuXHJcblxyXG5cdFx0dmFyIGdlb21ldHJ5ID0gZ2VvbWV0cmllcy5nZXQoIG9iamVjdCApO1xyXG5cclxuXHRcdGlmICggb2JqZWN0Lmdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuR2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0XHRnZW9tZXRyeS51cGRhdGVGcm9tT2JqZWN0KCBvYmplY3QgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XHJcblx0XHR2YXIgYXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XHJcblxyXG5cdFx0aWYgKCBpbmRleCAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdHVwZGF0ZUF0dHJpYnV0ZSggaW5kZXgsIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoIHZhciBuYW1lIGluIGF0dHJpYnV0ZXMgKSB7XHJcblxyXG5cdFx0XHR1cGRhdGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXNbIG5hbWUgXSwgZ2wuQVJSQVlfQlVGRkVSICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIG1vcnBoIHRhcmdldHNcclxuXHJcblx0XHR2YXIgbW9ycGhBdHRyaWJ1dGVzID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzO1xyXG5cclxuXHRcdGZvciAoIHZhciBuYW1lIGluIG1vcnBoQXR0cmlidXRlcyApIHtcclxuXHJcblx0XHRcdHZhciBhcnJheSA9IG1vcnBoQXR0cmlidXRlc1sgbmFtZSBdO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gYXJyYXkubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0dXBkYXRlQXR0cmlidXRlKCBhcnJheVsgaSBdLCBnbC5BUlJBWV9CVUZGRVIgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGdlb21ldHJ5O1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHVwZGF0ZUF0dHJpYnV0ZSggYXR0cmlidXRlLCBidWZmZXJUeXBlICkge1xyXG5cclxuXHRcdHZhciBkYXRhID0gKCBhdHRyaWJ1dGUgaW5zdGFuY2VvZiBUSFJFRS5JbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSApID8gYXR0cmlidXRlLmRhdGEgOiBhdHRyaWJ1dGU7XHJcblxyXG5cdFx0dmFyIGF0dHJpYnV0ZVByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggZGF0YSApO1xyXG5cclxuXHRcdGlmICggYXR0cmlidXRlUHJvcGVydGllcy5fX3dlYmdsQnVmZmVyID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRjcmVhdGVCdWZmZXIoIGF0dHJpYnV0ZVByb3BlcnRpZXMsIGRhdGEsIGJ1ZmZlclR5cGUgKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBhdHRyaWJ1dGVQcm9wZXJ0aWVzLnZlcnNpb24gIT09IGRhdGEudmVyc2lvbiApIHtcclxuXHJcblx0XHRcdHVwZGF0ZUJ1ZmZlciggYXR0cmlidXRlUHJvcGVydGllcywgZGF0YSwgYnVmZmVyVHlwZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBjcmVhdGVCdWZmZXIoIGF0dHJpYnV0ZVByb3BlcnRpZXMsIGRhdGEsIGJ1ZmZlclR5cGUgKSB7XHJcblxyXG5cdFx0YXR0cmlidXRlUHJvcGVydGllcy5fX3dlYmdsQnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XHJcblx0XHRnbC5iaW5kQnVmZmVyKCBidWZmZXJUeXBlLCBhdHRyaWJ1dGVQcm9wZXJ0aWVzLl9fd2ViZ2xCdWZmZXIgKTtcclxuXHJcblx0XHR2YXIgdXNhZ2UgPSBkYXRhLmR5bmFtaWMgPyBnbC5EWU5BTUlDX0RSQVcgOiBnbC5TVEFUSUNfRFJBVztcclxuXHJcblx0XHRnbC5idWZmZXJEYXRhKCBidWZmZXJUeXBlLCBkYXRhLmFycmF5LCB1c2FnZSApO1xyXG5cclxuXHRcdGF0dHJpYnV0ZVByb3BlcnRpZXMudmVyc2lvbiA9IGRhdGEudmVyc2lvbjtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiB1cGRhdGVCdWZmZXIoIGF0dHJpYnV0ZVByb3BlcnRpZXMsIGRhdGEsIGJ1ZmZlclR5cGUgKSB7XHJcblxyXG5cdFx0Z2wuYmluZEJ1ZmZlciggYnVmZmVyVHlwZSwgYXR0cmlidXRlUHJvcGVydGllcy5fX3dlYmdsQnVmZmVyICk7XHJcblxyXG5cdFx0aWYgKCBkYXRhLmR5bmFtaWMgPT09IGZhbHNlIHx8IGRhdGEudXBkYXRlUmFuZ2UuY291bnQgPT09IC0gMSApIHtcclxuXHJcblx0XHRcdC8vIE5vdCB1c2luZyB1cGRhdGUgcmFuZ2VzXHJcblxyXG5cdFx0XHRnbC5idWZmZXJTdWJEYXRhKCBidWZmZXJUeXBlLCAwLCBkYXRhLmFycmF5ICk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggZGF0YS51cGRhdGVSYW5nZS5jb3VudCA9PT0gMCApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTE9iamVjdHMudXBkYXRlQnVmZmVyOiBkeW5hbWljIFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSBtYXJrZWQgYXMgbmVlZHNVcGRhdGUgYnV0IHVwZGF0ZVJhbmdlLmNvdW50IGlzIDAsIGVuc3VyZSB5b3UgYXJlIHVzaW5nIHNldCBtZXRob2RzIG9yIHVwZGF0aW5nIG1hbnVhbGx5LicgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0Z2wuYnVmZmVyU3ViRGF0YSggYnVmZmVyVHlwZSwgZGF0YS51cGRhdGVSYW5nZS5vZmZzZXQgKiBkYXRhLmFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxyXG5cdFx0XHRcdFx0XHRcdCAgZGF0YS5hcnJheS5zdWJhcnJheSggZGF0YS51cGRhdGVSYW5nZS5vZmZzZXQsIGRhdGEudXBkYXRlUmFuZ2Uub2Zmc2V0ICsgZGF0YS51cGRhdGVSYW5nZS5jb3VudCApICk7XHJcblxyXG5cdFx0XHRkYXRhLnVwZGF0ZVJhbmdlLmNvdW50ID0gMDsgLy8gcmVzZXQgcmFuZ2VcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0YXR0cmlidXRlUHJvcGVydGllcy52ZXJzaW9uID0gZGF0YS52ZXJzaW9uO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGdldEF0dHJpYnV0ZUJ1ZmZlciggYXR0cmlidXRlICkge1xyXG5cclxuXHRcdGlmICggYXR0cmlidXRlIGluc3RhbmNlb2YgVEhSRUUuSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gcHJvcGVydGllcy5nZXQoIGF0dHJpYnV0ZS5kYXRhICkuX193ZWJnbEJ1ZmZlcjtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHByb3BlcnRpZXMuZ2V0KCBhdHRyaWJ1dGUgKS5fX3dlYmdsQnVmZmVyO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGdldFdpcmVmcmFtZUF0dHJpYnV0ZSggZ2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0dmFyIHByb3BlcnR5ID0gcHJvcGVydGllcy5nZXQoIGdlb21ldHJ5ICk7XHJcblxyXG5cdFx0aWYgKCBwcm9wZXJ0eS53aXJlZnJhbWUgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHJldHVybiBwcm9wZXJ0eS53aXJlZnJhbWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBpbmRpY2VzID0gW107XHJcblxyXG5cdFx0dmFyIGluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XHJcblx0XHR2YXIgYXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XHJcblx0XHR2YXIgcG9zaXRpb24gPSBhdHRyaWJ1dGVzLnBvc2l0aW9uO1xyXG5cclxuXHRcdC8vIGNvbnNvbGUudGltZSggJ3dpcmVmcmFtZScgKTtcclxuXHJcblx0XHRpZiAoIGluZGV4ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0dmFyIGVkZ2VzID0ge307XHJcblx0XHRcdHZhciBhcnJheSA9IGluZGV4LmFycmF5O1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gYXJyYXkubGVuZ3RoOyBpIDwgbDsgaSArPSAzICkge1xyXG5cclxuXHRcdFx0XHR2YXIgYSA9IGFycmF5WyBpICsgMCBdO1xyXG5cdFx0XHRcdHZhciBiID0gYXJyYXlbIGkgKyAxIF07XHJcblx0XHRcdFx0dmFyIGMgPSBhcnJheVsgaSArIDIgXTtcclxuXHJcblx0XHRcdFx0aWYgKCBjaGVja0VkZ2UoIGVkZ2VzLCBhLCBiICkgKSBpbmRpY2VzLnB1c2goIGEsIGIgKTtcclxuXHRcdFx0XHRpZiAoIGNoZWNrRWRnZSggZWRnZXMsIGIsIGMgKSApIGluZGljZXMucHVzaCggYiwgYyApO1xyXG5cdFx0XHRcdGlmICggY2hlY2tFZGdlKCBlZGdlcywgYywgYSApICkgaW5kaWNlcy5wdXNoKCBjLCBhICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHZhciBhcnJheSA9IGF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSAoIGFycmF5Lmxlbmd0aCAvIDMgKSAtIDE7IGkgPCBsOyBpICs9IDMgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBhID0gaSArIDA7XHJcblx0XHRcdFx0dmFyIGIgPSBpICsgMTtcclxuXHRcdFx0XHR2YXIgYyA9IGkgKyAyO1xyXG5cclxuXHRcdFx0XHRpbmRpY2VzLnB1c2goIGEsIGIsIGIsIGMsIGMsIGEgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gY29uc29sZS50aW1lRW5kKCAnd2lyZWZyYW1lJyApO1xyXG5cclxuXHRcdHZhciBUeXBlQXJyYXkgPSBwb3NpdGlvbi5jb3VudCA+IDY1NTM1ID8gVWludDMyQXJyYXkgOiBVaW50MTZBcnJheTtcclxuXHRcdHZhciBhdHRyaWJ1dGUgPSBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgVHlwZUFycmF5KCBpbmRpY2VzICksIDEgKTtcclxuXHJcblx0XHR1cGRhdGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZSwgZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIgKTtcclxuXHJcblx0XHRwcm9wZXJ0eS53aXJlZnJhbWUgPSBhdHRyaWJ1dGU7XHJcblxyXG5cdFx0cmV0dXJuIGF0dHJpYnV0ZTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBjaGVja0VkZ2UoIGVkZ2VzLCBhLCBiICkge1xyXG5cclxuXHRcdGlmICggYSA+IGIgKSB7XHJcblxyXG5cdFx0XHR2YXIgdG1wID0gYTtcclxuXHRcdFx0YSA9IGI7XHJcblx0XHRcdGIgPSB0bXA7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBsaXN0ID0gZWRnZXNbIGEgXTtcclxuXHJcblx0XHRpZiAoIGxpc3QgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGVkZ2VzWyBhIF0gPSBbIGIgXTtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggbGlzdC5pbmRleE9mKCBiICkgPT09IC0xICkge1xyXG5cclxuXHRcdFx0bGlzdC5wdXNoKCBiICk7XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblxyXG5cdH1cclxuXHJcblx0dGhpcy5nZXRBdHRyaWJ1dGVCdWZmZXIgPSBnZXRBdHRyaWJ1dGVCdWZmZXI7XHJcblx0dGhpcy5nZXRXaXJlZnJhbWVBdHRyaWJ1dGUgPSBnZXRXaXJlZnJhbWVBdHRyaWJ1dGU7XHJcblxyXG5cdHRoaXMudXBkYXRlID0gdXBkYXRlO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy93ZWJnbC9XZWJHTFByb2dyYW0uanNcclxuXHJcblRIUkVFLldlYkdMUHJvZ3JhbSA9ICggZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgcHJvZ3JhbUlkQ291bnQgPSAwO1xyXG5cclxuXHQvLyBUT0RPOiBDb21iaW5lIHRoZSByZWdleFxyXG5cdHZhciBzdHJ1Y3RSZSA9IC9eKFtcXHdcXGRfXSspXFwuKFtcXHdcXGRfXSspJC87XHJcblx0dmFyIGFycmF5U3RydWN0UmUgPSAvXihbXFx3XFxkX10rKVxcWyhcXGQrKVxcXVxcLihbXFx3XFxkX10rKSQvO1xyXG5cdHZhciBhcnJheVJlID0gL14oW1xcd1xcZF9dKylcXFswXFxdJC87XHJcblxyXG5cdGZ1bmN0aW9uIGdlbmVyYXRlRXh0ZW5zaW9ucyggZXh0ZW5zaW9ucywgcGFyYW1ldGVycywgcmVuZGVyZXJFeHRlbnNpb25zICkge1xyXG5cclxuXHRcdGV4dGVuc2lvbnMgPSBleHRlbnNpb25zIHx8IHt9O1xyXG5cclxuXHRcdHZhciBjaHVua3MgPSBbXHJcblx0XHRcdCggZXh0ZW5zaW9ucy5kZXJpdmF0aXZlcyB8fCBwYXJhbWV0ZXJzLmJ1bXBNYXAgfHwgcGFyYW1ldGVycy5ub3JtYWxNYXAgfHwgcGFyYW1ldGVycy5mbGF0U2hhZGluZyApID8gJyNleHRlbnNpb24gR0xfT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzIDogZW5hYmxlJyA6ICcnLFxyXG5cdFx0XHQoIGV4dGVuc2lvbnMuZnJhZ0RlcHRoIHx8IHBhcmFtZXRlcnMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciApICYmIHJlbmRlcmVyRXh0ZW5zaW9ucy5nZXQoICdFWFRfZnJhZ19kZXB0aCcgKSA/ICcjZXh0ZW5zaW9uIEdMX0VYVF9mcmFnX2RlcHRoIDogZW5hYmxlJyA6ICcnLFxyXG5cdFx0XHQoIGV4dGVuc2lvbnMuZHJhd0J1ZmZlcnMgKSAmJiByZW5kZXJlckV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfZHJhd19idWZmZXJzJyApID8gJyNleHRlbnNpb24gR0xfRVhUX2RyYXdfYnVmZmVycyA6IHJlcXVpcmUnIDogJycsXHJcblx0XHRcdCggZXh0ZW5zaW9ucy5zaGFkZXJUZXh0dXJlTE9EIHx8IHBhcmFtZXRlcnMuZW52TWFwICkgJiYgcmVuZGVyZXJFeHRlbnNpb25zLmdldCggJ0VYVF9zaGFkZXJfdGV4dHVyZV9sb2QnICkgPyAnI2V4dGVuc2lvbiBHTF9FWFRfc2hhZGVyX3RleHR1cmVfbG9kIDogZW5hYmxlJyA6ICcnLFxyXG5cdFx0XTtcclxuXHJcblx0XHRyZXR1cm4gY2h1bmtzLmZpbHRlciggZmlsdGVyRW1wdHlMaW5lICkuam9pbiggJ1xcbicgKTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBnZW5lcmF0ZURlZmluZXMoIGRlZmluZXMgKSB7XHJcblxyXG5cdFx0dmFyIGNodW5rcyA9IFtdO1xyXG5cclxuXHRcdGZvciAoIHZhciBuYW1lIGluIGRlZmluZXMgKSB7XHJcblxyXG5cdFx0XHR2YXIgdmFsdWUgPSBkZWZpbmVzWyBuYW1lIF07XHJcblxyXG5cdFx0XHRpZiAoIHZhbHVlID09PSBmYWxzZSApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0Y2h1bmtzLnB1c2goICcjZGVmaW5lICcgKyBuYW1lICsgJyAnICsgdmFsdWUgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGNodW5rcy5qb2luKCAnXFxuJyApO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGZldGNoVW5pZm9ybUxvY2F0aW9ucyggZ2wsIHByb2dyYW0sIGlkZW50aWZpZXJzICkge1xyXG5cclxuXHRcdHZhciB1bmlmb3JtcyA9IHt9O1xyXG5cclxuXHRcdHZhciBuID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlciggcHJvZ3JhbSwgZ2wuQUNUSVZFX1VOSUZPUk1TICk7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbjsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciBpbmZvID0gZ2wuZ2V0QWN0aXZlVW5pZm9ybSggcHJvZ3JhbSwgaSApO1xyXG5cdFx0XHR2YXIgbmFtZSA9IGluZm8ubmFtZTtcclxuXHRcdFx0dmFyIGxvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCBuYW1lICk7XHJcblxyXG5cdFx0XHQvL2NvbnNvbGUubG9nKFwiVEhSRUUuV2ViR0xQcm9ncmFtOiBBQ1RJVkUgVU5JRk9STTpcIiwgbmFtZSk7XHJcblxyXG5cdFx0XHR2YXIgbWF0Y2hlcyA9IHN0cnVjdFJlLmV4ZWMoIG5hbWUgKTtcclxuXHRcdFx0aWYgKCBtYXRjaGVzICkge1xyXG5cclxuXHRcdFx0XHR2YXIgc3RydWN0TmFtZSA9IG1hdGNoZXNbIDEgXTtcclxuXHRcdFx0XHR2YXIgc3RydWN0UHJvcGVydHkgPSBtYXRjaGVzWyAyIF07XHJcblxyXG5cdFx0XHRcdHZhciB1bmlmb3Jtc1N0cnVjdCA9IHVuaWZvcm1zWyBzdHJ1Y3ROYW1lIF07XHJcblxyXG5cdFx0XHRcdGlmICggISB1bmlmb3Jtc1N0cnVjdCApIHtcclxuXHJcblx0XHRcdFx0XHR1bmlmb3Jtc1N0cnVjdCA9IHVuaWZvcm1zWyBzdHJ1Y3ROYW1lIF0gPSB7fTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR1bmlmb3Jtc1N0cnVjdFsgc3RydWN0UHJvcGVydHkgXSA9IGxvY2F0aW9uO1xyXG5cclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdG1hdGNoZXMgPSBhcnJheVN0cnVjdFJlLmV4ZWMoIG5hbWUgKTtcclxuXHJcblx0XHRcdGlmICggbWF0Y2hlcyApIHtcclxuXHJcblx0XHRcdFx0dmFyIGFycmF5TmFtZSA9IG1hdGNoZXNbIDEgXTtcclxuXHRcdFx0XHR2YXIgYXJyYXlJbmRleCA9IG1hdGNoZXNbIDIgXTtcclxuXHRcdFx0XHR2YXIgYXJyYXlQcm9wZXJ0eSA9IG1hdGNoZXNbIDMgXTtcclxuXHJcblx0XHRcdFx0dmFyIHVuaWZvcm1zQXJyYXkgPSB1bmlmb3Jtc1sgYXJyYXlOYW1lIF07XHJcblxyXG5cdFx0XHRcdGlmICggISB1bmlmb3Jtc0FycmF5ICkge1xyXG5cclxuXHRcdFx0XHRcdHVuaWZvcm1zQXJyYXkgPSB1bmlmb3Jtc1sgYXJyYXlOYW1lIF0gPSBbXTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR2YXIgdW5pZm9ybXNBcnJheUluZGV4ID0gdW5pZm9ybXNBcnJheVsgYXJyYXlJbmRleCBdO1xyXG5cclxuXHRcdFx0XHRpZiAoICEgdW5pZm9ybXNBcnJheUluZGV4ICkge1xyXG5cclxuXHRcdFx0XHRcdHVuaWZvcm1zQXJyYXlJbmRleCA9IHVuaWZvcm1zQXJyYXlbIGFycmF5SW5kZXggXSA9IHt9O1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHVuaWZvcm1zQXJyYXlJbmRleFsgYXJyYXlQcm9wZXJ0eSBdID0gbG9jYXRpb247XHJcblxyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bWF0Y2hlcyA9IGFycmF5UmUuZXhlYyggbmFtZSApO1xyXG5cclxuXHRcdFx0aWYgKCBtYXRjaGVzICkge1xyXG5cclxuXHRcdFx0XHR2YXIgYXJyYXlOYW1lID0gbWF0Y2hlc1sgMSBdO1xyXG5cclxuXHRcdFx0XHR1bmlmb3Jtc1sgYXJyYXlOYW1lIF0gPSBsb2NhdGlvbjtcclxuXHJcblx0XHRcdFx0Y29udGludWU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR1bmlmb3Jtc1sgbmFtZSBdID0gbG9jYXRpb247XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB1bmlmb3JtcztcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBmZXRjaEF0dHJpYnV0ZUxvY2F0aW9ucyggZ2wsIHByb2dyYW0sIGlkZW50aWZpZXJzICkge1xyXG5cclxuXHRcdHZhciBhdHRyaWJ1dGVzID0ge307XHJcblxyXG5cdFx0dmFyIG4gPSBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKCBwcm9ncmFtLCBnbC5BQ1RJVkVfQVRUUklCVVRFUyApO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IG47IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgaW5mbyA9IGdsLmdldEFjdGl2ZUF0dHJpYiggcHJvZ3JhbSwgaSApO1xyXG5cdFx0XHR2YXIgbmFtZSA9IGluZm8ubmFtZTtcclxuXHJcblx0XHRcdC8vIGNvbnNvbGUubG9nKFwiVEhSRUUuV2ViR0xQcm9ncmFtOiBBQ1RJVkUgVkVSVEVYIEFUVFJJQlVURTpcIiwgbmFtZSwgaSApO1xyXG5cclxuXHRcdFx0YXR0cmlidXRlc1sgbmFtZSBdID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24oIHByb2dyYW0sIG5hbWUgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGF0dHJpYnV0ZXM7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gZmlsdGVyRW1wdHlMaW5lKCBzdHJpbmcgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHN0cmluZyAhPT0gJyc7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gcmVwbGFjZUxpZ2h0TnVtcyggc3RyaW5nLCBwYXJhbWV0ZXJzICkge1xyXG5cclxuXHRcdHJldHVybiBzdHJpbmdcclxuXHRcdFx0LnJlcGxhY2UoIC9OVU1fRElSX0xJR0hUUy9nLCBwYXJhbWV0ZXJzLm51bURpckxpZ2h0cyApXHJcblx0XHRcdC5yZXBsYWNlKCAvTlVNX1NQT1RfTElHSFRTL2csIHBhcmFtZXRlcnMubnVtU3BvdExpZ2h0cyApXHJcblx0XHRcdC5yZXBsYWNlKCAvTlVNX1BPSU5UX0xJR0hUUy9nLCBwYXJhbWV0ZXJzLm51bVBvaW50TGlnaHRzIClcclxuXHRcdFx0LnJlcGxhY2UoIC9OVU1fSEVNSV9MSUdIVFMvZywgcGFyYW1ldGVycy5udW1IZW1pTGlnaHRzICk7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gdW5yb2xsTG9vcHMoIHN0cmluZyApIHtcclxuXHJcblx0XHR2YXIgcGF0dGVybiA9IC9mb3IgXFwoIGludCBpIFxcPSAoXFxkKylcXDsgaSA8IChcXGQrKVxcOyBpIFxcK1xcKyBcXCkgXFx7KFtcXHNcXFNdKz8pKD89XFx9KVxcfS9nO1xyXG5cclxuXHRcdGZ1bmN0aW9uIHJlcGxhY2UoIG1hdGNoLCBzdGFydCwgZW5kLCBzbmlwcGV0ICkge1xyXG5cclxuXHRcdFx0dmFyIHVucm9sbCA9ICcnO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSBwYXJzZUludCggc3RhcnQgKTsgaSA8IHBhcnNlSW50KCBlbmQgKTsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0dW5yb2xsICs9IHNuaXBwZXQucmVwbGFjZSggL1xcWyBpIFxcXS9nLCAnWyAnICsgaSArICcgXScgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiB1bnJvbGw7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBzdHJpbmcucmVwbGFjZSggcGF0dGVybiwgcmVwbGFjZSApO1xyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiBmdW5jdGlvbiBXZWJHTFByb2dyYW0oIHJlbmRlcmVyLCBjb2RlLCBtYXRlcmlhbCwgcGFyYW1ldGVycyApIHtcclxuXHJcblx0XHR2YXIgZ2wgPSByZW5kZXJlci5jb250ZXh0O1xyXG5cclxuXHRcdHZhciBleHRlbnNpb25zID0gbWF0ZXJpYWwuZXh0ZW5zaW9ucztcclxuXHRcdHZhciBkZWZpbmVzID0gbWF0ZXJpYWwuZGVmaW5lcztcclxuXHJcblx0XHR2YXIgdmVydGV4U2hhZGVyID0gbWF0ZXJpYWwuX193ZWJnbFNoYWRlci52ZXJ0ZXhTaGFkZXI7XHJcblx0XHR2YXIgZnJhZ21lbnRTaGFkZXIgPSBtYXRlcmlhbC5fX3dlYmdsU2hhZGVyLmZyYWdtZW50U2hhZGVyO1xyXG5cclxuXHRcdHZhciBzaGFkb3dNYXBUeXBlRGVmaW5lID0gJ1NIQURPV01BUF9UWVBFX0JBU0lDJztcclxuXHJcblx0XHRpZiAoIHBhcmFtZXRlcnMuc2hhZG93TWFwVHlwZSA9PT0gVEhSRUUuUENGU2hhZG93TWFwICkge1xyXG5cclxuXHRcdFx0c2hhZG93TWFwVHlwZURlZmluZSA9ICdTSEFET1dNQVBfVFlQRV9QQ0YnO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIHBhcmFtZXRlcnMuc2hhZG93TWFwVHlwZSA9PT0gVEhSRUUuUENGU29mdFNoYWRvd01hcCApIHtcclxuXHJcblx0XHRcdHNoYWRvd01hcFR5cGVEZWZpbmUgPSAnU0hBRE9XTUFQX1RZUEVfUENGX1NPRlQnO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZW52TWFwVHlwZURlZmluZSA9ICdFTlZNQVBfVFlQRV9DVUJFJztcclxuXHRcdHZhciBlbnZNYXBNb2RlRGVmaW5lID0gJ0VOVk1BUF9NT0RFX1JFRkxFQ1RJT04nO1xyXG5cdFx0dmFyIGVudk1hcEJsZW5kaW5nRGVmaW5lID0gJ0VOVk1BUF9CTEVORElOR19NVUxUSVBMWSc7XHJcblxyXG5cdFx0aWYgKCBwYXJhbWV0ZXJzLmVudk1hcCApIHtcclxuXHJcblx0XHRcdHN3aXRjaCAoIG1hdGVyaWFsLmVudk1hcC5tYXBwaW5nICkge1xyXG5cclxuXHRcdFx0XHRjYXNlIFRIUkVFLkN1YmVSZWZsZWN0aW9uTWFwcGluZzpcclxuXHRcdFx0XHRjYXNlIFRIUkVFLkN1YmVSZWZyYWN0aW9uTWFwcGluZzpcclxuXHRcdFx0XHRcdGVudk1hcFR5cGVEZWZpbmUgPSAnRU5WTUFQX1RZUEVfQ1VCRSc7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSBUSFJFRS5FcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZzpcclxuXHRcdFx0XHRjYXNlIFRIUkVFLkVxdWlyZWN0YW5ndWxhclJlZnJhY3Rpb25NYXBwaW5nOlxyXG5cdFx0XHRcdFx0ZW52TWFwVHlwZURlZmluZSA9ICdFTlZNQVBfVFlQRV9FUVVJUkVDJztcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlIFRIUkVFLlNwaGVyaWNhbFJlZmxlY3Rpb25NYXBwaW5nOlxyXG5cdFx0XHRcdFx0ZW52TWFwVHlwZURlZmluZSA9ICdFTlZNQVBfVFlQRV9TUEhFUkUnO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRzd2l0Y2ggKCBtYXRlcmlhbC5lbnZNYXAubWFwcGluZyApIHtcclxuXHJcblx0XHRcdFx0Y2FzZSBUSFJFRS5DdWJlUmVmcmFjdGlvbk1hcHBpbmc6XHJcblx0XHRcdFx0Y2FzZSBUSFJFRS5FcXVpcmVjdGFuZ3VsYXJSZWZyYWN0aW9uTWFwcGluZzpcclxuXHRcdFx0XHRcdGVudk1hcE1vZGVEZWZpbmUgPSAnRU5WTUFQX01PREVfUkVGUkFDVElPTic7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHN3aXRjaCAoIG1hdGVyaWFsLmNvbWJpbmUgKSB7XHJcblxyXG5cdFx0XHRcdGNhc2UgVEhSRUUuTXVsdGlwbHlPcGVyYXRpb246XHJcblx0XHRcdFx0XHRlbnZNYXBCbGVuZGluZ0RlZmluZSA9ICdFTlZNQVBfQkxFTkRJTkdfTVVMVElQTFknO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgVEhSRUUuTWl4T3BlcmF0aW9uOlxyXG5cdFx0XHRcdFx0ZW52TWFwQmxlbmRpbmdEZWZpbmUgPSAnRU5WTUFQX0JMRU5ESU5HX01JWCc7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSBUSFJFRS5BZGRPcGVyYXRpb246XHJcblx0XHRcdFx0XHRlbnZNYXBCbGVuZGluZ0RlZmluZSA9ICdFTlZNQVBfQkxFTkRJTkdfQUREJztcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZ2FtbWFGYWN0b3JEZWZpbmUgPSAoIHJlbmRlcmVyLmdhbW1hRmFjdG9yID4gMCApID8gcmVuZGVyZXIuZ2FtbWFGYWN0b3IgOiAxLjA7XHJcblxyXG5cdFx0Ly8gY29uc29sZS5sb2coICdidWlsZGluZyBuZXcgcHJvZ3JhbSAnICk7XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHR2YXIgY3VzdG9tRXh0ZW5zaW9ucyA9IGdlbmVyYXRlRXh0ZW5zaW9ucyggZXh0ZW5zaW9ucywgcGFyYW1ldGVycywgcmVuZGVyZXIuZXh0ZW5zaW9ucyApO1xyXG5cclxuXHRcdHZhciBjdXN0b21EZWZpbmVzID0gZ2VuZXJhdGVEZWZpbmVzKCBkZWZpbmVzICk7XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHR2YXIgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcclxuXHJcblx0XHR2YXIgcHJlZml4VmVydGV4LCBwcmVmaXhGcmFnbWVudDtcclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuUmF3U2hhZGVyTWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHRwcmVmaXhWZXJ0ZXggPSAnJztcclxuXHRcdFx0cHJlZml4RnJhZ21lbnQgPSAnJztcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0cHJlZml4VmVydGV4ID0gW1xyXG5cclxuXHRcdFx0XHQncHJlY2lzaW9uICcgKyBwYXJhbWV0ZXJzLnByZWNpc2lvbiArICcgZmxvYXQ7JyxcclxuXHRcdFx0XHQncHJlY2lzaW9uICcgKyBwYXJhbWV0ZXJzLnByZWNpc2lvbiArICcgaW50OycsXHJcblxyXG5cdFx0XHRcdCcjZGVmaW5lIFNIQURFUl9OQU1FICcgKyBtYXRlcmlhbC5fX3dlYmdsU2hhZGVyLm5hbWUsXHJcblxyXG5cdFx0XHRcdGN1c3RvbURlZmluZXMsXHJcblxyXG5cdFx0XHRcdHBhcmFtZXRlcnMuc3VwcG9ydHNWZXJ0ZXhUZXh0dXJlcyA/ICcjZGVmaW5lIFZFUlRFWF9URVhUVVJFUycgOiAnJyxcclxuXHJcblx0XHRcdFx0cmVuZGVyZXIuZ2FtbWFJbnB1dCA/ICcjZGVmaW5lIEdBTU1BX0lOUFVUJyA6ICcnLFxyXG5cdFx0XHRcdHJlbmRlcmVyLmdhbW1hT3V0cHV0ID8gJyNkZWZpbmUgR0FNTUFfT1VUUFVUJyA6ICcnLFxyXG5cdFx0XHRcdCcjZGVmaW5lIEdBTU1BX0ZBQ1RPUiAnICsgZ2FtbWFGYWN0b3JEZWZpbmUsXHJcblxyXG5cdFx0XHRcdCcjZGVmaW5lIE1BWF9CT05FUyAnICsgcGFyYW1ldGVycy5tYXhCb25lcyxcclxuXHJcblx0XHRcdFx0cGFyYW1ldGVycy5tYXAgPyAnI2RlZmluZSBVU0VfTUFQJyA6ICcnLFxyXG5cdFx0XHRcdHBhcmFtZXRlcnMuZW52TWFwID8gJyNkZWZpbmUgVVNFX0VOVk1BUCcgOiAnJyxcclxuXHRcdFx0XHRwYXJhbWV0ZXJzLmVudk1hcCA/ICcjZGVmaW5lICcgKyBlbnZNYXBNb2RlRGVmaW5lIDogJycsXHJcblx0XHRcdFx0cGFyYW1ldGVycy5saWdodE1hcCA/ICcjZGVmaW5lIFVTRV9MSUdIVE1BUCcgOiAnJyxcclxuXHRcdFx0XHRwYXJhbWV0ZXJzLmFvTWFwID8gJyNkZWZpbmUgVVNFX0FPTUFQJyA6ICcnLFxyXG5cdFx0XHRcdHBhcmFtZXRlcnMuZW1pc3NpdmVNYXAgPyAnI2RlZmluZSBVU0VfRU1JU1NJVkVNQVAnIDogJycsXHJcblx0XHRcdFx0cGFyYW1ldGVycy5idW1wTWFwID8gJyNkZWZpbmUgVVNFX0JVTVBNQVAnIDogJycsXHJcblx0XHRcdFx0cGFyYW1ldGVycy5ub3JtYWxNYXAgPyAnI2RlZmluZSBVU0VfTk9STUFMTUFQJyA6ICcnLFxyXG5cdFx0XHRcdHBhcmFtZXRlcnMuZGlzcGxhY2VtZW50TWFwICYmIHBhcmFtZXRlcnMuc3VwcG9ydHNWZXJ0ZXhUZXh0dXJlcyA/ICcjZGVmaW5lIFVTRV9ESVNQTEFDRU1FTlRNQVAnIDogJycsXHJcblx0XHRcdFx0cGFyYW1ldGVycy5zcGVjdWxhck1hcCA/ICcjZGVmaW5lIFVTRV9TUEVDVUxBUk1BUCcgOiAnJyxcclxuXHRcdFx0XHRwYXJhbWV0ZXJzLnJvdWdobmVzc01hcCA/ICcjZGVmaW5lIFVTRV9ST1VHSE5FU1NNQVAnIDogJycsXHJcblx0XHRcdFx0cGFyYW1ldGVycy5tZXRhbG5lc3NNYXAgPyAnI2RlZmluZSBVU0VfTUVUQUxORVNTTUFQJyA6ICcnLFxyXG5cdFx0XHRcdHBhcmFtZXRlcnMuYWxwaGFNYXAgPyAnI2RlZmluZSBVU0VfQUxQSEFNQVAnIDogJycsXHJcblx0XHRcdFx0cGFyYW1ldGVycy52ZXJ0ZXhDb2xvcnMgPyAnI2RlZmluZSBVU0VfQ09MT1InIDogJycsXHJcblxyXG5cdFx0XHRcdHBhcmFtZXRlcnMuZmxhdFNoYWRpbmcgPyAnI2RlZmluZSBGTEFUX1NIQURFRCcgOiAnJyxcclxuXHJcblx0XHRcdFx0cGFyYW1ldGVycy5za2lubmluZyA/ICcjZGVmaW5lIFVTRV9TS0lOTklORycgOiAnJyxcclxuXHRcdFx0XHRwYXJhbWV0ZXJzLnVzZVZlcnRleFRleHR1cmUgPyAnI2RlZmluZSBCT05FX1RFWFRVUkUnIDogJycsXHJcblxyXG5cdFx0XHRcdHBhcmFtZXRlcnMubW9ycGhUYXJnZXRzID8gJyNkZWZpbmUgVVNFX01PUlBIVEFSR0VUUycgOiAnJyxcclxuXHRcdFx0XHRwYXJhbWV0ZXJzLm1vcnBoTm9ybWFscyAmJiBwYXJhbWV0ZXJzLmZsYXRTaGFkaW5nID09PSBmYWxzZSA/ICcjZGVmaW5lIFVTRV9NT1JQSE5PUk1BTFMnIDogJycsXHJcblx0XHRcdFx0cGFyYW1ldGVycy5kb3VibGVTaWRlZCA/ICcjZGVmaW5lIERPVUJMRV9TSURFRCcgOiAnJyxcclxuXHRcdFx0XHRwYXJhbWV0ZXJzLmZsaXBTaWRlZCA/ICcjZGVmaW5lIEZMSVBfU0lERUQnIDogJycsXHJcblxyXG5cdFx0XHRcdHBhcmFtZXRlcnMuc2hhZG93TWFwRW5hYmxlZCA/ICcjZGVmaW5lIFVTRV9TSEFET1dNQVAnIDogJycsXHJcblx0XHRcdFx0cGFyYW1ldGVycy5zaGFkb3dNYXBFbmFibGVkID8gJyNkZWZpbmUgJyArIHNoYWRvd01hcFR5cGVEZWZpbmUgOiAnJyxcclxuXHRcdFx0XHRwYXJhbWV0ZXJzLnBvaW50TGlnaHRTaGFkb3dzID4gMCA/ICcjZGVmaW5lIFBPSU5UX0xJR0hUX1NIQURPV1MnIDogJycsXHJcblxyXG5cdFx0XHRcdHBhcmFtZXRlcnMuc2l6ZUF0dGVudWF0aW9uID8gJyNkZWZpbmUgVVNFX1NJWkVBVFRFTlVBVElPTicgOiAnJyxcclxuXHJcblx0XHRcdFx0cGFyYW1ldGVycy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyID8gJyNkZWZpbmUgVVNFX0xPR0RFUFRIQlVGJyA6ICcnLFxyXG5cdFx0XHRcdHBhcmFtZXRlcnMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciAmJiByZW5kZXJlci5leHRlbnNpb25zLmdldCggJ0VYVF9mcmFnX2RlcHRoJyApID8gJyNkZWZpbmUgVVNFX0xPR0RFUFRIQlVGX0VYVCcgOiAnJyxcclxuXHJcblxyXG5cdFx0XHRcdCd1bmlmb3JtIG1hdDQgbW9kZWxNYXRyaXg7JyxcclxuXHRcdFx0XHQndW5pZm9ybSBtYXQ0IG1vZGVsVmlld01hdHJpeDsnLFxyXG5cdFx0XHRcdCd1bmlmb3JtIG1hdDQgcHJvamVjdGlvbk1hdHJpeDsnLFxyXG5cdFx0XHRcdCd1bmlmb3JtIG1hdDQgdmlld01hdHJpeDsnLFxyXG5cdFx0XHRcdCd1bmlmb3JtIG1hdDMgbm9ybWFsTWF0cml4OycsXHJcblx0XHRcdFx0J3VuaWZvcm0gdmVjMyBjYW1lcmFQb3NpdGlvbjsnLFxyXG5cclxuXHRcdFx0XHQnYXR0cmlidXRlIHZlYzMgcG9zaXRpb247JyxcclxuXHRcdFx0XHQnYXR0cmlidXRlIHZlYzMgbm9ybWFsOycsXHJcblx0XHRcdFx0J2F0dHJpYnV0ZSB2ZWMyIHV2OycsXHJcblxyXG5cdFx0XHRcdCcjaWZkZWYgVVNFX0NPTE9SJyxcclxuXHJcblx0XHRcdFx0J1x0YXR0cmlidXRlIHZlYzMgY29sb3I7JyxcclxuXHJcblx0XHRcdFx0JyNlbmRpZicsXHJcblxyXG5cdFx0XHRcdCcjaWZkZWYgVVNFX01PUlBIVEFSR0VUUycsXHJcblxyXG5cdFx0XHRcdCdcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0MDsnLFxyXG5cdFx0XHRcdCdcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0MTsnLFxyXG5cdFx0XHRcdCdcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0MjsnLFxyXG5cdFx0XHRcdCdcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0MzsnLFxyXG5cclxuXHRcdFx0XHQnXHQjaWZkZWYgVVNFX01PUlBITk9STUFMUycsXHJcblxyXG5cdFx0XHRcdCdcdFx0YXR0cmlidXRlIHZlYzMgbW9ycGhOb3JtYWwwOycsXHJcblx0XHRcdFx0J1x0XHRhdHRyaWJ1dGUgdmVjMyBtb3JwaE5vcm1hbDE7JyxcclxuXHRcdFx0XHQnXHRcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoTm9ybWFsMjsnLFxyXG5cdFx0XHRcdCdcdFx0YXR0cmlidXRlIHZlYzMgbW9ycGhOb3JtYWwzOycsXHJcblxyXG5cdFx0XHRcdCdcdCNlbHNlJyxcclxuXHJcblx0XHRcdFx0J1x0XHRhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDQ7JyxcclxuXHRcdFx0XHQnXHRcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0NTsnLFxyXG5cdFx0XHRcdCdcdFx0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQ2OycsXHJcblx0XHRcdFx0J1x0XHRhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDc7JyxcclxuXHJcblx0XHRcdFx0J1x0I2VuZGlmJyxcclxuXHJcblx0XHRcdFx0JyNlbmRpZicsXHJcblxyXG5cdFx0XHRcdCcjaWZkZWYgVVNFX1NLSU5OSU5HJyxcclxuXHJcblx0XHRcdFx0J1x0YXR0cmlidXRlIHZlYzQgc2tpbkluZGV4OycsXHJcblx0XHRcdFx0J1x0YXR0cmlidXRlIHZlYzQgc2tpbldlaWdodDsnLFxyXG5cclxuXHRcdFx0XHQnI2VuZGlmJyxcclxuXHJcblx0XHRcdFx0J1xcbidcclxuXHJcblx0XHRcdF0uZmlsdGVyKCBmaWx0ZXJFbXB0eUxpbmUgKS5qb2luKCAnXFxuJyApO1xyXG5cclxuXHJcblx0XHRcdHByZWZpeEZyYWdtZW50ID0gW1xyXG5cclxuXHRcdFx0XHRjdXN0b21FeHRlbnNpb25zLFxyXG5cclxuXHRcdFx0XHQncHJlY2lzaW9uICcgKyBwYXJhbWV0ZXJzLnByZWNpc2lvbiArICcgZmxvYXQ7JyxcclxuXHRcdFx0XHQncHJlY2lzaW9uICcgKyBwYXJhbWV0ZXJzLnByZWNpc2lvbiArICcgaW50OycsXHJcblxyXG5cdFx0XHRcdCcjZGVmaW5lIFNIQURFUl9OQU1FICcgKyBtYXRlcmlhbC5fX3dlYmdsU2hhZGVyLm5hbWUsXHJcblxyXG5cdFx0XHRcdGN1c3RvbURlZmluZXMsXHJcblxyXG5cdFx0XHRcdHBhcmFtZXRlcnMuYWxwaGFUZXN0ID8gJyNkZWZpbmUgQUxQSEFURVNUICcgKyBwYXJhbWV0ZXJzLmFscGhhVGVzdCA6ICcnLFxyXG5cclxuXHRcdFx0XHRyZW5kZXJlci5nYW1tYUlucHV0ID8gJyNkZWZpbmUgR0FNTUFfSU5QVVQnIDogJycsXHJcblx0XHRcdFx0cmVuZGVyZXIuZ2FtbWFPdXRwdXQgPyAnI2RlZmluZSBHQU1NQV9PVVRQVVQnIDogJycsXHJcblx0XHRcdFx0JyNkZWZpbmUgR0FNTUFfRkFDVE9SICcgKyBnYW1tYUZhY3RvckRlZmluZSxcclxuXHJcblx0XHRcdFx0KCBwYXJhbWV0ZXJzLnVzZUZvZyAmJiBwYXJhbWV0ZXJzLmZvZyApID8gJyNkZWZpbmUgVVNFX0ZPRycgOiAnJyxcclxuXHRcdFx0XHQoIHBhcmFtZXRlcnMudXNlRm9nICYmIHBhcmFtZXRlcnMuZm9nRXhwICkgPyAnI2RlZmluZSBGT0dfRVhQMicgOiAnJyxcclxuXHJcblx0XHRcdFx0cGFyYW1ldGVycy5tYXAgPyAnI2RlZmluZSBVU0VfTUFQJyA6ICcnLFxyXG5cdFx0XHRcdHBhcmFtZXRlcnMuZW52TWFwID8gJyNkZWZpbmUgVVNFX0VOVk1BUCcgOiAnJyxcclxuXHRcdFx0XHRwYXJhbWV0ZXJzLmVudk1hcCA/ICcjZGVmaW5lICcgKyBlbnZNYXBUeXBlRGVmaW5lIDogJycsXHJcblx0XHRcdFx0cGFyYW1ldGVycy5lbnZNYXAgPyAnI2RlZmluZSAnICsgZW52TWFwTW9kZURlZmluZSA6ICcnLFxyXG5cdFx0XHRcdHBhcmFtZXRlcnMuZW52TWFwID8gJyNkZWZpbmUgJyArIGVudk1hcEJsZW5kaW5nRGVmaW5lIDogJycsXHJcblx0XHRcdFx0cGFyYW1ldGVycy5saWdodE1hcCA/ICcjZGVmaW5lIFVTRV9MSUdIVE1BUCcgOiAnJyxcclxuXHRcdFx0XHRwYXJhbWV0ZXJzLmFvTWFwID8gJyNkZWZpbmUgVVNFX0FPTUFQJyA6ICcnLFxyXG5cdFx0XHRcdHBhcmFtZXRlcnMuZW1pc3NpdmVNYXAgPyAnI2RlZmluZSBVU0VfRU1JU1NJVkVNQVAnIDogJycsXHJcblx0XHRcdFx0cGFyYW1ldGVycy5idW1wTWFwID8gJyNkZWZpbmUgVVNFX0JVTVBNQVAnIDogJycsXHJcblx0XHRcdFx0cGFyYW1ldGVycy5ub3JtYWxNYXAgPyAnI2RlZmluZSBVU0VfTk9STUFMTUFQJyA6ICcnLFxyXG5cdFx0XHRcdHBhcmFtZXRlcnMuc3BlY3VsYXJNYXAgPyAnI2RlZmluZSBVU0VfU1BFQ1VMQVJNQVAnIDogJycsXHJcblx0XHRcdFx0cGFyYW1ldGVycy5yb3VnaG5lc3NNYXAgPyAnI2RlZmluZSBVU0VfUk9VR0hORVNTTUFQJyA6ICcnLFxyXG5cdFx0XHRcdHBhcmFtZXRlcnMubWV0YWxuZXNzTWFwID8gJyNkZWZpbmUgVVNFX01FVEFMTkVTU01BUCcgOiAnJyxcclxuXHRcdFx0XHRwYXJhbWV0ZXJzLmFscGhhTWFwID8gJyNkZWZpbmUgVVNFX0FMUEhBTUFQJyA6ICcnLFxyXG5cdFx0XHRcdHBhcmFtZXRlcnMudmVydGV4Q29sb3JzID8gJyNkZWZpbmUgVVNFX0NPTE9SJyA6ICcnLFxyXG5cclxuXHRcdFx0XHRwYXJhbWV0ZXJzLmZsYXRTaGFkaW5nID8gJyNkZWZpbmUgRkxBVF9TSEFERUQnIDogJycsXHJcblxyXG5cdFx0XHRcdHBhcmFtZXRlcnMuZG91YmxlU2lkZWQgPyAnI2RlZmluZSBET1VCTEVfU0lERUQnIDogJycsXHJcblx0XHRcdFx0cGFyYW1ldGVycy5mbGlwU2lkZWQgPyAnI2RlZmluZSBGTElQX1NJREVEJyA6ICcnLFxyXG5cclxuXHRcdFx0XHRwYXJhbWV0ZXJzLnNoYWRvd01hcEVuYWJsZWQgPyAnI2RlZmluZSBVU0VfU0hBRE9XTUFQJyA6ICcnLFxyXG5cdFx0XHRcdHBhcmFtZXRlcnMuc2hhZG93TWFwRW5hYmxlZCA/ICcjZGVmaW5lICcgKyBzaGFkb3dNYXBUeXBlRGVmaW5lIDogJycsXHJcblx0XHRcdFx0cGFyYW1ldGVycy5wb2ludExpZ2h0U2hhZG93cyA+IDAgPyAnI2RlZmluZSBQT0lOVF9MSUdIVF9TSEFET1dTJyA6ICcnLFxyXG5cclxuXHRcdFx0XHRwYXJhbWV0ZXJzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgPyAnI2RlZmluZSBVU0VfTE9HREVQVEhCVUYnIDogJycsXHJcblx0XHRcdFx0cGFyYW1ldGVycy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyICYmIHJlbmRlcmVyLmV4dGVuc2lvbnMuZ2V0KCAnRVhUX2ZyYWdfZGVwdGgnICkgPyAnI2RlZmluZSBVU0VfTE9HREVQVEhCVUZfRVhUJyA6ICcnLFxyXG5cclxuXHRcdFx0XHRwYXJhbWV0ZXJzLmVudk1hcCAmJiByZW5kZXJlci5leHRlbnNpb25zLmdldCggJ0VYVF9zaGFkZXJfdGV4dHVyZV9sb2QnICkgPyAnI2RlZmluZSBURVhUVVJFX0xPRF9FWFQnIDogJycsXHJcblxyXG5cdFx0XHRcdCd1bmlmb3JtIG1hdDQgdmlld01hdHJpeDsnLFxyXG5cdFx0XHRcdCd1bmlmb3JtIHZlYzMgY2FtZXJhUG9zaXRpb247JyxcclxuXHJcblx0XHRcdFx0J1xcbidcclxuXHJcblx0XHRcdF0uZmlsdGVyKCBmaWx0ZXJFbXB0eUxpbmUgKS5qb2luKCAnXFxuJyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2ZXJ0ZXhTaGFkZXIgPSByZXBsYWNlTGlnaHROdW1zKCB2ZXJ0ZXhTaGFkZXIsIHBhcmFtZXRlcnMgKTtcclxuXHRcdGZyYWdtZW50U2hhZGVyID0gcmVwbGFjZUxpZ2h0TnVtcyggZnJhZ21lbnRTaGFkZXIsIHBhcmFtZXRlcnMgKTtcclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuU2hhZGVyTWF0ZXJpYWwgPT09IGZhbHNlICkge1xyXG5cclxuXHRcdFx0dmVydGV4U2hhZGVyID0gdW5yb2xsTG9vcHMoIHZlcnRleFNoYWRlciApO1xyXG5cdFx0XHRmcmFnbWVudFNoYWRlciA9IHVucm9sbExvb3BzKCBmcmFnbWVudFNoYWRlciApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgdmVydGV4R2xzbCA9IHByZWZpeFZlcnRleCArIHZlcnRleFNoYWRlcjtcclxuXHRcdHZhciBmcmFnbWVudEdsc2wgPSBwcmVmaXhGcmFnbWVudCArIGZyYWdtZW50U2hhZGVyO1xyXG5cclxuXHRcdC8vIGNvbnNvbGUubG9nKCAnKlZFUlRFWConLCB2ZXJ0ZXhHbHNsICk7XHJcblx0XHQvLyBjb25zb2xlLmxvZyggJypGUkFHTUVOVConLCBmcmFnbWVudEdsc2wgKTtcclxuXHJcblx0XHR2YXIgZ2xWZXJ0ZXhTaGFkZXIgPSBUSFJFRS5XZWJHTFNoYWRlciggZ2wsIGdsLlZFUlRFWF9TSEFERVIsIHZlcnRleEdsc2wgKTtcclxuXHRcdHZhciBnbEZyYWdtZW50U2hhZGVyID0gVEhSRUUuV2ViR0xTaGFkZXIoIGdsLCBnbC5GUkFHTUVOVF9TSEFERVIsIGZyYWdtZW50R2xzbCApO1xyXG5cclxuXHRcdGdsLmF0dGFjaFNoYWRlciggcHJvZ3JhbSwgZ2xWZXJ0ZXhTaGFkZXIgKTtcclxuXHRcdGdsLmF0dGFjaFNoYWRlciggcHJvZ3JhbSwgZ2xGcmFnbWVudFNoYWRlciApO1xyXG5cclxuXHRcdC8vIEZvcmNlIGEgcGFydGljdWxhciBhdHRyaWJ1dGUgdG8gaW5kZXggMC5cclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsLmluZGV4MEF0dHJpYnV0ZU5hbWUgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGdsLmJpbmRBdHRyaWJMb2NhdGlvbiggcHJvZ3JhbSwgMCwgbWF0ZXJpYWwuaW5kZXgwQXR0cmlidXRlTmFtZSApO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIHBhcmFtZXRlcnMubW9ycGhUYXJnZXRzID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0Ly8gcHJvZ3JhbXMgd2l0aCBtb3JwaFRhcmdldHMgZGlzcGxhY2UgcG9zaXRpb24gb3V0IG9mIGF0dHJpYnV0ZSAwXHJcblx0XHRcdGdsLmJpbmRBdHRyaWJMb2NhdGlvbiggcHJvZ3JhbSwgMCwgJ3Bvc2l0aW9uJyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRnbC5saW5rUHJvZ3JhbSggcHJvZ3JhbSApO1xyXG5cclxuXHRcdHZhciBwcm9ncmFtTG9nID0gZ2wuZ2V0UHJvZ3JhbUluZm9Mb2coIHByb2dyYW0gKTtcclxuXHRcdHZhciB2ZXJ0ZXhMb2cgPSBnbC5nZXRTaGFkZXJJbmZvTG9nKCBnbFZlcnRleFNoYWRlciApO1xyXG5cdFx0dmFyIGZyYWdtZW50TG9nID0gZ2wuZ2V0U2hhZGVySW5mb0xvZyggZ2xGcmFnbWVudFNoYWRlciApO1xyXG5cclxuXHRcdHZhciBydW5uYWJsZSA9IHRydWU7XHJcblx0XHR2YXIgaGF2ZURpYWdub3N0aWNzID0gdHJ1ZTtcclxuXHJcblx0XHQvLyBjb25zb2xlLmxvZyggJyoqVkVSVEVYKionLCBnbC5nZXRFeHRlbnNpb24oICdXRUJHTF9kZWJ1Z19zaGFkZXJzJyApLmdldFRyYW5zbGF0ZWRTaGFkZXJTb3VyY2UoIGdsVmVydGV4U2hhZGVyICkgKTtcclxuXHRcdC8vIGNvbnNvbGUubG9nKCAnKipGUkFHTUVOVCoqJywgZ2wuZ2V0RXh0ZW5zaW9uKCAnV0VCR0xfZGVidWdfc2hhZGVycycgKS5nZXRUcmFuc2xhdGVkU2hhZGVyU291cmNlKCBnbEZyYWdtZW50U2hhZGVyICkgKTtcclxuXHJcblx0XHRpZiAoIGdsLmdldFByb2dyYW1QYXJhbWV0ZXIoIHByb2dyYW0sIGdsLkxJTktfU1RBVFVTICkgPT09IGZhbHNlICkge1xyXG5cclxuXHRcdFx0cnVubmFibGUgPSBmYWxzZTtcclxuXHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFByb2dyYW06IHNoYWRlciBlcnJvcjogJywgZ2wuZ2V0RXJyb3IoKSwgJ2dsLlZBTElEQVRFX1NUQVRVUycsIGdsLmdldFByb2dyYW1QYXJhbWV0ZXIoIHByb2dyYW0sIGdsLlZBTElEQVRFX1NUQVRVUyApLCAnZ2wuZ2V0UHJvZ3JhbUluZm9Mb2cnLCBwcm9ncmFtTG9nLCB2ZXJ0ZXhMb2csIGZyYWdtZW50TG9nICk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggcHJvZ3JhbUxvZyAhPT0gJycgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFByb2dyYW06IGdsLmdldFByb2dyYW1JbmZvTG9nKCknLCBwcm9ncmFtTG9nICk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggdmVydGV4TG9nID09PSAnJyB8fCBmcmFnbWVudExvZyA9PT0gJycgKSB7XHJcblxyXG5cdFx0XHRoYXZlRGlhZ25vc3RpY3MgPSBmYWxzZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBoYXZlRGlhZ25vc3RpY3MgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmRpYWdub3N0aWNzID0ge1xyXG5cclxuXHRcdFx0XHRydW5uYWJsZTogcnVubmFibGUsXHJcblx0XHRcdFx0bWF0ZXJpYWw6IG1hdGVyaWFsLFxyXG5cclxuXHRcdFx0XHRwcm9ncmFtTG9nOiBwcm9ncmFtTG9nLFxyXG5cclxuXHRcdFx0XHR2ZXJ0ZXhTaGFkZXI6IHtcclxuXHJcblx0XHRcdFx0XHRsb2c6IHZlcnRleExvZyxcclxuXHRcdFx0XHRcdHByZWZpeDogcHJlZml4VmVydGV4XHJcblxyXG5cdFx0XHRcdH0sXHJcblxyXG5cdFx0XHRcdGZyYWdtZW50U2hhZGVyOiB7XHJcblxyXG5cdFx0XHRcdFx0bG9nOiBmcmFnbWVudExvZyxcclxuXHRcdFx0XHRcdHByZWZpeDogcHJlZml4RnJhZ21lbnRcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gY2xlYW4gdXBcclxuXHJcblx0XHRnbC5kZWxldGVTaGFkZXIoIGdsVmVydGV4U2hhZGVyICk7XHJcblx0XHRnbC5kZWxldGVTaGFkZXIoIGdsRnJhZ21lbnRTaGFkZXIgKTtcclxuXHJcblx0XHQvLyBzZXQgdXAgY2FjaGluZyBmb3IgdW5pZm9ybSBsb2NhdGlvbnNcclxuXHJcblx0XHR2YXIgY2FjaGVkVW5pZm9ybXM7XHJcblxyXG5cdFx0dGhpcy5nZXRVbmlmb3JtcyA9IGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdFx0aWYgKCBjYWNoZWRVbmlmb3JtcyA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRjYWNoZWRVbmlmb3JtcyA9IGZldGNoVW5pZm9ybUxvY2F0aW9ucyggZ2wsIHByb2dyYW0gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBjYWNoZWRVbmlmb3JtcztcclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdC8vIHNldCB1cCBjYWNoaW5nIGZvciBhdHRyaWJ1dGUgbG9jYXRpb25zXHJcblxyXG5cdFx0dmFyIGNhY2hlZEF0dHJpYnV0ZXM7XHJcblxyXG5cdFx0dGhpcy5nZXRBdHRyaWJ1dGVzID0gZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0XHRpZiAoIGNhY2hlZEF0dHJpYnV0ZXMgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0Y2FjaGVkQXR0cmlidXRlcyA9IGZldGNoQXR0cmlidXRlTG9jYXRpb25zKCBnbCwgcHJvZ3JhbSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIGNhY2hlZEF0dHJpYnV0ZXM7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHQvLyBmcmVlIHJlc291cmNlXHJcblxyXG5cdFx0dGhpcy5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0XHRnbC5kZWxldGVQcm9ncmFtKCBwcm9ncmFtICk7XHJcblx0XHRcdHRoaXMucHJvZ3JhbSA9IHVuZGVmaW5lZDtcclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdC8vIERFUFJFQ0FURURcclxuXHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyggdGhpcywge1xyXG5cclxuXHRcdFx0dW5pZm9ybXM6IHtcclxuXHRcdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUHJvZ3JhbTogLnVuaWZvcm1zIGlzIG5vdyAuZ2V0VW5pZm9ybXMoKS4nICk7XHJcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5nZXRVbmlmb3JtcygpO1xyXG5cclxuXHRcdFx0XHR9XHJcblx0XHRcdH0sXHJcblxyXG5cdFx0XHRhdHRyaWJ1dGVzOiB7XHJcblx0XHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuXHJcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFByb2dyYW06IC5hdHRyaWJ1dGVzIGlzIG5vdyAuZ2V0QXR0cmlidXRlcygpLicgKTtcclxuXHRcdFx0XHRcdHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZXMoKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSApO1xyXG5cclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdHRoaXMuaWQgPSBwcm9ncmFtSWRDb3VudCArKztcclxuXHRcdHRoaXMuY29kZSA9IGNvZGU7XHJcblx0XHR0aGlzLnVzZWRUaW1lcyA9IDE7XHJcblx0XHR0aGlzLnByb2dyYW0gPSBwcm9ncmFtO1xyXG5cdFx0dGhpcy52ZXJ0ZXhTaGFkZXIgPSBnbFZlcnRleFNoYWRlcjtcclxuXHRcdHRoaXMuZnJhZ21lbnRTaGFkZXIgPSBnbEZyYWdtZW50U2hhZGVyO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9O1xyXG5cclxufSApKCk7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xQcm9ncmFtcy5qc1xyXG5cclxuVEhSRUUuV2ViR0xQcm9ncmFtcyA9IGZ1bmN0aW9uICggcmVuZGVyZXIsIGNhcGFiaWxpdGllcyApIHtcclxuXHJcblx0dmFyIHByb2dyYW1zID0gW107XHJcblxyXG5cdHZhciBzaGFkZXJJRHMgPSB7XHJcblx0XHRNZXNoRGVwdGhNYXRlcmlhbDogJ2RlcHRoJyxcclxuXHRcdE1lc2hOb3JtYWxNYXRlcmlhbDogJ25vcm1hbCcsXHJcblx0XHRNZXNoQmFzaWNNYXRlcmlhbDogJ2Jhc2ljJyxcclxuXHRcdE1lc2hMYW1iZXJ0TWF0ZXJpYWw6ICdsYW1iZXJ0JyxcclxuXHRcdE1lc2hQaG9uZ01hdGVyaWFsOiAncGhvbmcnLFxyXG5cdFx0TWVzaFN0YW5kYXJkTWF0ZXJpYWw6ICdzdGFuZGFyZCcsXHJcblx0XHRMaW5lQmFzaWNNYXRlcmlhbDogJ2Jhc2ljJyxcclxuXHRcdExpbmVEYXNoZWRNYXRlcmlhbDogJ2Rhc2hlZCcsXHJcblx0XHRQb2ludHNNYXRlcmlhbDogJ3BvaW50cydcclxuXHR9O1xyXG5cclxuXHR2YXIgcGFyYW1ldGVyTmFtZXMgPSBbXHJcblx0XHRcInByZWNpc2lvblwiLCBcInN1cHBvcnRzVmVydGV4VGV4dHVyZXNcIiwgXCJtYXBcIiwgXCJlbnZNYXBcIiwgXCJlbnZNYXBNb2RlXCIsXHJcblx0XHRcImxpZ2h0TWFwXCIsIFwiYW9NYXBcIiwgXCJlbWlzc2l2ZU1hcFwiLCBcImJ1bXBNYXBcIiwgXCJub3JtYWxNYXBcIiwgXCJkaXNwbGFjZW1lbnRNYXBcIiwgXCJzcGVjdWxhck1hcFwiLFxyXG5cdFx0XCJyb3VnaG5lc3NNYXBcIiwgXCJtZXRhbG5lc3NNYXBcIixcclxuXHRcdFwiYWxwaGFNYXBcIiwgXCJjb21iaW5lXCIsIFwidmVydGV4Q29sb3JzXCIsIFwiZm9nXCIsIFwidXNlRm9nXCIsIFwiZm9nRXhwXCIsXHJcblx0XHRcImZsYXRTaGFkaW5nXCIsIFwic2l6ZUF0dGVudWF0aW9uXCIsIFwibG9nYXJpdGhtaWNEZXB0aEJ1ZmZlclwiLCBcInNraW5uaW5nXCIsXHJcblx0XHRcIm1heEJvbmVzXCIsIFwidXNlVmVydGV4VGV4dHVyZVwiLCBcIm1vcnBoVGFyZ2V0c1wiLCBcIm1vcnBoTm9ybWFsc1wiLFxyXG5cdFx0XCJtYXhNb3JwaFRhcmdldHNcIiwgXCJtYXhNb3JwaE5vcm1hbHNcIixcclxuXHRcdFwibnVtRGlyTGlnaHRzXCIsIFwibnVtUG9pbnRMaWdodHNcIiwgXCJudW1TcG90TGlnaHRzXCIsIFwibnVtSGVtaUxpZ2h0c1wiLFxyXG5cdFx0XCJzaGFkb3dNYXBFbmFibGVkXCIsIFwicG9pbnRMaWdodFNoYWRvd3NcIixcclxuXHRcdFwic2hhZG93TWFwVHlwZVwiLFxyXG5cdFx0XCJhbHBoYVRlc3RcIiwgXCJkb3VibGVTaWRlZFwiLCBcImZsaXBTaWRlZFwiXHJcblx0XTtcclxuXHJcblxyXG5cdGZ1bmN0aW9uIGFsbG9jYXRlQm9uZXMgKCBvYmplY3QgKSB7XHJcblxyXG5cdFx0aWYgKCBjYXBhYmlsaXRpZXMuZmxvYXRWZXJ0ZXhUZXh0dXJlcyAmJiBvYmplY3QgJiYgb2JqZWN0LnNrZWxldG9uICYmIG9iamVjdC5za2VsZXRvbi51c2VWZXJ0ZXhUZXh0dXJlICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIDEwMjQ7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdC8vIGRlZmF1bHQgZm9yIHdoZW4gb2JqZWN0IGlzIG5vdCBzcGVjaWZpZWRcclxuXHRcdFx0Ly8gKCBmb3IgZXhhbXBsZSB3aGVuIHByZWJ1aWxkaW5nIHNoYWRlciB0byBiZSB1c2VkIHdpdGggbXVsdGlwbGUgb2JqZWN0cyApXHJcblx0XHRcdC8vXHJcblx0XHRcdC8vICAtIGxlYXZlIHNvbWUgZXh0cmEgc3BhY2UgZm9yIG90aGVyIHVuaWZvcm1zXHJcblx0XHRcdC8vICAtIGxpbWl0IGhlcmUgaXMgQU5HTEUncyAyNTQgbWF4IHVuaWZvcm0gdmVjdG9yc1xyXG5cdFx0XHQvLyAgICAodXAgdG8gNTQgc2hvdWxkIGJlIHNhZmUpXHJcblxyXG5cdFx0XHR2YXIgblZlcnRleFVuaWZvcm1zID0gY2FwYWJpbGl0aWVzLm1heFZlcnRleFVuaWZvcm1zO1xyXG5cdFx0XHR2YXIgblZlcnRleE1hdHJpY2VzID0gTWF0aC5mbG9vciggKCBuVmVydGV4VW5pZm9ybXMgLSAyMCApIC8gNCApO1xyXG5cclxuXHRcdFx0dmFyIG1heEJvbmVzID0gblZlcnRleE1hdHJpY2VzO1xyXG5cclxuXHRcdFx0aWYgKCBvYmplY3QgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5Ta2lubmVkTWVzaCApIHtcclxuXHJcblx0XHRcdFx0bWF4Qm9uZXMgPSBNYXRoLm1pbiggb2JqZWN0LnNrZWxldG9uLmJvbmVzLmxlbmd0aCwgbWF4Qm9uZXMgKTtcclxuXHJcblx0XHRcdFx0aWYgKCBtYXhCb25lcyA8IG9iamVjdC5za2VsZXRvbi5ib25lcy5sZW5ndGggKSB7XHJcblxyXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnV2ViR0xSZW5kZXJlcjogdG9vIG1hbnkgYm9uZXMgLSAnICsgb2JqZWN0LnNrZWxldG9uLmJvbmVzLmxlbmd0aCArICcsIHRoaXMgR1BVIHN1cHBvcnRzIGp1c3QgJyArIG1heEJvbmVzICsgJyAodHJ5IE9wZW5HTCBpbnN0ZWFkIG9mIEFOR0xFKScgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIG1heEJvbmVzO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHR0aGlzLmdldFBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoIG1hdGVyaWFsLCBsaWdodHMsIGZvZywgb2JqZWN0ICkge1xyXG5cclxuXHRcdHZhciBzaGFkZXJJRCA9IHNoYWRlcklEc1sgbWF0ZXJpYWwudHlwZSBdO1xyXG5cdFx0Ly8gaGV1cmlzdGljcyB0byBjcmVhdGUgc2hhZGVyIHBhcmFtZXRlcnMgYWNjb3JkaW5nIHRvIGxpZ2h0cyBpbiB0aGUgc2NlbmVcclxuXHRcdC8vIChub3QgdG8gYmxvdyBvdmVyIG1heExpZ2h0cyBidWRnZXQpXHJcblxyXG5cdFx0dmFyIG1heEJvbmVzID0gYWxsb2NhdGVCb25lcyggb2JqZWN0ICk7XHJcblx0XHR2YXIgcHJlY2lzaW9uID0gcmVuZGVyZXIuZ2V0UHJlY2lzaW9uKCk7XHJcblxyXG5cdFx0aWYgKCBtYXRlcmlhbC5wcmVjaXNpb24gIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRwcmVjaXNpb24gPSBjYXBhYmlsaXRpZXMuZ2V0TWF4UHJlY2lzaW9uKCBtYXRlcmlhbC5wcmVjaXNpb24gKTtcclxuXHJcblx0XHRcdGlmICggcHJlY2lzaW9uICE9PSBtYXRlcmlhbC5wcmVjaXNpb24gKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUHJvZ3JhbS5nZXRQYXJhbWV0ZXJzOicsIG1hdGVyaWFsLnByZWNpc2lvbiwgJ25vdCBzdXBwb3J0ZWQsIHVzaW5nJywgcHJlY2lzaW9uLCAnaW5zdGVhZC4nICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBwYXJhbWV0ZXJzID0ge1xyXG5cclxuXHRcdFx0c2hhZGVySUQ6IHNoYWRlcklELFxyXG5cclxuXHRcdFx0cHJlY2lzaW9uOiBwcmVjaXNpb24sXHJcblx0XHRcdHN1cHBvcnRzVmVydGV4VGV4dHVyZXM6IGNhcGFiaWxpdGllcy52ZXJ0ZXhUZXh0dXJlcyxcclxuXHJcblx0XHRcdG1hcDogISEgbWF0ZXJpYWwubWFwLFxyXG5cdFx0XHRlbnZNYXA6ICEhIG1hdGVyaWFsLmVudk1hcCxcclxuXHRcdFx0ZW52TWFwTW9kZTogbWF0ZXJpYWwuZW52TWFwICYmIG1hdGVyaWFsLmVudk1hcC5tYXBwaW5nLFxyXG5cdFx0XHRsaWdodE1hcDogISEgbWF0ZXJpYWwubGlnaHRNYXAsXHJcblx0XHRcdGFvTWFwOiAhISBtYXRlcmlhbC5hb01hcCxcclxuXHRcdFx0ZW1pc3NpdmVNYXA6ICEhIG1hdGVyaWFsLmVtaXNzaXZlTWFwLFxyXG5cdFx0XHRidW1wTWFwOiAhISBtYXRlcmlhbC5idW1wTWFwLFxyXG5cdFx0XHRub3JtYWxNYXA6ICEhIG1hdGVyaWFsLm5vcm1hbE1hcCxcclxuXHRcdFx0ZGlzcGxhY2VtZW50TWFwOiAhISBtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXAsXHJcblx0XHRcdHJvdWdobmVzc01hcDogISEgbWF0ZXJpYWwucm91Z2huZXNzTWFwLFxyXG5cdFx0XHRtZXRhbG5lc3NNYXA6ICEhIG1hdGVyaWFsLm1ldGFsbmVzc01hcCxcclxuXHRcdFx0c3BlY3VsYXJNYXA6ICEhIG1hdGVyaWFsLnNwZWN1bGFyTWFwLFxyXG5cdFx0XHRhbHBoYU1hcDogISEgbWF0ZXJpYWwuYWxwaGFNYXAsXHJcblxyXG5cdFx0XHRjb21iaW5lOiBtYXRlcmlhbC5jb21iaW5lLFxyXG5cclxuXHRcdFx0dmVydGV4Q29sb3JzOiBtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMsXHJcblxyXG5cdFx0XHRmb2c6IGZvZyxcclxuXHRcdFx0dXNlRm9nOiBtYXRlcmlhbC5mb2csXHJcblx0XHRcdGZvZ0V4cDogZm9nIGluc3RhbmNlb2YgVEhSRUUuRm9nRXhwMixcclxuXHJcblx0XHRcdGZsYXRTaGFkaW5nOiBtYXRlcmlhbC5zaGFkaW5nID09PSBUSFJFRS5GbGF0U2hhZGluZyxcclxuXHJcblx0XHRcdHNpemVBdHRlbnVhdGlvbjogbWF0ZXJpYWwuc2l6ZUF0dGVudWF0aW9uLFxyXG5cdFx0XHRsb2dhcml0aG1pY0RlcHRoQnVmZmVyOiBjYXBhYmlsaXRpZXMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlcixcclxuXHJcblx0XHRcdHNraW5uaW5nOiBtYXRlcmlhbC5za2lubmluZyxcclxuXHRcdFx0bWF4Qm9uZXM6IG1heEJvbmVzLFxyXG5cdFx0XHR1c2VWZXJ0ZXhUZXh0dXJlOiBjYXBhYmlsaXRpZXMuZmxvYXRWZXJ0ZXhUZXh0dXJlcyAmJiBvYmplY3QgJiYgb2JqZWN0LnNrZWxldG9uICYmIG9iamVjdC5za2VsZXRvbi51c2VWZXJ0ZXhUZXh0dXJlLFxyXG5cclxuXHRcdFx0bW9ycGhUYXJnZXRzOiBtYXRlcmlhbC5tb3JwaFRhcmdldHMsXHJcblx0XHRcdG1vcnBoTm9ybWFsczogbWF0ZXJpYWwubW9ycGhOb3JtYWxzLFxyXG5cdFx0XHRtYXhNb3JwaFRhcmdldHM6IHJlbmRlcmVyLm1heE1vcnBoVGFyZ2V0cyxcclxuXHRcdFx0bWF4TW9ycGhOb3JtYWxzOiByZW5kZXJlci5tYXhNb3JwaE5vcm1hbHMsXHJcblxyXG5cdFx0XHRudW1EaXJMaWdodHM6IGxpZ2h0cy5kaXJlY3Rpb25hbC5sZW5ndGgsXHJcblx0XHRcdG51bVBvaW50TGlnaHRzOiBsaWdodHMucG9pbnQubGVuZ3RoLFxyXG5cdFx0XHRudW1TcG90TGlnaHRzOiBsaWdodHMuc3BvdC5sZW5ndGgsXHJcblx0XHRcdG51bUhlbWlMaWdodHM6IGxpZ2h0cy5oZW1pLmxlbmd0aCxcclxuXHJcblx0XHRcdHBvaW50TGlnaHRTaGFkb3dzOiBsaWdodHMuc2hhZG93c1BvaW50TGlnaHQsXHJcblxyXG5cdFx0XHRzaGFkb3dNYXBFbmFibGVkOiByZW5kZXJlci5zaGFkb3dNYXAuZW5hYmxlZCAmJiBvYmplY3QucmVjZWl2ZVNoYWRvdyAmJiBsaWdodHMuc2hhZG93cy5sZW5ndGggPiAwLFxyXG5cdFx0XHRzaGFkb3dNYXBUeXBlOiByZW5kZXJlci5zaGFkb3dNYXAudHlwZSxcclxuXHJcblx0XHRcdGFscGhhVGVzdDogbWF0ZXJpYWwuYWxwaGFUZXN0LFxyXG5cdFx0XHRkb3VibGVTaWRlZDogbWF0ZXJpYWwuc2lkZSA9PT0gVEhSRUUuRG91YmxlU2lkZSxcclxuXHRcdFx0ZmxpcFNpZGVkOiBtYXRlcmlhbC5zaWRlID09PSBUSFJFRS5CYWNrU2lkZVxyXG5cclxuXHRcdH07XHJcblxyXG5cdFx0cmV0dXJuIHBhcmFtZXRlcnM7XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuZ2V0UHJvZ3JhbUNvZGUgPSBmdW5jdGlvbiAoIG1hdGVyaWFsLCBwYXJhbWV0ZXJzICkge1xyXG5cclxuXHRcdHZhciBjaHVua3MgPSBbXTtcclxuXHJcblx0XHRpZiAoIHBhcmFtZXRlcnMuc2hhZGVySUQgKSB7XHJcblxyXG5cdFx0XHRjaHVua3MucHVzaCggcGFyYW1ldGVycy5zaGFkZXJJRCApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRjaHVua3MucHVzaCggbWF0ZXJpYWwuZnJhZ21lbnRTaGFkZXIgKTtcclxuXHRcdFx0Y2h1bmtzLnB1c2goIG1hdGVyaWFsLnZlcnRleFNoYWRlciApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsLmRlZmluZXMgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGZvciAoIHZhciBuYW1lIGluIG1hdGVyaWFsLmRlZmluZXMgKSB7XHJcblxyXG5cdFx0XHRcdGNodW5rcy5wdXNoKCBuYW1lICk7XHJcblx0XHRcdFx0Y2h1bmtzLnB1c2goIG1hdGVyaWFsLmRlZmluZXNbIG5hbWUgXSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBwYXJhbWV0ZXJOYW1lcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgcGFyYW1ldGVyTmFtZSA9IHBhcmFtZXRlck5hbWVzWyBpIF07XHJcblx0XHRcdGNodW5rcy5wdXNoKCBwYXJhbWV0ZXJOYW1lICk7XHJcblx0XHRcdGNodW5rcy5wdXNoKCBwYXJhbWV0ZXJzWyBwYXJhbWV0ZXJOYW1lIF0gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGNodW5rcy5qb2luKCk7XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuYWNxdWlyZVByb2dyYW0gPSBmdW5jdGlvbiAoIG1hdGVyaWFsLCBwYXJhbWV0ZXJzLCBjb2RlICkge1xyXG5cclxuXHRcdHZhciBwcm9ncmFtO1xyXG5cclxuXHRcdC8vIENoZWNrIGlmIGNvZGUgaGFzIGJlZW4gYWxyZWFkeSBjb21waWxlZFxyXG5cdFx0Zm9yICggdmFyIHAgPSAwLCBwbCA9IHByb2dyYW1zLmxlbmd0aDsgcCA8IHBsOyBwICsrICkge1xyXG5cclxuXHRcdFx0dmFyIHByb2dyYW1JbmZvID0gcHJvZ3JhbXNbIHAgXTtcclxuXHJcblx0XHRcdGlmICggcHJvZ3JhbUluZm8uY29kZSA9PT0gY29kZSApIHtcclxuXHJcblx0XHRcdFx0cHJvZ3JhbSA9IHByb2dyYW1JbmZvO1xyXG5cdFx0XHRcdCsrIHByb2dyYW0udXNlZFRpbWVzO1xyXG5cclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBwcm9ncmFtID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRwcm9ncmFtID0gbmV3IFRIUkVFLldlYkdMUHJvZ3JhbSggcmVuZGVyZXIsIGNvZGUsIG1hdGVyaWFsLCBwYXJhbWV0ZXJzICk7XHJcblx0XHRcdHByb2dyYW1zLnB1c2goIHByb2dyYW0gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHByb2dyYW07XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMucmVsZWFzZVByb2dyYW0gPSBmdW5jdGlvbiggcHJvZ3JhbSApIHtcclxuXHJcblx0XHRpZiAoIC0tIHByb2dyYW0udXNlZFRpbWVzID09PSAwICkge1xyXG5cclxuXHRcdFx0Ly8gUmVtb3ZlIGZyb20gdW5vcmRlcmVkIHNldFxyXG5cdFx0XHR2YXIgaSA9IHByb2dyYW1zLmluZGV4T2YoIHByb2dyYW0gKTtcclxuXHRcdFx0cHJvZ3JhbXNbIGkgXSA9IHByb2dyYW1zWyBwcm9ncmFtcy5sZW5ndGggLSAxIF07XHJcblx0XHRcdHByb2dyYW1zLnBvcCgpO1xyXG5cclxuXHRcdFx0Ly8gRnJlZSBXZWJHTCByZXNvdXJjZXNcclxuXHRcdFx0cHJvZ3JhbS5kZXN0cm95KCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHQvLyBFeHBvc2VkIGZvciByZXNvdXJjZSBtb25pdG9yaW5nICYgZXJyb3IgZmVlZGJhY2sgdmlhIHJlbmRlcmVyLmluZm86XHJcblx0dGhpcy5wcm9ncmFtcyA9IHByb2dyYW1zO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy93ZWJnbC9XZWJHTFByb3BlcnRpZXMuanNcclxuXHJcbi8qKlxyXG4qIEBhdXRob3IgZm9yZGFjaW91cyAvIGZvcmRhY2lvdXMuZ2l0aHViLmlvXHJcbiovXHJcblxyXG5USFJFRS5XZWJHTFByb3BlcnRpZXMgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHZhciBwcm9wZXJ0aWVzID0ge307XHJcblxyXG5cdHRoaXMuZ2V0ID0gZnVuY3Rpb24gKCBvYmplY3QgKSB7XHJcblxyXG5cdFx0dmFyIHV1aWQgPSBvYmplY3QudXVpZDtcclxuXHRcdHZhciBtYXAgPSBwcm9wZXJ0aWVzWyB1dWlkIF07XHJcblxyXG5cdFx0aWYgKCBtYXAgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdG1hcCA9IHt9O1xyXG5cdFx0XHRwcm9wZXJ0aWVzWyB1dWlkIF0gPSBtYXA7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBtYXA7XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuZGVsZXRlID0gZnVuY3Rpb24gKCBvYmplY3QgKSB7XHJcblxyXG5cdFx0ZGVsZXRlIHByb3BlcnRpZXNbIG9iamVjdC51dWlkIF07XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cHJvcGVydGllcyA9IHt9O1xyXG5cclxuXHR9O1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy93ZWJnbC9XZWJHTFNoYWRlci5qc1xyXG5cclxuVEhSRUUuV2ViR0xTaGFkZXIgPSAoIGZ1bmN0aW9uICgpIHtcclxuXHJcblx0ZnVuY3Rpb24gYWRkTGluZU51bWJlcnMoIHN0cmluZyApIHtcclxuXHJcblx0XHR2YXIgbGluZXMgPSBzdHJpbmcuc3BsaXQoICdcXG4nICk7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0bGluZXNbIGkgXSA9ICggaSArIDEgKSArICc6ICcgKyBsaW5lc1sgaSBdO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbGluZXMuam9pbiggJ1xcbicgKTtcclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gV2ViR0xTaGFkZXIoIGdsLCB0eXBlLCBzdHJpbmcgKSB7XHJcblxyXG5cdFx0dmFyIHNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlciggdHlwZSApO1xyXG5cclxuXHRcdGdsLnNoYWRlclNvdXJjZSggc2hhZGVyLCBzdHJpbmcgKTtcclxuXHRcdGdsLmNvbXBpbGVTaGFkZXIoIHNoYWRlciApO1xyXG5cclxuXHRcdGlmICggZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKCBzaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTICkgPT09IGZhbHNlICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMU2hhZGVyOiBTaGFkZXIgY291bGRuXFwndCBjb21waWxlLicgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBnbC5nZXRTaGFkZXJJbmZvTG9nKCBzaGFkZXIgKSAhPT0gJycgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFNoYWRlcjogZ2wuZ2V0U2hhZGVySW5mb0xvZygpJywgdHlwZSA9PT0gZ2wuVkVSVEVYX1NIQURFUiA/ICd2ZXJ0ZXgnIDogJ2ZyYWdtZW50JywgZ2wuZ2V0U2hhZGVySW5mb0xvZyggc2hhZGVyICksIGFkZExpbmVOdW1iZXJzKCBzdHJpbmcgKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyAtLWVuYWJsZS1wcml2aWxlZ2VkLXdlYmdsLWV4dGVuc2lvblxyXG5cdFx0Ly8gY29uc29sZS5sb2coIHR5cGUsIGdsLmdldEV4dGVuc2lvbiggJ1dFQkdMX2RlYnVnX3NoYWRlcnMnICkuZ2V0VHJhbnNsYXRlZFNoYWRlclNvdXJjZSggc2hhZGVyICkgKTtcclxuXHJcblx0XHRyZXR1cm4gc2hhZGVyO1xyXG5cclxuXHR9O1xyXG5cclxufSApKCk7XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xTaGFkb3dNYXAuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLldlYkdMU2hhZG93TWFwID0gZnVuY3Rpb24gKCBfcmVuZGVyZXIsIF9saWdodHMsIF9vYmplY3RzICkge1xyXG5cclxuXHR2YXIgX2dsID0gX3JlbmRlcmVyLmNvbnRleHQsXHJcblx0X3N0YXRlID0gX3JlbmRlcmVyLnN0YXRlLFxyXG5cdF9mcnVzdHVtID0gbmV3IFRIUkVFLkZydXN0dW0oKSxcclxuXHRfcHJvalNjcmVlbk1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCksXHJcblxyXG5cdF9sb29rVGFyZ2V0ID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHRfbGlnaHRQb3NpdGlvbldvcmxkID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHJcblx0X3JlbmRlckxpc3QgPSBbXSxcclxuXHJcblx0X01vcnBoaW5nRmxhZyA9IDEsXHJcblx0X1NraW5uaW5nRmxhZyA9IDIsXHJcblxyXG5cdF9OdW1iZXJPZk1hdGVyaWFsVmFyaWFudHMgPSAoIF9Nb3JwaGluZ0ZsYWcgfCBfU2tpbm5pbmdGbGFnICkgKyAxLFxyXG5cclxuXHRfZGVwdGhNYXRlcmlhbHMgPSBuZXcgQXJyYXkoIF9OdW1iZXJPZk1hdGVyaWFsVmFyaWFudHMgKSxcclxuXHRfZGlzdGFuY2VNYXRlcmlhbHMgPSBuZXcgQXJyYXkoIF9OdW1iZXJPZk1hdGVyaWFsVmFyaWFudHMgKTtcclxuXHJcblx0dmFyIGN1YmVEaXJlY3Rpb25zID0gW1xyXG5cdFx0bmV3IFRIUkVFLlZlY3RvcjMoIDEsIDAsIDAgKSwgbmV3IFRIUkVFLlZlY3RvcjMoIC0gMSwgMCwgMCApLCBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMCwgMSApLFxyXG5cdFx0bmV3IFRIUkVFLlZlY3RvcjMoIDAsIDAsIC0gMSApLCBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMSwgMCApLCBuZXcgVEhSRUUuVmVjdG9yMyggMCwgLSAxLCAwIClcclxuXHRdO1xyXG5cclxuXHR2YXIgY3ViZVVwcyA9IFtcclxuXHRcdG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAxLCAwICksIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAxLCAwICksIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAxLCAwICksXHJcblx0XHRuZXcgVEhSRUUuVmVjdG9yMyggMCwgMSwgMCApLCBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMCwgMSApLFx0bmV3IFRIUkVFLlZlY3RvcjMoIDAsIDAsIC0gMSApXHJcblx0XTtcclxuXHJcblx0dmFyIGN1YmUyRFZpZXdQb3J0cyA9IFtcclxuXHRcdG5ldyBUSFJFRS5WZWN0b3I0KCksIG5ldyBUSFJFRS5WZWN0b3I0KCksIG5ldyBUSFJFRS5WZWN0b3I0KCksXHJcblx0XHRuZXcgVEhSRUUuVmVjdG9yNCgpLCBuZXcgVEhSRUUuVmVjdG9yNCgpLCBuZXcgVEhSRUUuVmVjdG9yNCgpXHJcblx0XTtcclxuXHJcblx0Ly8gaW5pdFxyXG5cclxuXHR2YXIgZGVwdGhTaGFkZXIgPSBUSFJFRS5TaGFkZXJMaWJbIFwiZGVwdGhSR0JBXCIgXTtcclxuXHR2YXIgZGVwdGhVbmlmb3JtcyA9IFRIUkVFLlVuaWZvcm1zVXRpbHMuY2xvbmUoIGRlcHRoU2hhZGVyLnVuaWZvcm1zICk7XHJcblxyXG5cdHZhciBkaXN0YW5jZVNoYWRlciA9IFRIUkVFLlNoYWRlckxpYlsgXCJkaXN0YW5jZVJHQkFcIiBdO1xyXG5cdHZhciBkaXN0YW5jZVVuaWZvcm1zID0gVEhSRUUuVW5pZm9ybXNVdGlscy5jbG9uZSggZGlzdGFuY2VTaGFkZXIudW5pZm9ybXMgKTtcclxuXHJcblx0Zm9yICggdmFyIGkgPSAwOyBpICE9PSBfTnVtYmVyT2ZNYXRlcmlhbFZhcmlhbnRzOyArKyBpICkge1xyXG5cclxuXHRcdHZhciB1c2VNb3JwaGluZyA9ICggaSAmIF9Nb3JwaGluZ0ZsYWcgKSAhPT0gMDtcclxuXHRcdHZhciB1c2VTa2lubmluZyA9ICggaSAmIF9Ta2lubmluZ0ZsYWcgKSAhPT0gMDtcclxuXHJcblx0XHR2YXIgZGVwdGhNYXRlcmlhbCA9IG5ldyBUSFJFRS5TaGFkZXJNYXRlcmlhbCgge1xyXG5cdFx0XHR1bmlmb3JtczogZGVwdGhVbmlmb3JtcyxcclxuXHRcdFx0dmVydGV4U2hhZGVyOiBkZXB0aFNoYWRlci52ZXJ0ZXhTaGFkZXIsXHJcblx0XHRcdGZyYWdtZW50U2hhZGVyOiBkZXB0aFNoYWRlci5mcmFnbWVudFNoYWRlcixcclxuXHRcdFx0bW9ycGhUYXJnZXRzOiB1c2VNb3JwaGluZyxcclxuXHRcdFx0c2tpbm5pbmc6IHVzZVNraW5uaW5nXHJcblx0XHR9ICk7XHJcblxyXG5cdFx0ZGVwdGhNYXRlcmlhbC5fc2hhZG93UGFzcyA9IHRydWU7XHJcblxyXG5cdFx0X2RlcHRoTWF0ZXJpYWxzWyBpIF0gPSBkZXB0aE1hdGVyaWFsO1xyXG5cclxuXHRcdHZhciBkaXN0YW5jZU1hdGVyaWFsID0gbmV3IFRIUkVFLlNoYWRlck1hdGVyaWFsKCB7XHJcblx0XHRcdHVuaWZvcm1zOiBkaXN0YW5jZVVuaWZvcm1zLFxyXG5cdFx0XHR2ZXJ0ZXhTaGFkZXI6IGRpc3RhbmNlU2hhZGVyLnZlcnRleFNoYWRlcixcclxuXHRcdFx0ZnJhZ21lbnRTaGFkZXI6IGRpc3RhbmNlU2hhZGVyLmZyYWdtZW50U2hhZGVyLFxyXG5cdFx0XHRtb3JwaFRhcmdldHM6IHVzZU1vcnBoaW5nLFxyXG5cdFx0XHRza2lubmluZzogdXNlU2tpbm5pbmdcclxuXHRcdH0gKTtcclxuXHJcblx0XHRkaXN0YW5jZU1hdGVyaWFsLl9zaGFkb3dQYXNzID0gdHJ1ZTtcclxuXHJcblx0XHRfZGlzdGFuY2VNYXRlcmlhbHNbIGkgXSA9IGRpc3RhbmNlTWF0ZXJpYWw7XHJcblxyXG5cdH1cclxuXHJcblx0Ly9cclxuXHJcblx0dmFyIHNjb3BlID0gdGhpcztcclxuXHJcblx0dGhpcy5lbmFibGVkID0gZmFsc2U7XHJcblxyXG5cdHRoaXMuYXV0b1VwZGF0ZSA9IHRydWU7XHJcblx0dGhpcy5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHR0aGlzLnR5cGUgPSBUSFJFRS5QQ0ZTaGFkb3dNYXA7XHJcblx0dGhpcy5jdWxsRmFjZSA9IFRIUkVFLkN1bGxGYWNlRnJvbnQ7XHJcblxyXG5cdHRoaXMucmVuZGVyID0gZnVuY3Rpb24gKCBzY2VuZSwgY2FtZXJhICkge1xyXG5cclxuXHRcdHZhciBmYWNlQ291bnQsIGlzUG9pbnRMaWdodDtcclxuXHJcblx0XHRpZiAoIHNjb3BlLmVuYWJsZWQgPT09IGZhbHNlICkgcmV0dXJuO1xyXG5cdFx0aWYgKCBzY29wZS5hdXRvVXBkYXRlID09PSBmYWxzZSAmJiBzY29wZS5uZWVkc1VwZGF0ZSA9PT0gZmFsc2UgKSByZXR1cm47XHJcblxyXG5cdFx0Ly8gU2V0IEdMIHN0YXRlIGZvciBkZXB0aCBtYXAuXHJcblx0XHRfc3RhdGUuY2xlYXJDb2xvciggMSwgMSwgMSwgMSApO1xyXG5cdFx0X3N0YXRlLmRpc2FibGUoIF9nbC5CTEVORCApO1xyXG5cdFx0X3N0YXRlLmVuYWJsZSggX2dsLkNVTExfRkFDRSApO1xyXG5cdFx0X2dsLmZyb250RmFjZSggX2dsLkNDVyApO1xyXG5cdFx0X2dsLmN1bGxGYWNlKCBzY29wZS5jdWxsRmFjZSA9PT0gVEhSRUUuQ3VsbEZhY2VGcm9udCA/IF9nbC5GUk9OVCA6IF9nbC5CQUNLICk7XHJcblx0XHRfc3RhdGUuc2V0RGVwdGhUZXN0KCB0cnVlICk7XHJcblx0XHRfc3RhdGUuc2V0U2Npc3NvclRlc3QoIGZhbHNlICk7XHJcblxyXG5cdFx0Ly8gcmVuZGVyIGRlcHRoIG1hcFxyXG5cclxuXHRcdHZhciBzaGFkb3dzID0gX2xpZ2h0cy5zaGFkb3dzO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBzaGFkb3dzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIGxpZ2h0ID0gc2hhZG93c1sgaSBdO1xyXG5cclxuXHRcdFx0dmFyIHNoYWRvdyA9IGxpZ2h0LnNoYWRvdztcclxuXHRcdFx0dmFyIHNoYWRvd0NhbWVyYSA9IHNoYWRvdy5jYW1lcmE7XHJcblx0XHRcdHZhciBzaGFkb3dNYXBTaXplID0gc2hhZG93Lm1hcFNpemU7XHJcblxyXG5cdFx0XHRpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuUG9pbnRMaWdodCApIHtcclxuXHJcblx0XHRcdFx0ZmFjZUNvdW50ID0gNjtcclxuXHRcdFx0XHRpc1BvaW50TGlnaHQgPSB0cnVlO1xyXG5cclxuXHRcdFx0XHR2YXIgdnBXaWR0aCA9IHNoYWRvd01hcFNpemUueCAvIDQuMDtcclxuXHRcdFx0XHR2YXIgdnBIZWlnaHQgPSBzaGFkb3dNYXBTaXplLnkgLyAyLjA7XHJcblxyXG5cdFx0XHRcdC8vIFRoZXNlIHZpZXdwb3J0cyBtYXAgYSBjdWJlLW1hcCBvbnRvIGEgMkQgdGV4dHVyZSB3aXRoIHRoZVxyXG5cdFx0XHRcdC8vIGZvbGxvd2luZyBvcmllbnRhdGlvbjpcclxuXHRcdFx0XHQvL1xyXG5cdFx0XHRcdC8vICB4elhaXHJcblx0XHRcdFx0Ly8gICB5IFlcclxuXHRcdFx0XHQvL1xyXG5cdFx0XHRcdC8vIFggLSBQb3NpdGl2ZSB4IGRpcmVjdGlvblxyXG5cdFx0XHRcdC8vIHggLSBOZWdhdGl2ZSB4IGRpcmVjdGlvblxyXG5cdFx0XHRcdC8vIFkgLSBQb3NpdGl2ZSB5IGRpcmVjdGlvblxyXG5cdFx0XHRcdC8vIHkgLSBOZWdhdGl2ZSB5IGRpcmVjdGlvblxyXG5cdFx0XHRcdC8vIFogLSBQb3NpdGl2ZSB6IGRpcmVjdGlvblxyXG5cdFx0XHRcdC8vIHogLSBOZWdhdGl2ZSB6IGRpcmVjdGlvblxyXG5cclxuXHRcdFx0XHQvLyBwb3NpdGl2ZSBYXHJcblx0XHRcdFx0Y3ViZTJEVmlld1BvcnRzWyAwIF0uc2V0KCB2cFdpZHRoICogMiwgdnBIZWlnaHQsIHZwV2lkdGgsIHZwSGVpZ2h0ICk7XHJcblx0XHRcdFx0Ly8gbmVnYXRpdmUgWFxyXG5cdFx0XHRcdGN1YmUyRFZpZXdQb3J0c1sgMSBdLnNldCggMCwgdnBIZWlnaHQsIHZwV2lkdGgsIHZwSGVpZ2h0ICk7XHJcblx0XHRcdFx0Ly8gcG9zaXRpdmUgWlxyXG5cdFx0XHRcdGN1YmUyRFZpZXdQb3J0c1sgMiBdLnNldCggdnBXaWR0aCAqIDMsIHZwSGVpZ2h0LCB2cFdpZHRoLCB2cEhlaWdodCApO1xyXG5cdFx0XHRcdC8vIG5lZ2F0aXZlIFpcclxuXHRcdFx0XHRjdWJlMkRWaWV3UG9ydHNbIDMgXS5zZXQoIHZwV2lkdGgsIHZwSGVpZ2h0LCB2cFdpZHRoLCB2cEhlaWdodCApO1xyXG5cdFx0XHRcdC8vIHBvc2l0aXZlIFlcclxuXHRcdFx0XHRjdWJlMkRWaWV3UG9ydHNbIDQgXS5zZXQoIHZwV2lkdGggKiAzLCAwLCB2cFdpZHRoLCB2cEhlaWdodCApO1xyXG5cdFx0XHRcdC8vIG5lZ2F0aXZlIFlcclxuXHRcdFx0XHRjdWJlMkRWaWV3UG9ydHNbIDUgXS5zZXQoIHZwV2lkdGgsIDAsIHZwV2lkdGgsIHZwSGVpZ2h0ICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRmYWNlQ291bnQgPSAxO1xyXG5cdFx0XHRcdGlzUG9pbnRMaWdodCA9IGZhbHNlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBzaGFkb3cubWFwID09PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHR2YXIgcGFycyA9IHsgbWluRmlsdGVyOiBUSFJFRS5MaW5lYXJGaWx0ZXIsIG1hZ0ZpbHRlcjogVEhSRUUuTGluZWFyRmlsdGVyLCBmb3JtYXQ6IFRIUkVFLlJHQkFGb3JtYXQgfTtcclxuXHJcblx0XHRcdFx0c2hhZG93Lm1hcCA9IG5ldyBUSFJFRS5XZWJHTFJlbmRlclRhcmdldCggc2hhZG93TWFwU2l6ZS54LCBzaGFkb3dNYXBTaXplLnksIHBhcnMgKTtcclxuXHJcblx0XHRcdFx0Ly9cclxuXHJcblx0XHRcdFx0aWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLlNwb3RMaWdodCApIHtcclxuXHJcblx0XHRcdFx0XHRzaGFkb3dDYW1lcmEuYXNwZWN0ID0gc2hhZG93TWFwU2l6ZS54IC8gc2hhZG93TWFwU2l6ZS55O1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHNoYWRvd0NhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgc2hhZG93TWFwID0gc2hhZG93Lm1hcDtcclxuXHRcdFx0dmFyIHNoYWRvd01hdHJpeCA9IHNoYWRvdy5tYXRyaXg7XHJcblxyXG5cdFx0XHRfbGlnaHRQb3NpdGlvbldvcmxkLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQubWF0cml4V29ybGQgKTtcclxuXHRcdFx0c2hhZG93Q2FtZXJhLnBvc2l0aW9uLmNvcHkoIF9saWdodFBvc2l0aW9uV29ybGQgKTtcclxuXHJcblx0XHRcdF9yZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQoIHNoYWRvd01hcCApO1xyXG5cdFx0XHRfcmVuZGVyZXIuY2xlYXIoKTtcclxuXHJcblx0XHRcdC8vIHJlbmRlciBzaGFkb3cgbWFwIGZvciBlYWNoIGN1YmUgZmFjZSAoaWYgb21uaS1kaXJlY3Rpb25hbCkgb3JcclxuXHRcdFx0Ly8gcnVuIGEgc2luZ2xlIHBhc3MgaWYgbm90XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgZmFjZSA9IDA7IGZhY2UgPCBmYWNlQ291bnQ7IGZhY2UgKysgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggaXNQb2ludExpZ2h0ICkge1xyXG5cclxuXHRcdFx0XHRcdF9sb29rVGFyZ2V0LmNvcHkoIHNoYWRvd0NhbWVyYS5wb3NpdGlvbiApO1xyXG5cdFx0XHRcdFx0X2xvb2tUYXJnZXQuYWRkKCBjdWJlRGlyZWN0aW9uc1sgZmFjZSBdICk7XHJcblx0XHRcdFx0XHRzaGFkb3dDYW1lcmEudXAuY29weSggY3ViZVVwc1sgZmFjZSBdICk7XHJcblx0XHRcdFx0XHRzaGFkb3dDYW1lcmEubG9va0F0KCBfbG9va1RhcmdldCApO1xyXG5cclxuXHRcdFx0XHRcdHZhciB2cERpbWVuc2lvbnMgPSBjdWJlMkRWaWV3UG9ydHNbIGZhY2UgXTtcclxuXHRcdFx0XHRcdF9zdGF0ZS52aWV3cG9ydCggdnBEaW1lbnNpb25zICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0X2xvb2tUYXJnZXQuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC50YXJnZXQubWF0cml4V29ybGQgKTtcclxuXHRcdFx0XHRcdHNoYWRvd0NhbWVyYS5sb29rQXQoIF9sb29rVGFyZ2V0ICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0c2hhZG93Q2FtZXJhLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XHJcblx0XHRcdFx0c2hhZG93Q2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZS5nZXRJbnZlcnNlKCBzaGFkb3dDYW1lcmEubWF0cml4V29ybGQgKTtcclxuXHJcblx0XHRcdFx0Ly8gY29tcHV0ZSBzaGFkb3cgbWF0cml4XHJcblxyXG5cdFx0XHRcdHNoYWRvd01hdHJpeC5zZXQoXHJcblx0XHRcdFx0XHQwLjUsIDAuMCwgMC4wLCAwLjUsXHJcblx0XHRcdFx0XHQwLjAsIDAuNSwgMC4wLCAwLjUsXHJcblx0XHRcdFx0XHQwLjAsIDAuMCwgMC41LCAwLjUsXHJcblx0XHRcdFx0XHQwLjAsIDAuMCwgMC4wLCAxLjBcclxuXHRcdFx0XHQpO1xyXG5cclxuXHRcdFx0XHRzaGFkb3dNYXRyaXgubXVsdGlwbHkoIHNoYWRvd0NhbWVyYS5wcm9qZWN0aW9uTWF0cml4ICk7XHJcblx0XHRcdFx0c2hhZG93TWF0cml4Lm11bHRpcGx5KCBzaGFkb3dDYW1lcmEubWF0cml4V29ybGRJbnZlcnNlICk7XHJcblxyXG5cdFx0XHRcdC8vIHVwZGF0ZSBjYW1lcmEgbWF0cmljZXMgYW5kIGZydXN0dW1cclxuXHJcblx0XHRcdFx0X3Byb2pTY3JlZW5NYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggc2hhZG93Q2FtZXJhLnByb2plY3Rpb25NYXRyaXgsIHNoYWRvd0NhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UgKTtcclxuXHRcdFx0XHRfZnJ1c3R1bS5zZXRGcm9tTWF0cml4KCBfcHJvalNjcmVlbk1hdHJpeCApO1xyXG5cclxuXHRcdFx0XHQvLyBzZXQgb2JqZWN0IG1hdHJpY2VzICYgZnJ1c3R1bSBjdWxsaW5nXHJcblxyXG5cdFx0XHRcdF9yZW5kZXJMaXN0Lmxlbmd0aCA9IDA7XHJcblxyXG5cdFx0XHRcdHByb2plY3RPYmplY3QoIHNjZW5lLCBjYW1lcmEsIHNoYWRvd0NhbWVyYSApO1xyXG5cclxuXHRcdFx0XHQvLyByZW5kZXIgc2hhZG93IG1hcFxyXG5cdFx0XHRcdC8vIHJlbmRlciByZWd1bGFyIG9iamVjdHNcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IF9yZW5kZXJMaXN0Lmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciBvYmplY3QgPSBfcmVuZGVyTGlzdFsgaiBdO1xyXG5cdFx0XHRcdFx0dmFyIGdlb21ldHJ5ID0gX29iamVjdHMudXBkYXRlKCBvYmplY3QgKTtcclxuXHRcdFx0XHRcdHZhciBtYXRlcmlhbCA9IG9iamVjdC5tYXRlcmlhbDtcclxuXHJcblx0XHRcdFx0XHRpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTXVsdGlNYXRlcmlhbCApIHtcclxuXHJcblx0XHRcdFx0XHRcdHZhciBncm91cHMgPSBnZW9tZXRyeS5ncm91cHM7XHJcblx0XHRcdFx0XHRcdHZhciBtYXRlcmlhbHMgPSBtYXRlcmlhbC5tYXRlcmlhbHM7XHJcblxyXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgayA9IDAsIGtsID0gZ3JvdXBzLmxlbmd0aDsgayA8IGtsOyBrICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHR2YXIgZ3JvdXAgPSBncm91cHNbIGsgXTtcclxuXHRcdFx0XHRcdFx0XHR2YXIgZ3JvdXBNYXRlcmlhbCA9IG1hdGVyaWFsc1sgZ3JvdXAubWF0ZXJpYWxJbmRleCBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRpZiAoIGdyb3VwTWF0ZXJpYWwudmlzaWJsZSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHR2YXIgZGVwdGhNYXRlcmlhbCA9IGdldERlcHRoTWF0ZXJpYWwoIG9iamVjdCwgZ3JvdXBNYXRlcmlhbCwgaXNQb2ludExpZ2h0LCBfbGlnaHRQb3NpdGlvbldvcmxkICk7XHJcblx0XHRcdFx0XHRcdFx0XHRfcmVuZGVyZXIucmVuZGVyQnVmZmVyRGlyZWN0KCBzaGFkb3dDYW1lcmEsIG51bGwsIGdlb21ldHJ5LCBkZXB0aE1hdGVyaWFsLCBvYmplY3QsIGdyb3VwICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0dmFyIGRlcHRoTWF0ZXJpYWwgPSBnZXREZXB0aE1hdGVyaWFsKCBvYmplY3QsIG1hdGVyaWFsLCBpc1BvaW50TGlnaHQsIF9saWdodFBvc2l0aW9uV29ybGQgKTtcclxuXHRcdFx0XHRcdFx0X3JlbmRlcmVyLnJlbmRlckJ1ZmZlckRpcmVjdCggc2hhZG93Q2FtZXJhLCBudWxsLCBnZW9tZXRyeSwgZGVwdGhNYXRlcmlhbCwgb2JqZWN0LCBudWxsICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBXZSBtdXN0IGNhbGwgX3JlbmRlcmVyLnJlc2V0R0xTdGF0ZSgpIGF0IHRoZSBlbmQgb2YgZWFjaCBpdGVyYXRpb24gb2ZcclxuXHRcdFx0Ly8gdGhlIGxpZ2h0IGxvb3AgaW4gb3JkZXIgdG8gZm9yY2UgbWF0ZXJpYWwgdXBkYXRlcyBmb3IgZWFjaCBsaWdodC5cclxuXHRcdFx0X3JlbmRlcmVyLnJlc2V0R0xTdGF0ZSgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBSZXN0b3JlIEdMIHN0YXRlLlxyXG5cdFx0dmFyIGNsZWFyQ29sb3IgPSBfcmVuZGVyZXIuZ2V0Q2xlYXJDb2xvcigpLFxyXG5cdFx0Y2xlYXJBbHBoYSA9IF9yZW5kZXJlci5nZXRDbGVhckFscGhhKCk7XHJcblx0XHRfcmVuZGVyZXIuc2V0Q2xlYXJDb2xvciggY2xlYXJDb2xvciwgY2xlYXJBbHBoYSApO1xyXG5cclxuXHRcdF9zdGF0ZS5lbmFibGUoIF9nbC5CTEVORCApO1xyXG5cclxuXHRcdGlmICggc2NvcGUuY3VsbEZhY2UgPT09IFRIUkVFLkN1bGxGYWNlRnJvbnQgKSB7XHJcblxyXG5cdFx0XHRfZ2wuY3VsbEZhY2UoIF9nbC5CQUNLICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdF9yZW5kZXJlci5yZXNldEdMU3RhdGUoKTtcclxuXHJcblx0XHRzY29wZS5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBnZXREZXB0aE1hdGVyaWFsKCBvYmplY3QsIG1hdGVyaWFsLCBpc1BvaW50TGlnaHQsIGxpZ2h0UG9zaXRpb25Xb3JsZCApIHtcclxuXHJcblx0XHR2YXIgZ2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnk7XHJcblxyXG5cdFx0dmFyIG5ld01hdGVyaWFsID0gbnVsbDtcclxuXHJcblx0XHR2YXIgbWF0ZXJpYWxWYXJpYW50cyA9IF9kZXB0aE1hdGVyaWFscztcclxuXHRcdHZhciBjdXN0b21NYXRlcmlhbCA9IG9iamVjdC5jdXN0b21EZXB0aE1hdGVyaWFsO1xyXG5cclxuXHRcdGlmICggaXNQb2ludExpZ2h0ICkge1xyXG5cclxuXHRcdFx0bWF0ZXJpYWxWYXJpYW50cyA9IF9kaXN0YW5jZU1hdGVyaWFscztcclxuXHRcdFx0Y3VzdG9tTWF0ZXJpYWwgPSBvYmplY3QuY3VzdG9tRGlzdGFuY2VNYXRlcmlhbDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCAhIGN1c3RvbU1hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0dmFyIHVzZU1vcnBoaW5nID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzICE9PSB1bmRlZmluZWQgJiZcclxuXHRcdFx0XHRcdGdlb21ldHJ5Lm1vcnBoVGFyZ2V0cy5sZW5ndGggPiAwICYmIG1hdGVyaWFsLm1vcnBoVGFyZ2V0cztcclxuXHJcblx0XHRcdHZhciB1c2VTa2lubmluZyA9IG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLlNraW5uZWRNZXNoICYmIG1hdGVyaWFsLnNraW5uaW5nO1xyXG5cclxuXHRcdFx0dmFyIHZhcmlhbnRJbmRleCA9IDA7XHJcblxyXG5cdFx0XHRpZiAoIHVzZU1vcnBoaW5nICkgdmFyaWFudEluZGV4IHw9IF9Nb3JwaGluZ0ZsYWc7XHJcblx0XHRcdGlmICggdXNlU2tpbm5pbmcgKSB2YXJpYW50SW5kZXggfD0gX1NraW5uaW5nRmxhZztcclxuXHJcblx0XHRcdG5ld01hdGVyaWFsID0gbWF0ZXJpYWxWYXJpYW50c1sgdmFyaWFudEluZGV4IF07XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdG5ld01hdGVyaWFsID0gY3VzdG9tTWF0ZXJpYWw7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdG5ld01hdGVyaWFsLnZpc2libGUgPSBtYXRlcmlhbC52aXNpYmxlO1xyXG5cdFx0bmV3TWF0ZXJpYWwud2lyZWZyYW1lID0gbWF0ZXJpYWwud2lyZWZyYW1lO1xyXG5cdFx0bmV3TWF0ZXJpYWwud2lyZWZyYW1lTGluZXdpZHRoID0gbWF0ZXJpYWwud2lyZWZyYW1lTGluZXdpZHRoO1xyXG5cclxuXHRcdGlmICggaXNQb2ludExpZ2h0ICYmIG5ld01hdGVyaWFsLnVuaWZvcm1zLmxpZ2h0UG9zICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRuZXdNYXRlcmlhbC51bmlmb3Jtcy5saWdodFBvcy52YWx1ZS5jb3B5KCBsaWdodFBvc2l0aW9uV29ybGQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG5ld01hdGVyaWFsO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHByb2plY3RPYmplY3QoIG9iamVjdCwgY2FtZXJhLCBzaGFkb3dDYW1lcmEgKSB7XHJcblxyXG5cdFx0aWYgKCBvYmplY3QudmlzaWJsZSA9PT0gZmFsc2UgKSByZXR1cm47XHJcblxyXG5cdFx0aWYgKCBvYmplY3QubGF5ZXJzLnRlc3QoIGNhbWVyYS5sYXllcnMgKSAmJiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLk1lc2ggfHwgb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTGluZSB8fCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5Qb2ludHMgKSApIHtcclxuXHJcblx0XHRcdGlmICggb2JqZWN0LmNhc3RTaGFkb3cgJiYgKCBvYmplY3QuZnJ1c3R1bUN1bGxlZCA9PT0gZmFsc2UgfHwgX2ZydXN0dW0uaW50ZXJzZWN0c09iamVjdCggb2JqZWN0ICkgPT09IHRydWUgKSApIHtcclxuXHJcblx0XHRcdFx0dmFyIG1hdGVyaWFsID0gb2JqZWN0Lm1hdGVyaWFsO1xyXG5cclxuXHRcdFx0XHRpZiAoIG1hdGVyaWFsLnZpc2libGUgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdFx0b2JqZWN0Lm1vZGVsVmlld01hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBzaGFkb3dDYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLCBvYmplY3QubWF0cml4V29ybGQgKTtcclxuXHRcdFx0XHRcdF9yZW5kZXJMaXN0LnB1c2goIG9iamVjdCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBjaGlsZHJlbiA9IG9iamVjdC5jaGlsZHJlbjtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0cHJvamVjdE9iamVjdCggY2hpbGRyZW5bIGkgXSwgY2FtZXJhLCBzaGFkb3dDYW1lcmEgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xTdGF0ZS5qc1xyXG5cclxuLyoqXHJcbiogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuKi9cclxuXHJcblRIUkVFLldlYkdMU3RhdGUgPSBmdW5jdGlvbiAoIGdsLCBleHRlbnNpb25zLCBwYXJhbVRocmVlVG9HTCApIHtcclxuXHJcblx0dmFyIF90aGlzID0gdGhpcztcclxuXHJcblx0dmFyIGNvbG9yID0gbmV3IFRIUkVFLlZlY3RvcjQoKTtcclxuXHJcblx0dmFyIG5ld0F0dHJpYnV0ZXMgPSBuZXcgVWludDhBcnJheSggMTYgKTtcclxuXHR2YXIgZW5hYmxlZEF0dHJpYnV0ZXMgPSBuZXcgVWludDhBcnJheSggMTYgKTtcclxuXHR2YXIgYXR0cmlidXRlRGl2aXNvcnMgPSBuZXcgVWludDhBcnJheSggMTYgKTtcclxuXHJcblx0dmFyIGNhcGFiaWxpdGllcyA9IHt9O1xyXG5cclxuXHR2YXIgY29tcHJlc3NlZFRleHR1cmVGb3JtYXRzID0gbnVsbDtcclxuXHJcblx0dmFyIGN1cnJlbnRCbGVuZGluZyA9IG51bGw7XHJcblx0dmFyIGN1cnJlbnRCbGVuZEVxdWF0aW9uID0gbnVsbDtcclxuXHR2YXIgY3VycmVudEJsZW5kU3JjID0gbnVsbDtcclxuXHR2YXIgY3VycmVudEJsZW5kRHN0ID0gbnVsbDtcclxuXHR2YXIgY3VycmVudEJsZW5kRXF1YXRpb25BbHBoYSA9IG51bGw7XHJcblx0dmFyIGN1cnJlbnRCbGVuZFNyY0FscGhhID0gbnVsbDtcclxuXHR2YXIgY3VycmVudEJsZW5kRHN0QWxwaGEgPSBudWxsO1xyXG5cclxuXHR2YXIgY3VycmVudERlcHRoRnVuYyA9IG51bGw7XHJcblx0dmFyIGN1cnJlbnREZXB0aFdyaXRlID0gbnVsbDtcclxuXHJcblx0dmFyIGN1cnJlbnRDb2xvcldyaXRlID0gbnVsbDtcclxuXHJcblx0dmFyIGN1cnJlbnRTdGVuY2lsV3JpdGUgPSBudWxsO1xyXG5cdHZhciBjdXJyZW50U3RlbmNpbEZ1bmMgPSBudWxsO1xyXG5cdHZhciBjdXJyZW50U3RlbmNpbFJlZiA9IG51bGw7XHJcblx0dmFyIGN1cnJlbnRTdGVuY2lsTWFzayA9IG51bGw7XHJcblx0dmFyIGN1cnJlbnRTdGVuY2lsRmFpbCAgPSBudWxsO1xyXG5cdHZhciBjdXJyZW50U3RlbmNpbFpGYWlsID0gbnVsbDtcclxuXHR2YXIgY3VycmVudFN0ZW5jaWxaUGFzcyA9IG51bGw7XHJcblxyXG5cdHZhciBjdXJyZW50RmxpcFNpZGVkID0gbnVsbDtcclxuXHJcblx0dmFyIGN1cnJlbnRMaW5lV2lkdGggPSBudWxsO1xyXG5cclxuXHR2YXIgY3VycmVudFBvbHlnb25PZmZzZXRGYWN0b3IgPSBudWxsO1xyXG5cdHZhciBjdXJyZW50UG9seWdvbk9mZnNldFVuaXRzID0gbnVsbDtcclxuXHJcblx0dmFyIGN1cnJlbnRTY2lzc29yVGVzdCA9IG51bGw7XHJcblxyXG5cdHZhciBtYXhUZXh0dXJlcyA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX1RFWFRVUkVfSU1BR0VfVU5JVFMgKTtcclxuXHJcblx0dmFyIGN1cnJlbnRUZXh0dXJlU2xvdCA9IHVuZGVmaW5lZDtcclxuXHR2YXIgY3VycmVudEJvdW5kVGV4dHVyZXMgPSB7fTtcclxuXHJcblx0dmFyIGN1cnJlbnRDbGVhckNvbG9yID0gbmV3IFRIUkVFLlZlY3RvcjQoKTtcclxuXHR2YXIgY3VycmVudENsZWFyRGVwdGggPSBudWxsO1xyXG5cdHZhciBjdXJyZW50Q2xlYXJTdGVuY2lsID0gbnVsbDtcclxuXHJcblx0dmFyIGN1cnJlbnRTY2lzc29yID0gbmV3IFRIUkVFLlZlY3RvcjQoKTtcclxuXHR2YXIgY3VycmVudFZpZXdwb3J0ID0gbmV3IFRIUkVFLlZlY3RvcjQoKTtcclxuXHJcblx0dGhpcy5pbml0ID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMuY2xlYXJDb2xvciggMCwgMCwgMCwgMSApO1xyXG5cdFx0dGhpcy5jbGVhckRlcHRoKCAxICk7XHJcblx0XHR0aGlzLmNsZWFyU3RlbmNpbCggMCApO1xyXG5cclxuXHRcdHRoaXMuZW5hYmxlKCBnbC5ERVBUSF9URVNUICk7XHJcblx0XHRnbC5kZXB0aEZ1bmMoIGdsLkxFUVVBTCApO1xyXG5cclxuXHRcdGdsLmZyb250RmFjZSggZ2wuQ0NXICk7XHJcblx0XHRnbC5jdWxsRmFjZSggZ2wuQkFDSyApO1xyXG5cdFx0dGhpcy5lbmFibGUoIGdsLkNVTExfRkFDRSApO1xyXG5cclxuXHRcdHRoaXMuZW5hYmxlKCBnbC5CTEVORCApO1xyXG5cdFx0Z2wuYmxlbmRFcXVhdGlvbiggZ2wuRlVOQ19BREQgKTtcclxuXHRcdGdsLmJsZW5kRnVuYyggZ2wuU1JDX0FMUEhBLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBICk7XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuaW5pdEF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gbmV3QXR0cmlidXRlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0bmV3QXR0cmlidXRlc1sgaSBdID0gMDtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuZW5hYmxlQXR0cmlidXRlID0gZnVuY3Rpb24gKCBhdHRyaWJ1dGUgKSB7XHJcblxyXG5cdFx0bmV3QXR0cmlidXRlc1sgYXR0cmlidXRlIF0gPSAxO1xyXG5cclxuXHRcdGlmICggZW5hYmxlZEF0dHJpYnV0ZXNbIGF0dHJpYnV0ZSBdID09PSAwICkge1xyXG5cclxuXHRcdFx0Z2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoIGF0dHJpYnV0ZSApO1xyXG5cdFx0XHRlbmFibGVkQXR0cmlidXRlc1sgYXR0cmlidXRlIF0gPSAxO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGF0dHJpYnV0ZURpdmlzb3JzWyBhdHRyaWJ1dGUgXSAhPT0gMCApIHtcclxuXHJcblx0XHRcdHZhciBleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ0FOR0xFX2luc3RhbmNlZF9hcnJheXMnICk7XHJcblxyXG5cdFx0XHRleHRlbnNpb24udmVydGV4QXR0cmliRGl2aXNvckFOR0xFKCBhdHRyaWJ1dGUsIDAgKTtcclxuXHRcdFx0YXR0cmlidXRlRGl2aXNvcnNbIGF0dHJpYnV0ZSBdID0gMDtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuZW5hYmxlQXR0cmlidXRlQW5kRGl2aXNvciA9IGZ1bmN0aW9uICggYXR0cmlidXRlLCBtZXNoUGVyQXR0cmlidXRlLCBleHRlbnNpb24gKSB7XHJcblxyXG5cdFx0bmV3QXR0cmlidXRlc1sgYXR0cmlidXRlIF0gPSAxO1xyXG5cclxuXHRcdGlmICggZW5hYmxlZEF0dHJpYnV0ZXNbIGF0dHJpYnV0ZSBdID09PSAwICkge1xyXG5cclxuXHRcdFx0Z2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoIGF0dHJpYnV0ZSApO1xyXG5cdFx0XHRlbmFibGVkQXR0cmlidXRlc1sgYXR0cmlidXRlIF0gPSAxO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGF0dHJpYnV0ZURpdmlzb3JzWyBhdHRyaWJ1dGUgXSAhPT0gbWVzaFBlckF0dHJpYnV0ZSApIHtcclxuXHJcblx0XHRcdGV4dGVuc2lvbi52ZXJ0ZXhBdHRyaWJEaXZpc29yQU5HTEUoIGF0dHJpYnV0ZSwgbWVzaFBlckF0dHJpYnV0ZSApO1xyXG5cdFx0XHRhdHRyaWJ1dGVEaXZpc29yc1sgYXR0cmlidXRlIF0gPSBtZXNoUGVyQXR0cmlidXRlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5kaXNhYmxlVW51c2VkQXR0cmlidXRlcyA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBlbmFibGVkQXR0cmlidXRlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0aWYgKCBlbmFibGVkQXR0cmlidXRlc1sgaSBdICE9PSBuZXdBdHRyaWJ1dGVzWyBpIF0gKSB7XHJcblxyXG5cdFx0XHRcdGdsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheSggaSApO1xyXG5cdFx0XHRcdGVuYWJsZWRBdHRyaWJ1dGVzWyBpIF0gPSAwO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5lbmFibGUgPSBmdW5jdGlvbiAoIGlkICkge1xyXG5cclxuXHRcdGlmICggY2FwYWJpbGl0aWVzWyBpZCBdICE9PSB0cnVlICkge1xyXG5cclxuXHRcdFx0Z2wuZW5hYmxlKCBpZCApO1xyXG5cdFx0XHRjYXBhYmlsaXRpZXNbIGlkIF0gPSB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5kaXNhYmxlID0gZnVuY3Rpb24gKCBpZCApIHtcclxuXHJcblx0XHRpZiAoIGNhcGFiaWxpdGllc1sgaWQgXSAhPT0gZmFsc2UgKSB7XHJcblxyXG5cdFx0XHRnbC5kaXNhYmxlKCBpZCApO1xyXG5cdFx0XHRjYXBhYmlsaXRpZXNbIGlkIF0gPSBmYWxzZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuZ2V0Q29tcHJlc3NlZFRleHR1cmVGb3JtYXRzID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdGlmICggY29tcHJlc3NlZFRleHR1cmVGb3JtYXRzID09PSBudWxsICkge1xyXG5cclxuXHRcdFx0Y29tcHJlc3NlZFRleHR1cmVGb3JtYXRzID0gW107XHJcblxyXG5cdFx0XHRpZiAoIGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjJyApIHx8XHJcblx0XHRcdCAgICAgZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0YycgKSB8fFxyXG5cdFx0XHQgICAgIGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX2V0YzEnICkpIHtcclxuXHJcblx0XHRcdFx0dmFyIGZvcm1hdHMgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLkNPTVBSRVNTRURfVEVYVFVSRV9GT1JNQVRTICk7XHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGZvcm1hdHMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdGNvbXByZXNzZWRUZXh0dXJlRm9ybWF0cy5wdXNoKCBmb3JtYXRzWyBpIF0gKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gY29tcHJlc3NlZFRleHR1cmVGb3JtYXRzO1xyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLnNldEJsZW5kaW5nID0gZnVuY3Rpb24gKCBibGVuZGluZywgYmxlbmRFcXVhdGlvbiwgYmxlbmRTcmMsIGJsZW5kRHN0LCBibGVuZEVxdWF0aW9uQWxwaGEsIGJsZW5kU3JjQWxwaGEsIGJsZW5kRHN0QWxwaGEgKSB7XHJcblxyXG5cdFx0aWYgKCBibGVuZGluZyA9PT0gVEhSRUUuTm9CbGVuZGluZyApIHtcclxuXHJcblx0XHRcdHRoaXMuZGlzYWJsZSggZ2wuQkxFTkQgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0dGhpcy5lbmFibGUoIGdsLkJMRU5EICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggYmxlbmRpbmcgIT09IGN1cnJlbnRCbGVuZGluZyApIHtcclxuXHJcblx0XHRcdGlmICggYmxlbmRpbmcgPT09IFRIUkVFLkFkZGl0aXZlQmxlbmRpbmcgKSB7XHJcblxyXG5cdFx0XHRcdGdsLmJsZW5kRXF1YXRpb24oIGdsLkZVTkNfQUREICk7XHJcblx0XHRcdFx0Z2wuYmxlbmRGdW5jKCBnbC5TUkNfQUxQSEEsIGdsLk9ORSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggYmxlbmRpbmcgPT09IFRIUkVFLlN1YnRyYWN0aXZlQmxlbmRpbmcgKSB7XHJcblxyXG5cdFx0XHRcdC8vIFRPRE86IEZpbmQgYmxlbmRGdW5jU2VwYXJhdGUoKSBjb21iaW5hdGlvblxyXG5cclxuXHRcdFx0XHRnbC5ibGVuZEVxdWF0aW9uKCBnbC5GVU5DX0FERCApO1xyXG5cdFx0XHRcdGdsLmJsZW5kRnVuYyggZ2wuWkVSTywgZ2wuT05FX01JTlVTX1NSQ19DT0xPUiApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggYmxlbmRpbmcgPT09IFRIUkVFLk11bHRpcGx5QmxlbmRpbmcgKSB7XHJcblxyXG5cdFx0XHRcdC8vIFRPRE86IEZpbmQgYmxlbmRGdW5jU2VwYXJhdGUoKSBjb21iaW5hdGlvblxyXG5cclxuXHRcdFx0XHRnbC5ibGVuZEVxdWF0aW9uKCBnbC5GVU5DX0FERCApO1xyXG5cdFx0XHRcdGdsLmJsZW5kRnVuYyggZ2wuWkVSTywgZ2wuU1JDX0NPTE9SICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRnbC5ibGVuZEVxdWF0aW9uU2VwYXJhdGUoIGdsLkZVTkNfQURELCBnbC5GVU5DX0FERCApO1xyXG5cdFx0XHRcdGdsLmJsZW5kRnVuY1NlcGFyYXRlKCBnbC5TUkNfQUxQSEEsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEsIGdsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Y3VycmVudEJsZW5kaW5nID0gYmxlbmRpbmc7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggYmxlbmRpbmcgPT09IFRIUkVFLkN1c3RvbUJsZW5kaW5nICkge1xyXG5cclxuXHRcdFx0YmxlbmRFcXVhdGlvbkFscGhhID0gYmxlbmRFcXVhdGlvbkFscGhhIHx8IGJsZW5kRXF1YXRpb247XHJcblx0XHRcdGJsZW5kU3JjQWxwaGEgPSBibGVuZFNyY0FscGhhIHx8IGJsZW5kU3JjO1xyXG5cdFx0XHRibGVuZERzdEFscGhhID0gYmxlbmREc3RBbHBoYSB8fCBibGVuZERzdDtcclxuXHJcblx0XHRcdGlmICggYmxlbmRFcXVhdGlvbiAhPT0gY3VycmVudEJsZW5kRXF1YXRpb24gfHwgYmxlbmRFcXVhdGlvbkFscGhhICE9PSBjdXJyZW50QmxlbmRFcXVhdGlvbkFscGhhICkge1xyXG5cclxuXHRcdFx0XHRnbC5ibGVuZEVxdWF0aW9uU2VwYXJhdGUoIHBhcmFtVGhyZWVUb0dMKCBibGVuZEVxdWF0aW9uICksIHBhcmFtVGhyZWVUb0dMKCBibGVuZEVxdWF0aW9uQWxwaGEgKSApO1xyXG5cclxuXHRcdFx0XHRjdXJyZW50QmxlbmRFcXVhdGlvbiA9IGJsZW5kRXF1YXRpb247XHJcblx0XHRcdFx0Y3VycmVudEJsZW5kRXF1YXRpb25BbHBoYSA9IGJsZW5kRXF1YXRpb25BbHBoYTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggYmxlbmRTcmMgIT09IGN1cnJlbnRCbGVuZFNyYyB8fCBibGVuZERzdCAhPT0gY3VycmVudEJsZW5kRHN0IHx8IGJsZW5kU3JjQWxwaGEgIT09IGN1cnJlbnRCbGVuZFNyY0FscGhhIHx8IGJsZW5kRHN0QWxwaGEgIT09IGN1cnJlbnRCbGVuZERzdEFscGhhICkge1xyXG5cclxuXHRcdFx0XHRnbC5ibGVuZEZ1bmNTZXBhcmF0ZSggcGFyYW1UaHJlZVRvR0woIGJsZW5kU3JjICksIHBhcmFtVGhyZWVUb0dMKCBibGVuZERzdCApLCBwYXJhbVRocmVlVG9HTCggYmxlbmRTcmNBbHBoYSApLCBwYXJhbVRocmVlVG9HTCggYmxlbmREc3RBbHBoYSApICk7XHJcblxyXG5cdFx0XHRcdGN1cnJlbnRCbGVuZFNyYyA9IGJsZW5kU3JjO1xyXG5cdFx0XHRcdGN1cnJlbnRCbGVuZERzdCA9IGJsZW5kRHN0O1xyXG5cdFx0XHRcdGN1cnJlbnRCbGVuZFNyY0FscGhhID0gYmxlbmRTcmNBbHBoYTtcclxuXHRcdFx0XHRjdXJyZW50QmxlbmREc3RBbHBoYSA9IGJsZW5kRHN0QWxwaGE7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdGN1cnJlbnRCbGVuZEVxdWF0aW9uID0gbnVsbDtcclxuXHRcdFx0Y3VycmVudEJsZW5kU3JjID0gbnVsbDtcclxuXHRcdFx0Y3VycmVudEJsZW5kRHN0ID0gbnVsbDtcclxuXHRcdFx0Y3VycmVudEJsZW5kRXF1YXRpb25BbHBoYSA9IG51bGw7XHJcblx0XHRcdGN1cnJlbnRCbGVuZFNyY0FscGhhID0gbnVsbDtcclxuXHRcdFx0Y3VycmVudEJsZW5kRHN0QWxwaGEgPSBudWxsO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5zZXREZXB0aEZ1bmMgPSBmdW5jdGlvbiAoIGRlcHRoRnVuYyApIHtcclxuXHJcblx0XHRpZiAoIGN1cnJlbnREZXB0aEZ1bmMgIT09IGRlcHRoRnVuYyApIHtcclxuXHJcblx0XHRcdGlmICggZGVwdGhGdW5jICkge1xyXG5cclxuXHRcdFx0XHRzd2l0Y2ggKCBkZXB0aEZ1bmMgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSBUSFJFRS5OZXZlckRlcHRoOlxyXG5cclxuXHRcdFx0XHRcdFx0Z2wuZGVwdGhGdW5jKCBnbC5ORVZFUiApO1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlIFRIUkVFLkFsd2F5c0RlcHRoOlxyXG5cclxuXHRcdFx0XHRcdFx0Z2wuZGVwdGhGdW5jKCBnbC5BTFdBWVMgKTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSBUSFJFRS5MZXNzRGVwdGg6XHJcblxyXG5cdFx0XHRcdFx0XHRnbC5kZXB0aEZ1bmMoIGdsLkxFU1MgKTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSBUSFJFRS5MZXNzRXF1YWxEZXB0aDpcclxuXHJcblx0XHRcdFx0XHRcdGdsLmRlcHRoRnVuYyggZ2wuTEVRVUFMICk7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgVEhSRUUuRXF1YWxEZXB0aDpcclxuXHJcblx0XHRcdFx0XHRcdGdsLmRlcHRoRnVuYyggZ2wuRVFVQUwgKTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSBUSFJFRS5HcmVhdGVyRXF1YWxEZXB0aDpcclxuXHJcblx0XHRcdFx0XHRcdGdsLmRlcHRoRnVuYyggZ2wuR0VRVUFMICk7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgVEhSRUUuR3JlYXRlckRlcHRoOlxyXG5cclxuXHRcdFx0XHRcdFx0Z2wuZGVwdGhGdW5jKCBnbC5HUkVBVEVSICk7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgVEhSRUUuTm90RXF1YWxEZXB0aDpcclxuXHJcblx0XHRcdFx0XHRcdGdsLmRlcHRoRnVuYyggZ2wuTk9URVFVQUwgKTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0ZGVmYXVsdDpcclxuXHJcblx0XHRcdFx0XHRcdGdsLmRlcHRoRnVuYyggZ2wuTEVRVUFMICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGdsLmRlcHRoRnVuYyggZ2wuTEVRVUFMICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRjdXJyZW50RGVwdGhGdW5jID0gZGVwdGhGdW5jO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5zZXREZXB0aFRlc3QgPSBmdW5jdGlvbiAoIGRlcHRoVGVzdCApIHtcclxuXHJcblx0XHRpZiAoIGRlcHRoVGVzdCApIHtcclxuXHJcblx0XHRcdHRoaXMuZW5hYmxlKCBnbC5ERVBUSF9URVNUICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHRoaXMuZGlzYWJsZSggZ2wuREVQVEhfVEVTVCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5zZXREZXB0aFdyaXRlID0gZnVuY3Rpb24gKCBkZXB0aFdyaXRlICkge1xyXG5cclxuXHRcdC8vIFRPRE86IFJlbmFtZSB0byBzZXREZXB0aE1hc2tcclxuXHJcblx0XHRpZiAoIGN1cnJlbnREZXB0aFdyaXRlICE9PSBkZXB0aFdyaXRlICkge1xyXG5cclxuXHRcdFx0Z2wuZGVwdGhNYXNrKCBkZXB0aFdyaXRlICk7XHJcblx0XHRcdGN1cnJlbnREZXB0aFdyaXRlID0gZGVwdGhXcml0ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuc2V0Q29sb3JXcml0ZSA9IGZ1bmN0aW9uICggY29sb3JXcml0ZSApIHtcclxuXHJcblx0XHQvLyBUT0RPOiBSZW5hbWUgdG8gc2V0Q29sb3JNYXNrXHJcblxyXG5cdFx0aWYgKCBjdXJyZW50Q29sb3JXcml0ZSAhPT0gY29sb3JXcml0ZSApIHtcclxuXHJcblx0XHRcdGdsLmNvbG9yTWFzayggY29sb3JXcml0ZSwgY29sb3JXcml0ZSwgY29sb3JXcml0ZSwgY29sb3JXcml0ZSApO1xyXG5cdFx0XHRjdXJyZW50Q29sb3JXcml0ZSA9IGNvbG9yV3JpdGU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLnNldFN0ZW5jaWxGdW5jID0gZnVuY3Rpb24gKCBzdGVuY2lsRnVuYywgc3RlbmNpbFJlZiwgc3RlbmNpbE1hc2sgKSB7XHJcblxyXG5cdFx0aWYgKCBjdXJyZW50U3RlbmNpbEZ1bmMgIT09IHN0ZW5jaWxGdW5jIHx8XHJcblx0XHRcdFx0IGN1cnJlbnRTdGVuY2lsUmVmIFx0IT09IHN0ZW5jaWxSZWYgXHR8fFxyXG5cdFx0XHRcdCBjdXJyZW50U3RlbmNpbE1hc2sgIT09IHN0ZW5jaWxNYXNrICkge1xyXG5cclxuXHRcdFx0Z2wuc3RlbmNpbEZ1bmMoIHN0ZW5jaWxGdW5jLCAgc3RlbmNpbFJlZiwgc3RlbmNpbE1hc2sgKTtcclxuXHJcblx0XHRcdGN1cnJlbnRTdGVuY2lsRnVuYyA9IHN0ZW5jaWxGdW5jO1xyXG5cdFx0XHRjdXJyZW50U3RlbmNpbFJlZiAgPSBzdGVuY2lsUmVmO1xyXG5cdFx0XHRjdXJyZW50U3RlbmNpbE1hc2sgPSBzdGVuY2lsTWFzaztcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuc2V0U3RlbmNpbE9wID0gZnVuY3Rpb24gKCBzdGVuY2lsRmFpbCwgc3RlbmNpbFpGYWlsLCBzdGVuY2lsWlBhc3MgKSB7XHJcblxyXG5cdFx0aWYgKCBjdXJyZW50U3RlbmNpbEZhaWxcdCAhPT0gc3RlbmNpbEZhaWwgXHR8fFxyXG5cdFx0XHRcdCBjdXJyZW50U3RlbmNpbFpGYWlsICE9PSBzdGVuY2lsWkZhaWwgfHxcclxuXHRcdFx0XHQgY3VycmVudFN0ZW5jaWxaUGFzcyAhPT0gc3RlbmNpbFpQYXNzICkge1xyXG5cclxuXHRcdFx0Z2wuc3RlbmNpbE9wKCBzdGVuY2lsRmFpbCwgIHN0ZW5jaWxaRmFpbCwgc3RlbmNpbFpQYXNzICk7XHJcblxyXG5cdFx0XHRjdXJyZW50U3RlbmNpbEZhaWwgID0gc3RlbmNpbEZhaWw7XHJcblx0XHRcdGN1cnJlbnRTdGVuY2lsWkZhaWwgPSBzdGVuY2lsWkZhaWw7XHJcblx0XHRcdGN1cnJlbnRTdGVuY2lsWlBhc3MgPSBzdGVuY2lsWlBhc3M7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLnNldFN0ZW5jaWxUZXN0ID0gZnVuY3Rpb24gKCBzdGVuY2lsVGVzdCApIHtcclxuXHJcblx0XHRpZiAoIHN0ZW5jaWxUZXN0ICkge1xyXG5cclxuXHRcdFx0dGhpcy5lbmFibGUoIGdsLlNURU5DSUxfVEVTVCApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHR0aGlzLmRpc2FibGUoIGdsLlNURU5DSUxfVEVTVCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5zZXRTdGVuY2lsV3JpdGUgPSBmdW5jdGlvbiAoIHN0ZW5jaWxXcml0ZSApIHtcclxuXHJcblx0XHQvLyBUT0RPOiBSZW5hbWUgdG8gc2V0U3RlbmNpbE1hc2tcclxuXHJcblx0XHRpZiAoIGN1cnJlbnRTdGVuY2lsV3JpdGUgIT09IHN0ZW5jaWxXcml0ZSApIHtcclxuXHJcblx0XHRcdGdsLnN0ZW5jaWxNYXNrKCBzdGVuY2lsV3JpdGUgKTtcclxuXHRcdFx0Y3VycmVudFN0ZW5jaWxXcml0ZSA9IHN0ZW5jaWxXcml0ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuc2V0RmxpcFNpZGVkID0gZnVuY3Rpb24gKCBmbGlwU2lkZWQgKSB7XHJcblxyXG5cdFx0aWYgKCBjdXJyZW50RmxpcFNpZGVkICE9PSBmbGlwU2lkZWQgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGZsaXBTaWRlZCApIHtcclxuXHJcblx0XHRcdFx0Z2wuZnJvbnRGYWNlKCBnbC5DVyApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Z2wuZnJvbnRGYWNlKCBnbC5DQ1cgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGN1cnJlbnRGbGlwU2lkZWQgPSBmbGlwU2lkZWQ7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLnNldExpbmVXaWR0aCA9IGZ1bmN0aW9uICggd2lkdGggKSB7XHJcblxyXG5cdFx0aWYgKCB3aWR0aCAhPT0gY3VycmVudExpbmVXaWR0aCApIHtcclxuXHJcblx0XHRcdGdsLmxpbmVXaWR0aCggd2lkdGggKTtcclxuXHJcblx0XHRcdGN1cnJlbnRMaW5lV2lkdGggPSB3aWR0aDtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuc2V0UG9seWdvbk9mZnNldCA9IGZ1bmN0aW9uICggcG9seWdvbk9mZnNldCwgZmFjdG9yLCB1bml0cyApIHtcclxuXHJcblx0XHRpZiAoIHBvbHlnb25PZmZzZXQgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmVuYWJsZSggZ2wuUE9MWUdPTl9PRkZTRVRfRklMTCApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHR0aGlzLmRpc2FibGUoIGdsLlBPTFlHT05fT0ZGU0VUX0ZJTEwgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBwb2x5Z29uT2Zmc2V0ICYmICggY3VycmVudFBvbHlnb25PZmZzZXRGYWN0b3IgIT09IGZhY3RvciB8fCBjdXJyZW50UG9seWdvbk9mZnNldFVuaXRzICE9PSB1bml0cyApICkge1xyXG5cclxuXHRcdFx0Z2wucG9seWdvbk9mZnNldCggZmFjdG9yLCB1bml0cyApO1xyXG5cclxuXHRcdFx0Y3VycmVudFBvbHlnb25PZmZzZXRGYWN0b3IgPSBmYWN0b3I7XHJcblx0XHRcdGN1cnJlbnRQb2x5Z29uT2Zmc2V0VW5pdHMgPSB1bml0cztcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuZ2V0U2Npc3NvclRlc3QgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIGN1cnJlbnRTY2lzc29yVGVzdDtcclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5zZXRTY2lzc29yVGVzdCA9IGZ1bmN0aW9uICggc2Npc3NvclRlc3QgKSB7XHJcblxyXG5cdFx0Y3VycmVudFNjaXNzb3JUZXN0ID0gc2Npc3NvclRlc3Q7XHJcblxyXG5cdFx0aWYgKCBzY2lzc29yVGVzdCApIHtcclxuXHJcblx0XHRcdHRoaXMuZW5hYmxlKCBnbC5TQ0lTU09SX1RFU1QgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0dGhpcy5kaXNhYmxlKCBnbC5TQ0lTU09SX1RFU1QgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdC8vIHRleHR1cmVcclxuXHJcblx0dGhpcy5hY3RpdmVUZXh0dXJlID0gZnVuY3Rpb24gKCB3ZWJnbFNsb3QgKSB7XHJcblxyXG5cdFx0aWYgKCB3ZWJnbFNsb3QgPT09IHVuZGVmaW5lZCApIHdlYmdsU2xvdCA9IGdsLlRFWFRVUkUwICsgbWF4VGV4dHVyZXMgLSAxO1xyXG5cclxuXHRcdGlmICggY3VycmVudFRleHR1cmVTbG90ICE9PSB3ZWJnbFNsb3QgKSB7XHJcblxyXG5cdFx0XHRnbC5hY3RpdmVUZXh0dXJlKCB3ZWJnbFNsb3QgKTtcclxuXHRcdFx0Y3VycmVudFRleHR1cmVTbG90ID0gd2ViZ2xTbG90O1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5iaW5kVGV4dHVyZSA9IGZ1bmN0aW9uICggd2ViZ2xUeXBlLCB3ZWJnbFRleHR1cmUgKSB7XHJcblxyXG5cdFx0aWYgKCBjdXJyZW50VGV4dHVyZVNsb3QgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdF90aGlzLmFjdGl2ZVRleHR1cmUoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGJvdW5kVGV4dHVyZSA9IGN1cnJlbnRCb3VuZFRleHR1cmVzWyBjdXJyZW50VGV4dHVyZVNsb3QgXTtcclxuXHJcblx0XHRpZiAoIGJvdW5kVGV4dHVyZSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Ym91bmRUZXh0dXJlID0geyB0eXBlOiB1bmRlZmluZWQsIHRleHR1cmU6IHVuZGVmaW5lZCB9O1xyXG5cdFx0XHRjdXJyZW50Qm91bmRUZXh0dXJlc1sgY3VycmVudFRleHR1cmVTbG90IF0gPSBib3VuZFRleHR1cmU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggYm91bmRUZXh0dXJlLnR5cGUgIT09IHdlYmdsVHlwZSB8fCBib3VuZFRleHR1cmUudGV4dHVyZSAhPT0gd2ViZ2xUZXh0dXJlICkge1xyXG5cclxuXHRcdFx0Z2wuYmluZFRleHR1cmUoIHdlYmdsVHlwZSwgd2ViZ2xUZXh0dXJlICk7XHJcblxyXG5cdFx0XHRib3VuZFRleHR1cmUudHlwZSA9IHdlYmdsVHlwZTtcclxuXHRcdFx0Ym91bmRUZXh0dXJlLnRleHR1cmUgPSB3ZWJnbFRleHR1cmU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLmNvbXByZXNzZWRUZXhJbWFnZTJEID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRyeSB7XHJcblxyXG5cdFx0XHRnbC5jb21wcmVzc2VkVGV4SW1hZ2UyRC5hcHBseSggZ2wsIGFyZ3VtZW50cyApO1xyXG5cclxuXHRcdH0gY2F0Y2ggKCBlcnJvciApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoIGVycm9yICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLnRleEltYWdlMkQgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dHJ5IHtcclxuXHJcblx0XHRcdGdsLnRleEltYWdlMkQuYXBwbHkoIGdsLCBhcmd1bWVudHMgKTtcclxuXHJcblx0XHR9IGNhdGNoICggZXJyb3IgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLmVycm9yKCBlcnJvciApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0Ly8gY2xlYXIgdmFsdWVzXHJcblxyXG5cdHRoaXMuY2xlYXJDb2xvciA9IGZ1bmN0aW9uICggciwgZywgYiwgYSApIHtcclxuXHJcblx0XHRjb2xvci5zZXQoIHIsIGcsIGIsIGEgKTtcclxuXHJcblx0XHRpZiAoIGN1cnJlbnRDbGVhckNvbG9yLmVxdWFscyggY29sb3IgKSA9PT0gZmFsc2UgKSB7XHJcblxyXG5cdFx0XHRnbC5jbGVhckNvbG9yKCByLCBnLCBiLCBhICk7XHJcblx0XHRcdGN1cnJlbnRDbGVhckNvbG9yLmNvcHkoIGNvbG9yICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLmNsZWFyRGVwdGggPSBmdW5jdGlvbiAoIGRlcHRoICkge1xyXG5cclxuXHRcdGlmICggY3VycmVudENsZWFyRGVwdGggIT09IGRlcHRoICkge1xyXG5cclxuXHRcdFx0Z2wuY2xlYXJEZXB0aCggZGVwdGggKTtcclxuXHRcdFx0Y3VycmVudENsZWFyRGVwdGggPSBkZXB0aDtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuY2xlYXJTdGVuY2lsID0gZnVuY3Rpb24gKCBzdGVuY2lsICkge1xyXG5cclxuXHRcdGlmICggY3VycmVudENsZWFyU3RlbmNpbCAhPT0gc3RlbmNpbCApIHtcclxuXHJcblx0XHRcdGdsLmNsZWFyU3RlbmNpbCggc3RlbmNpbCApO1xyXG5cdFx0XHRjdXJyZW50Q2xlYXJTdGVuY2lsID0gc3RlbmNpbDtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdC8vXHJcblxyXG5cdHRoaXMuc2Npc3NvciA9IGZ1bmN0aW9uICggc2Npc3NvciApIHtcclxuXHJcblx0XHRpZiAoIGN1cnJlbnRTY2lzc29yLmVxdWFscyggc2Npc3NvciApID09PSBmYWxzZSApIHtcclxuXHJcblx0XHRcdGdsLnNjaXNzb3IoIHNjaXNzb3IueCwgc2Npc3Nvci55LCBzY2lzc29yLnosIHNjaXNzb3IudyApO1xyXG5cdFx0XHRjdXJyZW50U2Npc3Nvci5jb3B5KCBzY2lzc29yICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLnZpZXdwb3J0ID0gZnVuY3Rpb24gKCB2aWV3cG9ydCApIHtcclxuXHJcblx0XHRpZiAoIGN1cnJlbnRWaWV3cG9ydC5lcXVhbHMoIHZpZXdwb3J0ICkgPT09IGZhbHNlICkge1xyXG5cclxuXHRcdFx0Z2wudmlld3BvcnQoIHZpZXdwb3J0LngsIHZpZXdwb3J0LnksIHZpZXdwb3J0LnosIHZpZXdwb3J0LncgKTtcclxuXHRcdFx0Y3VycmVudFZpZXdwb3J0LmNvcHkoIHZpZXdwb3J0ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHQvL1xyXG5cclxuXHR0aGlzLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGVuYWJsZWRBdHRyaWJ1dGVzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdGlmICggZW5hYmxlZEF0dHJpYnV0ZXNbIGkgXSA9PT0gMSApIHtcclxuXHJcblx0XHRcdFx0Z2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KCBpICk7XHJcblx0XHRcdFx0ZW5hYmxlZEF0dHJpYnV0ZXNbIGkgXSA9IDA7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGNhcGFiaWxpdGllcyA9IHt9O1xyXG5cclxuXHRcdGNvbXByZXNzZWRUZXh0dXJlRm9ybWF0cyA9IG51bGw7XHJcblxyXG5cdFx0Y3VycmVudEJsZW5kaW5nID0gbnVsbDtcclxuXHJcblx0XHRjdXJyZW50Q29sb3JXcml0ZSA9IG51bGw7XHJcblx0XHRjdXJyZW50RGVwdGhXcml0ZSA9IG51bGw7XHJcblx0XHRjdXJyZW50U3RlbmNpbFdyaXRlID0gbnVsbDtcclxuXHJcblx0XHRjdXJyZW50RmxpcFNpZGVkID0gbnVsbDtcclxuXHJcblx0fTtcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvd2ViZ2wvcGx1Z2lucy9MZW5zRmxhcmVQbHVnaW4uanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkxlbnNGbGFyZVBsdWdpbiA9IGZ1bmN0aW9uICggcmVuZGVyZXIsIGZsYXJlcyApIHtcclxuXHJcblx0dmFyIGdsID0gcmVuZGVyZXIuY29udGV4dDtcclxuXHR2YXIgc3RhdGUgPSByZW5kZXJlci5zdGF0ZTtcclxuXHJcblx0dmFyIHZlcnRleEJ1ZmZlciwgZWxlbWVudEJ1ZmZlcjtcclxuXHR2YXIgcHJvZ3JhbSwgYXR0cmlidXRlcywgdW5pZm9ybXM7XHJcblx0dmFyIGhhc1ZlcnRleFRleHR1cmU7XHJcblxyXG5cdHZhciB0ZW1wVGV4dHVyZSwgb2NjbHVzaW9uVGV4dHVyZTtcclxuXHJcblx0ZnVuY3Rpb24gaW5pdCgpIHtcclxuXHJcblx0XHR2YXIgdmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KCBbXHJcblx0XHRcdC0gMSwgLSAxLCAgMCwgMCxcclxuXHRcdFx0IDEsIC0gMSwgIDEsIDAsXHJcblx0XHRcdCAxLCAgMSwgIDEsIDEsXHJcblx0XHRcdC0gMSwgIDEsICAwLCAxXHJcblx0XHRdICk7XHJcblxyXG5cdFx0dmFyIGZhY2VzID0gbmV3IFVpbnQxNkFycmF5KCBbXHJcblx0XHRcdDAsIDEsIDIsXHJcblx0XHRcdDAsIDIsIDNcclxuXHRcdF0gKTtcclxuXHJcblx0XHQvLyBidWZmZXJzXHJcblxyXG5cdFx0dmVydGV4QnVmZmVyICAgICA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xyXG5cdFx0ZWxlbWVudEJ1ZmZlciAgICA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xyXG5cclxuXHRcdGdsLmJpbmRCdWZmZXIoIGdsLkFSUkFZX0JVRkZFUiwgdmVydGV4QnVmZmVyICk7XHJcblx0XHRnbC5idWZmZXJEYXRhKCBnbC5BUlJBWV9CVUZGRVIsIHZlcnRpY2VzLCBnbC5TVEFUSUNfRFJBVyApO1xyXG5cclxuXHRcdGdsLmJpbmRCdWZmZXIoIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBlbGVtZW50QnVmZmVyICk7XHJcblx0XHRnbC5idWZmZXJEYXRhKCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgZmFjZXMsIGdsLlNUQVRJQ19EUkFXICk7XHJcblxyXG5cdFx0Ly8gdGV4dHVyZXNcclxuXHJcblx0XHR0ZW1wVGV4dHVyZSAgICAgID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xyXG5cdFx0b2NjbHVzaW9uVGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcclxuXHJcblx0XHRzdGF0ZS5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgdGVtcFRleHR1cmUgKTtcclxuXHRcdGdsLnRleEltYWdlMkQoIGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQiwgMTYsIDE2LCAwLCBnbC5SR0IsIGdsLlVOU0lHTkVEX0JZVEUsIG51bGwgKTtcclxuXHRcdGdsLnRleFBhcmFtZXRlcmkoIGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFICk7XHJcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKCBnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSApO1xyXG5cdFx0Z2wudGV4UGFyYW1ldGVyaSggZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUICk7XHJcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKCBnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QgKTtcclxuXHJcblx0XHRzdGF0ZS5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgb2NjbHVzaW9uVGV4dHVyZSApO1xyXG5cdFx0Z2wudGV4SW1hZ2UyRCggZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgMTYsIDE2LCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBudWxsICk7XHJcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKCBnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSApO1xyXG5cdFx0Z2wudGV4UGFyYW1ldGVyaSggZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UgKTtcclxuXHRcdGdsLnRleFBhcmFtZXRlcmkoIGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTkVBUkVTVCApO1xyXG5cdFx0Z2wudGV4UGFyYW1ldGVyaSggZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUICk7XHJcblxyXG5cdFx0aGFzVmVydGV4VGV4dHVyZSA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX1ZFUlRFWF9URVhUVVJFX0lNQUdFX1VOSVRTICkgPiAwO1xyXG5cclxuXHRcdHZhciBzaGFkZXI7XHJcblxyXG5cdFx0aWYgKCBoYXNWZXJ0ZXhUZXh0dXJlICkge1xyXG5cclxuXHRcdFx0c2hhZGVyID0ge1xyXG5cclxuXHRcdFx0XHR2ZXJ0ZXhTaGFkZXI6IFtcclxuXHJcblx0XHRcdFx0XHRcInVuaWZvcm0gbG93cCBpbnQgcmVuZGVyVHlwZTtcIixcclxuXHJcblx0XHRcdFx0XHRcInVuaWZvcm0gdmVjMyBzY3JlZW5Qb3NpdGlvbjtcIixcclxuXHRcdFx0XHRcdFwidW5pZm9ybSB2ZWMyIHNjYWxlO1wiLFxyXG5cdFx0XHRcdFx0XCJ1bmlmb3JtIGZsb2F0IHJvdGF0aW9uO1wiLFxyXG5cclxuXHRcdFx0XHRcdFwidW5pZm9ybSBzYW1wbGVyMkQgb2NjbHVzaW9uTWFwO1wiLFxyXG5cclxuXHRcdFx0XHRcdFwiYXR0cmlidXRlIHZlYzIgcG9zaXRpb247XCIsXHJcblx0XHRcdFx0XHRcImF0dHJpYnV0ZSB2ZWMyIHV2O1wiLFxyXG5cclxuXHRcdFx0XHRcdFwidmFyeWluZyB2ZWMyIHZVVjtcIixcclxuXHRcdFx0XHRcdFwidmFyeWluZyBmbG9hdCB2VmlzaWJpbGl0eTtcIixcclxuXHJcblx0XHRcdFx0XHRcInZvaWQgbWFpbigpIHtcIixcclxuXHJcblx0XHRcdFx0XHRcdFwidlVWID0gdXY7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcInZlYzIgcG9zID0gcG9zaXRpb247XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcImlmICggcmVuZGVyVHlwZSA9PSAyICkge1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XHRcInZlYzQgdmlzaWJpbGl0eSA9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjEsIDAuMSApICk7XCIsXHJcblx0XHRcdFx0XHRcdFx0XCJ2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjUsIDAuMSApICk7XCIsXHJcblx0XHRcdFx0XHRcdFx0XCJ2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjksIDAuMSApICk7XCIsXHJcblx0XHRcdFx0XHRcdFx0XCJ2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjksIDAuNSApICk7XCIsXHJcblx0XHRcdFx0XHRcdFx0XCJ2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjksIDAuOSApICk7XCIsXHJcblx0XHRcdFx0XHRcdFx0XCJ2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjUsIDAuOSApICk7XCIsXHJcblx0XHRcdFx0XHRcdFx0XCJ2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjEsIDAuOSApICk7XCIsXHJcblx0XHRcdFx0XHRcdFx0XCJ2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjEsIDAuNSApICk7XCIsXHJcblx0XHRcdFx0XHRcdFx0XCJ2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjUsIDAuNSApICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcdFwidlZpc2liaWxpdHkgPSAgICAgICAgdmlzaWJpbGl0eS5yIC8gOS4wO1wiLFxyXG5cdFx0XHRcdFx0XHRcdFwidlZpc2liaWxpdHkgKj0gMS4wIC0gdmlzaWJpbGl0eS5nIC8gOS4wO1wiLFxyXG5cdFx0XHRcdFx0XHRcdFwidlZpc2liaWxpdHkgKj0gICAgICAgdmlzaWJpbGl0eS5iIC8gOS4wO1wiLFxyXG5cdFx0XHRcdFx0XHRcdFwidlZpc2liaWxpdHkgKj0gMS4wIC0gdmlzaWJpbGl0eS5hIC8gOS4wO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XHRcInBvcy54ID0gY29zKCByb3RhdGlvbiApICogcG9zaXRpb24ueCAtIHNpbiggcm90YXRpb24gKSAqIHBvc2l0aW9uLnk7XCIsXHJcblx0XHRcdFx0XHRcdFx0XCJwb3MueSA9IHNpbiggcm90YXRpb24gKSAqIHBvc2l0aW9uLnggKyBjb3MoIHJvdGF0aW9uICkgKiBwb3NpdGlvbi55O1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJ9XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcImdsX1Bvc2l0aW9uID0gdmVjNCggKCBwb3MgKiBzY2FsZSArIHNjcmVlblBvc2l0aW9uLnh5ICkueHksIHNjcmVlblBvc2l0aW9uLnosIDEuMCApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFwifVwiXHJcblxyXG5cdFx0XHRcdF0uam9pbiggXCJcXG5cIiApLFxyXG5cclxuXHRcdFx0XHRmcmFnbWVudFNoYWRlcjogW1xyXG5cclxuXHRcdFx0XHRcdFwidW5pZm9ybSBsb3dwIGludCByZW5kZXJUeXBlO1wiLFxyXG5cclxuXHRcdFx0XHRcdFwidW5pZm9ybSBzYW1wbGVyMkQgbWFwO1wiLFxyXG5cdFx0XHRcdFx0XCJ1bmlmb3JtIGZsb2F0IG9wYWNpdHk7XCIsXHJcblx0XHRcdFx0XHRcInVuaWZvcm0gdmVjMyBjb2xvcjtcIixcclxuXHJcblx0XHRcdFx0XHRcInZhcnlpbmcgdmVjMiB2VVY7XCIsXHJcblx0XHRcdFx0XHRcInZhcnlpbmcgZmxvYXQgdlZpc2liaWxpdHk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHQvLyBwaW5rIHNxdWFyZVxyXG5cclxuXHRcdFx0XHRcdFx0XCJpZiAoIHJlbmRlclR5cGUgPT0gMCApIHtcIixcclxuXHJcblx0XHRcdFx0XHRcdFx0XCJnbF9GcmFnQ29sb3IgPSB2ZWM0KCAxLjAsIDAuMCwgMS4wLCAwLjAgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcdC8vIHJlc3RvcmVcclxuXHJcblx0XHRcdFx0XHRcdFwifSBlbHNlIGlmICggcmVuZGVyVHlwZSA9PSAxICkge1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XHRcImdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCggbWFwLCB2VVYgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcdC8vIGZsYXJlXHJcblxyXG5cdFx0XHRcdFx0XHRcIn0gZWxzZSB7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcdFwidmVjNCB0ZXh0dXJlID0gdGV4dHVyZTJEKCBtYXAsIHZVViApO1wiLFxyXG5cdFx0XHRcdFx0XHRcdFwidGV4dHVyZS5hICo9IG9wYWNpdHkgKiB2VmlzaWJpbGl0eTtcIixcclxuXHRcdFx0XHRcdFx0XHRcImdsX0ZyYWdDb2xvciA9IHRleHR1cmU7XCIsXHJcblx0XHRcdFx0XHRcdFx0XCJnbF9GcmFnQ29sb3IucmdiICo9IGNvbG9yO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJ9XCIsXHJcblxyXG5cdFx0XHRcdFx0XCJ9XCJcclxuXHJcblx0XHRcdFx0XS5qb2luKCBcIlxcblwiIClcclxuXHJcblx0XHRcdH07XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHNoYWRlciA9IHtcclxuXHJcblx0XHRcdFx0dmVydGV4U2hhZGVyOiBbXHJcblxyXG5cdFx0XHRcdFx0XCJ1bmlmb3JtIGxvd3AgaW50IHJlbmRlclR5cGU7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCJ1bmlmb3JtIHZlYzMgc2NyZWVuUG9zaXRpb247XCIsXHJcblx0XHRcdFx0XHRcInVuaWZvcm0gdmVjMiBzY2FsZTtcIixcclxuXHRcdFx0XHRcdFwidW5pZm9ybSBmbG9hdCByb3RhdGlvbjtcIixcclxuXHJcblx0XHRcdFx0XHRcImF0dHJpYnV0ZSB2ZWMyIHBvc2l0aW9uO1wiLFxyXG5cdFx0XHRcdFx0XCJhdHRyaWJ1dGUgdmVjMiB1djtcIixcclxuXHJcblx0XHRcdFx0XHRcInZhcnlpbmcgdmVjMiB2VVY7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcInZVViA9IHV2O1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJ2ZWMyIHBvcyA9IHBvc2l0aW9uO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJpZiAoIHJlbmRlclR5cGUgPT0gMiApIHtcIixcclxuXHJcblx0XHRcdFx0XHRcdFx0XCJwb3MueCA9IGNvcyggcm90YXRpb24gKSAqIHBvc2l0aW9uLnggLSBzaW4oIHJvdGF0aW9uICkgKiBwb3NpdGlvbi55O1wiLFxyXG5cdFx0XHRcdFx0XHRcdFwicG9zLnkgPSBzaW4oIHJvdGF0aW9uICkgKiBwb3NpdGlvbi54ICsgY29zKCByb3RhdGlvbiApICogcG9zaXRpb24ueTtcIixcclxuXHJcblx0XHRcdFx0XHRcdFwifVwiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJnbF9Qb3NpdGlvbiA9IHZlYzQoICggcG9zICogc2NhbGUgKyBzY3JlZW5Qb3NpdGlvbi54eSApLnh5LCBzY3JlZW5Qb3NpdGlvbi56LCAxLjAgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcIn1cIlxyXG5cclxuXHRcdFx0XHRdLmpvaW4oIFwiXFxuXCIgKSxcclxuXHJcblx0XHRcdFx0ZnJhZ21lbnRTaGFkZXI6IFtcclxuXHJcblx0XHRcdFx0XHRcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1wiLFxyXG5cclxuXHRcdFx0XHRcdFwidW5pZm9ybSBsb3dwIGludCByZW5kZXJUeXBlO1wiLFxyXG5cclxuXHRcdFx0XHRcdFwidW5pZm9ybSBzYW1wbGVyMkQgbWFwO1wiLFxyXG5cdFx0XHRcdFx0XCJ1bmlmb3JtIHNhbXBsZXIyRCBvY2NsdXNpb25NYXA7XCIsXHJcblx0XHRcdFx0XHRcInVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcIixcclxuXHRcdFx0XHRcdFwidW5pZm9ybSB2ZWMzIGNvbG9yO1wiLFxyXG5cclxuXHRcdFx0XHRcdFwidmFyeWluZyB2ZWMyIHZVVjtcIixcclxuXHJcblx0XHRcdFx0XHRcInZvaWQgbWFpbigpIHtcIixcclxuXHJcblx0XHRcdFx0XHRcdC8vIHBpbmsgc3F1YXJlXHJcblxyXG5cdFx0XHRcdFx0XHRcImlmICggcmVuZGVyVHlwZSA9PSAwICkge1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XHRcImdsX0ZyYWdDb2xvciA9IHZlYzQoIHRleHR1cmUyRCggbWFwLCB2VVYgKS5yZ2IsIDAuMCApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0Ly8gcmVzdG9yZVxyXG5cclxuXHRcdFx0XHRcdFx0XCJ9IGVsc2UgaWYgKCByZW5kZXJUeXBlID09IDEgKSB7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcdFwiZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKCBtYXAsIHZVViApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0Ly8gZmxhcmVcclxuXHJcblx0XHRcdFx0XHRcdFwifSBlbHNlIHtcIixcclxuXHJcblx0XHRcdFx0XHRcdFx0XCJmbG9hdCB2aXNpYmlsaXR5ID0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuNSwgMC4xICkgKS5hO1wiLFxyXG5cdFx0XHRcdFx0XHRcdFwidmlzaWJpbGl0eSArPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC45LCAwLjUgKSApLmE7XCIsXHJcblx0XHRcdFx0XHRcdFx0XCJ2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjUsIDAuOSApICkuYTtcIixcclxuXHRcdFx0XHRcdFx0XHRcInZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuMSwgMC41ICkgKS5hO1wiLFxyXG5cdFx0XHRcdFx0XHRcdFwidmlzaWJpbGl0eSA9ICggMS4wIC0gdmlzaWJpbGl0eSAvIDQuMCApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XHRcInZlYzQgdGV4dHVyZSA9IHRleHR1cmUyRCggbWFwLCB2VVYgKTtcIixcclxuXHRcdFx0XHRcdFx0XHRcInRleHR1cmUuYSAqPSBvcGFjaXR5ICogdmlzaWJpbGl0eTtcIixcclxuXHRcdFx0XHRcdFx0XHRcImdsX0ZyYWdDb2xvciA9IHRleHR1cmU7XCIsXHJcblx0XHRcdFx0XHRcdFx0XCJnbF9GcmFnQ29sb3IucmdiICo9IGNvbG9yO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJ9XCIsXHJcblxyXG5cdFx0XHRcdFx0XCJ9XCJcclxuXHJcblx0XHRcdFx0XS5qb2luKCBcIlxcblwiIClcclxuXHJcblx0XHRcdH07XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHByb2dyYW0gPSBjcmVhdGVQcm9ncmFtKCBzaGFkZXIgKTtcclxuXHJcblx0XHRhdHRyaWJ1dGVzID0ge1xyXG5cdFx0XHR2ZXJ0ZXg6IGdsLmdldEF0dHJpYkxvY2F0aW9uICggcHJvZ3JhbSwgXCJwb3NpdGlvblwiICksXHJcblx0XHRcdHV2OiAgICAgZ2wuZ2V0QXR0cmliTG9jYXRpb24gKCBwcm9ncmFtLCBcInV2XCIgKVxyXG5cdFx0fTtcclxuXHJcblx0XHR1bmlmb3JtcyA9IHtcclxuXHRcdFx0cmVuZGVyVHlwZTogICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgXCJyZW5kZXJUeXBlXCIgKSxcclxuXHRcdFx0bWFwOiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgXCJtYXBcIiApLFxyXG5cdFx0XHRvY2NsdXNpb25NYXA6ICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCBcIm9jY2x1c2lvbk1hcFwiICksXHJcblx0XHRcdG9wYWNpdHk6ICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sIFwib3BhY2l0eVwiICksXHJcblx0XHRcdGNvbG9yOiAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sIFwiY29sb3JcIiApLFxyXG5cdFx0XHRzY2FsZTogICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCBcInNjYWxlXCIgKSxcclxuXHRcdFx0cm90YXRpb246ICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgXCJyb3RhdGlvblwiICksXHJcblx0XHRcdHNjcmVlblBvc2l0aW9uOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sIFwic2NyZWVuUG9zaXRpb25cIiApXHJcblx0XHR9O1xyXG5cclxuXHR9XHJcblxyXG5cdC8qXHJcblx0ICogUmVuZGVyIGxlbnMgZmxhcmVzXHJcblx0ICogTWV0aG9kOiByZW5kZXJzIDE2eDE2IDB4ZmYwMGZmLWNvbG9yZWQgcG9pbnRzIHNjYXR0ZXJlZCBvdmVyIHRoZSBsaWdodCBzb3VyY2UgYXJlYSxcclxuXHQgKiAgICAgICAgIHJlYWRzIHRoZXNlIGJhY2sgYW5kIGNhbGN1bGF0ZXMgb2NjbHVzaW9uLlxyXG5cdCAqL1xyXG5cclxuXHR0aGlzLnJlbmRlciA9IGZ1bmN0aW9uICggc2NlbmUsIGNhbWVyYSwgdmlld3BvcnQgKSB7XHJcblxyXG5cdFx0aWYgKCBmbGFyZXMubGVuZ3RoID09PSAwICkgcmV0dXJuO1xyXG5cclxuXHRcdHZhciB0ZW1wUG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdHZhciBpbnZBc3BlY3QgPSB2aWV3cG9ydC53IC8gdmlld3BvcnQueixcclxuXHRcdFx0aGFsZlZpZXdwb3J0V2lkdGggPSB2aWV3cG9ydC56ICogMC41LFxyXG5cdFx0XHRoYWxmVmlld3BvcnRIZWlnaHQgPSB2aWV3cG9ydC53ICogMC41O1xyXG5cclxuXHRcdHZhciBzaXplID0gMTYgLyB2aWV3cG9ydC53LFxyXG5cdFx0XHRzY2FsZSA9IG5ldyBUSFJFRS5WZWN0b3IyKCBzaXplICogaW52QXNwZWN0LCBzaXplICk7XHJcblxyXG5cdFx0dmFyIHNjcmVlblBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoIDEsIDEsIDAgKSxcclxuXHRcdFx0c2NyZWVuUG9zaXRpb25QaXhlbHMgPSBuZXcgVEhSRUUuVmVjdG9yMiggMSwgMSApO1xyXG5cclxuXHRcdGlmICggcHJvZ3JhbSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0aW5pdCgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRnbC51c2VQcm9ncmFtKCBwcm9ncmFtICk7XHJcblxyXG5cdFx0c3RhdGUuaW5pdEF0dHJpYnV0ZXMoKTtcclxuXHRcdHN0YXRlLmVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlcy52ZXJ0ZXggKTtcclxuXHRcdHN0YXRlLmVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlcy51diApO1xyXG5cdFx0c3RhdGUuZGlzYWJsZVVudXNlZEF0dHJpYnV0ZXMoKTtcclxuXHJcblx0XHQvLyBsb29wIHRocm91Z2ggYWxsIGxlbnMgZmxhcmVzIHRvIHVwZGF0ZSB0aGVpciBvY2NsdXNpb24gYW5kIHBvc2l0aW9uc1xyXG5cdFx0Ly8gc2V0dXAgZ2wgYW5kIGNvbW1vbiB1c2VkIGF0dHJpYnMvdW5pZm9ybXNcclxuXHJcblx0XHRnbC51bmlmb3JtMWkoIHVuaWZvcm1zLm9jY2x1c2lvbk1hcCwgMCApO1xyXG5cdFx0Z2wudW5pZm9ybTFpKCB1bmlmb3Jtcy5tYXAsIDEgKTtcclxuXHJcblx0XHRnbC5iaW5kQnVmZmVyKCBnbC5BUlJBWV9CVUZGRVIsIHZlcnRleEJ1ZmZlciApO1xyXG5cdFx0Z2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy52ZXJ0ZXgsIDIsIGdsLkZMT0FULCBmYWxzZSwgMiAqIDgsIDAgKTtcclxuXHRcdGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMudXYsIDIsIGdsLkZMT0FULCBmYWxzZSwgMiAqIDgsIDggKTtcclxuXHJcblx0XHRnbC5iaW5kQnVmZmVyKCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgZWxlbWVudEJ1ZmZlciApO1xyXG5cclxuXHRcdHN0YXRlLmRpc2FibGUoIGdsLkNVTExfRkFDRSApO1xyXG5cdFx0c3RhdGUuc2V0RGVwdGhXcml0ZSggZmFsc2UgKTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBmbGFyZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHNpemUgPSAxNiAvIHZpZXdwb3J0Lnc7XHJcblx0XHRcdHNjYWxlLnNldCggc2l6ZSAqIGludkFzcGVjdCwgc2l6ZSApO1xyXG5cclxuXHRcdFx0Ly8gY2FsYyBvYmplY3Qgc2NyZWVuIHBvc2l0aW9uXHJcblxyXG5cdFx0XHR2YXIgZmxhcmUgPSBmbGFyZXNbIGkgXTtcclxuXHJcblx0XHRcdHRlbXBQb3NpdGlvbi5zZXQoIGZsYXJlLm1hdHJpeFdvcmxkLmVsZW1lbnRzWyAxMiBdLCBmbGFyZS5tYXRyaXhXb3JsZC5lbGVtZW50c1sgMTMgXSwgZmxhcmUubWF0cml4V29ybGQuZWxlbWVudHNbIDE0IF0gKTtcclxuXHJcblx0XHRcdHRlbXBQb3NpdGlvbi5hcHBseU1hdHJpeDQoIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UgKTtcclxuXHRcdFx0dGVtcFBvc2l0aW9uLmFwcGx5UHJvamVjdGlvbiggY2FtZXJhLnByb2plY3Rpb25NYXRyaXggKTtcclxuXHJcblx0XHRcdC8vIHNldHVwIGFycmF5cyBmb3IgZ2wgcHJvZ3JhbXNcclxuXHJcblx0XHRcdHNjcmVlblBvc2l0aW9uLmNvcHkoIHRlbXBQb3NpdGlvbiApO1xyXG5cclxuXHRcdFx0c2NyZWVuUG9zaXRpb25QaXhlbHMueCA9IHNjcmVlblBvc2l0aW9uLnggKiBoYWxmVmlld3BvcnRXaWR0aCArIGhhbGZWaWV3cG9ydFdpZHRoO1xyXG5cdFx0XHRzY3JlZW5Qb3NpdGlvblBpeGVscy55ID0gc2NyZWVuUG9zaXRpb24ueSAqIGhhbGZWaWV3cG9ydEhlaWdodCArIGhhbGZWaWV3cG9ydEhlaWdodDtcclxuXHJcblx0XHRcdC8vIHNjcmVlbiBjdWxsXHJcblxyXG5cdFx0XHRpZiAoIGhhc1ZlcnRleFRleHR1cmUgfHwgKFxyXG5cdFx0XHRcdHNjcmVlblBvc2l0aW9uUGl4ZWxzLnggPiAwICYmXHJcblx0XHRcdFx0c2NyZWVuUG9zaXRpb25QaXhlbHMueCA8IHZpZXdwb3J0LnogJiZcclxuXHRcdFx0XHRzY3JlZW5Qb3NpdGlvblBpeGVscy55ID4gMCAmJlxyXG5cdFx0XHRcdHNjcmVlblBvc2l0aW9uUGl4ZWxzLnkgPCB2aWV3cG9ydC53ICkgKSB7XHJcblxyXG5cdFx0XHRcdC8vIHNhdmUgY3VycmVudCBSR0IgdG8gdGVtcCB0ZXh0dXJlXHJcblxyXG5cdFx0XHRcdHN0YXRlLmFjdGl2ZVRleHR1cmUoIGdsLlRFWFRVUkUwICk7XHJcblx0XHRcdFx0c3RhdGUuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIG51bGwgKTtcclxuXHRcdFx0XHRzdGF0ZS5hY3RpdmVUZXh0dXJlKCBnbC5URVhUVVJFMSApO1xyXG5cdFx0XHRcdHN0YXRlLmJpbmRUZXh0dXJlKCBnbC5URVhUVVJFXzJELCB0ZW1wVGV4dHVyZSApO1xyXG5cdFx0XHRcdGdsLmNvcHlUZXhJbWFnZTJEKCBnbC5URVhUVVJFXzJELCAwLCBnbC5SR0IsIHZpZXdwb3J0LnggKyBzY3JlZW5Qb3NpdGlvblBpeGVscy54IC0gOCwgdmlld3BvcnQueSArIHNjcmVlblBvc2l0aW9uUGl4ZWxzLnkgLSA4LCAxNiwgMTYsIDAgKTtcclxuXHJcblxyXG5cdFx0XHRcdC8vIHJlbmRlciBwaW5rIHF1YWRcclxuXHJcblx0XHRcdFx0Z2wudW5pZm9ybTFpKCB1bmlmb3Jtcy5yZW5kZXJUeXBlLCAwICk7XHJcblx0XHRcdFx0Z2wudW5pZm9ybTJmKCB1bmlmb3Jtcy5zY2FsZSwgc2NhbGUueCwgc2NhbGUueSApO1xyXG5cdFx0XHRcdGdsLnVuaWZvcm0zZiggdW5pZm9ybXMuc2NyZWVuUG9zaXRpb24sIHNjcmVlblBvc2l0aW9uLngsIHNjcmVlblBvc2l0aW9uLnksIHNjcmVlblBvc2l0aW9uLnogKTtcclxuXHJcblx0XHRcdFx0c3RhdGUuZGlzYWJsZSggZ2wuQkxFTkQgKTtcclxuXHRcdFx0XHRzdGF0ZS5lbmFibGUoIGdsLkRFUFRIX1RFU1QgKTtcclxuXHJcblx0XHRcdFx0Z2wuZHJhd0VsZW1lbnRzKCBnbC5UUklBTkdMRVMsIDYsIGdsLlVOU0lHTkVEX1NIT1JULCAwICk7XHJcblxyXG5cclxuXHRcdFx0XHQvLyBjb3B5IHJlc3VsdCB0byBvY2NsdXNpb25NYXBcclxuXHJcblx0XHRcdFx0c3RhdGUuYWN0aXZlVGV4dHVyZSggZ2wuVEVYVFVSRTAgKTtcclxuXHRcdFx0XHRzdGF0ZS5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgb2NjbHVzaW9uVGV4dHVyZSApO1xyXG5cdFx0XHRcdGdsLmNvcHlUZXhJbWFnZTJEKCBnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCB2aWV3cG9ydC54ICsgc2NyZWVuUG9zaXRpb25QaXhlbHMueCAtIDgsIHZpZXdwb3J0LnkgKyBzY3JlZW5Qb3NpdGlvblBpeGVscy55IC0gOCwgMTYsIDE2LCAwICk7XHJcblxyXG5cclxuXHRcdFx0XHQvLyByZXN0b3JlIGdyYXBoaWNzXHJcblxyXG5cdFx0XHRcdGdsLnVuaWZvcm0xaSggdW5pZm9ybXMucmVuZGVyVHlwZSwgMSApO1xyXG5cdFx0XHRcdHN0YXRlLmRpc2FibGUoIGdsLkRFUFRIX1RFU1QgKTtcclxuXHJcblx0XHRcdFx0c3RhdGUuYWN0aXZlVGV4dHVyZSggZ2wuVEVYVFVSRTEgKTtcclxuXHRcdFx0XHRzdGF0ZS5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgdGVtcFRleHR1cmUgKTtcclxuXHRcdFx0XHRnbC5kcmF3RWxlbWVudHMoIGdsLlRSSUFOR0xFUywgNiwgZ2wuVU5TSUdORURfU0hPUlQsIDAgKTtcclxuXHJcblxyXG5cdFx0XHRcdC8vIHVwZGF0ZSBvYmplY3QgcG9zaXRpb25zXHJcblxyXG5cdFx0XHRcdGZsYXJlLnBvc2l0aW9uU2NyZWVuLmNvcHkoIHNjcmVlblBvc2l0aW9uICk7XHJcblxyXG5cdFx0XHRcdGlmICggZmxhcmUuY3VzdG9tVXBkYXRlQ2FsbGJhY2sgKSB7XHJcblxyXG5cdFx0XHRcdFx0ZmxhcmUuY3VzdG9tVXBkYXRlQ2FsbGJhY2soIGZsYXJlICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0ZmxhcmUudXBkYXRlTGVuc0ZsYXJlcygpO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vIHJlbmRlciBmbGFyZXNcclxuXHJcblx0XHRcdFx0Z2wudW5pZm9ybTFpKCB1bmlmb3Jtcy5yZW5kZXJUeXBlLCAyICk7XHJcblx0XHRcdFx0c3RhdGUuZW5hYmxlKCBnbC5CTEVORCApO1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gZmxhcmUubGVuc0ZsYXJlcy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgc3ByaXRlID0gZmxhcmUubGVuc0ZsYXJlc1sgaiBdO1xyXG5cclxuXHRcdFx0XHRcdGlmICggc3ByaXRlLm9wYWNpdHkgPiAwLjAwMSAmJiBzcHJpdGUuc2NhbGUgPiAwLjAwMSApIHtcclxuXHJcblx0XHRcdFx0XHRcdHNjcmVlblBvc2l0aW9uLnggPSBzcHJpdGUueDtcclxuXHRcdFx0XHRcdFx0c2NyZWVuUG9zaXRpb24ueSA9IHNwcml0ZS55O1xyXG5cdFx0XHRcdFx0XHRzY3JlZW5Qb3NpdGlvbi56ID0gc3ByaXRlLno7XHJcblxyXG5cdFx0XHRcdFx0XHRzaXplID0gc3ByaXRlLnNpemUgKiBzcHJpdGUuc2NhbGUgLyB2aWV3cG9ydC53O1xyXG5cclxuXHRcdFx0XHRcdFx0c2NhbGUueCA9IHNpemUgKiBpbnZBc3BlY3Q7XHJcblx0XHRcdFx0XHRcdHNjYWxlLnkgPSBzaXplO1xyXG5cclxuXHRcdFx0XHRcdFx0Z2wudW5pZm9ybTNmKCB1bmlmb3Jtcy5zY3JlZW5Qb3NpdGlvbiwgc2NyZWVuUG9zaXRpb24ueCwgc2NyZWVuUG9zaXRpb24ueSwgc2NyZWVuUG9zaXRpb24ueiApO1xyXG5cdFx0XHRcdFx0XHRnbC51bmlmb3JtMmYoIHVuaWZvcm1zLnNjYWxlLCBzY2FsZS54LCBzY2FsZS55ICk7XHJcblx0XHRcdFx0XHRcdGdsLnVuaWZvcm0xZiggdW5pZm9ybXMucm90YXRpb24sIHNwcml0ZS5yb3RhdGlvbiApO1xyXG5cclxuXHRcdFx0XHRcdFx0Z2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5vcGFjaXR5LCBzcHJpdGUub3BhY2l0eSApO1xyXG5cdFx0XHRcdFx0XHRnbC51bmlmb3JtM2YoIHVuaWZvcm1zLmNvbG9yLCBzcHJpdGUuY29sb3Iuciwgc3ByaXRlLmNvbG9yLmcsIHNwcml0ZS5jb2xvci5iICk7XHJcblxyXG5cdFx0XHRcdFx0XHRzdGF0ZS5zZXRCbGVuZGluZyggc3ByaXRlLmJsZW5kaW5nLCBzcHJpdGUuYmxlbmRFcXVhdGlvbiwgc3ByaXRlLmJsZW5kU3JjLCBzcHJpdGUuYmxlbmREc3QgKTtcclxuXHRcdFx0XHRcdFx0cmVuZGVyZXIuc2V0VGV4dHVyZSggc3ByaXRlLnRleHR1cmUsIDEgKTtcclxuXHJcblx0XHRcdFx0XHRcdGdsLmRyYXdFbGVtZW50cyggZ2wuVFJJQU5HTEVTLCA2LCBnbC5VTlNJR05FRF9TSE9SVCwgMCApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyByZXN0b3JlIGdsXHJcblxyXG5cdFx0c3RhdGUuZW5hYmxlKCBnbC5DVUxMX0ZBQ0UgKTtcclxuXHRcdHN0YXRlLmVuYWJsZSggZ2wuREVQVEhfVEVTVCApO1xyXG5cdFx0c3RhdGUuc2V0RGVwdGhXcml0ZSggdHJ1ZSApO1xyXG5cclxuXHRcdHJlbmRlcmVyLnJlc2V0R0xTdGF0ZSgpO1xyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBjcmVhdGVQcm9ncmFtICggc2hhZGVyICkge1xyXG5cclxuXHRcdHZhciBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xyXG5cclxuXHRcdHZhciBmcmFnbWVudFNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlciggZ2wuRlJBR01FTlRfU0hBREVSICk7XHJcblx0XHR2YXIgdmVydGV4U2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKCBnbC5WRVJURVhfU0hBREVSICk7XHJcblxyXG5cdFx0dmFyIHByZWZpeCA9IFwicHJlY2lzaW9uIFwiICsgcmVuZGVyZXIuZ2V0UHJlY2lzaW9uKCkgKyBcIiBmbG9hdDtcXG5cIjtcclxuXHJcblx0XHRnbC5zaGFkZXJTb3VyY2UoIGZyYWdtZW50U2hhZGVyLCBwcmVmaXggKyBzaGFkZXIuZnJhZ21lbnRTaGFkZXIgKTtcclxuXHRcdGdsLnNoYWRlclNvdXJjZSggdmVydGV4U2hhZGVyLCBwcmVmaXggKyBzaGFkZXIudmVydGV4U2hhZGVyICk7XHJcblxyXG5cdFx0Z2wuY29tcGlsZVNoYWRlciggZnJhZ21lbnRTaGFkZXIgKTtcclxuXHRcdGdsLmNvbXBpbGVTaGFkZXIoIHZlcnRleFNoYWRlciApO1xyXG5cclxuXHRcdGdsLmF0dGFjaFNoYWRlciggcHJvZ3JhbSwgZnJhZ21lbnRTaGFkZXIgKTtcclxuXHRcdGdsLmF0dGFjaFNoYWRlciggcHJvZ3JhbSwgdmVydGV4U2hhZGVyICk7XHJcblxyXG5cdFx0Z2wubGlua1Byb2dyYW0oIHByb2dyYW0gKTtcclxuXHJcblx0XHRyZXR1cm4gcHJvZ3JhbTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL3JlbmRlcmVycy93ZWJnbC9wbHVnaW5zL1Nwcml0ZVBsdWdpbi5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuU3ByaXRlUGx1Z2luID0gZnVuY3Rpb24gKCByZW5kZXJlciwgc3ByaXRlcyApIHtcclxuXHJcblx0dmFyIGdsID0gcmVuZGVyZXIuY29udGV4dDtcclxuXHR2YXIgc3RhdGUgPSByZW5kZXJlci5zdGF0ZTtcclxuXHJcblx0dmFyIHZlcnRleEJ1ZmZlciwgZWxlbWVudEJ1ZmZlcjtcclxuXHR2YXIgcHJvZ3JhbSwgYXR0cmlidXRlcywgdW5pZm9ybXM7XHJcblxyXG5cdHZhciB0ZXh0dXJlO1xyXG5cclxuXHQvLyBkZWNvbXBvc2UgbWF0cml4V29ybGRcclxuXHJcblx0dmFyIHNwcml0ZVBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHR2YXIgc3ByaXRlUm90YXRpb24gPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xyXG5cdHZhciBzcHJpdGVTY2FsZSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdGZ1bmN0aW9uIGluaXQoKSB7XHJcblxyXG5cdFx0dmFyIHZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheSggW1xyXG5cdFx0XHQtIDAuNSwgLSAwLjUsICAwLCAwLFxyXG5cdFx0XHQgIDAuNSwgLSAwLjUsICAxLCAwLFxyXG5cdFx0XHQgIDAuNSwgICAwLjUsICAxLCAxLFxyXG5cdFx0XHQtIDAuNSwgICAwLjUsICAwLCAxXHJcblx0XHRdICk7XHJcblxyXG5cdFx0dmFyIGZhY2VzID0gbmV3IFVpbnQxNkFycmF5KCBbXHJcblx0XHRcdDAsIDEsIDIsXHJcblx0XHRcdDAsIDIsIDNcclxuXHRcdF0gKTtcclxuXHJcblx0XHR2ZXJ0ZXhCdWZmZXIgID0gZ2wuY3JlYXRlQnVmZmVyKCk7XHJcblx0XHRlbGVtZW50QnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XHJcblxyXG5cdFx0Z2wuYmluZEJ1ZmZlciggZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0ZXhCdWZmZXIgKTtcclxuXHRcdGdsLmJ1ZmZlckRhdGEoIGdsLkFSUkFZX0JVRkZFUiwgdmVydGljZXMsIGdsLlNUQVRJQ19EUkFXICk7XHJcblxyXG5cdFx0Z2wuYmluZEJ1ZmZlciggZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGVsZW1lbnRCdWZmZXIgKTtcclxuXHRcdGdsLmJ1ZmZlckRhdGEoIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBmYWNlcywgZ2wuU1RBVElDX0RSQVcgKTtcclxuXHJcblx0XHRwcm9ncmFtID0gY3JlYXRlUHJvZ3JhbSgpO1xyXG5cclxuXHRcdGF0dHJpYnV0ZXMgPSB7XHJcblx0XHRcdHBvc2l0aW9uOlx0XHRcdGdsLmdldEF0dHJpYkxvY2F0aW9uICggcHJvZ3JhbSwgJ3Bvc2l0aW9uJyApLFxyXG5cdFx0XHR1djpcdFx0XHRcdFx0Z2wuZ2V0QXR0cmliTG9jYXRpb24gKCBwcm9ncmFtLCAndXYnIClcclxuXHRcdH07XHJcblxyXG5cdFx0dW5pZm9ybXMgPSB7XHJcblx0XHRcdHV2T2Zmc2V0Olx0XHRcdGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ3V2T2Zmc2V0JyApLFxyXG5cdFx0XHR1dlNjYWxlOlx0XHRcdGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ3V2U2NhbGUnICksXHJcblxyXG5cdFx0XHRyb3RhdGlvbjpcdFx0XHRnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdyb3RhdGlvbicgKSxcclxuXHRcdFx0c2NhbGU6XHRcdFx0XHRnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdzY2FsZScgKSxcclxuXHJcblx0XHRcdGNvbG9yOlx0XHRcdFx0Z2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnY29sb3InICksXHJcblx0XHRcdG1hcDpcdFx0XHRcdGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ21hcCcgKSxcclxuXHRcdFx0b3BhY2l0eTpcdFx0XHRnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdvcGFjaXR5JyApLFxyXG5cclxuXHRcdFx0bW9kZWxWaWV3TWF0cml4OiBcdGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ21vZGVsVmlld01hdHJpeCcgKSxcclxuXHRcdFx0cHJvamVjdGlvbk1hdHJpeDpcdGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ3Byb2plY3Rpb25NYXRyaXgnICksXHJcblxyXG5cdFx0XHRmb2dUeXBlOlx0XHRcdGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ2ZvZ1R5cGUnICksXHJcblx0XHRcdGZvZ0RlbnNpdHk6XHRcdFx0Z2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnZm9nRGVuc2l0eScgKSxcclxuXHRcdFx0Zm9nTmVhcjpcdFx0XHRnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdmb2dOZWFyJyApLFxyXG5cdFx0XHRmb2dGYXI6XHRcdFx0XHRnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdmb2dGYXInICksXHJcblx0XHRcdGZvZ0NvbG9yOlx0XHRcdGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ2ZvZ0NvbG9yJyApLFxyXG5cclxuXHRcdFx0YWxwaGFUZXN0Olx0XHRcdGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ2FscGhhVGVzdCcgKVxyXG5cdFx0fTtcclxuXHJcblx0XHR2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2NhbnZhcycgKTtcclxuXHRcdGNhbnZhcy53aWR0aCA9IDg7XHJcblx0XHRjYW52YXMuaGVpZ2h0ID0gODtcclxuXHJcblx0XHR2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCAnMmQnICk7XHJcblx0XHRjb250ZXh0LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XHJcblx0XHRjb250ZXh0LmZpbGxSZWN0KCAwLCAwLCA4LCA4ICk7XHJcblxyXG5cdFx0dGV4dHVyZSA9IG5ldyBUSFJFRS5UZXh0dXJlKCBjYW52YXMgKTtcclxuXHRcdHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHR9XHJcblxyXG5cdHRoaXMucmVuZGVyID0gZnVuY3Rpb24gKCBzY2VuZSwgY2FtZXJhICkge1xyXG5cclxuXHRcdGlmICggc3ByaXRlcy5sZW5ndGggPT09IDAgKSByZXR1cm47XHJcblxyXG5cdFx0Ly8gc2V0dXAgZ2xcclxuXHJcblx0XHRpZiAoIHByb2dyYW0gPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGluaXQoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Z2wudXNlUHJvZ3JhbSggcHJvZ3JhbSApO1xyXG5cclxuXHRcdHN0YXRlLmluaXRBdHRyaWJ1dGVzKCk7XHJcblx0XHRzdGF0ZS5lbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXMucG9zaXRpb24gKTtcclxuXHRcdHN0YXRlLmVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlcy51diApO1xyXG5cdFx0c3RhdGUuZGlzYWJsZVVudXNlZEF0dHJpYnV0ZXMoKTtcclxuXHJcblx0XHRzdGF0ZS5kaXNhYmxlKCBnbC5DVUxMX0ZBQ0UgKTtcclxuXHRcdHN0YXRlLmVuYWJsZSggZ2wuQkxFTkQgKTtcclxuXHJcblx0XHRnbC5iaW5kQnVmZmVyKCBnbC5BUlJBWV9CVUZGRVIsIHZlcnRleEJ1ZmZlciApO1xyXG5cdFx0Z2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy5wb3NpdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAyICogOCwgMCApO1xyXG5cdFx0Z2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy51diwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAyICogOCwgOCApO1xyXG5cclxuXHRcdGdsLmJpbmRCdWZmZXIoIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBlbGVtZW50QnVmZmVyICk7XHJcblxyXG5cdFx0Z2wudW5pZm9ybU1hdHJpeDRmdiggdW5pZm9ybXMucHJvamVjdGlvbk1hdHJpeCwgZmFsc2UsIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4LmVsZW1lbnRzICk7XHJcblxyXG5cdFx0c3RhdGUuYWN0aXZlVGV4dHVyZSggZ2wuVEVYVFVSRTAgKTtcclxuXHRcdGdsLnVuaWZvcm0xaSggdW5pZm9ybXMubWFwLCAwICk7XHJcblxyXG5cdFx0dmFyIG9sZEZvZ1R5cGUgPSAwO1xyXG5cdFx0dmFyIHNjZW5lRm9nVHlwZSA9IDA7XHJcblx0XHR2YXIgZm9nID0gc2NlbmUuZm9nO1xyXG5cclxuXHRcdGlmICggZm9nICkge1xyXG5cclxuXHRcdFx0Z2wudW5pZm9ybTNmKCB1bmlmb3Jtcy5mb2dDb2xvciwgZm9nLmNvbG9yLnIsIGZvZy5jb2xvci5nLCBmb2cuY29sb3IuYiApO1xyXG5cclxuXHRcdFx0aWYgKCBmb2cgaW5zdGFuY2VvZiBUSFJFRS5Gb2cgKSB7XHJcblxyXG5cdFx0XHRcdGdsLnVuaWZvcm0xZiggdW5pZm9ybXMuZm9nTmVhciwgZm9nLm5lYXIgKTtcclxuXHRcdFx0XHRnbC51bmlmb3JtMWYoIHVuaWZvcm1zLmZvZ0ZhciwgZm9nLmZhciApO1xyXG5cclxuXHRcdFx0XHRnbC51bmlmb3JtMWkoIHVuaWZvcm1zLmZvZ1R5cGUsIDEgKTtcclxuXHRcdFx0XHRvbGRGb2dUeXBlID0gMTtcclxuXHRcdFx0XHRzY2VuZUZvZ1R5cGUgPSAxO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggZm9nIGluc3RhbmNlb2YgVEhSRUUuRm9nRXhwMiApIHtcclxuXHJcblx0XHRcdFx0Z2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5mb2dEZW5zaXR5LCBmb2cuZGVuc2l0eSApO1xyXG5cclxuXHRcdFx0XHRnbC51bmlmb3JtMWkoIHVuaWZvcm1zLmZvZ1R5cGUsIDIgKTtcclxuXHRcdFx0XHRvbGRGb2dUeXBlID0gMjtcclxuXHRcdFx0XHRzY2VuZUZvZ1R5cGUgPSAyO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRnbC51bmlmb3JtMWkoIHVuaWZvcm1zLmZvZ1R5cGUsIDAgKTtcclxuXHRcdFx0b2xkRm9nVHlwZSA9IDA7XHJcblx0XHRcdHNjZW5lRm9nVHlwZSA9IDA7XHJcblxyXG5cdFx0fVxyXG5cclxuXHJcblx0XHQvLyB1cGRhdGUgcG9zaXRpb25zIGFuZCBzb3J0XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gc3ByaXRlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIHNwcml0ZSA9IHNwcml0ZXNbIGkgXTtcclxuXHJcblx0XHRcdHNwcml0ZS5tb2RlbFZpZXdNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSwgc3ByaXRlLm1hdHJpeFdvcmxkICk7XHJcblx0XHRcdHNwcml0ZS56ID0gLSBzcHJpdGUubW9kZWxWaWV3TWF0cml4LmVsZW1lbnRzWyAxNCBdO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRzcHJpdGVzLnNvcnQoIHBhaW50ZXJTb3J0U3RhYmxlICk7XHJcblxyXG5cdFx0Ly8gcmVuZGVyIGFsbCBzcHJpdGVzXHJcblxyXG5cdFx0dmFyIHNjYWxlID0gW107XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gc3ByaXRlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIHNwcml0ZSA9IHNwcml0ZXNbIGkgXTtcclxuXHRcdFx0dmFyIG1hdGVyaWFsID0gc3ByaXRlLm1hdGVyaWFsO1xyXG5cclxuXHRcdFx0Z2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5hbHBoYVRlc3QsIG1hdGVyaWFsLmFscGhhVGVzdCApO1xyXG5cdFx0XHRnbC51bmlmb3JtTWF0cml4NGZ2KCB1bmlmb3Jtcy5tb2RlbFZpZXdNYXRyaXgsIGZhbHNlLCBzcHJpdGUubW9kZWxWaWV3TWF0cml4LmVsZW1lbnRzICk7XHJcblxyXG5cdFx0XHRzcHJpdGUubWF0cml4V29ybGQuZGVjb21wb3NlKCBzcHJpdGVQb3NpdGlvbiwgc3ByaXRlUm90YXRpb24sIHNwcml0ZVNjYWxlICk7XHJcblxyXG5cdFx0XHRzY2FsZVsgMCBdID0gc3ByaXRlU2NhbGUueDtcclxuXHRcdFx0c2NhbGVbIDEgXSA9IHNwcml0ZVNjYWxlLnk7XHJcblxyXG5cdFx0XHR2YXIgZm9nVHlwZSA9IDA7XHJcblxyXG5cdFx0XHRpZiAoIHNjZW5lLmZvZyAmJiBtYXRlcmlhbC5mb2cgKSB7XHJcblxyXG5cdFx0XHRcdGZvZ1R5cGUgPSBzY2VuZUZvZ1R5cGU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIG9sZEZvZ1R5cGUgIT09IGZvZ1R5cGUgKSB7XHJcblxyXG5cdFx0XHRcdGdsLnVuaWZvcm0xaSggdW5pZm9ybXMuZm9nVHlwZSwgZm9nVHlwZSApO1xyXG5cdFx0XHRcdG9sZEZvZ1R5cGUgPSBmb2dUeXBlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBtYXRlcmlhbC5tYXAgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdGdsLnVuaWZvcm0yZiggdW5pZm9ybXMudXZPZmZzZXQsIG1hdGVyaWFsLm1hcC5vZmZzZXQueCwgbWF0ZXJpYWwubWFwLm9mZnNldC55ICk7XHJcblx0XHRcdFx0Z2wudW5pZm9ybTJmKCB1bmlmb3Jtcy51dlNjYWxlLCBtYXRlcmlhbC5tYXAucmVwZWF0LngsIG1hdGVyaWFsLm1hcC5yZXBlYXQueSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Z2wudW5pZm9ybTJmKCB1bmlmb3Jtcy51dk9mZnNldCwgMCwgMCApO1xyXG5cdFx0XHRcdGdsLnVuaWZvcm0yZiggdW5pZm9ybXMudXZTY2FsZSwgMSwgMSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Z2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5vcGFjaXR5LCBtYXRlcmlhbC5vcGFjaXR5ICk7XHJcblx0XHRcdGdsLnVuaWZvcm0zZiggdW5pZm9ybXMuY29sb3IsIG1hdGVyaWFsLmNvbG9yLnIsIG1hdGVyaWFsLmNvbG9yLmcsIG1hdGVyaWFsLmNvbG9yLmIgKTtcclxuXHJcblx0XHRcdGdsLnVuaWZvcm0xZiggdW5pZm9ybXMucm90YXRpb24sIG1hdGVyaWFsLnJvdGF0aW9uICk7XHJcblx0XHRcdGdsLnVuaWZvcm0yZnYoIHVuaWZvcm1zLnNjYWxlLCBzY2FsZSApO1xyXG5cclxuXHRcdFx0c3RhdGUuc2V0QmxlbmRpbmcoIG1hdGVyaWFsLmJsZW5kaW5nLCBtYXRlcmlhbC5ibGVuZEVxdWF0aW9uLCBtYXRlcmlhbC5ibGVuZFNyYywgbWF0ZXJpYWwuYmxlbmREc3QgKTtcclxuXHRcdFx0c3RhdGUuc2V0RGVwdGhUZXN0KCBtYXRlcmlhbC5kZXB0aFRlc3QgKTtcclxuXHRcdFx0c3RhdGUuc2V0RGVwdGhXcml0ZSggbWF0ZXJpYWwuZGVwdGhXcml0ZSApO1xyXG5cclxuXHRcdFx0aWYgKCBtYXRlcmlhbC5tYXAgJiYgbWF0ZXJpYWwubWFwLmltYWdlICYmIG1hdGVyaWFsLm1hcC5pbWFnZS53aWR0aCApIHtcclxuXHJcblx0XHRcdFx0cmVuZGVyZXIuc2V0VGV4dHVyZSggbWF0ZXJpYWwubWFwLCAwICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRyZW5kZXJlci5zZXRUZXh0dXJlKCB0ZXh0dXJlLCAwICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRnbC5kcmF3RWxlbWVudHMoIGdsLlRSSUFOR0xFUywgNiwgZ2wuVU5TSUdORURfU0hPUlQsIDAgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gcmVzdG9yZSBnbFxyXG5cclxuXHRcdHN0YXRlLmVuYWJsZSggZ2wuQ1VMTF9GQUNFICk7XHJcblxyXG5cdFx0cmVuZGVyZXIucmVzZXRHTFN0YXRlKCk7XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIGNyZWF0ZVByb2dyYW0gKCkge1xyXG5cclxuXHRcdHZhciBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xyXG5cclxuXHRcdHZhciB2ZXJ0ZXhTaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoIGdsLlZFUlRFWF9TSEFERVIgKTtcclxuXHRcdHZhciBmcmFnbWVudFNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlciggZ2wuRlJBR01FTlRfU0hBREVSICk7XHJcblxyXG5cdFx0Z2wuc2hhZGVyU291cmNlKCB2ZXJ0ZXhTaGFkZXIsIFtcclxuXHJcblx0XHRcdCdwcmVjaXNpb24gJyArIHJlbmRlcmVyLmdldFByZWNpc2lvbigpICsgJyBmbG9hdDsnLFxyXG5cclxuXHRcdFx0J3VuaWZvcm0gbWF0NCBtb2RlbFZpZXdNYXRyaXg7JyxcclxuXHRcdFx0J3VuaWZvcm0gbWF0NCBwcm9qZWN0aW9uTWF0cml4OycsXHJcblx0XHRcdCd1bmlmb3JtIGZsb2F0IHJvdGF0aW9uOycsXHJcblx0XHRcdCd1bmlmb3JtIHZlYzIgc2NhbGU7JyxcclxuXHRcdFx0J3VuaWZvcm0gdmVjMiB1dk9mZnNldDsnLFxyXG5cdFx0XHQndW5pZm9ybSB2ZWMyIHV2U2NhbGU7JyxcclxuXHJcblx0XHRcdCdhdHRyaWJ1dGUgdmVjMiBwb3NpdGlvbjsnLFxyXG5cdFx0XHQnYXR0cmlidXRlIHZlYzIgdXY7JyxcclxuXHJcblx0XHRcdCd2YXJ5aW5nIHZlYzIgdlVWOycsXHJcblxyXG5cdFx0XHQndm9pZCBtYWluKCkgeycsXHJcblxyXG5cdFx0XHRcdCd2VVYgPSB1dk9mZnNldCArIHV2ICogdXZTY2FsZTsnLFxyXG5cclxuXHRcdFx0XHQndmVjMiBhbGlnbmVkUG9zaXRpb24gPSBwb3NpdGlvbiAqIHNjYWxlOycsXHJcblxyXG5cdFx0XHRcdCd2ZWMyIHJvdGF0ZWRQb3NpdGlvbjsnLFxyXG5cdFx0XHRcdCdyb3RhdGVkUG9zaXRpb24ueCA9IGNvcyggcm90YXRpb24gKSAqIGFsaWduZWRQb3NpdGlvbi54IC0gc2luKCByb3RhdGlvbiApICogYWxpZ25lZFBvc2l0aW9uLnk7JyxcclxuXHRcdFx0XHQncm90YXRlZFBvc2l0aW9uLnkgPSBzaW4oIHJvdGF0aW9uICkgKiBhbGlnbmVkUG9zaXRpb24ueCArIGNvcyggcm90YXRpb24gKSAqIGFsaWduZWRQb3NpdGlvbi55OycsXHJcblxyXG5cdFx0XHRcdCd2ZWM0IGZpbmFsUG9zaXRpb247JyxcclxuXHJcblx0XHRcdFx0J2ZpbmFsUG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCAwLjAsIDAuMCwgMC4wLCAxLjAgKTsnLFxyXG5cdFx0XHRcdCdmaW5hbFBvc2l0aW9uLnh5ICs9IHJvdGF0ZWRQb3NpdGlvbjsnLFxyXG5cdFx0XHRcdCdmaW5hbFBvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIGZpbmFsUG9zaXRpb247JyxcclxuXHJcblx0XHRcdFx0J2dsX1Bvc2l0aW9uID0gZmluYWxQb3NpdGlvbjsnLFxyXG5cclxuXHRcdFx0J30nXHJcblxyXG5cdFx0XS5qb2luKCAnXFxuJyApICk7XHJcblxyXG5cdFx0Z2wuc2hhZGVyU291cmNlKCBmcmFnbWVudFNoYWRlciwgW1xyXG5cclxuXHRcdFx0J3ByZWNpc2lvbiAnICsgcmVuZGVyZXIuZ2V0UHJlY2lzaW9uKCkgKyAnIGZsb2F0OycsXHJcblxyXG5cdFx0XHQndW5pZm9ybSB2ZWMzIGNvbG9yOycsXHJcblx0XHRcdCd1bmlmb3JtIHNhbXBsZXIyRCBtYXA7JyxcclxuXHRcdFx0J3VuaWZvcm0gZmxvYXQgb3BhY2l0eTsnLFxyXG5cclxuXHRcdFx0J3VuaWZvcm0gaW50IGZvZ1R5cGU7JyxcclxuXHRcdFx0J3VuaWZvcm0gdmVjMyBmb2dDb2xvcjsnLFxyXG5cdFx0XHQndW5pZm9ybSBmbG9hdCBmb2dEZW5zaXR5OycsXHJcblx0XHRcdCd1bmlmb3JtIGZsb2F0IGZvZ05lYXI7JyxcclxuXHRcdFx0J3VuaWZvcm0gZmxvYXQgZm9nRmFyOycsXHJcblx0XHRcdCd1bmlmb3JtIGZsb2F0IGFscGhhVGVzdDsnLFxyXG5cclxuXHRcdFx0J3ZhcnlpbmcgdmVjMiB2VVY7JyxcclxuXHJcblx0XHRcdCd2b2lkIG1haW4oKSB7JyxcclxuXHJcblx0XHRcdFx0J3ZlYzQgdGV4dHVyZSA9IHRleHR1cmUyRCggbWFwLCB2VVYgKTsnLFxyXG5cclxuXHRcdFx0XHQnaWYgKCB0ZXh0dXJlLmEgPCBhbHBoYVRlc3QgKSBkaXNjYXJkOycsXHJcblxyXG5cdFx0XHRcdCdnbF9GcmFnQ29sb3IgPSB2ZWM0KCBjb2xvciAqIHRleHR1cmUueHl6LCB0ZXh0dXJlLmEgKiBvcGFjaXR5ICk7JyxcclxuXHJcblx0XHRcdFx0J2lmICggZm9nVHlwZSA+IDAgKSB7JyxcclxuXHJcblx0XHRcdFx0XHQnZmxvYXQgZGVwdGggPSBnbF9GcmFnQ29vcmQueiAvIGdsX0ZyYWdDb29yZC53OycsXHJcblx0XHRcdFx0XHQnZmxvYXQgZm9nRmFjdG9yID0gMC4wOycsXHJcblxyXG5cdFx0XHRcdFx0J2lmICggZm9nVHlwZSA9PSAxICkgeycsXHJcblxyXG5cdFx0XHRcdFx0XHQnZm9nRmFjdG9yID0gc21vb3Roc3RlcCggZm9nTmVhciwgZm9nRmFyLCBkZXB0aCApOycsXHJcblxyXG5cdFx0XHRcdFx0J30gZWxzZSB7JyxcclxuXHJcblx0XHRcdFx0XHRcdCdjb25zdCBmbG9hdCBMT0cyID0gMS40NDI2OTU7JyxcclxuXHRcdFx0XHRcdFx0J2ZvZ0ZhY3RvciA9IGV4cDIoIC0gZm9nRGVuc2l0eSAqIGZvZ0RlbnNpdHkgKiBkZXB0aCAqIGRlcHRoICogTE9HMiApOycsXHJcblx0XHRcdFx0XHRcdCdmb2dGYWN0b3IgPSAxLjAgLSBjbGFtcCggZm9nRmFjdG9yLCAwLjAsIDEuMCApOycsXHJcblxyXG5cdFx0XHRcdFx0J30nLFxyXG5cclxuXHRcdFx0XHRcdCdnbF9GcmFnQ29sb3IgPSBtaXgoIGdsX0ZyYWdDb2xvciwgdmVjNCggZm9nQ29sb3IsIGdsX0ZyYWdDb2xvci53ICksIGZvZ0ZhY3RvciApOycsXHJcblxyXG5cdFx0XHRcdCd9JyxcclxuXHJcblx0XHRcdCd9J1xyXG5cclxuXHRcdF0uam9pbiggJ1xcbicgKSApO1xyXG5cclxuXHRcdGdsLmNvbXBpbGVTaGFkZXIoIHZlcnRleFNoYWRlciApO1xyXG5cdFx0Z2wuY29tcGlsZVNoYWRlciggZnJhZ21lbnRTaGFkZXIgKTtcclxuXHJcblx0XHRnbC5hdHRhY2hTaGFkZXIoIHByb2dyYW0sIHZlcnRleFNoYWRlciApO1xyXG5cdFx0Z2wuYXR0YWNoU2hhZGVyKCBwcm9ncmFtLCBmcmFnbWVudFNoYWRlciApO1xyXG5cclxuXHRcdGdsLmxpbmtQcm9ncmFtKCBwcm9ncmFtICk7XHJcblxyXG5cdFx0cmV0dXJuIHByb2dyYW07XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gcGFpbnRlclNvcnRTdGFibGUgKCBhLCBiICkge1xyXG5cdFx0XHJcblx0XHRpZiAoIGEucmVuZGVyT3JkZXIgIT09IGIucmVuZGVyT3JkZXIgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gYS5yZW5kZXJPcmRlciAtIGIucmVuZGVyT3JkZXI7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggYS56ICE9PSBiLnogKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gYi56IC0gYS56O1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gYi5pZCAtIGEuaWQ7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvVGhyZWUuTGVnYWN5LmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggVEhSRUUuQm94Mi5wcm90b3R5cGUsIHtcclxuXHRlbXB0eToge1xyXG5cdFx0dmFsdWU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQm94MjogLmVtcHR5KCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuaXNFbXB0eSgpLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMuaXNFbXB0eSgpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblx0aXNJbnRlcnNlY3Rpb25Cb3g6IHtcclxuXHRcdHZhbHVlOiBmdW5jdGlvbiAoIGJveCApIHtcclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQm94MjogLmlzSW50ZXJzZWN0aW9uQm94KCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuaW50ZXJzZWN0c0JveCgpLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMuaW50ZXJzZWN0c0JveCggYm94ICk7XHJcblx0XHR9XHJcblx0fVxyXG59ICk7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggVEhSRUUuQm94My5wcm90b3R5cGUsIHtcclxuXHRlbXB0eToge1xyXG5cdFx0dmFsdWU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQm94MzogLmVtcHR5KCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuaXNFbXB0eSgpLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMuaXNFbXB0eSgpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblx0aXNJbnRlcnNlY3Rpb25Cb3g6IHtcclxuXHRcdHZhbHVlOiBmdW5jdGlvbiAoIGJveCApIHtcclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQm94MzogLmlzSW50ZXJzZWN0aW9uQm94KCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuaW50ZXJzZWN0c0JveCgpLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMuaW50ZXJzZWN0c0JveCggYm94ICk7XHJcblx0XHR9XHJcblx0fSxcclxuXHRpc0ludGVyc2VjdGlvblNwaGVyZToge1xyXG5cdFx0dmFsdWU6IGZ1bmN0aW9uICggc3BoZXJlICkge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Cb3gzOiAuaXNJbnRlcnNlY3Rpb25TcGhlcmUoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5pbnRlcnNlY3RzU3BoZXJlKCkuJyApO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5pbnRlcnNlY3RzU3BoZXJlKCBzcGhlcmUgKTtcclxuXHRcdH1cclxuXHR9XHJcbn0gKTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBUSFJFRS5NYXRyaXgzLnByb3RvdHlwZSwge1xyXG5cdG11bHRpcGx5VmVjdG9yMzoge1xyXG5cdFx0dmFsdWU6IGZ1bmN0aW9uICggdmVjdG9yICkge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXgzOiAubXVsdGlwbHlWZWN0b3IzKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIHZlY3Rvci5hcHBseU1hdHJpeDMoIG1hdHJpeCApIGluc3RlYWQuJyApO1xyXG5cdFx0XHRyZXR1cm4gdmVjdG9yLmFwcGx5TWF0cml4MyggdGhpcyApO1xyXG5cdFx0fVxyXG5cdH0sXHJcblx0bXVsdGlwbHlWZWN0b3IzQXJyYXk6IHtcclxuXHRcdHZhbHVlOiBmdW5jdGlvbiAoIGEgKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDM6IC5tdWx0aXBseVZlY3RvcjNBcnJheSgpIGhhcyBiZWVuIHJlbmFtZWQuIFVzZSBtYXRyaXguYXBwbHlUb1ZlY3RvcjNBcnJheSggYXJyYXkgKSBpbnN0ZWFkLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMuYXBwbHlUb1ZlY3RvcjNBcnJheSggYSApO1xyXG5cdFx0fVxyXG5cdH1cclxufSApO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFRIUkVFLk1hdHJpeDQucHJvdG90eXBlLCB7XHJcblx0ZXh0cmFjdFBvc2l0aW9uOiB7XHJcblx0XHR2YWx1ZTogZnVuY3Rpb24gKCBtICkge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAuZXh0cmFjdFBvc2l0aW9uKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuY29weVBvc2l0aW9uKCkuJyApO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5jb3B5UG9zaXRpb24oIG0gKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cdHNldFJvdGF0aW9uRnJvbVF1YXRlcm5pb246IHtcclxuXHRcdHZhbHVlOiBmdW5jdGlvbiAoIHEgKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC5zZXRSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAubWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb24oKS4nICk7XHJcblx0XHRcdHJldHVybiB0aGlzLm1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKCBxICk7XHJcblx0XHR9XHJcblx0fSxcclxuXHRtdWx0aXBseVZlY3RvcjM6IHtcclxuXHRcdHZhbHVlOiBmdW5jdGlvbiAoIHZlY3RvciApIHtcclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLm11bHRpcGx5VmVjdG9yMygpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSB2ZWN0b3IuYXBwbHlNYXRyaXg0KCBtYXRyaXggKSBvciB2ZWN0b3IuYXBwbHlQcm9qZWN0aW9uKCBtYXRyaXggKSBpbnN0ZWFkLicgKTtcclxuXHRcdFx0cmV0dXJuIHZlY3Rvci5hcHBseVByb2plY3Rpb24oIHRoaXMgKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cdG11bHRpcGx5VmVjdG9yNDoge1xyXG5cdFx0dmFsdWU6IGZ1bmN0aW9uICggdmVjdG9yICkge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAubXVsdGlwbHlWZWN0b3I0KCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIHZlY3Rvci5hcHBseU1hdHJpeDQoIG1hdHJpeCApIGluc3RlYWQuJyApO1xyXG5cdFx0XHRyZXR1cm4gdmVjdG9yLmFwcGx5TWF0cml4NCggdGhpcyApO1xyXG5cdFx0fVxyXG5cdH0sXHJcblx0bXVsdGlwbHlWZWN0b3IzQXJyYXk6IHtcclxuXHRcdHZhbHVlOiBmdW5jdGlvbiAoIGEgKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC5tdWx0aXBseVZlY3RvcjNBcnJheSgpIGhhcyBiZWVuIHJlbmFtZWQuIFVzZSBtYXRyaXguYXBwbHlUb1ZlY3RvcjNBcnJheSggYXJyYXkgKSBpbnN0ZWFkLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMuYXBwbHlUb1ZlY3RvcjNBcnJheSggYSApO1xyXG5cdFx0fVxyXG5cdH0sXHJcblx0cm90YXRlQXhpczoge1xyXG5cdFx0dmFsdWU6IGZ1bmN0aW9uICggdiApIHtcclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLnJvdGF0ZUF4aXMoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgVmVjdG9yMy50cmFuc2Zvcm1EaXJlY3Rpb24oIG1hdHJpeCApIGluc3RlYWQuJyApO1xyXG5cdFx0XHR2LnRyYW5zZm9ybURpcmVjdGlvbiggdGhpcyApO1xyXG5cdFx0fVxyXG5cdH0sXHJcblx0Y3Jvc3NWZWN0b3I6IHtcclxuXHRcdHZhbHVlOiBmdW5jdGlvbiAoIHZlY3RvciApIHtcclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLmNyb3NzVmVjdG9yKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIHZlY3Rvci5hcHBseU1hdHJpeDQoIG1hdHJpeCApIGluc3RlYWQuJyApO1xyXG5cdFx0XHRyZXR1cm4gdmVjdG9yLmFwcGx5TWF0cml4NCggdGhpcyApO1xyXG5cdFx0fVxyXG5cdH0sXHJcblx0dHJhbnNsYXRlOiB7XHJcblx0XHR2YWx1ZTogZnVuY3Rpb24gKCB2ICkge1xyXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuTWF0cml4NDogLnRyYW5zbGF0ZSgpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xyXG5cdFx0fVxyXG5cdH0sXHJcblx0cm90YXRlWDoge1xyXG5cdFx0dmFsdWU6IGZ1bmN0aW9uICggYW5nbGUgKSB7XHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5NYXRyaXg0OiAucm90YXRlWCgpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xyXG5cdFx0fVxyXG5cdH0sXHJcblx0cm90YXRlWToge1xyXG5cdFx0dmFsdWU6IGZ1bmN0aW9uICggYW5nbGUgKSB7XHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5NYXRyaXg0OiAucm90YXRlWSgpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xyXG5cdFx0fVxyXG5cdH0sXHJcblx0cm90YXRlWjoge1xyXG5cdFx0dmFsdWU6IGZ1bmN0aW9uICggYW5nbGUgKSB7XHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5NYXRyaXg0OiAucm90YXRlWigpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xyXG5cdFx0fVxyXG5cdH0sXHJcblx0cm90YXRlQnlBeGlzOiB7XHJcblx0XHR2YWx1ZTogZnVuY3Rpb24gKCBheGlzLCBhbmdsZSApIHtcclxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLk1hdHJpeDQ6IC5yb3RhdGVCeUF4aXMoKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcclxuXHRcdH1cclxuXHR9XHJcbn0gKTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBUSFJFRS5QbGFuZS5wcm90b3R5cGUsIHtcclxuXHRpc0ludGVyc2VjdGlvbkxpbmU6IHtcclxuXHRcdHZhbHVlOiBmdW5jdGlvbiAoIGxpbmUgKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlBsYW5lOiAuaXNJbnRlcnNlY3Rpb25MaW5lKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuaW50ZXJzZWN0c0xpbmUoKS4nICk7XHJcblx0XHRcdHJldHVybiB0aGlzLmludGVyc2VjdHNMaW5lKCBsaW5lICk7XHJcblx0XHR9XHJcblx0fVxyXG59ICk7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggVEhSRUUuUXVhdGVybmlvbi5wcm90b3R5cGUsIHtcclxuXHRtdWx0aXBseVZlY3RvcjM6IHtcclxuXHRcdHZhbHVlOiBmdW5jdGlvbiAoIHZlY3RvciApIHtcclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuUXVhdGVybmlvbjogLm11bHRpcGx5VmVjdG9yMygpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBpcyBub3cgdmVjdG9yLmFwcGx5UXVhdGVybmlvbiggcXVhdGVybmlvbiApIGluc3RlYWQuJyApO1xyXG5cdFx0XHRyZXR1cm4gdmVjdG9yLmFwcGx5UXVhdGVybmlvbiggdGhpcyApO1xyXG5cdFx0fVxyXG5cdH1cclxufSApO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFRIUkVFLlJheS5wcm90b3R5cGUsIHtcclxuXHRpc0ludGVyc2VjdGlvbkJveDoge1xyXG5cdFx0dmFsdWU6IGZ1bmN0aW9uICggYm94ICkge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5SYXk6IC5pc0ludGVyc2VjdGlvbkJveCgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmludGVyc2VjdHNCb3goKS4nICk7XHJcblx0XHRcdHJldHVybiB0aGlzLmludGVyc2VjdHNCb3goIGJveCApO1xyXG5cdFx0fVxyXG5cdH0sXHJcblx0aXNJbnRlcnNlY3Rpb25QbGFuZToge1xyXG5cdFx0dmFsdWU6IGZ1bmN0aW9uICggcGxhbmUgKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlJheTogLmlzSW50ZXJzZWN0aW9uUGxhbmUoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5pbnRlcnNlY3RzUGxhbmUoKS4nICk7XHJcblx0XHRcdHJldHVybiB0aGlzLmludGVyc2VjdHNQbGFuZSggcGxhbmUgKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cdGlzSW50ZXJzZWN0aW9uU3BoZXJlOiB7XHJcblx0XHR2YWx1ZTogZnVuY3Rpb24gKCBzcGhlcmUgKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlJheTogLmlzSW50ZXJzZWN0aW9uU3BoZXJlKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuaW50ZXJzZWN0c1NwaGVyZSgpLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMuaW50ZXJzZWN0c1NwaGVyZSggc3BoZXJlICk7XHJcblx0XHR9XHJcblx0fVxyXG59ICk7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggVEhSRUUuVmVjdG9yMy5wcm90b3R5cGUsIHtcclxuXHRzZXRFdWxlckZyb21Sb3RhdGlvbk1hdHJpeDoge1xyXG5cdFx0dmFsdWU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlZlY3RvcjM6IC5zZXRFdWxlckZyb21Sb3RhdGlvbk1hdHJpeCgpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBFdWxlci5zZXRGcm9tUm90YXRpb25NYXRyaXgoKSBpbnN0ZWFkLicgKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cdHNldEV1bGVyRnJvbVF1YXRlcm5pb246IHtcclxuXHRcdHZhbHVlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5WZWN0b3IzOiAuc2V0RXVsZXJGcm9tUXVhdGVybmlvbigpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBFdWxlci5zZXRGcm9tUXVhdGVybmlvbigpIGluc3RlYWQuJyApO1xyXG5cdFx0fVxyXG5cdH0sXHJcblx0Z2V0UG9zaXRpb25Gcm9tTWF0cml4OiB7XHJcblx0XHR2YWx1ZTogZnVuY3Rpb24gKCBtICkge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IzOiAuZ2V0UG9zaXRpb25Gcm9tTWF0cml4KCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCkuJyApO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5zZXRGcm9tTWF0cml4UG9zaXRpb24oIG0gKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cdGdldFNjYWxlRnJvbU1hdHJpeDoge1xyXG5cdFx0dmFsdWU6IGZ1bmN0aW9uICggbSApIHtcclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLmdldFNjYWxlRnJvbU1hdHJpeCgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLnNldEZyb21NYXRyaXhTY2FsZSgpLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMuc2V0RnJvbU1hdHJpeFNjYWxlKCBtICk7XHJcblx0XHR9XHJcblx0fSxcclxuXHRnZXRDb2x1bW5Gcm9tTWF0cml4OiB7XHJcblx0XHR2YWx1ZTogZnVuY3Rpb24gKCBpbmRleCwgbWF0cml4ICkge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IzOiAuZ2V0Q29sdW1uRnJvbU1hdHJpeCgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLnNldEZyb21NYXRyaXhDb2x1bW4oKS4nICk7XHJcblx0XHRcdHJldHVybiB0aGlzLnNldEZyb21NYXRyaXhDb2x1bW4oIGluZGV4LCBtYXRyaXggKTtcclxuXHRcdH1cclxuXHR9XHJcbn0gKTtcclxuXHJcbi8vXHJcblxyXG5USFJFRS5GYWNlNCA9IGZ1bmN0aW9uICggYSwgYiwgYywgZCwgbm9ybWFsLCBjb2xvciwgbWF0ZXJpYWxJbmRleCApIHtcclxuXHJcblx0Y29uc29sZS53YXJuKCAnVEhSRUUuRmFjZTQgaGFzIGJlZW4gcmVtb3ZlZC4gQSBUSFJFRS5GYWNlMyB3aWxsIGJlIGNyZWF0ZWQgaW5zdGVhZC4nICk7XHJcblx0cmV0dXJuIG5ldyBUSFJFRS5GYWNlMyggYSwgYiwgYywgbm9ybWFsLCBjb2xvciwgbWF0ZXJpYWxJbmRleCApO1xyXG5cclxufTtcclxuXHJcbi8vXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlLCB7XHJcblx0ZXVsZXJPcmRlcjoge1xyXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdDNEOiAuZXVsZXJPcmRlciBpcyBub3cgLnJvdGF0aW9uLm9yZGVyLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMucm90YXRpb24ub3JkZXI7XHJcblx0XHR9LFxyXG5cdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3QzRDogLmV1bGVyT3JkZXIgaXMgbm93IC5yb3RhdGlvbi5vcmRlci4nICk7XHJcblx0XHRcdHRoaXMucm90YXRpb24ub3JkZXIgPSB2YWx1ZTtcclxuXHRcdH1cclxuXHR9LFxyXG5cdGdldENoaWxkQnlOYW1lOiB7XHJcblx0XHR2YWx1ZTogZnVuY3Rpb24gKCBuYW1lICkge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3QzRDogLmdldENoaWxkQnlOYW1lKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuZ2V0T2JqZWN0QnlOYW1lKCkuJyApO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRPYmplY3RCeU5hbWUoIG5hbWUgKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cdHJlbmRlckRlcHRoOiB7XHJcblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdDNEOiAucmVuZGVyRGVwdGggaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIC5yZW5kZXJPcmRlciwgaW5zdGVhZC4nICk7XHJcblx0XHR9XHJcblx0fSxcclxuXHR0cmFuc2xhdGU6IHtcclxuXHRcdHZhbHVlOiBmdW5jdGlvbiAoIGRpc3RhbmNlLCBheGlzICkge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3QzRDogLnRyYW5zbGF0ZSgpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSAudHJhbnNsYXRlT25BeGlzKCBheGlzLCBkaXN0YW5jZSApIGluc3RlYWQuJyApO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy50cmFuc2xhdGVPbkF4aXMoIGF4aXMsIGRpc3RhbmNlICk7XHJcblx0XHR9XHJcblx0fSxcclxuXHR1c2VRdWF0ZXJuaW9uOiB7XHJcblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0M0Q6IC51c2VRdWF0ZXJuaW9uIGhhcyBiZWVuIHJlbW92ZWQuIFRoZSBsaWJyYXJ5IG5vdyB1c2VzIHF1YXRlcm5pb25zIGJ5IGRlZmF1bHQuJyApO1xyXG5cdFx0fSxcclxuXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0M0Q6IC51c2VRdWF0ZXJuaW9uIGhhcyBiZWVuIHJlbW92ZWQuIFRoZSBsaWJyYXJ5IG5vdyB1c2VzIHF1YXRlcm5pb25zIGJ5IGRlZmF1bHQuJyApO1xyXG5cdFx0fVxyXG5cdH1cclxufSApO1xyXG5cclxuLy9cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBUSFJFRSwge1xyXG5cdFBvaW50Q2xvdWQ6IHtcclxuXHRcdHZhbHVlOiBmdW5jdGlvbiAoIGdlb21ldHJ5LCBtYXRlcmlhbCApIHtcclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuUG9pbnRDbG91ZCBoYXMgYmVlbiByZW5hbWVkIHRvIFRIUkVFLlBvaW50cy4nICk7XHJcblx0XHRcdHJldHVybiBuZXcgVEhSRUUuUG9pbnRzKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cdFBhcnRpY2xlU3lzdGVtOiB7XHJcblx0XHR2YWx1ZTogZnVuY3Rpb24gKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlBhcnRpY2xlU3lzdGVtIGhhcyBiZWVuIHJlbmFtZWQgdG8gVEhSRUUuUG9pbnRzLicgKTtcclxuXHRcdFx0cmV0dXJuIG5ldyBUSFJFRS5Qb2ludHMoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xyXG5cdFx0fVxyXG5cdH1cclxufSApO1xyXG5cclxuLy9cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBUSFJFRS5MaWdodC5wcm90b3R5cGUsIHtcclxuXHRvbmx5U2hhZG93OiB7XHJcblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkxpZ2h0OiAub25seVNoYWRvdyBoYXMgYmVlbiByZW1vdmVkLicgKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cdHNoYWRvd0NhbWVyYUZvdjoge1xyXG5cdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5MaWdodDogLnNoYWRvd0NhbWVyYUZvdiBpcyBub3cgLnNoYWRvdy5jYW1lcmEuZm92LicgKTtcclxuXHRcdFx0dGhpcy5zaGFkb3cuY2FtZXJhLmZvdiA9IHZhbHVlO1xyXG5cdFx0fVxyXG5cdH0sXHJcblx0c2hhZG93Q2FtZXJhTGVmdDoge1xyXG5cdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5MaWdodDogLnNoYWRvd0NhbWVyYUxlZnQgaXMgbm93IC5zaGFkb3cuY2FtZXJhLmxlZnQuJyApO1xyXG5cdFx0XHR0aGlzLnNoYWRvdy5jYW1lcmEubGVmdCA9IHZhbHVlO1xyXG5cdFx0fVxyXG5cdH0sXHJcblx0c2hhZG93Q2FtZXJhUmlnaHQ6IHtcclxuXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTGlnaHQ6IC5zaGFkb3dDYW1lcmFSaWdodCBpcyBub3cgLnNoYWRvdy5jYW1lcmEucmlnaHQuJyApO1xyXG5cdFx0XHR0aGlzLnNoYWRvdy5jYW1lcmEucmlnaHQgPSB2YWx1ZTtcclxuXHRcdH1cclxuXHR9LFxyXG5cdHNoYWRvd0NhbWVyYVRvcDoge1xyXG5cdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5MaWdodDogLnNoYWRvd0NhbWVyYVRvcCBpcyBub3cgLnNoYWRvdy5jYW1lcmEudG9wLicgKTtcclxuXHRcdFx0dGhpcy5zaGFkb3cuY2FtZXJhLnRvcCA9IHZhbHVlO1xyXG5cdFx0fVxyXG5cdH0sXHJcblx0c2hhZG93Q2FtZXJhQm90dG9tOiB7XHJcblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkxpZ2h0OiAuc2hhZG93Q2FtZXJhQm90dG9tIGlzIG5vdyAuc2hhZG93LmNhbWVyYS5ib3R0b20uJyApO1xyXG5cdFx0XHR0aGlzLnNoYWRvdy5jYW1lcmEuYm90dG9tID0gdmFsdWU7XHJcblx0XHR9XHJcblx0fSxcclxuXHRzaGFkb3dDYW1lcmFOZWFyOiB7XHJcblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkxpZ2h0OiAuc2hhZG93Q2FtZXJhTmVhciBpcyBub3cgLnNoYWRvdy5jYW1lcmEubmVhci4nICk7XHJcblx0XHRcdHRoaXMuc2hhZG93LmNhbWVyYS5uZWFyID0gdmFsdWU7XHJcblx0XHR9XHJcblx0fSxcclxuXHRzaGFkb3dDYW1lcmFGYXI6IHtcclxuXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTGlnaHQ6IC5zaGFkb3dDYW1lcmFGYXIgaXMgbm93IC5zaGFkb3cuY2FtZXJhLmZhci4nICk7XHJcblx0XHRcdHRoaXMuc2hhZG93LmNhbWVyYS5mYXIgPSB2YWx1ZTtcclxuXHRcdH1cclxuXHR9LFxyXG5cdHNoYWRvd0NhbWVyYVZpc2libGU6IHtcclxuXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTGlnaHQ6IC5zaGFkb3dDYW1lcmFWaXNpYmxlIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBuZXcgVEhSRUUuQ2FtZXJhSGVscGVyKCBsaWdodC5zaGFkb3cuY2FtZXJhICkgaW5zdGVhZC4nICk7XHJcblx0XHR9XHJcblx0fSxcclxuXHRzaGFkb3dCaWFzOiB7XHJcblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkxpZ2h0OiAuc2hhZG93QmlhcyBpcyBub3cgLnNoYWRvdy5iaWFzLicgKTtcclxuXHRcdFx0dGhpcy5zaGFkb3cuYmlhcyA9IHZhbHVlO1xyXG5cdFx0fVxyXG5cdH0sXHJcblx0c2hhZG93RGFya25lc3M6IHtcclxuXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTGlnaHQ6IC5zaGFkb3dEYXJrbmVzcyBoYXMgYmVlbiByZW1vdmVkLicgKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cdHNoYWRvd01hcFdpZHRoOiB7XHJcblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkxpZ2h0OiAuc2hhZG93TWFwV2lkdGggaXMgbm93IC5zaGFkb3cubWFwU2l6ZS53aWR0aC4nICk7XHJcblx0XHRcdHRoaXMuc2hhZG93Lm1hcFNpemUud2lkdGggPSB2YWx1ZTtcclxuXHRcdH1cclxuXHR9LFxyXG5cdHNoYWRvd01hcEhlaWdodDoge1xyXG5cdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5MaWdodDogLnNoYWRvd01hcEhlaWdodCBpcyBub3cgLnNoYWRvdy5tYXBTaXplLmhlaWdodC4nICk7XHJcblx0XHRcdHRoaXMuc2hhZG93Lm1hcFNpemUuaGVpZ2h0ID0gdmFsdWU7XHJcblx0XHR9XHJcblx0fVxyXG59ICk7XHJcblxyXG4vL1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUsIHtcclxuXHRsZW5ndGg6IHtcclxuXHRcdGdldDogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJBdHRyaWJ1dGU6IC5sZW5ndGggaGFzIGJlZW4gZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSAuY291bnQuJyApO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5hcnJheS5sZW5ndGg7XHJcblx0XHR9XHJcblx0fVxyXG59ICk7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggVEhSRUUuQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLCB7XHJcblx0ZHJhd2NhbGxzOiB7XHJcblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5OiAuZHJhd2NhbGxzIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmdyb3Vwcy4nICk7XHJcblx0XHRcdHJldHVybiB0aGlzLmdyb3VwcztcclxuXHRcdH1cclxuXHR9LFxyXG5cdG9mZnNldHM6IHtcclxuXHRcdGdldDogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLm9mZnNldHMgaGFzIGJlZW4gcmVuYW1lZCB0byAuZ3JvdXBzLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMuZ3JvdXBzO1xyXG5cdFx0fVxyXG5cdH0sXHJcblx0YWRkSW5kZXg6IHtcclxuXHRcdHZhbHVlOiBmdW5jdGlvbiAoIGluZGV4ICkge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLmFkZEluZGV4KCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuc2V0SW5kZXgoKS4nICk7XHJcblx0XHRcdHRoaXMuc2V0SW5kZXgoIGluZGV4ICk7XHJcblx0XHR9XHJcblx0fSxcclxuXHRhZGREcmF3Q2FsbDoge1xyXG5cdFx0dmFsdWU6IGZ1bmN0aW9uICggc3RhcnQsIGNvdW50LCBpbmRleE9mZnNldCApIHtcclxuXHRcdFx0aWYgKCBpbmRleE9mZnNldCAhPT0gdW5kZWZpbmVkICkge1xyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5OiAuYWRkRHJhd0NhbGwoKSBubyBsb25nZXIgc3VwcG9ydHMgaW5kZXhPZmZzZXQuJyApO1xyXG5cdFx0XHR9XHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5OiAuYWRkRHJhd0NhbGwoKSBpcyBub3cgLmFkZEdyb3VwKCkuJyApO1xyXG5cdFx0XHR0aGlzLmFkZEdyb3VwKCBzdGFydCwgY291bnQgKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cdGNsZWFyRHJhd0NhbGxzOiB7XHJcblx0XHR2YWx1ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLmNsZWFyRHJhd0NhbGxzKCkgaXMgbm93IC5jbGVhckdyb3VwcygpLicgKTtcclxuXHRcdFx0dGhpcy5jbGVhckdyb3VwcygpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblx0Y29tcHV0ZVRhbmdlbnRzOiB7XHJcblx0XHR2YWx1ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLmNvbXB1dGVUYW5nZW50cygpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xyXG5cdFx0fVxyXG5cdH0sXHJcblx0Y29tcHV0ZU9mZnNldHM6IHtcclxuXHRcdHZhbHVlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5OiAuY29tcHV0ZU9mZnNldHMoKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcclxuXHRcdH1cclxuXHR9XHJcbn0gKTtcclxuXHJcbi8vXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlLCB7XHJcblx0d3JhcEFyb3VuZDoge1xyXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLicgKyB0aGlzLnR5cGUgKyAnOiAud3JhcEFyb3VuZCBoYXMgYmVlbiByZW1vdmVkLicgKTtcclxuXHRcdH0sXHJcblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLicgKyB0aGlzLnR5cGUgKyAnOiAud3JhcEFyb3VuZCBoYXMgYmVlbiByZW1vdmVkLicgKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cdHdyYXBSR0I6IHtcclxuXHRcdGdldDogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS4nICsgdGhpcy50eXBlICsgJzogLndyYXBSR0IgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XHJcblx0XHRcdHJldHVybiBuZXcgVEhSRUUuQ29sb3IoKTtcclxuXHRcdH1cclxuXHR9XHJcbn0gKTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBUSFJFRSwge1xyXG5cdFBvaW50Q2xvdWRNYXRlcmlhbDoge1xyXG5cdFx0dmFsdWU6IGZ1bmN0aW9uICggcGFyYW1ldGVycyApIHtcclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuUG9pbnRDbG91ZE1hdGVyaWFsIGhhcyBiZWVuIHJlbmFtZWQgdG8gVEhSRUUuUG9pbnRzTWF0ZXJpYWwuJyApO1xyXG5cdFx0XHRyZXR1cm4gbmV3IFRIUkVFLlBvaW50c01hdGVyaWFsKCBwYXJhbWV0ZXJzICk7XHJcblx0XHR9XHJcblx0fSxcclxuXHRQYXJ0aWNsZUJhc2ljTWF0ZXJpYWw6IHtcclxuXHRcdHZhbHVlOiBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlBhcnRpY2xlQmFzaWNNYXRlcmlhbCBoYXMgYmVlbiByZW5hbWVkIHRvIFRIUkVFLlBvaW50c01hdGVyaWFsLicgKTtcclxuXHRcdFx0cmV0dXJuIG5ldyBUSFJFRS5Qb2ludHNNYXRlcmlhbCggcGFyYW1ldGVycyApO1xyXG5cdFx0fVxyXG5cdH0sXHJcblx0UGFydGljbGVTeXN0ZW1NYXRlcmlhbDp7XHJcblx0XHR2YWx1ZTogZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5QYXJ0aWNsZVN5c3RlbU1hdGVyaWFsIGhhcyBiZWVuIHJlbmFtZWQgdG8gVEhSRUUuUG9pbnRzTWF0ZXJpYWwuJyApO1xyXG5cdFx0XHRyZXR1cm4gbmV3IFRIUkVFLlBvaW50c01hdGVyaWFsKCBwYXJhbWV0ZXJzICk7XHJcblx0XHR9XHJcblx0fVxyXG59ICk7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwucHJvdG90eXBlLCB7XHJcblx0bWV0YWw6IHtcclxuXHRcdGdldDogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbDogLm1ldGFsIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBUSFJFRS5NZXNoU3RhbmRhcmRNYXRlcmlhbCBpbnN0ZWFkLicgKTtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fSxcclxuXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWVzaFBob25nTWF0ZXJpYWw6IC5tZXRhbCBoYXMgYmVlbiByZW1vdmVkLiBVc2UgVEhSRUUuTWVzaFN0YW5kYXJkTWF0ZXJpYWwgaW5zdGVhZCcgKTtcclxuXHRcdH1cclxuXHR9XHJcbn0gKTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBUSFJFRS5TaGFkZXJNYXRlcmlhbC5wcm90b3R5cGUsIHtcclxuXHRkZXJpdmF0aXZlczoge1xyXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlNoYWRlck1hdGVyaWFsOiAuZGVyaXZhdGl2ZXMgaGFzIGJlZW4gbW92ZWQgdG8gLmV4dGVuc2lvbnMuZGVyaXZhdGl2ZXMuJyApO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5leHRlbnNpb25zLmRlcml2YXRpdmVzO1xyXG5cdFx0fSxcclxuXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuIFNoYWRlck1hdGVyaWFsOiAuZGVyaXZhdGl2ZXMgaGFzIGJlZW4gbW92ZWQgdG8gLmV4dGVuc2lvbnMuZGVyaXZhdGl2ZXMuJyApO1xyXG5cdFx0XHR0aGlzLmV4dGVuc2lvbnMuZGVyaXZhdGl2ZXMgPSB2YWx1ZTtcclxuXHRcdH1cclxuXHR9XHJcbn0gKTtcclxuXHJcbi8vXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggVEhSRUUuV2ViR0xSZW5kZXJlci5wcm90b3R5cGUsIHtcclxuXHRzdXBwb3J0c0Zsb2F0VGV4dHVyZXM6IHtcclxuXHRcdHZhbHVlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zdXBwb3J0c0Zsb2F0VGV4dHVyZXMoKSBpcyBub3cgLmV4dGVuc2lvbnMuZ2V0KCBcXCdPRVNfdGV4dHVyZV9mbG9hdFxcJyApLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMuZXh0ZW5zaW9ucy5nZXQoICdPRVNfdGV4dHVyZV9mbG9hdCcgKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cdHN1cHBvcnRzSGFsZkZsb2F0VGV4dHVyZXM6IHtcclxuXHRcdHZhbHVlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zdXBwb3J0c0hhbGZGbG9hdFRleHR1cmVzKCkgaXMgbm93IC5leHRlbnNpb25zLmdldCggXFwnT0VTX3RleHR1cmVfaGFsZl9mbG9hdFxcJyApLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMuZXh0ZW5zaW9ucy5nZXQoICdPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0JyApO1xyXG5cdFx0fVxyXG5cdH0sXHJcblx0c3VwcG9ydHNTdGFuZGFyZERlcml2YXRpdmVzOiB7XHJcblx0XHR2YWx1ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc3VwcG9ydHNTdGFuZGFyZERlcml2YXRpdmVzKCkgaXMgbm93IC5leHRlbnNpb25zLmdldCggXFwnT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzXFwnICkuJyApO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5leHRlbnNpb25zLmdldCggJ09FU19zdGFuZGFyZF9kZXJpdmF0aXZlcycgKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cdHN1cHBvcnRzQ29tcHJlc3NlZFRleHR1cmVTM1RDOiB7XHJcblx0XHR2YWx1ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc3VwcG9ydHNDb21wcmVzc2VkVGV4dHVyZVMzVEMoKSBpcyBub3cgLmV4dGVuc2lvbnMuZ2V0KCBcXCdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0Y1xcJyApLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMuZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0YycgKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cdHN1cHBvcnRzQ29tcHJlc3NlZFRleHR1cmVQVlJUQzoge1xyXG5cdFx0dmFsdWU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLnN1cHBvcnRzQ29tcHJlc3NlZFRleHR1cmVQVlJUQygpIGlzIG5vdyAuZXh0ZW5zaW9ucy5nZXQoIFxcJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0Y1xcJyApLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMuZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMnICk7XHJcblx0XHR9XHJcblx0fSxcclxuXHRzdXBwb3J0c0JsZW5kTWluTWF4OiB7XHJcblx0XHR2YWx1ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc3VwcG9ydHNCbGVuZE1pbk1heCgpIGlzIG5vdyAuZXh0ZW5zaW9ucy5nZXQoIFxcJ0VYVF9ibGVuZF9taW5tYXhcXCcgKS4nICk7XHJcblx0XHRcdHJldHVybiB0aGlzLmV4dGVuc2lvbnMuZ2V0KCAnRVhUX2JsZW5kX21pbm1heCcgKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cdHN1cHBvcnRzVmVydGV4VGV4dHVyZXM6IHtcclxuXHRcdHZhbHVlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLmNhcGFiaWxpdGllcy52ZXJ0ZXhUZXh0dXJlcztcclxuXHRcdH1cclxuXHR9LFxyXG5cdHN1cHBvcnRzSW5zdGFuY2VkQXJyYXlzOiB7XHJcblx0XHR2YWx1ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc3VwcG9ydHNJbnN0YW5jZWRBcnJheXMoKSBpcyBub3cgLmV4dGVuc2lvbnMuZ2V0KCBcXCdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzXFwnICkuJyApO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5leHRlbnNpb25zLmdldCggJ0FOR0xFX2luc3RhbmNlZF9hcnJheXMnICk7XHJcblx0XHR9XHJcblx0fSxcclxuXHRlbmFibGVTY2lzc29yVGVzdDoge1xyXG5cdFx0dmFsdWU6IGZ1bmN0aW9uICggYm9vbGVhbiApIHtcclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLmVuYWJsZVNjaXNzb3JUZXN0KCkgaXMgbm93IC5zZXRTY2lzc29yVGVzdCgpLicgKTtcclxuXHRcdFx0dGhpcy5zZXRTY2lzc29yVGVzdCggYm9vbGVhbiApO1xyXG5cdFx0fVxyXG5cdH0sXHJcblx0aW5pdE1hdGVyaWFsOiB7XHJcblx0XHR2YWx1ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuaW5pdE1hdGVyaWFsKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XHJcblx0XHR9XHJcblx0fSxcclxuXHRhZGRQcmVQbHVnaW46IHtcclxuXHRcdHZhbHVlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5hZGRQcmVQbHVnaW4oKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cdGFkZFBvc3RQbHVnaW46IHtcclxuXHRcdHZhbHVlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5hZGRQb3N0UGx1Z2luKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XHJcblx0XHR9XHJcblx0fSxcclxuXHR1cGRhdGVTaGFkb3dNYXA6IHtcclxuXHRcdHZhbHVlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC51cGRhdGVTaGFkb3dNYXAoKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cdHNoYWRvd01hcEVuYWJsZWQ6IHtcclxuXHRcdGdldDogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5zaGFkb3dNYXAuZW5hYmxlZDtcclxuXHRcdH0sXHJcblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zaGFkb3dNYXBFbmFibGVkIGlzIG5vdyAuc2hhZG93TWFwLmVuYWJsZWQuJyApO1xyXG5cdFx0XHR0aGlzLnNoYWRvd01hcC5lbmFibGVkID0gdmFsdWU7XHJcblx0XHR9XHJcblx0fSxcclxuXHRzaGFkb3dNYXBUeXBlOiB7XHJcblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuc2hhZG93TWFwLnR5cGU7XHJcblx0XHR9LFxyXG5cdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc2hhZG93TWFwVHlwZSBpcyBub3cgLnNoYWRvd01hcC50eXBlLicgKTtcclxuXHRcdFx0dGhpcy5zaGFkb3dNYXAudHlwZSA9IHZhbHVlO1xyXG5cdFx0fVxyXG5cdH0sXHJcblx0c2hhZG93TWFwQ3VsbEZhY2U6IHtcclxuXHRcdGdldDogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5zaGFkb3dNYXAuY3VsbEZhY2U7XHJcblx0XHR9LFxyXG5cdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc2hhZG93TWFwQ3VsbEZhY2UgaXMgbm93IC5zaGFkb3dNYXAuY3VsbEZhY2UuJyApO1xyXG5cdFx0XHR0aGlzLnNoYWRvd01hcC5jdWxsRmFjZSA9IHZhbHVlO1xyXG5cdFx0fVxyXG5cdH1cclxufSApO1xyXG5cclxuLy9cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBUSFJFRS5XZWJHTFJlbmRlclRhcmdldC5wcm90b3R5cGUsIHtcclxuXHR3cmFwUzoge1xyXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAud3JhcFMgaXMgbm93IC50ZXh0dXJlLndyYXBTLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMudGV4dHVyZS53cmFwUztcclxuXHRcdH0sXHJcblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAud3JhcFMgaXMgbm93IC50ZXh0dXJlLndyYXBTLicgKTtcclxuXHRcdFx0dGhpcy50ZXh0dXJlLndyYXBTID0gdmFsdWU7XHJcblx0XHR9XHJcblx0fSxcclxuXHR3cmFwVDoge1xyXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAud3JhcFQgaXMgbm93IC50ZXh0dXJlLndyYXBULicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMudGV4dHVyZS53cmFwVDtcclxuXHRcdH0sXHJcblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAud3JhcFQgaXMgbm93IC50ZXh0dXJlLndyYXBULicgKTtcclxuXHRcdFx0dGhpcy50ZXh0dXJlLndyYXBUID0gdmFsdWU7XHJcblx0XHR9XHJcblx0fSxcclxuXHRtYWdGaWx0ZXI6IHtcclxuXHRcdGdldDogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLm1hZ0ZpbHRlciBpcyBub3cgLnRleHR1cmUubWFnRmlsdGVyLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMudGV4dHVyZS5tYWdGaWx0ZXI7XHJcblx0XHR9LFxyXG5cdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLm1hZ0ZpbHRlciBpcyBub3cgLnRleHR1cmUubWFnRmlsdGVyLicgKTtcclxuXHRcdFx0dGhpcy50ZXh0dXJlLm1hZ0ZpbHRlciA9IHZhbHVlO1xyXG5cdFx0fVxyXG5cdH0sXHJcblx0bWluRmlsdGVyOiB7XHJcblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5taW5GaWx0ZXIgaXMgbm93IC50ZXh0dXJlLm1pbkZpbHRlci4nICk7XHJcblx0XHRcdHJldHVybiB0aGlzLnRleHR1cmUubWluRmlsdGVyO1xyXG5cdFx0fSxcclxuXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5taW5GaWx0ZXIgaXMgbm93IC50ZXh0dXJlLm1pbkZpbHRlci4nICk7XHJcblx0XHRcdHRoaXMudGV4dHVyZS5taW5GaWx0ZXIgPSB2YWx1ZTtcclxuXHRcdH1cclxuXHR9LFxyXG5cdGFuaXNvdHJvcHk6IHtcclxuXHRcdGdldDogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLmFuaXNvdHJvcHkgaXMgbm93IC50ZXh0dXJlLmFuaXNvdHJvcHkuJyApO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy50ZXh0dXJlLmFuaXNvdHJvcHk7XHJcblx0XHR9LFxyXG5cdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLmFuaXNvdHJvcHkgaXMgbm93IC50ZXh0dXJlLmFuaXNvdHJvcHkuJyApO1xyXG5cdFx0XHR0aGlzLnRleHR1cmUuYW5pc290cm9weSA9IHZhbHVlO1xyXG5cdFx0fVxyXG5cdH0sXHJcblx0b2Zmc2V0OiB7XHJcblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5vZmZzZXQgaXMgbm93IC50ZXh0dXJlLm9mZnNldC4nICk7XHJcblx0XHRcdHJldHVybiB0aGlzLnRleHR1cmUub2Zmc2V0O1xyXG5cdFx0fSxcclxuXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5vZmZzZXQgaXMgbm93IC50ZXh0dXJlLm9mZnNldC4nICk7XHJcblx0XHRcdHRoaXMudGV4dHVyZS5vZmZzZXQgPSB2YWx1ZTtcclxuXHRcdH1cclxuXHR9LFxyXG5cdHJlcGVhdDoge1xyXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAucmVwZWF0IGlzIG5vdyAudGV4dHVyZS5yZXBlYXQuJyApO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy50ZXh0dXJlLnJlcGVhdDtcclxuXHRcdH0sXHJcblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAucmVwZWF0IGlzIG5vdyAudGV4dHVyZS5yZXBlYXQuJyApO1xyXG5cdFx0XHR0aGlzLnRleHR1cmUucmVwZWF0ID0gdmFsdWU7XHJcblx0XHR9XHJcblx0fSxcclxuXHRmb3JtYXQ6IHtcclxuXHRcdGdldDogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLmZvcm1hdCBpcyBub3cgLnRleHR1cmUuZm9ybWF0LicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMudGV4dHVyZS5mb3JtYXQ7XHJcblx0XHR9LFxyXG5cdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLmZvcm1hdCBpcyBub3cgLnRleHR1cmUuZm9ybWF0LicgKTtcclxuXHRcdFx0dGhpcy50ZXh0dXJlLmZvcm1hdCA9IHZhbHVlO1xyXG5cdFx0fVxyXG5cdH0sXHJcblx0dHlwZToge1xyXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAudHlwZSBpcyBub3cgLnRleHR1cmUudHlwZS4nICk7XHJcblx0XHRcdHJldHVybiB0aGlzLnRleHR1cmUudHlwZTtcclxuXHRcdH0sXHJcblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAudHlwZSBpcyBub3cgLnRleHR1cmUudHlwZS4nICk7XHJcblx0XHRcdHRoaXMudGV4dHVyZS50eXBlID0gdmFsdWU7XHJcblx0XHR9XHJcblx0fSxcclxuXHRnZW5lcmF0ZU1pcG1hcHM6IHtcclxuXHRcdGdldDogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLmdlbmVyYXRlTWlwbWFwcyBpcyBub3cgLnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHM7XHJcblx0XHR9LFxyXG5cdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLmdlbmVyYXRlTWlwbWFwcyBpcyBub3cgLnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzLicgKTtcclxuXHRcdFx0dGhpcy50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IHZhbHVlO1xyXG5cdFx0fVxyXG5cdH1cclxufSApO1xyXG5cclxuLy9cclxuXHJcblRIUkVFLkdlb21ldHJ5VXRpbHMgPSB7XHJcblxyXG5cdG1lcmdlOiBmdW5jdGlvbiAoIGdlb21ldHJ5MSwgZ2VvbWV0cnkyLCBtYXRlcmlhbEluZGV4T2Zmc2V0ICkge1xyXG5cclxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkdlb21ldHJ5VXRpbHM6IC5tZXJnZSgpIGhhcyBiZWVuIG1vdmVkIHRvIEdlb21ldHJ5LiBVc2UgZ2VvbWV0cnkubWVyZ2UoIGdlb21ldHJ5MiwgbWF0cml4LCBtYXRlcmlhbEluZGV4T2Zmc2V0ICkgaW5zdGVhZC4nICk7XHJcblxyXG5cdFx0dmFyIG1hdHJpeDtcclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5MiBpbnN0YW5jZW9mIFRIUkVFLk1lc2ggKSB7XHJcblxyXG5cdFx0XHRnZW9tZXRyeTIubWF0cml4QXV0b1VwZGF0ZSAmJiBnZW9tZXRyeTIudXBkYXRlTWF0cml4KCk7XHJcblxyXG5cdFx0XHRtYXRyaXggPSBnZW9tZXRyeTIubWF0cml4O1xyXG5cdFx0XHRnZW9tZXRyeTIgPSBnZW9tZXRyeTIuZ2VvbWV0cnk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGdlb21ldHJ5MS5tZXJnZSggZ2VvbWV0cnkyLCBtYXRyaXgsIG1hdGVyaWFsSW5kZXhPZmZzZXQgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y2VudGVyOiBmdW5jdGlvbiAoIGdlb21ldHJ5ICkge1xyXG5cclxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkdlb21ldHJ5VXRpbHM6IC5jZW50ZXIoKSBoYXMgYmVlbiBtb3ZlZCB0byBHZW9tZXRyeS4gVXNlIGdlb21ldHJ5LmNlbnRlcigpIGluc3RlYWQuJyApO1xyXG5cdFx0cmV0dXJuIGdlb21ldHJ5LmNlbnRlcigpO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuSW1hZ2VVdGlscyA9IHtcclxuXHJcblx0Y3Jvc3NPcmlnaW46IHVuZGVmaW5lZCxcclxuXHJcblx0bG9hZFRleHR1cmU6IGZ1bmN0aW9uICggdXJsLCBtYXBwaW5nLCBvbkxvYWQsIG9uRXJyb3IgKSB7XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuSW1hZ2VVdGlscy5sb2FkVGV4dHVyZSBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgVEhSRUUuVGV4dHVyZUxvYWRlcigpIGluc3RlYWQuJyApO1xyXG5cclxuXHRcdHZhciBsb2FkZXIgPSBuZXcgVEhSRUUuVGV4dHVyZUxvYWRlcigpO1xyXG5cdFx0bG9hZGVyLnNldENyb3NzT3JpZ2luKCB0aGlzLmNyb3NzT3JpZ2luICk7XHJcblxyXG5cdFx0dmFyIHRleHR1cmUgPSBsb2FkZXIubG9hZCggdXJsLCBvbkxvYWQsIHVuZGVmaW5lZCwgb25FcnJvciApO1xyXG5cclxuXHRcdGlmICggbWFwcGluZyApIHRleHR1cmUubWFwcGluZyA9IG1hcHBpbmc7XHJcblxyXG5cdFx0cmV0dXJuIHRleHR1cmU7XHJcblxyXG5cdH0sXHJcblxyXG5cdGxvYWRUZXh0dXJlQ3ViZTogZnVuY3Rpb24gKCB1cmxzLCBtYXBwaW5nLCBvbkxvYWQsIG9uRXJyb3IgKSB7XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuSW1hZ2VVdGlscy5sb2FkVGV4dHVyZUN1YmUgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIFRIUkVFLkN1YmVUZXh0dXJlTG9hZGVyKCkgaW5zdGVhZC4nICk7XHJcblxyXG5cdFx0dmFyIGxvYWRlciA9IG5ldyBUSFJFRS5DdWJlVGV4dHVyZUxvYWRlcigpO1xyXG5cdFx0bG9hZGVyLnNldENyb3NzT3JpZ2luKCB0aGlzLmNyb3NzT3JpZ2luICk7XHJcblxyXG5cdFx0dmFyIHRleHR1cmUgPSBsb2FkZXIubG9hZCggdXJscywgb25Mb2FkLCB1bmRlZmluZWQsIG9uRXJyb3IgKTtcclxuXHJcblx0XHRpZiAoIG1hcHBpbmcgKSB0ZXh0dXJlLm1hcHBpbmcgPSBtYXBwaW5nO1xyXG5cclxuXHRcdHJldHVybiB0ZXh0dXJlO1xyXG5cclxuXHR9LFxyXG5cclxuXHRsb2FkQ29tcHJlc3NlZFRleHR1cmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuSW1hZ2VVdGlscy5sb2FkQ29tcHJlc3NlZFRleHR1cmUgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFRIUkVFLkREU0xvYWRlciBpbnN0ZWFkLicgKTtcclxuXHJcblx0fSxcclxuXHJcblx0bG9hZENvbXByZXNzZWRUZXh0dXJlQ3ViZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5JbWFnZVV0aWxzLmxvYWRDb21wcmVzc2VkVGV4dHVyZUN1YmUgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFRIUkVFLkREU0xvYWRlciBpbnN0ZWFkLicgKTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbi8vXHJcblxyXG5USFJFRS5Qcm9qZWN0b3IgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5Qcm9qZWN0b3IgaGFzIGJlZW4gbW92ZWQgdG8gL2V4YW1wbGVzL2pzL3JlbmRlcmVycy9Qcm9qZWN0b3IuanMuJyApO1xyXG5cclxuXHR0aGlzLnByb2plY3RWZWN0b3IgPSBmdW5jdGlvbiAoIHZlY3RvciwgY2FtZXJhICkge1xyXG5cclxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlByb2plY3RvcjogLnByb2plY3RWZWN0b3IoKSBpcyBub3cgdmVjdG9yLnByb2plY3QoKS4nICk7XHJcblx0XHR2ZWN0b3IucHJvamVjdCggY2FtZXJhICk7XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMudW5wcm9qZWN0VmVjdG9yID0gZnVuY3Rpb24gKCB2ZWN0b3IsIGNhbWVyYSApIHtcclxuXHJcblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Qcm9qZWN0b3I6IC51bnByb2plY3RWZWN0b3IoKSBpcyBub3cgdmVjdG9yLnVucHJvamVjdCgpLicgKTtcclxuXHRcdHZlY3Rvci51bnByb2plY3QoIGNhbWVyYSApO1xyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLnBpY2tpbmdSYXkgPSBmdW5jdGlvbiAoIHZlY3RvciwgY2FtZXJhICkge1xyXG5cclxuXHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5Qcm9qZWN0b3I6IC5waWNraW5nUmF5KCkgaXMgbm93IHJheWNhc3Rlci5zZXRGcm9tQ2FtZXJhKCkuJyApO1xyXG5cclxuXHR9O1xyXG5cclxufTtcclxuXHJcbi8vXHJcblxyXG5USFJFRS5DYW52YXNSZW5kZXJlciA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkNhbnZhc1JlbmRlcmVyIGhhcyBiZWVuIG1vdmVkIHRvIC9leGFtcGxlcy9qcy9yZW5kZXJlcnMvQ2FudmFzUmVuZGVyZXIuanMnICk7XHJcblxyXG5cdHRoaXMuZG9tRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdjYW52YXMnICk7XHJcblx0dGhpcy5jbGVhciA9IGZ1bmN0aW9uICgpIHt9O1xyXG5cdHRoaXMucmVuZGVyID0gZnVuY3Rpb24gKCkge307XHJcblx0dGhpcy5zZXRDbGVhckNvbG9yID0gZnVuY3Rpb24gKCkge307XHJcblx0dGhpcy5zZXRTaXplID0gZnVuY3Rpb24gKCkge307XHJcblxyXG59O1xyXG5cclxuLy9cclxuXHJcblRIUkVFLk1lc2hGYWNlTWF0ZXJpYWwgPSBUSFJFRS5NdWx0aU1hdGVyaWFsO1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL0N1cnZlVXRpbHMuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXHJcbiAqL1xyXG5cclxuVEhSRUUuQ3VydmVVdGlscyA9IHtcclxuXHJcblx0dGFuZ2VudFF1YWRyYXRpY0JlemllcjogZnVuY3Rpb24gKCB0LCBwMCwgcDEsIHAyICkge1xyXG5cclxuXHRcdHJldHVybiAyICogKCAxIC0gdCApICogKCBwMSAtIHAwICkgKyAyICogdCAqICggcDIgLSBwMSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHQvLyBQdWF5IEJpbmcsIHRoYW5rcyBmb3IgaGVscGluZyB3aXRoIHRoaXMgZGVyaXZhdGl2ZSFcclxuXHJcblx0dGFuZ2VudEN1YmljQmV6aWVyOiBmdW5jdGlvbiAoIHQsIHAwLCBwMSwgcDIsIHAzICkge1xyXG5cclxuXHRcdHJldHVybiAtIDMgKiBwMCAqICggMSAtIHQgKSAqICggMSAtIHQgKSAgK1xyXG5cdFx0XHQzICogcDEgKiAoIDEgLSB0ICkgKiAoIDEgLSB0ICkgLSA2ICogdCAqIHAxICogKCAxIC0gdCApICtcclxuXHRcdFx0NiAqIHQgKiAgcDIgKiAoIDEgLSB0ICkgLSAzICogdCAqIHQgKiBwMiArXHJcblx0XHRcdDMgKiB0ICogdCAqIHAzO1xyXG5cclxuXHR9LFxyXG5cclxuXHR0YW5nZW50U3BsaW5lOiBmdW5jdGlvbiAoIHQsIHAwLCBwMSwgcDIsIHAzICkge1xyXG5cclxuXHRcdC8vIFRvIGNoZWNrIGlmIG15IGZvcm11bGFzIGFyZSBjb3JyZWN0XHJcblxyXG5cdFx0dmFyIGgwMCA9IDYgKiB0ICogdCAtIDYgKiB0OyBcdC8vIGRlcml2ZWQgZnJvbSAydF4zIOKIkiAzdF4yICsgMVxyXG5cdFx0dmFyIGgxMCA9IDMgKiB0ICogdCAtIDQgKiB0ICsgMTsgLy8gdF4zIOKIkiAydF4yICsgdFxyXG5cdFx0dmFyIGgwMSA9IC0gNiAqIHQgKiB0ICsgNiAqIHQ7IFx0Ly8g4oiSIDJ0MyArIDN0MlxyXG5cdFx0dmFyIGgxMSA9IDMgKiB0ICogdCAtIDIgKiB0O1x0Ly8gdDMg4oiSIHQyXHJcblxyXG5cdFx0cmV0dXJuIGgwMCArIGgxMCArIGgwMSArIGgxMTtcclxuXHJcblx0fSxcclxuXHJcblx0Ly8gQ2F0bXVsbC1Sb21cclxuXHJcblx0aW50ZXJwb2xhdGU6IGZ1bmN0aW9uKCBwMCwgcDEsIHAyLCBwMywgdCApIHtcclxuXHJcblx0XHR2YXIgdjAgPSAoIHAyIC0gcDAgKSAqIDAuNTtcclxuXHRcdHZhciB2MSA9ICggcDMgLSBwMSApICogMC41O1xyXG5cdFx0dmFyIHQyID0gdCAqIHQ7XHJcblx0XHR2YXIgdDMgPSB0ICogdDI7XHJcblx0XHRyZXR1cm4gKCAyICogcDEgLSAyICogcDIgKyB2MCArIHYxICkgKiB0MyArICggLSAzICogcDEgKyAzICogcDIgLSAyICogdjAgLSB2MSApICogdDIgKyB2MCAqIHQgKyBwMTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9TY2VuZVV0aWxzLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5TY2VuZVV0aWxzID0ge1xyXG5cclxuXHRjcmVhdGVNdWx0aU1hdGVyaWFsT2JqZWN0OiBmdW5jdGlvbiAoIGdlb21ldHJ5LCBtYXRlcmlhbHMgKSB7XHJcblxyXG5cdFx0dmFyIGdyb3VwID0gbmV3IFRIUkVFLkdyb3VwKCk7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gbWF0ZXJpYWxzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRncm91cC5hZGQoIG5ldyBUSFJFRS5NZXNoKCBnZW9tZXRyeSwgbWF0ZXJpYWxzWyBpIF0gKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZ3JvdXA7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRldGFjaDogZnVuY3Rpb24gKCBjaGlsZCwgcGFyZW50LCBzY2VuZSApIHtcclxuXHJcblx0XHRjaGlsZC5hcHBseU1hdHJpeCggcGFyZW50Lm1hdHJpeFdvcmxkICk7XHJcblx0XHRwYXJlbnQucmVtb3ZlKCBjaGlsZCApO1xyXG5cdFx0c2NlbmUuYWRkKCBjaGlsZCApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRhdHRhY2g6IGZ1bmN0aW9uICggY2hpbGQsIHNjZW5lLCBwYXJlbnQgKSB7XHJcblxyXG5cdFx0dmFyIG1hdHJpeFdvcmxkSW52ZXJzZSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblx0XHRtYXRyaXhXb3JsZEludmVyc2UuZ2V0SW52ZXJzZSggcGFyZW50Lm1hdHJpeFdvcmxkICk7XHJcblx0XHRjaGlsZC5hcHBseU1hdHJpeCggbWF0cml4V29ybGRJbnZlcnNlICk7XHJcblxyXG5cdFx0c2NlbmUucmVtb3ZlKCBjaGlsZCApO1xyXG5cdFx0cGFyZW50LmFkZCggY2hpbGQgKTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9TaGFwZVV0aWxzLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xyXG4gKi9cclxuXHJcblRIUkVFLlNoYXBlVXRpbHMgPSB7XHJcblxyXG5cdC8vIGNhbGN1bGF0ZSBhcmVhIG9mIHRoZSBjb250b3VyIHBvbHlnb25cclxuXHJcblx0YXJlYTogZnVuY3Rpb24gKCBjb250b3VyICkge1xyXG5cclxuXHRcdHZhciBuID0gY29udG91ci5sZW5ndGg7XHJcblx0XHR2YXIgYSA9IDAuMDtcclxuXHJcblx0XHRmb3IgKCB2YXIgcCA9IG4gLSAxLCBxID0gMDsgcSA8IG47IHAgPSBxICsrICkge1xyXG5cclxuXHRcdFx0YSArPSBjb250b3VyWyBwIF0ueCAqIGNvbnRvdXJbIHEgXS55IC0gY29udG91clsgcSBdLnggKiBjb250b3VyWyBwIF0ueTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGEgKiAwLjU7XHJcblxyXG5cdH0sXHJcblxyXG5cdHRyaWFuZ3VsYXRlOiAoIGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoaXMgY29kZSBpcyBhIHF1aWNrIHBvcnQgb2YgY29kZSB3cml0dGVuIGluIEMrKyB3aGljaCB3YXMgc3VibWl0dGVkIHRvXHJcblx0XHQgKiBmbGlwY29kZS5jb20gYnkgSm9obiBXLiBSYXRjbGlmZiAgLy8gSnVseSAyMiwgMjAwMFxyXG5cdFx0ICogU2VlIG9yaWdpbmFsIGNvZGUgYW5kIG1vcmUgaW5mb3JtYXRpb24gaGVyZTpcclxuXHRcdCAqIGh0dHA6Ly93d3cuZmxpcGNvZGUuY29tL2FyY2hpdmVzL0VmZmljaWVudF9Qb2x5Z29uX1RyaWFuZ3VsYXRpb24uc2h0bWxcclxuXHRcdCAqXHJcblx0XHQgKiBwb3J0ZWQgdG8gYWN0aW9uc2NyaXB0IGJ5IFpldmFuIFJvc3NlclxyXG5cdFx0ICogd3d3LmFjdGlvbnNuaXBwZXQuY29tXHJcblx0XHQgKlxyXG5cdFx0ICogcG9ydGVkIHRvIGphdmFzY3JpcHQgYnkgSm9zaHVhIEtvb1xyXG5cdFx0ICogaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xyXG5cdFx0ICpcclxuXHRcdCAqL1xyXG5cclxuXHRcdGZ1bmN0aW9uIHNuaXAoIGNvbnRvdXIsIHUsIHYsIHcsIG4sIHZlcnRzICkge1xyXG5cclxuXHRcdFx0dmFyIHA7XHJcblx0XHRcdHZhciBheCwgYXksIGJ4LCBieTtcclxuXHRcdFx0dmFyIGN4LCBjeSwgcHgsIHB5O1xyXG5cclxuXHRcdFx0YXggPSBjb250b3VyWyB2ZXJ0c1sgdSBdIF0ueDtcclxuXHRcdFx0YXkgPSBjb250b3VyWyB2ZXJ0c1sgdSBdIF0ueTtcclxuXHJcblx0XHRcdGJ4ID0gY29udG91clsgdmVydHNbIHYgXSBdLng7XHJcblx0XHRcdGJ5ID0gY29udG91clsgdmVydHNbIHYgXSBdLnk7XHJcblxyXG5cdFx0XHRjeCA9IGNvbnRvdXJbIHZlcnRzWyB3IF0gXS54O1xyXG5cdFx0XHRjeSA9IGNvbnRvdXJbIHZlcnRzWyB3IF0gXS55O1xyXG5cclxuXHRcdFx0aWYgKCBOdW1iZXIuRVBTSUxPTiA+ICggKCAoIGJ4IC0gYXggKSAqICggY3kgLSBheSApICkgLSAoICggYnkgLSBheSApICogKCBjeCAtIGF4ICkgKSApICkgcmV0dXJuIGZhbHNlO1xyXG5cclxuXHRcdFx0dmFyIGFYLCBhWSwgYlgsIGJZLCBjWCwgY1k7XHJcblx0XHRcdHZhciBhcHgsIGFweSwgYnB4LCBicHksIGNweCwgY3B5O1xyXG5cdFx0XHR2YXIgY0NST1NTYXAsIGJDUk9TU2NwLCBhQ1JPU1NicDtcclxuXHJcblx0XHRcdGFYID0gY3ggLSBieDsgIGFZID0gY3kgLSBieTtcclxuXHRcdFx0YlggPSBheCAtIGN4OyAgYlkgPSBheSAtIGN5O1xyXG5cdFx0XHRjWCA9IGJ4IC0gYXg7ICBjWSA9IGJ5IC0gYXk7XHJcblxyXG5cdFx0XHRmb3IgKCBwID0gMDsgcCA8IG47IHAgKysgKSB7XHJcblxyXG5cdFx0XHRcdHB4ID0gY29udG91clsgdmVydHNbIHAgXSBdLng7XHJcblx0XHRcdFx0cHkgPSBjb250b3VyWyB2ZXJ0c1sgcCBdIF0ueTtcclxuXHJcblx0XHRcdFx0aWYgKCAoICggcHggPT09IGF4ICkgJiYgKCBweSA9PT0gYXkgKSApIHx8XHJcblx0XHRcdFx0XHQgKCAoIHB4ID09PSBieCApICYmICggcHkgPT09IGJ5ICkgKSB8fFxyXG5cdFx0XHRcdFx0ICggKCBweCA9PT0gY3ggKSAmJiAoIHB5ID09PSBjeSApICkgKVx0Y29udGludWU7XHJcblxyXG5cdFx0XHRcdGFweCA9IHB4IC0gYXg7ICBhcHkgPSBweSAtIGF5O1xyXG5cdFx0XHRcdGJweCA9IHB4IC0gYng7ICBicHkgPSBweSAtIGJ5O1xyXG5cdFx0XHRcdGNweCA9IHB4IC0gY3g7ICBjcHkgPSBweSAtIGN5O1xyXG5cclxuXHRcdFx0XHQvLyBzZWUgaWYgcCBpcyBpbnNpZGUgdHJpYW5nbGUgYWJjXHJcblxyXG5cdFx0XHRcdGFDUk9TU2JwID0gYVggKiBicHkgLSBhWSAqIGJweDtcclxuXHRcdFx0XHRjQ1JPU1NhcCA9IGNYICogYXB5IC0gY1kgKiBhcHg7XHJcblx0XHRcdFx0YkNST1NTY3AgPSBiWCAqIGNweSAtIGJZICogY3B4O1xyXG5cclxuXHRcdFx0XHRpZiAoICggYUNST1NTYnAgPj0gLSBOdW1iZXIuRVBTSUxPTiApICYmICggYkNST1NTY3AgPj0gLSBOdW1iZXIuRVBTSUxPTiApICYmICggY0NST1NTYXAgPj0gLSBOdW1iZXIuRVBTSUxPTiApICkgcmV0dXJuIGZhbHNlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHRha2VzIGluIGFuIGNvbnRvdXIgYXJyYXkgYW5kIHJldHVybnNcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBjb250b3VyLCBpbmRpY2VzICkge1xyXG5cclxuXHRcdFx0dmFyIG4gPSBjb250b3VyLmxlbmd0aDtcclxuXHJcblx0XHRcdGlmICggbiA8IDMgKSByZXR1cm4gbnVsbDtcclxuXHJcblx0XHRcdHZhciByZXN1bHQgPSBbXSxcclxuXHRcdFx0XHR2ZXJ0cyA9IFtdLFxyXG5cdFx0XHRcdHZlcnRJbmRpY2VzID0gW107XHJcblxyXG5cdFx0XHQvKiB3ZSB3YW50IGEgY291bnRlci1jbG9ja3dpc2UgcG9seWdvbiBpbiB2ZXJ0cyAqL1xyXG5cclxuXHRcdFx0dmFyIHUsIHYsIHc7XHJcblxyXG5cdFx0XHRpZiAoIFRIUkVFLlNoYXBlVXRpbHMuYXJlYSggY29udG91ciApID4gMC4wICkge1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2ID0gMDsgdiA8IG47IHYgKysgKSB2ZXJ0c1sgdiBdID0gdjtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGZvciAoIHYgPSAwOyB2IDwgbjsgdiArKyApIHZlcnRzWyB2IF0gPSAoIG4gLSAxICkgLSB2O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIG52ID0gbjtcclxuXHJcblx0XHRcdC8qICByZW1vdmUgbnYgLSAyIHZlcnRpY2VzLCBjcmVhdGluZyAxIHRyaWFuZ2xlIGV2ZXJ5IHRpbWUgKi9cclxuXHJcblx0XHRcdHZhciBjb3VudCA9IDIgKiBudjsgICAvKiBlcnJvciBkZXRlY3Rpb24gKi9cclxuXHJcblx0XHRcdGZvciAoIHYgPSBudiAtIDE7IG52ID4gMjsgKSB7XHJcblxyXG5cdFx0XHRcdC8qIGlmIHdlIGxvb3AsIGl0IGlzIHByb2JhYmx5IGEgbm9uLXNpbXBsZSBwb2x5Z29uICovXHJcblxyXG5cdFx0XHRcdGlmICggKCBjb3VudCAtLSApIDw9IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0Ly8qKiBUcmlhbmd1bGF0ZTogRVJST1IgLSBwcm9iYWJsZSBiYWQgcG9seWdvbiFcclxuXHJcblx0XHRcdFx0XHQvL3Rocm93ICggXCJXYXJuaW5nLCB1bmFibGUgdG8gdHJpYW5ndWxhdGUgcG9seWdvbiFcIiApO1xyXG5cdFx0XHRcdFx0Ly9yZXR1cm4gbnVsbDtcclxuXHRcdFx0XHRcdC8vIFNvbWV0aW1lcyB3YXJuaW5nIGlzIGZpbmUsIGVzcGVjaWFsbHkgcG9seWdvbnMgYXJlIHRyaWFuZ3VsYXRlZCBpbiByZXZlcnNlLlxyXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuU2hhcGVVdGlsczogVW5hYmxlIHRvIHRyaWFuZ3VsYXRlIHBvbHlnb24hIGluIHRyaWFuZ3VsYXRlKCknICk7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBpbmRpY2VzICkgcmV0dXJuIHZlcnRJbmRpY2VzO1xyXG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvKiB0aHJlZSBjb25zZWN1dGl2ZSB2ZXJ0aWNlcyBpbiBjdXJyZW50IHBvbHlnb24sIDx1LHYsdz4gKi9cclxuXHJcblx0XHRcdFx0dSA9IHY7IFx0IFx0aWYgKCBudiA8PSB1ICkgdSA9IDA7ICAgICAvKiBwcmV2aW91cyAqL1xyXG5cdFx0XHRcdHYgPSB1ICsgMTsgIGlmICggbnYgPD0gdiApIHYgPSAwOyAgICAgLyogbmV3IHYgICAgKi9cclxuXHRcdFx0XHR3ID0gdiArIDE7ICBpZiAoIG52IDw9IHcgKSB3ID0gMDsgICAgIC8qIG5leHQgICAgICovXHJcblxyXG5cdFx0XHRcdGlmICggc25pcCggY29udG91ciwgdSwgdiwgdywgbnYsIHZlcnRzICkgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIGEsIGIsIGMsIHMsIHQ7XHJcblxyXG5cdFx0XHRcdFx0LyogdHJ1ZSBuYW1lcyBvZiB0aGUgdmVydGljZXMgKi9cclxuXHJcblx0XHRcdFx0XHRhID0gdmVydHNbIHUgXTtcclxuXHRcdFx0XHRcdGIgPSB2ZXJ0c1sgdiBdO1xyXG5cdFx0XHRcdFx0YyA9IHZlcnRzWyB3IF07XHJcblxyXG5cdFx0XHRcdFx0Lyogb3V0cHV0IFRyaWFuZ2xlICovXHJcblxyXG5cdFx0XHRcdFx0cmVzdWx0LnB1c2goIFsgY29udG91clsgYSBdLFxyXG5cdFx0XHRcdFx0XHRjb250b3VyWyBiIF0sXHJcblx0XHRcdFx0XHRcdGNvbnRvdXJbIGMgXSBdICk7XHJcblxyXG5cclxuXHRcdFx0XHRcdHZlcnRJbmRpY2VzLnB1c2goIFsgdmVydHNbIHUgXSwgdmVydHNbIHYgXSwgdmVydHNbIHcgXSBdICk7XHJcblxyXG5cdFx0XHRcdFx0LyogcmVtb3ZlIHYgZnJvbSB0aGUgcmVtYWluaW5nIHBvbHlnb24gKi9cclxuXHJcblx0XHRcdFx0XHRmb3IgKCBzID0gdiwgdCA9IHYgKyAxOyB0IDwgbnY7IHMgKyssIHQgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR2ZXJ0c1sgcyBdID0gdmVydHNbIHQgXTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0bnYgLS07XHJcblxyXG5cdFx0XHRcdFx0LyogcmVzZXQgZXJyb3IgZGV0ZWN0aW9uIGNvdW50ZXIgKi9cclxuXHJcblx0XHRcdFx0XHRjb3VudCA9IDIgKiBudjtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBpbmRpY2VzICkgcmV0dXJuIHZlcnRJbmRpY2VzO1xyXG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSApKCksXHJcblxyXG5cdHRyaWFuZ3VsYXRlU2hhcGU6IGZ1bmN0aW9uICggY29udG91ciwgaG9sZXMgKSB7XHJcblxyXG5cdFx0ZnVuY3Rpb24gcG9pbnRfaW5fc2VnbWVudF8yRF9jb2xpbiggaW5TZWdQdDEsIGluU2VnUHQyLCBpbk90aGVyUHQgKSB7XHJcblxyXG5cdFx0XHQvLyBpbk90aGVyUHQgbmVlZHMgdG8gYmUgY29sbGluZWFyIHRvIHRoZSBpblNlZ21lbnRcclxuXHRcdFx0aWYgKCBpblNlZ1B0MS54ICE9PSBpblNlZ1B0Mi54ICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIGluU2VnUHQxLnggPCBpblNlZ1B0Mi54ICkge1xyXG5cclxuXHRcdFx0XHRcdHJldHVyblx0KCAoIGluU2VnUHQxLnggPD0gaW5PdGhlclB0LnggKSAmJiAoIGluT3RoZXJQdC54IDw9IGluU2VnUHQyLnggKSApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdHJldHVyblx0KCAoIGluU2VnUHQyLnggPD0gaW5PdGhlclB0LnggKSAmJiAoIGluT3RoZXJQdC54IDw9IGluU2VnUHQxLnggKSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRpZiAoIGluU2VnUHQxLnkgPCBpblNlZ1B0Mi55ICkge1xyXG5cclxuXHRcdFx0XHRcdHJldHVyblx0KCAoIGluU2VnUHQxLnkgPD0gaW5PdGhlclB0LnkgKSAmJiAoIGluT3RoZXJQdC55IDw9IGluU2VnUHQyLnkgKSApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdHJldHVyblx0KCAoIGluU2VnUHQyLnkgPD0gaW5PdGhlclB0LnkgKSAmJiAoIGluT3RoZXJQdC55IDw9IGluU2VnUHQxLnkgKSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIGludGVyc2VjdF9zZWdtZW50c18yRCggaW5TZWcxUHQxLCBpblNlZzFQdDIsIGluU2VnMlB0MSwgaW5TZWcyUHQyLCBpbkV4Y2x1ZGVBZGphY2VudFNlZ3MgKSB7XHJcblxyXG5cdFx0XHR2YXIgc2VnMWR4ID0gaW5TZWcxUHQyLnggLSBpblNlZzFQdDEueCwgICBzZWcxZHkgPSBpblNlZzFQdDIueSAtIGluU2VnMVB0MS55O1xyXG5cdFx0XHR2YXIgc2VnMmR4ID0gaW5TZWcyUHQyLnggLSBpblNlZzJQdDEueCwgICBzZWcyZHkgPSBpblNlZzJQdDIueSAtIGluU2VnMlB0MS55O1xyXG5cclxuXHRcdFx0dmFyIHNlZzFzZWcyZHggPSBpblNlZzFQdDEueCAtIGluU2VnMlB0MS54O1xyXG5cdFx0XHR2YXIgc2VnMXNlZzJkeSA9IGluU2VnMVB0MS55IC0gaW5TZWcyUHQxLnk7XHJcblxyXG5cdFx0XHR2YXIgbGltaXRcdFx0PSBzZWcxZHkgKiBzZWcyZHggLSBzZWcxZHggKiBzZWcyZHk7XHJcblx0XHRcdHZhciBwZXJwU2VnMVx0PSBzZWcxZHkgKiBzZWcxc2VnMmR4IC0gc2VnMWR4ICogc2VnMXNlZzJkeTtcclxuXHJcblx0XHRcdGlmICggTWF0aC5hYnMoIGxpbWl0ICkgPiBOdW1iZXIuRVBTSUxPTiApIHtcclxuXHJcblx0XHRcdFx0Ly8gbm90IHBhcmFsbGVsXHJcblxyXG5cdFx0XHRcdHZhciBwZXJwU2VnMjtcclxuXHRcdFx0XHRpZiAoIGxpbWl0ID4gMCApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoICggcGVycFNlZzEgPCAwICkgfHwgKCBwZXJwU2VnMSA+IGxpbWl0ICkgKSBcdFx0cmV0dXJuIFtdO1xyXG5cdFx0XHRcdFx0cGVycFNlZzIgPSBzZWcyZHkgKiBzZWcxc2VnMmR4IC0gc2VnMmR4ICogc2VnMXNlZzJkeTtcclxuXHRcdFx0XHRcdGlmICggKCBwZXJwU2VnMiA8IDAgKSB8fCAoIHBlcnBTZWcyID4gbGltaXQgKSApIFx0XHRyZXR1cm4gW107XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCAoIHBlcnBTZWcxID4gMCApIHx8ICggcGVycFNlZzEgPCBsaW1pdCApICkgXHRcdHJldHVybiBbXTtcclxuXHRcdFx0XHRcdHBlcnBTZWcyID0gc2VnMmR5ICogc2VnMXNlZzJkeCAtIHNlZzJkeCAqIHNlZzFzZWcyZHk7XHJcblx0XHRcdFx0XHRpZiAoICggcGVycFNlZzIgPiAwICkgfHwgKCBwZXJwU2VnMiA8IGxpbWl0ICkgKSBcdFx0cmV0dXJuIFtdO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vIGkuZS4gdG8gcmVkdWNlIHJvdW5kaW5nIGVycm9yc1xyXG5cdFx0XHRcdC8vIGludGVyc2VjdGlvbiBhdCBlbmRwb2ludCBvZiBzZWdtZW50IzE/XHJcblx0XHRcdFx0aWYgKCBwZXJwU2VnMiA9PT0gMCApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoICggaW5FeGNsdWRlQWRqYWNlbnRTZWdzICkgJiZcclxuXHRcdFx0XHRcdFx0ICggKCBwZXJwU2VnMSA9PT0gMCApIHx8ICggcGVycFNlZzEgPT09IGxpbWl0ICkgKSApXHRcdHJldHVybiBbXTtcclxuXHRcdFx0XHRcdHJldHVybiBbIGluU2VnMVB0MSBdO1xyXG5cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKCBwZXJwU2VnMiA9PT0gbGltaXQgKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCAoIGluRXhjbHVkZUFkamFjZW50U2VncyApICYmXHJcblx0XHRcdFx0XHRcdCAoICggcGVycFNlZzEgPT09IDAgKSB8fCAoIHBlcnBTZWcxID09PSBsaW1pdCApICkgKVx0XHRyZXR1cm4gW107XHJcblx0XHRcdFx0XHRyZXR1cm4gWyBpblNlZzFQdDIgXTtcclxuXHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdC8vIGludGVyc2VjdGlvbiBhdCBlbmRwb2ludCBvZiBzZWdtZW50IzI/XHJcblx0XHRcdFx0aWYgKCBwZXJwU2VnMSA9PT0gMCApXHRcdHJldHVybiBbIGluU2VnMlB0MSBdO1xyXG5cdFx0XHRcdGlmICggcGVycFNlZzEgPT09IGxpbWl0IClcdHJldHVybiBbIGluU2VnMlB0MiBdO1xyXG5cclxuXHRcdFx0XHQvLyByZXR1cm4gcmVhbCBpbnRlcnNlY3Rpb24gcG9pbnRcclxuXHRcdFx0XHR2YXIgZmFjdG9yU2VnMSA9IHBlcnBTZWcyIC8gbGltaXQ7XHJcblx0XHRcdFx0cmV0dXJuXHRbIHsgeDogaW5TZWcxUHQxLnggKyBmYWN0b3JTZWcxICogc2VnMWR4LFxyXG5cdFx0XHRcdFx0XHRcdHk6IGluU2VnMVB0MS55ICsgZmFjdG9yU2VnMSAqIHNlZzFkeSB9IF07XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHQvLyBwYXJhbGxlbCBvciBjb2xsaW5lYXJcclxuXHRcdFx0XHRpZiAoICggcGVycFNlZzEgIT09IDAgKSB8fFxyXG5cdFx0XHRcdFx0ICggc2VnMmR5ICogc2VnMXNlZzJkeCAhPT0gc2VnMmR4ICogc2VnMXNlZzJkeSApICkgXHRcdFx0cmV0dXJuIFtdO1xyXG5cclxuXHRcdFx0XHQvLyB0aGV5IGFyZSBjb2xsaW5lYXIgb3IgZGVnZW5lcmF0ZVxyXG5cdFx0XHRcdHZhciBzZWcxUHQgPSAoICggc2VnMWR4ID09PSAwICkgJiYgKCBzZWcxZHkgPT09IDAgKSApO1x0Ly8gc2VnbWVudDEgaXMganVzdCBhIHBvaW50P1xyXG5cdFx0XHRcdHZhciBzZWcyUHQgPSAoICggc2VnMmR4ID09PSAwICkgJiYgKCBzZWcyZHkgPT09IDAgKSApO1x0Ly8gc2VnbWVudDIgaXMganVzdCBhIHBvaW50P1xyXG5cdFx0XHRcdC8vIGJvdGggc2VnbWVudHMgYXJlIHBvaW50c1xyXG5cdFx0XHRcdGlmICggc2VnMVB0ICYmIHNlZzJQdCApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoICggaW5TZWcxUHQxLnggIT09IGluU2VnMlB0MS54ICkgfHxcclxuXHRcdFx0XHRcdFx0ICggaW5TZWcxUHQxLnkgIT09IGluU2VnMlB0MS55ICkgKVx0XHRyZXR1cm4gW107XHQvLyB0aGV5IGFyZSBkaXN0aW5jdCAgcG9pbnRzXHJcblx0XHRcdFx0XHRyZXR1cm4gWyBpblNlZzFQdDEgXTsgICAgICAgICAgICAgICAgIFx0XHRcdFx0XHRcdC8vIHRoZXkgYXJlIHRoZSBzYW1lIHBvaW50XHJcblxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHQvLyBzZWdtZW50IzEgIGlzIGEgc2luZ2xlIHBvaW50XHJcblx0XHRcdFx0aWYgKCBzZWcxUHQgKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCAhIHBvaW50X2luX3NlZ21lbnRfMkRfY29saW4oIGluU2VnMlB0MSwgaW5TZWcyUHQyLCBpblNlZzFQdDEgKSApXHRcdHJldHVybiBbXTtcdFx0Ly8gYnV0IG5vdCBpbiBzZWdtZW50IzJcclxuXHRcdFx0XHRcdHJldHVybiBbIGluU2VnMVB0MSBdO1xyXG5cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Ly8gc2VnbWVudCMyICBpcyBhIHNpbmdsZSBwb2ludFxyXG5cdFx0XHRcdGlmICggc2VnMlB0ICkge1xyXG5cclxuXHRcdFx0XHRcdGlmICggISBwb2ludF9pbl9zZWdtZW50XzJEX2NvbGluKCBpblNlZzFQdDEsIGluU2VnMVB0MiwgaW5TZWcyUHQxICkgKVx0XHRyZXR1cm4gW107XHRcdC8vIGJ1dCBub3QgaW4gc2VnbWVudCMxXHJcblx0XHRcdFx0XHRyZXR1cm4gWyBpblNlZzJQdDEgXTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyB0aGV5IGFyZSBjb2xsaW5lYXIgc2VnbWVudHMsIHdoaWNoIG1pZ2h0IG92ZXJsYXBcclxuXHRcdFx0XHR2YXIgc2VnMW1pbiwgc2VnMW1heCwgc2VnMW1pblZhbCwgc2VnMW1heFZhbDtcclxuXHRcdFx0XHR2YXIgc2VnMm1pbiwgc2VnMm1heCwgc2VnMm1pblZhbCwgc2VnMm1heFZhbDtcclxuXHRcdFx0XHRpZiAoIHNlZzFkeCAhPT0gMCApIHtcclxuXHJcblx0XHRcdFx0XHQvLyB0aGUgc2VnbWVudHMgYXJlIE5PVCBvbiBhIHZlcnRpY2FsIGxpbmVcclxuXHRcdFx0XHRcdGlmICggaW5TZWcxUHQxLnggPCBpblNlZzFQdDIueCApIHtcclxuXHJcblx0XHRcdFx0XHRcdHNlZzFtaW4gPSBpblNlZzFQdDE7IHNlZzFtaW5WYWwgPSBpblNlZzFQdDEueDtcclxuXHRcdFx0XHRcdFx0c2VnMW1heCA9IGluU2VnMVB0Mjsgc2VnMW1heFZhbCA9IGluU2VnMVB0Mi54O1xyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRzZWcxbWluID0gaW5TZWcxUHQyOyBzZWcxbWluVmFsID0gaW5TZWcxUHQyLng7XHJcblx0XHRcdFx0XHRcdHNlZzFtYXggPSBpblNlZzFQdDE7IHNlZzFtYXhWYWwgPSBpblNlZzFQdDEueDtcclxuXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZiAoIGluU2VnMlB0MS54IDwgaW5TZWcyUHQyLnggKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRzZWcybWluID0gaW5TZWcyUHQxOyBzZWcybWluVmFsID0gaW5TZWcyUHQxLng7XHJcblx0XHRcdFx0XHRcdHNlZzJtYXggPSBpblNlZzJQdDI7IHNlZzJtYXhWYWwgPSBpblNlZzJQdDIueDtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0c2VnMm1pbiA9IGluU2VnMlB0Mjsgc2VnMm1pblZhbCA9IGluU2VnMlB0Mi54O1xyXG5cdFx0XHRcdFx0XHRzZWcybWF4ID0gaW5TZWcyUHQxOyBzZWcybWF4VmFsID0gaW5TZWcyUHQxLng7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdC8vIHRoZSBzZWdtZW50cyBhcmUgb24gYSB2ZXJ0aWNhbCBsaW5lXHJcblx0XHRcdFx0XHRpZiAoIGluU2VnMVB0MS55IDwgaW5TZWcxUHQyLnkgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRzZWcxbWluID0gaW5TZWcxUHQxOyBzZWcxbWluVmFsID0gaW5TZWcxUHQxLnk7XHJcblx0XHRcdFx0XHRcdHNlZzFtYXggPSBpblNlZzFQdDI7IHNlZzFtYXhWYWwgPSBpblNlZzFQdDIueTtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0c2VnMW1pbiA9IGluU2VnMVB0Mjsgc2VnMW1pblZhbCA9IGluU2VnMVB0Mi55O1xyXG5cdFx0XHRcdFx0XHRzZWcxbWF4ID0gaW5TZWcxUHQxOyBzZWcxbWF4VmFsID0gaW5TZWcxUHQxLnk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYgKCBpblNlZzJQdDEueSA8IGluU2VnMlB0Mi55ICkge1xyXG5cclxuXHRcdFx0XHRcdFx0c2VnMm1pbiA9IGluU2VnMlB0MTsgc2VnMm1pblZhbCA9IGluU2VnMlB0MS55O1xyXG5cdFx0XHRcdFx0XHRzZWcybWF4ID0gaW5TZWcyUHQyOyBzZWcybWF4VmFsID0gaW5TZWcyUHQyLnk7XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdHNlZzJtaW4gPSBpblNlZzJQdDI7IHNlZzJtaW5WYWwgPSBpblNlZzJQdDIueTtcclxuXHRcdFx0XHRcdFx0c2VnMm1heCA9IGluU2VnMlB0MTsgc2VnMm1heFZhbCA9IGluU2VnMlB0MS55O1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmICggc2VnMW1pblZhbCA8PSBzZWcybWluVmFsICkge1xyXG5cclxuXHRcdFx0XHRcdGlmICggc2VnMW1heFZhbCA8ICBzZWcybWluVmFsIClcdHJldHVybiBbXTtcclxuXHRcdFx0XHRcdGlmICggc2VnMW1heFZhbCA9PT0gc2VnMm1pblZhbCApXHR7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIGluRXhjbHVkZUFkamFjZW50U2VncyApXHRcdHJldHVybiBbXTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIFsgc2VnMm1pbiBdO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGlmICggc2VnMW1heFZhbCA8PSBzZWcybWF4VmFsIClcdHJldHVybiBbIHNlZzJtaW4sIHNlZzFtYXggXTtcclxuXHRcdFx0XHRcdHJldHVyblx0WyBzZWcybWluLCBzZWcybWF4IF07XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBzZWcxbWluVmFsID4gIHNlZzJtYXhWYWwgKVx0cmV0dXJuIFtdO1xyXG5cdFx0XHRcdFx0aWYgKCBzZWcxbWluVmFsID09PSBzZWcybWF4VmFsIClcdHtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggaW5FeGNsdWRlQWRqYWNlbnRTZWdzIClcdFx0cmV0dXJuIFtdO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gWyBzZWcxbWluIF07XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYgKCBzZWcxbWF4VmFsIDw9IHNlZzJtYXhWYWwgKVx0cmV0dXJuIFsgc2VnMW1pbiwgc2VnMW1heCBdO1xyXG5cdFx0XHRcdFx0cmV0dXJuXHRbIHNlZzFtaW4sIHNlZzJtYXggXTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBpc1BvaW50SW5zaWRlQW5nbGUoIGluVmVydGV4LCBpbkxlZ0Zyb21QdCwgaW5MZWdUb1B0LCBpbk90aGVyUHQgKSB7XHJcblxyXG5cdFx0XHQvLyBUaGUgb3JkZXIgb2YgbGVncyBpcyBpbXBvcnRhbnRcclxuXHJcblx0XHRcdC8vIHRyYW5zbGF0aW9uIG9mIGFsbCBwb2ludHMsIHNvIHRoYXQgVmVydGV4IGlzIGF0ICgwLDApXHJcblx0XHRcdHZhciBsZWdGcm9tUHRYXHQ9IGluTGVnRnJvbVB0LnggLSBpblZlcnRleC54LCAgbGVnRnJvbVB0WVx0PSBpbkxlZ0Zyb21QdC55IC0gaW5WZXJ0ZXgueTtcclxuXHRcdFx0dmFyIGxlZ1RvUHRYXHQ9IGluTGVnVG9QdC54XHQtIGluVmVydGV4LngsICBsZWdUb1B0WVx0XHQ9IGluTGVnVG9QdC55XHQtIGluVmVydGV4Lnk7XHJcblx0XHRcdHZhciBvdGhlclB0WFx0PSBpbk90aGVyUHQueFx0LSBpblZlcnRleC54LCAgb3RoZXJQdFlcdFx0PSBpbk90aGVyUHQueVx0LSBpblZlcnRleC55O1xyXG5cclxuXHRcdFx0Ly8gbWFpbiBhbmdsZSA+MDogPCAxODAgZGVnLjsgMDogMTgwIGRlZy47IDwwOiA+IDE4MCBkZWcuXHJcblx0XHRcdHZhciBmcm9tMnRvQW5nbGVcdD0gbGVnRnJvbVB0WCAqIGxlZ1RvUHRZIC0gbGVnRnJvbVB0WSAqIGxlZ1RvUHRYO1xyXG5cdFx0XHR2YXIgZnJvbTJvdGhlckFuZ2xlXHQ9IGxlZ0Zyb21QdFggKiBvdGhlclB0WSAtIGxlZ0Zyb21QdFkgKiBvdGhlclB0WDtcclxuXHJcblx0XHRcdGlmICggTWF0aC5hYnMoIGZyb20ydG9BbmdsZSApID4gTnVtYmVyLkVQU0lMT04gKSB7XHJcblxyXG5cdFx0XHRcdC8vIGFuZ2xlICE9IDE4MCBkZWcuXHJcblxyXG5cdFx0XHRcdHZhciBvdGhlcjJ0b0FuZ2xlXHRcdD0gb3RoZXJQdFggKiBsZWdUb1B0WSAtIG90aGVyUHRZICogbGVnVG9QdFg7XHJcblx0XHRcdFx0Ly8gY29uc29sZS5sb2coIFwiZnJvbTJ0bzogXCIgKyBmcm9tMnRvQW5nbGUgKyBcIiwgZnJvbTJvdGhlcjogXCIgKyBmcm9tMm90aGVyQW5nbGUgKyBcIiwgb3RoZXIydG86IFwiICsgb3RoZXIydG9BbmdsZSApO1xyXG5cclxuXHRcdFx0XHRpZiAoIGZyb20ydG9BbmdsZSA+IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0Ly8gbWFpbiBhbmdsZSA8IDE4MCBkZWcuXHJcblx0XHRcdFx0XHRyZXR1cm5cdCggKCBmcm9tMm90aGVyQW5nbGUgPj0gMCApICYmICggb3RoZXIydG9BbmdsZSA+PSAwICkgKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHQvLyBtYWluIGFuZ2xlID4gMTgwIGRlZy5cclxuXHRcdFx0XHRcdHJldHVyblx0KCAoIGZyb20yb3RoZXJBbmdsZSA+PSAwICkgfHwgKCBvdGhlcjJ0b0FuZ2xlID49IDAgKSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHQvLyBhbmdsZSA9PSAxODAgZGVnLlxyXG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nKCBcImZyb20ydG86IDE4MCBkZWcuLCBmcm9tMm90aGVyOiBcIiArIGZyb20yb3RoZXJBbmdsZSAgKTtcclxuXHRcdFx0XHRyZXR1cm5cdCggZnJvbTJvdGhlckFuZ2xlID4gMCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblxyXG5cdFx0ZnVuY3Rpb24gcmVtb3ZlSG9sZXMoIGNvbnRvdXIsIGhvbGVzICkge1xyXG5cclxuXHRcdFx0dmFyIHNoYXBlID0gY29udG91ci5jb25jYXQoKTsgLy8gd29yayBvbiB0aGlzIHNoYXBlXHJcblx0XHRcdHZhciBob2xlO1xyXG5cclxuXHRcdFx0ZnVuY3Rpb24gaXNDdXRMaW5lSW5zaWRlQW5nbGVzKCBpblNoYXBlSWR4LCBpbkhvbGVJZHggKSB7XHJcblxyXG5cdFx0XHRcdC8vIENoZWNrIGlmIGhvbGUgcG9pbnQgbGllcyB3aXRoaW4gYW5nbGUgYXJvdW5kIHNoYXBlIHBvaW50XHJcblx0XHRcdFx0dmFyIGxhc3RTaGFwZUlkeCA9IHNoYXBlLmxlbmd0aCAtIDE7XHJcblxyXG5cdFx0XHRcdHZhciBwcmV2U2hhcGVJZHggPSBpblNoYXBlSWR4IC0gMTtcclxuXHRcdFx0XHRpZiAoIHByZXZTaGFwZUlkeCA8IDAgKVx0XHRcdHByZXZTaGFwZUlkeCA9IGxhc3RTaGFwZUlkeDtcclxuXHJcblx0XHRcdFx0dmFyIG5leHRTaGFwZUlkeCA9IGluU2hhcGVJZHggKyAxO1xyXG5cdFx0XHRcdGlmICggbmV4dFNoYXBlSWR4ID4gbGFzdFNoYXBlSWR4IClcdG5leHRTaGFwZUlkeCA9IDA7XHJcblxyXG5cdFx0XHRcdHZhciBpbnNpZGVBbmdsZSA9IGlzUG9pbnRJbnNpZGVBbmdsZSggc2hhcGVbIGluU2hhcGVJZHggXSwgc2hhcGVbIHByZXZTaGFwZUlkeCBdLCBzaGFwZVsgbmV4dFNoYXBlSWR4IF0sIGhvbGVbIGluSG9sZUlkeCBdICk7XHJcblx0XHRcdFx0aWYgKCAhIGluc2lkZUFuZ2xlICkge1xyXG5cclxuXHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nKCBcIlZlcnRleCAoU2hhcGUpOiBcIiArIGluU2hhcGVJZHggKyBcIiwgUG9pbnQ6IFwiICsgaG9sZVtpbkhvbGVJZHhdLnggKyBcIi9cIiArIGhvbGVbaW5Ib2xlSWR4XS55ICk7XHJcblx0XHRcdFx0XHRyZXR1cm5cdGZhbHNlO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vIENoZWNrIGlmIHNoYXBlIHBvaW50IGxpZXMgd2l0aGluIGFuZ2xlIGFyb3VuZCBob2xlIHBvaW50XHJcblx0XHRcdFx0dmFyIGxhc3RIb2xlSWR4ID0gaG9sZS5sZW5ndGggLSAxO1xyXG5cclxuXHRcdFx0XHR2YXIgcHJldkhvbGVJZHggPSBpbkhvbGVJZHggLSAxO1xyXG5cdFx0XHRcdGlmICggcHJldkhvbGVJZHggPCAwIClcdFx0XHRwcmV2SG9sZUlkeCA9IGxhc3RIb2xlSWR4O1xyXG5cclxuXHRcdFx0XHR2YXIgbmV4dEhvbGVJZHggPSBpbkhvbGVJZHggKyAxO1xyXG5cdFx0XHRcdGlmICggbmV4dEhvbGVJZHggPiBsYXN0SG9sZUlkeCApXHRuZXh0SG9sZUlkeCA9IDA7XHJcblxyXG5cdFx0XHRcdGluc2lkZUFuZ2xlID0gaXNQb2ludEluc2lkZUFuZ2xlKCBob2xlWyBpbkhvbGVJZHggXSwgaG9sZVsgcHJldkhvbGVJZHggXSwgaG9sZVsgbmV4dEhvbGVJZHggXSwgc2hhcGVbIGluU2hhcGVJZHggXSApO1xyXG5cdFx0XHRcdGlmICggISBpbnNpZGVBbmdsZSApIHtcclxuXHJcblx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZyggXCJWZXJ0ZXggKEhvbGUpOiBcIiArIGluSG9sZUlkeCArIFwiLCBQb2ludDogXCIgKyBzaGFwZVtpblNoYXBlSWR4XS54ICsgXCIvXCIgKyBzaGFwZVtpblNoYXBlSWR4XS55ICk7XHJcblx0XHRcdFx0XHRyZXR1cm5cdGZhbHNlO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHJldHVyblx0dHJ1ZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZ1bmN0aW9uIGludGVyc2VjdHNTaGFwZUVkZ2UoIGluU2hhcGVQdCwgaW5Ib2xlUHQgKSB7XHJcblxyXG5cdFx0XHRcdC8vIGNoZWNrcyBmb3IgaW50ZXJzZWN0aW9ucyB3aXRoIHNoYXBlIGVkZ2VzXHJcblx0XHRcdFx0dmFyIHNJZHgsIG5leHRJZHgsIGludGVyc2VjdGlvbjtcclxuXHRcdFx0XHRmb3IgKCBzSWR4ID0gMDsgc0lkeCA8IHNoYXBlLmxlbmd0aDsgc0lkeCArKyApIHtcclxuXHJcblx0XHRcdFx0XHRuZXh0SWR4ID0gc0lkeCArIDE7IG5leHRJZHggJT0gc2hhcGUubGVuZ3RoO1xyXG5cdFx0XHRcdFx0aW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0X3NlZ21lbnRzXzJEKCBpblNoYXBlUHQsIGluSG9sZVB0LCBzaGFwZVsgc0lkeCBdLCBzaGFwZVsgbmV4dElkeCBdLCB0cnVlICk7XHJcblx0XHRcdFx0XHRpZiAoIGludGVyc2VjdGlvbi5sZW5ndGggPiAwIClcdFx0cmV0dXJuXHR0cnVlO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHJldHVyblx0ZmFsc2U7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgaW5kZXBIb2xlcyA9IFtdO1xyXG5cclxuXHRcdFx0ZnVuY3Rpb24gaW50ZXJzZWN0c0hvbGVFZGdlKCBpblNoYXBlUHQsIGluSG9sZVB0ICkge1xyXG5cclxuXHRcdFx0XHQvLyBjaGVja3MgZm9yIGludGVyc2VjdGlvbnMgd2l0aCBob2xlIGVkZ2VzXHJcblx0XHRcdFx0dmFyIGloSWR4LCBjaGtIb2xlLFxyXG5cdFx0XHRcdFx0aElkeCwgbmV4dElkeCwgaW50ZXJzZWN0aW9uO1xyXG5cdFx0XHRcdGZvciAoIGloSWR4ID0gMDsgaWhJZHggPCBpbmRlcEhvbGVzLmxlbmd0aDsgaWhJZHggKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y2hrSG9sZSA9IGhvbGVzWyBpbmRlcEhvbGVzWyBpaElkeCBdXTtcclxuXHRcdFx0XHRcdGZvciAoIGhJZHggPSAwOyBoSWR4IDwgY2hrSG9sZS5sZW5ndGg7IGhJZHggKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRuZXh0SWR4ID0gaElkeCArIDE7IG5leHRJZHggJT0gY2hrSG9sZS5sZW5ndGg7XHJcblx0XHRcdFx0XHRcdGludGVyc2VjdGlvbiA9IGludGVyc2VjdF9zZWdtZW50c18yRCggaW5TaGFwZVB0LCBpbkhvbGVQdCwgY2hrSG9sZVsgaElkeCBdLCBjaGtIb2xlWyBuZXh0SWR4IF0sIHRydWUgKTtcclxuXHRcdFx0XHRcdFx0aWYgKCBpbnRlcnNlY3Rpb24ubGVuZ3RoID4gMCApXHRcdHJldHVyblx0dHJ1ZTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm5cdGZhbHNlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIGhvbGVJbmRleCwgc2hhcGVJbmRleCxcclxuXHRcdFx0XHRzaGFwZVB0LCBob2xlUHQsXHJcblx0XHRcdFx0aG9sZUlkeCwgY3V0S2V5LCBmYWlsZWRDdXRzID0gW10sXHJcblx0XHRcdFx0dG1wU2hhcGUxLCB0bXBTaGFwZTIsXHJcblx0XHRcdFx0dG1wSG9sZTEsIHRtcEhvbGUyO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoICsrICkge1xyXG5cclxuXHRcdFx0XHRpbmRlcEhvbGVzLnB1c2goIGggKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBtaW5TaGFwZUluZGV4ID0gMDtcclxuXHRcdFx0dmFyIGNvdW50ZXIgPSBpbmRlcEhvbGVzLmxlbmd0aCAqIDI7XHJcblx0XHRcdHdoaWxlICggaW5kZXBIb2xlcy5sZW5ndGggPiAwICkge1xyXG5cclxuXHRcdFx0XHRjb3VudGVyIC0tO1xyXG5cdFx0XHRcdGlmICggY291bnRlciA8IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y29uc29sZS5sb2coIFwiSW5maW5pdGUgTG9vcCEgSG9sZXMgbGVmdDpcIiArIGluZGVwSG9sZXMubGVuZ3RoICsgXCIsIFByb2JhYmx5IEhvbGUgb3V0c2lkZSBTaGFwZSFcIiApO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gc2VhcmNoIGZvciBzaGFwZS12ZXJ0ZXggYW5kIGhvbGUtdmVydGV4LFxyXG5cdFx0XHRcdC8vIHdoaWNoIGNhbiBiZSBjb25uZWN0ZWQgd2l0aG91dCBpbnRlcnNlY3Rpb25zXHJcblx0XHRcdFx0Zm9yICggc2hhcGVJbmRleCA9IG1pblNoYXBlSW5kZXg7IHNoYXBlSW5kZXggPCBzaGFwZS5sZW5ndGg7IHNoYXBlSW5kZXggKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0c2hhcGVQdCA9IHNoYXBlWyBzaGFwZUluZGV4IF07XHJcblx0XHRcdFx0XHRob2xlSW5kZXhcdD0gLSAxO1xyXG5cclxuXHRcdFx0XHRcdC8vIHNlYXJjaCBmb3IgaG9sZSB3aGljaCBjYW4gYmUgcmVhY2hlZCB3aXRob3V0IGludGVyc2VjdGlvbnNcclxuXHRcdFx0XHRcdGZvciAoIHZhciBoID0gMDsgaCA8IGluZGVwSG9sZXMubGVuZ3RoOyBoICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0aG9sZUlkeCA9IGluZGVwSG9sZXNbIGggXTtcclxuXHJcblx0XHRcdFx0XHRcdC8vIHByZXZlbnQgbXVsdGlwbGUgY2hlY2tzXHJcblx0XHRcdFx0XHRcdGN1dEtleSA9IHNoYXBlUHQueCArIFwiOlwiICsgc2hhcGVQdC55ICsgXCI6XCIgKyBob2xlSWR4O1xyXG5cdFx0XHRcdFx0XHRpZiAoIGZhaWxlZEN1dHNbIGN1dEtleSBdICE9PSB1bmRlZmluZWQgKVx0XHRcdGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0XHRcdFx0aG9sZSA9IGhvbGVzWyBob2xlSWR4IF07XHJcblx0XHRcdFx0XHRcdGZvciAoIHZhciBoMiA9IDA7IGgyIDwgaG9sZS5sZW5ndGg7IGgyICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRob2xlUHQgPSBob2xlWyBoMiBdO1xyXG5cdFx0XHRcdFx0XHRcdGlmICggISBpc0N1dExpbmVJbnNpZGVBbmdsZXMoIHNoYXBlSW5kZXgsIGgyICkgKVx0XHRjb250aW51ZTtcclxuXHRcdFx0XHRcdFx0XHRpZiAoIGludGVyc2VjdHNTaGFwZUVkZ2UoIHNoYXBlUHQsIGhvbGVQdCApIClcdFx0Y29udGludWU7XHJcblx0XHRcdFx0XHRcdFx0aWYgKCBpbnRlcnNlY3RzSG9sZUVkZ2UoIHNoYXBlUHQsIGhvbGVQdCApIClcdFx0Y29udGludWU7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGhvbGVJbmRleCA9IGgyO1xyXG5cdFx0XHRcdFx0XHRcdGluZGVwSG9sZXMuc3BsaWNlKCBoLCAxICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHRtcFNoYXBlMSA9IHNoYXBlLnNsaWNlKCAwLCBzaGFwZUluZGV4ICsgMSApO1xyXG5cdFx0XHRcdFx0XHRcdHRtcFNoYXBlMiA9IHNoYXBlLnNsaWNlKCBzaGFwZUluZGV4ICk7XHJcblx0XHRcdFx0XHRcdFx0dG1wSG9sZTEgPSBob2xlLnNsaWNlKCBob2xlSW5kZXggKTtcclxuXHRcdFx0XHRcdFx0XHR0bXBIb2xlMiA9IGhvbGUuc2xpY2UoIDAsIGhvbGVJbmRleCArIDEgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0c2hhcGUgPSB0bXBTaGFwZTEuY29uY2F0KCB0bXBIb2xlMSApLmNvbmNhdCggdG1wSG9sZTIgKS5jb25jYXQoIHRtcFNoYXBlMiApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRtaW5TaGFwZUluZGV4ID0gc2hhcGVJbmRleDtcclxuXHJcblx0XHRcdFx0XHRcdFx0Ly8gRGVidWcgb25seSwgdG8gc2hvdyB0aGUgc2VsZWN0ZWQgY3V0c1xyXG5cdFx0XHRcdFx0XHRcdC8vIGdsb2JfQ3V0TGluZXMucHVzaCggWyBzaGFwZVB0LCBob2xlUHQgXSApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0aWYgKCBob2xlSW5kZXggPj0gMCApXHRicmVhaztcdFx0Ly8gaG9sZS12ZXJ0ZXggZm91bmRcclxuXHJcblx0XHRcdFx0XHRcdGZhaWxlZEN1dHNbIGN1dEtleSBdID0gdHJ1ZTtcdFx0XHQvLyByZW1lbWJlciBmYWlsdXJlXHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYgKCBob2xlSW5kZXggPj0gMCApXHRicmVhaztcdFx0Ly8gaG9sZS12ZXJ0ZXggZm91bmRcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHNoYXBlOyBcdFx0XHQvKiBzaGFwZSB3aXRoIG5vIGhvbGVzICovXHJcblxyXG5cdFx0fVxyXG5cclxuXHJcblx0XHR2YXIgaSwgaWwsIGYsIGZhY2UsXHJcblx0XHRcdGtleSwgaW5kZXgsXHJcblx0XHRcdGFsbFBvaW50c01hcCA9IHt9O1xyXG5cclxuXHRcdC8vIFRvIG1haW50YWluIHJlZmVyZW5jZSB0byBvbGQgc2hhcGUsIG9uZSBtdXN0IG1hdGNoIGNvb3JkaW5hdGVzLCBvciBvZmZzZXQgdGhlIGluZGljZXMgZnJvbSBvcmlnaW5hbCBhcnJheXMuIEl0J3MgcHJvYmFibHkgZWFzaWVyIHRvIGRvIHRoZSBmaXJzdC5cclxuXHJcblx0XHR2YXIgYWxscG9pbnRzID0gY29udG91ci5jb25jYXQoKTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyBoIDwgaGw7IGggKysgKSB7XHJcblxyXG5cdFx0XHRBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseSggYWxscG9pbnRzLCBob2xlc1sgaCBdICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vY29uc29sZS5sb2coIFwiYWxscG9pbnRzXCIsYWxscG9pbnRzLCBhbGxwb2ludHMubGVuZ3RoICk7XHJcblxyXG5cdFx0Ly8gcHJlcGFyZSBhbGwgcG9pbnRzIG1hcFxyXG5cclxuXHRcdGZvciAoIGkgPSAwLCBpbCA9IGFsbHBvaW50cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdGtleSA9IGFsbHBvaW50c1sgaSBdLnggKyBcIjpcIiArIGFsbHBvaW50c1sgaSBdLnk7XHJcblxyXG5cdFx0XHRpZiAoIGFsbFBvaW50c01hcFsga2V5IF0gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCBcIlRIUkVFLlNoYXBlOiBEdXBsaWNhdGUgcG9pbnRcIiwga2V5ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRhbGxQb2ludHNNYXBbIGtleSBdID0gaTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gcmVtb3ZlIGhvbGVzIGJ5IGN1dHRpbmcgcGF0aHMgdG8gaG9sZXMgYW5kIGFkZGluZyB0aGVtIHRvIHRoZSBzaGFwZVxyXG5cdFx0dmFyIHNoYXBlV2l0aG91dEhvbGVzID0gcmVtb3ZlSG9sZXMoIGNvbnRvdXIsIGhvbGVzICk7XHJcblxyXG5cdFx0dmFyIHRyaWFuZ2xlcyA9IFRIUkVFLlNoYXBlVXRpbHMudHJpYW5ndWxhdGUoIHNoYXBlV2l0aG91dEhvbGVzLCBmYWxzZSApOyAvLyBUcnVlIHJldHVybnMgaW5kaWNlcyBmb3IgcG9pbnRzIG9mIHNwb29sZWQgc2hhcGVcclxuXHRcdC8vY29uc29sZS5sb2coIFwidHJpYW5nbGVzXCIsdHJpYW5nbGVzLCB0cmlhbmdsZXMubGVuZ3RoICk7XHJcblxyXG5cdFx0Ly8gY2hlY2sgYWxsIGZhY2UgdmVydGljZXMgYWdhaW5zdCBhbGwgcG9pbnRzIG1hcFxyXG5cclxuXHRcdGZvciAoIGkgPSAwLCBpbCA9IHRyaWFuZ2xlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdGZhY2UgPSB0cmlhbmdsZXNbIGkgXTtcclxuXHJcblx0XHRcdGZvciAoIGYgPSAwOyBmIDwgMzsgZiArKyApIHtcclxuXHJcblx0XHRcdFx0a2V5ID0gZmFjZVsgZiBdLnggKyBcIjpcIiArIGZhY2VbIGYgXS55O1xyXG5cclxuXHRcdFx0XHRpbmRleCA9IGFsbFBvaW50c01hcFsga2V5IF07XHJcblxyXG5cdFx0XHRcdGlmICggaW5kZXggIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRmYWNlWyBmIF0gPSBpbmRleDtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdHJpYW5nbGVzLmNvbmNhdCgpO1xyXG5cclxuXHR9LFxyXG5cclxuXHRpc0Nsb2NrV2lzZTogZnVuY3Rpb24gKCBwdHMgKSB7XHJcblxyXG5cdFx0cmV0dXJuIFRIUkVFLlNoYXBlVXRpbHMuYXJlYSggcHRzICkgPCAwO1xyXG5cclxuXHR9LFxyXG5cclxuXHQvLyBCZXppZXIgQ3VydmVzIGZvcm11bGFzIG9idGFpbmVkIGZyb21cclxuXHQvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0IlQzMlQTl6aWVyX2N1cnZlXHJcblxyXG5cdC8vIFF1YWQgQmV6aWVyIEZ1bmN0aW9uc1xyXG5cclxuXHRiMjogKCBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0ZnVuY3Rpb24gYjJwMCggdCwgcCApIHtcclxuXHJcblx0XHRcdHZhciBrID0gMSAtIHQ7XHJcblx0XHRcdHJldHVybiBrICogayAqIHA7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIGIycDEoIHQsIHAgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gMiAqICggMSAtIHQgKSAqIHQgKiBwO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBiMnAyKCB0LCBwICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHQgKiB0ICogcDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggdCwgcDAsIHAxLCBwMiApIHtcclxuXHJcblx0XHRcdHJldHVybiBiMnAwKCB0LCBwMCApICsgYjJwMSggdCwgcDEgKSArIGIycDIoIHQsIHAyICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSApKCksXHJcblxyXG5cdC8vIEN1YmljIEJlemllciBGdW5jdGlvbnNcclxuXHJcblx0YjM6ICggZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdGZ1bmN0aW9uIGIzcDAoIHQsIHAgKSB7XHJcblxyXG5cdFx0XHR2YXIgayA9IDEgLSB0O1xyXG5cdFx0XHRyZXR1cm4gayAqIGsgKiBrICogcDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gYjNwMSggdCwgcCApIHtcclxuXHJcblx0XHRcdHZhciBrID0gMSAtIHQ7XHJcblx0XHRcdHJldHVybiAzICogayAqIGsgKiB0ICogcDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gYjNwMiggdCwgcCApIHtcclxuXHJcblx0XHRcdHZhciBrID0gMSAtIHQ7XHJcblx0XHRcdHJldHVybiAzICogayAqIHQgKiB0ICogcDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gYjNwMyggdCwgcCApIHtcclxuXHJcblx0XHRcdHJldHVybiB0ICogdCAqIHQgKiBwO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCB0LCBwMCwgcDEsIHAyLCBwMyApIHtcclxuXHJcblx0XHRcdHJldHVybiBiM3AwKCB0LCBwMCApICsgYjNwMSggdCwgcDEgKSArIGIzcDIoIHQsIHAyICkgKyBiM3AzKCB0LCBwMyApO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0gKSgpXHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2NvcmUvQ3VydmUuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXHJcbiAqIEV4dGVuc2libGUgY3VydmUgb2JqZWN0XHJcbiAqXHJcbiAqIFNvbWUgY29tbW9uIG9mIEN1cnZlIG1ldGhvZHNcclxuICogLmdldFBvaW50KHQpLCBnZXRUYW5nZW50KHQpXHJcbiAqIC5nZXRQb2ludEF0KHUpLCBnZXRUYWdlbnRBdCh1KVxyXG4gKiAuZ2V0UG9pbnRzKCksIC5nZXRTcGFjZWRQb2ludHMoKVxyXG4gKiAuZ2V0TGVuZ3RoKClcclxuICogLnVwZGF0ZUFyY0xlbmd0aHMoKVxyXG4gKlxyXG4gKiBUaGlzIGZvbGxvd2luZyBjbGFzc2VzIHN1YmNsYXNzZXMgVEhSRUUuQ3VydmU6XHJcbiAqXHJcbiAqIC0tIDJkIGNsYXNzZXMgLS1cclxuICogVEhSRUUuTGluZUN1cnZlXHJcbiAqIFRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlXHJcbiAqIFRIUkVFLkN1YmljQmV6aWVyQ3VydmVcclxuICogVEhSRUUuU3BsaW5lQ3VydmVcclxuICogVEhSRUUuQXJjQ3VydmVcclxuICogVEhSRUUuRWxsaXBzZUN1cnZlXHJcbiAqXHJcbiAqIC0tIDNkIGNsYXNzZXMgLS1cclxuICogVEhSRUUuTGluZUN1cnZlM1xyXG4gKiBUSFJFRS5RdWFkcmF0aWNCZXppZXJDdXJ2ZTNcclxuICogVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZTNcclxuICogVEhSRUUuU3BsaW5lQ3VydmUzXHJcbiAqIFRIUkVFLkNsb3NlZFNwbGluZUN1cnZlM1xyXG4gKlxyXG4gKiBBIHNlcmllcyBvZiBjdXJ2ZXMgY2FuIGJlIHJlcHJlc2VudGVkIGFzIGEgVEhSRUUuQ3VydmVQYXRoXHJcbiAqXHJcbiAqKi9cclxuXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gKlx0QWJzdHJhY3QgQ3VydmUgYmFzZSBjbGFzc1xyXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG5USFJFRS5DdXJ2ZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbn07XHJcblxyXG5USFJFRS5DdXJ2ZS5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5DdXJ2ZSxcclxuXHJcblx0Ly8gVmlydHVhbCBiYXNlIGNsYXNzIG1ldGhvZCB0byBvdmVyd3JpdGUgYW5kIGltcGxlbWVudCBpbiBzdWJjbGFzc2VzXHJcblx0Ly9cdC0gdCBbMCAuLiAxXVxyXG5cclxuXHRnZXRQb2ludDogZnVuY3Rpb24gKCB0ICkge1xyXG5cclxuXHRcdGNvbnNvbGUud2FybiggXCJUSFJFRS5DdXJ2ZTogV2FybmluZywgZ2V0UG9pbnQoKSBub3QgaW1wbGVtZW50ZWQhXCIgKTtcclxuXHRcdHJldHVybiBudWxsO1xyXG5cclxuXHR9LFxyXG5cclxuXHQvLyBHZXQgcG9pbnQgYXQgcmVsYXRpdmUgcG9zaXRpb24gaW4gY3VydmUgYWNjb3JkaW5nIHRvIGFyYyBsZW5ndGhcclxuXHQvLyAtIHUgWzAgLi4gMV1cclxuXHJcblx0Z2V0UG9pbnRBdDogZnVuY3Rpb24gKCB1ICkge1xyXG5cclxuXHRcdHZhciB0ID0gdGhpcy5nZXRVdG9UbWFwcGluZyggdSApO1xyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0UG9pbnQoIHQgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Ly8gR2V0IHNlcXVlbmNlIG9mIHBvaW50cyB1c2luZyBnZXRQb2ludCggdCApXHJcblxyXG5cdGdldFBvaW50czogZnVuY3Rpb24gKCBkaXZpc2lvbnMgKSB7XHJcblxyXG5cdFx0aWYgKCAhIGRpdmlzaW9ucyApIGRpdmlzaW9ucyA9IDU7XHJcblxyXG5cdFx0dmFyIGQsIHB0cyA9IFtdO1xyXG5cclxuXHRcdGZvciAoIGQgPSAwOyBkIDw9IGRpdmlzaW9uczsgZCArKyApIHtcclxuXHJcblx0XHRcdHB0cy5wdXNoKCB0aGlzLmdldFBvaW50KCBkIC8gZGl2aXNpb25zICkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHB0cztcclxuXHJcblx0fSxcclxuXHJcblx0Ly8gR2V0IHNlcXVlbmNlIG9mIHBvaW50cyB1c2luZyBnZXRQb2ludEF0KCB1IClcclxuXHJcblx0Z2V0U3BhY2VkUG9pbnRzOiBmdW5jdGlvbiAoIGRpdmlzaW9ucyApIHtcclxuXHJcblx0XHRpZiAoICEgZGl2aXNpb25zICkgZGl2aXNpb25zID0gNTtcclxuXHJcblx0XHR2YXIgZCwgcHRzID0gW107XHJcblxyXG5cdFx0Zm9yICggZCA9IDA7IGQgPD0gZGl2aXNpb25zOyBkICsrICkge1xyXG5cclxuXHRcdFx0cHRzLnB1c2goIHRoaXMuZ2V0UG9pbnRBdCggZCAvIGRpdmlzaW9ucyApICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBwdHM7XHJcblxyXG5cdH0sXHJcblxyXG5cdC8vIEdldCB0b3RhbCBjdXJ2ZSBhcmMgbGVuZ3RoXHJcblxyXG5cdGdldExlbmd0aDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBsZW5ndGhzID0gdGhpcy5nZXRMZW5ndGhzKCk7XHJcblx0XHRyZXR1cm4gbGVuZ3Roc1sgbGVuZ3Rocy5sZW5ndGggLSAxIF07XHJcblxyXG5cdH0sXHJcblxyXG5cdC8vIEdldCBsaXN0IG9mIGN1bXVsYXRpdmUgc2VnbWVudCBsZW5ndGhzXHJcblxyXG5cdGdldExlbmd0aHM6IGZ1bmN0aW9uICggZGl2aXNpb25zICkge1xyXG5cclxuXHRcdGlmICggISBkaXZpc2lvbnMgKSBkaXZpc2lvbnMgPSAoIHRoaXMuX19hcmNMZW5ndGhEaXZpc2lvbnMgKSA/ICggdGhpcy5fX2FyY0xlbmd0aERpdmlzaW9ucyApIDogMjAwO1xyXG5cclxuXHRcdGlmICggdGhpcy5jYWNoZUFyY0xlbmd0aHNcclxuXHRcdFx0JiYgKCB0aGlzLmNhY2hlQXJjTGVuZ3Rocy5sZW5ndGggPT09IGRpdmlzaW9ucyArIDEgKVxyXG5cdFx0XHQmJiAhIHRoaXMubmVlZHNVcGRhdGUgKSB7XHJcblxyXG5cdFx0XHQvL2NvbnNvbGUubG9nKCBcImNhY2hlZFwiLCB0aGlzLmNhY2hlQXJjTGVuZ3RocyApO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5jYWNoZUFyY0xlbmd0aHM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMubmVlZHNVcGRhdGUgPSBmYWxzZTtcclxuXHJcblx0XHR2YXIgY2FjaGUgPSBbXTtcclxuXHRcdHZhciBjdXJyZW50LCBsYXN0ID0gdGhpcy5nZXRQb2ludCggMCApO1xyXG5cdFx0dmFyIHAsIHN1bSA9IDA7XHJcblxyXG5cdFx0Y2FjaGUucHVzaCggMCApO1xyXG5cclxuXHRcdGZvciAoIHAgPSAxOyBwIDw9IGRpdmlzaW9uczsgcCArKyApIHtcclxuXHJcblx0XHRcdGN1cnJlbnQgPSB0aGlzLmdldFBvaW50ICggcCAvIGRpdmlzaW9ucyApO1xyXG5cdFx0XHRzdW0gKz0gY3VycmVudC5kaXN0YW5jZVRvKCBsYXN0ICk7XHJcblx0XHRcdGNhY2hlLnB1c2goIHN1bSApO1xyXG5cdFx0XHRsYXN0ID0gY3VycmVudDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5jYWNoZUFyY0xlbmd0aHMgPSBjYWNoZTtcclxuXHJcblx0XHRyZXR1cm4gY2FjaGU7IC8vIHsgc3VtczogY2FjaGUsIHN1bTpzdW0gfTsgU3VtIGlzIGluIHRoZSBsYXN0IGVsZW1lbnQuXHJcblxyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZUFyY0xlbmd0aHM6IGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cdFx0dGhpcy5nZXRMZW5ndGhzKCk7XHJcblxyXG5cdH0sXHJcblxyXG5cdC8vIEdpdmVuIHUgKCAwIC4uIDEgKSwgZ2V0IGEgdCB0byBmaW5kIHAuIFRoaXMgZ2l2ZXMgeW91IHBvaW50cyB3aGljaCBhcmUgZXF1aWRpc3RhbnRcclxuXHJcblx0Z2V0VXRvVG1hcHBpbmc6IGZ1bmN0aW9uICggdSwgZGlzdGFuY2UgKSB7XHJcblxyXG5cdFx0dmFyIGFyY0xlbmd0aHMgPSB0aGlzLmdldExlbmd0aHMoKTtcclxuXHJcblx0XHR2YXIgaSA9IDAsIGlsID0gYXJjTGVuZ3Rocy5sZW5ndGg7XHJcblxyXG5cdFx0dmFyIHRhcmdldEFyY0xlbmd0aDsgLy8gVGhlIHRhcmdldGVkIHUgZGlzdGFuY2UgdmFsdWUgdG8gZ2V0XHJcblxyXG5cdFx0aWYgKCBkaXN0YW5jZSApIHtcclxuXHJcblx0XHRcdHRhcmdldEFyY0xlbmd0aCA9IGRpc3RhbmNlO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHR0YXJnZXRBcmNMZW5ndGggPSB1ICogYXJjTGVuZ3Roc1sgaWwgLSAxIF07XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vdmFyIHRpbWUgPSBEYXRlLm5vdygpO1xyXG5cclxuXHRcdC8vIGJpbmFyeSBzZWFyY2ggZm9yIHRoZSBpbmRleCB3aXRoIGxhcmdlc3QgdmFsdWUgc21hbGxlciB0aGFuIHRhcmdldCB1IGRpc3RhbmNlXHJcblxyXG5cdFx0dmFyIGxvdyA9IDAsIGhpZ2ggPSBpbCAtIDEsIGNvbXBhcmlzb247XHJcblxyXG5cdFx0d2hpbGUgKCBsb3cgPD0gaGlnaCApIHtcclxuXHJcblx0XHRcdGkgPSBNYXRoLmZsb29yKCBsb3cgKyAoIGhpZ2ggLSBsb3cgKSAvIDIgKTsgLy8gbGVzcyBsaWtlbHkgdG8gb3ZlcmZsb3csIHRob3VnaCBwcm9iYWJseSBub3QgaXNzdWUgaGVyZSwgSlMgZG9lc24ndCByZWFsbHkgaGF2ZSBpbnRlZ2VycywgYWxsIG51bWJlcnMgYXJlIGZsb2F0c1xyXG5cclxuXHRcdFx0Y29tcGFyaXNvbiA9IGFyY0xlbmd0aHNbIGkgXSAtIHRhcmdldEFyY0xlbmd0aDtcclxuXHJcblx0XHRcdGlmICggY29tcGFyaXNvbiA8IDAgKSB7XHJcblxyXG5cdFx0XHRcdGxvdyA9IGkgKyAxO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggY29tcGFyaXNvbiA+IDAgKSB7XHJcblxyXG5cdFx0XHRcdGhpZ2ggPSBpIC0gMTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGhpZ2ggPSBpO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHQvLyBET05FXHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGkgPSBoaWdoO1xyXG5cclxuXHRcdC8vY29uc29sZS5sb2coJ2InICwgaSwgbG93LCBoaWdoLCBEYXRlLm5vdygpLSB0aW1lKTtcclxuXHJcblx0XHRpZiAoIGFyY0xlbmd0aHNbIGkgXSA9PT0gdGFyZ2V0QXJjTGVuZ3RoICkge1xyXG5cclxuXHRcdFx0dmFyIHQgPSBpIC8gKCBpbCAtIDEgKTtcclxuXHRcdFx0cmV0dXJuIHQ7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHdlIGNvdWxkIGdldCBmaW5lciBncmFpbiBhdCBsZW5ndGhzLCBvciB1c2Ugc2ltcGxlIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gcG9pbnRzXHJcblxyXG5cdFx0dmFyIGxlbmd0aEJlZm9yZSA9IGFyY0xlbmd0aHNbIGkgXTtcclxuXHRcdHZhciBsZW5ndGhBZnRlciA9IGFyY0xlbmd0aHNbIGkgKyAxIF07XHJcblxyXG5cdFx0dmFyIHNlZ21lbnRMZW5ndGggPSBsZW5ndGhBZnRlciAtIGxlbmd0aEJlZm9yZTtcclxuXHJcblx0XHQvLyBkZXRlcm1pbmUgd2hlcmUgd2UgYXJlIGJldHdlZW4gdGhlICdiZWZvcmUnIGFuZCAnYWZ0ZXInIHBvaW50c1xyXG5cclxuXHRcdHZhciBzZWdtZW50RnJhY3Rpb24gPSAoIHRhcmdldEFyY0xlbmd0aCAtIGxlbmd0aEJlZm9yZSApIC8gc2VnbWVudExlbmd0aDtcclxuXHJcblx0XHQvLyBhZGQgdGhhdCBmcmFjdGlvbmFsIGFtb3VudCB0byB0XHJcblxyXG5cdFx0dmFyIHQgPSAoIGkgKyBzZWdtZW50RnJhY3Rpb24gKSAvICggaWwgLSAxICk7XHJcblxyXG5cdFx0cmV0dXJuIHQ7XHJcblxyXG5cdH0sXHJcblxyXG5cdC8vIFJldHVybnMgYSB1bml0IHZlY3RvciB0YW5nZW50IGF0IHRcclxuXHQvLyBJbiBjYXNlIGFueSBzdWIgY3VydmUgZG9lcyBub3QgaW1wbGVtZW50IGl0cyB0YW5nZW50IGRlcml2YXRpb24sXHJcblx0Ly8gMiBwb2ludHMgYSBzbWFsbCBkZWx0YSBhcGFydCB3aWxsIGJlIHVzZWQgdG8gZmluZCBpdHMgZ3JhZGllbnRcclxuXHQvLyB3aGljaCBzZWVtcyB0byBnaXZlIGEgcmVhc29uYWJsZSBhcHByb3hpbWF0aW9uXHJcblxyXG5cdGdldFRhbmdlbnQ6IGZ1bmN0aW9uKCB0ICkge1xyXG5cclxuXHRcdHZhciBkZWx0YSA9IDAuMDAwMTtcclxuXHRcdHZhciB0MSA9IHQgLSBkZWx0YTtcclxuXHRcdHZhciB0MiA9IHQgKyBkZWx0YTtcclxuXHJcblx0XHQvLyBDYXBwaW5nIGluIGNhc2Ugb2YgZGFuZ2VyXHJcblxyXG5cdFx0aWYgKCB0MSA8IDAgKSB0MSA9IDA7XHJcblx0XHRpZiAoIHQyID4gMSApIHQyID0gMTtcclxuXHJcblx0XHR2YXIgcHQxID0gdGhpcy5nZXRQb2ludCggdDEgKTtcclxuXHRcdHZhciBwdDIgPSB0aGlzLmdldFBvaW50KCB0MiApO1xyXG5cclxuXHRcdHZhciB2ZWMgPSBwdDIuY2xvbmUoKS5zdWIoIHB0MSApO1xyXG5cdFx0cmV0dXJuIHZlYy5ub3JtYWxpemUoKTtcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0VGFuZ2VudEF0OiBmdW5jdGlvbiAoIHUgKSB7XHJcblxyXG5cdFx0dmFyIHQgPSB0aGlzLmdldFV0b1RtYXBwaW5nKCB1ICk7XHJcblx0XHRyZXR1cm4gdGhpcy5nZXRUYW5nZW50KCB0ICk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vLyBUT0RPOiBUcmFuc2Zvcm1hdGlvbiBmb3IgQ3VydmVzP1xyXG5cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAqXHQzRCBDdXJ2ZXNcclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuLy8gQSBGYWN0b3J5IG1ldGhvZCBmb3IgY3JlYXRpbmcgbmV3IGN1cnZlIHN1YmNsYXNzZXNcclxuXHJcblRIUkVFLkN1cnZlLmNyZWF0ZSA9IGZ1bmN0aW9uICggY29uc3RydWN0b3IsIGdldFBvaW50RnVuYyApIHtcclxuXHJcblx0Y29uc3RydWN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQ3VydmUucHJvdG90eXBlICk7XHJcblx0Y29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY29uc3RydWN0b3I7XHJcblx0Y29uc3RydWN0b3IucHJvdG90eXBlLmdldFBvaW50ID0gZ2V0UG9pbnRGdW5jO1xyXG5cclxuXHRyZXR1cm4gY29uc3RydWN0b3I7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2NvcmUvQ3VydmVQYXRoLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xyXG4gKlxyXG4gKiovXHJcblxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICpcdEN1cnZlZCBQYXRoIC0gYSBjdXJ2ZSBwYXRoIGlzIHNpbXBseSBhIGFycmF5IG9mIGNvbm5lY3RlZFxyXG4gKiAgY3VydmVzLCBidXQgcmV0YWlucyB0aGUgYXBpIG9mIGEgY3VydmVcclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuVEhSRUUuQ3VydmVQYXRoID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR0aGlzLmN1cnZlcyA9IFtdO1xyXG5cclxuXHR0aGlzLmF1dG9DbG9zZSA9IGZhbHNlOyAvLyBBdXRvbWF0aWNhbGx5IGNsb3NlcyB0aGUgcGF0aFxyXG5cclxufTtcclxuXHJcblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5DdXJ2ZS5wcm90b3R5cGUgKTtcclxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkN1cnZlUGF0aDtcclxuXHJcblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKCBjdXJ2ZSApIHtcclxuXHJcblx0dGhpcy5jdXJ2ZXMucHVzaCggY3VydmUgKTtcclxuXHJcbn07XHJcblxyXG4vKlxyXG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmNoZWNrQ29ubmVjdGlvbiA9IGZ1bmN0aW9uKCkge1xyXG5cdC8vIFRPRE9cclxuXHQvLyBJZiB0aGUgZW5kaW5nIG9mIGN1cnZlIGlzIG5vdCBjb25uZWN0ZWQgdG8gdGhlIHN0YXJ0aW5nXHJcblx0Ly8gb3IgdGhlIG5leHQgY3VydmUsIHRoZW4sIHRoaXMgaXMgbm90IGEgcmVhbCBwYXRoXHJcbn07XHJcbiovXHJcblxyXG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmNsb3NlUGF0aCA9IGZ1bmN0aW9uKCkge1xyXG5cclxuXHQvLyBUT0RPIFRlc3RcclxuXHQvLyBhbmQgdmVyaWZ5IGZvciB2ZWN0b3IzIChuZWVkcyB0byBpbXBsZW1lbnQgZXF1YWxzKVxyXG5cdC8vIEFkZCBhIGxpbmUgY3VydmUgaWYgc3RhcnQgYW5kIGVuZCBvZiBsaW5lcyBhcmUgbm90IGNvbm5lY3RlZFxyXG5cdHZhciBzdGFydFBvaW50ID0gdGhpcy5jdXJ2ZXNbIDAgXS5nZXRQb2ludCggMCApO1xyXG5cdHZhciBlbmRQb2ludCA9IHRoaXMuY3VydmVzWyB0aGlzLmN1cnZlcy5sZW5ndGggLSAxIF0uZ2V0UG9pbnQoIDEgKTtcclxuXHJcblx0aWYgKCAhIHN0YXJ0UG9pbnQuZXF1YWxzKCBlbmRQb2ludCApICkge1xyXG5cclxuXHRcdHRoaXMuY3VydmVzLnB1c2goIG5ldyBUSFJFRS5MaW5lQ3VydmUoIGVuZFBvaW50LCBzdGFydFBvaW50ICkgKTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbi8vIFRvIGdldCBhY2N1cmF0ZSBwb2ludCB3aXRoIHJlZmVyZW5jZSB0b1xyXG4vLyBlbnRpcmUgcGF0aCBkaXN0YW5jZSBhdCB0aW1lIHQsXHJcbi8vIGZvbGxvd2luZyBoYXMgdG8gYmUgZG9uZTpcclxuXHJcbi8vIDEuIExlbmd0aCBvZiBlYWNoIHN1YiBwYXRoIGhhdmUgdG8gYmUga25vd25cclxuLy8gMi4gTG9jYXRlIGFuZCBpZGVudGlmeSB0eXBlIG9mIGN1cnZlXHJcbi8vIDMuIEdldCB0IGZvciB0aGUgY3VydmVcclxuLy8gNC4gUmV0dXJuIGN1cnZlLmdldFBvaW50QXQodCcpXHJcblxyXG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmdldFBvaW50ID0gZnVuY3Rpb24oIHQgKSB7XHJcblxyXG5cdHZhciBkID0gdCAqIHRoaXMuZ2V0TGVuZ3RoKCk7XHJcblx0dmFyIGN1cnZlTGVuZ3RocyA9IHRoaXMuZ2V0Q3VydmVMZW5ndGhzKCk7XHJcblx0dmFyIGkgPSAwO1xyXG5cclxuXHQvLyBUbyB0aGluayBhYm91dCBib3VuZGFyaWVzIHBvaW50cy5cclxuXHJcblx0d2hpbGUgKCBpIDwgY3VydmVMZW5ndGhzLmxlbmd0aCApIHtcclxuXHJcblx0XHRpZiAoIGN1cnZlTGVuZ3Roc1sgaSBdID49IGQgKSB7XHJcblxyXG5cdFx0XHR2YXIgZGlmZiA9IGN1cnZlTGVuZ3Roc1sgaSBdIC0gZDtcclxuXHRcdFx0dmFyIGN1cnZlID0gdGhpcy5jdXJ2ZXNbIGkgXTtcclxuXHJcblx0XHRcdHZhciB1ID0gMSAtIGRpZmYgLyBjdXJ2ZS5nZXRMZW5ndGgoKTtcclxuXHJcblx0XHRcdHJldHVybiBjdXJ2ZS5nZXRQb2ludEF0KCB1ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGkgKys7XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIG51bGw7XHJcblxyXG5cdC8vIGxvb3Agd2hlcmUgc3VtICE9IDAsIHN1bSA+IGQgLCBzdW0rMSA8ZFxyXG5cclxufTtcclxuXHJcbi8qXHJcblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuZ2V0VGFuZ2VudCA9IGZ1bmN0aW9uKCB0ICkge1xyXG59O1xyXG4qL1xyXG5cclxuLy8gV2UgY2Fubm90IHVzZSB0aGUgZGVmYXVsdCBUSFJFRS5DdXJ2ZSBnZXRQb2ludCgpIHdpdGggZ2V0TGVuZ3RoKCkgYmVjYXVzZSBpblxyXG4vLyBUSFJFRS5DdXJ2ZSwgZ2V0TGVuZ3RoKCkgZGVwZW5kcyBvbiBnZXRQb2ludCgpIGJ1dCBpbiBUSFJFRS5DdXJ2ZVBhdGhcclxuLy8gZ2V0UG9pbnQoKSBkZXBlbmRzIG9uIGdldExlbmd0aFxyXG5cclxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5nZXRMZW5ndGggPSBmdW5jdGlvbigpIHtcclxuXHJcblx0dmFyIGxlbnMgPSB0aGlzLmdldEN1cnZlTGVuZ3RocygpO1xyXG5cdHJldHVybiBsZW5zWyBsZW5zLmxlbmd0aCAtIDEgXTtcclxuXHJcbn07XHJcblxyXG4vLyBDb21wdXRlIGxlbmd0aHMgYW5kIGNhY2hlIHRoZW1cclxuLy8gV2UgY2Fubm90IG92ZXJ3cml0ZSBnZXRMZW5ndGhzKCkgYmVjYXVzZSBVdG9UIG1hcHBpbmcgdXNlcyBpdC5cclxuXHJcblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuZ2V0Q3VydmVMZW5ndGhzID0gZnVuY3Rpb24oKSB7XHJcblxyXG5cdC8vIFdlIHVzZSBjYWNoZSB2YWx1ZXMgaWYgY3VydmVzIGFuZCBjYWNoZSBhcnJheSBhcmUgc2FtZSBsZW5ndGhcclxuXHJcblx0aWYgKCB0aGlzLmNhY2hlTGVuZ3RocyAmJiB0aGlzLmNhY2hlTGVuZ3Rocy5sZW5ndGggPT09IHRoaXMuY3VydmVzLmxlbmd0aCApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5jYWNoZUxlbmd0aHM7XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gR2V0IGxlbmd0aCBvZiBzdWItY3VydmVcclxuXHQvLyBQdXNoIHN1bXMgaW50byBjYWNoZWQgYXJyYXlcclxuXHJcblx0dmFyIGxlbmd0aHMgPSBbXSwgc3VtcyA9IDA7XHJcblxyXG5cdGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMuY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0c3VtcyArPSB0aGlzLmN1cnZlc1sgaSBdLmdldExlbmd0aCgpO1xyXG5cdFx0bGVuZ3Rocy5wdXNoKCBzdW1zICk7XHJcblxyXG5cdH1cclxuXHJcblx0dGhpcy5jYWNoZUxlbmd0aHMgPSBsZW5ndGhzO1xyXG5cclxuXHRyZXR1cm4gbGVuZ3RocztcclxuXHJcbn07XHJcblxyXG5cclxuXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gKlx0Q3JlYXRlIEdlb21ldHJpZXMgSGVscGVyc1xyXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG4vLy8gR2VuZXJhdGUgZ2VvbWV0cnkgZnJvbSBwYXRoIHBvaW50cyAoZm9yIExpbmUgb3IgUG9pbnRzIG9iamVjdHMpXHJcblxyXG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmNyZWF0ZVBvaW50c0dlb21ldHJ5ID0gZnVuY3Rpb24oIGRpdmlzaW9ucyApIHtcclxuXHJcblx0dmFyIHB0cyA9IHRoaXMuZ2V0UG9pbnRzKCBkaXZpc2lvbnMgKTtcclxuXHRyZXR1cm4gdGhpcy5jcmVhdGVHZW9tZXRyeSggcHRzICk7XHJcblxyXG59O1xyXG5cclxuLy8gR2VuZXJhdGUgZ2VvbWV0cnkgZnJvbSBlcXVpZGlzdGFudCBzYW1wbGluZyBhbG9uZyB0aGUgcGF0aFxyXG5cclxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5jcmVhdGVTcGFjZWRQb2ludHNHZW9tZXRyeSA9IGZ1bmN0aW9uKCBkaXZpc2lvbnMgKSB7XHJcblxyXG5cdHZhciBwdHMgPSB0aGlzLmdldFNwYWNlZFBvaW50cyggZGl2aXNpb25zICk7XHJcblx0cmV0dXJuIHRoaXMuY3JlYXRlR2VvbWV0cnkoIHB0cyApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuY3JlYXRlR2VvbWV0cnkgPSBmdW5jdGlvbiggcG9pbnRzICkge1xyXG5cclxuXHR2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcclxuXHJcblx0Zm9yICggdmFyIGkgPSAwLCBsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0dmFyIHBvaW50ID0gcG9pbnRzWyBpIF07XHJcblx0XHRnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMyggcG9pbnQueCwgcG9pbnQueSwgcG9pbnQueiB8fCAwICkgKTtcclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gZ2VvbWV0cnk7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2NvcmUvRm9udC5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5Gb250ID0gZnVuY3Rpb24gKCBkYXRhICkge1xyXG5cclxuXHR0aGlzLmRhdGEgPSBkYXRhO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkZvbnQucHJvdG90eXBlID0ge1xyXG5cclxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuRm9udCxcclxuXHJcblx0Z2VuZXJhdGVTaGFwZXM6IGZ1bmN0aW9uICggdGV4dCwgc2l6ZSwgZGl2aXNpb25zICkge1xyXG5cclxuXHRcdGZ1bmN0aW9uIGNyZWF0ZVBhdGhzKCB0ZXh0ICkge1xyXG5cclxuXHRcdFx0dmFyIGNoYXJzID0gU3RyaW5nKCB0ZXh0ICkuc3BsaXQoICcnICk7XHJcblx0XHRcdHZhciBzY2FsZSA9IHNpemUgLyBkYXRhLnJlc29sdXRpb247XHJcblx0XHRcdHZhciBvZmZzZXQgPSAwO1xyXG5cclxuXHRcdFx0dmFyIHBhdGhzID0gW107XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHZhciByZXQgPSBjcmVhdGVQYXRoKCBjaGFyc1sgaSBdLCBzY2FsZSwgb2Zmc2V0ICk7XHJcblx0XHRcdFx0b2Zmc2V0ICs9IHJldC5vZmZzZXQ7XHJcblxyXG5cdFx0XHRcdHBhdGhzLnB1c2goIHJldC5wYXRoICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gcGF0aHM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIGNyZWF0ZVBhdGgoIGMsIHNjYWxlLCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0XHR2YXIgZ2x5cGggPSBkYXRhLmdseXBoc1sgYyBdIHx8IGRhdGEuZ2x5cGhzWyAnPycgXTtcclxuXHJcblx0XHRcdGlmICggISBnbHlwaCApIHJldHVybjtcclxuXHJcblx0XHRcdHZhciBwYXRoID0gbmV3IFRIUkVFLlBhdGgoKTtcclxuXHJcblx0XHRcdHZhciBwdHMgPSBbXSwgYjIgPSBUSFJFRS5TaGFwZVV0aWxzLmIyLCBiMyA9IFRIUkVFLlNoYXBlVXRpbHMuYjM7XHJcblx0XHRcdHZhciB4LCB5LCBjcHgsIGNweSwgY3B4MCwgY3B5MCwgY3B4MSwgY3B5MSwgY3B4MiwgY3B5MiwgbGFzdGU7XHJcblxyXG5cdFx0XHRpZiAoIGdseXBoLm8gKSB7XHJcblxyXG5cdFx0XHRcdHZhciBvdXRsaW5lID0gZ2x5cGguX2NhY2hlZE91dGxpbmUgfHwgKCBnbHlwaC5fY2FjaGVkT3V0bGluZSA9IGdseXBoLm8uc3BsaXQoICcgJyApICk7XHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IG91dGxpbmUubGVuZ3RoOyBpIDwgbDsgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIGFjdGlvbiA9IG91dGxpbmVbIGkgKysgXTtcclxuXHJcblx0XHRcdFx0XHRzd2l0Y2ggKCBhY3Rpb24gKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRjYXNlICdtJzogLy8gbW92ZVRvXHJcblxyXG5cdFx0XHRcdFx0XHRcdHggPSBvdXRsaW5lWyBpICsrIF0gKiBzY2FsZSArIG9mZnNldDtcclxuXHRcdFx0XHRcdFx0XHR5ID0gb3V0bGluZVsgaSArKyBdICogc2NhbGU7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHBhdGgubW92ZVRvKCB4LCB5ICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdFx0Y2FzZSAnbCc6IC8vIGxpbmVUb1xyXG5cclxuXHRcdFx0XHRcdFx0XHR4ID0gb3V0bGluZVsgaSArKyBdICogc2NhbGUgKyBvZmZzZXQ7XHJcblx0XHRcdFx0XHRcdFx0eSA9IG91dGxpbmVbIGkgKysgXSAqIHNjYWxlO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRwYXRoLmxpbmVUbyggeCwgeSApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRcdGNhc2UgJ3EnOiAvLyBxdWFkcmF0aWNDdXJ2ZVRvXHJcblxyXG5cdFx0XHRcdFx0XHRcdGNweCAgPSBvdXRsaW5lWyBpICsrIF0gKiBzY2FsZSArIG9mZnNldDtcclxuXHRcdFx0XHRcdFx0XHRjcHkgID0gb3V0bGluZVsgaSArKyBdICogc2NhbGU7XHJcblx0XHRcdFx0XHRcdFx0Y3B4MSA9IG91dGxpbmVbIGkgKysgXSAqIHNjYWxlICsgb2Zmc2V0O1xyXG5cdFx0XHRcdFx0XHRcdGNweTEgPSBvdXRsaW5lWyBpICsrIF0gKiBzY2FsZTtcclxuXHJcblx0XHRcdFx0XHRcdFx0cGF0aC5xdWFkcmF0aWNDdXJ2ZVRvKCBjcHgxLCBjcHkxLCBjcHgsIGNweSApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRsYXN0ZSA9IHB0c1sgcHRzLmxlbmd0aCAtIDEgXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0aWYgKCBsYXN0ZSApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRjcHgwID0gbGFzdGUueDtcclxuXHRcdFx0XHRcdFx0XHRcdGNweTAgPSBsYXN0ZS55O1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdGZvciAoIHZhciBpMiA9IDE7IGkyIDw9IGRpdmlzaW9uczsgaTIgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgdCA9IGkyIC8gZGl2aXNpb25zO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRiMiggdCwgY3B4MCwgY3B4MSwgY3B4ICk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGIyKCB0LCBjcHkwLCBjcHkxLCBjcHkgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0XHRjYXNlICdiJzogLy8gYmV6aWVyQ3VydmVUb1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjcHggID0gb3V0bGluZVsgaSArKyBdICogc2NhbGUgKyBvZmZzZXQ7XHJcblx0XHRcdFx0XHRcdFx0Y3B5ICA9IG91dGxpbmVbIGkgKysgXSAqIHNjYWxlO1xyXG5cdFx0XHRcdFx0XHRcdGNweDEgPSBvdXRsaW5lWyBpICsrIF0gKiBzY2FsZSArIG9mZnNldDtcclxuXHRcdFx0XHRcdFx0XHRjcHkxID0gb3V0bGluZVsgaSArKyBdICogc2NhbGU7XHJcblx0XHRcdFx0XHRcdFx0Y3B4MiA9IG91dGxpbmVbIGkgKysgXSAqIHNjYWxlICsgb2Zmc2V0O1xyXG5cdFx0XHRcdFx0XHRcdGNweTIgPSBvdXRsaW5lWyBpICsrIF0gKiBzY2FsZTtcclxuXHJcblx0XHRcdFx0XHRcdFx0cGF0aC5iZXppZXJDdXJ2ZVRvKCBjcHgxLCBjcHkxLCBjcHgyLCBjcHkyLCBjcHgsIGNweSApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRsYXN0ZSA9IHB0c1sgcHRzLmxlbmd0aCAtIDEgXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0aWYgKCBsYXN0ZSApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRjcHgwID0gbGFzdGUueDtcclxuXHRcdFx0XHRcdFx0XHRcdGNweTAgPSBsYXN0ZS55O1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdGZvciAoIHZhciBpMiA9IDE7IGkyIDw9IGRpdmlzaW9uczsgaTIgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgdCA9IGkyIC8gZGl2aXNpb25zO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRiMyggdCwgY3B4MCwgY3B4MSwgY3B4MiwgY3B4ICk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGIzKCB0LCBjcHkwLCBjcHkxLCBjcHkyLCBjcHkgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4geyBvZmZzZXQ6IGdseXBoLmhhICogc2NhbGUsIHBhdGg6IHBhdGggfTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHRpZiAoIHNpemUgPT09IHVuZGVmaW5lZCApIHNpemUgPSAxMDA7XHJcblx0XHRpZiAoIGRpdmlzaW9ucyA9PT0gdW5kZWZpbmVkICkgZGl2aXNpb25zID0gNDtcclxuXHJcblx0XHR2YXIgZGF0YSA9IHRoaXMuZGF0YTtcclxuXHJcblx0XHR2YXIgcGF0aHMgPSBjcmVhdGVQYXRocyggdGV4dCApO1xyXG5cdFx0dmFyIHNoYXBlcyA9IFtdO1xyXG5cclxuXHRcdGZvciAoIHZhciBwID0gMCwgcGwgPSBwYXRocy5sZW5ndGg7IHAgPCBwbDsgcCArKyApIHtcclxuXHJcblx0XHRcdEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KCBzaGFwZXMsIHBhdGhzWyBwIF0udG9TaGFwZXMoKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gc2hhcGVzO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2NvcmUvUGF0aC5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcclxuICogQ3JlYXRlcyBmcmVlIGZvcm0gMmQgcGF0aCB1c2luZyBzZXJpZXMgb2YgcG9pbnRzLCBsaW5lcyBvciBjdXJ2ZXMuXHJcbiAqXHJcbiAqKi9cclxuXHJcblRIUkVFLlBhdGggPSBmdW5jdGlvbiAoIHBvaW50cyApIHtcclxuXHJcblx0VEhSRUUuQ3VydmVQYXRoLmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy5hY3Rpb25zID0gW107XHJcblxyXG5cdGlmICggcG9pbnRzICkge1xyXG5cclxuXHRcdHRoaXMuZnJvbVBvaW50cyggcG9pbnRzICk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5QYXRoLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUgKTtcclxuVEhSRUUuUGF0aC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5QYXRoO1xyXG5cclxuLy8gVE9ETyBDbGVhbiB1cCBQQVRIIEFQSVxyXG5cclxuLy8gQ3JlYXRlIHBhdGggdXNpbmcgc3RyYWlnaHQgbGluZXMgdG8gY29ubmVjdCBhbGwgcG9pbnRzXHJcbi8vIC0gdmVjdG9yczogYXJyYXkgb2YgVmVjdG9yMlxyXG5cclxuVEhSRUUuUGF0aC5wcm90b3R5cGUuZnJvbVBvaW50cyA9IGZ1bmN0aW9uICggdmVjdG9ycyApIHtcclxuXHJcblx0dGhpcy5tb3ZlVG8oIHZlY3RvcnNbIDAgXS54LCB2ZWN0b3JzWyAwIF0ueSApO1xyXG5cclxuXHRmb3IgKCB2YXIgaSA9IDEsIGwgPSB2ZWN0b3JzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0dGhpcy5saW5lVG8oIHZlY3RvcnNbIGkgXS54LCB2ZWN0b3JzWyBpIF0ueSApO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuLy8gc3RhcnRQYXRoKCkgZW5kUGF0aCgpP1xyXG5cclxuVEhSRUUuUGF0aC5wcm90b3R5cGUubW92ZVRvID0gZnVuY3Rpb24gKCB4LCB5ICkge1xyXG5cclxuXHR0aGlzLmFjdGlvbnMucHVzaCggeyBhY3Rpb246ICdtb3ZlVG8nLCBhcmdzOiBbIHgsIHkgXSB9ICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUGF0aC5wcm90b3R5cGUubGluZVRvID0gZnVuY3Rpb24gKCB4LCB5ICkge1xyXG5cclxuXHR2YXIgbGFzdGFyZ3MgPSB0aGlzLmFjdGlvbnNbIHRoaXMuYWN0aW9ucy5sZW5ndGggLSAxIF0uYXJncztcclxuXHJcblx0dmFyIHgwID0gbGFzdGFyZ3NbIGxhc3RhcmdzLmxlbmd0aCAtIDIgXTtcclxuXHR2YXIgeTAgPSBsYXN0YXJnc1sgbGFzdGFyZ3MubGVuZ3RoIC0gMSBdO1xyXG5cclxuXHR2YXIgY3VydmUgPSBuZXcgVEhSRUUuTGluZUN1cnZlKCBuZXcgVEhSRUUuVmVjdG9yMiggeDAsIHkwICksIG5ldyBUSFJFRS5WZWN0b3IyKCB4LCB5ICkgKTtcclxuXHR0aGlzLmN1cnZlcy5wdXNoKCBjdXJ2ZSApO1xyXG5cclxuXHR0aGlzLmFjdGlvbnMucHVzaCggeyBhY3Rpb246ICdsaW5lVG8nLCBhcmdzOiBbIHgsIHkgXSB9ICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUGF0aC5wcm90b3R5cGUucXVhZHJhdGljQ3VydmVUbyA9IGZ1bmN0aW9uKCBhQ1B4LCBhQ1B5LCBhWCwgYVkgKSB7XHJcblxyXG5cdHZhciBsYXN0YXJncyA9IHRoaXMuYWN0aW9uc1sgdGhpcy5hY3Rpb25zLmxlbmd0aCAtIDEgXS5hcmdzO1xyXG5cclxuXHR2YXIgeDAgPSBsYXN0YXJnc1sgbGFzdGFyZ3MubGVuZ3RoIC0gMiBdO1xyXG5cdHZhciB5MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAxIF07XHJcblxyXG5cdHZhciBjdXJ2ZSA9IG5ldyBUSFJFRS5RdWFkcmF0aWNCZXppZXJDdXJ2ZShcclxuXHRcdG5ldyBUSFJFRS5WZWN0b3IyKCB4MCwgeTAgKSxcclxuXHRcdG5ldyBUSFJFRS5WZWN0b3IyKCBhQ1B4LCBhQ1B5ICksXHJcblx0XHRuZXcgVEhSRUUuVmVjdG9yMiggYVgsIGFZIClcclxuXHQpO1xyXG5cclxuXHR0aGlzLmN1cnZlcy5wdXNoKCBjdXJ2ZSApO1xyXG5cclxuXHR0aGlzLmFjdGlvbnMucHVzaCggeyBhY3Rpb246ICdxdWFkcmF0aWNDdXJ2ZVRvJywgYXJnczogWyBhQ1B4LCBhQ1B5LCBhWCwgYVkgXSB9ICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUGF0aC5wcm90b3R5cGUuYmV6aWVyQ3VydmVUbyA9IGZ1bmN0aW9uKCBhQ1AxeCwgYUNQMXksIGFDUDJ4LCBhQ1AyeSwgYVgsIGFZICkge1xyXG5cclxuXHR2YXIgbGFzdGFyZ3MgPSB0aGlzLmFjdGlvbnNbIHRoaXMuYWN0aW9ucy5sZW5ndGggLSAxIF0uYXJncztcclxuXHJcblx0dmFyIHgwID0gbGFzdGFyZ3NbIGxhc3RhcmdzLmxlbmd0aCAtIDIgXTtcclxuXHR2YXIgeTAgPSBsYXN0YXJnc1sgbGFzdGFyZ3MubGVuZ3RoIC0gMSBdO1xyXG5cclxuXHR2YXIgY3VydmUgPSBuZXcgVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZShcclxuXHRcdG5ldyBUSFJFRS5WZWN0b3IyKCB4MCwgeTAgKSxcclxuXHRcdG5ldyBUSFJFRS5WZWN0b3IyKCBhQ1AxeCwgYUNQMXkgKSxcclxuXHRcdG5ldyBUSFJFRS5WZWN0b3IyKCBhQ1AyeCwgYUNQMnkgKSxcclxuXHRcdG5ldyBUSFJFRS5WZWN0b3IyKCBhWCwgYVkgKVxyXG5cdCk7XHJcblxyXG5cdHRoaXMuY3VydmVzLnB1c2goIGN1cnZlICk7XHJcblxyXG5cdHRoaXMuYWN0aW9ucy5wdXNoKCB7IGFjdGlvbjogJ2JlemllckN1cnZlVG8nLCBhcmdzOiBbIGFDUDF4LCBhQ1AxeSwgYUNQMngsIGFDUDJ5LCBhWCwgYVkgXSB9ICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUGF0aC5wcm90b3R5cGUuc3BsaW5lVGhydSA9IGZ1bmN0aW9uKCBwdHMgLypBcnJheSBvZiBWZWN0b3IqLyApIHtcclxuXHJcblx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggYXJndW1lbnRzICk7XHJcblxyXG5cdHZhciBsYXN0YXJncyA9IHRoaXMuYWN0aW9uc1sgdGhpcy5hY3Rpb25zLmxlbmd0aCAtIDEgXS5hcmdzO1xyXG5cclxuXHR2YXIgeDAgPSBsYXN0YXJnc1sgbGFzdGFyZ3MubGVuZ3RoIC0gMiBdO1xyXG5cdHZhciB5MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAxIF07XHJcblxyXG5cdHZhciBucHRzID0gWyBuZXcgVEhSRUUuVmVjdG9yMiggeDAsIHkwICkgXTtcclxuXHRBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseSggbnB0cywgcHRzICk7XHJcblxyXG5cdHZhciBjdXJ2ZSA9IG5ldyBUSFJFRS5TcGxpbmVDdXJ2ZSggbnB0cyApO1xyXG5cdHRoaXMuY3VydmVzLnB1c2goIGN1cnZlICk7XHJcblxyXG5cdHRoaXMuYWN0aW9ucy5wdXNoKCB7IGFjdGlvbjogJ3NwbGluZVRocnUnLCBhcmdzOiBhcmdzIH0gKTtcclxuXHJcbn07XHJcblxyXG4vLyBGVVRVUkU6IENoYW5nZSB0aGUgQVBJIG9yIGZvbGxvdyBjYW52YXMgQVBJP1xyXG5cclxuVEhSRUUuUGF0aC5wcm90b3R5cGUuYXJjID0gZnVuY3Rpb24gKCBhWCwgYVksIGFSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKSB7XHJcblxyXG5cdHZhciBsYXN0YXJncyA9IHRoaXMuYWN0aW9uc1sgdGhpcy5hY3Rpb25zLmxlbmd0aCAtIDEgXS5hcmdzO1xyXG5cdHZhciB4MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAyIF07XHJcblx0dmFyIHkwID0gbGFzdGFyZ3NbIGxhc3RhcmdzLmxlbmd0aCAtIDEgXTtcclxuXHJcblx0dGhpcy5hYnNhcmMoIGFYICsgeDAsIGFZICsgeTAsIGFSYWRpdXMsXHJcblx0XHRhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlICk7XHJcblxyXG4gfTtcclxuXHJcbiBUSFJFRS5QYXRoLnByb3RvdHlwZS5hYnNhcmMgPSBmdW5jdGlvbiAoIGFYLCBhWSwgYVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApIHtcclxuXHJcblx0dGhpcy5hYnNlbGxpcHNlKCBhWCwgYVksIGFSYWRpdXMsIGFSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKTtcclxuXHJcbiB9O1xyXG5cclxuVEhSRUUuUGF0aC5wcm90b3R5cGUuZWxsaXBzZSA9IGZ1bmN0aW9uICggYVgsIGFZLCB4UmFkaXVzLCB5UmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlLCBhUm90YXRpb24gKSB7XHJcblxyXG5cdHZhciBsYXN0YXJncyA9IHRoaXMuYWN0aW9uc1sgdGhpcy5hY3Rpb25zLmxlbmd0aCAtIDEgXS5hcmdzO1xyXG5cdHZhciB4MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAyIF07XHJcblx0dmFyIHkwID0gbGFzdGFyZ3NbIGxhc3RhcmdzLmxlbmd0aCAtIDEgXTtcclxuXHJcblx0dGhpcy5hYnNlbGxpcHNlKCBhWCArIHgwLCBhWSArIHkwLCB4UmFkaXVzLCB5UmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlLCBhUm90YXRpb24gKTtcclxuXHJcbiB9O1xyXG5cclxuXHJcblRIUkVFLlBhdGgucHJvdG90eXBlLmFic2VsbGlwc2UgPSBmdW5jdGlvbiAoIGFYLCBhWSwgeFJhZGl1cywgeVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSwgYVJvdGF0aW9uICkge1xyXG5cclxuXHR2YXIgYXJncyA9IFtcclxuXHRcdGFYLCBhWSxcclxuXHRcdHhSYWRpdXMsIHlSYWRpdXMsXHJcblx0XHRhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLFxyXG5cdFx0YUNsb2Nrd2lzZSxcclxuXHRcdGFSb3RhdGlvbiB8fCAwIC8vIGFSb3RhdGlvbiBpcyBvcHRpb25hbC5cclxuXHRdO1xyXG5cclxuXHR2YXIgY3VydmUgPSBuZXcgVEhSRUUuRWxsaXBzZUN1cnZlKCBhWCwgYVksIHhSYWRpdXMsIHlSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UsIGFSb3RhdGlvbiApO1xyXG5cdHRoaXMuY3VydmVzLnB1c2goIGN1cnZlICk7XHJcblxyXG5cdHZhciBsYXN0UG9pbnQgPSBjdXJ2ZS5nZXRQb2ludCggMSApO1xyXG5cdGFyZ3MucHVzaCggbGFzdFBvaW50LnggKTtcclxuXHRhcmdzLnB1c2goIGxhc3RQb2ludC55ICk7XHJcblxyXG5cdHRoaXMuYWN0aW9ucy5wdXNoKCB7IGFjdGlvbjogJ2VsbGlwc2UnLCBhcmdzOiBhcmdzIH0gKTtcclxuXHJcbiB9O1xyXG5cclxuVEhSRUUuUGF0aC5wcm90b3R5cGUuZ2V0U3BhY2VkUG9pbnRzID0gZnVuY3Rpb24gKCBkaXZpc2lvbnMgKSB7XHJcblxyXG5cdGlmICggISBkaXZpc2lvbnMgKSBkaXZpc2lvbnMgPSA0MDtcclxuXHJcblx0dmFyIHBvaW50cyA9IFtdO1xyXG5cclxuXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBkaXZpc2lvbnM7IGkgKysgKSB7XHJcblxyXG5cdFx0cG9pbnRzLnB1c2goIHRoaXMuZ2V0UG9pbnQoIGkgLyBkaXZpc2lvbnMgKSApO1xyXG5cclxuXHRcdC8vaWYgKCAhdGhpcy5nZXRQb2ludCggaSAvIGRpdmlzaW9ucyApICkgdGhyb3cgXCJESUVcIjtcclxuXHJcblx0fVxyXG5cclxuXHRpZiAoIHRoaXMuYXV0b0Nsb3NlICkge1xyXG5cclxuXHRcdHBvaW50cy5wdXNoKCBwb2ludHNbIDAgXSApO1xyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiBwb2ludHM7XHJcblxyXG59O1xyXG5cclxuLyogUmV0dXJuIGFuIGFycmF5IG9mIHZlY3RvcnMgYmFzZWQgb24gY29udG91ciBvZiB0aGUgcGF0aCAqL1xyXG5cclxuVEhSRUUuUGF0aC5wcm90b3R5cGUuZ2V0UG9pbnRzID0gZnVuY3Rpb24oIGRpdmlzaW9ucyApIHtcclxuXHJcblx0ZGl2aXNpb25zID0gZGl2aXNpb25zIHx8IDEyO1xyXG5cclxuXHR2YXIgYjIgPSBUSFJFRS5TaGFwZVV0aWxzLmIyO1xyXG5cdHZhciBiMyA9IFRIUkVFLlNoYXBlVXRpbHMuYjM7XHJcblxyXG5cdHZhciBwb2ludHMgPSBbXTtcclxuXHJcblx0dmFyIGNweCwgY3B5LCBjcHgyLCBjcHkyLCBjcHgxLCBjcHkxLCBjcHgwLCBjcHkwLFxyXG5cdFx0bGFzdGUsIHR4LCB0eTtcclxuXHJcblx0Zm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy5hY3Rpb25zLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0dmFyIGl0ZW0gPSB0aGlzLmFjdGlvbnNbIGkgXTtcclxuXHJcblx0XHR2YXIgYWN0aW9uID0gaXRlbS5hY3Rpb247XHJcblx0XHR2YXIgYXJncyA9IGl0ZW0uYXJncztcclxuXHJcblx0XHRzd2l0Y2ggKCBhY3Rpb24gKSB7XHJcblxyXG5cdFx0Y2FzZSAnbW92ZVRvJzpcclxuXHJcblx0XHRcdHBvaW50cy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMiggYXJnc1sgMCBdLCBhcmdzWyAxIF0gKSApO1xyXG5cclxuXHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0Y2FzZSAnbGluZVRvJzpcclxuXHJcblx0XHRcdHBvaW50cy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMiggYXJnc1sgMCBdLCBhcmdzWyAxIF0gKSApO1xyXG5cclxuXHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0Y2FzZSAncXVhZHJhdGljQ3VydmVUbyc6XHJcblxyXG5cdFx0XHRjcHggID0gYXJnc1sgMiBdO1xyXG5cdFx0XHRjcHkgID0gYXJnc1sgMyBdO1xyXG5cclxuXHRcdFx0Y3B4MSA9IGFyZ3NbIDAgXTtcclxuXHRcdFx0Y3B5MSA9IGFyZ3NbIDEgXTtcclxuXHJcblx0XHRcdGlmICggcG9pbnRzLmxlbmd0aCA+IDAgKSB7XHJcblxyXG5cdFx0XHRcdGxhc3RlID0gcG9pbnRzWyBwb2ludHMubGVuZ3RoIC0gMSBdO1xyXG5cclxuXHRcdFx0XHRjcHgwID0gbGFzdGUueDtcclxuXHRcdFx0XHRjcHkwID0gbGFzdGUueTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGxhc3RlID0gdGhpcy5hY3Rpb25zWyBpIC0gMSBdLmFyZ3M7XHJcblxyXG5cdFx0XHRcdGNweDAgPSBsYXN0ZVsgbGFzdGUubGVuZ3RoIC0gMiBdO1xyXG5cdFx0XHRcdGNweTAgPSBsYXN0ZVsgbGFzdGUubGVuZ3RoIC0gMSBdO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Zm9yICggdmFyIGogPSAxOyBqIDw9IGRpdmlzaW9uczsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0dmFyIHQgPSBqIC8gZGl2aXNpb25zO1xyXG5cclxuXHRcdFx0XHR0eCA9IGIyKCB0LCBjcHgwLCBjcHgxLCBjcHggKTtcclxuXHRcdFx0XHR0eSA9IGIyKCB0LCBjcHkwLCBjcHkxLCBjcHkgKTtcclxuXHJcblx0XHRcdFx0cG9pbnRzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCB0eCwgdHkgKSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0Y2FzZSAnYmV6aWVyQ3VydmVUbyc6XHJcblxyXG5cdFx0XHRjcHggID0gYXJnc1sgNCBdO1xyXG5cdFx0XHRjcHkgID0gYXJnc1sgNSBdO1xyXG5cclxuXHRcdFx0Y3B4MSA9IGFyZ3NbIDAgXTtcclxuXHRcdFx0Y3B5MSA9IGFyZ3NbIDEgXTtcclxuXHJcblx0XHRcdGNweDIgPSBhcmdzWyAyIF07XHJcblx0XHRcdGNweTIgPSBhcmdzWyAzIF07XHJcblxyXG5cdFx0XHRpZiAoIHBvaW50cy5sZW5ndGggPiAwICkge1xyXG5cclxuXHRcdFx0XHRsYXN0ZSA9IHBvaW50c1sgcG9pbnRzLmxlbmd0aCAtIDEgXTtcclxuXHJcblx0XHRcdFx0Y3B4MCA9IGxhc3RlLng7XHJcblx0XHRcdFx0Y3B5MCA9IGxhc3RlLnk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRsYXN0ZSA9IHRoaXMuYWN0aW9uc1sgaSAtIDEgXS5hcmdzO1xyXG5cclxuXHRcdFx0XHRjcHgwID0gbGFzdGVbIGxhc3RlLmxlbmd0aCAtIDIgXTtcclxuXHRcdFx0XHRjcHkwID0gbGFzdGVbIGxhc3RlLmxlbmd0aCAtIDEgXTtcclxuXHJcblx0XHRcdH1cclxuXHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaiA9IDE7IGogPD0gZGl2aXNpb25zOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgdCA9IGogLyBkaXZpc2lvbnM7XHJcblxyXG5cdFx0XHRcdHR4ID0gYjMoIHQsIGNweDAsIGNweDEsIGNweDIsIGNweCApO1xyXG5cdFx0XHRcdHR5ID0gYjMoIHQsIGNweTAsIGNweTEsIGNweTIsIGNweSApO1xyXG5cclxuXHRcdFx0XHRwb2ludHMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoIHR4LCB0eSApICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRicmVhaztcclxuXHJcblx0XHRjYXNlICdzcGxpbmVUaHJ1JzpcclxuXHJcblx0XHRcdGxhc3RlID0gdGhpcy5hY3Rpb25zWyBpIC0gMSBdLmFyZ3M7XHJcblxyXG5cdFx0XHR2YXIgbGFzdCA9IG5ldyBUSFJFRS5WZWN0b3IyKCBsYXN0ZVsgbGFzdGUubGVuZ3RoIC0gMiBdLCBsYXN0ZVsgbGFzdGUubGVuZ3RoIC0gMSBdICk7XHJcblx0XHRcdHZhciBzcHRzID0gWyBsYXN0IF07XHJcblxyXG5cdFx0XHR2YXIgbiA9IGRpdmlzaW9ucyAqIGFyZ3NbIDAgXS5sZW5ndGg7XHJcblxyXG5cdFx0XHRzcHRzID0gc3B0cy5jb25jYXQoIGFyZ3NbIDAgXSApO1xyXG5cclxuXHRcdFx0dmFyIHNwbGluZSA9IG5ldyBUSFJFRS5TcGxpbmVDdXJ2ZSggc3B0cyApO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGogPSAxOyBqIDw9IG47IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdHBvaW50cy5wdXNoKCBzcGxpbmUuZ2V0UG9pbnRBdCggaiAvIG4gKSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0Y2FzZSAnYXJjJzpcclxuXHJcblx0XHRcdHZhciBhWCA9IGFyZ3NbIDAgXSwgYVkgPSBhcmdzWyAxIF0sXHJcblx0XHRcdFx0YVJhZGl1cyA9IGFyZ3NbIDIgXSxcclxuXHRcdFx0XHRhU3RhcnRBbmdsZSA9IGFyZ3NbIDMgXSwgYUVuZEFuZ2xlID0gYXJnc1sgNCBdLFxyXG5cdFx0XHRcdGFDbG9ja3dpc2UgPSAhISBhcmdzWyA1IF07XHJcblxyXG5cdFx0XHR2YXIgZGVsdGFBbmdsZSA9IGFFbmRBbmdsZSAtIGFTdGFydEFuZ2xlO1xyXG5cdFx0XHR2YXIgYW5nbGU7XHJcblx0XHRcdHZhciB0ZGl2aXNpb25zID0gZGl2aXNpb25zICogMjtcclxuXHJcblx0XHRcdGZvciAoIHZhciBqID0gMTsgaiA8PSB0ZGl2aXNpb25zOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgdCA9IGogLyB0ZGl2aXNpb25zO1xyXG5cclxuXHRcdFx0XHRpZiAoICEgYUNsb2Nrd2lzZSApIHtcclxuXHJcblx0XHRcdFx0XHR0ID0gMSAtIHQ7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0YW5nbGUgPSBhU3RhcnRBbmdsZSArIHQgKiBkZWx0YUFuZ2xlO1xyXG5cclxuXHRcdFx0XHR0eCA9IGFYICsgYVJhZGl1cyAqIE1hdGguY29zKCBhbmdsZSApO1xyXG5cdFx0XHRcdHR5ID0gYVkgKyBhUmFkaXVzICogTWF0aC5zaW4oIGFuZ2xlICk7XHJcblxyXG5cdFx0XHRcdC8vY29uc29sZS5sb2coJ3QnLCB0LCAnYW5nbGUnLCBhbmdsZSwgJ3R4JywgdHgsICd0eScsIHR5KTtcclxuXHJcblx0XHRcdFx0cG9pbnRzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCB0eCwgdHkgKSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly9jb25zb2xlLmxvZyhwb2ludHMpO1xyXG5cclxuXHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0Y2FzZSAnZWxsaXBzZSc6XHJcblxyXG5cdFx0XHR2YXIgYVggPSBhcmdzWyAwIF0sIGFZID0gYXJnc1sgMSBdLFxyXG5cdFx0XHRcdHhSYWRpdXMgPSBhcmdzWyAyIF0sXHJcblx0XHRcdFx0eVJhZGl1cyA9IGFyZ3NbIDMgXSxcclxuXHRcdFx0XHRhU3RhcnRBbmdsZSA9IGFyZ3NbIDQgXSwgYUVuZEFuZ2xlID0gYXJnc1sgNSBdLFxyXG5cdFx0XHRcdGFDbG9ja3dpc2UgPSAhISBhcmdzWyA2IF0sXHJcblx0XHRcdFx0YVJvdGF0aW9uID0gYXJnc1sgNyBdO1xyXG5cclxuXHJcblx0XHRcdHZhciBkZWx0YUFuZ2xlID0gYUVuZEFuZ2xlIC0gYVN0YXJ0QW5nbGU7XHJcblx0XHRcdHZhciBhbmdsZTtcclxuXHRcdFx0dmFyIHRkaXZpc2lvbnMgPSBkaXZpc2lvbnMgKiAyO1xyXG5cclxuXHRcdFx0dmFyIGNvcywgc2luO1xyXG5cdFx0XHRpZiAoIGFSb3RhdGlvbiAhPT0gMCApIHtcclxuXHJcblx0XHRcdFx0Y29zID0gTWF0aC5jb3MoIGFSb3RhdGlvbiApO1xyXG5cdFx0XHRcdHNpbiA9IE1hdGguc2luKCBhUm90YXRpb24gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZvciAoIHZhciBqID0gMTsgaiA8PSB0ZGl2aXNpb25zOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgdCA9IGogLyB0ZGl2aXNpb25zO1xyXG5cclxuXHRcdFx0XHRpZiAoICEgYUNsb2Nrd2lzZSApIHtcclxuXHJcblx0XHRcdFx0XHR0ID0gMSAtIHQ7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0YW5nbGUgPSBhU3RhcnRBbmdsZSArIHQgKiBkZWx0YUFuZ2xlO1xyXG5cclxuXHRcdFx0XHR0eCA9IGFYICsgeFJhZGl1cyAqIE1hdGguY29zKCBhbmdsZSApO1xyXG5cdFx0XHRcdHR5ID0gYVkgKyB5UmFkaXVzICogTWF0aC5zaW4oIGFuZ2xlICk7XHJcblxyXG5cdFx0XHRcdGlmICggYVJvdGF0aW9uICE9PSAwICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciB4ID0gdHgsIHkgPSB0eTtcclxuXHJcblx0XHRcdFx0XHQvLyBSb3RhdGUgdGhlIHBvaW50IGFib3V0IHRoZSBjZW50ZXIgb2YgdGhlIGVsbGlwc2UuXHJcblx0XHRcdFx0XHR0eCA9ICggeCAtIGFYICkgKiBjb3MgLSAoIHkgLSBhWSApICogc2luICsgYVg7XHJcblx0XHRcdFx0XHR0eSA9ICggeCAtIGFYICkgKiBzaW4gKyAoIHkgLSBhWSApICogY29zICsgYVk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly9jb25zb2xlLmxvZygndCcsIHQsICdhbmdsZScsIGFuZ2xlLCAndHgnLCB0eCwgJ3R5JywgdHkpO1xyXG5cclxuXHRcdFx0XHRwb2ludHMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoIHR4LCB0eSApICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvL2NvbnNvbGUubG9nKHBvaW50cyk7XHJcblxyXG5cdFx0XHRicmVhaztcclxuXHJcblx0XHR9IC8vIGVuZCBzd2l0Y2hcclxuXHJcblx0fVxyXG5cclxuXHJcblxyXG5cdC8vIE5vcm1hbGl6ZSB0byByZW1vdmUgdGhlIGNsb3NpbmcgcG9pbnQgYnkgZGVmYXVsdC5cclxuXHR2YXIgbGFzdFBvaW50ID0gcG9pbnRzWyBwb2ludHMubGVuZ3RoIC0gMSBdO1xyXG5cdGlmICggTWF0aC5hYnMoIGxhc3RQb2ludC54IC0gcG9pbnRzWyAwIF0ueCApIDwgTnVtYmVyLkVQU0lMT04gJiZcclxuXHRcdFx0IE1hdGguYWJzKCBsYXN0UG9pbnQueSAtIHBvaW50c1sgMCBdLnkgKSA8IE51bWJlci5FUFNJTE9OIClcclxuXHRcdHBvaW50cy5zcGxpY2UoIHBvaW50cy5sZW5ndGggLSAxLCAxICk7XHJcblxyXG5cdGlmICggdGhpcy5hdXRvQ2xvc2UgKSB7XHJcblxyXG5cdFx0cG9pbnRzLnB1c2goIHBvaW50c1sgMCBdICk7XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIHBvaW50cztcclxuXHJcbn07XHJcblxyXG4vL1xyXG4vLyBCcmVha3MgcGF0aCBpbnRvIHNoYXBlc1xyXG4vL1xyXG4vL1x0QXNzdW1wdGlvbnMgKGlmIHBhcmFtZXRlciBpc0NDVz09dHJ1ZSB0aGUgb3Bwb3NpdGUgaG9sZHMpOlxyXG4vL1x0LSBzb2xpZCBzaGFwZXMgYXJlIGRlZmluZWQgY2xvY2t3aXNlIChDVylcclxuLy9cdC0gaG9sZXMgYXJlIGRlZmluZWQgY291bnRlcmNsb2Nrd2lzZSAoQ0NXKVxyXG4vL1xyXG4vL1x0SWYgcGFyYW1ldGVyIG5vSG9sZXM9PXRydWU6XHJcbi8vICAtIGFsbCBzdWJQYXRocyBhcmUgcmVnYXJkZWQgYXMgc29saWQgc2hhcGVzXHJcbi8vICAtIGRlZmluaXRpb24gb3JkZXIgQ1cvQ0NXIGhhcyBubyByZWxldmFuY2VcclxuLy9cclxuXHJcblRIUkVFLlBhdGgucHJvdG90eXBlLnRvU2hhcGVzID0gZnVuY3Rpb24oIGlzQ0NXLCBub0hvbGVzICkge1xyXG5cclxuXHRmdW5jdGlvbiBleHRyYWN0U3VicGF0aHMoIGluQWN0aW9ucyApIHtcclxuXHJcblx0XHR2YXIgc3ViUGF0aHMgPSBbXSwgbGFzdFBhdGggPSBuZXcgVEhSRUUuUGF0aCgpO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGluQWN0aW9ucy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIGl0ZW0gPSBpbkFjdGlvbnNbIGkgXTtcclxuXHJcblx0XHRcdHZhciBhcmdzID0gaXRlbS5hcmdzO1xyXG5cdFx0XHR2YXIgYWN0aW9uID0gaXRlbS5hY3Rpb247XHJcblxyXG5cdFx0XHRpZiAoIGFjdGlvbiA9PT0gJ21vdmVUbycgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggbGFzdFBhdGguYWN0aW9ucy5sZW5ndGggIT09IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0c3ViUGF0aHMucHVzaCggbGFzdFBhdGggKTtcclxuXHRcdFx0XHRcdGxhc3RQYXRoID0gbmV3IFRIUkVFLlBhdGgoKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bGFzdFBhdGhbIGFjdGlvbiBdLmFwcGx5KCBsYXN0UGF0aCwgYXJncyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGxhc3RQYXRoLmFjdGlvbnMubGVuZ3RoICE9PSAwICkge1xyXG5cclxuXHRcdFx0c3ViUGF0aHMucHVzaCggbGFzdFBhdGggKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gY29uc29sZS5sb2coc3ViUGF0aHMpO1xyXG5cclxuXHRcdHJldHVyblx0c3ViUGF0aHM7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gdG9TaGFwZXNOb0hvbGVzKCBpblN1YnBhdGhzICkge1xyXG5cclxuXHRcdHZhciBzaGFwZXMgPSBbXTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBpblN1YnBhdGhzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgdG1wUGF0aCA9IGluU3VicGF0aHNbIGkgXTtcclxuXHJcblx0XHRcdHZhciB0bXBTaGFwZSA9IG5ldyBUSFJFRS5TaGFwZSgpO1xyXG5cdFx0XHR0bXBTaGFwZS5hY3Rpb25zID0gdG1wUGF0aC5hY3Rpb25zO1xyXG5cdFx0XHR0bXBTaGFwZS5jdXJ2ZXMgPSB0bXBQYXRoLmN1cnZlcztcclxuXHJcblx0XHRcdHNoYXBlcy5wdXNoKCB0bXBTaGFwZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvL2NvbnNvbGUubG9nKFwic2hhcGVcIiwgc2hhcGVzKTtcclxuXHJcblx0XHRyZXR1cm4gc2hhcGVzO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGlzUG9pbnRJbnNpZGVQb2x5Z29uKCBpblB0LCBpblBvbHlnb24gKSB7XHJcblxyXG5cdFx0dmFyIHBvbHlMZW4gPSBpblBvbHlnb24ubGVuZ3RoO1xyXG5cclxuXHRcdC8vIGluUHQgb24gcG9seWdvbiBjb250b3VyID0+IGltbWVkaWF0ZSBzdWNjZXNzICAgIG9yXHJcblx0XHQvLyB0b2dnbGluZyBvZiBpbnNpZGUvb3V0c2lkZSBhdCBldmVyeSBzaW5nbGUhIGludGVyc2VjdGlvbiBwb2ludCBvZiBhbiBlZGdlXHJcblx0XHQvLyAgd2l0aCB0aGUgaG9yaXpvbnRhbCBsaW5lIHRocm91Z2ggaW5QdCwgbGVmdCBvZiBpblB0XHJcblx0XHQvLyAgbm90IGNvdW50aW5nIGxvd2VyWSBlbmRwb2ludHMgb2YgZWRnZXMgYW5kIHdob2xlIGVkZ2VzIG9uIHRoYXQgbGluZVxyXG5cdFx0dmFyIGluc2lkZSA9IGZhbHNlO1xyXG5cdFx0Zm9yICggdmFyIHAgPSBwb2x5TGVuIC0gMSwgcSA9IDA7IHEgPCBwb2x5TGVuOyBwID0gcSArKyApIHtcclxuXHJcblx0XHRcdHZhciBlZGdlTG93UHQgID0gaW5Qb2x5Z29uWyBwIF07XHJcblx0XHRcdHZhciBlZGdlSGlnaFB0ID0gaW5Qb2x5Z29uWyBxIF07XHJcblxyXG5cdFx0XHR2YXIgZWRnZUR4ID0gZWRnZUhpZ2hQdC54IC0gZWRnZUxvd1B0Lng7XHJcblx0XHRcdHZhciBlZGdlRHkgPSBlZGdlSGlnaFB0LnkgLSBlZGdlTG93UHQueTtcclxuXHJcblx0XHRcdGlmICggTWF0aC5hYnMoIGVkZ2VEeSApID4gTnVtYmVyLkVQU0lMT04gKSB7XHJcblxyXG5cdFx0XHRcdC8vIG5vdCBwYXJhbGxlbFxyXG5cdFx0XHRcdGlmICggZWRnZUR5IDwgMCApIHtcclxuXHJcblx0XHRcdFx0XHRlZGdlTG93UHQgID0gaW5Qb2x5Z29uWyBxIF07IGVkZ2VEeCA9IC0gZWRnZUR4O1xyXG5cdFx0XHRcdFx0ZWRnZUhpZ2hQdCA9IGluUG9seWdvblsgcCBdOyBlZGdlRHkgPSAtIGVkZ2VEeTtcclxuXHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmICggKCBpblB0LnkgPCBlZGdlTG93UHQueSApIHx8ICggaW5QdC55ID4gZWRnZUhpZ2hQdC55ICkgKSBcdFx0Y29udGludWU7XHJcblxyXG5cdFx0XHRcdGlmICggaW5QdC55ID09PSBlZGdlTG93UHQueSApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGluUHQueCA9PT0gZWRnZUxvd1B0LnggKVx0XHRyZXR1cm5cdHRydWU7XHRcdC8vIGluUHQgaXMgb24gY29udG91ciA/XHJcblx0XHRcdFx0XHQvLyBjb250aW51ZTtcdFx0XHRcdC8vIG5vIGludGVyc2VjdGlvbiBvciBlZGdlTG93UHQgPT4gZG9lc24ndCBjb3VudCAhISFcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgcGVycEVkZ2UgPSBlZGdlRHkgKiAoIGluUHQueCAtIGVkZ2VMb3dQdC54ICkgLSBlZGdlRHggKiAoIGluUHQueSAtIGVkZ2VMb3dQdC55ICk7XHJcblx0XHRcdFx0XHRpZiAoIHBlcnBFZGdlID09PSAwIClcdFx0XHRcdHJldHVyblx0dHJ1ZTtcdFx0Ly8gaW5QdCBpcyBvbiBjb250b3VyID9cclxuXHRcdFx0XHRcdGlmICggcGVycEVkZ2UgPCAwICkgXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHRcdGluc2lkZSA9ICEgaW5zaWRlO1x0XHQvLyB0cnVlIGludGVyc2VjdGlvbiBsZWZ0IG9mIGluUHRcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Ly8gcGFyYWxsZWwgb3IgY29sbGluZWFyXHJcblx0XHRcdFx0aWYgKCBpblB0LnkgIT09IGVkZ2VMb3dQdC55ICkgXHRcdGNvbnRpbnVlO1x0XHRcdC8vIHBhcmFsbGVsXHJcblx0XHRcdFx0Ly8gZWRnZSBsaWVzIG9uIHRoZSBzYW1lIGhvcml6b250YWwgbGluZSBhcyBpblB0XHJcblx0XHRcdFx0aWYgKCAoICggZWRnZUhpZ2hQdC54IDw9IGluUHQueCApICYmICggaW5QdC54IDw9IGVkZ2VMb3dQdC54ICkgKSB8fFxyXG5cdFx0XHRcdFx0ICggKCBlZGdlTG93UHQueCA8PSBpblB0LnggKSAmJiAoIGluUHQueCA8PSBlZGdlSGlnaFB0LnggKSApIClcdFx0cmV0dXJuXHR0cnVlO1x0Ly8gaW5QdDogUG9pbnQgb24gY29udG91ciAhXHJcblx0XHRcdFx0Ly8gY29udGludWU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVyblx0aW5zaWRlO1xyXG5cclxuXHR9XHJcblxyXG5cdHZhciBpc0Nsb2NrV2lzZSA9IFRIUkVFLlNoYXBlVXRpbHMuaXNDbG9ja1dpc2U7XHJcblxyXG5cdHZhciBzdWJQYXRocyA9IGV4dHJhY3RTdWJwYXRocyggdGhpcy5hY3Rpb25zICk7XHJcblx0aWYgKCBzdWJQYXRocy5sZW5ndGggPT09IDAgKSByZXR1cm4gW107XHJcblxyXG5cdGlmICggbm9Ib2xlcyA9PT0gdHJ1ZSApXHRyZXR1cm5cdHRvU2hhcGVzTm9Ib2xlcyggc3ViUGF0aHMgKTtcclxuXHJcblxyXG5cdHZhciBzb2xpZCwgdG1wUGF0aCwgdG1wU2hhcGUsIHNoYXBlcyA9IFtdO1xyXG5cclxuXHRpZiAoIHN1YlBhdGhzLmxlbmd0aCA9PT0gMSApIHtcclxuXHJcblx0XHR0bXBQYXRoID0gc3ViUGF0aHNbIDAgXTtcclxuXHRcdHRtcFNoYXBlID0gbmV3IFRIUkVFLlNoYXBlKCk7XHJcblx0XHR0bXBTaGFwZS5hY3Rpb25zID0gdG1wUGF0aC5hY3Rpb25zO1xyXG5cdFx0dG1wU2hhcGUuY3VydmVzID0gdG1wUGF0aC5jdXJ2ZXM7XHJcblx0XHRzaGFwZXMucHVzaCggdG1wU2hhcGUgKTtcclxuXHRcdHJldHVybiBzaGFwZXM7XHJcblxyXG5cdH1cclxuXHJcblx0dmFyIGhvbGVzRmlyc3QgPSAhIGlzQ2xvY2tXaXNlKCBzdWJQYXRoc1sgMCBdLmdldFBvaW50cygpICk7XHJcblx0aG9sZXNGaXJzdCA9IGlzQ0NXID8gISBob2xlc0ZpcnN0IDogaG9sZXNGaXJzdDtcclxuXHJcblx0Ly8gY29uc29sZS5sb2coXCJIb2xlcyBmaXJzdFwiLCBob2xlc0ZpcnN0KTtcclxuXHJcblx0dmFyIGJldHRlclNoYXBlSG9sZXMgPSBbXTtcclxuXHR2YXIgbmV3U2hhcGVzID0gW107XHJcblx0dmFyIG5ld1NoYXBlSG9sZXMgPSBbXTtcclxuXHR2YXIgbWFpbklkeCA9IDA7XHJcblx0dmFyIHRtcFBvaW50cztcclxuXHJcblx0bmV3U2hhcGVzWyBtYWluSWR4IF0gPSB1bmRlZmluZWQ7XHJcblx0bmV3U2hhcGVIb2xlc1sgbWFpbklkeCBdID0gW107XHJcblxyXG5cdGZvciAoIHZhciBpID0gMCwgbCA9IHN1YlBhdGhzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0dG1wUGF0aCA9IHN1YlBhdGhzWyBpIF07XHJcblx0XHR0bXBQb2ludHMgPSB0bXBQYXRoLmdldFBvaW50cygpO1xyXG5cdFx0c29saWQgPSBpc0Nsb2NrV2lzZSggdG1wUG9pbnRzICk7XHJcblx0XHRzb2xpZCA9IGlzQ0NXID8gISBzb2xpZCA6IHNvbGlkO1xyXG5cclxuXHRcdGlmICggc29saWQgKSB7XHJcblxyXG5cdFx0XHRpZiAoICggISBob2xlc0ZpcnN0ICkgJiYgKCBuZXdTaGFwZXNbIG1haW5JZHggXSApIClcdG1haW5JZHggKys7XHJcblxyXG5cdFx0XHRuZXdTaGFwZXNbIG1haW5JZHggXSA9IHsgczogbmV3IFRIUkVFLlNoYXBlKCksIHA6IHRtcFBvaW50cyB9O1xyXG5cdFx0XHRuZXdTaGFwZXNbIG1haW5JZHggXS5zLmFjdGlvbnMgPSB0bXBQYXRoLmFjdGlvbnM7XHJcblx0XHRcdG5ld1NoYXBlc1sgbWFpbklkeCBdLnMuY3VydmVzID0gdG1wUGF0aC5jdXJ2ZXM7XHJcblxyXG5cdFx0XHRpZiAoIGhvbGVzRmlyc3QgKVx0bWFpbklkeCArKztcclxuXHRcdFx0bmV3U2hhcGVIb2xlc1sgbWFpbklkeCBdID0gW107XHJcblxyXG5cdFx0XHQvL2NvbnNvbGUubG9nKCdjdycsIGkpO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRuZXdTaGFwZUhvbGVzWyBtYWluSWR4IF0ucHVzaCggeyBoOiB0bXBQYXRoLCBwOiB0bXBQb2ludHNbIDAgXSB9ICk7XHJcblxyXG5cdFx0XHQvL2NvbnNvbGUubG9nKCdjY3cnLCBpKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gb25seSBIb2xlcz8gLT4gcHJvYmFibHkgYWxsIFNoYXBlcyB3aXRoIHdyb25nIG9yaWVudGF0aW9uXHJcblx0aWYgKCAhIG5ld1NoYXBlc1sgMCBdIClcdHJldHVyblx0dG9TaGFwZXNOb0hvbGVzKCBzdWJQYXRocyApO1xyXG5cclxuXHJcblx0aWYgKCBuZXdTaGFwZXMubGVuZ3RoID4gMSApIHtcclxuXHJcblx0XHR2YXIgYW1iaWd1b3VzID0gZmFsc2U7XHJcblx0XHR2YXIgdG9DaGFuZ2UgPSBbXTtcclxuXHJcblx0XHRmb3IgKCB2YXIgc0lkeCA9IDAsIHNMZW4gPSBuZXdTaGFwZXMubGVuZ3RoOyBzSWR4IDwgc0xlbjsgc0lkeCArKyApIHtcclxuXHJcblx0XHRcdGJldHRlclNoYXBlSG9sZXNbIHNJZHggXSA9IFtdO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKCB2YXIgc0lkeCA9IDAsIHNMZW4gPSBuZXdTaGFwZXMubGVuZ3RoOyBzSWR4IDwgc0xlbjsgc0lkeCArKyApIHtcclxuXHJcblx0XHRcdHZhciBzaG8gPSBuZXdTaGFwZUhvbGVzWyBzSWR4IF07XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaElkeCA9IDA7IGhJZHggPCBzaG8ubGVuZ3RoOyBoSWR4ICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgaG8gPSBzaG9bIGhJZHggXTtcclxuXHRcdFx0XHR2YXIgaG9sZV91bmFzc2lnbmVkID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIHMySWR4ID0gMDsgczJJZHggPCBuZXdTaGFwZXMubGVuZ3RoOyBzMklkeCArKyApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGlzUG9pbnRJbnNpZGVQb2x5Z29uKCBoby5wLCBuZXdTaGFwZXNbIHMySWR4IF0ucCApICkge1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCBzSWR4ICE9PSBzMklkeCApXHR0b0NoYW5nZS5wdXNoKCB7IGZyb21zOiBzSWR4LCB0b3M6IHMySWR4LCBob2xlOiBoSWR4IH0gKTtcclxuXHRcdFx0XHRcdFx0aWYgKCBob2xlX3VuYXNzaWduZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGhvbGVfdW5hc3NpZ25lZCA9IGZhbHNlO1xyXG5cdFx0XHRcdFx0XHRcdGJldHRlclNoYXBlSG9sZXNbIHMySWR4IF0ucHVzaCggaG8gKTtcclxuXHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGFtYmlndW91cyA9IHRydWU7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKCBob2xlX3VuYXNzaWduZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0YmV0dGVyU2hhcGVIb2xlc1sgc0lkeCBdLnB1c2goIGhvICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblx0XHQvLyBjb25zb2xlLmxvZyhcImFtYmlndW91czogXCIsIGFtYmlndW91cyk7XHJcblx0XHRpZiAoIHRvQ2hhbmdlLmxlbmd0aCA+IDAgKSB7XHJcblxyXG5cdFx0XHQvLyBjb25zb2xlLmxvZyhcInRvIGNoYW5nZTogXCIsIHRvQ2hhbmdlKTtcclxuXHRcdFx0aWYgKCAhIGFtYmlndW91cyApXHRuZXdTaGFwZUhvbGVzID0gYmV0dGVyU2hhcGVIb2xlcztcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0dmFyIHRtcEhvbGVzO1xyXG5cclxuXHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gbmV3U2hhcGVzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdHRtcFNoYXBlID0gbmV3U2hhcGVzWyBpIF0ucztcclxuXHRcdHNoYXBlcy5wdXNoKCB0bXBTaGFwZSApO1xyXG5cdFx0dG1wSG9sZXMgPSBuZXdTaGFwZUhvbGVzWyBpIF07XHJcblxyXG5cdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IHRtcEhvbGVzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xyXG5cclxuXHRcdFx0dG1wU2hhcGUuaG9sZXMucHVzaCggdG1wSG9sZXNbIGogXS5oICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdC8vY29uc29sZS5sb2coXCJzaGFwZVwiLCBzaGFwZXMpO1xyXG5cclxuXHRyZXR1cm4gc2hhcGVzO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9jb3JlL1NoYXBlLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xyXG4gKiBEZWZpbmVzIGEgMmQgc2hhcGUgcGxhbmUgdXNpbmcgcGF0aHMuXHJcbiAqKi9cclxuXHJcbi8vIFNURVAgMSBDcmVhdGUgYSBwYXRoLlxyXG4vLyBTVEVQIDIgVHVybiBwYXRoIGludG8gc2hhcGUuXHJcbi8vIFNURVAgMyBFeHRydWRlR2VvbWV0cnkgdGFrZXMgaW4gU2hhcGUvU2hhcGVzXHJcbi8vIFNURVAgM2EgLSBFeHRyYWN0IHBvaW50cyBmcm9tIGVhY2ggc2hhcGUsIHR1cm4gdG8gdmVydGljZXNcclxuLy8gU1RFUCAzYiAtIFRyaWFuZ3VsYXRlIGVhY2ggc2hhcGUsIGFkZCBmYWNlcy5cclxuXHJcblRIUkVFLlNoYXBlID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRUSFJFRS5QYXRoLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcclxuXHJcblx0dGhpcy5ob2xlcyA9IFtdO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlNoYXBlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLlBhdGgucHJvdG90eXBlICk7XHJcblRIUkVFLlNoYXBlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlNoYXBlO1xyXG5cclxuLy8gQ29udmVuaWVuY2UgbWV0aG9kIHRvIHJldHVybiBFeHRydWRlR2VvbWV0cnlcclxuXHJcblRIUkVFLlNoYXBlLnByb3RvdHlwZS5leHRydWRlID0gZnVuY3Rpb24gKCBvcHRpb25zICkge1xyXG5cclxuXHRyZXR1cm4gbmV3IFRIUkVFLkV4dHJ1ZGVHZW9tZXRyeSggdGhpcywgb3B0aW9ucyApO1xyXG5cclxufTtcclxuXHJcbi8vIENvbnZlbmllbmNlIG1ldGhvZCB0byByZXR1cm4gU2hhcGVHZW9tZXRyeVxyXG5cclxuVEhSRUUuU2hhcGUucHJvdG90eXBlLm1ha2VHZW9tZXRyeSA9IGZ1bmN0aW9uICggb3B0aW9ucyApIHtcclxuXHJcblx0cmV0dXJuIG5ldyBUSFJFRS5TaGFwZUdlb21ldHJ5KCB0aGlzLCBvcHRpb25zICk7XHJcblxyXG59O1xyXG5cclxuLy8gR2V0IHBvaW50cyBvZiBob2xlc1xyXG5cclxuVEhSRUUuU2hhcGUucHJvdG90eXBlLmdldFBvaW50c0hvbGVzID0gZnVuY3Rpb24gKCBkaXZpc2lvbnMgKSB7XHJcblxyXG5cdHZhciBob2xlc1B0cyA9IFtdO1xyXG5cclxuXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLmhvbGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0aG9sZXNQdHNbIGkgXSA9IHRoaXMuaG9sZXNbIGkgXS5nZXRQb2ludHMoIGRpdmlzaW9ucyApO1xyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiBob2xlc1B0cztcclxuXHJcbn07XHJcblxyXG5cclxuLy8gR2V0IHBvaW50cyBvZiBzaGFwZSBhbmQgaG9sZXMgKGtleXBvaW50cyBiYXNlZCBvbiBzZWdtZW50cyBwYXJhbWV0ZXIpXHJcblxyXG5USFJFRS5TaGFwZS5wcm90b3R5cGUuZXh0cmFjdEFsbFBvaW50cyA9IGZ1bmN0aW9uICggZGl2aXNpb25zICkge1xyXG5cclxuXHRyZXR1cm4ge1xyXG5cclxuXHRcdHNoYXBlOiB0aGlzLmdldFBvaW50cyggZGl2aXNpb25zICksXHJcblx0XHRob2xlczogdGhpcy5nZXRQb2ludHNIb2xlcyggZGl2aXNpb25zIClcclxuXHJcblx0fTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5TaGFwZS5wcm90b3R5cGUuZXh0cmFjdFBvaW50cyA9IGZ1bmN0aW9uICggZGl2aXNpb25zICkge1xyXG5cclxuXHRyZXR1cm4gdGhpcy5leHRyYWN0QWxsUG9pbnRzKCBkaXZpc2lvbnMgKTtcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvY3VydmVzL0xpbmVDdXJ2ZS5qc1xyXG5cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAqXHRMaW5lXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcblRIUkVFLkxpbmVDdXJ2ZSA9IGZ1bmN0aW9uICggdjEsIHYyICkge1xyXG5cclxuXHR0aGlzLnYxID0gdjE7XHJcblx0dGhpcy52MiA9IHYyO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkxpbmVDdXJ2ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5DdXJ2ZS5wcm90b3R5cGUgKTtcclxuVEhSRUUuTGluZUN1cnZlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkxpbmVDdXJ2ZTtcclxuXHJcblRIUkVFLkxpbmVDdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiAoIHQgKSB7XHJcblxyXG5cdHZhciBwb2ludCA9IHRoaXMudjIuY2xvbmUoKS5zdWIoIHRoaXMudjEgKTtcclxuXHRwb2ludC5tdWx0aXBseVNjYWxhciggdCApLmFkZCggdGhpcy52MSApO1xyXG5cclxuXHRyZXR1cm4gcG9pbnQ7XHJcblxyXG59O1xyXG5cclxuLy8gTGluZSBjdXJ2ZSBpcyBsaW5lYXIsIHNvIHdlIGNhbiBvdmVyd3JpdGUgZGVmYXVsdCBnZXRQb2ludEF0XHJcblxyXG5USFJFRS5MaW5lQ3VydmUucHJvdG90eXBlLmdldFBvaW50QXQgPSBmdW5jdGlvbiAoIHUgKSB7XHJcblxyXG5cdHJldHVybiB0aGlzLmdldFBvaW50KCB1ICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTGluZUN1cnZlLnByb3RvdHlwZS5nZXRUYW5nZW50ID0gZnVuY3Rpb24oIHQgKSB7XHJcblxyXG5cdHZhciB0YW5nZW50ID0gdGhpcy52Mi5jbG9uZSgpLnN1YiggdGhpcy52MSApO1xyXG5cclxuXHRyZXR1cm4gdGFuZ2VudC5ub3JtYWxpemUoKTtcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvY3VydmVzL1F1YWRyYXRpY0JlemllckN1cnZlLmpzXHJcblxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICpcdFF1YWRyYXRpYyBCZXppZXIgY3VydmVcclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuXHJcblRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlID0gZnVuY3Rpb24gKCB2MCwgdjEsIHYyICkge1xyXG5cclxuXHR0aGlzLnYwID0gdjA7XHJcblx0dGhpcy52MSA9IHYxO1xyXG5cdHRoaXMudjIgPSB2MjtcclxuXHJcbn07XHJcblxyXG5USFJFRS5RdWFkcmF0aWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5DdXJ2ZS5wcm90b3R5cGUgKTtcclxuVEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmU7XHJcblxyXG5cclxuVEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmUucHJvdG90eXBlLmdldFBvaW50ID0gZnVuY3Rpb24gKCB0ICkge1xyXG5cclxuXHR2YXIgYjIgPSBUSFJFRS5TaGFwZVV0aWxzLmIyO1xyXG5cclxuXHRyZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjIoXHJcblx0XHRiMiggdCwgdGhpcy52MC54LCB0aGlzLnYxLngsIHRoaXMudjIueCApLFxyXG5cdFx0YjIoIHQsIHRoaXMudjAueSwgdGhpcy52MS55LCB0aGlzLnYyLnkgKVxyXG5cdCk7XHJcblxyXG59O1xyXG5cclxuXHJcblRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlLnByb3RvdHlwZS5nZXRUYW5nZW50ID0gZnVuY3Rpb24oIHQgKSB7XHJcblxyXG5cdHZhciB0YW5nZW50UXVhZHJhdGljQmV6aWVyID0gVEhSRUUuQ3VydmVVdGlscy50YW5nZW50UXVhZHJhdGljQmV6aWVyO1xyXG5cclxuXHRyZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjIoXHJcblx0XHR0YW5nZW50UXVhZHJhdGljQmV6aWVyKCB0LCB0aGlzLnYwLngsIHRoaXMudjEueCwgdGhpcy52Mi54ICksXHJcblx0XHR0YW5nZW50UXVhZHJhdGljQmV6aWVyKCB0LCB0aGlzLnYwLnksIHRoaXMudjEueSwgdGhpcy52Mi55IClcclxuXHQpLm5vcm1hbGl6ZSgpO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9jdXJ2ZXMvQ3ViaWNCZXppZXJDdXJ2ZS5qc1xyXG5cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAqXHRDdWJpYyBCZXppZXIgY3VydmVcclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZSA9IGZ1bmN0aW9uICggdjAsIHYxLCB2MiwgdjMgKSB7XHJcblxyXG5cdHRoaXMudjAgPSB2MDtcclxuXHR0aGlzLnYxID0gdjE7XHJcblx0dGhpcy52MiA9IHYyO1xyXG5cdHRoaXMudjMgPSB2MztcclxuXHJcbn07XHJcblxyXG5USFJFRS5DdWJpY0JlemllckN1cnZlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkN1cnZlLnByb3RvdHlwZSApO1xyXG5USFJFRS5DdWJpY0JlemllckN1cnZlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkN1YmljQmV6aWVyQ3VydmU7XHJcblxyXG5USFJFRS5DdWJpY0JlemllckN1cnZlLnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uICggdCApIHtcclxuXHJcblx0dmFyIGIzID0gVEhSRUUuU2hhcGVVdGlscy5iMztcclxuXHJcblx0cmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IyKCBcclxuXHRcdGIzKCB0LCB0aGlzLnYwLngsIHRoaXMudjEueCwgdGhpcy52Mi54LCB0aGlzLnYzLnggKSxcclxuXHRcdGIzKCB0LCB0aGlzLnYwLnksIHRoaXMudjEueSwgdGhpcy52Mi55LCB0aGlzLnYzLnkgKVxyXG5cdCk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUuZ2V0VGFuZ2VudCA9IGZ1bmN0aW9uKCB0ICkge1xyXG5cclxuXHR2YXIgdGFuZ2VudEN1YmljQmV6aWVyID0gVEhSRUUuQ3VydmVVdGlscy50YW5nZW50Q3ViaWNCZXppZXI7XHJcblxyXG5cdHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMiggXHJcblx0XHR0YW5nZW50Q3ViaWNCZXppZXIoIHQsIHRoaXMudjAueCwgdGhpcy52MS54LCB0aGlzLnYyLngsIHRoaXMudjMueCApLFxyXG5cdFx0dGFuZ2VudEN1YmljQmV6aWVyKCB0LCB0aGlzLnYwLnksIHRoaXMudjEueSwgdGhpcy52Mi55LCB0aGlzLnYzLnkgKVxyXG5cdCkubm9ybWFsaXplKCk7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2N1cnZlcy9TcGxpbmVDdXJ2ZS5qc1xyXG5cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAqXHRTcGxpbmUgY3VydmVcclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuVEhSRUUuU3BsaW5lQ3VydmUgPSBmdW5jdGlvbiAoIHBvaW50cyAvKiBhcnJheSBvZiBWZWN0b3IyICovICkge1xyXG5cclxuXHR0aGlzLnBvaW50cyA9ICggcG9pbnRzID09IHVuZGVmaW5lZCApID8gW10gOiBwb2ludHM7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuU3BsaW5lQ3VydmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQ3VydmUucHJvdG90eXBlICk7XHJcblRIUkVFLlNwbGluZUN1cnZlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlNwbGluZUN1cnZlO1xyXG5cclxuVEhSRUUuU3BsaW5lQ3VydmUucHJvdG90eXBlLmdldFBvaW50ID0gZnVuY3Rpb24gKCB0ICkge1xyXG5cclxuXHR2YXIgcG9pbnRzID0gdGhpcy5wb2ludHM7XHJcblx0dmFyIHBvaW50ID0gKCBwb2ludHMubGVuZ3RoIC0gMSApICogdDtcclxuXHJcblx0dmFyIGludFBvaW50ID0gTWF0aC5mbG9vciggcG9pbnQgKTtcclxuXHR2YXIgd2VpZ2h0ID0gcG9pbnQgLSBpbnRQb2ludDtcclxuXHJcblx0dmFyIHBvaW50MCA9IHBvaW50c1sgaW50UG9pbnQgPT09IDAgPyBpbnRQb2ludCA6IGludFBvaW50IC0gMSBdO1xyXG5cdHZhciBwb2ludDEgPSBwb2ludHNbIGludFBvaW50IF07XHJcblx0dmFyIHBvaW50MiA9IHBvaW50c1sgaW50UG9pbnQgPiBwb2ludHMubGVuZ3RoIC0gMiA/IHBvaW50cy5sZW5ndGggLSAxIDogaW50UG9pbnQgKyAxIF07XHJcblx0dmFyIHBvaW50MyA9IHBvaW50c1sgaW50UG9pbnQgPiBwb2ludHMubGVuZ3RoIC0gMyA/IHBvaW50cy5sZW5ndGggLSAxIDogaW50UG9pbnQgKyAyIF07XHJcblxyXG5cdHZhciBpbnRlcnBvbGF0ZSA9IFRIUkVFLkN1cnZlVXRpbHMuaW50ZXJwb2xhdGU7XHJcblxyXG5cdHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMihcclxuXHRcdGludGVycG9sYXRlKCBwb2ludDAueCwgcG9pbnQxLngsIHBvaW50Mi54LCBwb2ludDMueCwgd2VpZ2h0ICksXHJcblx0XHRpbnRlcnBvbGF0ZSggcG9pbnQwLnksIHBvaW50MS55LCBwb2ludDIueSwgcG9pbnQzLnksIHdlaWdodCApXHJcblx0KTtcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvY3VydmVzL0VsbGlwc2VDdXJ2ZS5qc1xyXG5cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAqXHRFbGxpcHNlIGN1cnZlXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcblRIUkVFLkVsbGlwc2VDdXJ2ZSA9IGZ1bmN0aW9uICggYVgsIGFZLCB4UmFkaXVzLCB5UmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlLCBhUm90YXRpb24gKSB7XHJcblxyXG5cdHRoaXMuYVggPSBhWDtcclxuXHR0aGlzLmFZID0gYVk7XHJcblxyXG5cdHRoaXMueFJhZGl1cyA9IHhSYWRpdXM7XHJcblx0dGhpcy55UmFkaXVzID0geVJhZGl1cztcclxuXHJcblx0dGhpcy5hU3RhcnRBbmdsZSA9IGFTdGFydEFuZ2xlO1xyXG5cdHRoaXMuYUVuZEFuZ2xlID0gYUVuZEFuZ2xlO1xyXG5cclxuXHR0aGlzLmFDbG9ja3dpc2UgPSBhQ2xvY2t3aXNlO1xyXG5cdFxyXG5cdHRoaXMuYVJvdGF0aW9uID0gYVJvdGF0aW9uIHx8IDA7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuRWxsaXBzZUN1cnZlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkN1cnZlLnByb3RvdHlwZSApO1xyXG5USFJFRS5FbGxpcHNlQ3VydmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuRWxsaXBzZUN1cnZlO1xyXG5cclxuVEhSRUUuRWxsaXBzZUN1cnZlLnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uICggdCApIHtcclxuXHJcblx0dmFyIGRlbHRhQW5nbGUgPSB0aGlzLmFFbmRBbmdsZSAtIHRoaXMuYVN0YXJ0QW5nbGU7XHJcblxyXG5cdGlmICggZGVsdGFBbmdsZSA8IDAgKSBkZWx0YUFuZ2xlICs9IE1hdGguUEkgKiAyO1xyXG5cdGlmICggZGVsdGFBbmdsZSA+IE1hdGguUEkgKiAyICkgZGVsdGFBbmdsZSAtPSBNYXRoLlBJICogMjtcclxuXHJcblx0dmFyIGFuZ2xlO1xyXG5cclxuXHRpZiAoIHRoaXMuYUNsb2Nrd2lzZSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRhbmdsZSA9IHRoaXMuYUVuZEFuZ2xlICsgKCAxIC0gdCApICogKCBNYXRoLlBJICogMiAtIGRlbHRhQW5nbGUgKTtcclxuXHJcblx0fSBlbHNlIHtcclxuXHJcblx0XHRhbmdsZSA9IHRoaXMuYVN0YXJ0QW5nbGUgKyB0ICogZGVsdGFBbmdsZTtcclxuXHJcblx0fVxyXG5cdFxyXG5cdHZhciB4ID0gdGhpcy5hWCArIHRoaXMueFJhZGl1cyAqIE1hdGguY29zKCBhbmdsZSApO1xyXG5cdHZhciB5ID0gdGhpcy5hWSArIHRoaXMueVJhZGl1cyAqIE1hdGguc2luKCBhbmdsZSApO1xyXG5cclxuXHRpZiAoIHRoaXMuYVJvdGF0aW9uICE9PSAwICkge1xyXG5cclxuXHRcdHZhciBjb3MgPSBNYXRoLmNvcyggdGhpcy5hUm90YXRpb24gKTtcclxuXHRcdHZhciBzaW4gPSBNYXRoLnNpbiggdGhpcy5hUm90YXRpb24gKTtcclxuXHJcblx0XHR2YXIgdHggPSB4LCB0eSA9IHk7XHJcblxyXG5cdFx0Ly8gUm90YXRlIHRoZSBwb2ludCBhYm91dCB0aGUgY2VudGVyIG9mIHRoZSBlbGxpcHNlLlxyXG5cdFx0eCA9ICggdHggLSB0aGlzLmFYICkgKiBjb3MgLSAoIHR5IC0gdGhpcy5hWSApICogc2luICsgdGhpcy5hWDtcclxuXHRcdHkgPSAoIHR4IC0gdGhpcy5hWCApICogc2luICsgKCB0eSAtIHRoaXMuYVkgKSAqIGNvcyArIHRoaXMuYVk7XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IyKCB4LCB5ICk7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2N1cnZlcy9BcmNDdXJ2ZS5qc1xyXG5cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAqXHRBcmMgY3VydmVcclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuVEhSRUUuQXJjQ3VydmUgPSBmdW5jdGlvbiAoIGFYLCBhWSwgYVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApIHtcclxuXHJcblx0VEhSRUUuRWxsaXBzZUN1cnZlLmNhbGwoIHRoaXMsIGFYLCBhWSwgYVJhZGl1cywgYVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkFyY0N1cnZlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkVsbGlwc2VDdXJ2ZS5wcm90b3R5cGUgKTtcclxuVEhSRUUuQXJjQ3VydmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQXJjQ3VydmU7XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvY3VydmVzL0xpbmVDdXJ2ZTMuanNcclxuXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gKlx0TGluZTNEXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcblRIUkVFLkxpbmVDdXJ2ZTMgPSBUSFJFRS5DdXJ2ZS5jcmVhdGUoXHJcblxyXG5cdGZ1bmN0aW9uICggdjEsIHYyICkge1xyXG5cclxuXHRcdHRoaXMudjEgPSB2MTtcclxuXHRcdHRoaXMudjIgPSB2MjtcclxuXHJcblx0fSxcclxuXHJcblx0ZnVuY3Rpb24gKCB0ICkge1xyXG5cclxuXHRcdHZhciB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdHZlY3Rvci5zdWJWZWN0b3JzKCB0aGlzLnYyLCB0aGlzLnYxICk7IC8vIGRpZmZcclxuXHRcdHZlY3Rvci5tdWx0aXBseVNjYWxhciggdCApO1xyXG5cdFx0dmVjdG9yLmFkZCggdGhpcy52MSApO1xyXG5cclxuXHRcdHJldHVybiB2ZWN0b3I7XHJcblxyXG5cdH1cclxuXHJcbik7XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvY3VydmVzL1F1YWRyYXRpY0JlemllckN1cnZlMy5qc1xyXG5cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAqXHRRdWFkcmF0aWMgQmV6aWVyIDNEIGN1cnZlXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcblRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlMyA9IFRIUkVFLkN1cnZlLmNyZWF0ZShcclxuXHJcblx0ZnVuY3Rpb24gKCB2MCwgdjEsIHYyICkge1xyXG5cclxuXHRcdHRoaXMudjAgPSB2MDtcclxuXHRcdHRoaXMudjEgPSB2MTtcclxuXHRcdHRoaXMudjIgPSB2MjtcclxuXHJcblx0fSxcclxuXHJcblx0ZnVuY3Rpb24gKCB0ICkge1xyXG5cclxuXHRcdHZhciBiMiA9IFRIUkVFLlNoYXBlVXRpbHMuYjI7XHRcdFxyXG5cclxuXHRcdHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMyhcclxuXHRcdFx0YjIoIHQsIHRoaXMudjAueCwgdGhpcy52MS54LCB0aGlzLnYyLnggKSxcclxuXHRcdFx0YjIoIHQsIHRoaXMudjAueSwgdGhpcy52MS55LCB0aGlzLnYyLnkgKSxcclxuXHRcdFx0YjIoIHQsIHRoaXMudjAueiwgdGhpcy52MS56LCB0aGlzLnYyLnogKVxyXG5cdFx0KTtcclxuXHJcblx0fVxyXG5cclxuKTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9jdXJ2ZXMvQ3ViaWNCZXppZXJDdXJ2ZTMuanNcclxuXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gKlx0Q3ViaWMgQmV6aWVyIDNEIGN1cnZlXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcblRIUkVFLkN1YmljQmV6aWVyQ3VydmUzID0gVEhSRUUuQ3VydmUuY3JlYXRlKFxyXG5cclxuXHRmdW5jdGlvbiAoIHYwLCB2MSwgdjIsIHYzICkge1xyXG5cclxuXHRcdHRoaXMudjAgPSB2MDtcclxuXHRcdHRoaXMudjEgPSB2MTtcclxuXHRcdHRoaXMudjIgPSB2MjtcclxuXHRcdHRoaXMudjMgPSB2MztcclxuXHJcblx0fSxcclxuXHJcblx0ZnVuY3Rpb24gKCB0ICkge1xyXG5cclxuXHRcdHZhciBiMyA9IFRIUkVFLlNoYXBlVXRpbHMuYjM7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IzKFxyXG5cdFx0XHRiMyggdCwgdGhpcy52MC54LCB0aGlzLnYxLngsIHRoaXMudjIueCwgdGhpcy52My54ICksXHJcblx0XHRcdGIzKCB0LCB0aGlzLnYwLnksIHRoaXMudjEueSwgdGhpcy52Mi55LCB0aGlzLnYzLnkgKSxcclxuXHRcdFx0YjMoIHQsIHRoaXMudjAueiwgdGhpcy52MS56LCB0aGlzLnYyLnosIHRoaXMudjMueiApXHJcblx0XHQpO1xyXG5cclxuXHR9XHJcblxyXG4pO1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2N1cnZlcy9TcGxpbmVDdXJ2ZTMuanNcclxuXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gKlx0U3BsaW5lIDNEIGN1cnZlXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcblxyXG5USFJFRS5TcGxpbmVDdXJ2ZTMgPSBUSFJFRS5DdXJ2ZS5jcmVhdGUoXHJcblxyXG5cdGZ1bmN0aW9uICggcG9pbnRzIC8qIGFycmF5IG9mIFZlY3RvcjMgKi8gKSB7XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuU3BsaW5lQ3VydmUzIHdpbGwgYmUgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBUSFJFRS5DYXRtdWxsUm9tQ3VydmUzJyApO1xyXG5cdFx0dGhpcy5wb2ludHMgPSAoIHBvaW50cyA9PSB1bmRlZmluZWQgKSA/IFtdIDogcG9pbnRzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRmdW5jdGlvbiAoIHQgKSB7XHJcblxyXG5cdFx0dmFyIHBvaW50cyA9IHRoaXMucG9pbnRzO1xyXG5cdFx0dmFyIHBvaW50ID0gKCBwb2ludHMubGVuZ3RoIC0gMSApICogdDtcclxuXHJcblx0XHR2YXIgaW50UG9pbnQgPSBNYXRoLmZsb29yKCBwb2ludCApO1xyXG5cdFx0dmFyIHdlaWdodCA9IHBvaW50IC0gaW50UG9pbnQ7XHJcblxyXG5cdFx0dmFyIHBvaW50MCA9IHBvaW50c1sgaW50UG9pbnQgPT0gMCA/IGludFBvaW50IDogaW50UG9pbnQgLSAxIF07XHJcblx0XHR2YXIgcG9pbnQxID0gcG9pbnRzWyBpbnRQb2ludCBdO1xyXG5cdFx0dmFyIHBvaW50MiA9IHBvaW50c1sgaW50UG9pbnQgPiBwb2ludHMubGVuZ3RoIC0gMiA/IHBvaW50cy5sZW5ndGggLSAxIDogaW50UG9pbnQgKyAxIF07XHJcblx0XHR2YXIgcG9pbnQzID0gcG9pbnRzWyBpbnRQb2ludCA+IHBvaW50cy5sZW5ndGggLSAzID8gcG9pbnRzLmxlbmd0aCAtIDEgOiBpbnRQb2ludCArIDIgXTtcclxuXHJcblx0XHR2YXIgaW50ZXJwb2xhdGUgPSBUSFJFRS5DdXJ2ZVV0aWxzLmludGVycG9sYXRlO1xyXG5cclxuXHRcdHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMyhcclxuXHRcdFx0aW50ZXJwb2xhdGUoIHBvaW50MC54LCBwb2ludDEueCwgcG9pbnQyLngsIHBvaW50My54LCB3ZWlnaHQgKSxcclxuXHRcdFx0aW50ZXJwb2xhdGUoIHBvaW50MC55LCBwb2ludDEueSwgcG9pbnQyLnksIHBvaW50My55LCB3ZWlnaHQgKSxcclxuXHRcdFx0aW50ZXJwb2xhdGUoIHBvaW50MC56LCBwb2ludDEueiwgcG9pbnQyLnosIHBvaW50My56LCB3ZWlnaHQgKVxyXG5cdFx0KTtcclxuXHJcblx0fVxyXG5cclxuKTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9jdXJ2ZXMvQ2F0bXVsbFJvbUN1cnZlMy5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3Igeno4NSBodHRwczovL2dpdGh1Yi5jb20veno4NVxyXG4gKlxyXG4gKiBDZW50cmlwZXRhbCBDYXRtdWxsUm9tIEN1cnZlIC0gd2hpY2ggaXMgdXNlZnVsIGZvciBhdm9pZGluZ1xyXG4gKiBjdXNwcyBhbmQgc2VsZi1pbnRlcnNlY3Rpb25zIGluIG5vbi11bmlmb3JtIGNhdG11bGwgcm9tIGN1cnZlcy5cclxuICogaHR0cDovL3d3dy5jZW15dWtzZWwuY29tL3Jlc2VhcmNoL2NhdG11bGxyb21fcGFyYW0vY2F0bXVsbHJvbS5wZGZcclxuICpcclxuICogY3VydmUudHlwZSBhY2NlcHRzIGNlbnRyaXBldGFsKGRlZmF1bHQpLCBjaG9yZGFsIGFuZCBjYXRtdWxscm9tXHJcbiAqIGN1cnZlLnRlbnNpb24gaXMgdXNlZCBmb3IgY2F0bXVsbHJvbSB3aGljaCBkZWZhdWx0cyB0byAwLjVcclxuICovXHJcblxyXG5USFJFRS5DYXRtdWxsUm9tQ3VydmUzID0gKCBmdW5jdGlvbigpIHtcclxuXHJcblx0dmFyXHJcblx0XHR0bXAgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG5cdFx0cHggPSBuZXcgQ3ViaWNQb2x5KCksXHJcblx0XHRweSA9IG5ldyBDdWJpY1BvbHkoKSxcclxuXHRcdHB6ID0gbmV3IEN1YmljUG9seSgpO1xyXG5cclxuXHQvKlxyXG5cdEJhc2VkIG9uIGFuIG9wdGltaXplZCBjKysgc29sdXRpb24gaW5cclxuXHQgLSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzk0ODk3MzYvY2F0bXVsbC1yb20tY3VydmUtd2l0aC1uby1jdXNwcy1hbmQtbm8tc2VsZi1pbnRlcnNlY3Rpb25zL1xyXG5cdCAtIGh0dHA6Ly9pZGVvbmUuY29tL05vRWJWTVxyXG5cclxuXHRUaGlzIEN1YmljUG9seSBjbGFzcyBjb3VsZCBiZSB1c2VkIGZvciByZXVzaW5nIHNvbWUgdmFyaWFibGVzIGFuZCBjYWxjdWxhdGlvbnMsXHJcblx0YnV0IGZvciB0aHJlZS5qcyBjdXJ2ZSB1c2UsIGl0IGNvdWxkIGJlIHBvc3NpYmxlIGlubGluZWQgYW5kIGZsYXR0ZW4gaW50byBhIHNpbmdsZSBmdW5jdGlvbiBjYWxsXHJcblx0d2hpY2ggY2FuIGJlIHBsYWNlZCBpbiBDdXJ2ZVV0aWxzLlxyXG5cdCovXHJcblxyXG5cdGZ1bmN0aW9uIEN1YmljUG9seSgpIHtcclxuXHJcblx0fVxyXG5cclxuXHQvKlxyXG5cdCAqIENvbXB1dGUgY29lZmZpY2llbnRzIGZvciBhIGN1YmljIHBvbHlub21pYWxcclxuXHQgKiAgIHAocykgPSBjMCArIGMxKnMgKyBjMipzXjIgKyBjMypzXjNcclxuXHQgKiBzdWNoIHRoYXRcclxuXHQgKiAgIHAoMCkgPSB4MCwgcCgxKSA9IHgxXHJcblx0ICogIGFuZFxyXG5cdCAqICAgcCcoMCkgPSB0MCwgcCcoMSkgPSB0MS5cclxuXHQgKi9cclxuXHRDdWJpY1BvbHkucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiggeDAsIHgxLCB0MCwgdDEgKSB7XHJcblxyXG5cdFx0dGhpcy5jMCA9IHgwO1xyXG5cdFx0dGhpcy5jMSA9IHQwO1xyXG5cdFx0dGhpcy5jMiA9IC0gMyAqIHgwICsgMyAqIHgxIC0gMiAqIHQwIC0gdDE7XHJcblx0XHR0aGlzLmMzID0gMiAqIHgwIC0gMiAqIHgxICsgdDAgKyB0MTtcclxuXHJcblx0fTtcclxuXHJcblx0Q3ViaWNQb2x5LnByb3RvdHlwZS5pbml0Tm9udW5pZm9ybUNhdG11bGxSb20gPSBmdW5jdGlvbiggeDAsIHgxLCB4MiwgeDMsIGR0MCwgZHQxLCBkdDIgKSB7XHJcblxyXG5cdFx0Ly8gY29tcHV0ZSB0YW5nZW50cyB3aGVuIHBhcmFtZXRlcml6ZWQgaW4gW3QxLHQyXVxyXG5cdFx0dmFyIHQxID0gKCB4MSAtIHgwICkgLyBkdDAgLSAoIHgyIC0geDAgKSAvICggZHQwICsgZHQxICkgKyAoIHgyIC0geDEgKSAvIGR0MTtcclxuXHRcdHZhciB0MiA9ICggeDIgLSB4MSApIC8gZHQxIC0gKCB4MyAtIHgxICkgLyAoIGR0MSArIGR0MiApICsgKCB4MyAtIHgyICkgLyBkdDI7XHJcblxyXG5cdFx0Ly8gcmVzY2FsZSB0YW5nZW50cyBmb3IgcGFyYW1ldHJpemF0aW9uIGluIFswLDFdXHJcblx0XHR0MSAqPSBkdDE7XHJcblx0XHR0MiAqPSBkdDE7XHJcblxyXG5cdFx0Ly8gaW5pdEN1YmljUG9seVxyXG5cdFx0dGhpcy5pbml0KCB4MSwgeDIsIHQxLCB0MiApO1xyXG5cclxuXHR9O1xyXG5cclxuXHQvLyBzdGFuZGFyZCBDYXRtdWxsLVJvbSBzcGxpbmU6IGludGVycG9sYXRlIGJldHdlZW4geDEgYW5kIHgyIHdpdGggcHJldmlvdXMvZm9sbG93aW5nIHBvaW50cyB4MS94NFxyXG5cdEN1YmljUG9seS5wcm90b3R5cGUuaW5pdENhdG11bGxSb20gPSBmdW5jdGlvbiggeDAsIHgxLCB4MiwgeDMsIHRlbnNpb24gKSB7XHJcblxyXG5cdFx0dGhpcy5pbml0KCB4MSwgeDIsIHRlbnNpb24gKiAoIHgyIC0geDAgKSwgdGVuc2lvbiAqICggeDMgLSB4MSApICk7XHJcblxyXG5cdH07XHJcblxyXG5cdEN1YmljUG9seS5wcm90b3R5cGUuY2FsYyA9IGZ1bmN0aW9uKCB0ICkge1xyXG5cclxuXHRcdHZhciB0MiA9IHQgKiB0O1xyXG5cdFx0dmFyIHQzID0gdDIgKiB0O1xyXG5cdFx0cmV0dXJuIHRoaXMuYzAgKyB0aGlzLmMxICogdCArIHRoaXMuYzIgKiB0MiArIHRoaXMuYzMgKiB0MztcclxuXHJcblx0fTtcclxuXHJcblx0Ly8gU3ViY2xhc3MgVGhyZWUuanMgY3VydmVcclxuXHRyZXR1cm4gVEhSRUUuQ3VydmUuY3JlYXRlKFxyXG5cclxuXHRcdGZ1bmN0aW9uICggcCAvKiBhcnJheSBvZiBWZWN0b3IzICovICkge1xyXG5cclxuXHRcdFx0dGhpcy5wb2ludHMgPSBwIHx8IFtdO1xyXG5cdFx0XHR0aGlzLmNsb3NlZCA9IGZhbHNlO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0ZnVuY3Rpb24gKCB0ICkge1xyXG5cclxuXHRcdFx0dmFyIHBvaW50cyA9IHRoaXMucG9pbnRzLFxyXG5cdFx0XHRcdHBvaW50LCBpbnRQb2ludCwgd2VpZ2h0LCBsO1xyXG5cclxuXHRcdFx0bCA9IHBvaW50cy5sZW5ndGg7XHJcblxyXG5cdFx0XHRpZiAoIGwgPCAyICkgY29uc29sZS5sb2coICdkdWgsIHlvdSBuZWVkIGF0IGxlYXN0IDIgcG9pbnRzJyApO1xyXG5cclxuXHRcdFx0cG9pbnQgPSAoIGwgLSAoIHRoaXMuY2xvc2VkID8gMCA6IDEgKSApICogdDtcclxuXHRcdFx0aW50UG9pbnQgPSBNYXRoLmZsb29yKCBwb2ludCApO1xyXG5cdFx0XHR3ZWlnaHQgPSBwb2ludCAtIGludFBvaW50O1xyXG5cclxuXHRcdFx0aWYgKCB0aGlzLmNsb3NlZCApIHtcclxuXHJcblx0XHRcdFx0aW50UG9pbnQgKz0gaW50UG9pbnQgPiAwID8gMCA6ICggTWF0aC5mbG9vciggTWF0aC5hYnMoIGludFBvaW50ICkgLyBwb2ludHMubGVuZ3RoICkgKyAxICkgKiBwb2ludHMubGVuZ3RoO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggd2VpZ2h0ID09PSAwICYmIGludFBvaW50ID09PSBsIC0gMSApIHtcclxuXHJcblx0XHRcdFx0aW50UG9pbnQgPSBsIC0gMjtcclxuXHRcdFx0XHR3ZWlnaHQgPSAxO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIHAwLCBwMSwgcDIsIHAzOyAvLyA0IHBvaW50c1xyXG5cclxuXHRcdFx0aWYgKCB0aGlzLmNsb3NlZCB8fCBpbnRQb2ludCA+IDAgKSB7XHJcblxyXG5cdFx0XHRcdHAwID0gcG9pbnRzWyAoIGludFBvaW50IC0gMSApICUgbCBdO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Ly8gZXh0cmFwb2xhdGUgZmlyc3QgcG9pbnRcclxuXHRcdFx0XHR0bXAuc3ViVmVjdG9ycyggcG9pbnRzWyAwIF0sIHBvaW50c1sgMSBdICkuYWRkKCBwb2ludHNbIDAgXSApO1xyXG5cdFx0XHRcdHAwID0gdG1wO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cDEgPSBwb2ludHNbIGludFBvaW50ICUgbCBdO1xyXG5cdFx0XHRwMiA9IHBvaW50c1sgKCBpbnRQb2ludCArIDEgKSAlIGwgXTtcclxuXHJcblx0XHRcdGlmICggdGhpcy5jbG9zZWQgfHwgaW50UG9pbnQgKyAyIDwgbCApIHtcclxuXHJcblx0XHRcdFx0cDMgPSBwb2ludHNbICggaW50UG9pbnQgKyAyICkgJSBsIF07XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHQvLyBleHRyYXBvbGF0ZSBsYXN0IHBvaW50XHJcblx0XHRcdFx0dG1wLnN1YlZlY3RvcnMoIHBvaW50c1sgbCAtIDEgXSwgcG9pbnRzWyBsIC0gMiBdICkuYWRkKCBwb2ludHNbIGwgLSAxIF0gKTtcclxuXHRcdFx0XHRwMyA9IHRtcDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggdGhpcy50eXBlID09PSB1bmRlZmluZWQgfHwgdGhpcy50eXBlID09PSAnY2VudHJpcGV0YWwnIHx8IHRoaXMudHlwZSA9PT0gJ2Nob3JkYWwnICkge1xyXG5cclxuXHRcdFx0XHQvLyBpbml0IENlbnRyaXBldGFsIC8gQ2hvcmRhbCBDYXRtdWxsLVJvbVxyXG5cdFx0XHRcdHZhciBwb3cgPSB0aGlzLnR5cGUgPT09ICdjaG9yZGFsJyA/IDAuNSA6IDAuMjU7XHJcblx0XHRcdFx0dmFyIGR0MCA9IE1hdGgucG93KCBwMC5kaXN0YW5jZVRvU3F1YXJlZCggcDEgKSwgcG93ICk7XHJcblx0XHRcdFx0dmFyIGR0MSA9IE1hdGgucG93KCBwMS5kaXN0YW5jZVRvU3F1YXJlZCggcDIgKSwgcG93ICk7XHJcblx0XHRcdFx0dmFyIGR0MiA9IE1hdGgucG93KCBwMi5kaXN0YW5jZVRvU3F1YXJlZCggcDMgKSwgcG93ICk7XHJcblxyXG5cdFx0XHRcdC8vIHNhZmV0eSBjaGVjayBmb3IgcmVwZWF0ZWQgcG9pbnRzXHJcblx0XHRcdFx0aWYgKCBkdDEgPCAxZS00ICkgZHQxID0gMS4wO1xyXG5cdFx0XHRcdGlmICggZHQwIDwgMWUtNCApIGR0MCA9IGR0MTtcclxuXHRcdFx0XHRpZiAoIGR0MiA8IDFlLTQgKSBkdDIgPSBkdDE7XHJcblxyXG5cdFx0XHRcdHB4LmluaXROb251bmlmb3JtQ2F0bXVsbFJvbSggcDAueCwgcDEueCwgcDIueCwgcDMueCwgZHQwLCBkdDEsIGR0MiApO1xyXG5cdFx0XHRcdHB5LmluaXROb251bmlmb3JtQ2F0bXVsbFJvbSggcDAueSwgcDEueSwgcDIueSwgcDMueSwgZHQwLCBkdDEsIGR0MiApO1xyXG5cdFx0XHRcdHB6LmluaXROb251bmlmb3JtQ2F0bXVsbFJvbSggcDAueiwgcDEueiwgcDIueiwgcDMueiwgZHQwLCBkdDEsIGR0MiApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggdGhpcy50eXBlID09PSAnY2F0bXVsbHJvbScgKSB7XHJcblxyXG5cdFx0XHRcdHZhciB0ZW5zaW9uID0gdGhpcy50ZW5zaW9uICE9PSB1bmRlZmluZWQgPyB0aGlzLnRlbnNpb24gOiAwLjU7XHJcblx0XHRcdFx0cHguaW5pdENhdG11bGxSb20oIHAwLngsIHAxLngsIHAyLngsIHAzLngsIHRlbnNpb24gKTtcclxuXHRcdFx0XHRweS5pbml0Q2F0bXVsbFJvbSggcDAueSwgcDEueSwgcDIueSwgcDMueSwgdGVuc2lvbiApO1xyXG5cdFx0XHRcdHB6LmluaXRDYXRtdWxsUm9tKCBwMC56LCBwMS56LCBwMi56LCBwMy56LCB0ZW5zaW9uICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgdiA9IG5ldyBUSFJFRS5WZWN0b3IzKFxyXG5cdFx0XHRcdHB4LmNhbGMoIHdlaWdodCApLFxyXG5cdFx0XHRcdHB5LmNhbGMoIHdlaWdodCApLFxyXG5cdFx0XHRcdHB6LmNhbGMoIHdlaWdodCApXHJcblx0XHRcdCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdjtcclxuXHJcblx0XHR9XHJcblxyXG5cdCk7XHJcblxyXG59ICkoKTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9jdXJ2ZXMvQ2xvc2VkU3BsaW5lQ3VydmUzLmpzXHJcblxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICpcdENsb3NlZCBTcGxpbmUgM0QgY3VydmVcclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuXHJcblRIUkVFLkNsb3NlZFNwbGluZUN1cnZlMyA9IGZ1bmN0aW9uICggcG9pbnRzICkge1xyXG5cclxuXHRjb25zb2xlLndhcm4oICdUSFJFRS5DbG9zZWRTcGxpbmVDdXJ2ZTMgaGFzIGJlZW4gZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBUSFJFRS5DYXRtdWxsUm9tQ3VydmUzLicgKTtcclxuXHJcblx0VEhSRUUuQ2F0bXVsbFJvbUN1cnZlMy5jYWxsKCB0aGlzLCBwb2ludHMgKTtcclxuXHR0aGlzLnR5cGUgPSAnY2F0bXVsbHJvbSc7XHJcblx0dGhpcy5jbG9zZWQgPSB0cnVlO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkNsb3NlZFNwbGluZUN1cnZlMy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5DYXRtdWxsUm9tQ3VydmUzLnByb3RvdHlwZSApO1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvQm94R2VvbWV0cnkuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBiYXNlZCBvbiBodHRwOi8vcGFwZXJ2aXNpb24zZC5nb29nbGVjb2RlLmNvbS9zdm4vdHJ1bmsvYXMzL3RydW5rL3NyYy9vcmcvcGFwZXJ2aXNpb24zZC9vYmplY3RzL3ByaW1pdGl2ZXMvQ3ViZS5hc1xyXG4gKi9cclxuXHJcblRIUkVFLkJveEdlb21ldHJ5ID0gZnVuY3Rpb24gKCB3aWR0aCwgaGVpZ2h0LCBkZXB0aCwgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIGRlcHRoU2VnbWVudHMgKSB7XHJcblxyXG5cdFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy50eXBlID0gJ0JveEdlb21ldHJ5JztcclxuXHJcblx0dGhpcy5wYXJhbWV0ZXJzID0ge1xyXG5cdFx0d2lkdGg6IHdpZHRoLFxyXG5cdFx0aGVpZ2h0OiBoZWlnaHQsXHJcblx0XHRkZXB0aDogZGVwdGgsXHJcblx0XHR3aWR0aFNlZ21lbnRzOiB3aWR0aFNlZ21lbnRzLFxyXG5cdFx0aGVpZ2h0U2VnbWVudHM6IGhlaWdodFNlZ21lbnRzLFxyXG5cdFx0ZGVwdGhTZWdtZW50czogZGVwdGhTZWdtZW50c1xyXG5cdH07XHJcblxyXG5cdHRoaXMud2lkdGhTZWdtZW50cyA9IHdpZHRoU2VnbWVudHMgfHwgMTtcclxuXHR0aGlzLmhlaWdodFNlZ21lbnRzID0gaGVpZ2h0U2VnbWVudHMgfHwgMTtcclxuXHR0aGlzLmRlcHRoU2VnbWVudHMgPSBkZXB0aFNlZ21lbnRzIHx8IDE7XHJcblxyXG5cdHZhciBzY29wZSA9IHRoaXM7XHJcblxyXG5cdHZhciB3aWR0aF9oYWxmID0gd2lkdGggLyAyO1xyXG5cdHZhciBoZWlnaHRfaGFsZiA9IGhlaWdodCAvIDI7XHJcblx0dmFyIGRlcHRoX2hhbGYgPSBkZXB0aCAvIDI7XHJcblxyXG5cdGJ1aWxkUGxhbmUoICd6JywgJ3knLCAtIDEsIC0gMSwgZGVwdGgsIGhlaWdodCwgd2lkdGhfaGFsZiwgMCApOyAvLyBweFxyXG5cdGJ1aWxkUGxhbmUoICd6JywgJ3knLCAgIDEsIC0gMSwgZGVwdGgsIGhlaWdodCwgLSB3aWR0aF9oYWxmLCAxICk7IC8vIG54XHJcblx0YnVpbGRQbGFuZSggJ3gnLCAneicsICAgMSwgICAxLCB3aWR0aCwgZGVwdGgsIGhlaWdodF9oYWxmLCAyICk7IC8vIHB5XHJcblx0YnVpbGRQbGFuZSggJ3gnLCAneicsICAgMSwgLSAxLCB3aWR0aCwgZGVwdGgsIC0gaGVpZ2h0X2hhbGYsIDMgKTsgLy8gbnlcclxuXHRidWlsZFBsYW5lKCAneCcsICd5JywgICAxLCAtIDEsIHdpZHRoLCBoZWlnaHQsIGRlcHRoX2hhbGYsIDQgKTsgLy8gcHpcclxuXHRidWlsZFBsYW5lKCAneCcsICd5JywgLSAxLCAtIDEsIHdpZHRoLCBoZWlnaHQsIC0gZGVwdGhfaGFsZiwgNSApOyAvLyBuelxyXG5cclxuXHRmdW5jdGlvbiBidWlsZFBsYW5lKCB1LCB2LCB1ZGlyLCB2ZGlyLCB3aWR0aCwgaGVpZ2h0LCBkZXB0aCwgbWF0ZXJpYWxJbmRleCApIHtcclxuXHJcblx0XHR2YXIgdywgaXgsIGl5LFxyXG5cdFx0Z3JpZFggPSBzY29wZS53aWR0aFNlZ21lbnRzLFxyXG5cdFx0Z3JpZFkgPSBzY29wZS5oZWlnaHRTZWdtZW50cyxcclxuXHRcdHdpZHRoX2hhbGYgPSB3aWR0aCAvIDIsXHJcblx0XHRoZWlnaHRfaGFsZiA9IGhlaWdodCAvIDIsXHJcblx0XHRvZmZzZXQgPSBzY29wZS52ZXJ0aWNlcy5sZW5ndGg7XHJcblxyXG5cdFx0aWYgKCAoIHUgPT09ICd4JyAmJiB2ID09PSAneScgKSB8fCAoIHUgPT09ICd5JyAmJiB2ID09PSAneCcgKSApIHtcclxuXHJcblx0XHRcdHcgPSAneic7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggKCB1ID09PSAneCcgJiYgdiA9PT0gJ3onICkgfHwgKCB1ID09PSAneicgJiYgdiA9PT0gJ3gnICkgKSB7XHJcblxyXG5cdFx0XHR3ID0gJ3knO1xyXG5cdFx0XHRncmlkWSA9IHNjb3BlLmRlcHRoU2VnbWVudHM7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggKCB1ID09PSAneicgJiYgdiA9PT0gJ3knICkgfHwgKCB1ID09PSAneScgJiYgdiA9PT0gJ3onICkgKSB7XHJcblxyXG5cdFx0XHR3ID0gJ3gnO1xyXG5cdFx0XHRncmlkWCA9IHNjb3BlLmRlcHRoU2VnbWVudHM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBncmlkWDEgPSBncmlkWCArIDEsXHJcblx0XHRncmlkWTEgPSBncmlkWSArIDEsXHJcblx0XHRzZWdtZW50X3dpZHRoID0gd2lkdGggLyBncmlkWCxcclxuXHRcdHNlZ21lbnRfaGVpZ2h0ID0gaGVpZ2h0IC8gZ3JpZFksXHJcblx0XHRub3JtYWwgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdG5vcm1hbFsgdyBdID0gZGVwdGggPiAwID8gMSA6IC0gMTtcclxuXHJcblx0XHRmb3IgKCBpeSA9IDA7IGl5IDwgZ3JpZFkxOyBpeSArKyApIHtcclxuXHJcblx0XHRcdGZvciAoIGl4ID0gMDsgaXggPCBncmlkWDE7IGl4ICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdFx0XHR2ZWN0b3JbIHUgXSA9ICggaXggKiBzZWdtZW50X3dpZHRoIC0gd2lkdGhfaGFsZiApICogdWRpcjtcclxuXHRcdFx0XHR2ZWN0b3JbIHYgXSA9ICggaXkgKiBzZWdtZW50X2hlaWdodCAtIGhlaWdodF9oYWxmICkgKiB2ZGlyO1xyXG5cdFx0XHRcdHZlY3RvclsgdyBdID0gZGVwdGg7XHJcblxyXG5cdFx0XHRcdHNjb3BlLnZlcnRpY2VzLnB1c2goIHZlY3RvciApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKCBpeSA9IDA7IGl5IDwgZ3JpZFk7IGl5ICsrICkge1xyXG5cclxuXHRcdFx0Zm9yICggaXggPSAwOyBpeCA8IGdyaWRYOyBpeCArKyApIHtcclxuXHJcblx0XHRcdFx0dmFyIGEgPSBpeCArIGdyaWRYMSAqIGl5O1xyXG5cdFx0XHRcdHZhciBiID0gaXggKyBncmlkWDEgKiAoIGl5ICsgMSApO1xyXG5cdFx0XHRcdHZhciBjID0gKCBpeCArIDEgKSArIGdyaWRYMSAqICggaXkgKyAxICk7XHJcblx0XHRcdFx0dmFyIGQgPSAoIGl4ICsgMSApICsgZ3JpZFgxICogaXk7XHJcblxyXG5cdFx0XHRcdHZhciB1dmEgPSBuZXcgVEhSRUUuVmVjdG9yMiggaXggLyBncmlkWCwgMSAtIGl5IC8gZ3JpZFkgKTtcclxuXHRcdFx0XHR2YXIgdXZiID0gbmV3IFRIUkVFLlZlY3RvcjIoIGl4IC8gZ3JpZFgsIDEgLSAoIGl5ICsgMSApIC8gZ3JpZFkgKTtcclxuXHRcdFx0XHR2YXIgdXZjID0gbmV3IFRIUkVFLlZlY3RvcjIoICggaXggKyAxICkgLyBncmlkWCwgMSAtICggaXkgKyAxICkgLyBncmlkWSApO1xyXG5cdFx0XHRcdHZhciB1dmQgPSBuZXcgVEhSRUUuVmVjdG9yMiggKCBpeCArIDEgKSAvIGdyaWRYLCAxIC0gaXkgLyBncmlkWSApO1xyXG5cclxuXHRcdFx0XHR2YXIgZmFjZSA9IG5ldyBUSFJFRS5GYWNlMyggYSArIG9mZnNldCwgYiArIG9mZnNldCwgZCArIG9mZnNldCApO1xyXG5cdFx0XHRcdGZhY2Uubm9ybWFsLmNvcHkoIG5vcm1hbCApO1xyXG5cdFx0XHRcdGZhY2UudmVydGV4Tm9ybWFscy5wdXNoKCBub3JtYWwuY2xvbmUoKSwgbm9ybWFsLmNsb25lKCksIG5vcm1hbC5jbG9uZSgpICk7XHJcblx0XHRcdFx0ZmFjZS5tYXRlcmlhbEluZGV4ID0gbWF0ZXJpYWxJbmRleDtcclxuXHJcblx0XHRcdFx0c2NvcGUuZmFjZXMucHVzaCggZmFjZSApO1xyXG5cdFx0XHRcdHNjb3BlLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2YSwgdXZiLCB1dmQgXSApO1xyXG5cclxuXHRcdFx0XHRmYWNlID0gbmV3IFRIUkVFLkZhY2UzKCBiICsgb2Zmc2V0LCBjICsgb2Zmc2V0LCBkICsgb2Zmc2V0ICk7XHJcblx0XHRcdFx0ZmFjZS5ub3JtYWwuY29weSggbm9ybWFsICk7XHJcblx0XHRcdFx0ZmFjZS52ZXJ0ZXhOb3JtYWxzLnB1c2goIG5vcm1hbC5jbG9uZSgpLCBub3JtYWwuY2xvbmUoKSwgbm9ybWFsLmNsb25lKCkgKTtcclxuXHRcdFx0XHRmYWNlLm1hdGVyaWFsSW5kZXggPSBtYXRlcmlhbEluZGV4O1xyXG5cclxuXHRcdFx0XHRzY29wZS5mYWNlcy5wdXNoKCBmYWNlICk7XHJcblx0XHRcdFx0c2NvcGUuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZiLmNsb25lKCksIHV2YywgdXZkLmNsb25lKCkgXSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHR0aGlzLm1lcmdlVmVydGljZXMoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Cb3hHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuVEhSRUUuQm94R2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQm94R2VvbWV0cnk7XHJcblxyXG5USFJFRS5DdWJlR2VvbWV0cnkgPSBUSFJFRS5Cb3hHZW9tZXRyeTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL0NpcmNsZUdlb21ldHJ5LmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBodWdoZXNcclxuICovXHJcblxyXG5USFJFRS5DaXJjbGVHZW9tZXRyeSA9IGZ1bmN0aW9uICggcmFkaXVzLCBzZWdtZW50cywgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKSB7XHJcblxyXG5cdFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy50eXBlID0gJ0NpcmNsZUdlb21ldHJ5JztcclxuXHJcblx0dGhpcy5wYXJhbWV0ZXJzID0ge1xyXG5cdFx0cmFkaXVzOiByYWRpdXMsXHJcblx0XHRzZWdtZW50czogc2VnbWVudHMsXHJcblx0XHR0aGV0YVN0YXJ0OiB0aGV0YVN0YXJ0LFxyXG5cdFx0dGhldGFMZW5ndGg6IHRoZXRhTGVuZ3RoXHJcblx0fTtcclxuXHJcblx0dGhpcy5mcm9tQnVmZmVyR2VvbWV0cnkoIG5ldyBUSFJFRS5DaXJjbGVCdWZmZXJHZW9tZXRyeSggcmFkaXVzLCBzZWdtZW50cywgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKSApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkNpcmNsZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG5USFJFRS5DaXJjbGVHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5DaXJjbGVHZW9tZXRyeTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL0NpcmNsZUJ1ZmZlckdlb21ldHJ5LmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBiZW5hYWRhbXMgLyBodHRwczovL3R3aXR0ZXIuY29tL2Jlbl9hX2FkYW1zXHJcbiAqL1xyXG5cclxuVEhSRUUuQ2lyY2xlQnVmZmVyR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHJhZGl1cywgc2VnbWVudHMsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICkge1xyXG5cclxuXHRUSFJFRS5CdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMudHlwZSA9ICdDaXJjbGVCdWZmZXJHZW9tZXRyeSc7XHJcblxyXG5cdHRoaXMucGFyYW1ldGVycyA9IHtcclxuXHRcdHJhZGl1czogcmFkaXVzLFxyXG5cdFx0c2VnbWVudHM6IHNlZ21lbnRzLFxyXG5cdFx0dGhldGFTdGFydDogdGhldGFTdGFydCxcclxuXHRcdHRoZXRhTGVuZ3RoOiB0aGV0YUxlbmd0aFxyXG5cdH07XHJcblxyXG5cdHJhZGl1cyA9IHJhZGl1cyB8fCA1MDtcclxuXHRzZWdtZW50cyA9IHNlZ21lbnRzICE9PSB1bmRlZmluZWQgPyBNYXRoLm1heCggMywgc2VnbWVudHMgKSA6IDg7XHJcblxyXG5cdHRoZXRhU3RhcnQgPSB0aGV0YVN0YXJ0ICE9PSB1bmRlZmluZWQgPyB0aGV0YVN0YXJ0IDogMDtcclxuXHR0aGV0YUxlbmd0aCA9IHRoZXRhTGVuZ3RoICE9PSB1bmRlZmluZWQgPyB0aGV0YUxlbmd0aCA6IE1hdGguUEkgKiAyO1xyXG5cclxuXHR2YXIgdmVydGljZXMgPSBzZWdtZW50cyArIDI7XHJcblxyXG5cdHZhciBwb3NpdGlvbnMgPSBuZXcgRmxvYXQzMkFycmF5KCB2ZXJ0aWNlcyAqIDMgKTtcclxuXHR2YXIgbm9ybWFscyA9IG5ldyBGbG9hdDMyQXJyYXkoIHZlcnRpY2VzICogMyApO1xyXG5cdHZhciB1dnMgPSBuZXcgRmxvYXQzMkFycmF5KCB2ZXJ0aWNlcyAqIDIgKTtcclxuXHJcblx0Ly8gY2VudGVyIGRhdGEgaXMgYWxyZWFkeSB6ZXJvLCBidXQgbmVlZCB0byBzZXQgYSBmZXcgZXh0cmFzXHJcblx0bm9ybWFsc1sgMiBdID0gMS4wO1xyXG5cdHV2c1sgMCBdID0gMC41O1xyXG5cdHV2c1sgMSBdID0gMC41O1xyXG5cclxuXHRmb3IgKCB2YXIgcyA9IDAsIGkgPSAzLCBpaSA9IDIgOyBzIDw9IHNlZ21lbnRzOyBzICsrLCBpICs9IDMsIGlpICs9IDIgKSB7XHJcblxyXG5cdFx0dmFyIHNlZ21lbnQgPSB0aGV0YVN0YXJ0ICsgcyAvIHNlZ21lbnRzICogdGhldGFMZW5ndGg7XHJcblxyXG5cdFx0cG9zaXRpb25zWyBpIF0gPSByYWRpdXMgKiBNYXRoLmNvcyggc2VnbWVudCApO1xyXG5cdFx0cG9zaXRpb25zWyBpICsgMSBdID0gcmFkaXVzICogTWF0aC5zaW4oIHNlZ21lbnQgKTtcclxuXHJcblx0XHRub3JtYWxzWyBpICsgMiBdID0gMTsgLy8gbm9ybWFsIHpcclxuXHJcblx0XHR1dnNbIGlpIF0gPSAoIHBvc2l0aW9uc1sgaSBdIC8gcmFkaXVzICsgMSApIC8gMjtcclxuXHRcdHV2c1sgaWkgKyAxIF0gPSAoIHBvc2l0aW9uc1sgaSArIDEgXSAvIHJhZGl1cyArIDEgKSAvIDI7XHJcblxyXG5cdH1cclxuXHJcblx0dmFyIGluZGljZXMgPSBbXTtcclxuXHJcblx0Zm9yICggdmFyIGkgPSAxOyBpIDw9IHNlZ21lbnRzOyBpICsrICkge1xyXG5cclxuXHRcdGluZGljZXMucHVzaCggaSwgaSArIDEsIDAgKTtcclxuXHJcblx0fVxyXG5cclxuXHR0aGlzLnNldEluZGV4KCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgVWludDE2QXJyYXkoIGluZGljZXMgKSwgMSApICk7XHJcblx0dGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9ucywgMyApICk7XHJcblx0dGhpcy5hZGRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBub3JtYWxzLCAzICkgKTtcclxuXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3V2JywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcclxuXHJcblx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG5ldyBUSFJFRS5TcGhlcmUoIG5ldyBUSFJFRS5WZWN0b3IzKCksIHJhZGl1cyApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkNpcmNsZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG5USFJFRS5DaXJjbGVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5DaXJjbGVCdWZmZXJHZW9tZXRyeTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL0N5bGluZGVyR2VvbWV0cnkuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkN5bGluZGVyR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHJhZGl1c1RvcCwgcmFkaXVzQm90dG9tLCBoZWlnaHQsIHJhZGlhbFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgb3BlbkVuZGVkLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApIHtcclxuXHJcblx0VEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLnR5cGUgPSAnQ3lsaW5kZXJHZW9tZXRyeSc7XHJcblxyXG5cdHRoaXMucGFyYW1ldGVycyA9IHtcclxuXHRcdHJhZGl1c1RvcDogcmFkaXVzVG9wLFxyXG5cdFx0cmFkaXVzQm90dG9tOiByYWRpdXNCb3R0b20sXHJcblx0XHRoZWlnaHQ6IGhlaWdodCxcclxuXHRcdHJhZGlhbFNlZ21lbnRzOiByYWRpYWxTZWdtZW50cyxcclxuXHRcdGhlaWdodFNlZ21lbnRzOiBoZWlnaHRTZWdtZW50cyxcclxuXHRcdG9wZW5FbmRlZDogb3BlbkVuZGVkLFxyXG5cdFx0dGhldGFTdGFydDogdGhldGFTdGFydCxcclxuXHRcdHRoZXRhTGVuZ3RoOiB0aGV0YUxlbmd0aFxyXG5cdH07XHJcblxyXG5cdHJhZGl1c1RvcCA9IHJhZGl1c1RvcCAhPT0gdW5kZWZpbmVkID8gcmFkaXVzVG9wIDogMjA7XHJcblx0cmFkaXVzQm90dG9tID0gcmFkaXVzQm90dG9tICE9PSB1bmRlZmluZWQgPyByYWRpdXNCb3R0b20gOiAyMDtcclxuXHRoZWlnaHQgPSBoZWlnaHQgIT09IHVuZGVmaW5lZCA/IGhlaWdodCA6IDEwMDtcclxuXHJcblx0cmFkaWFsU2VnbWVudHMgPSByYWRpYWxTZWdtZW50cyB8fCA4O1xyXG5cdGhlaWdodFNlZ21lbnRzID0gaGVpZ2h0U2VnbWVudHMgfHwgMTtcclxuXHJcblx0b3BlbkVuZGVkID0gb3BlbkVuZGVkICE9PSB1bmRlZmluZWQgPyBvcGVuRW5kZWQgOiBmYWxzZTtcclxuXHR0aGV0YVN0YXJ0ID0gdGhldGFTdGFydCAhPT0gdW5kZWZpbmVkID8gdGhldGFTdGFydCA6IDA7XHJcblx0dGhldGFMZW5ndGggPSB0aGV0YUxlbmd0aCAhPT0gdW5kZWZpbmVkID8gdGhldGFMZW5ndGggOiAyICogTWF0aC5QSTtcclxuXHJcblx0dmFyIGhlaWdodEhhbGYgPSBoZWlnaHQgLyAyO1xyXG5cclxuXHR2YXIgeCwgeSwgdmVydGljZXMgPSBbXSwgdXZzID0gW107XHJcblxyXG5cdGZvciAoIHkgPSAwOyB5IDw9IGhlaWdodFNlZ21lbnRzOyB5ICsrICkge1xyXG5cclxuXHRcdHZhciB2ZXJ0aWNlc1JvdyA9IFtdO1xyXG5cdFx0dmFyIHV2c1JvdyA9IFtdO1xyXG5cclxuXHRcdHZhciB2ID0geSAvIGhlaWdodFNlZ21lbnRzO1xyXG5cdFx0dmFyIHJhZGl1cyA9IHYgKiAoIHJhZGl1c0JvdHRvbSAtIHJhZGl1c1RvcCApICsgcmFkaXVzVG9wO1xyXG5cclxuXHRcdGZvciAoIHggPSAwOyB4IDw9IHJhZGlhbFNlZ21lbnRzOyB4ICsrICkge1xyXG5cclxuXHRcdFx0dmFyIHUgPSB4IC8gcmFkaWFsU2VnbWVudHM7XHJcblxyXG5cdFx0XHR2YXIgdmVydGV4ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdFx0dmVydGV4LnggPSByYWRpdXMgKiBNYXRoLnNpbiggdSAqIHRoZXRhTGVuZ3RoICsgdGhldGFTdGFydCApO1xyXG5cdFx0XHR2ZXJ0ZXgueSA9IC0gdiAqIGhlaWdodCArIGhlaWdodEhhbGY7XHJcblx0XHRcdHZlcnRleC56ID0gcmFkaXVzICogTWF0aC5jb3MoIHUgKiB0aGV0YUxlbmd0aCArIHRoZXRhU3RhcnQgKTtcclxuXHJcblx0XHRcdHRoaXMudmVydGljZXMucHVzaCggdmVydGV4ICk7XHJcblxyXG5cdFx0XHR2ZXJ0aWNlc1Jvdy5wdXNoKCB0aGlzLnZlcnRpY2VzLmxlbmd0aCAtIDEgKTtcclxuXHRcdFx0dXZzUm93LnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCB1LCAxIC0gdiApICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZlcnRpY2VzLnB1c2goIHZlcnRpY2VzUm93ICk7XHJcblx0XHR1dnMucHVzaCggdXZzUm93ICk7XHJcblxyXG5cdH1cclxuXHJcblx0dmFyIHRhblRoZXRhID0gKCByYWRpdXNCb3R0b20gLSByYWRpdXNUb3AgKSAvIGhlaWdodDtcclxuXHR2YXIgbmEsIG5iO1xyXG5cclxuXHRmb3IgKCB4ID0gMDsgeCA8IHJhZGlhbFNlZ21lbnRzOyB4ICsrICkge1xyXG5cclxuXHRcdGlmICggcmFkaXVzVG9wICE9PSAwICkge1xyXG5cclxuXHRcdFx0bmEgPSB0aGlzLnZlcnRpY2VzWyB2ZXJ0aWNlc1sgMCBdWyB4IF0gXS5jbG9uZSgpO1xyXG5cdFx0XHRuYiA9IHRoaXMudmVydGljZXNbIHZlcnRpY2VzWyAwIF1bIHggKyAxIF0gXS5jbG9uZSgpO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRuYSA9IHRoaXMudmVydGljZXNbIHZlcnRpY2VzWyAxIF1bIHggXSBdLmNsb25lKCk7XHJcblx0XHRcdG5iID0gdGhpcy52ZXJ0aWNlc1sgdmVydGljZXNbIDEgXVsgeCArIDEgXSBdLmNsb25lKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdG5hLnNldFkoIE1hdGguc3FydCggbmEueCAqIG5hLnggKyBuYS56ICogbmEueiApICogdGFuVGhldGEgKS5ub3JtYWxpemUoKTtcclxuXHRcdG5iLnNldFkoIE1hdGguc3FydCggbmIueCAqIG5iLnggKyBuYi56ICogbmIueiApICogdGFuVGhldGEgKS5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRmb3IgKCB5ID0gMDsgeSA8IGhlaWdodFNlZ21lbnRzOyB5ICsrICkge1xyXG5cclxuXHRcdFx0dmFyIHYxID0gdmVydGljZXNbIHkgXVsgeCBdO1xyXG5cdFx0XHR2YXIgdjIgPSB2ZXJ0aWNlc1sgeSArIDEgXVsgeCBdO1xyXG5cdFx0XHR2YXIgdjMgPSB2ZXJ0aWNlc1sgeSArIDEgXVsgeCArIDEgXTtcclxuXHRcdFx0dmFyIHY0ID0gdmVydGljZXNbIHkgXVsgeCArIDEgXTtcclxuXHJcblx0XHRcdHZhciBuMSA9IG5hLmNsb25lKCk7XHJcblx0XHRcdHZhciBuMiA9IG5hLmNsb25lKCk7XHJcblx0XHRcdHZhciBuMyA9IG5iLmNsb25lKCk7XHJcblx0XHRcdHZhciBuNCA9IG5iLmNsb25lKCk7XHJcblxyXG5cdFx0XHR2YXIgdXYxID0gdXZzWyB5IF1bIHggXS5jbG9uZSgpO1xyXG5cdFx0XHR2YXIgdXYyID0gdXZzWyB5ICsgMSBdWyB4IF0uY2xvbmUoKTtcclxuXHRcdFx0dmFyIHV2MyA9IHV2c1sgeSArIDEgXVsgeCArIDEgXS5jbG9uZSgpO1xyXG5cdFx0XHR2YXIgdXY0ID0gdXZzWyB5IF1bIHggKyAxIF0uY2xvbmUoKTtcclxuXHJcblx0XHRcdHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCB2MSwgdjIsIHY0LCBbIG4xLCBuMiwgbjQgXSApICk7XHJcblx0XHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXYxLCB1djIsIHV2NCBdICk7XHJcblxyXG5cdFx0XHR0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggdjIsIHYzLCB2NCwgWyBuMi5jbG9uZSgpLCBuMywgbjQuY2xvbmUoKSBdICkgKTtcclxuXHRcdFx0dGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1djIuY2xvbmUoKSwgdXYzLCB1djQuY2xvbmUoKSBdICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdC8vIHRvcCBjYXBcclxuXHJcblx0aWYgKCBvcGVuRW5kZWQgPT09IGZhbHNlICYmIHJhZGl1c1RvcCA+IDAgKSB7XHJcblxyXG5cdFx0dGhpcy52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMyggMCwgaGVpZ2h0SGFsZiwgMCApICk7XHJcblxyXG5cdFx0Zm9yICggeCA9IDA7IHggPCByYWRpYWxTZWdtZW50czsgeCArKyApIHtcclxuXHJcblx0XHRcdHZhciB2MSA9IHZlcnRpY2VzWyAwIF1bIHggXTtcclxuXHRcdFx0dmFyIHYyID0gdmVydGljZXNbIDAgXVsgeCArIDEgXTtcclxuXHRcdFx0dmFyIHYzID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGggLSAxO1xyXG5cclxuXHRcdFx0dmFyIG4xID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDEsIDAgKTtcclxuXHRcdFx0dmFyIG4yID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDEsIDAgKTtcclxuXHRcdFx0dmFyIG4zID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDEsIDAgKTtcclxuXHJcblx0XHRcdHZhciB1djEgPSB1dnNbIDAgXVsgeCBdLmNsb25lKCk7XHJcblx0XHRcdHZhciB1djIgPSB1dnNbIDAgXVsgeCArIDEgXS5jbG9uZSgpO1xyXG5cdFx0XHR2YXIgdXYzID0gbmV3IFRIUkVFLlZlY3RvcjIoIHV2Mi54LCAwICk7XHJcblxyXG5cdFx0XHR0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggdjEsIHYyLCB2MywgWyBuMSwgbjIsIG4zIF0sIHVuZGVmaW5lZCwgMSApICk7XHJcblx0XHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXYxLCB1djIsIHV2MyBdICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdC8vIGJvdHRvbSBjYXBcclxuXHJcblx0aWYgKCBvcGVuRW5kZWQgPT09IGZhbHNlICYmIHJhZGl1c0JvdHRvbSA+IDAgKSB7XHJcblxyXG5cdFx0dGhpcy52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMyggMCwgLSBoZWlnaHRIYWxmLCAwICkgKTtcclxuXHJcblx0XHRmb3IgKCB4ID0gMDsgeCA8IHJhZGlhbFNlZ21lbnRzOyB4ICsrICkge1xyXG5cclxuXHRcdFx0dmFyIHYxID0gdmVydGljZXNbIGhlaWdodFNlZ21lbnRzIF1bIHggKyAxIF07XHJcblx0XHRcdHZhciB2MiA9IHZlcnRpY2VzWyBoZWlnaHRTZWdtZW50cyBdWyB4IF07XHJcblx0XHRcdHZhciB2MyA9IHRoaXMudmVydGljZXMubGVuZ3RoIC0gMTtcclxuXHJcblx0XHRcdHZhciBuMSA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAtIDEsIDAgKTtcclxuXHRcdFx0dmFyIG4yID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIC0gMSwgMCApO1xyXG5cdFx0XHR2YXIgbjMgPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgLSAxLCAwICk7XHJcblxyXG5cdFx0XHR2YXIgdXYxID0gdXZzWyBoZWlnaHRTZWdtZW50cyBdWyB4ICsgMSBdLmNsb25lKCk7XHJcblx0XHRcdHZhciB1djIgPSB1dnNbIGhlaWdodFNlZ21lbnRzIF1bIHggXS5jbG9uZSgpO1xyXG5cdFx0XHR2YXIgdXYzID0gbmV3IFRIUkVFLlZlY3RvcjIoIHV2Mi54LCAxICk7XHJcblxyXG5cdFx0XHR0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggdjEsIHYyLCB2MywgWyBuMSwgbjIsIG4zIF0sIHVuZGVmaW5lZCwgMiApICk7XHJcblx0XHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXYxLCB1djIsIHV2MyBdICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQ3lsaW5kZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuVEhSRUUuQ3lsaW5kZXJHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5DeWxpbmRlckdlb21ldHJ5O1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvRWRnZXNHZW9tZXRyeS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxyXG4gKi9cclxuXHJcblRIUkVFLkVkZ2VzR2VvbWV0cnkgPSBmdW5jdGlvbiAoIGdlb21ldHJ5LCB0aHJlc2hvbGRBbmdsZSApIHtcclxuXHJcblx0VEhSRUUuQnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aHJlc2hvbGRBbmdsZSA9ICggdGhyZXNob2xkQW5nbGUgIT09IHVuZGVmaW5lZCApID8gdGhyZXNob2xkQW5nbGUgOiAxO1xyXG5cclxuXHR2YXIgdGhyZXNob2xkRG90ID0gTWF0aC5jb3MoIFRIUkVFLk1hdGguZGVnVG9SYWQoIHRocmVzaG9sZEFuZ2xlICkgKTtcclxuXHJcblx0dmFyIGVkZ2UgPSBbIDAsIDAgXSwgaGFzaCA9IHt9O1xyXG5cclxuXHRmdW5jdGlvbiBzb3J0RnVuY3Rpb24oIGEsIGIgKSB7XHJcblxyXG5cdFx0cmV0dXJuIGEgLSBiO1xyXG5cclxuXHR9XHJcblxyXG5cdHZhciBrZXlzID0gWyAnYScsICdiJywgJ2MnIF07XHJcblxyXG5cdHZhciBnZW9tZXRyeTI7XHJcblxyXG5cdGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSApIHtcclxuXHJcblx0XHRnZW9tZXRyeTIgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcclxuXHRcdGdlb21ldHJ5Mi5mcm9tQnVmZmVyR2VvbWV0cnkoIGdlb21ldHJ5ICk7XHJcblxyXG5cdH0gZWxzZSB7XHJcblxyXG5cdFx0Z2VvbWV0cnkyID0gZ2VvbWV0cnkuY2xvbmUoKTtcclxuXHJcblx0fVxyXG5cclxuXHRnZW9tZXRyeTIubWVyZ2VWZXJ0aWNlcygpO1xyXG5cdGdlb21ldHJ5Mi5jb21wdXRlRmFjZU5vcm1hbHMoKTtcclxuXHJcblx0dmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkyLnZlcnRpY2VzO1xyXG5cdHZhciBmYWNlcyA9IGdlb21ldHJ5Mi5mYWNlcztcclxuXHJcblx0Zm9yICggdmFyIGkgPSAwLCBsID0gZmFjZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHR2YXIgZmFjZSA9IGZhY2VzWyBpIF07XHJcblxyXG5cdFx0Zm9yICggdmFyIGogPSAwOyBqIDwgMzsgaiArKyApIHtcclxuXHJcblx0XHRcdGVkZ2VbIDAgXSA9IGZhY2VbIGtleXNbIGogXSBdO1xyXG5cdFx0XHRlZGdlWyAxIF0gPSBmYWNlWyBrZXlzWyAoIGogKyAxICkgJSAzIF0gXTtcclxuXHRcdFx0ZWRnZS5zb3J0KCBzb3J0RnVuY3Rpb24gKTtcclxuXHJcblx0XHRcdHZhciBrZXkgPSBlZGdlLnRvU3RyaW5nKCk7XHJcblxyXG5cdFx0XHRpZiAoIGhhc2hbIGtleSBdID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGhhc2hbIGtleSBdID0geyB2ZXJ0MTogZWRnZVsgMCBdLCB2ZXJ0MjogZWRnZVsgMSBdLCBmYWNlMTogaSwgZmFjZTI6IHVuZGVmaW5lZCB9O1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0aGFzaFsga2V5IF0uZmFjZTIgPSBpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHR2YXIgY29vcmRzID0gW107XHJcblxyXG5cdGZvciAoIHZhciBrZXkgaW4gaGFzaCApIHtcclxuXHJcblx0XHR2YXIgaCA9IGhhc2hbIGtleSBdO1xyXG5cclxuXHRcdGlmICggaC5mYWNlMiA9PT0gdW5kZWZpbmVkIHx8IGZhY2VzWyBoLmZhY2UxIF0ubm9ybWFsLmRvdCggZmFjZXNbIGguZmFjZTIgXS5ub3JtYWwgKSA8PSB0aHJlc2hvbGREb3QgKSB7XHJcblxyXG5cdFx0XHR2YXIgdmVydGV4ID0gdmVydGljZXNbIGgudmVydDEgXTtcclxuXHRcdFx0Y29vcmRzLnB1c2goIHZlcnRleC54ICk7XHJcblx0XHRcdGNvb3Jkcy5wdXNoKCB2ZXJ0ZXgueSApO1xyXG5cdFx0XHRjb29yZHMucHVzaCggdmVydGV4LnogKTtcclxuXHJcblx0XHRcdHZlcnRleCA9IHZlcnRpY2VzWyBoLnZlcnQyIF07XHJcblx0XHRcdGNvb3Jkcy5wdXNoKCB2ZXJ0ZXgueCApO1xyXG5cdFx0XHRjb29yZHMucHVzaCggdmVydGV4LnkgKTtcclxuXHRcdFx0Y29vcmRzLnB1c2goIHZlcnRleC56ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgRmxvYXQzMkFycmF5KCBjb29yZHMgKSwgMyApICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuRWRnZXNHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5CdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuVEhSRUUuRWRnZXNHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5FZGdlc0dlb21ldHJ5O1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvRXh0cnVkZUdlb21ldHJ5LmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xyXG4gKlxyXG4gKiBDcmVhdGVzIGV4dHJ1ZGVkIGdlb21ldHJ5IGZyb20gYSBwYXRoIHNoYXBlLlxyXG4gKlxyXG4gKiBwYXJhbWV0ZXJzID0ge1xyXG4gKlxyXG4gKiAgY3VydmVTZWdtZW50czogPGludD4sIC8vIG51bWJlciBvZiBwb2ludHMgb24gdGhlIGN1cnZlc1xyXG4gKiAgc3RlcHM6IDxpbnQ+LCAvLyBudW1iZXIgb2YgcG9pbnRzIGZvciB6LXNpZGUgZXh0cnVzaW9ucyAvIHVzZWQgZm9yIHN1YmRpdmlkaW5nIHNlZ21lbnRzIG9mIGV4dHJ1ZGUgc3BsaW5lIHRvb1xyXG4gKiAgYW1vdW50OiA8aW50PiwgLy8gRGVwdGggdG8gZXh0cnVkZSB0aGUgc2hhcGVcclxuICpcclxuICogIGJldmVsRW5hYmxlZDogPGJvb2w+LCAvLyB0dXJuIG9uIGJldmVsXHJcbiAqICBiZXZlbFRoaWNrbmVzczogPGZsb2F0PiwgLy8gaG93IGRlZXAgaW50byB0aGUgb3JpZ2luYWwgc2hhcGUgYmV2ZWwgZ29lc1xyXG4gKiAgYmV2ZWxTaXplOiA8ZmxvYXQ+LCAvLyBob3cgZmFyIGZyb20gc2hhcGUgb3V0bGluZSBpcyBiZXZlbFxyXG4gKiAgYmV2ZWxTZWdtZW50czogPGludD4sIC8vIG51bWJlciBvZiBiZXZlbCBsYXllcnNcclxuICpcclxuICogIGV4dHJ1ZGVQYXRoOiA8VEhSRUUuQ3VydmVQYXRoPiAvLyAzZCBzcGxpbmUgcGF0aCB0byBleHRydWRlIHNoYXBlIGFsb25nLiAoY3JlYXRlcyBGcmFtZXMgaWYgLmZyYW1lcyBhcmVuJ3QgZGVmaW5lZClcclxuICogIGZyYW1lczogPFRIUkVFLlR1YmVHZW9tZXRyeS5GcmVuZXRGcmFtZXM+IC8vIGNvbnRhaW5pbmcgYXJyYXlzIG9mIHRhbmdlbnRzLCBub3JtYWxzLCBiaW5vcm1hbHNcclxuICpcclxuICogIHV2R2VuZXJhdG9yOiA8T2JqZWN0PiAvLyBvYmplY3QgdGhhdCBwcm92aWRlcyBVViBnZW5lcmF0b3IgZnVuY3Rpb25zXHJcbiAqXHJcbiAqIH1cclxuICoqL1xyXG5cclxuVEhSRUUuRXh0cnVkZUdlb21ldHJ5ID0gZnVuY3Rpb24gKCBzaGFwZXMsIG9wdGlvbnMgKSB7XHJcblxyXG5cdGlmICggdHlwZW9mKCBzaGFwZXMgKSA9PT0gXCJ1bmRlZmluZWRcIiApIHtcclxuXHJcblx0XHRzaGFwZXMgPSBbXTtcclxuXHRcdHJldHVybjtcclxuXHJcblx0fVxyXG5cclxuXHRUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMudHlwZSA9ICdFeHRydWRlR2VvbWV0cnknO1xyXG5cclxuXHRzaGFwZXMgPSBBcnJheS5pc0FycmF5KCBzaGFwZXMgKSA/IHNoYXBlcyA6IFsgc2hhcGVzIF07XHJcblxyXG5cdHRoaXMuYWRkU2hhcGVMaXN0KCBzaGFwZXMsIG9wdGlvbnMgKTtcclxuXHJcblx0dGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcclxuXHJcblx0Ly8gY2FuJ3QgcmVhbGx5IHVzZSBhdXRvbWF0aWMgdmVydGV4IG5vcm1hbHNcclxuXHQvLyBhcyB0aGVuIGZyb250IGFuZCBiYWNrIHNpZGVzIGdldCBzbW9vdGhlZCB0b29cclxuXHQvLyBzaG91bGQgZG8gc2VwYXJhdGUgc21vb3RoaW5nIGp1c3QgZm9yIHNpZGVzXHJcblxyXG5cdC8vdGhpcy5jb21wdXRlVmVydGV4Tm9ybWFscygpO1xyXG5cclxuXHQvL2NvbnNvbGUubG9nKCBcInRvb2tcIiwgKCBEYXRlLm5vdygpIC0gc3RhcnRUaW1lICkgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5FeHRydWRlR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XHJcblRIUkVFLkV4dHJ1ZGVHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5FeHRydWRlR2VvbWV0cnk7XHJcblxyXG5USFJFRS5FeHRydWRlR2VvbWV0cnkucHJvdG90eXBlLmFkZFNoYXBlTGlzdCA9IGZ1bmN0aW9uICggc2hhcGVzLCBvcHRpb25zICkge1xyXG5cclxuXHR2YXIgc2wgPSBzaGFwZXMubGVuZ3RoO1xyXG5cclxuXHRmb3IgKCB2YXIgcyA9IDA7IHMgPCBzbDsgcyArKyApIHtcclxuXHJcblx0XHR2YXIgc2hhcGUgPSBzaGFwZXNbIHMgXTtcclxuXHRcdHRoaXMuYWRkU2hhcGUoIHNoYXBlLCBvcHRpb25zICk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5FeHRydWRlR2VvbWV0cnkucHJvdG90eXBlLmFkZFNoYXBlID0gZnVuY3Rpb24gKCBzaGFwZSwgb3B0aW9ucyApIHtcclxuXHJcblx0dmFyIGFtb3VudCA9IG9wdGlvbnMuYW1vdW50ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmFtb3VudCA6IDEwMDtcclxuXHJcblx0dmFyIGJldmVsVGhpY2tuZXNzID0gb3B0aW9ucy5iZXZlbFRoaWNrbmVzcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5iZXZlbFRoaWNrbmVzcyA6IDY7IC8vIDEwXHJcblx0dmFyIGJldmVsU2l6ZSA9IG9wdGlvbnMuYmV2ZWxTaXplICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmJldmVsU2l6ZSA6IGJldmVsVGhpY2tuZXNzIC0gMjsgLy8gOFxyXG5cdHZhciBiZXZlbFNlZ21lbnRzID0gb3B0aW9ucy5iZXZlbFNlZ21lbnRzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmJldmVsU2VnbWVudHMgOiAzO1xyXG5cclxuXHR2YXIgYmV2ZWxFbmFibGVkID0gb3B0aW9ucy5iZXZlbEVuYWJsZWQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYmV2ZWxFbmFibGVkIDogdHJ1ZTsgLy8gZmFsc2VcclxuXHJcblx0dmFyIGN1cnZlU2VnbWVudHMgPSBvcHRpb25zLmN1cnZlU2VnbWVudHMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY3VydmVTZWdtZW50cyA6IDEyO1xyXG5cclxuXHR2YXIgc3RlcHMgPSBvcHRpb25zLnN0ZXBzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnN0ZXBzIDogMTtcclxuXHJcblx0dmFyIGV4dHJ1ZGVQYXRoID0gb3B0aW9ucy5leHRydWRlUGF0aDtcclxuXHR2YXIgZXh0cnVkZVB0cywgZXh0cnVkZUJ5UGF0aCA9IGZhbHNlO1xyXG5cclxuXHQvLyBVc2UgZGVmYXVsdCBXb3JsZFVWR2VuZXJhdG9yIGlmIG5vIFVWIGdlbmVyYXRvcnMgYXJlIHNwZWNpZmllZC5cclxuXHR2YXIgdXZnZW4gPSBvcHRpb25zLlVWR2VuZXJhdG9yICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLlVWR2VuZXJhdG9yIDogVEhSRUUuRXh0cnVkZUdlb21ldHJ5LldvcmxkVVZHZW5lcmF0b3I7XHJcblxyXG5cdHZhciBzcGxpbmVUdWJlLCBiaW5vcm1hbCwgbm9ybWFsLCBwb3NpdGlvbjI7XHJcblx0aWYgKCBleHRydWRlUGF0aCApIHtcclxuXHJcblx0XHRleHRydWRlUHRzID0gZXh0cnVkZVBhdGguZ2V0U3BhY2VkUG9pbnRzKCBzdGVwcyApO1xyXG5cclxuXHRcdGV4dHJ1ZGVCeVBhdGggPSB0cnVlO1xyXG5cdFx0YmV2ZWxFbmFibGVkID0gZmFsc2U7IC8vIGJldmVscyBub3Qgc3VwcG9ydGVkIGZvciBwYXRoIGV4dHJ1c2lvblxyXG5cclxuXHRcdC8vIFNFVFVQIFROQiB2YXJpYWJsZXNcclxuXHJcblx0XHQvLyBSZXVzZSBUTkIgZnJvbSBUdWJlR2VvbXRyeSBmb3Igbm93LlxyXG5cdFx0Ly8gVE9ETzEgLSBoYXZlIGEgLmlzQ2xvc2VkIGluIHNwbGluZT9cclxuXHJcblx0XHRzcGxpbmVUdWJlID0gb3B0aW9ucy5mcmFtZXMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZnJhbWVzIDogbmV3IFRIUkVFLlR1YmVHZW9tZXRyeS5GcmVuZXRGcmFtZXMoIGV4dHJ1ZGVQYXRoLCBzdGVwcywgZmFsc2UgKTtcclxuXHJcblx0XHQvLyBjb25zb2xlLmxvZyhzcGxpbmVUdWJlLCAnc3BsaW5lVHViZScsIHNwbGluZVR1YmUubm9ybWFscy5sZW5ndGgsICdzdGVwcycsIHN0ZXBzLCAnZXh0cnVkZVB0cycsIGV4dHJ1ZGVQdHMubGVuZ3RoKTtcclxuXHJcblx0XHRiaW5vcm1hbCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHRub3JtYWwgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0cG9zaXRpb24yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0fVxyXG5cclxuXHQvLyBTYWZlZ3VhcmRzIGlmIGJldmVscyBhcmUgbm90IGVuYWJsZWRcclxuXHJcblx0aWYgKCAhIGJldmVsRW5hYmxlZCApIHtcclxuXHJcblx0XHRiZXZlbFNlZ21lbnRzID0gMDtcclxuXHRcdGJldmVsVGhpY2tuZXNzID0gMDtcclxuXHRcdGJldmVsU2l6ZSA9IDA7XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gVmFyaWFibGVzIGluaXRpYWxpemF0aW9uXHJcblxyXG5cdHZhciBhaG9sZSwgaCwgaGw7IC8vIGxvb3Bpbmcgb2YgaG9sZXNcclxuXHR2YXIgc2NvcGUgPSB0aGlzO1xyXG5cclxuXHR2YXIgc2hhcGVzT2Zmc2V0ID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7XHJcblxyXG5cdHZhciBzaGFwZVBvaW50cyA9IHNoYXBlLmV4dHJhY3RQb2ludHMoIGN1cnZlU2VnbWVudHMgKTtcclxuXHJcblx0dmFyIHZlcnRpY2VzID0gc2hhcGVQb2ludHMuc2hhcGU7XHJcblx0dmFyIGhvbGVzID0gc2hhcGVQb2ludHMuaG9sZXM7XHJcblxyXG5cdHZhciByZXZlcnNlID0gISBUSFJFRS5TaGFwZVV0aWxzLmlzQ2xvY2tXaXNlKCB2ZXJ0aWNlcyApO1xyXG5cclxuXHRpZiAoIHJldmVyc2UgKSB7XHJcblxyXG5cdFx0dmVydGljZXMgPSB2ZXJ0aWNlcy5yZXZlcnNlKCk7XHJcblxyXG5cdFx0Ly8gTWF5YmUgd2Ugc2hvdWxkIGFsc28gY2hlY2sgaWYgaG9sZXMgYXJlIGluIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb24sIGp1c3QgdG8gYmUgc2FmZSAuLi5cclxuXHJcblx0XHRmb3IgKCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcclxuXHJcblx0XHRcdGFob2xlID0gaG9sZXNbIGggXTtcclxuXHJcblx0XHRcdGlmICggVEhSRUUuU2hhcGVVdGlscy5pc0Nsb2NrV2lzZSggYWhvbGUgKSApIHtcclxuXHJcblx0XHRcdFx0aG9sZXNbIGggXSA9IGFob2xlLnJldmVyc2UoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV2ZXJzZSA9IGZhbHNlOyAvLyBJZiB2ZXJ0aWNlcyBhcmUgaW4gb3JkZXIgbm93LCB3ZSBzaG91bGRuJ3QgbmVlZCB0byB3b3JyeSBhYm91dCB0aGVtIGFnYWluIChob3BlZnVsbHkpIVxyXG5cclxuXHR9XHJcblxyXG5cclxuXHR2YXIgZmFjZXMgPSBUSFJFRS5TaGFwZVV0aWxzLnRyaWFuZ3VsYXRlU2hhcGUoIHZlcnRpY2VzLCBob2xlcyApO1xyXG5cclxuXHQvKiBWZXJ0aWNlcyAqL1xyXG5cclxuXHR2YXIgY29udG91ciA9IHZlcnRpY2VzOyAvLyB2ZXJ0aWNlcyBoYXMgYWxsIHBvaW50cyBidXQgY29udG91ciBoYXMgb25seSBwb2ludHMgb2YgY2lyY3VtZmVyZW5jZVxyXG5cclxuXHRmb3IgKCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcclxuXHJcblx0XHRhaG9sZSA9IGhvbGVzWyBoIF07XHJcblxyXG5cdFx0dmVydGljZXMgPSB2ZXJ0aWNlcy5jb25jYXQoIGFob2xlICk7XHJcblxyXG5cdH1cclxuXHJcblxyXG5cdGZ1bmN0aW9uIHNjYWxlUHQyICggcHQsIHZlYywgc2l6ZSApIHtcclxuXHJcblx0XHRpZiAoICEgdmVjICkgY29uc29sZS5lcnJvciggXCJUSFJFRS5FeHRydWRlR2VvbWV0cnk6IHZlYyBkb2VzIG5vdCBleGlzdFwiICk7XHJcblxyXG5cdFx0cmV0dXJuIHZlYy5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKCBzaXplICkuYWRkKCBwdCApO1xyXG5cclxuXHR9XHJcblxyXG5cdHZhciBiLCBicywgdCwgeixcclxuXHRcdHZlcnQsIHZsZW4gPSB2ZXJ0aWNlcy5sZW5ndGgsXHJcblx0XHRmYWNlLCBmbGVuID0gZmFjZXMubGVuZ3RoO1xyXG5cclxuXHJcblx0Ly8gRmluZCBkaXJlY3Rpb25zIGZvciBwb2ludCBtb3ZlbWVudFxyXG5cclxuXHJcblx0ZnVuY3Rpb24gZ2V0QmV2ZWxWZWMoIGluUHQsIGluUHJldiwgaW5OZXh0ICkge1xyXG5cclxuXHRcdC8vIGNvbXB1dGVzIGZvciBpblB0IHRoZSBjb3JyZXNwb25kaW5nIHBvaW50IGluUHQnIG9uIGEgbmV3IGNvbnRvdXJcclxuXHRcdC8vICAgc2hpZnRlZCBieSAxIHVuaXQgKGxlbmd0aCBvZiBub3JtYWxpemVkIHZlY3RvcikgdG8gdGhlIGxlZnRcclxuXHRcdC8vIGlmIHdlIHdhbGsgYWxvbmcgY29udG91ciBjbG9ja3dpc2UsIHRoaXMgbmV3IGNvbnRvdXIgaXMgb3V0c2lkZSB0aGUgb2xkIG9uZVxyXG5cdFx0Ly9cclxuXHRcdC8vIGluUHQnIGlzIHRoZSBpbnRlcnNlY3Rpb24gb2YgdGhlIHR3byBsaW5lcyBwYXJhbGxlbCB0byB0aGUgdHdvXHJcblx0XHQvLyAgYWRqYWNlbnQgZWRnZXMgb2YgaW5QdCBhdCBhIGRpc3RhbmNlIG9mIDEgdW5pdCBvbiB0aGUgbGVmdCBzaWRlLlxyXG5cclxuXHRcdHZhciB2X3RyYW5zX3gsIHZfdHJhbnNfeSwgc2hyaW5rX2J5ID0gMTtcdFx0Ly8gcmVzdWx0aW5nIHRyYW5zbGF0aW9uIHZlY3RvciBmb3IgaW5QdFxyXG5cclxuXHRcdC8vIGdvb2QgcmVhZGluZyBmb3IgZ2VvbWV0cnkgYWxnb3JpdGhtcyAoaGVyZTogbGluZS1saW5lIGludGVyc2VjdGlvbilcclxuXHRcdC8vIGh0dHA6Ly9nZW9tYWxnb3JpdGhtcy5jb20vYTA1LV9pbnRlcnNlY3QtMS5odG1sXHJcblxyXG5cdFx0dmFyIHZfcHJldl94ID0gaW5QdC54IC0gaW5QcmV2LngsIHZfcHJldl95ID0gaW5QdC55IC0gaW5QcmV2Lnk7XHJcblx0XHR2YXIgdl9uZXh0X3ggPSBpbk5leHQueCAtIGluUHQueCwgdl9uZXh0X3kgPSBpbk5leHQueSAtIGluUHQueTtcclxuXHJcblx0XHR2YXIgdl9wcmV2X2xlbnNxID0gKCB2X3ByZXZfeCAqIHZfcHJldl94ICsgdl9wcmV2X3kgKiB2X3ByZXZfeSApO1xyXG5cclxuXHRcdC8vIGNoZWNrIGZvciBjb2xsaW5lYXIgZWRnZXNcclxuXHRcdHZhciBjb2xsaW5lYXIwID0gKCB2X3ByZXZfeCAqIHZfbmV4dF95IC0gdl9wcmV2X3kgKiB2X25leHRfeCApO1xyXG5cclxuXHRcdGlmICggTWF0aC5hYnMoIGNvbGxpbmVhcjAgKSA+IE51bWJlci5FUFNJTE9OICkge1xyXG5cclxuXHRcdFx0Ly8gbm90IGNvbGxpbmVhclxyXG5cclxuXHRcdFx0Ly8gbGVuZ3RoIG9mIHZlY3RvcnMgZm9yIG5vcm1hbGl6aW5nXHJcblxyXG5cdFx0XHR2YXIgdl9wcmV2X2xlbiA9IE1hdGguc3FydCggdl9wcmV2X2xlbnNxICk7XHJcblx0XHRcdHZhciB2X25leHRfbGVuID0gTWF0aC5zcXJ0KCB2X25leHRfeCAqIHZfbmV4dF94ICsgdl9uZXh0X3kgKiB2X25leHRfeSApO1xyXG5cclxuXHRcdFx0Ly8gc2hpZnQgYWRqYWNlbnQgcG9pbnRzIGJ5IHVuaXQgdmVjdG9ycyB0byB0aGUgbGVmdFxyXG5cclxuXHRcdFx0dmFyIHB0UHJldlNoaWZ0X3ggPSAoIGluUHJldi54IC0gdl9wcmV2X3kgLyB2X3ByZXZfbGVuICk7XHJcblx0XHRcdHZhciBwdFByZXZTaGlmdF95ID0gKCBpblByZXYueSArIHZfcHJldl94IC8gdl9wcmV2X2xlbiApO1xyXG5cclxuXHRcdFx0dmFyIHB0TmV4dFNoaWZ0X3ggPSAoIGluTmV4dC54IC0gdl9uZXh0X3kgLyB2X25leHRfbGVuICk7XHJcblx0XHRcdHZhciBwdE5leHRTaGlmdF95ID0gKCBpbk5leHQueSArIHZfbmV4dF94IC8gdl9uZXh0X2xlbiApO1xyXG5cclxuXHRcdFx0Ly8gc2NhbGluZyBmYWN0b3IgZm9yIHZfcHJldiB0byBpbnRlcnNlY3Rpb24gcG9pbnRcclxuXHJcblx0XHRcdHZhciBzZiA9ICggICggcHROZXh0U2hpZnRfeCAtIHB0UHJldlNoaWZ0X3ggKSAqIHZfbmV4dF95IC1cclxuXHRcdFx0XHRcdFx0KCBwdE5leHRTaGlmdF95IC0gcHRQcmV2U2hpZnRfeSApICogdl9uZXh0X3ggICAgKSAvXHJcblx0XHRcdFx0XHQgICggdl9wcmV2X3ggKiB2X25leHRfeSAtIHZfcHJldl95ICogdl9uZXh0X3ggKTtcclxuXHJcblx0XHRcdC8vIHZlY3RvciBmcm9tIGluUHQgdG8gaW50ZXJzZWN0aW9uIHBvaW50XHJcblxyXG5cdFx0XHR2X3RyYW5zX3ggPSAoIHB0UHJldlNoaWZ0X3ggKyB2X3ByZXZfeCAqIHNmIC0gaW5QdC54ICk7XHJcblx0XHRcdHZfdHJhbnNfeSA9ICggcHRQcmV2U2hpZnRfeSArIHZfcHJldl95ICogc2YgLSBpblB0LnkgKTtcclxuXHJcblx0XHRcdC8vIERvbid0IG5vcm1hbGl6ZSEsIG90aGVyd2lzZSBzaGFycCBjb3JuZXJzIGJlY29tZSB1Z2x5XHJcblx0XHRcdC8vICBidXQgcHJldmVudCBjcmF6eSBzcGlrZXNcclxuXHRcdFx0dmFyIHZfdHJhbnNfbGVuc3EgPSAoIHZfdHJhbnNfeCAqIHZfdHJhbnNfeCArIHZfdHJhbnNfeSAqIHZfdHJhbnNfeSApO1xyXG5cdFx0XHRpZiAoIHZfdHJhbnNfbGVuc3EgPD0gMiApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuXHRuZXcgVEhSRUUuVmVjdG9yMiggdl90cmFuc194LCB2X3RyYW5zX3kgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHNocmlua19ieSA9IE1hdGguc3FydCggdl90cmFuc19sZW5zcSAvIDIgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0Ly8gaGFuZGxlIHNwZWNpYWwgY2FzZSBvZiBjb2xsaW5lYXIgZWRnZXNcclxuXHJcblx0XHRcdHZhciBkaXJlY3Rpb25fZXEgPSBmYWxzZTtcdFx0Ly8gYXNzdW1lczogb3Bwb3NpdGVcclxuXHRcdFx0aWYgKCB2X3ByZXZfeCA+IE51bWJlci5FUFNJTE9OICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIHZfbmV4dF94ID4gTnVtYmVyLkVQU0lMT04gKSB7XHJcblxyXG5cdFx0XHRcdFx0ZGlyZWN0aW9uX2VxID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0aWYgKCB2X3ByZXZfeCA8IC0gTnVtYmVyLkVQU0lMT04gKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCB2X25leHRfeCA8IC0gTnVtYmVyLkVQU0lMT04gKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRkaXJlY3Rpb25fZXEgPSB0cnVlO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIE1hdGguc2lnbiggdl9wcmV2X3kgKSA9PT0gTWF0aC5zaWduKCB2X25leHRfeSApICkge1xyXG5cclxuXHRcdFx0XHRcdFx0ZGlyZWN0aW9uX2VxID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggZGlyZWN0aW9uX2VxICkge1xyXG5cclxuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyhcIldhcm5pbmc6IGxpbmVzIGFyZSBhIHN0cmFpZ2h0IHNlcXVlbmNlXCIpO1xyXG5cdFx0XHRcdHZfdHJhbnNfeCA9IC0gdl9wcmV2X3k7XHJcblx0XHRcdFx0dl90cmFuc195ID0gIHZfcHJldl94O1xyXG5cdFx0XHRcdHNocmlua19ieSA9IE1hdGguc3FydCggdl9wcmV2X2xlbnNxICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyhcIldhcm5pbmc6IGxpbmVzIGFyZSBhIHN0cmFpZ2h0IHNwaWtlXCIpO1xyXG5cdFx0XHRcdHZfdHJhbnNfeCA9IHZfcHJldl94O1xyXG5cdFx0XHRcdHZfdHJhbnNfeSA9IHZfcHJldl95O1xyXG5cdFx0XHRcdHNocmlua19ieSA9IE1hdGguc3FydCggdl9wcmV2X2xlbnNxIC8gMiApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm5cdG5ldyBUSFJFRS5WZWN0b3IyKCB2X3RyYW5zX3ggLyBzaHJpbmtfYnksIHZfdHJhbnNfeSAvIHNocmlua19ieSApO1xyXG5cclxuXHR9XHJcblxyXG5cclxuXHR2YXIgY29udG91ck1vdmVtZW50cyA9IFtdO1xyXG5cclxuXHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gY29udG91ci5sZW5ndGgsIGogPSBpbCAtIDEsIGsgPSBpICsgMTsgaSA8IGlsOyBpICsrLCBqICsrLCBrICsrICkge1xyXG5cclxuXHRcdGlmICggaiA9PT0gaWwgKSBqID0gMDtcclxuXHRcdGlmICggayA9PT0gaWwgKSBrID0gMDtcclxuXHJcblx0XHQvLyAgKGopLS0tKGkpLS0tKGspXHJcblx0XHQvLyBjb25zb2xlLmxvZygnaSxqLGsnLCBpLCBqICwgaylcclxuXHJcblx0XHRjb250b3VyTW92ZW1lbnRzWyBpIF0gPSBnZXRCZXZlbFZlYyggY29udG91clsgaSBdLCBjb250b3VyWyBqIF0sIGNvbnRvdXJbIGsgXSApO1xyXG5cclxuXHR9XHJcblxyXG5cdHZhciBob2xlc01vdmVtZW50cyA9IFtdLCBvbmVIb2xlTW92ZW1lbnRzLCB2ZXJ0aWNlc01vdmVtZW50cyA9IGNvbnRvdXJNb3ZlbWVudHMuY29uY2F0KCk7XHJcblxyXG5cdGZvciAoIGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoICsrICkge1xyXG5cclxuXHRcdGFob2xlID0gaG9sZXNbIGggXTtcclxuXHJcblx0XHRvbmVIb2xlTW92ZW1lbnRzID0gW107XHJcblxyXG5cdFx0Zm9yICggaSA9IDAsIGlsID0gYWhvbGUubGVuZ3RoLCBqID0gaWwgLSAxLCBrID0gaSArIDE7IGkgPCBpbDsgaSArKywgaiArKywgayArKyApIHtcclxuXHJcblx0XHRcdGlmICggaiA9PT0gaWwgKSBqID0gMDtcclxuXHRcdFx0aWYgKCBrID09PSBpbCApIGsgPSAwO1xyXG5cclxuXHRcdFx0Ly8gIChqKS0tLShpKS0tLShrKVxyXG5cdFx0XHRvbmVIb2xlTW92ZW1lbnRzWyBpIF0gPSBnZXRCZXZlbFZlYyggYWhvbGVbIGkgXSwgYWhvbGVbIGogXSwgYWhvbGVbIGsgXSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRob2xlc01vdmVtZW50cy5wdXNoKCBvbmVIb2xlTW92ZW1lbnRzICk7XHJcblx0XHR2ZXJ0aWNlc01vdmVtZW50cyA9IHZlcnRpY2VzTW92ZW1lbnRzLmNvbmNhdCggb25lSG9sZU1vdmVtZW50cyApO1xyXG5cclxuXHR9XHJcblxyXG5cclxuXHQvLyBMb29wIGJldmVsU2VnbWVudHMsIDEgZm9yIHRoZSBmcm9udCwgMSBmb3IgdGhlIGJhY2tcclxuXHJcblx0Zm9yICggYiA9IDA7IGIgPCBiZXZlbFNlZ21lbnRzOyBiICsrICkge1xyXG5cclxuXHRcdC8vZm9yICggYiA9IGJldmVsU2VnbWVudHM7IGIgPiAwOyBiIC0tICkge1xyXG5cclxuXHRcdHQgPSBiIC8gYmV2ZWxTZWdtZW50cztcclxuXHRcdHogPSBiZXZlbFRoaWNrbmVzcyAqICggMSAtIHQgKTtcclxuXHJcblx0XHQvL3ogPSBiZXZlbFRoaWNrbmVzcyAqIHQ7XHJcblx0XHRicyA9IGJldmVsU2l6ZSAqICggTWF0aC5zaW4gKCB0ICogTWF0aC5QSSAvIDIgKSApOyAvLyBjdXJ2ZWRcclxuXHRcdC8vYnMgPSBiZXZlbFNpemUgKiB0OyAvLyBsaW5lYXJcclxuXHJcblx0XHQvLyBjb250cmFjdCBzaGFwZVxyXG5cclxuXHRcdGZvciAoIGkgPSAwLCBpbCA9IGNvbnRvdXIubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2ZXJ0ID0gc2NhbGVQdDIoIGNvbnRvdXJbIGkgXSwgY29udG91ck1vdmVtZW50c1sgaSBdLCBicyApO1xyXG5cclxuXHRcdFx0diggdmVydC54LCB2ZXJ0LnksICAtIHogKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gZXhwYW5kIGhvbGVzXHJcblxyXG5cdFx0Zm9yICggaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyBoIDwgaGw7IGggKysgKSB7XHJcblxyXG5cdFx0XHRhaG9sZSA9IGhvbGVzWyBoIF07XHJcblx0XHRcdG9uZUhvbGVNb3ZlbWVudHMgPSBob2xlc01vdmVtZW50c1sgaCBdO1xyXG5cclxuXHRcdFx0Zm9yICggaSA9IDAsIGlsID0gYWhvbGUubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHZlcnQgPSBzY2FsZVB0MiggYWhvbGVbIGkgXSwgb25lSG9sZU1vdmVtZW50c1sgaSBdLCBicyApO1xyXG5cclxuXHRcdFx0XHR2KCB2ZXJ0LngsIHZlcnQueSwgIC0geiApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRicyA9IGJldmVsU2l6ZTtcclxuXHJcblx0Ly8gQmFjayBmYWNpbmcgdmVydGljZXNcclxuXHJcblx0Zm9yICggaSA9IDA7IGkgPCB2bGVuOyBpICsrICkge1xyXG5cclxuXHRcdHZlcnQgPSBiZXZlbEVuYWJsZWQgPyBzY2FsZVB0MiggdmVydGljZXNbIGkgXSwgdmVydGljZXNNb3ZlbWVudHNbIGkgXSwgYnMgKSA6IHZlcnRpY2VzWyBpIF07XHJcblxyXG5cdFx0aWYgKCAhIGV4dHJ1ZGVCeVBhdGggKSB7XHJcblxyXG5cdFx0XHR2KCB2ZXJ0LngsIHZlcnQueSwgMCApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHQvLyB2KCB2ZXJ0LngsIHZlcnQueSArIGV4dHJ1ZGVQdHNbIDAgXS55LCBleHRydWRlUHRzWyAwIF0ueCApO1xyXG5cclxuXHRcdFx0bm9ybWFsLmNvcHkoIHNwbGluZVR1YmUubm9ybWFsc1sgMCBdICkubXVsdGlwbHlTY2FsYXIoIHZlcnQueCApO1xyXG5cdFx0XHRiaW5vcm1hbC5jb3B5KCBzcGxpbmVUdWJlLmJpbm9ybWFsc1sgMCBdICkubXVsdGlwbHlTY2FsYXIoIHZlcnQueSApO1xyXG5cclxuXHRcdFx0cG9zaXRpb24yLmNvcHkoIGV4dHJ1ZGVQdHNbIDAgXSApLmFkZCggbm9ybWFsICkuYWRkKCBiaW5vcm1hbCApO1xyXG5cclxuXHRcdFx0diggcG9zaXRpb24yLngsIHBvc2l0aW9uMi55LCBwb3NpdGlvbjIueiApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHQvLyBBZGQgc3RlcHBlZCB2ZXJ0aWNlcy4uLlxyXG5cdC8vIEluY2x1ZGluZyBmcm9udCBmYWNpbmcgdmVydGljZXNcclxuXHJcblx0dmFyIHM7XHJcblxyXG5cdGZvciAoIHMgPSAxOyBzIDw9IHN0ZXBzOyBzICsrICkge1xyXG5cclxuXHRcdGZvciAoIGkgPSAwOyBpIDwgdmxlbjsgaSArKyApIHtcclxuXHJcblx0XHRcdHZlcnQgPSBiZXZlbEVuYWJsZWQgPyBzY2FsZVB0MiggdmVydGljZXNbIGkgXSwgdmVydGljZXNNb3ZlbWVudHNbIGkgXSwgYnMgKSA6IHZlcnRpY2VzWyBpIF07XHJcblxyXG5cdFx0XHRpZiAoICEgZXh0cnVkZUJ5UGF0aCApIHtcclxuXHJcblx0XHRcdFx0diggdmVydC54LCB2ZXJ0LnksIGFtb3VudCAvIHN0ZXBzICogcyApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Ly8gdiggdmVydC54LCB2ZXJ0LnkgKyBleHRydWRlUHRzWyBzIC0gMSBdLnksIGV4dHJ1ZGVQdHNbIHMgLSAxIF0ueCApO1xyXG5cclxuXHRcdFx0XHRub3JtYWwuY29weSggc3BsaW5lVHViZS5ub3JtYWxzWyBzIF0gKS5tdWx0aXBseVNjYWxhciggdmVydC54ICk7XHJcblx0XHRcdFx0Ymlub3JtYWwuY29weSggc3BsaW5lVHViZS5iaW5vcm1hbHNbIHMgXSApLm11bHRpcGx5U2NhbGFyKCB2ZXJ0LnkgKTtcclxuXHJcblx0XHRcdFx0cG9zaXRpb24yLmNvcHkoIGV4dHJ1ZGVQdHNbIHMgXSApLmFkZCggbm9ybWFsICkuYWRkKCBiaW5vcm1hbCApO1xyXG5cclxuXHRcdFx0XHR2KCBwb3NpdGlvbjIueCwgcG9zaXRpb24yLnksIHBvc2l0aW9uMi56ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cclxuXHQvLyBBZGQgYmV2ZWwgc2VnbWVudHMgcGxhbmVzXHJcblxyXG5cdC8vZm9yICggYiA9IDE7IGIgPD0gYmV2ZWxTZWdtZW50czsgYiArKyApIHtcclxuXHRmb3IgKCBiID0gYmV2ZWxTZWdtZW50cyAtIDE7IGIgPj0gMDsgYiAtLSApIHtcclxuXHJcblx0XHR0ID0gYiAvIGJldmVsU2VnbWVudHM7XHJcblx0XHR6ID0gYmV2ZWxUaGlja25lc3MgKiAoIDEgLSB0ICk7XHJcblx0XHQvL2JzID0gYmV2ZWxTaXplICogKCAxLU1hdGguc2luICggKCAxIC0gdCApICogTWF0aC5QSS8yICkgKTtcclxuXHRcdGJzID0gYmV2ZWxTaXplICogTWF0aC5zaW4gKCB0ICogTWF0aC5QSSAvIDIgKTtcclxuXHJcblx0XHQvLyBjb250cmFjdCBzaGFwZVxyXG5cclxuXHRcdGZvciAoIGkgPSAwLCBpbCA9IGNvbnRvdXIubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2ZXJ0ID0gc2NhbGVQdDIoIGNvbnRvdXJbIGkgXSwgY29udG91ck1vdmVtZW50c1sgaSBdLCBicyApO1xyXG5cdFx0XHR2KCB2ZXJ0LngsIHZlcnQueSwgIGFtb3VudCArIHogKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gZXhwYW5kIGhvbGVzXHJcblxyXG5cdFx0Zm9yICggaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyBoIDwgaGw7IGggKysgKSB7XHJcblxyXG5cdFx0XHRhaG9sZSA9IGhvbGVzWyBoIF07XHJcblx0XHRcdG9uZUhvbGVNb3ZlbWVudHMgPSBob2xlc01vdmVtZW50c1sgaCBdO1xyXG5cclxuXHRcdFx0Zm9yICggaSA9IDAsIGlsID0gYWhvbGUubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHZlcnQgPSBzY2FsZVB0MiggYWhvbGVbIGkgXSwgb25lSG9sZU1vdmVtZW50c1sgaSBdLCBicyApO1xyXG5cclxuXHRcdFx0XHRpZiAoICEgZXh0cnVkZUJ5UGF0aCApIHtcclxuXHJcblx0XHRcdFx0XHR2KCB2ZXJ0LngsIHZlcnQueSwgIGFtb3VudCArIHogKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHR2KCB2ZXJ0LngsIHZlcnQueSArIGV4dHJ1ZGVQdHNbIHN0ZXBzIC0gMSBdLnksIGV4dHJ1ZGVQdHNbIHN0ZXBzIC0gMSBdLnggKyB6ICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0LyogRmFjZXMgKi9cclxuXHJcblx0Ly8gVG9wIGFuZCBib3R0b20gZmFjZXNcclxuXHJcblx0YnVpbGRMaWRGYWNlcygpO1xyXG5cclxuXHQvLyBTaWRlcyBmYWNlc1xyXG5cclxuXHRidWlsZFNpZGVGYWNlcygpO1xyXG5cclxuXHJcblx0Ly8vLy8gIEludGVybmFsIGZ1bmN0aW9uc1xyXG5cclxuXHRmdW5jdGlvbiBidWlsZExpZEZhY2VzKCkge1xyXG5cclxuXHRcdGlmICggYmV2ZWxFbmFibGVkICkge1xyXG5cclxuXHRcdFx0dmFyIGxheWVyID0gMDsgLy8gc3RlcHMgKyAxXHJcblx0XHRcdHZhciBvZmZzZXQgPSB2bGVuICogbGF5ZXI7XHJcblxyXG5cdFx0XHQvLyBCb3R0b20gZmFjZXNcclxuXHJcblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgZmxlbjsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0ZmFjZSA9IGZhY2VzWyBpIF07XHJcblx0XHRcdFx0ZjMoIGZhY2VbIDIgXSArIG9mZnNldCwgZmFjZVsgMSBdICsgb2Zmc2V0LCBmYWNlWyAwIF0gKyBvZmZzZXQgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGxheWVyID0gc3RlcHMgKyBiZXZlbFNlZ21lbnRzICogMjtcclxuXHRcdFx0b2Zmc2V0ID0gdmxlbiAqIGxheWVyO1xyXG5cclxuXHRcdFx0Ly8gVG9wIGZhY2VzXHJcblxyXG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IGZsZW47IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdGZhY2UgPSBmYWNlc1sgaSBdO1xyXG5cdFx0XHRcdGYzKCBmYWNlWyAwIF0gKyBvZmZzZXQsIGZhY2VbIDEgXSArIG9mZnNldCwgZmFjZVsgMiBdICsgb2Zmc2V0ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdC8vIEJvdHRvbSBmYWNlc1xyXG5cclxuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBmbGVuOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRmYWNlID0gZmFjZXNbIGkgXTtcclxuXHRcdFx0XHRmMyggZmFjZVsgMiBdLCBmYWNlWyAxIF0sIGZhY2VbIDAgXSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gVG9wIGZhY2VzXHJcblxyXG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IGZsZW47IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdGZhY2UgPSBmYWNlc1sgaSBdO1xyXG5cdFx0XHRcdGYzKCBmYWNlWyAwIF0gKyB2bGVuICogc3RlcHMsIGZhY2VbIDEgXSArIHZsZW4gKiBzdGVwcywgZmFjZVsgMiBdICsgdmxlbiAqIHN0ZXBzICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdC8vIENyZWF0ZSBmYWNlcyBmb3IgdGhlIHotc2lkZXMgb2YgdGhlIHNoYXBlXHJcblxyXG5cdGZ1bmN0aW9uIGJ1aWxkU2lkZUZhY2VzKCkge1xyXG5cclxuXHRcdHZhciBsYXllcm9mZnNldCA9IDA7XHJcblx0XHRzaWRld2FsbHMoIGNvbnRvdXIsIGxheWVyb2Zmc2V0ICk7XHJcblx0XHRsYXllcm9mZnNldCArPSBjb250b3VyLmxlbmd0aDtcclxuXHJcblx0XHRmb3IgKCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcclxuXHJcblx0XHRcdGFob2xlID0gaG9sZXNbIGggXTtcclxuXHRcdFx0c2lkZXdhbGxzKCBhaG9sZSwgbGF5ZXJvZmZzZXQgKTtcclxuXHJcblx0XHRcdC8vLCB0cnVlXHJcblx0XHRcdGxheWVyb2Zmc2V0ICs9IGFob2xlLmxlbmd0aDtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gc2lkZXdhbGxzKCBjb250b3VyLCBsYXllcm9mZnNldCApIHtcclxuXHJcblx0XHR2YXIgaiwgaztcclxuXHRcdGkgPSBjb250b3VyLmxlbmd0aDtcclxuXHJcblx0XHR3aGlsZSAoIC0tIGkgPj0gMCApIHtcclxuXHJcblx0XHRcdGogPSBpO1xyXG5cdFx0XHRrID0gaSAtIDE7XHJcblx0XHRcdGlmICggayA8IDAgKSBrID0gY29udG91ci5sZW5ndGggLSAxO1xyXG5cclxuXHRcdFx0Ly9jb25zb2xlLmxvZygnYicsIGksaiwgaS0xLCBrLHZlcnRpY2VzLmxlbmd0aCk7XHJcblxyXG5cdFx0XHR2YXIgcyA9IDAsIHNsID0gc3RlcHMgICsgYmV2ZWxTZWdtZW50cyAqIDI7XHJcblxyXG5cdFx0XHRmb3IgKCBzID0gMDsgcyA8IHNsOyBzICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgc2xlbjEgPSB2bGVuICogcztcclxuXHRcdFx0XHR2YXIgc2xlbjIgPSB2bGVuICogKCBzICsgMSApO1xyXG5cclxuXHRcdFx0XHR2YXIgYSA9IGxheWVyb2Zmc2V0ICsgaiArIHNsZW4xLFxyXG5cdFx0XHRcdFx0YiA9IGxheWVyb2Zmc2V0ICsgayArIHNsZW4xLFxyXG5cdFx0XHRcdFx0YyA9IGxheWVyb2Zmc2V0ICsgayArIHNsZW4yLFxyXG5cdFx0XHRcdFx0ZCA9IGxheWVyb2Zmc2V0ICsgaiArIHNsZW4yO1xyXG5cclxuXHRcdFx0XHRmNCggYSwgYiwgYywgZCwgY29udG91ciwgcywgc2wsIGosIGsgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblxyXG5cdGZ1bmN0aW9uIHYoIHgsIHksIHogKSB7XHJcblxyXG5cdFx0c2NvcGUudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoIHgsIHksIHogKSApO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGYzKCBhLCBiLCBjICkge1xyXG5cclxuXHRcdGEgKz0gc2hhcGVzT2Zmc2V0O1xyXG5cdFx0YiArPSBzaGFwZXNPZmZzZXQ7XHJcblx0XHRjICs9IHNoYXBlc09mZnNldDtcclxuXHJcblx0XHRzY29wZS5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIGEsIGIsIGMsIG51bGwsIG51bGwsIDAgKSApO1xyXG5cclxuXHRcdHZhciB1dnMgPSB1dmdlbi5nZW5lcmF0ZVRvcFVWKCBzY29wZSwgYSwgYiwgYyApO1xyXG5cclxuXHRcdHNjb3BlLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCB1dnMgKTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBmNCggYSwgYiwgYywgZCwgd2FsbENvbnRvdXIsIHN0ZXBJbmRleCwgc3RlcHNMZW5ndGgsIGNvbnRvdXJJbmRleDEsIGNvbnRvdXJJbmRleDIgKSB7XHJcblxyXG5cdFx0YSArPSBzaGFwZXNPZmZzZXQ7XHJcblx0XHRiICs9IHNoYXBlc09mZnNldDtcclxuXHRcdGMgKz0gc2hhcGVzT2Zmc2V0O1xyXG5cdFx0ZCArPSBzaGFwZXNPZmZzZXQ7XHJcblxyXG5cdFx0c2NvcGUuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCBhLCBiLCBkLCBudWxsLCBudWxsLCAxICkgKTtcclxuXHRcdHNjb3BlLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggYiwgYywgZCwgbnVsbCwgbnVsbCwgMSApICk7XHJcblxyXG5cdFx0dmFyIHV2cyA9IHV2Z2VuLmdlbmVyYXRlU2lkZVdhbGxVViggc2NvcGUsIGEsIGIsIGMsIGQgKTtcclxuXHJcblx0XHRzY29wZS5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1dnNbIDAgXSwgdXZzWyAxIF0sIHV2c1sgMyBdIF0gKTtcclxuXHRcdHNjb3BlLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2c1sgMSBdLCB1dnNbIDIgXSwgdXZzWyAzIF0gXSApO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuRXh0cnVkZUdlb21ldHJ5LldvcmxkVVZHZW5lcmF0b3IgPSB7XHJcblxyXG5cdGdlbmVyYXRlVG9wVVY6IGZ1bmN0aW9uICggZ2VvbWV0cnksIGluZGV4QSwgaW5kZXhCLCBpbmRleEMgKSB7XHJcblxyXG5cdFx0dmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXM7XHJcblxyXG5cdFx0dmFyIGEgPSB2ZXJ0aWNlc1sgaW5kZXhBIF07XHJcblx0XHR2YXIgYiA9IHZlcnRpY2VzWyBpbmRleEIgXTtcclxuXHRcdHZhciBjID0gdmVydGljZXNbIGluZGV4QyBdO1xyXG5cclxuXHRcdHJldHVybiBbXHJcblx0XHRcdG5ldyBUSFJFRS5WZWN0b3IyKCBhLngsIGEueSApLFxyXG5cdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggYi54LCBiLnkgKSxcclxuXHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoIGMueCwgYy55IClcclxuXHRcdF07XHJcblxyXG5cdH0sXHJcblxyXG5cdGdlbmVyYXRlU2lkZVdhbGxVVjogZnVuY3Rpb24gKCBnZW9tZXRyeSwgaW5kZXhBLCBpbmRleEIsIGluZGV4QywgaW5kZXhEICkge1xyXG5cclxuXHRcdHZhciB2ZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzO1xyXG5cclxuXHRcdHZhciBhID0gdmVydGljZXNbIGluZGV4QSBdO1xyXG5cdFx0dmFyIGIgPSB2ZXJ0aWNlc1sgaW5kZXhCIF07XHJcblx0XHR2YXIgYyA9IHZlcnRpY2VzWyBpbmRleEMgXTtcclxuXHRcdHZhciBkID0gdmVydGljZXNbIGluZGV4RCBdO1xyXG5cclxuXHRcdGlmICggTWF0aC5hYnMoIGEueSAtIGIueSApIDwgMC4wMSApIHtcclxuXHJcblx0XHRcdHJldHVybiBbXHJcblx0XHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoIGEueCwgMSAtIGEueiApLFxyXG5cdFx0XHRcdG5ldyBUSFJFRS5WZWN0b3IyKCBiLngsIDEgLSBiLnogKSxcclxuXHRcdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggYy54LCAxIC0gYy56ICksXHJcblx0XHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoIGQueCwgMSAtIGQueiApXHJcblx0XHRcdF07XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHJldHVybiBbXHJcblx0XHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoIGEueSwgMSAtIGEueiApLFxyXG5cdFx0XHRcdG5ldyBUSFJFRS5WZWN0b3IyKCBiLnksIDEgLSBiLnogKSxcclxuXHRcdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggYy55LCAxIC0gYy56ICksXHJcblx0XHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoIGQueSwgMSAtIGQueiApXHJcblx0XHRcdF07XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9TaGFwZUdlb21ldHJ5LmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBqb25vYnIxIC8gaHR0cDovL2pvbm9icjEuY29tXHJcbiAqXHJcbiAqIENyZWF0ZXMgYSBvbmUtc2lkZWQgcG9seWdvbmFsIGdlb21ldHJ5IGZyb20gYSBwYXRoIHNoYXBlLiBTaW1pbGFyIHRvXHJcbiAqIEV4dHJ1ZGVHZW9tZXRyeS5cclxuICpcclxuICogcGFyYW1ldGVycyA9IHtcclxuICpcclxuICpcdGN1cnZlU2VnbWVudHM6IDxpbnQ+LCAvLyBudW1iZXIgb2YgcG9pbnRzIG9uIHRoZSBjdXJ2ZXMuIE5PVCBVU0VEIEFUIFRIRSBNT01FTlQuXHJcbiAqXHJcbiAqXHRtYXRlcmlhbDogPGludD4gLy8gbWF0ZXJpYWwgaW5kZXggZm9yIGZyb250IGFuZCBiYWNrIGZhY2VzXHJcbiAqXHR1dkdlbmVyYXRvcjogPE9iamVjdD4gLy8gb2JqZWN0IHRoYXQgcHJvdmlkZXMgVVYgZ2VuZXJhdG9yIGZ1bmN0aW9uc1xyXG4gKlxyXG4gKiB9XHJcbiAqKi9cclxuXHJcblRIUkVFLlNoYXBlR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHNoYXBlcywgb3B0aW9ucyApIHtcclxuXHJcblx0VEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLnR5cGUgPSAnU2hhcGVHZW9tZXRyeSc7XHJcblxyXG5cdGlmICggQXJyYXkuaXNBcnJheSggc2hhcGVzICkgPT09IGZhbHNlICkgc2hhcGVzID0gWyBzaGFwZXMgXTtcclxuXHJcblx0dGhpcy5hZGRTaGFwZUxpc3QoIHNoYXBlcywgb3B0aW9ucyApO1xyXG5cclxuXHR0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlNoYXBlR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XHJcblRIUkVFLlNoYXBlR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuU2hhcGVHZW9tZXRyeTtcclxuXHJcbi8qKlxyXG4gKiBBZGQgYW4gYXJyYXkgb2Ygc2hhcGVzIHRvIFRIUkVFLlNoYXBlR2VvbWV0cnkuXHJcbiAqL1xyXG5USFJFRS5TaGFwZUdlb21ldHJ5LnByb3RvdHlwZS5hZGRTaGFwZUxpc3QgPSBmdW5jdGlvbiAoIHNoYXBlcywgb3B0aW9ucyApIHtcclxuXHJcblx0Zm9yICggdmFyIGkgPSAwLCBsID0gc2hhcGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0dGhpcy5hZGRTaGFwZSggc2hhcGVzWyBpIF0sIG9wdGlvbnMgKTtcclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gdGhpcztcclxuXHJcbn07XHJcblxyXG4vKipcclxuICogQWRkcyBhIHNoYXBlIHRvIFRIUkVFLlNoYXBlR2VvbWV0cnksIGJhc2VkIG9uIFRIUkVFLkV4dHJ1ZGVHZW9tZXRyeS5cclxuICovXHJcblRIUkVFLlNoYXBlR2VvbWV0cnkucHJvdG90eXBlLmFkZFNoYXBlID0gZnVuY3Rpb24gKCBzaGFwZSwgb3B0aW9ucyApIHtcclxuXHJcblx0aWYgKCBvcHRpb25zID09PSB1bmRlZmluZWQgKSBvcHRpb25zID0ge307XHJcblx0dmFyIGN1cnZlU2VnbWVudHMgPSBvcHRpb25zLmN1cnZlU2VnbWVudHMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY3VydmVTZWdtZW50cyA6IDEyO1xyXG5cclxuXHR2YXIgbWF0ZXJpYWwgPSBvcHRpb25zLm1hdGVyaWFsO1xyXG5cdHZhciB1dmdlbiA9IG9wdGlvbnMuVVZHZW5lcmF0b3IgPT09IHVuZGVmaW5lZCA/IFRIUkVFLkV4dHJ1ZGVHZW9tZXRyeS5Xb3JsZFVWR2VuZXJhdG9yIDogb3B0aW9ucy5VVkdlbmVyYXRvcjtcclxuXHJcblx0Ly9cclxuXHJcblx0dmFyIGksIGwsIGhvbGU7XHJcblxyXG5cdHZhciBzaGFwZXNPZmZzZXQgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDtcclxuXHR2YXIgc2hhcGVQb2ludHMgPSBzaGFwZS5leHRyYWN0UG9pbnRzKCBjdXJ2ZVNlZ21lbnRzICk7XHJcblxyXG5cdHZhciB2ZXJ0aWNlcyA9IHNoYXBlUG9pbnRzLnNoYXBlO1xyXG5cdHZhciBob2xlcyA9IHNoYXBlUG9pbnRzLmhvbGVzO1xyXG5cclxuXHR2YXIgcmV2ZXJzZSA9ICEgVEhSRUUuU2hhcGVVdGlscy5pc0Nsb2NrV2lzZSggdmVydGljZXMgKTtcclxuXHJcblx0aWYgKCByZXZlcnNlICkge1xyXG5cclxuXHRcdHZlcnRpY2VzID0gdmVydGljZXMucmV2ZXJzZSgpO1xyXG5cclxuXHRcdC8vIE1heWJlIHdlIHNob3VsZCBhbHNvIGNoZWNrIGlmIGhvbGVzIGFyZSBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uLCBqdXN0IHRvIGJlIHNhZmUuLi5cclxuXHJcblx0XHRmb3IgKCBpID0gMCwgbCA9IGhvbGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRob2xlID0gaG9sZXNbIGkgXTtcclxuXHJcblx0XHRcdGlmICggVEhSRUUuU2hhcGVVdGlscy5pc0Nsb2NrV2lzZSggaG9sZSApICkge1xyXG5cclxuXHRcdFx0XHRob2xlc1sgaSBdID0gaG9sZS5yZXZlcnNlKCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldmVyc2UgPSBmYWxzZTtcclxuXHJcblx0fVxyXG5cclxuXHR2YXIgZmFjZXMgPSBUSFJFRS5TaGFwZVV0aWxzLnRyaWFuZ3VsYXRlU2hhcGUoIHZlcnRpY2VzLCBob2xlcyApO1xyXG5cclxuXHQvLyBWZXJ0aWNlc1xyXG5cclxuXHRmb3IgKCBpID0gMCwgbCA9IGhvbGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0aG9sZSA9IGhvbGVzWyBpIF07XHJcblx0XHR2ZXJ0aWNlcyA9IHZlcnRpY2VzLmNvbmNhdCggaG9sZSApO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vXHJcblxyXG5cdHZhciB2ZXJ0LCB2bGVuID0gdmVydGljZXMubGVuZ3RoO1xyXG5cdHZhciBmYWNlLCBmbGVuID0gZmFjZXMubGVuZ3RoO1xyXG5cclxuXHRmb3IgKCBpID0gMDsgaSA8IHZsZW47IGkgKysgKSB7XHJcblxyXG5cdFx0dmVydCA9IHZlcnRpY2VzWyBpIF07XHJcblxyXG5cdFx0dGhpcy52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMyggdmVydC54LCB2ZXJ0LnksIDAgKSApO1xyXG5cclxuXHR9XHJcblxyXG5cdGZvciAoIGkgPSAwOyBpIDwgZmxlbjsgaSArKyApIHtcclxuXHJcblx0XHRmYWNlID0gZmFjZXNbIGkgXTtcclxuXHJcblx0XHR2YXIgYSA9IGZhY2VbIDAgXSArIHNoYXBlc09mZnNldDtcclxuXHRcdHZhciBiID0gZmFjZVsgMSBdICsgc2hhcGVzT2Zmc2V0O1xyXG5cdFx0dmFyIGMgPSBmYWNlWyAyIF0gKyBzaGFwZXNPZmZzZXQ7XHJcblxyXG5cdFx0dGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIGEsIGIsIGMsIG51bGwsIG51bGwsIG1hdGVyaWFsICkgKTtcclxuXHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIHV2Z2VuLmdlbmVyYXRlVG9wVVYoIHRoaXMsIGEsIGIsIGMgKSApO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvTGF0aGVHZW9tZXRyeS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYXN0cm9kdWQgLyBodHRwOi8vYXN0cm9kdWQuaXNncmVhdC5vcmcvXHJcbiAqIEBhdXRob3Igeno4NSAvIGh0dHBzOi8vZ2l0aHViLmNvbS96ejg1XHJcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cclxuICovXHJcblxyXG4vLyBwb2ludHMgLSB0byBjcmVhdGUgYSBjbG9zZWQgdG9ydXMsIG9uZSBtdXN0IHVzZSBhIHNldCBvZiBwb2ludHNcclxuLy8gICAgbGlrZSBzbzogWyBhLCBiLCBjLCBkLCBhIF0sIHNlZSBmaXJzdCBpcyB0aGUgc2FtZSBhcyBsYXN0LlxyXG4vLyBzZWdtZW50cyAtIHRoZSBudW1iZXIgb2YgY2lyY3VtZmVyZW5jZSBzZWdtZW50cyB0byBjcmVhdGVcclxuLy8gcGhpU3RhcnQgLSB0aGUgc3RhcnRpbmcgcmFkaWFuXHJcbi8vIHBoaUxlbmd0aCAtIHRoZSByYWRpYW4gKDAgdG8gMipQSSkgcmFuZ2Ugb2YgdGhlIGxhdGhlZCBzZWN0aW9uXHJcbi8vICAgIDIqcGkgaXMgYSBjbG9zZWQgbGF0aGUsIGxlc3MgdGhhbiAyUEkgaXMgYSBwb3J0aW9uLlxyXG5cclxuVEhSRUUuTGF0aGVHZW9tZXRyeSA9IGZ1bmN0aW9uICggcG9pbnRzLCBzZWdtZW50cywgcGhpU3RhcnQsIHBoaUxlbmd0aCApIHtcclxuXHJcblx0VEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLnR5cGUgPSAnTGF0aGVHZW9tZXRyeSc7XHJcblxyXG5cdHRoaXMucGFyYW1ldGVycyA9IHtcclxuXHRcdHBvaW50czogcG9pbnRzLFxyXG5cdFx0c2VnbWVudHM6IHNlZ21lbnRzLFxyXG5cdFx0cGhpU3RhcnQ6IHBoaVN0YXJ0LFxyXG5cdFx0cGhpTGVuZ3RoOiBwaGlMZW5ndGhcclxuXHR9O1xyXG5cclxuXHRzZWdtZW50cyA9IHNlZ21lbnRzIHx8IDEyO1xyXG5cdHBoaVN0YXJ0ID0gcGhpU3RhcnQgfHwgMDtcclxuXHRwaGlMZW5ndGggPSBwaGlMZW5ndGggfHwgMiAqIE1hdGguUEk7XHJcblxyXG5cdHZhciBpbnZlcnNlUG9pbnRMZW5ndGggPSAxLjAgLyAoIHBvaW50cy5sZW5ndGggLSAxICk7XHJcblx0dmFyIGludmVyc2VTZWdtZW50cyA9IDEuMCAvIHNlZ21lbnRzO1xyXG5cclxuXHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gc2VnbWVudHM7IGkgPD0gaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0dmFyIHBoaSA9IHBoaVN0YXJ0ICsgaSAqIGludmVyc2VTZWdtZW50cyAqIHBoaUxlbmd0aDtcclxuXHJcblx0XHR2YXIgc2luID0gTWF0aC5zaW4oIHBoaSApO1xyXG5cdFx0dmFyIGNvcyA9IE1hdGguY29zKCBwaGkgKTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gcG9pbnRzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xyXG5cclxuXHRcdFx0dmFyIHBvaW50ID0gcG9pbnRzWyBqIF07XHJcblxyXG5cdFx0XHR2YXIgdmVydGV4ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHRcdHZlcnRleC54ID0gcG9pbnQueCAqIHNpbjtcclxuXHRcdFx0dmVydGV4LnkgPSBwb2ludC55O1xyXG5cdFx0XHR2ZXJ0ZXgueiA9IHBvaW50LnggKiBjb3M7XHJcblxyXG5cdFx0XHR0aGlzLnZlcnRpY2VzLnB1c2goIHZlcnRleCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHR2YXIgbnAgPSBwb2ludHMubGVuZ3RoO1xyXG5cclxuXHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gc2VnbWVudHM7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gcG9pbnRzLmxlbmd0aCAtIDE7IGogPCBqbDsgaiArKyApIHtcclxuXHJcblx0XHRcdHZhciBiYXNlID0gaiArIG5wICogaTtcclxuXHRcdFx0dmFyIGEgPSBiYXNlO1xyXG5cdFx0XHR2YXIgYiA9IGJhc2UgKyBucDtcclxuXHRcdFx0dmFyIGMgPSBiYXNlICsgMSArIG5wO1xyXG5cdFx0XHR2YXIgZCA9IGJhc2UgKyAxO1xyXG5cclxuXHRcdFx0dmFyIHUwID0gaSAqIGludmVyc2VTZWdtZW50cztcclxuXHRcdFx0dmFyIHYwID0gaiAqIGludmVyc2VQb2ludExlbmd0aDtcclxuXHRcdFx0dmFyIHUxID0gdTAgKyBpbnZlcnNlU2VnbWVudHM7XHJcblx0XHRcdHZhciB2MSA9IHYwICsgaW52ZXJzZVBvaW50TGVuZ3RoO1xyXG5cclxuXHRcdFx0dGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIGEsIGIsIGQgKSApO1xyXG5cclxuXHRcdFx0dGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggW1xyXG5cclxuXHRcdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggdTAsIHYwICksXHJcblx0XHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoIHUxLCB2MCApLFxyXG5cdFx0XHRcdG5ldyBUSFJFRS5WZWN0b3IyKCB1MCwgdjEgKVxyXG5cclxuXHRcdFx0XSApO1xyXG5cclxuXHRcdFx0dGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIGIsIGMsIGQgKSApO1xyXG5cclxuXHRcdFx0dGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggW1xyXG5cclxuXHRcdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggdTEsIHYwICksXHJcblx0XHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoIHUxLCB2MSApLFxyXG5cdFx0XHRcdG5ldyBUSFJFRS5WZWN0b3IyKCB1MCwgdjEgKVxyXG5cclxuXHRcdFx0XSApO1xyXG5cclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0dGhpcy5tZXJnZVZlcnRpY2VzKCk7XHJcblx0dGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcclxuXHR0aGlzLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTGF0aGVHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuVEhSRUUuTGF0aGVHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5MYXRoZUdlb21ldHJ5O1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvUGxhbmVHZW9tZXRyeS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIGJhc2VkIG9uIGh0dHA6Ly9wYXBlcnZpc2lvbjNkLmdvb2dsZWNvZGUuY29tL3N2bi90cnVuay9hczMvdHJ1bmsvc3JjL29yZy9wYXBlcnZpc2lvbjNkL29iamVjdHMvcHJpbWl0aXZlcy9QbGFuZS5hc1xyXG4gKi9cclxuXHJcblRIUkVFLlBsYW5lR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHdpZHRoLCBoZWlnaHQsIHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzICkge1xyXG5cclxuXHRUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMudHlwZSA9ICdQbGFuZUdlb21ldHJ5JztcclxuXHJcblx0dGhpcy5wYXJhbWV0ZXJzID0ge1xyXG5cdFx0d2lkdGg6IHdpZHRoLFxyXG5cdFx0aGVpZ2h0OiBoZWlnaHQsXHJcblx0XHR3aWR0aFNlZ21lbnRzOiB3aWR0aFNlZ21lbnRzLFxyXG5cdFx0aGVpZ2h0U2VnbWVudHM6IGhlaWdodFNlZ21lbnRzXHJcblx0fTtcclxuXHJcblx0dGhpcy5mcm9tQnVmZmVyR2VvbWV0cnkoIG5ldyBUSFJFRS5QbGFuZUJ1ZmZlckdlb21ldHJ5KCB3aWR0aCwgaGVpZ2h0LCB3aWR0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cyApICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUGxhbmVHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuVEhSRUUuUGxhbmVHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5QbGFuZUdlb21ldHJ5O1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvUGxhbmVCdWZmZXJHZW9tZXRyeS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIGJhc2VkIG9uIGh0dHA6Ly9wYXBlcnZpc2lvbjNkLmdvb2dsZWNvZGUuY29tL3N2bi90cnVuay9hczMvdHJ1bmsvc3JjL29yZy9wYXBlcnZpc2lvbjNkL29iamVjdHMvcHJpbWl0aXZlcy9QbGFuZS5hc1xyXG4gKi9cclxuXHJcblRIUkVFLlBsYW5lQnVmZmVyR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHdpZHRoLCBoZWlnaHQsIHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzICkge1xyXG5cclxuXHRUSFJFRS5CdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMudHlwZSA9ICdQbGFuZUJ1ZmZlckdlb21ldHJ5JztcclxuXHJcblx0dGhpcy5wYXJhbWV0ZXJzID0ge1xyXG5cdFx0d2lkdGg6IHdpZHRoLFxyXG5cdFx0aGVpZ2h0OiBoZWlnaHQsXHJcblx0XHR3aWR0aFNlZ21lbnRzOiB3aWR0aFNlZ21lbnRzLFxyXG5cdFx0aGVpZ2h0U2VnbWVudHM6IGhlaWdodFNlZ21lbnRzXHJcblx0fTtcclxuXHJcblx0dmFyIHdpZHRoX2hhbGYgPSB3aWR0aCAvIDI7XHJcblx0dmFyIGhlaWdodF9oYWxmID0gaGVpZ2h0IC8gMjtcclxuXHJcblx0dmFyIGdyaWRYID0gTWF0aC5mbG9vciggd2lkdGhTZWdtZW50cyApIHx8IDE7XHJcblx0dmFyIGdyaWRZID0gTWF0aC5mbG9vciggaGVpZ2h0U2VnbWVudHMgKSB8fCAxO1xyXG5cclxuXHR2YXIgZ3JpZFgxID0gZ3JpZFggKyAxO1xyXG5cdHZhciBncmlkWTEgPSBncmlkWSArIDE7XHJcblxyXG5cdHZhciBzZWdtZW50X3dpZHRoID0gd2lkdGggLyBncmlkWDtcclxuXHR2YXIgc2VnbWVudF9oZWlnaHQgPSBoZWlnaHQgLyBncmlkWTtcclxuXHJcblx0dmFyIHZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheSggZ3JpZFgxICogZ3JpZFkxICogMyApO1xyXG5cdHZhciBub3JtYWxzID0gbmV3IEZsb2F0MzJBcnJheSggZ3JpZFgxICogZ3JpZFkxICogMyApO1xyXG5cdHZhciB1dnMgPSBuZXcgRmxvYXQzMkFycmF5KCBncmlkWDEgKiBncmlkWTEgKiAyICk7XHJcblxyXG5cdHZhciBvZmZzZXQgPSAwO1xyXG5cdHZhciBvZmZzZXQyID0gMDtcclxuXHJcblx0Zm9yICggdmFyIGl5ID0gMDsgaXkgPCBncmlkWTE7IGl5ICsrICkge1xyXG5cclxuXHRcdHZhciB5ID0gaXkgKiBzZWdtZW50X2hlaWdodCAtIGhlaWdodF9oYWxmO1xyXG5cclxuXHRcdGZvciAoIHZhciBpeCA9IDA7IGl4IDwgZ3JpZFgxOyBpeCArKyApIHtcclxuXHJcblx0XHRcdHZhciB4ID0gaXggKiBzZWdtZW50X3dpZHRoIC0gd2lkdGhfaGFsZjtcclxuXHJcblx0XHRcdHZlcnRpY2VzWyBvZmZzZXQgXSA9IHg7XHJcblx0XHRcdHZlcnRpY2VzWyBvZmZzZXQgKyAxIF0gPSAtIHk7XHJcblxyXG5cdFx0XHRub3JtYWxzWyBvZmZzZXQgKyAyIF0gPSAxO1xyXG5cclxuXHRcdFx0dXZzWyBvZmZzZXQyIF0gPSBpeCAvIGdyaWRYO1xyXG5cdFx0XHR1dnNbIG9mZnNldDIgKyAxIF0gPSAxIC0gKCBpeSAvIGdyaWRZICk7XHJcblxyXG5cdFx0XHRvZmZzZXQgKz0gMztcclxuXHRcdFx0b2Zmc2V0MiArPSAyO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRvZmZzZXQgPSAwO1xyXG5cclxuXHR2YXIgaW5kaWNlcyA9IG5ldyAoICggdmVydGljZXMubGVuZ3RoIC8gMyApID4gNjU1MzUgPyBVaW50MzJBcnJheSA6IFVpbnQxNkFycmF5ICkoIGdyaWRYICogZ3JpZFkgKiA2ICk7XHJcblxyXG5cdGZvciAoIHZhciBpeSA9IDA7IGl5IDwgZ3JpZFk7IGl5ICsrICkge1xyXG5cclxuXHRcdGZvciAoIHZhciBpeCA9IDA7IGl4IDwgZ3JpZFg7IGl4ICsrICkge1xyXG5cclxuXHRcdFx0dmFyIGEgPSBpeCArIGdyaWRYMSAqIGl5O1xyXG5cdFx0XHR2YXIgYiA9IGl4ICsgZ3JpZFgxICogKCBpeSArIDEgKTtcclxuXHRcdFx0dmFyIGMgPSAoIGl4ICsgMSApICsgZ3JpZFgxICogKCBpeSArIDEgKTtcclxuXHRcdFx0dmFyIGQgPSAoIGl4ICsgMSApICsgZ3JpZFgxICogaXk7XHJcblxyXG5cdFx0XHRpbmRpY2VzWyBvZmZzZXQgXSA9IGE7XHJcblx0XHRcdGluZGljZXNbIG9mZnNldCArIDEgXSA9IGI7XHJcblx0XHRcdGluZGljZXNbIG9mZnNldCArIDIgXSA9IGQ7XHJcblxyXG5cdFx0XHRpbmRpY2VzWyBvZmZzZXQgKyAzIF0gPSBiO1xyXG5cdFx0XHRpbmRpY2VzWyBvZmZzZXQgKyA0IF0gPSBjO1xyXG5cdFx0XHRpbmRpY2VzWyBvZmZzZXQgKyA1IF0gPSBkO1xyXG5cclxuXHRcdFx0b2Zmc2V0ICs9IDY7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdHRoaXMuc2V0SW5kZXgoIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIGluZGljZXMsIDEgKSApO1xyXG5cdHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XHJcblx0dGhpcy5hZGRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBub3JtYWxzLCAzICkgKTtcclxuXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3V2JywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5QbGFuZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG5USFJFRS5QbGFuZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlBsYW5lQnVmZmVyR2VvbWV0cnk7XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9SaW5nR2VvbWV0cnkuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIEthbGViIE11cnBoeVxyXG4gKi9cclxuXHJcblRIUkVFLlJpbmdHZW9tZXRyeSA9IGZ1bmN0aW9uICggaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzLCB0aGV0YVNlZ21lbnRzLCBwaGlTZWdtZW50cywgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKSB7XHJcblxyXG5cdFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy50eXBlID0gJ1JpbmdHZW9tZXRyeSc7XHJcblxyXG5cdHRoaXMucGFyYW1ldGVycyA9IHtcclxuXHRcdGlubmVyUmFkaXVzOiBpbm5lclJhZGl1cyxcclxuXHRcdG91dGVyUmFkaXVzOiBvdXRlclJhZGl1cyxcclxuXHRcdHRoZXRhU2VnbWVudHM6IHRoZXRhU2VnbWVudHMsXHJcblx0XHRwaGlTZWdtZW50czogcGhpU2VnbWVudHMsXHJcblx0XHR0aGV0YVN0YXJ0OiB0aGV0YVN0YXJ0LFxyXG5cdFx0dGhldGFMZW5ndGg6IHRoZXRhTGVuZ3RoXHJcblx0fTtcclxuXHJcblx0aW5uZXJSYWRpdXMgPSBpbm5lclJhZGl1cyB8fCAwO1xyXG5cdG91dGVyUmFkaXVzID0gb3V0ZXJSYWRpdXMgfHwgNTA7XHJcblxyXG5cdHRoZXRhU3RhcnQgPSB0aGV0YVN0YXJ0ICE9PSB1bmRlZmluZWQgPyB0aGV0YVN0YXJ0IDogMDtcclxuXHR0aGV0YUxlbmd0aCA9IHRoZXRhTGVuZ3RoICE9PSB1bmRlZmluZWQgPyB0aGV0YUxlbmd0aCA6IE1hdGguUEkgKiAyO1xyXG5cclxuXHR0aGV0YVNlZ21lbnRzID0gdGhldGFTZWdtZW50cyAhPT0gdW5kZWZpbmVkID8gTWF0aC5tYXgoIDMsIHRoZXRhU2VnbWVudHMgKSA6IDg7XHJcblx0cGhpU2VnbWVudHMgPSBwaGlTZWdtZW50cyAhPT0gdW5kZWZpbmVkID8gTWF0aC5tYXgoIDEsIHBoaVNlZ21lbnRzICkgOiA4O1xyXG5cclxuXHR2YXIgaSwgbywgdXZzID0gW10sIHJhZGl1cyA9IGlubmVyUmFkaXVzLCByYWRpdXNTdGVwID0gKCAoIG91dGVyUmFkaXVzIC0gaW5uZXJSYWRpdXMgKSAvIHBoaVNlZ21lbnRzICk7XHJcblxyXG5cdGZvciAoIGkgPSAwOyBpIDwgcGhpU2VnbWVudHMgKyAxOyBpICsrICkge1xyXG5cclxuXHRcdC8vIGNvbmNlbnRyaWMgY2lyY2xlcyBpbnNpZGUgcmluZ1xyXG5cclxuXHRcdGZvciAoIG8gPSAwOyBvIDwgdGhldGFTZWdtZW50cyArIDE7IG8gKysgKSB7XHJcblxyXG5cdFx0XHQvLyBudW1iZXIgb2Ygc2VnbWVudHMgcGVyIGNpcmNsZVxyXG5cclxuXHRcdFx0dmFyIHZlcnRleCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHRcdHZhciBzZWdtZW50ID0gdGhldGFTdGFydCArIG8gLyB0aGV0YVNlZ21lbnRzICogdGhldGFMZW5ndGg7XHJcblx0XHRcdHZlcnRleC54ID0gcmFkaXVzICogTWF0aC5jb3MoIHNlZ21lbnQgKTtcclxuXHRcdFx0dmVydGV4LnkgPSByYWRpdXMgKiBNYXRoLnNpbiggc2VnbWVudCApO1xyXG5cclxuXHRcdFx0dGhpcy52ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXggKTtcclxuXHRcdFx0dXZzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCAoIHZlcnRleC54IC8gb3V0ZXJSYWRpdXMgKyAxICkgLyAyLCAoIHZlcnRleC55IC8gb3V0ZXJSYWRpdXMgKyAxICkgLyAyICkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmFkaXVzICs9IHJhZGl1c1N0ZXA7XHJcblxyXG5cdH1cclxuXHJcblx0dmFyIG4gPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMCwgMSApO1xyXG5cclxuXHRmb3IgKCBpID0gMDsgaSA8IHBoaVNlZ21lbnRzOyBpICsrICkge1xyXG5cclxuXHRcdC8vIGNvbmNlbnRyaWMgY2lyY2xlcyBpbnNpZGUgcmluZ1xyXG5cclxuXHRcdHZhciB0aGV0YVNlZ21lbnQgPSBpICogKCB0aGV0YVNlZ21lbnRzICsgMSApO1xyXG5cclxuXHRcdGZvciAoIG8gPSAwOyBvIDwgdGhldGFTZWdtZW50cyA7IG8gKysgKSB7XHJcblxyXG5cdFx0XHQvLyBudW1iZXIgb2Ygc2VnbWVudHMgcGVyIGNpcmNsZVxyXG5cclxuXHRcdFx0dmFyIHNlZ21lbnQgPSBvICsgdGhldGFTZWdtZW50O1xyXG5cclxuXHRcdFx0dmFyIHYxID0gc2VnbWVudDtcclxuXHRcdFx0dmFyIHYyID0gc2VnbWVudCArIHRoZXRhU2VnbWVudHMgKyAxO1xyXG5cdFx0XHR2YXIgdjMgPSBzZWdtZW50ICsgdGhldGFTZWdtZW50cyArIDI7XHJcblxyXG5cdFx0XHR0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggdjEsIHYyLCB2MywgWyBuLmNsb25lKCksIG4uY2xvbmUoKSwgbi5jbG9uZSgpIF0gKSApO1xyXG5cdFx0XHR0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2c1sgdjEgXS5jbG9uZSgpLCB1dnNbIHYyIF0uY2xvbmUoKSwgdXZzWyB2MyBdLmNsb25lKCkgXSApO1xyXG5cclxuXHRcdFx0djEgPSBzZWdtZW50O1xyXG5cdFx0XHR2MiA9IHNlZ21lbnQgKyB0aGV0YVNlZ21lbnRzICsgMjtcclxuXHRcdFx0djMgPSBzZWdtZW50ICsgMTtcclxuXHJcblx0XHRcdHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCB2MSwgdjIsIHYzLCBbIG4uY2xvbmUoKSwgbi5jbG9uZSgpLCBuLmNsb25lKCkgXSApICk7XHJcblx0XHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZzWyB2MSBdLmNsb25lKCksIHV2c1sgdjIgXS5jbG9uZSgpLCB1dnNbIHYzIF0uY2xvbmUoKSBdICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XHJcblxyXG5cdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBuZXcgVEhSRUUuU3BoZXJlKCBuZXcgVEhSRUUuVmVjdG9yMygpLCByYWRpdXMgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5SaW5nR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XHJcblRIUkVFLlJpbmdHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5SaW5nR2VvbWV0cnk7XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9TcGhlcmVHZW9tZXRyeS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuU3BoZXJlR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHJhZGl1cywgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIHBoaVN0YXJ0LCBwaGlMZW5ndGgsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICkge1xyXG5cclxuXHRUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMudHlwZSA9ICdTcGhlcmVHZW9tZXRyeSc7XHJcblxyXG5cdHRoaXMucGFyYW1ldGVycyA9IHtcclxuXHRcdHJhZGl1czogcmFkaXVzLFxyXG5cdFx0d2lkdGhTZWdtZW50czogd2lkdGhTZWdtZW50cyxcclxuXHRcdGhlaWdodFNlZ21lbnRzOiBoZWlnaHRTZWdtZW50cyxcclxuXHRcdHBoaVN0YXJ0OiBwaGlTdGFydCxcclxuXHRcdHBoaUxlbmd0aDogcGhpTGVuZ3RoLFxyXG5cdFx0dGhldGFTdGFydDogdGhldGFTdGFydCxcclxuXHRcdHRoZXRhTGVuZ3RoOiB0aGV0YUxlbmd0aFxyXG5cdH07XHJcblxyXG5cdHRoaXMuZnJvbUJ1ZmZlckdlb21ldHJ5KCBuZXcgVEhSRUUuU3BoZXJlQnVmZmVyR2VvbWV0cnkoIHJhZGl1cywgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIHBoaVN0YXJ0LCBwaGlMZW5ndGgsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICkgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5TcGhlcmVHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuVEhSRUUuU3BoZXJlR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuU3BoZXJlR2VvbWV0cnk7XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9TcGhlcmVCdWZmZXJHZW9tZXRyeS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYmVuYWFkYW1zIC8gaHR0cHM6Ly90d2l0dGVyLmNvbS9iZW5fYV9hZGFtc1xyXG4gKiBiYXNlZCBvbiBUSFJFRS5TcGhlcmVHZW9tZXRyeVxyXG4gKi9cclxuXHJcblRIUkVFLlNwaGVyZUJ1ZmZlckdlb21ldHJ5ID0gZnVuY3Rpb24gKCByYWRpdXMsIHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCBwaGlTdGFydCwgcGhpTGVuZ3RoLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApIHtcclxuXHJcblx0VEhSRUUuQnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLnR5cGUgPSAnU3BoZXJlQnVmZmVyR2VvbWV0cnknO1xyXG5cclxuXHR0aGlzLnBhcmFtZXRlcnMgPSB7XHJcblx0XHRyYWRpdXM6IHJhZGl1cyxcclxuXHRcdHdpZHRoU2VnbWVudHM6IHdpZHRoU2VnbWVudHMsXHJcblx0XHRoZWlnaHRTZWdtZW50czogaGVpZ2h0U2VnbWVudHMsXHJcblx0XHRwaGlTdGFydDogcGhpU3RhcnQsXHJcblx0XHRwaGlMZW5ndGg6IHBoaUxlbmd0aCxcclxuXHRcdHRoZXRhU3RhcnQ6IHRoZXRhU3RhcnQsXHJcblx0XHR0aGV0YUxlbmd0aDogdGhldGFMZW5ndGhcclxuXHR9O1xyXG5cclxuXHRyYWRpdXMgPSByYWRpdXMgfHwgNTA7XHJcblxyXG5cdHdpZHRoU2VnbWVudHMgPSBNYXRoLm1heCggMywgTWF0aC5mbG9vciggd2lkdGhTZWdtZW50cyApIHx8IDggKTtcclxuXHRoZWlnaHRTZWdtZW50cyA9IE1hdGgubWF4KCAyLCBNYXRoLmZsb29yKCBoZWlnaHRTZWdtZW50cyApIHx8IDYgKTtcclxuXHJcblx0cGhpU3RhcnQgPSBwaGlTdGFydCAhPT0gdW5kZWZpbmVkID8gcGhpU3RhcnQgOiAwO1xyXG5cdHBoaUxlbmd0aCA9IHBoaUxlbmd0aCAhPT0gdW5kZWZpbmVkID8gcGhpTGVuZ3RoIDogTWF0aC5QSSAqIDI7XHJcblxyXG5cdHRoZXRhU3RhcnQgPSB0aGV0YVN0YXJ0ICE9PSB1bmRlZmluZWQgPyB0aGV0YVN0YXJ0IDogMDtcclxuXHR0aGV0YUxlbmd0aCA9IHRoZXRhTGVuZ3RoICE9PSB1bmRlZmluZWQgPyB0aGV0YUxlbmd0aCA6IE1hdGguUEk7XHJcblxyXG5cdHZhciB0aGV0YUVuZCA9IHRoZXRhU3RhcnQgKyB0aGV0YUxlbmd0aDtcclxuXHJcblx0dmFyIHZlcnRleENvdW50ID0gKCAoIHdpZHRoU2VnbWVudHMgKyAxICkgKiAoIGhlaWdodFNlZ21lbnRzICsgMSApICk7XHJcblxyXG5cdHZhciBwb3NpdGlvbnMgPSBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgRmxvYXQzMkFycmF5KCB2ZXJ0ZXhDb3VudCAqIDMgKSwgMyApO1xyXG5cdHZhciBub3JtYWxzID0gbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IEZsb2F0MzJBcnJheSggdmVydGV4Q291bnQgKiAzICksIDMgKTtcclxuXHR2YXIgdXZzID0gbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IEZsb2F0MzJBcnJheSggdmVydGV4Q291bnQgKiAyICksIDIgKTtcclxuXHJcblx0dmFyIGluZGV4ID0gMCwgdmVydGljZXMgPSBbXSwgbm9ybWFsID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0Zm9yICggdmFyIHkgPSAwOyB5IDw9IGhlaWdodFNlZ21lbnRzOyB5ICsrICkge1xyXG5cclxuXHRcdHZhciB2ZXJ0aWNlc1JvdyA9IFtdO1xyXG5cclxuXHRcdHZhciB2ID0geSAvIGhlaWdodFNlZ21lbnRzO1xyXG5cclxuXHRcdGZvciAoIHZhciB4ID0gMDsgeCA8PSB3aWR0aFNlZ21lbnRzOyB4ICsrICkge1xyXG5cclxuXHRcdFx0dmFyIHUgPSB4IC8gd2lkdGhTZWdtZW50cztcclxuXHJcblx0XHRcdHZhciBweCA9IC0gcmFkaXVzICogTWF0aC5jb3MoIHBoaVN0YXJ0ICsgdSAqIHBoaUxlbmd0aCApICogTWF0aC5zaW4oIHRoZXRhU3RhcnQgKyB2ICogdGhldGFMZW5ndGggKTtcclxuXHRcdFx0dmFyIHB5ID0gcmFkaXVzICogTWF0aC5jb3MoIHRoZXRhU3RhcnQgKyB2ICogdGhldGFMZW5ndGggKTtcclxuXHRcdFx0dmFyIHB6ID0gcmFkaXVzICogTWF0aC5zaW4oIHBoaVN0YXJ0ICsgdSAqIHBoaUxlbmd0aCApICogTWF0aC5zaW4oIHRoZXRhU3RhcnQgKyB2ICogdGhldGFMZW5ndGggKTtcclxuXHJcblx0XHRcdG5vcm1hbC5zZXQoIHB4LCBweSwgcHogKS5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRcdHBvc2l0aW9ucy5zZXRYWVooIGluZGV4LCBweCwgcHksIHB6ICk7XHJcblx0XHRcdG5vcm1hbHMuc2V0WFlaKCBpbmRleCwgbm9ybWFsLngsIG5vcm1hbC55LCBub3JtYWwueiApO1xyXG5cdFx0XHR1dnMuc2V0WFkoIGluZGV4LCB1LCAxIC0gdiApO1xyXG5cclxuXHRcdFx0dmVydGljZXNSb3cucHVzaCggaW5kZXggKTtcclxuXHJcblx0XHRcdGluZGV4ICsrO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2ZXJ0aWNlcy5wdXNoKCB2ZXJ0aWNlc1JvdyApO1xyXG5cclxuXHR9XHJcblxyXG5cdHZhciBpbmRpY2VzID0gW107XHJcblxyXG5cdGZvciAoIHZhciB5ID0gMDsgeSA8IGhlaWdodFNlZ21lbnRzOyB5ICsrICkge1xyXG5cclxuXHRcdGZvciAoIHZhciB4ID0gMDsgeCA8IHdpZHRoU2VnbWVudHM7IHggKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgdjEgPSB2ZXJ0aWNlc1sgeSBdWyB4ICsgMSBdO1xyXG5cdFx0XHR2YXIgdjIgPSB2ZXJ0aWNlc1sgeSBdWyB4IF07XHJcblx0XHRcdHZhciB2MyA9IHZlcnRpY2VzWyB5ICsgMSBdWyB4IF07XHJcblx0XHRcdHZhciB2NCA9IHZlcnRpY2VzWyB5ICsgMSBdWyB4ICsgMSBdO1xyXG5cclxuXHRcdFx0aWYgKCB5ICE9PSAwIHx8IHRoZXRhU3RhcnQgPiAwICkgaW5kaWNlcy5wdXNoKCB2MSwgdjIsIHY0ICk7XHJcblx0XHRcdGlmICggeSAhPT0gaGVpZ2h0U2VnbWVudHMgLSAxIHx8IHRoZXRhRW5kIDwgTWF0aC5QSSApIGluZGljZXMucHVzaCggdjIsIHYzLCB2NCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHR0aGlzLnNldEluZGV4KCBuZXcgKCBwb3NpdGlvbnMuY291bnQgPiA2NTUzNSA/IFRIUkVFLlVpbnQzMkF0dHJpYnV0ZSA6IFRIUkVFLlVpbnQxNkF0dHJpYnV0ZSApKCBpbmRpY2VzLCAxICkgKTtcclxuXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgcG9zaXRpb25zICk7XHJcblx0dGhpcy5hZGRBdHRyaWJ1dGUoICdub3JtYWwnLCBub3JtYWxzICk7XHJcblx0dGhpcy5hZGRBdHRyaWJ1dGUoICd1dicsIHV2cyApO1xyXG5cclxuXHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gbmV3IFRIUkVFLlNwaGVyZSggbmV3IFRIUkVFLlZlY3RvcjMoKSwgcmFkaXVzICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuU3BoZXJlQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XHJcblRIUkVFLlNwaGVyZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlNwaGVyZUJ1ZmZlckdlb21ldHJ5O1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvVGV4dEdlb21ldHJ5LmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKlxyXG4gKiBUZXh0ID0gM0QgVGV4dFxyXG4gKlxyXG4gKiBwYXJhbWV0ZXJzID0ge1xyXG4gKiAgZm9udDogPFRIUkVFLkZvbnQ+LCAvLyBmb250XHJcbiAqXHJcbiAqICBzaXplOiA8ZmxvYXQ+LCAvLyBzaXplIG9mIHRoZSB0ZXh0XHJcbiAqICBoZWlnaHQ6IDxmbG9hdD4sIC8vIHRoaWNrbmVzcyB0byBleHRydWRlIHRleHRcclxuICogIGN1cnZlU2VnbWVudHM6IDxpbnQ+LCAvLyBudW1iZXIgb2YgcG9pbnRzIG9uIHRoZSBjdXJ2ZXNcclxuICpcclxuICogIGJldmVsRW5hYmxlZDogPGJvb2w+LCAvLyB0dXJuIG9uIGJldmVsXHJcbiAqICBiZXZlbFRoaWNrbmVzczogPGZsb2F0PiwgLy8gaG93IGRlZXAgaW50byB0ZXh0IGJldmVsIGdvZXNcclxuICogIGJldmVsU2l6ZTogPGZsb2F0PiAvLyBob3cgZmFyIGZyb20gdGV4dCBvdXRsaW5lIGlzIGJldmVsXHJcbiAqIH1cclxuICovXHJcblxyXG5USFJFRS5UZXh0R2VvbWV0cnkgPSBmdW5jdGlvbiAoIHRleHQsIHBhcmFtZXRlcnMgKSB7XHJcblxyXG5cdHBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzIHx8IHt9O1xyXG5cclxuXHR2YXIgZm9udCA9IHBhcmFtZXRlcnMuZm9udDtcclxuXHJcblx0aWYgKCBmb250IGluc3RhbmNlb2YgVEhSRUUuRm9udCA9PT0gZmFsc2UgKSB7XHJcblxyXG5cdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlRleHRHZW9tZXRyeTogZm9udCBwYXJhbWV0ZXIgaXMgbm90IGFuIGluc3RhbmNlIG9mIFRIUkVFLkZvbnQuJyApO1xyXG5cdFx0cmV0dXJuIG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xyXG5cclxuXHR9XHJcblxyXG5cdHZhciBzaGFwZXMgPSBmb250LmdlbmVyYXRlU2hhcGVzKCB0ZXh0LCBwYXJhbWV0ZXJzLnNpemUsIHBhcmFtZXRlcnMuY3VydmVTZWdtZW50cyApO1xyXG5cclxuXHQvLyB0cmFuc2xhdGUgcGFyYW1ldGVycyB0byBFeHRydWRlR2VvbWV0cnkgQVBJXHJcblxyXG5cdHBhcmFtZXRlcnMuYW1vdW50ID0gcGFyYW1ldGVycy5oZWlnaHQgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuaGVpZ2h0IDogNTA7XHJcblxyXG5cdC8vIGRlZmF1bHRzXHJcblxyXG5cdGlmICggcGFyYW1ldGVycy5iZXZlbFRoaWNrbmVzcyA9PT0gdW5kZWZpbmVkICkgcGFyYW1ldGVycy5iZXZlbFRoaWNrbmVzcyA9IDEwO1xyXG5cdGlmICggcGFyYW1ldGVycy5iZXZlbFNpemUgPT09IHVuZGVmaW5lZCApIHBhcmFtZXRlcnMuYmV2ZWxTaXplID0gODtcclxuXHRpZiAoIHBhcmFtZXRlcnMuYmV2ZWxFbmFibGVkID09PSB1bmRlZmluZWQgKSBwYXJhbWV0ZXJzLmJldmVsRW5hYmxlZCA9IGZhbHNlO1xyXG5cclxuXHRUSFJFRS5FeHRydWRlR2VvbWV0cnkuY2FsbCggdGhpcywgc2hhcGVzLCBwYXJhbWV0ZXJzICk7XHJcblxyXG5cdHRoaXMudHlwZSA9ICdUZXh0R2VvbWV0cnknO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlRleHRHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5FeHRydWRlR2VvbWV0cnkucHJvdG90eXBlICk7XHJcblRIUkVFLlRleHRHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5UZXh0R2VvbWV0cnk7XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9Ub3J1c0dlb21ldHJ5LmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBvb3Ntb3hpZWNvZGVcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogYmFzZWQgb24gaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2F3YXkzZC9zb3VyY2UvYnJvd3NlL3RydW5rL2ZwMTAvQXdheTNETGl0ZS9zcmMvYXdheTNkbGl0ZS9wcmltaXRpdmVzL1RvcnVzLmFzP3I9Mjg4OFxyXG4gKi9cclxuXHJcblRIUkVFLlRvcnVzR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHJhZGl1cywgdHViZSwgcmFkaWFsU2VnbWVudHMsIHR1YnVsYXJTZWdtZW50cywgYXJjICkge1xyXG5cclxuXHRUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMudHlwZSA9ICdUb3J1c0dlb21ldHJ5JztcclxuXHJcblx0dGhpcy5wYXJhbWV0ZXJzID0ge1xyXG5cdFx0cmFkaXVzOiByYWRpdXMsXHJcblx0XHR0dWJlOiB0dWJlLFxyXG5cdFx0cmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxyXG5cdFx0dHVidWxhclNlZ21lbnRzOiB0dWJ1bGFyU2VnbWVudHMsXHJcblx0XHRhcmM6IGFyY1xyXG5cdH07XHJcblxyXG5cdHJhZGl1cyA9IHJhZGl1cyB8fCAxMDA7XHJcblx0dHViZSA9IHR1YmUgfHwgNDA7XHJcblx0cmFkaWFsU2VnbWVudHMgPSByYWRpYWxTZWdtZW50cyB8fCA4O1xyXG5cdHR1YnVsYXJTZWdtZW50cyA9IHR1YnVsYXJTZWdtZW50cyB8fCA2O1xyXG5cdGFyYyA9IGFyYyB8fCBNYXRoLlBJICogMjtcclxuXHJcblx0dmFyIGNlbnRlciA9IG5ldyBUSFJFRS5WZWN0b3IzKCksIHV2cyA9IFtdLCBub3JtYWxzID0gW107XHJcblxyXG5cdGZvciAoIHZhciBqID0gMDsgaiA8PSByYWRpYWxTZWdtZW50czsgaiArKyApIHtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPD0gdHVidWxhclNlZ21lbnRzOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIHUgPSBpIC8gdHVidWxhclNlZ21lbnRzICogYXJjO1xyXG5cdFx0XHR2YXIgdiA9IGogLyByYWRpYWxTZWdtZW50cyAqIE1hdGguUEkgKiAyO1xyXG5cclxuXHRcdFx0Y2VudGVyLnggPSByYWRpdXMgKiBNYXRoLmNvcyggdSApO1xyXG5cdFx0XHRjZW50ZXIueSA9IHJhZGl1cyAqIE1hdGguc2luKCB1ICk7XHJcblxyXG5cdFx0XHR2YXIgdmVydGV4ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdFx0dmVydGV4LnggPSAoIHJhZGl1cyArIHR1YmUgKiBNYXRoLmNvcyggdiApICkgKiBNYXRoLmNvcyggdSApO1xyXG5cdFx0XHR2ZXJ0ZXgueSA9ICggcmFkaXVzICsgdHViZSAqIE1hdGguY29zKCB2ICkgKSAqIE1hdGguc2luKCB1ICk7XHJcblx0XHRcdHZlcnRleC56ID0gdHViZSAqIE1hdGguc2luKCB2ICk7XHJcblxyXG5cdFx0XHR0aGlzLnZlcnRpY2VzLnB1c2goIHZlcnRleCApO1xyXG5cclxuXHRcdFx0dXZzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCBpIC8gdHVidWxhclNlZ21lbnRzLCBqIC8gcmFkaWFsU2VnbWVudHMgKSApO1xyXG5cdFx0XHRub3JtYWxzLnB1c2goIHZlcnRleC5jbG9uZSgpLnN1YiggY2VudGVyICkubm9ybWFsaXplKCkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0Zm9yICggdmFyIGogPSAxOyBqIDw9IHJhZGlhbFNlZ21lbnRzOyBqICsrICkge1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMTsgaSA8PSB0dWJ1bGFyU2VnbWVudHM7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgYSA9ICggdHVidWxhclNlZ21lbnRzICsgMSApICogaiArIGkgLSAxO1xyXG5cdFx0XHR2YXIgYiA9ICggdHVidWxhclNlZ21lbnRzICsgMSApICogKCBqIC0gMSApICsgaSAtIDE7XHJcblx0XHRcdHZhciBjID0gKCB0dWJ1bGFyU2VnbWVudHMgKyAxICkgKiAoIGogLSAxICkgKyBpO1xyXG5cdFx0XHR2YXIgZCA9ICggdHVidWxhclNlZ21lbnRzICsgMSApICogaiArIGk7XHJcblxyXG5cdFx0XHR2YXIgZmFjZSA9IG5ldyBUSFJFRS5GYWNlMyggYSwgYiwgZCwgWyBub3JtYWxzWyBhIF0uY2xvbmUoKSwgbm9ybWFsc1sgYiBdLmNsb25lKCksIG5vcm1hbHNbIGQgXS5jbG9uZSgpIF0gKTtcclxuXHRcdFx0dGhpcy5mYWNlcy5wdXNoKCBmYWNlICk7XHJcblx0XHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZzWyBhIF0uY2xvbmUoKSwgdXZzWyBiIF0uY2xvbmUoKSwgdXZzWyBkIF0uY2xvbmUoKSBdICk7XHJcblxyXG5cdFx0XHRmYWNlID0gbmV3IFRIUkVFLkZhY2UzKCBiLCBjLCBkLCBbIG5vcm1hbHNbIGIgXS5jbG9uZSgpLCBub3JtYWxzWyBjIF0uY2xvbmUoKSwgbm9ybWFsc1sgZCBdLmNsb25lKCkgXSApO1xyXG5cdFx0XHR0aGlzLmZhY2VzLnB1c2goIGZhY2UgKTtcclxuXHRcdFx0dGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1dnNbIGIgXS5jbG9uZSgpLCB1dnNbIGMgXS5jbG9uZSgpLCB1dnNbIGQgXS5jbG9uZSgpIF0gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0dGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Ub3J1c0dlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG5USFJFRS5Ub3J1c0dlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlRvcnVzR2VvbWV0cnk7XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9Ub3J1c0tub3RHZW9tZXRyeS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3Igb29zbW94aWVjb2RlXHJcbiAqIGJhc2VkIG9uIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9hd2F5M2Qvc291cmNlL2Jyb3dzZS90cnVuay9mcDEwL0F3YXkzRC9zcmMvYXdheTNkL3ByaW1pdGl2ZXMvVG9ydXNLbm90LmFzP3NwZWM9c3ZuMjQ3MyZyPTI0NzNcclxuICovXHJcblxyXG5USFJFRS5Ub3J1c0tub3RHZW9tZXRyeSA9IGZ1bmN0aW9uICggcmFkaXVzLCB0dWJlLCByYWRpYWxTZWdtZW50cywgdHVidWxhclNlZ21lbnRzLCBwLCBxLCBoZWlnaHRTY2FsZSApIHtcclxuXHJcblx0VEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLnR5cGUgPSAnVG9ydXNLbm90R2VvbWV0cnknO1xyXG5cclxuXHR0aGlzLnBhcmFtZXRlcnMgPSB7XHJcblx0XHRyYWRpdXM6IHJhZGl1cyxcclxuXHRcdHR1YmU6IHR1YmUsXHJcblx0XHRyYWRpYWxTZWdtZW50czogcmFkaWFsU2VnbWVudHMsXHJcblx0XHR0dWJ1bGFyU2VnbWVudHM6IHR1YnVsYXJTZWdtZW50cyxcclxuXHRcdHA6IHAsXHJcblx0XHRxOiBxLFxyXG5cdFx0aGVpZ2h0U2NhbGU6IGhlaWdodFNjYWxlXHJcblx0fTtcclxuXHJcblx0cmFkaXVzID0gcmFkaXVzIHx8IDEwMDtcclxuXHR0dWJlID0gdHViZSB8fCA0MDtcclxuXHRyYWRpYWxTZWdtZW50cyA9IHJhZGlhbFNlZ21lbnRzIHx8IDY0O1xyXG5cdHR1YnVsYXJTZWdtZW50cyA9IHR1YnVsYXJTZWdtZW50cyB8fCA4O1xyXG5cdHAgPSBwIHx8IDI7XHJcblx0cSA9IHEgfHwgMztcclxuXHRoZWlnaHRTY2FsZSA9IGhlaWdodFNjYWxlIHx8IDE7XHJcblxyXG5cdHZhciBncmlkID0gbmV3IEFycmF5KCByYWRpYWxTZWdtZW50cyApO1xyXG5cdHZhciB0YW5nID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHR2YXIgbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0dmFyIGJpdGFuID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0Zm9yICggdmFyIGkgPSAwOyBpIDwgcmFkaWFsU2VnbWVudHM7ICsrIGkgKSB7XHJcblxyXG5cdFx0Z3JpZFsgaSBdID0gbmV3IEFycmF5KCB0dWJ1bGFyU2VnbWVudHMgKTtcclxuXHRcdHZhciB1ID0gaSAvIHJhZGlhbFNlZ21lbnRzICogMiAqIHAgKiBNYXRoLlBJO1xyXG5cdFx0dmFyIHAxID0gZ2V0UG9zKCB1LCBxLCBwLCByYWRpdXMsIGhlaWdodFNjYWxlICk7XHJcblx0XHR2YXIgcDIgPSBnZXRQb3MoIHUgKyAwLjAxLCBxLCBwLCByYWRpdXMsIGhlaWdodFNjYWxlICk7XHJcblx0XHR0YW5nLnN1YlZlY3RvcnMoIHAyLCBwMSApO1xyXG5cdFx0bi5hZGRWZWN0b3JzKCBwMiwgcDEgKTtcclxuXHJcblx0XHRiaXRhbi5jcm9zc1ZlY3RvcnMoIHRhbmcsIG4gKTtcclxuXHRcdG4uY3Jvc3NWZWN0b3JzKCBiaXRhbiwgdGFuZyApO1xyXG5cdFx0Yml0YW4ubm9ybWFsaXplKCk7XHJcblx0XHRuLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdGZvciAoIHZhciBqID0gMDsgaiA8IHR1YnVsYXJTZWdtZW50czsgKysgaiApIHtcclxuXHJcblx0XHRcdHZhciB2ID0gaiAvIHR1YnVsYXJTZWdtZW50cyAqIDIgKiBNYXRoLlBJO1xyXG5cdFx0XHR2YXIgY3ggPSAtIHR1YmUgKiBNYXRoLmNvcyggdiApOyAvLyBUT0RPOiBIYWNrOiBOZWdhdGluZyBpdCBzbyBpdCBmYWNlcyBvdXRzaWRlLlxyXG5cdFx0XHR2YXIgY3kgPSB0dWJlICogTWF0aC5zaW4oIHYgKTtcclxuXHJcblx0XHRcdHZhciBwb3MgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0XHRwb3MueCA9IHAxLnggKyBjeCAqIG4ueCArIGN5ICogYml0YW4ueDtcclxuXHRcdFx0cG9zLnkgPSBwMS55ICsgY3ggKiBuLnkgKyBjeSAqIGJpdGFuLnk7XHJcblx0XHRcdHBvcy56ID0gcDEueiArIGN4ICogbi56ICsgY3kgKiBiaXRhbi56O1xyXG5cclxuXHRcdFx0Z3JpZFsgaSBdWyBqIF0gPSB0aGlzLnZlcnRpY2VzLnB1c2goIHBvcyApIC0gMTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0Zm9yICggdmFyIGkgPSAwOyBpIDwgcmFkaWFsU2VnbWVudHM7ICsrIGkgKSB7XHJcblxyXG5cdFx0Zm9yICggdmFyIGogPSAwOyBqIDwgdHVidWxhclNlZ21lbnRzOyArKyBqICkge1xyXG5cclxuXHRcdFx0dmFyIGlwID0gKCBpICsgMSApICUgcmFkaWFsU2VnbWVudHM7XHJcblx0XHRcdHZhciBqcCA9ICggaiArIDEgKSAlIHR1YnVsYXJTZWdtZW50cztcclxuXHJcblx0XHRcdHZhciBhID0gZ3JpZFsgaSBdWyBqIF07XHJcblx0XHRcdHZhciBiID0gZ3JpZFsgaXAgXVsgaiBdO1xyXG5cdFx0XHR2YXIgYyA9IGdyaWRbIGlwIF1bIGpwIF07XHJcblx0XHRcdHZhciBkID0gZ3JpZFsgaSBdWyBqcCBdO1xyXG5cclxuXHRcdFx0dmFyIHV2YSA9IG5ldyBUSFJFRS5WZWN0b3IyKCBpIC8gcmFkaWFsU2VnbWVudHMsIGogLyB0dWJ1bGFyU2VnbWVudHMgKTtcclxuXHRcdFx0dmFyIHV2YiA9IG5ldyBUSFJFRS5WZWN0b3IyKCAoIGkgKyAxICkgLyByYWRpYWxTZWdtZW50cywgaiAvIHR1YnVsYXJTZWdtZW50cyApO1xyXG5cdFx0XHR2YXIgdXZjID0gbmV3IFRIUkVFLlZlY3RvcjIoICggaSArIDEgKSAvIHJhZGlhbFNlZ21lbnRzLCAoIGogKyAxICkgLyB0dWJ1bGFyU2VnbWVudHMgKTtcclxuXHRcdFx0dmFyIHV2ZCA9IG5ldyBUSFJFRS5WZWN0b3IyKCBpIC8gcmFkaWFsU2VnbWVudHMsICggaiArIDEgKSAvIHR1YnVsYXJTZWdtZW50cyApO1xyXG5cclxuXHRcdFx0dGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIGEsIGIsIGQgKSApO1xyXG5cdFx0XHR0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2YSwgdXZiLCB1dmQgXSApO1xyXG5cclxuXHRcdFx0dGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIGIsIGMsIGQgKSApO1xyXG5cdFx0XHR0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2Yi5jbG9uZSgpLCB1dmMsIHV2ZC5jbG9uZSgpIF0gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0dGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcclxuXHR0aGlzLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7XHJcblxyXG5cdGZ1bmN0aW9uIGdldFBvcyggdSwgaW5fcSwgaW5fcCwgcmFkaXVzLCBoZWlnaHRTY2FsZSApIHtcclxuXHJcblx0XHR2YXIgY3UgPSBNYXRoLmNvcyggdSApO1xyXG5cdFx0dmFyIHN1ID0gTWF0aC5zaW4oIHUgKTtcclxuXHRcdHZhciBxdU92ZXJQID0gaW5fcSAvIGluX3AgKiB1O1xyXG5cdFx0dmFyIGNzID0gTWF0aC5jb3MoIHF1T3ZlclAgKTtcclxuXHJcblx0XHR2YXIgdHggPSByYWRpdXMgKiAoIDIgKyBjcyApICogMC41ICogY3U7XHJcblx0XHR2YXIgdHkgPSByYWRpdXMgKiAoIDIgKyBjcyApICogc3UgKiAwLjU7XHJcblx0XHR2YXIgdHogPSBoZWlnaHRTY2FsZSAqIHJhZGl1cyAqIE1hdGguc2luKCBxdU92ZXJQICkgKiAwLjU7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IzKCB0eCwgdHksIHR6ICk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5Ub3J1c0tub3RHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuVEhSRUUuVG9ydXNLbm90R2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuVG9ydXNLbm90R2VvbWV0cnk7XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9UdWJlR2VvbWV0cnkuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cHM6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XHJcbiAqIEBhdXRob3Igeno4NSAvIGh0dHBzOi8vZ2l0aHViLmNvbS96ejg1XHJcbiAqIEBhdXRob3IgbWluaW5nb2xkIC8gaHR0cHM6Ly9naXRodWIuY29tL21pbmluZ29sZFxyXG4gKiBAYXV0aG9yIGpvbm9icjEgLyBodHRwczovL2dpdGh1Yi5jb20vam9ub2JyMVxyXG4gKlxyXG4gKiBNb2RpZmllZCBmcm9tIHRoZSBUb3J1c0tub3RHZW9tZXRyeSBieSBAb29zbW94aWVjb2RlXHJcbiAqXHJcbiAqIENyZWF0ZXMgYSB0dWJlIHdoaWNoIGV4dHJ1ZGVzIGFsb25nIGEgM2Qgc3BsaW5lXHJcbiAqXHJcbiAqIFVzZXMgcGFyYWxsZWwgdHJhbnNwb3J0IGZyYW1lcyBhcyBkZXNjcmliZWQgaW5cclxuICogaHR0cDovL3d3dy5jcy5pbmRpYW5hLmVkdS9wdWIvdGVjaHJlcG9ydHMvVFI0MjUucGRmXHJcbiAqL1xyXG5cclxuVEhSRUUuVHViZUdlb21ldHJ5ID0gZnVuY3Rpb24gKCBwYXRoLCBzZWdtZW50cywgcmFkaXVzLCByYWRpYWxTZWdtZW50cywgY2xvc2VkLCB0YXBlciApIHtcclxuXHJcblx0VEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLnR5cGUgPSAnVHViZUdlb21ldHJ5JztcclxuXHJcblx0dGhpcy5wYXJhbWV0ZXJzID0ge1xyXG5cdFx0cGF0aDogcGF0aCxcclxuXHRcdHNlZ21lbnRzOiBzZWdtZW50cyxcclxuXHRcdHJhZGl1czogcmFkaXVzLFxyXG5cdFx0cmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxyXG5cdFx0Y2xvc2VkOiBjbG9zZWQsXHJcblx0XHR0YXBlcjogdGFwZXJcclxuXHR9O1xyXG5cclxuXHRzZWdtZW50cyA9IHNlZ21lbnRzIHx8IDY0O1xyXG5cdHJhZGl1cyA9IHJhZGl1cyB8fCAxO1xyXG5cdHJhZGlhbFNlZ21lbnRzID0gcmFkaWFsU2VnbWVudHMgfHwgODtcclxuXHRjbG9zZWQgPSBjbG9zZWQgfHwgZmFsc2U7XHJcblx0dGFwZXIgPSB0YXBlciB8fCBUSFJFRS5UdWJlR2VvbWV0cnkuTm9UYXBlcjtcclxuXHJcblx0dmFyIGdyaWQgPSBbXTtcclxuXHJcblx0dmFyIHNjb3BlID0gdGhpcyxcclxuXHJcblx0XHR0YW5nZW50LFxyXG5cdFx0bm9ybWFsLFxyXG5cdFx0Ymlub3JtYWwsXHJcblxyXG5cdFx0bnVtcG9pbnRzID0gc2VnbWVudHMgKyAxLFxyXG5cclxuXHRcdHUsIHYsIHIsXHJcblxyXG5cdFx0Y3gsIGN5LFxyXG5cdFx0cG9zLCBwb3MyID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHRcdGksIGosXHJcblx0XHRpcCwganAsXHJcblx0XHRhLCBiLCBjLCBkLFxyXG5cdFx0dXZhLCB1dmIsIHV2YywgdXZkO1xyXG5cclxuXHR2YXIgZnJhbWVzID0gbmV3IFRIUkVFLlR1YmVHZW9tZXRyeS5GcmVuZXRGcmFtZXMoIHBhdGgsIHNlZ21lbnRzLCBjbG9zZWQgKSxcclxuXHRcdHRhbmdlbnRzID0gZnJhbWVzLnRhbmdlbnRzLFxyXG5cdFx0bm9ybWFscyA9IGZyYW1lcy5ub3JtYWxzLFxyXG5cdFx0Ymlub3JtYWxzID0gZnJhbWVzLmJpbm9ybWFscztcclxuXHJcblx0Ly8gcHJveHkgaW50ZXJuYWxzXHJcblx0dGhpcy50YW5nZW50cyA9IHRhbmdlbnRzO1xyXG5cdHRoaXMubm9ybWFscyA9IG5vcm1hbHM7XHJcblx0dGhpcy5iaW5vcm1hbHMgPSBiaW5vcm1hbHM7XHJcblxyXG5cdGZ1bmN0aW9uIHZlcnQoIHgsIHksIHogKSB7XHJcblxyXG5cdFx0cmV0dXJuIHNjb3BlLnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCB4LCB5LCB6ICkgKSAtIDE7XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gY29uc3RydWN0IHRoZSBncmlkXHJcblxyXG5cdGZvciAoIGkgPSAwOyBpIDwgbnVtcG9pbnRzOyBpICsrICkge1xyXG5cclxuXHRcdGdyaWRbIGkgXSA9IFtdO1xyXG5cclxuXHRcdHUgPSBpIC8gKCBudW1wb2ludHMgLSAxICk7XHJcblxyXG5cdFx0cG9zID0gcGF0aC5nZXRQb2ludEF0KCB1ICk7XHJcblxyXG5cdFx0dGFuZ2VudCA9IHRhbmdlbnRzWyBpIF07XHJcblx0XHRub3JtYWwgPSBub3JtYWxzWyBpIF07XHJcblx0XHRiaW5vcm1hbCA9IGJpbm9ybWFsc1sgaSBdO1xyXG5cclxuXHRcdHIgPSByYWRpdXMgKiB0YXBlciggdSApO1xyXG5cclxuXHRcdGZvciAoIGogPSAwOyBqIDwgcmFkaWFsU2VnbWVudHM7IGogKysgKSB7XHJcblxyXG5cdFx0XHR2ID0gaiAvIHJhZGlhbFNlZ21lbnRzICogMiAqIE1hdGguUEk7XHJcblxyXG5cdFx0XHRjeCA9IC0gciAqIE1hdGguY29zKCB2ICk7IC8vIFRPRE86IEhhY2s6IE5lZ2F0aW5nIGl0IHNvIGl0IGZhY2VzIG91dHNpZGUuXHJcblx0XHRcdGN5ID0gciAqIE1hdGguc2luKCB2ICk7XHJcblxyXG5cdFx0XHRwb3MyLmNvcHkoIHBvcyApO1xyXG5cdFx0XHRwb3MyLnggKz0gY3ggKiBub3JtYWwueCArIGN5ICogYmlub3JtYWwueDtcclxuXHRcdFx0cG9zMi55ICs9IGN4ICogbm9ybWFsLnkgKyBjeSAqIGJpbm9ybWFsLnk7XHJcblx0XHRcdHBvczIueiArPSBjeCAqIG5vcm1hbC56ICsgY3kgKiBiaW5vcm1hbC56O1xyXG5cclxuXHRcdFx0Z3JpZFsgaSBdWyBqIF0gPSB2ZXJ0KCBwb3MyLngsIHBvczIueSwgcG9zMi56ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cclxuXHQvLyBjb25zdHJ1Y3QgdGhlIG1lc2hcclxuXHJcblx0Zm9yICggaSA9IDA7IGkgPCBzZWdtZW50czsgaSArKyApIHtcclxuXHJcblx0XHRmb3IgKCBqID0gMDsgaiA8IHJhZGlhbFNlZ21lbnRzOyBqICsrICkge1xyXG5cclxuXHRcdFx0aXAgPSAoIGNsb3NlZCApID8gKCBpICsgMSApICUgc2VnbWVudHMgOiBpICsgMTtcclxuXHRcdFx0anAgPSAoIGogKyAxICkgJSByYWRpYWxTZWdtZW50cztcclxuXHJcblx0XHRcdGEgPSBncmlkWyBpIF1bIGogXTtcdFx0Ly8gKioqIE5PVCBORUNFU1NBUklMWSBQTEFOQVIgISAqKipcclxuXHRcdFx0YiA9IGdyaWRbIGlwIF1bIGogXTtcclxuXHRcdFx0YyA9IGdyaWRbIGlwIF1bIGpwIF07XHJcblx0XHRcdGQgPSBncmlkWyBpIF1bIGpwIF07XHJcblxyXG5cdFx0XHR1dmEgPSBuZXcgVEhSRUUuVmVjdG9yMiggaSAvIHNlZ21lbnRzLCBqIC8gcmFkaWFsU2VnbWVudHMgKTtcclxuXHRcdFx0dXZiID0gbmV3IFRIUkVFLlZlY3RvcjIoICggaSArIDEgKSAvIHNlZ21lbnRzLCBqIC8gcmFkaWFsU2VnbWVudHMgKTtcclxuXHRcdFx0dXZjID0gbmV3IFRIUkVFLlZlY3RvcjIoICggaSArIDEgKSAvIHNlZ21lbnRzLCAoIGogKyAxICkgLyByYWRpYWxTZWdtZW50cyApO1xyXG5cdFx0XHR1dmQgPSBuZXcgVEhSRUUuVmVjdG9yMiggaSAvIHNlZ21lbnRzLCAoIGogKyAxICkgLyByYWRpYWxTZWdtZW50cyApO1xyXG5cclxuXHRcdFx0dGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIGEsIGIsIGQgKSApO1xyXG5cdFx0XHR0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2YSwgdXZiLCB1dmQgXSApO1xyXG5cclxuXHRcdFx0dGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIGIsIGMsIGQgKSApO1xyXG5cdFx0XHR0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2Yi5jbG9uZSgpLCB1dmMsIHV2ZC5jbG9uZSgpIF0gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0dGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcclxuXHR0aGlzLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuVHViZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG5USFJFRS5UdWJlR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuVHViZUdlb21ldHJ5O1xyXG5cclxuVEhSRUUuVHViZUdlb21ldHJ5Lk5vVGFwZXIgPSBmdW5jdGlvbiAoIHUgKSB7XHJcblxyXG5cdHJldHVybiAxO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlR1YmVHZW9tZXRyeS5TaW51c29pZGFsVGFwZXIgPSBmdW5jdGlvbiAoIHUgKSB7XHJcblxyXG5cdHJldHVybiBNYXRoLnNpbiggTWF0aC5QSSAqIHUgKTtcclxuXHJcbn07XHJcblxyXG4vLyBGb3IgY29tcHV0aW5nIG9mIEZyZW5ldCBmcmFtZXMsIGV4cG9zaW5nIHRoZSB0YW5nZW50cywgbm9ybWFscyBhbmQgYmlub3JtYWxzIHRoZSBzcGxpbmVcclxuVEhSRUUuVHViZUdlb21ldHJ5LkZyZW5ldEZyYW1lcyA9IGZ1bmN0aW9uICggcGF0aCwgc2VnbWVudHMsIGNsb3NlZCApIHtcclxuXHJcblx0dmFyXHRub3JtYWwgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG5cclxuXHRcdHRhbmdlbnRzID0gW10sXHJcblx0XHRub3JtYWxzID0gW10sXHJcblx0XHRiaW5vcm1hbHMgPSBbXSxcclxuXHJcblx0XHR2ZWMgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG5cdFx0bWF0ID0gbmV3IFRIUkVFLk1hdHJpeDQoKSxcclxuXHJcblx0XHRudW1wb2ludHMgPSBzZWdtZW50cyArIDEsXHJcblx0XHR0aGV0YSxcclxuXHRcdHNtYWxsZXN0LFxyXG5cclxuXHRcdHR4LCB0eSwgdHosXHJcblx0XHRpLCB1O1xyXG5cclxuXHJcblx0Ly8gZXhwb3NlIGludGVybmFsc1xyXG5cdHRoaXMudGFuZ2VudHMgPSB0YW5nZW50cztcclxuXHR0aGlzLm5vcm1hbHMgPSBub3JtYWxzO1xyXG5cdHRoaXMuYmlub3JtYWxzID0gYmlub3JtYWxzO1xyXG5cclxuXHQvLyBjb21wdXRlIHRoZSB0YW5nZW50IHZlY3RvcnMgZm9yIGVhY2ggc2VnbWVudCBvbiB0aGUgcGF0aFxyXG5cclxuXHRmb3IgKCBpID0gMDsgaSA8IG51bXBvaW50czsgaSArKyApIHtcclxuXHJcblx0XHR1ID0gaSAvICggbnVtcG9pbnRzIC0gMSApO1xyXG5cclxuXHRcdHRhbmdlbnRzWyBpIF0gPSBwYXRoLmdldFRhbmdlbnRBdCggdSApO1xyXG5cdFx0dGFuZ2VudHNbIGkgXS5ub3JtYWxpemUoKTtcclxuXHJcblx0fVxyXG5cclxuXHRpbml0aWFsTm9ybWFsMygpO1xyXG5cclxuXHQvKlxyXG5cdGZ1bmN0aW9uIGluaXRpYWxOb3JtYWwxKGxhc3RCaW5vcm1hbCkge1xyXG5cdFx0Ly8gZml4ZWQgc3RhcnQgYmlub3JtYWwuIEhhcyBkYW5nZXJzIG9mIDAgdmVjdG9yc1xyXG5cdFx0bm9ybWFsc1sgMCBdID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdGJpbm9ybWFsc1sgMCBdID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdGlmIChsYXN0Qmlub3JtYWw9PT11bmRlZmluZWQpIGxhc3RCaW5vcm1hbCA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAwLCAxICk7XHJcblx0XHRub3JtYWxzWyAwIF0uY3Jvc3NWZWN0b3JzKCBsYXN0Qmlub3JtYWwsIHRhbmdlbnRzWyAwIF0gKS5ub3JtYWxpemUoKTtcclxuXHRcdGJpbm9ybWFsc1sgMCBdLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIDAgXSwgbm9ybWFsc1sgMCBdICkubm9ybWFsaXplKCk7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBpbml0aWFsTm9ybWFsMigpIHtcclxuXHJcblx0XHQvLyBUaGlzIHVzZXMgdGhlIEZyZW5ldC1TZXJyZXQgZm9ybXVsYSBmb3IgZGVyaXZpbmcgYmlub3JtYWxcclxuXHRcdHZhciB0MiA9IHBhdGguZ2V0VGFuZ2VudEF0KCBlcHNpbG9uICk7XHJcblxyXG5cdFx0bm9ybWFsc1sgMCBdID0gbmV3IFRIUkVFLlZlY3RvcjMoKS5zdWJWZWN0b3JzKCB0MiwgdGFuZ2VudHNbIDAgXSApLm5vcm1hbGl6ZSgpO1xyXG5cdFx0Ymlub3JtYWxzWyAwIF0gPSBuZXcgVEhSRUUuVmVjdG9yMygpLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIDAgXSwgbm9ybWFsc1sgMCBdICk7XHJcblxyXG5cdFx0bm9ybWFsc1sgMCBdLmNyb3NzVmVjdG9ycyggYmlub3JtYWxzWyAwIF0sIHRhbmdlbnRzWyAwIF0gKS5ub3JtYWxpemUoKTsgLy8gbGFzdCBiaW5vcm1hbCB4IHRhbmdlbnRcclxuXHRcdGJpbm9ybWFsc1sgMCBdLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIDAgXSwgbm9ybWFsc1sgMCBdICkubm9ybWFsaXplKCk7XHJcblxyXG5cdH1cclxuXHQqL1xyXG5cclxuXHRmdW5jdGlvbiBpbml0aWFsTm9ybWFsMygpIHtcclxuXHJcblx0XHQvLyBzZWxlY3QgYW4gaW5pdGlhbCBub3JtYWwgdmVjdG9yIHBlcnBlbmRpY3VsYXIgdG8gdGhlIGZpcnN0IHRhbmdlbnQgdmVjdG9yLFxyXG5cdFx0Ly8gYW5kIGluIHRoZSBkaXJlY3Rpb24gb2YgdGhlIHNtYWxsZXN0IHRhbmdlbnQgeHl6IGNvbXBvbmVudFxyXG5cclxuXHRcdG5vcm1hbHNbIDAgXSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHRiaW5vcm1hbHNbIDAgXSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHRzbWFsbGVzdCA9IE51bWJlci5NQVhfVkFMVUU7XHJcblx0XHR0eCA9IE1hdGguYWJzKCB0YW5nZW50c1sgMCBdLnggKTtcclxuXHRcdHR5ID0gTWF0aC5hYnMoIHRhbmdlbnRzWyAwIF0ueSApO1xyXG5cdFx0dHogPSBNYXRoLmFicyggdGFuZ2VudHNbIDAgXS56ICk7XHJcblxyXG5cdFx0aWYgKCB0eCA8PSBzbWFsbGVzdCApIHtcclxuXHJcblx0XHRcdHNtYWxsZXN0ID0gdHg7XHJcblx0XHRcdG5vcm1hbC5zZXQoIDEsIDAsIDAgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0eSA8PSBzbWFsbGVzdCApIHtcclxuXHJcblx0XHRcdHNtYWxsZXN0ID0gdHk7XHJcblx0XHRcdG5vcm1hbC5zZXQoIDAsIDEsIDAgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0eiA8PSBzbWFsbGVzdCApIHtcclxuXHJcblx0XHRcdG5vcm1hbC5zZXQoIDAsIDAsIDEgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmVjLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIDAgXSwgbm9ybWFsICkubm9ybWFsaXplKCk7XHJcblxyXG5cdFx0bm9ybWFsc1sgMCBdLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIDAgXSwgdmVjICk7XHJcblx0XHRiaW5vcm1hbHNbIDAgXS5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyAwIF0sIG5vcm1hbHNbIDAgXSApO1xyXG5cclxuXHR9XHJcblxyXG5cclxuXHQvLyBjb21wdXRlIHRoZSBzbG93bHktdmFyeWluZyBub3JtYWwgYW5kIGJpbm9ybWFsIHZlY3RvcnMgZm9yIGVhY2ggc2VnbWVudCBvbiB0aGUgcGF0aFxyXG5cclxuXHRmb3IgKCBpID0gMTsgaSA8IG51bXBvaW50czsgaSArKyApIHtcclxuXHJcblx0XHRub3JtYWxzWyBpIF0gPSBub3JtYWxzWyBpIC0gMSBdLmNsb25lKCk7XHJcblxyXG5cdFx0Ymlub3JtYWxzWyBpIF0gPSBiaW5vcm1hbHNbIGkgLSAxIF0uY2xvbmUoKTtcclxuXHJcblx0XHR2ZWMuY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgaSAtIDEgXSwgdGFuZ2VudHNbIGkgXSApO1xyXG5cclxuXHRcdGlmICggdmVjLmxlbmd0aCgpID4gTnVtYmVyLkVQU0lMT04gKSB7XHJcblxyXG5cdFx0XHR2ZWMubm9ybWFsaXplKCk7XHJcblxyXG5cdFx0XHR0aGV0YSA9IE1hdGguYWNvcyggVEhSRUUuTWF0aC5jbGFtcCggdGFuZ2VudHNbIGkgLSAxIF0uZG90KCB0YW5nZW50c1sgaSBdICksIC0gMSwgMSApICk7IC8vIGNsYW1wIGZvciBmbG9hdGluZyBwdCBlcnJvcnNcclxuXHJcblx0XHRcdG5vcm1hbHNbIGkgXS5hcHBseU1hdHJpeDQoIG1hdC5tYWtlUm90YXRpb25BeGlzKCB2ZWMsIHRoZXRhICkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ymlub3JtYWxzWyBpIF0uY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgaSBdLCBub3JtYWxzWyBpIF0gKTtcclxuXHJcblx0fVxyXG5cclxuXHJcblx0Ly8gaWYgdGhlIGN1cnZlIGlzIGNsb3NlZCwgcG9zdHByb2Nlc3MgdGhlIHZlY3RvcnMgc28gdGhlIGZpcnN0IGFuZCBsYXN0IG5vcm1hbCB2ZWN0b3JzIGFyZSB0aGUgc2FtZVxyXG5cclxuXHRpZiAoIGNsb3NlZCApIHtcclxuXHJcblx0XHR0aGV0YSA9IE1hdGguYWNvcyggVEhSRUUuTWF0aC5jbGFtcCggbm9ybWFsc1sgMCBdLmRvdCggbm9ybWFsc1sgbnVtcG9pbnRzIC0gMSBdICksIC0gMSwgMSApICk7XHJcblx0XHR0aGV0YSAvPSAoIG51bXBvaW50cyAtIDEgKTtcclxuXHJcblx0XHRpZiAoIHRhbmdlbnRzWyAwIF0uZG90KCB2ZWMuY3Jvc3NWZWN0b3JzKCBub3JtYWxzWyAwIF0sIG5vcm1hbHNbIG51bXBvaW50cyAtIDEgXSApICkgPiAwICkge1xyXG5cclxuXHRcdFx0dGhldGEgPSAtIHRoZXRhO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKCBpID0gMTsgaSA8IG51bXBvaW50czsgaSArKyApIHtcclxuXHJcblx0XHRcdC8vIHR3aXN0IGEgbGl0dGxlLi4uXHJcblx0XHRcdG5vcm1hbHNbIGkgXS5hcHBseU1hdHJpeDQoIG1hdC5tYWtlUm90YXRpb25BeGlzKCB0YW5nZW50c1sgaSBdLCB0aGV0YSAqIGkgKSApO1xyXG5cdFx0XHRiaW5vcm1hbHNbIGkgXS5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyBpIF0sIG5vcm1hbHNbIGkgXSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL1BvbHloZWRyb25HZW9tZXRyeS5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgY2xvY2t3b3JrZ2VlayAvIGh0dHBzOi8vZ2l0aHViLmNvbS9jbG9ja3dvcmtnZWVrXHJcbiAqIEBhdXRob3IgdGltb3RoeXByYXRsZXkgLyBodHRwczovL2dpdGh1Yi5jb20vdGltb3RoeXByYXRsZXlcclxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XHJcbiovXHJcblxyXG5USFJFRS5Qb2x5aGVkcm9uR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHZlcnRpY2VzLCBpbmRpY2VzLCByYWRpdXMsIGRldGFpbCApIHtcclxuXHJcblx0VEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLnR5cGUgPSAnUG9seWhlZHJvbkdlb21ldHJ5JztcclxuXHJcblx0dGhpcy5wYXJhbWV0ZXJzID0ge1xyXG5cdFx0dmVydGljZXM6IHZlcnRpY2VzLFxyXG5cdFx0aW5kaWNlczogaW5kaWNlcyxcclxuXHRcdHJhZGl1czogcmFkaXVzLFxyXG5cdFx0ZGV0YWlsOiBkZXRhaWxcclxuXHR9O1xyXG5cclxuXHRyYWRpdXMgPSByYWRpdXMgfHwgMTtcclxuXHRkZXRhaWwgPSBkZXRhaWwgfHwgMDtcclxuXHJcblx0dmFyIHRoYXQgPSB0aGlzO1xyXG5cclxuXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB2ZXJ0aWNlcy5sZW5ndGg7IGkgPCBsOyBpICs9IDMgKSB7XHJcblxyXG5cdFx0cHJlcGFyZSggbmV3IFRIUkVFLlZlY3RvcjMoIHZlcnRpY2VzWyBpIF0sIHZlcnRpY2VzWyBpICsgMSBdLCB2ZXJ0aWNlc1sgaSArIDIgXSApICk7XHJcblxyXG5cdH1cclxuXHJcblx0dmFyIHAgPSB0aGlzLnZlcnRpY2VzO1xyXG5cclxuXHR2YXIgZmFjZXMgPSBbXTtcclxuXHJcblx0Zm9yICggdmFyIGkgPSAwLCBqID0gMCwgbCA9IGluZGljZXMubGVuZ3RoOyBpIDwgbDsgaSArPSAzLCBqICsrICkge1xyXG5cclxuXHRcdHZhciB2MSA9IHBbIGluZGljZXNbIGkgXSBdO1xyXG5cdFx0dmFyIHYyID0gcFsgaW5kaWNlc1sgaSArIDEgXSBdO1xyXG5cdFx0dmFyIHYzID0gcFsgaW5kaWNlc1sgaSArIDIgXSBdO1xyXG5cclxuXHRcdGZhY2VzWyBqIF0gPSBuZXcgVEhSRUUuRmFjZTMoIHYxLmluZGV4LCB2Mi5pbmRleCwgdjMuaW5kZXgsIFsgdjEuY2xvbmUoKSwgdjIuY2xvbmUoKSwgdjMuY2xvbmUoKSBdLCB1bmRlZmluZWQsIGogKTtcclxuXHJcblx0fVxyXG5cclxuXHR2YXIgY2VudHJvaWQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBmYWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdHN1YmRpdmlkZSggZmFjZXNbIGkgXSwgZGV0YWlsICk7XHJcblxyXG5cdH1cclxuXHJcblxyXG5cdC8vIEhhbmRsZSBjYXNlIHdoZW4gZmFjZSBzdHJhZGRsZXMgdGhlIHNlYW1cclxuXHJcblx0Zm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHR2YXIgdXZzID0gdGhpcy5mYWNlVmVydGV4VXZzWyAwIF1bIGkgXTtcclxuXHJcblx0XHR2YXIgeDAgPSB1dnNbIDAgXS54O1xyXG5cdFx0dmFyIHgxID0gdXZzWyAxIF0ueDtcclxuXHRcdHZhciB4MiA9IHV2c1sgMiBdLng7XHJcblxyXG5cdFx0dmFyIG1heCA9IE1hdGgubWF4KCB4MCwgeDEsIHgyICk7XHJcblx0XHR2YXIgbWluID0gTWF0aC5taW4oIHgwLCB4MSwgeDIgKTtcclxuXHJcblx0XHRpZiAoIG1heCA+IDAuOSAmJiBtaW4gPCAwLjEgKSB7XHJcblxyXG5cdFx0XHQvLyAwLjkgaXMgc29tZXdoYXQgYXJiaXRyYXJ5XHJcblxyXG5cdFx0XHRpZiAoIHgwIDwgMC4yICkgdXZzWyAwIF0ueCArPSAxO1xyXG5cdFx0XHRpZiAoIHgxIDwgMC4yICkgdXZzWyAxIF0ueCArPSAxO1xyXG5cdFx0XHRpZiAoIHgyIDwgMC4yICkgdXZzWyAyIF0ueCArPSAxO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHJcblx0Ly8gQXBwbHkgcmFkaXVzXHJcblxyXG5cdGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMudmVydGljZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHR0aGlzLnZlcnRpY2VzWyBpIF0ubXVsdGlwbHlTY2FsYXIoIHJhZGl1cyApO1xyXG5cclxuXHR9XHJcblxyXG5cclxuXHQvLyBNZXJnZSB2ZXJ0aWNlc1xyXG5cclxuXHR0aGlzLm1lcmdlVmVydGljZXMoKTtcclxuXHJcblx0dGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcclxuXHJcblx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG5ldyBUSFJFRS5TcGhlcmUoIG5ldyBUSFJFRS5WZWN0b3IzKCksIHJhZGl1cyApO1xyXG5cclxuXHJcblx0Ly8gUHJvamVjdCB2ZWN0b3Igb250byBzcGhlcmUncyBzdXJmYWNlXHJcblxyXG5cdGZ1bmN0aW9uIHByZXBhcmUoIHZlY3RvciApIHtcclxuXHJcblx0XHR2YXIgdmVydGV4ID0gdmVjdG9yLm5vcm1hbGl6ZSgpLmNsb25lKCk7XHJcblx0XHR2ZXJ0ZXguaW5kZXggPSB0aGF0LnZlcnRpY2VzLnB1c2goIHZlcnRleCApIC0gMTtcclxuXHJcblx0XHQvLyBUZXh0dXJlIGNvb3JkcyBhcmUgZXF1aXZhbGVudCB0byBtYXAgY29vcmRzLCBjYWxjdWxhdGUgYW5nbGUgYW5kIGNvbnZlcnQgdG8gZnJhY3Rpb24gb2YgYSBjaXJjbGUuXHJcblxyXG5cdFx0dmFyIHUgPSBhemltdXRoKCB2ZWN0b3IgKSAvIDIgLyBNYXRoLlBJICsgMC41O1xyXG5cdFx0dmFyIHYgPSBpbmNsaW5hdGlvbiggdmVjdG9yICkgLyBNYXRoLlBJICsgMC41O1xyXG5cdFx0dmVydGV4LnV2ID0gbmV3IFRIUkVFLlZlY3RvcjIoIHUsIDEgLSB2ICk7XHJcblxyXG5cdFx0cmV0dXJuIHZlcnRleDtcclxuXHJcblx0fVxyXG5cclxuXHJcblx0Ly8gQXBwcm94aW1hdGUgYSBjdXJ2ZWQgZmFjZSB3aXRoIHJlY3Vyc2l2ZWx5IHN1Yi1kaXZpZGVkIHRyaWFuZ2xlcy5cclxuXHJcblx0ZnVuY3Rpb24gbWFrZSggdjEsIHYyLCB2MywgbWF0ZXJpYWxJbmRleCApIHtcclxuXHJcblx0XHR2YXIgZmFjZSA9IG5ldyBUSFJFRS5GYWNlMyggdjEuaW5kZXgsIHYyLmluZGV4LCB2My5pbmRleCwgWyB2MS5jbG9uZSgpLCB2Mi5jbG9uZSgpLCB2My5jbG9uZSgpIF0sIHVuZGVmaW5lZCwgbWF0ZXJpYWxJbmRleCApO1xyXG5cdFx0dGhhdC5mYWNlcy5wdXNoKCBmYWNlICk7XHJcblxyXG5cdFx0Y2VudHJvaWQuY29weSggdjEgKS5hZGQoIHYyICkuYWRkKCB2MyApLmRpdmlkZVNjYWxhciggMyApO1xyXG5cclxuXHRcdHZhciBhemkgPSBhemltdXRoKCBjZW50cm9pZCApO1xyXG5cclxuXHRcdHRoYXQuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFtcclxuXHRcdFx0Y29ycmVjdFVWKCB2MS51diwgdjEsIGF6aSApLFxyXG5cdFx0XHRjb3JyZWN0VVYoIHYyLnV2LCB2MiwgYXppICksXHJcblx0XHRcdGNvcnJlY3RVViggdjMudXYsIHYzLCBhemkgKVxyXG5cdFx0XSApO1xyXG5cclxuXHR9XHJcblxyXG5cclxuXHQvLyBBbmFseXRpY2FsbHkgc3ViZGl2aWRlIGEgZmFjZSB0byB0aGUgcmVxdWlyZWQgZGV0YWlsIGxldmVsLlxyXG5cclxuXHRmdW5jdGlvbiBzdWJkaXZpZGUoIGZhY2UsIGRldGFpbCApIHtcclxuXHJcblx0XHR2YXIgY29scyA9IE1hdGgucG93KCAyLCBkZXRhaWwgKTtcclxuXHRcdHZhciBhID0gcHJlcGFyZSggdGhhdC52ZXJ0aWNlc1sgZmFjZS5hIF0gKTtcclxuXHRcdHZhciBiID0gcHJlcGFyZSggdGhhdC52ZXJ0aWNlc1sgZmFjZS5iIF0gKTtcclxuXHRcdHZhciBjID0gcHJlcGFyZSggdGhhdC52ZXJ0aWNlc1sgZmFjZS5jIF0gKTtcclxuXHRcdHZhciB2ID0gW107XHJcblxyXG5cdFx0dmFyIG1hdGVyaWFsSW5kZXggPSBmYWNlLm1hdGVyaWFsSW5kZXg7XHJcblxyXG5cdFx0Ly8gQ29uc3RydWN0IGFsbCBvZiB0aGUgdmVydGljZXMgZm9yIHRoaXMgc3ViZGl2aXNpb24uXHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwIDsgaSA8PSBjb2xzOyBpICsrICkge1xyXG5cclxuXHRcdFx0dlsgaSBdID0gW107XHJcblxyXG5cdFx0XHR2YXIgYWogPSBwcmVwYXJlKCBhLmNsb25lKCkubGVycCggYywgaSAvIGNvbHMgKSApO1xyXG5cdFx0XHR2YXIgYmogPSBwcmVwYXJlKCBiLmNsb25lKCkubGVycCggYywgaSAvIGNvbHMgKSApO1xyXG5cdFx0XHR2YXIgcm93cyA9IGNvbHMgLSBpO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGogPSAwOyBqIDw9IHJvd3M7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggaiA9PT0gMCAmJiBpID09PSBjb2xzICkge1xyXG5cclxuXHRcdFx0XHRcdHZbIGkgXVsgaiBdID0gYWo7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0dlsgaSBdWyBqIF0gPSBwcmVwYXJlKCBhai5jbG9uZSgpLmxlcnAoIGJqLCBqIC8gcm93cyApICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQ29uc3RydWN0IGFsbCBvZiB0aGUgZmFjZXMuXHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgY29scyA7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCAyICogKCBjb2xzIC0gaSApIC0gMTsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0dmFyIGsgPSBNYXRoLmZsb29yKCBqIC8gMiApO1xyXG5cclxuXHRcdFx0XHRpZiAoIGogJSAyID09PSAwICkge1xyXG5cclxuXHRcdFx0XHRcdG1ha2UoXHJcblx0XHRcdFx0XHRcdHZbIGkgXVsgayArIDEgXSxcclxuXHRcdFx0XHRcdFx0dlsgaSArIDEgXVsgayBdLFxyXG5cdFx0XHRcdFx0XHR2WyBpIF1bIGsgXSxcclxuXHRcdFx0XHRcdFx0bWF0ZXJpYWxJbmRleFxyXG5cdFx0XHRcdFx0KTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRtYWtlKFxyXG5cdFx0XHRcdFx0XHR2WyBpIF1bIGsgKyAxIF0sXHJcblx0XHRcdFx0XHRcdHZbIGkgKyAxIF1bIGsgKyAxIF0sXHJcblx0XHRcdFx0XHRcdHZbIGkgKyAxIF1bIGsgXSxcclxuXHRcdFx0XHRcdFx0bWF0ZXJpYWxJbmRleFxyXG5cdFx0XHRcdFx0KTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHJcblx0Ly8gQW5nbGUgYXJvdW5kIHRoZSBZIGF4aXMsIGNvdW50ZXItY2xvY2t3aXNlIHdoZW4gbG9va2luZyBmcm9tIGFib3ZlLlxyXG5cclxuXHRmdW5jdGlvbiBhemltdXRoKCB2ZWN0b3IgKSB7XHJcblxyXG5cdFx0cmV0dXJuIE1hdGguYXRhbjIoIHZlY3Rvci56LCAtIHZlY3Rvci54ICk7XHJcblxyXG5cdH1cclxuXHJcblxyXG5cdC8vIEFuZ2xlIGFib3ZlIHRoZSBYWiBwbGFuZS5cclxuXHJcblx0ZnVuY3Rpb24gaW5jbGluYXRpb24oIHZlY3RvciApIHtcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5hdGFuMiggLSB2ZWN0b3IueSwgTWF0aC5zcXJ0KCAoIHZlY3Rvci54ICogdmVjdG9yLnggKSArICggdmVjdG9yLnogKiB2ZWN0b3IueiApICkgKTtcclxuXHJcblx0fVxyXG5cclxuXHJcblx0Ly8gVGV4dHVyZSBmaXhpbmcgaGVscGVyLiBTcGhlcmVzIGhhdmUgc29tZSBvZGQgYmVoYXZpb3Vycy5cclxuXHJcblx0ZnVuY3Rpb24gY29ycmVjdFVWKCB1diwgdmVjdG9yLCBhemltdXRoICkge1xyXG5cclxuXHRcdGlmICggKCBhemltdXRoIDwgMCApICYmICggdXYueCA9PT0gMSApICkgdXYgPSBuZXcgVEhSRUUuVmVjdG9yMiggdXYueCAtIDEsIHV2LnkgKTtcclxuXHRcdGlmICggKCB2ZWN0b3IueCA9PT0gMCApICYmICggdmVjdG9yLnogPT09IDAgKSApIHV2ID0gbmV3IFRIUkVFLlZlY3RvcjIoIGF6aW11dGggLyAyIC8gTWF0aC5QSSArIDAuNSwgdXYueSApO1xyXG5cdFx0cmV0dXJuIHV2LmNsb25lKCk7XHJcblxyXG5cdH1cclxuXHJcblxyXG59O1xyXG5cclxuVEhSRUUuUG9seWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG5USFJFRS5Qb2x5aGVkcm9uR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuUG9seWhlZHJvbkdlb21ldHJ5O1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvRG9kZWNhaGVkcm9uR2VvbWV0cnkuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIEFiZSBQYXpvcyAvIGh0dHBzOi8vaGFtb2lkLmNvbVxyXG4gKi9cclxuXHJcblRIUkVFLkRvZGVjYWhlZHJvbkdlb21ldHJ5ID0gZnVuY3Rpb24gKCByYWRpdXMsIGRldGFpbCApIHtcclxuXHJcblx0dmFyIHQgPSAoIDEgKyBNYXRoLnNxcnQoIDUgKSApIC8gMjtcclxuXHR2YXIgciA9IDEgLyB0O1xyXG5cclxuXHR2YXIgdmVydGljZXMgPSBbXHJcblxyXG5cdFx0Ly8gKMKxMSwgwrExLCDCsTEpXHJcblx0XHQtIDEsIC0gMSwgLSAxLCAgICAtIDEsIC0gMSwgIDEsXHJcblx0XHQtIDEsICAxLCAtIDEsICAgIC0gMSwgIDEsICAxLFxyXG5cdFx0IDEsIC0gMSwgLSAxLCAgICAgMSwgLSAxLCAgMSxcclxuXHRcdCAxLCAgMSwgLSAxLCAgICAgMSwgIDEsICAxLFxyXG5cclxuXHRcdC8vICgwLCDCsTEvz4YsIMKxz4YpXHJcblx0XHQgMCwgLSByLCAtIHQsICAgICAwLCAtIHIsICB0LFxyXG5cdFx0IDAsICByLCAtIHQsICAgICAwLCAgciwgIHQsXHJcblxyXG5cdFx0Ly8gKMKxMS/PhiwgwrHPhiwgMClcclxuXHRcdC0gciwgLSB0LCAgMCwgICAgLSByLCAgdCwgIDAsXHJcblx0XHQgciwgLSB0LCAgMCwgICAgIHIsICB0LCAgMCxcclxuXHJcblx0XHQvLyAowrHPhiwgMCwgwrExL8+GKVxyXG5cdFx0LSB0LCAgMCwgLSByLCAgICAgdCwgIDAsIC0gcixcclxuXHRcdC0gdCwgIDAsICByLCAgICAgdCwgIDAsICByXHJcblx0XTtcclxuXHJcblx0dmFyIGluZGljZXMgPSBbXHJcblx0XHQgMywgMTEsICA3LCAgICAgIDMsICA3LCAxNSwgICAgICAzLCAxNSwgMTMsXHJcblx0XHQgNywgMTksIDE3LCAgICAgIDcsIDE3LCAgNiwgICAgICA3LCAgNiwgMTUsXHJcblx0XHQxNywgIDQsICA4LCAgICAgMTcsICA4LCAxMCwgICAgIDE3LCAxMCwgIDYsXHJcblx0XHQgOCwgIDAsIDE2LCAgICAgIDgsIDE2LCAgMiwgICAgICA4LCAgMiwgMTAsXHJcblx0XHQgMCwgMTIsICAxLCAgICAgIDAsICAxLCAxOCwgICAgICAwLCAxOCwgMTYsXHJcblx0XHQgNiwgMTAsICAyLCAgICAgIDYsICAyLCAxMywgICAgICA2LCAxMywgMTUsXHJcblx0XHQgMiwgMTYsIDE4LCAgICAgIDIsIDE4LCAgMywgICAgICAyLCAgMywgMTMsXHJcblx0XHQxOCwgIDEsICA5LCAgICAgMTgsICA5LCAxMSwgICAgIDE4LCAxMSwgIDMsXHJcblx0XHQgNCwgMTQsIDEyLCAgICAgIDQsIDEyLCAgMCwgICAgICA0LCAgMCwgIDgsXHJcblx0XHQxMSwgIDksICA1LCAgICAgMTEsICA1LCAxOSwgICAgIDExLCAxOSwgIDcsXHJcblx0XHQxOSwgIDUsIDE0LCAgICAgMTksIDE0LCAgNCwgICAgIDE5LCAgNCwgMTcsXHJcblx0XHQgMSwgMTIsIDE0LCAgICAgIDEsIDE0LCAgNSwgICAgICAxLCAgNSwgIDlcclxuXHRdO1xyXG5cclxuXHRUSFJFRS5Qb2x5aGVkcm9uR2VvbWV0cnkuY2FsbCggdGhpcywgdmVydGljZXMsIGluZGljZXMsIHJhZGl1cywgZGV0YWlsICk7XHJcblxyXG5cdHRoaXMudHlwZSA9ICdEb2RlY2FoZWRyb25HZW9tZXRyeSc7XHJcblxyXG5cdHRoaXMucGFyYW1ldGVycyA9IHtcclxuXHRcdHJhZGl1czogcmFkaXVzLFxyXG5cdFx0ZGV0YWlsOiBkZXRhaWxcclxuXHR9O1xyXG5cclxufTtcclxuXHJcblRIUkVFLkRvZGVjYWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLlBvbHloZWRyb25HZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuVEhSRUUuRG9kZWNhaGVkcm9uR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuRG9kZWNhaGVkcm9uR2VvbWV0cnk7XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9JY29zYWhlZHJvbkdlb21ldHJ5LmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciB0aW1vdGh5cHJhdGxleSAvIGh0dHBzOi8vZ2l0aHViLmNvbS90aW1vdGh5cHJhdGxleVxyXG4gKi9cclxuXHJcblRIUkVFLkljb3NhaGVkcm9uR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHJhZGl1cywgZGV0YWlsICkge1xyXG5cclxuXHR2YXIgdCA9ICggMSArIE1hdGguc3FydCggNSApICkgLyAyO1xyXG5cclxuXHR2YXIgdmVydGljZXMgPSBbXHJcblx0XHQtIDEsICB0LCAgMCwgICAgMSwgIHQsICAwLCAgIC0gMSwgLSB0LCAgMCwgICAgMSwgLSB0LCAgMCxcclxuXHRcdCAwLCAtIDEsICB0LCAgICAwLCAgMSwgIHQsICAgIDAsIC0gMSwgLSB0LCAgICAwLCAgMSwgLSB0LFxyXG5cdFx0IHQsICAwLCAtIDEsICAgIHQsICAwLCAgMSwgICAtIHQsICAwLCAtIDEsICAgLSB0LCAgMCwgIDFcclxuXHRdO1xyXG5cclxuXHR2YXIgaW5kaWNlcyA9IFtcclxuXHRcdCAwLCAxMSwgIDUsICAgIDAsICA1LCAgMSwgICAgMCwgIDEsICA3LCAgICAwLCAgNywgMTAsICAgIDAsIDEwLCAxMSxcclxuXHRcdCAxLCAgNSwgIDksICAgIDUsIDExLCAgNCwgICAxMSwgMTAsICAyLCAgIDEwLCAgNywgIDYsICAgIDcsICAxLCAgOCxcclxuXHRcdCAzLCAgOSwgIDQsICAgIDMsICA0LCAgMiwgICAgMywgIDIsICA2LCAgICAzLCAgNiwgIDgsICAgIDMsICA4LCAgOSxcclxuXHRcdCA0LCAgOSwgIDUsICAgIDIsICA0LCAxMSwgICAgNiwgIDIsIDEwLCAgICA4LCAgNiwgIDcsICAgIDksICA4LCAgMVxyXG5cdF07XHJcblxyXG5cdFRIUkVFLlBvbHloZWRyb25HZW9tZXRyeS5jYWxsKCB0aGlzLCB2ZXJ0aWNlcywgaW5kaWNlcywgcmFkaXVzLCBkZXRhaWwgKTtcclxuXHJcblx0dGhpcy50eXBlID0gJ0ljb3NhaGVkcm9uR2VvbWV0cnknO1xyXG5cclxuXHR0aGlzLnBhcmFtZXRlcnMgPSB7XHJcblx0XHRyYWRpdXM6IHJhZGl1cyxcclxuXHRcdGRldGFpbDogZGV0YWlsXHJcblx0fTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5JY29zYWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLlBvbHloZWRyb25HZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuVEhSRUUuSWNvc2FoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5JY29zYWhlZHJvbkdlb21ldHJ5O1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvT2N0YWhlZHJvbkdlb21ldHJ5LmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciB0aW1vdGh5cHJhdGxleSAvIGh0dHBzOi8vZ2l0aHViLmNvbS90aW1vdGh5cHJhdGxleVxyXG4gKi9cclxuXHJcblRIUkVFLk9jdGFoZWRyb25HZW9tZXRyeSA9IGZ1bmN0aW9uICggcmFkaXVzLCBkZXRhaWwgKSB7XHJcblxyXG5cdHZhciB2ZXJ0aWNlcyA9IFtcclxuXHRcdDEsIDAsIDAsICAgLSAxLCAwLCAwLCAgICAwLCAxLCAwLCAgICAwLCAtIDEsIDAsICAgIDAsIDAsIDEsICAgIDAsIDAsIC0gMVxyXG5cdF07XHJcblxyXG5cdHZhciBpbmRpY2VzID0gW1xyXG5cdFx0MCwgMiwgNCwgICAgMCwgNCwgMywgICAgMCwgMywgNSwgICAgMCwgNSwgMiwgICAgMSwgMiwgNSwgICAgMSwgNSwgMywgICAgMSwgMywgNCwgICAgMSwgNCwgMlxyXG5cdF07XHJcblxyXG5cdFRIUkVFLlBvbHloZWRyb25HZW9tZXRyeS5jYWxsKCB0aGlzLCB2ZXJ0aWNlcywgaW5kaWNlcywgcmFkaXVzLCBkZXRhaWwgKTtcclxuXHJcblx0dGhpcy50eXBlID0gJ09jdGFoZWRyb25HZW9tZXRyeSc7XHJcblxyXG5cdHRoaXMucGFyYW1ldGVycyA9IHtcclxuXHRcdHJhZGl1czogcmFkaXVzLFxyXG5cdFx0ZGV0YWlsOiBkZXRhaWxcclxuXHR9O1xyXG5cclxufTtcclxuXHJcblRIUkVFLk9jdGFoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5Qb2x5aGVkcm9uR2VvbWV0cnkucHJvdG90eXBlICk7XHJcblRIUkVFLk9jdGFoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5PY3RhaGVkcm9uR2VvbWV0cnk7XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9UZXRyYWhlZHJvbkdlb21ldHJ5LmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciB0aW1vdGh5cHJhdGxleSAvIGh0dHBzOi8vZ2l0aHViLmNvbS90aW1vdGh5cHJhdGxleVxyXG4gKi9cclxuXHJcblRIUkVFLlRldHJhaGVkcm9uR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHJhZGl1cywgZGV0YWlsICkge1xyXG5cclxuXHR2YXIgdmVydGljZXMgPSBbXHJcblx0XHQgMSwgIDEsICAxLCAgIC0gMSwgLSAxLCAgMSwgICAtIDEsICAxLCAtIDEsICAgIDEsIC0gMSwgLSAxXHJcblx0XTtcclxuXHJcblx0dmFyIGluZGljZXMgPSBbXHJcblx0XHQgMiwgIDEsICAwLCAgICAwLCAgMywgIDIsICAgIDEsICAzLCAgMCwgICAgMiwgIDMsICAxXHJcblx0XTtcclxuXHJcblx0VEhSRUUuUG9seWhlZHJvbkdlb21ldHJ5LmNhbGwoIHRoaXMsIHZlcnRpY2VzLCBpbmRpY2VzLCByYWRpdXMsIGRldGFpbCApO1xyXG5cclxuXHR0aGlzLnR5cGUgPSAnVGV0cmFoZWRyb25HZW9tZXRyeSc7XHJcblxyXG5cdHRoaXMucGFyYW1ldGVycyA9IHtcclxuXHRcdHJhZGl1czogcmFkaXVzLFxyXG5cdFx0ZGV0YWlsOiBkZXRhaWxcclxuXHR9O1xyXG5cclxufTtcclxuXHJcblRIUkVFLlRldHJhaGVkcm9uR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuUG9seWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG5USFJFRS5UZXRyYWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlRldHJhaGVkcm9uR2VvbWV0cnk7XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9QYXJhbWV0cmljR2VvbWV0cnkuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwczovL2dpdGh1Yi5jb20veno4NVxyXG4gKiBQYXJhbWV0cmljIFN1cmZhY2VzIEdlb21ldHJ5XHJcbiAqIGJhc2VkIG9uIHRoZSBicmlsbGlhbnQgYXJ0aWNsZSBieSBAcHJpZGVvdXQgaHR0cDovL3ByaWRlb3V0Lm5ldC9ibG9nLz9wPTQ0XHJcbiAqXHJcbiAqIG5ldyBUSFJFRS5QYXJhbWV0cmljR2VvbWV0cnkoIHBhcmFtZXRyaWNGdW5jdGlvbiwgdVNlZ21lbnRzLCB5U2VnZW1lbnRzICk7XHJcbiAqXHJcbiAqL1xyXG5cclxuVEhSRUUuUGFyYW1ldHJpY0dlb21ldHJ5ID0gZnVuY3Rpb24gKCBmdW5jLCBzbGljZXMsIHN0YWNrcyApIHtcclxuXHJcblx0VEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLnR5cGUgPSAnUGFyYW1ldHJpY0dlb21ldHJ5JztcclxuXHJcblx0dGhpcy5wYXJhbWV0ZXJzID0ge1xyXG5cdFx0ZnVuYzogZnVuYyxcclxuXHRcdHNsaWNlczogc2xpY2VzLFxyXG5cdFx0c3RhY2tzOiBzdGFja3NcclxuXHR9O1xyXG5cclxuXHR2YXIgdmVydHMgPSB0aGlzLnZlcnRpY2VzO1xyXG5cdHZhciBmYWNlcyA9IHRoaXMuZmFjZXM7XHJcblx0dmFyIHV2cyA9IHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdO1xyXG5cclxuXHR2YXIgaSwgaiwgcDtcclxuXHR2YXIgdSwgdjtcclxuXHJcblx0dmFyIHNsaWNlQ291bnQgPSBzbGljZXMgKyAxO1xyXG5cclxuXHRmb3IgKCBpID0gMDsgaSA8PSBzdGFja3M7IGkgKysgKSB7XHJcblxyXG5cdFx0diA9IGkgLyBzdGFja3M7XHJcblxyXG5cdFx0Zm9yICggaiA9IDA7IGogPD0gc2xpY2VzOyBqICsrICkge1xyXG5cclxuXHRcdFx0dSA9IGogLyBzbGljZXM7XHJcblxyXG5cdFx0XHRwID0gZnVuYyggdSwgdiApO1xyXG5cdFx0XHR2ZXJ0cy5wdXNoKCBwICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdHZhciBhLCBiLCBjLCBkO1xyXG5cdHZhciB1dmEsIHV2YiwgdXZjLCB1dmQ7XHJcblxyXG5cdGZvciAoIGkgPSAwOyBpIDwgc3RhY2tzOyBpICsrICkge1xyXG5cclxuXHRcdGZvciAoIGogPSAwOyBqIDwgc2xpY2VzOyBqICsrICkge1xyXG5cclxuXHRcdFx0YSA9IGkgKiBzbGljZUNvdW50ICsgajtcclxuXHRcdFx0YiA9IGkgKiBzbGljZUNvdW50ICsgaiArIDE7XHJcblx0XHRcdGMgPSAoIGkgKyAxICkgKiBzbGljZUNvdW50ICsgaiArIDE7XHJcblx0XHRcdGQgPSAoIGkgKyAxICkgKiBzbGljZUNvdW50ICsgajtcclxuXHJcblx0XHRcdHV2YSA9IG5ldyBUSFJFRS5WZWN0b3IyKCBqIC8gc2xpY2VzLCBpIC8gc3RhY2tzICk7XHJcblx0XHRcdHV2YiA9IG5ldyBUSFJFRS5WZWN0b3IyKCAoIGogKyAxICkgLyBzbGljZXMsIGkgLyBzdGFja3MgKTtcclxuXHRcdFx0dXZjID0gbmV3IFRIUkVFLlZlY3RvcjIoICggaiArIDEgKSAvIHNsaWNlcywgKCBpICsgMSApIC8gc3RhY2tzICk7XHJcblx0XHRcdHV2ZCA9IG5ldyBUSFJFRS5WZWN0b3IyKCBqIC8gc2xpY2VzLCAoIGkgKyAxICkgLyBzdGFja3MgKTtcclxuXHJcblx0XHRcdGZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggYSwgYiwgZCApICk7XHJcblx0XHRcdHV2cy5wdXNoKCBbIHV2YSwgdXZiLCB1dmQgXSApO1xyXG5cclxuXHRcdFx0ZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCBiLCBjLCBkICkgKTtcclxuXHRcdFx0dXZzLnB1c2goIFsgdXZiLmNsb25lKCksIHV2YywgdXZkLmNsb25lKCkgXSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHQvLyBjb25zb2xlLmxvZyh0aGlzKTtcclxuXHJcblx0Ly8gbWFnaWMgYnVsbGV0XHJcblx0Ly8gdmFyIGRpZmYgPSB0aGlzLm1lcmdlVmVydGljZXMoKTtcclxuXHQvLyBjb25zb2xlLmxvZygncmVtb3ZlZCAnLCBkaWZmLCAnIHZlcnRpY2VzIGJ5IG1lcmdpbmcnKTtcclxuXHJcblx0dGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcclxuXHR0aGlzLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUGFyYW1ldHJpY0dlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG5USFJFRS5QYXJhbWV0cmljR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuUGFyYW1ldHJpY0dlb21ldHJ5O1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvV2lyZWZyYW1lR2VvbWV0cnkuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLldpcmVmcmFtZUdlb21ldHJ5ID0gZnVuY3Rpb24gKCBnZW9tZXRyeSApIHtcclxuXHJcblx0VEhSRUUuQnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcyApO1xyXG5cclxuXHR2YXIgZWRnZSA9IFsgMCwgMCBdLCBoYXNoID0ge307XHJcblxyXG5cdGZ1bmN0aW9uIHNvcnRGdW5jdGlvbiggYSwgYiApIHtcclxuXHJcblx0XHRyZXR1cm4gYSAtIGI7XHJcblxyXG5cdH1cclxuXHJcblx0dmFyIGtleXMgPSBbICdhJywgJ2InLCAnYycgXTtcclxuXHJcblx0aWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkdlb21ldHJ5ICkge1xyXG5cclxuXHRcdHZhciB2ZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzO1xyXG5cdFx0dmFyIGZhY2VzID0gZ2VvbWV0cnkuZmFjZXM7XHJcblx0XHR2YXIgbnVtRWRnZXMgPSAwO1xyXG5cclxuXHRcdC8vIGFsbG9jYXRlIG1heGltYWwgc2l6ZVxyXG5cdFx0dmFyIGVkZ2VzID0gbmV3IFVpbnQzMkFycmF5KCA2ICogZmFjZXMubGVuZ3RoICk7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gZmFjZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciBmYWNlID0gZmFjZXNbIGkgXTtcclxuXHJcblx0XHRcdGZvciAoIHZhciBqID0gMDsgaiA8IDM7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdGVkZ2VbIDAgXSA9IGZhY2VbIGtleXNbIGogXSBdO1xyXG5cdFx0XHRcdGVkZ2VbIDEgXSA9IGZhY2VbIGtleXNbICggaiArIDEgKSAlIDMgXSBdO1xyXG5cdFx0XHRcdGVkZ2Uuc29ydCggc29ydEZ1bmN0aW9uICk7XHJcblxyXG5cdFx0XHRcdHZhciBrZXkgPSBlZGdlLnRvU3RyaW5nKCk7XHJcblxyXG5cdFx0XHRcdGlmICggaGFzaFsga2V5IF0gPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRlZGdlc1sgMiAqIG51bUVkZ2VzIF0gPSBlZGdlWyAwIF07XHJcblx0XHRcdFx0XHRlZGdlc1sgMiAqIG51bUVkZ2VzICsgMSBdID0gZWRnZVsgMSBdO1xyXG5cdFx0XHRcdFx0aGFzaFsga2V5IF0gPSB0cnVlO1xyXG5cdFx0XHRcdFx0bnVtRWRnZXMgKys7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGNvb3JkcyA9IG5ldyBGbG9hdDMyQXJyYXkoIG51bUVkZ2VzICogMiAqIDMgKTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBudW1FZGdlczsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCAyOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgdmVydGV4ID0gdmVydGljZXNbIGVkZ2VzIFsgMiAqIGkgKyBqIF0gXTtcclxuXHJcblx0XHRcdFx0dmFyIGluZGV4ID0gNiAqIGkgKyAzICogajtcclxuXHRcdFx0XHRjb29yZHNbIGluZGV4ICsgMCBdID0gdmVydGV4Lng7XHJcblx0XHRcdFx0Y29vcmRzWyBpbmRleCArIDEgXSA9IHZlcnRleC55O1xyXG5cdFx0XHRcdGNvb3Jkc1sgaW5kZXggKyAyIF0gPSB2ZXJ0ZXguejtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIGNvb3JkcywgMyApICk7XHJcblxyXG5cdH0gZWxzZSBpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuQnVmZmVyR2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0aWYgKCBnZW9tZXRyeS5pbmRleCAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdC8vIEluZGV4ZWQgQnVmZmVyR2VvbWV0cnlcclxuXHJcblx0XHRcdHZhciBpbmRpY2VzID0gZ2VvbWV0cnkuaW5kZXguYXJyYXk7XHJcblx0XHRcdHZhciB2ZXJ0aWNlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XHJcblx0XHRcdHZhciBncm91cHMgPSBnZW9tZXRyeS5ncm91cHM7XHJcblx0XHRcdHZhciBudW1FZGdlcyA9IDA7XHJcblxyXG5cdFx0XHRpZiAoIGdyb3Vwcy5sZW5ndGggPT09IDAgKSB7XHJcblxyXG5cdFx0XHRcdGdlb21ldHJ5LmFkZEdyb3VwKCAwLCBpbmRpY2VzLmxlbmd0aCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gYWxsb2NhdGUgbWF4aW1hbCBzaXplXHJcblx0XHRcdHZhciBlZGdlcyA9IG5ldyBVaW50MzJBcnJheSggMiAqIGluZGljZXMubGVuZ3RoICk7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgbyA9IDAsIG9sID0gZ3JvdXBzLmxlbmd0aDsgbyA8IG9sOyArKyBvICkge1xyXG5cclxuXHRcdFx0XHR2YXIgZ3JvdXAgPSBncm91cHNbIG8gXTtcclxuXHJcblx0XHRcdFx0dmFyIHN0YXJ0ID0gZ3JvdXAuc3RhcnQ7XHJcblx0XHRcdFx0dmFyIGNvdW50ID0gZ3JvdXAuY291bnQ7XHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciBpID0gc3RhcnQsIGlsID0gc3RhcnQgKyBjb3VudDsgaSA8IGlsOyBpICs9IDMgKSB7XHJcblxyXG5cdFx0XHRcdFx0Zm9yICggdmFyIGogPSAwOyBqIDwgMzsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdGVkZ2VbIDAgXSA9IGluZGljZXNbIGkgKyBqIF07XHJcblx0XHRcdFx0XHRcdGVkZ2VbIDEgXSA9IGluZGljZXNbIGkgKyAoIGogKyAxICkgJSAzIF07XHJcblx0XHRcdFx0XHRcdGVkZ2Uuc29ydCggc29ydEZ1bmN0aW9uICk7XHJcblxyXG5cdFx0XHRcdFx0XHR2YXIga2V5ID0gZWRnZS50b1N0cmluZygpO1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCBoYXNoWyBrZXkgXSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRlZGdlc1sgMiAqIG51bUVkZ2VzIF0gPSBlZGdlWyAwIF07XHJcblx0XHRcdFx0XHRcdFx0ZWRnZXNbIDIgKiBudW1FZGdlcyArIDEgXSA9IGVkZ2VbIDEgXTtcclxuXHRcdFx0XHRcdFx0XHRoYXNoWyBrZXkgXSA9IHRydWU7XHJcblx0XHRcdFx0XHRcdFx0bnVtRWRnZXMgKys7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgY29vcmRzID0gbmV3IEZsb2F0MzJBcnJheSggbnVtRWRnZXMgKiAyICogMyApO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gbnVtRWRnZXM7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCAyOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciBpbmRleCA9IDYgKiBpICsgMyAqIGo7XHJcblx0XHRcdFx0XHR2YXIgaW5kZXgyID0gZWRnZXNbIDIgKiBpICsgaiBdO1xyXG5cclxuXHRcdFx0XHRcdGNvb3Jkc1sgaW5kZXggKyAwIF0gPSB2ZXJ0aWNlcy5nZXRYKCBpbmRleDIgKTtcclxuXHRcdFx0XHRcdGNvb3Jkc1sgaW5kZXggKyAxIF0gPSB2ZXJ0aWNlcy5nZXRZKCBpbmRleDIgKTtcclxuXHRcdFx0XHRcdGNvb3Jkc1sgaW5kZXggKyAyIF0gPSB2ZXJ0aWNlcy5nZXRaKCBpbmRleDIgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIGNvb3JkcywgMyApICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdC8vIG5vbi1pbmRleGVkIEJ1ZmZlckdlb21ldHJ5XHJcblxyXG5cdFx0XHR2YXIgdmVydGljZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xyXG5cdFx0XHR2YXIgbnVtRWRnZXMgPSB2ZXJ0aWNlcy5sZW5ndGggLyAzO1xyXG5cdFx0XHR2YXIgbnVtVHJpcyA9IG51bUVkZ2VzIC8gMztcclxuXHJcblx0XHRcdHZhciBjb29yZHMgPSBuZXcgRmxvYXQzMkFycmF5KCBudW1FZGdlcyAqIDIgKiAzICk7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBudW1UcmlzOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGogPSAwOyBqIDwgMzsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgaW5kZXggPSAxOCAqIGkgKyA2ICogajtcclxuXHJcblx0XHRcdFx0XHR2YXIgaW5kZXgxID0gOSAqIGkgKyAzICogajtcclxuXHRcdFx0XHRcdGNvb3Jkc1sgaW5kZXggKyAwIF0gPSB2ZXJ0aWNlc1sgaW5kZXgxIF07XHJcblx0XHRcdFx0XHRjb29yZHNbIGluZGV4ICsgMSBdID0gdmVydGljZXNbIGluZGV4MSArIDEgXTtcclxuXHRcdFx0XHRcdGNvb3Jkc1sgaW5kZXggKyAyIF0gPSB2ZXJ0aWNlc1sgaW5kZXgxICsgMiBdO1xyXG5cclxuXHRcdFx0XHRcdHZhciBpbmRleDIgPSA5ICogaSArIDMgKiAoICggaiArIDEgKSAlIDMgKTtcclxuXHRcdFx0XHRcdGNvb3Jkc1sgaW5kZXggKyAzIF0gPSB2ZXJ0aWNlc1sgaW5kZXgyIF07XHJcblx0XHRcdFx0XHRjb29yZHNbIGluZGV4ICsgNCBdID0gdmVydGljZXNbIGluZGV4MiArIDEgXTtcclxuXHRcdFx0XHRcdGNvb3Jkc1sgaW5kZXggKyA1IF0gPSB2ZXJ0aWNlc1sgaW5kZXgyICsgMiBdO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggY29vcmRzLCAzICkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5XaXJlZnJhbWVHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5CdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuVEhSRUUuV2lyZWZyYW1lR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuV2lyZWZyYW1lR2VvbWV0cnk7XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvaGVscGVycy9BeGlzSGVscGVyLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBzcm91Y2hlcmF5IC8gaHR0cDovL3Nyb3VjaGVyYXkub3JnL1xyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkF4aXNIZWxwZXIgPSBmdW5jdGlvbiAoIHNpemUgKSB7XHJcblxyXG5cdHNpemUgPSBzaXplIHx8IDE7XHJcblxyXG5cdHZhciB2ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIFtcclxuXHRcdDAsIDAsIDAsICBzaXplLCAwLCAwLFxyXG5cdFx0MCwgMCwgMCwgIDAsIHNpemUsIDAsXHJcblx0XHQwLCAwLCAwLCAgMCwgMCwgc2l6ZVxyXG5cdF0gKTtcclxuXHJcblx0dmFyIGNvbG9ycyA9IG5ldyBGbG9hdDMyQXJyYXkoIFtcclxuXHRcdDEsIDAsIDAsICAxLCAwLjYsIDAsXHJcblx0XHQwLCAxLCAwLCAgMC42LCAxLCAwLFxyXG5cdFx0MCwgMCwgMSwgIDAsIDAuNiwgMVxyXG5cdF0gKTtcclxuXHJcblx0dmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCk7XHJcblx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XHJcblx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAnY29sb3InLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBjb2xvcnMsIDMgKSApO1xyXG5cclxuXHR2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHsgdmVydGV4Q29sb3JzOiBUSFJFRS5WZXJ0ZXhDb2xvcnMgfSApO1xyXG5cclxuXHRUSFJFRS5MaW5lU2VnbWVudHMuY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQXhpc0hlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaW5lU2VnbWVudHMucHJvdG90eXBlICk7XHJcblRIUkVFLkF4aXNIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQXhpc0hlbHBlcjtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL0Fycm93SGVscGVyLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XHJcbiAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly9naXRodWIuY29tL3p6ODVcclxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pb1xyXG4gKlxyXG4gKiBDcmVhdGVzIGFuIGFycm93IGZvciB2aXN1YWxpemluZyBkaXJlY3Rpb25zXHJcbiAqXHJcbiAqIFBhcmFtZXRlcnM6XHJcbiAqICBkaXIgLSBWZWN0b3IzXHJcbiAqICBvcmlnaW4gLSBWZWN0b3IzXHJcbiAqICBsZW5ndGggLSBOdW1iZXJcclxuICogIGNvbG9yIC0gY29sb3IgaW4gaGV4IHZhbHVlXHJcbiAqICBoZWFkTGVuZ3RoIC0gTnVtYmVyXHJcbiAqICBoZWFkV2lkdGggLSBOdW1iZXJcclxuICovXHJcblxyXG5USFJFRS5BcnJvd0hlbHBlciA9ICggZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgbGluZUdlb21ldHJ5ID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XHJcblx0bGluZUdlb21ldHJ5LnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAwLCAwICksIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAxLCAwICkgKTtcclxuXHJcblx0dmFyIGNvbmVHZW9tZXRyeSA9IG5ldyBUSFJFRS5DeWxpbmRlckdlb21ldHJ5KCAwLCAwLjUsIDEsIDUsIDEgKTtcclxuXHRjb25lR2VvbWV0cnkudHJhbnNsYXRlKCAwLCAtIDAuNSwgMCApO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gQXJyb3dIZWxwZXIoIGRpciwgb3JpZ2luLCBsZW5ndGgsIGNvbG9yLCBoZWFkTGVuZ3RoLCBoZWFkV2lkdGggKSB7XHJcblxyXG5cdFx0Ly8gZGlyIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZFxyXG5cclxuXHRcdFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcclxuXHJcblx0XHRpZiAoIGNvbG9yID09PSB1bmRlZmluZWQgKSBjb2xvciA9IDB4ZmZmZjAwO1xyXG5cdFx0aWYgKCBsZW5ndGggPT09IHVuZGVmaW5lZCApIGxlbmd0aCA9IDE7XHJcblx0XHRpZiAoIGhlYWRMZW5ndGggPT09IHVuZGVmaW5lZCApIGhlYWRMZW5ndGggPSAwLjIgKiBsZW5ndGg7XHJcblx0XHRpZiAoIGhlYWRXaWR0aCA9PT0gdW5kZWZpbmVkICkgaGVhZFdpZHRoID0gMC4yICogaGVhZExlbmd0aDtcclxuXHJcblx0XHR0aGlzLnBvc2l0aW9uLmNvcHkoIG9yaWdpbiApO1xyXG5cdFx0XHJcblx0XHR0aGlzLmxpbmUgPSBuZXcgVEhSRUUuTGluZSggbGluZUdlb21ldHJ5LCBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGNvbG9yIH0gKSApO1xyXG5cdFx0dGhpcy5saW5lLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcclxuXHRcdHRoaXMuYWRkKCB0aGlzLmxpbmUgKTtcclxuXHJcblx0XHR0aGlzLmNvbmUgPSBuZXcgVEhSRUUuTWVzaCggY29uZUdlb21ldHJ5LCBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGNvbG9yIH0gKSApO1xyXG5cdFx0dGhpcy5jb25lLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcclxuXHRcdHRoaXMuYWRkKCB0aGlzLmNvbmUgKTtcclxuXHJcblx0XHR0aGlzLnNldERpcmVjdGlvbiggZGlyICk7XHJcblx0XHR0aGlzLnNldExlbmd0aCggbGVuZ3RoLCBoZWFkTGVuZ3RoLCBoZWFkV2lkdGggKTtcclxuXHJcblx0fVxyXG5cclxufSgpICk7XHJcblxyXG5USFJFRS5BcnJvd0hlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcclxuVEhSRUUuQXJyb3dIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQXJyb3dIZWxwZXI7XHJcblxyXG5USFJFRS5BcnJvd0hlbHBlci5wcm90b3R5cGUuc2V0RGlyZWN0aW9uID0gKCBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHZhciBheGlzID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHR2YXIgcmFkaWFucztcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uIHNldERpcmVjdGlvbiggZGlyICkge1xyXG5cclxuXHRcdC8vIGRpciBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWRcclxuXHJcblx0XHRpZiAoIGRpci55ID4gMC45OTk5OSApIHtcclxuXHJcblx0XHRcdHRoaXMucXVhdGVybmlvbi5zZXQoIDAsIDAsIDAsIDEgKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBkaXIueSA8IC0gMC45OTk5OSApIHtcclxuXHJcblx0XHRcdHRoaXMucXVhdGVybmlvbi5zZXQoIDEsIDAsIDAsIDAgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0YXhpcy5zZXQoIGRpci56LCAwLCAtIGRpci54ICkubm9ybWFsaXplKCk7XHJcblxyXG5cdFx0XHRyYWRpYW5zID0gTWF0aC5hY29zKCBkaXIueSApO1xyXG5cclxuXHRcdFx0dGhpcy5xdWF0ZXJuaW9uLnNldEZyb21BeGlzQW5nbGUoIGF4aXMsIHJhZGlhbnMgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG59KCkgKTtcclxuXHJcblRIUkVFLkFycm93SGVscGVyLnByb3RvdHlwZS5zZXRMZW5ndGggPSBmdW5jdGlvbiAoIGxlbmd0aCwgaGVhZExlbmd0aCwgaGVhZFdpZHRoICkge1xyXG5cclxuXHRpZiAoIGhlYWRMZW5ndGggPT09IHVuZGVmaW5lZCApIGhlYWRMZW5ndGggPSAwLjIgKiBsZW5ndGg7XHJcblx0aWYgKCBoZWFkV2lkdGggPT09IHVuZGVmaW5lZCApIGhlYWRXaWR0aCA9IDAuMiAqIGhlYWRMZW5ndGg7XHJcblxyXG5cdHRoaXMubGluZS5zY2FsZS5zZXQoIDEsIE1hdGgubWF4KCAwLCBsZW5ndGggLSBoZWFkTGVuZ3RoICksIDEgKTtcclxuXHR0aGlzLmxpbmUudXBkYXRlTWF0cml4KCk7XHJcblxyXG5cdHRoaXMuY29uZS5zY2FsZS5zZXQoIGhlYWRXaWR0aCwgaGVhZExlbmd0aCwgaGVhZFdpZHRoICk7XHJcblx0dGhpcy5jb25lLnBvc2l0aW9uLnkgPSBsZW5ndGg7XHJcblx0dGhpcy5jb25lLnVwZGF0ZU1hdHJpeCgpO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkFycm93SGVscGVyLnByb3RvdHlwZS5zZXRDb2xvciA9IGZ1bmN0aW9uICggY29sb3IgKSB7XHJcblxyXG5cdHRoaXMubGluZS5tYXRlcmlhbC5jb2xvci5zZXQoIGNvbG9yICk7XHJcblx0dGhpcy5jb25lLm1hdGVyaWFsLmNvbG9yLnNldCggY29sb3IgKTtcclxuXHJcbn07XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvaGVscGVycy9Cb3hIZWxwZXIuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkJveEhlbHBlciA9IGZ1bmN0aW9uICggb2JqZWN0ICkge1xyXG5cclxuXHR2YXIgaW5kaWNlcyA9IG5ldyBVaW50MTZBcnJheSggWyAwLCAxLCAxLCAyLCAyLCAzLCAzLCAwLCA0LCA1LCA1LCA2LCA2LCA3LCA3LCA0LCAwLCA0LCAxLCA1LCAyLCA2LCAzLCA3IF0gKTtcclxuXHR2YXIgcG9zaXRpb25zID0gbmV3IEZsb2F0MzJBcnJheSggOCAqIDMgKTtcclxuXHJcblx0dmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCk7XHJcblx0Z2VvbWV0cnkuc2V0SW5kZXgoIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIGluZGljZXMsIDEgKSApO1xyXG5cdGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25zLCAzICkgKTtcclxuXHJcblx0VEhSRUUuTGluZVNlZ21lbnRzLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IDB4ZmZmZjAwIH0gKSApO1xyXG5cclxuXHRpZiAoIG9iamVjdCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdHRoaXMudXBkYXRlKCBvYmplY3QgKTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcblRIUkVFLkJveEhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaW5lU2VnbWVudHMucHJvdG90eXBlICk7XHJcblRIUkVFLkJveEhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Cb3hIZWxwZXI7XHJcblxyXG5USFJFRS5Cb3hIZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9ICggZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgYm94ID0gbmV3IFRIUkVFLkJveDMoKTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uICggb2JqZWN0ICkge1xyXG5cclxuXHRcdGJveC5zZXRGcm9tT2JqZWN0KCBvYmplY3QgKTtcclxuXHJcblx0XHRpZiAoIGJveC5pc0VtcHR5KCkgKSByZXR1cm47XHJcblxyXG5cdFx0dmFyIG1pbiA9IGJveC5taW47XHJcblx0XHR2YXIgbWF4ID0gYm94Lm1heDtcclxuXHJcblx0XHQvKlxyXG5cdFx0ICA1X19fXzRcclxuXHRcdDEvX19fMC98XHJcblx0XHR8IDZfX3xfN1xyXG5cdFx0Mi9fX18zL1xyXG5cclxuXHRcdDA6IG1heC54LCBtYXgueSwgbWF4LnpcclxuXHRcdDE6IG1pbi54LCBtYXgueSwgbWF4LnpcclxuXHRcdDI6IG1pbi54LCBtaW4ueSwgbWF4LnpcclxuXHRcdDM6IG1heC54LCBtaW4ueSwgbWF4LnpcclxuXHRcdDQ6IG1heC54LCBtYXgueSwgbWluLnpcclxuXHRcdDU6IG1pbi54LCBtYXgueSwgbWluLnpcclxuXHRcdDY6IG1pbi54LCBtaW4ueSwgbWluLnpcclxuXHRcdDc6IG1heC54LCBtaW4ueSwgbWluLnpcclxuXHRcdCovXHJcblxyXG5cdFx0dmFyIHBvc2l0aW9uID0gdGhpcy5nZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xyXG5cdFx0dmFyIGFycmF5ID0gcG9zaXRpb24uYXJyYXk7XHJcblxyXG5cdFx0YXJyYXlbICAwIF0gPSBtYXgueDsgYXJyYXlbICAxIF0gPSBtYXgueTsgYXJyYXlbICAyIF0gPSBtYXguejtcclxuXHRcdGFycmF5WyAgMyBdID0gbWluLng7IGFycmF5WyAgNCBdID0gbWF4Lnk7IGFycmF5WyAgNSBdID0gbWF4Lno7XHJcblx0XHRhcnJheVsgIDYgXSA9IG1pbi54OyBhcnJheVsgIDcgXSA9IG1pbi55OyBhcnJheVsgIDggXSA9IG1heC56O1xyXG5cdFx0YXJyYXlbICA5IF0gPSBtYXgueDsgYXJyYXlbIDEwIF0gPSBtaW4ueTsgYXJyYXlbIDExIF0gPSBtYXguejtcclxuXHRcdGFycmF5WyAxMiBdID0gbWF4Lng7IGFycmF5WyAxMyBdID0gbWF4Lnk7IGFycmF5WyAxNCBdID0gbWluLno7XHJcblx0XHRhcnJheVsgMTUgXSA9IG1pbi54OyBhcnJheVsgMTYgXSA9IG1heC55OyBhcnJheVsgMTcgXSA9IG1pbi56O1xyXG5cdFx0YXJyYXlbIDE4IF0gPSBtaW4ueDsgYXJyYXlbIDE5IF0gPSBtaW4ueTsgYXJyYXlbIDIwIF0gPSBtaW4uejtcclxuXHRcdGFycmF5WyAyMSBdID0gbWF4Lng7IGFycmF5WyAyMiBdID0gbWluLnk7IGFycmF5WyAyMyBdID0gbWluLno7XHJcblxyXG5cdFx0cG9zaXRpb24ubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMuZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XHJcblxyXG5cdH07XHJcblxyXG59ICkoKTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL0JvdW5kaW5nQm94SGVscGVyLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XHJcbiAqL1xyXG5cclxuLy8gYSBoZWxwZXIgdG8gc2hvdyB0aGUgd29ybGQtYXhpcy1hbGlnbmVkIGJvdW5kaW5nIGJveCBmb3IgYW4gb2JqZWN0XHJcblxyXG5USFJFRS5Cb3VuZGluZ0JveEhlbHBlciA9IGZ1bmN0aW9uICggb2JqZWN0LCBoZXggKSB7XHJcblxyXG5cdHZhciBjb2xvciA9ICggaGV4ICE9PSB1bmRlZmluZWQgKSA/IGhleCA6IDB4ODg4ODg4O1xyXG5cclxuXHR0aGlzLm9iamVjdCA9IG9iamVjdDtcclxuXHJcblx0dGhpcy5ib3ggPSBuZXcgVEhSRUUuQm94MygpO1xyXG5cclxuXHRUSFJFRS5NZXNoLmNhbGwoIHRoaXMsIG5ldyBUSFJFRS5Cb3hHZW9tZXRyeSggMSwgMSwgMSApLCBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGNvbG9yLCB3aXJlZnJhbWU6IHRydWUgfSApICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQm91bmRpbmdCb3hIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWVzaC5wcm90b3R5cGUgKTtcclxuVEhSRUUuQm91bmRpbmdCb3hIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQm91bmRpbmdCb3hIZWxwZXI7XHJcblxyXG5USFJFRS5Cb3VuZGluZ0JveEhlbHBlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR0aGlzLmJveC5zZXRGcm9tT2JqZWN0KCB0aGlzLm9iamVjdCApO1xyXG5cclxuXHR0aGlzLmJveC5zaXplKCB0aGlzLnNjYWxlICk7XHJcblxyXG5cdHRoaXMuYm94LmNlbnRlciggdGhpcy5wb3NpdGlvbiApO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL0NhbWVyYUhlbHBlci5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqXHJcbiAqXHQtIHNob3dzIGZydXN0dW0sIGxpbmUgb2Ygc2lnaHQgYW5kIHVwIG9mIHRoZSBjYW1lcmFcclxuICpcdC0gc3VpdGFibGUgZm9yIGZhc3QgdXBkYXRlc1xyXG4gKiBcdC0gYmFzZWQgb24gZnJ1c3R1bSB2aXN1YWxpemF0aW9uIGluIGxpZ2h0Z2wuanMgc2hhZG93bWFwIGV4YW1wbGVcclxuICpcdFx0aHR0cDovL2V2YW53LmdpdGh1Yi5jb20vbGlnaHRnbC5qcy90ZXN0cy9zaGFkb3dtYXAuaHRtbFxyXG4gKi9cclxuXHJcblRIUkVFLkNhbWVyYUhlbHBlciA9IGZ1bmN0aW9uICggY2FtZXJhICkge1xyXG5cclxuXHR2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcclxuXHR2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IDB4ZmZmZmZmLCB2ZXJ0ZXhDb2xvcnM6IFRIUkVFLkZhY2VDb2xvcnMgfSApO1xyXG5cclxuXHR2YXIgcG9pbnRNYXAgPSB7fTtcclxuXHJcblx0Ly8gY29sb3JzXHJcblxyXG5cdHZhciBoZXhGcnVzdHVtID0gMHhmZmFhMDA7XHJcblx0dmFyIGhleENvbmUgPSAweGZmMDAwMDtcclxuXHR2YXIgaGV4VXAgPSAweDAwYWFmZjtcclxuXHR2YXIgaGV4VGFyZ2V0ID0gMHhmZmZmZmY7XHJcblx0dmFyIGhleENyb3NzID0gMHgzMzMzMzM7XHJcblxyXG5cdC8vIG5lYXJcclxuXHJcblx0YWRkTGluZSggXCJuMVwiLCBcIm4yXCIsIGhleEZydXN0dW0gKTtcclxuXHRhZGRMaW5lKCBcIm4yXCIsIFwibjRcIiwgaGV4RnJ1c3R1bSApO1xyXG5cdGFkZExpbmUoIFwibjRcIiwgXCJuM1wiLCBoZXhGcnVzdHVtICk7XHJcblx0YWRkTGluZSggXCJuM1wiLCBcIm4xXCIsIGhleEZydXN0dW0gKTtcclxuXHJcblx0Ly8gZmFyXHJcblxyXG5cdGFkZExpbmUoIFwiZjFcIiwgXCJmMlwiLCBoZXhGcnVzdHVtICk7XHJcblx0YWRkTGluZSggXCJmMlwiLCBcImY0XCIsIGhleEZydXN0dW0gKTtcclxuXHRhZGRMaW5lKCBcImY0XCIsIFwiZjNcIiwgaGV4RnJ1c3R1bSApO1xyXG5cdGFkZExpbmUoIFwiZjNcIiwgXCJmMVwiLCBoZXhGcnVzdHVtICk7XHJcblxyXG5cdC8vIHNpZGVzXHJcblxyXG5cdGFkZExpbmUoIFwibjFcIiwgXCJmMVwiLCBoZXhGcnVzdHVtICk7XHJcblx0YWRkTGluZSggXCJuMlwiLCBcImYyXCIsIGhleEZydXN0dW0gKTtcclxuXHRhZGRMaW5lKCBcIm4zXCIsIFwiZjNcIiwgaGV4RnJ1c3R1bSApO1xyXG5cdGFkZExpbmUoIFwibjRcIiwgXCJmNFwiLCBoZXhGcnVzdHVtICk7XHJcblxyXG5cdC8vIGNvbmVcclxuXHJcblx0YWRkTGluZSggXCJwXCIsIFwibjFcIiwgaGV4Q29uZSApO1xyXG5cdGFkZExpbmUoIFwicFwiLCBcIm4yXCIsIGhleENvbmUgKTtcclxuXHRhZGRMaW5lKCBcInBcIiwgXCJuM1wiLCBoZXhDb25lICk7XHJcblx0YWRkTGluZSggXCJwXCIsIFwibjRcIiwgaGV4Q29uZSApO1xyXG5cclxuXHQvLyB1cFxyXG5cclxuXHRhZGRMaW5lKCBcInUxXCIsIFwidTJcIiwgaGV4VXAgKTtcclxuXHRhZGRMaW5lKCBcInUyXCIsIFwidTNcIiwgaGV4VXAgKTtcclxuXHRhZGRMaW5lKCBcInUzXCIsIFwidTFcIiwgaGV4VXAgKTtcclxuXHJcblx0Ly8gdGFyZ2V0XHJcblxyXG5cdGFkZExpbmUoIFwiY1wiLCBcInRcIiwgaGV4VGFyZ2V0ICk7XHJcblx0YWRkTGluZSggXCJwXCIsIFwiY1wiLCBoZXhDcm9zcyApO1xyXG5cclxuXHQvLyBjcm9zc1xyXG5cclxuXHRhZGRMaW5lKCBcImNuMVwiLCBcImNuMlwiLCBoZXhDcm9zcyApO1xyXG5cdGFkZExpbmUoIFwiY24zXCIsIFwiY240XCIsIGhleENyb3NzICk7XHJcblxyXG5cdGFkZExpbmUoIFwiY2YxXCIsIFwiY2YyXCIsIGhleENyb3NzICk7XHJcblx0YWRkTGluZSggXCJjZjNcIiwgXCJjZjRcIiwgaGV4Q3Jvc3MgKTtcclxuXHJcblx0ZnVuY3Rpb24gYWRkTGluZSggYSwgYiwgaGV4ICkge1xyXG5cclxuXHRcdGFkZFBvaW50KCBhLCBoZXggKTtcclxuXHRcdGFkZFBvaW50KCBiLCBoZXggKTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBhZGRQb2ludCggaWQsIGhleCApIHtcclxuXHJcblx0XHRnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMygpICk7XHJcblx0XHRnZW9tZXRyeS5jb2xvcnMucHVzaCggbmV3IFRIUkVFLkNvbG9yKCBoZXggKSApO1xyXG5cclxuXHRcdGlmICggcG9pbnRNYXBbIGlkIF0gPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHBvaW50TWFwWyBpZCBdID0gW107XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHBvaW50TWFwWyBpZCBdLnB1c2goIGdlb21ldHJ5LnZlcnRpY2VzLmxlbmd0aCAtIDEgKTtcclxuXHJcblx0fVxyXG5cclxuXHRUSFJFRS5MaW5lU2VnbWVudHMuY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsICk7XHJcblxyXG5cdHRoaXMuY2FtZXJhID0gY2FtZXJhO1xyXG5cdHRoaXMuY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcclxuXHJcblx0dGhpcy5tYXRyaXggPSBjYW1lcmEubWF0cml4V29ybGQ7XHJcblx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XHJcblxyXG5cdHRoaXMucG9pbnRNYXAgPSBwb2ludE1hcDtcclxuXHJcblx0dGhpcy51cGRhdGUoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5DYW1lcmFIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGluZVNlZ21lbnRzLnByb3RvdHlwZSApO1xyXG5USFJFRS5DYW1lcmFIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQ2FtZXJhSGVscGVyO1xyXG5cclxuVEhSRUUuQ2FtZXJhSGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHZhciBnZW9tZXRyeSwgcG9pbnRNYXA7XHJcblxyXG5cdHZhciB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdHZhciBjYW1lcmEgPSBuZXcgVEhSRUUuQ2FtZXJhKCk7XHJcblxyXG5cdGZ1bmN0aW9uIHNldFBvaW50KCBwb2ludCwgeCwgeSwgeiApIHtcclxuXHJcblx0XHR2ZWN0b3Iuc2V0KCB4LCB5LCB6ICkudW5wcm9qZWN0KCBjYW1lcmEgKTtcclxuXHJcblx0XHR2YXIgcG9pbnRzID0gcG9pbnRNYXBbIHBvaW50IF07XHJcblxyXG5cdFx0aWYgKCBwb2ludHMgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdGdlb21ldHJ5LnZlcnRpY2VzWyBwb2ludHNbIGkgXSBdLmNvcHkoIHZlY3RvciApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcclxuXHRcdHBvaW50TWFwID0gdGhpcy5wb2ludE1hcDtcclxuXHJcblx0XHR2YXIgdyA9IDEsIGggPSAxO1xyXG5cclxuXHRcdC8vIHdlIG5lZWQganVzdCBjYW1lcmEgcHJvamVjdGlvbiBtYXRyaXhcclxuXHRcdC8vIHdvcmxkIG1hdHJpeCBtdXN0IGJlIGlkZW50aXR5XHJcblxyXG5cdFx0Y2FtZXJhLnByb2plY3Rpb25NYXRyaXguY29weSggdGhpcy5jYW1lcmEucHJvamVjdGlvbk1hdHJpeCApO1xyXG5cclxuXHRcdC8vIGNlbnRlciAvIHRhcmdldFxyXG5cclxuXHRcdHNldFBvaW50KCBcImNcIiwgMCwgMCwgLSAxICk7XHJcblx0XHRzZXRQb2ludCggXCJ0XCIsIDAsIDAsICAxICk7XHJcblxyXG5cdFx0Ly8gbmVhclxyXG5cclxuXHRcdHNldFBvaW50KCBcIm4xXCIsIC0gdywgLSBoLCAtIDEgKTtcclxuXHRcdHNldFBvaW50KCBcIm4yXCIsICAgdywgLSBoLCAtIDEgKTtcclxuXHRcdHNldFBvaW50KCBcIm4zXCIsIC0gdywgICBoLCAtIDEgKTtcclxuXHRcdHNldFBvaW50KCBcIm40XCIsICAgdywgICBoLCAtIDEgKTtcclxuXHJcblx0XHQvLyBmYXJcclxuXHJcblx0XHRzZXRQb2ludCggXCJmMVwiLCAtIHcsIC0gaCwgMSApO1xyXG5cdFx0c2V0UG9pbnQoIFwiZjJcIiwgICB3LCAtIGgsIDEgKTtcclxuXHRcdHNldFBvaW50KCBcImYzXCIsIC0gdywgICBoLCAxICk7XHJcblx0XHRzZXRQb2ludCggXCJmNFwiLCAgIHcsICAgaCwgMSApO1xyXG5cclxuXHRcdC8vIHVwXHJcblxyXG5cdFx0c2V0UG9pbnQoIFwidTFcIiwgICB3ICogMC43LCBoICogMS4xLCAtIDEgKTtcclxuXHRcdHNldFBvaW50KCBcInUyXCIsIC0gdyAqIDAuNywgaCAqIDEuMSwgLSAxICk7XHJcblx0XHRzZXRQb2ludCggXCJ1M1wiLCAgICAgICAgIDAsIGggKiAyLCAgIC0gMSApO1xyXG5cclxuXHRcdC8vIGNyb3NzXHJcblxyXG5cdFx0c2V0UG9pbnQoIFwiY2YxXCIsIC0gdywgICAwLCAxICk7XHJcblx0XHRzZXRQb2ludCggXCJjZjJcIiwgICB3LCAgIDAsIDEgKTtcclxuXHRcdHNldFBvaW50KCBcImNmM1wiLCAgIDAsIC0gaCwgMSApO1xyXG5cdFx0c2V0UG9pbnQoIFwiY2Y0XCIsICAgMCwgICBoLCAxICk7XHJcblxyXG5cdFx0c2V0UG9pbnQoIFwiY24xXCIsIC0gdywgICAwLCAtIDEgKTtcclxuXHRcdHNldFBvaW50KCBcImNuMlwiLCAgIHcsICAgMCwgLSAxICk7XHJcblx0XHRzZXRQb2ludCggXCJjbjNcIiwgICAwLCAtIGgsIC0gMSApO1xyXG5cdFx0c2V0UG9pbnQoIFwiY240XCIsICAgMCwgICBoLCAtIDEgKTtcclxuXHJcblx0XHRnZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHR9O1xyXG5cclxufSgpO1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2hlbHBlcnMvRGlyZWN0aW9uYWxMaWdodEhlbHBlci5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxyXG4gKi9cclxuXHJcblRIUkVFLkRpcmVjdGlvbmFsTGlnaHRIZWxwZXIgPSBmdW5jdGlvbiAoIGxpZ2h0LCBzaXplICkge1xyXG5cclxuXHRUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMubGlnaHQgPSBsaWdodDtcclxuXHR0aGlzLmxpZ2h0LnVwZGF0ZU1hdHJpeFdvcmxkKCk7XHJcblxyXG5cdHRoaXMubWF0cml4ID0gbGlnaHQubWF0cml4V29ybGQ7XHJcblx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XHJcblxyXG5cdHNpemUgPSBzaXplIHx8IDE7XHJcblxyXG5cdHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xyXG5cdGdlb21ldHJ5LnZlcnRpY2VzLnB1c2goXHJcblx0XHRuZXcgVEhSRUUuVmVjdG9yMyggLSBzaXplLCAgIHNpemUsIDAgKSxcclxuXHRcdG5ldyBUSFJFRS5WZWN0b3IzKCAgIHNpemUsICAgc2l6ZSwgMCApLFxyXG5cdFx0bmV3IFRIUkVFLlZlY3RvcjMoICAgc2l6ZSwgLSBzaXplLCAwICksXHJcblx0XHRuZXcgVEhSRUUuVmVjdG9yMyggLSBzaXplLCAtIHNpemUsIDAgKSxcclxuXHRcdG5ldyBUSFJFRS5WZWN0b3IzKCAtIHNpemUsICAgc2l6ZSwgMCApXHJcblx0KTtcclxuXHJcblx0dmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCB7IGZvZzogZmFsc2UgfSApO1xyXG5cdG1hdGVyaWFsLmNvbG9yLmNvcHkoIHRoaXMubGlnaHQuY29sb3IgKS5tdWx0aXBseVNjYWxhciggdGhpcy5saWdodC5pbnRlbnNpdHkgKTtcclxuXHJcblx0dGhpcy5saWdodFBsYW5lID0gbmV3IFRIUkVFLkxpbmUoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xyXG5cdHRoaXMuYWRkKCB0aGlzLmxpZ2h0UGxhbmUgKTtcclxuXHJcblx0Z2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcclxuXHRnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKFxyXG5cdFx0bmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHRcdG5ldyBUSFJFRS5WZWN0b3IzKClcclxuXHQpO1xyXG5cclxuXHRtYXRlcmlhbCA9IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyBmb2c6IGZhbHNlIH0gKTtcclxuXHRtYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmxpZ2h0LmNvbG9yICkubXVsdGlwbHlTY2FsYXIoIHRoaXMubGlnaHQuaW50ZW5zaXR5ICk7XHJcblxyXG5cdHRoaXMudGFyZ2V0TGluZSA9IG5ldyBUSFJFRS5MaW5lKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcclxuXHR0aGlzLmFkZCggdGhpcy50YXJnZXRMaW5lICk7XHJcblxyXG5cdHRoaXMudXBkYXRlKCk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuRGlyZWN0aW9uYWxMaWdodEhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcclxuVEhSRUUuRGlyZWN0aW9uYWxMaWdodEhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0SGVscGVyO1xyXG5cclxuVEhSRUUuRGlyZWN0aW9uYWxMaWdodEhlbHBlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dGhpcy5saWdodFBsYW5lLmdlb21ldHJ5LmRpc3Bvc2UoKTtcclxuXHR0aGlzLmxpZ2h0UGxhbmUubWF0ZXJpYWwuZGlzcG9zZSgpO1xyXG5cdHRoaXMudGFyZ2V0TGluZS5nZW9tZXRyeS5kaXNwb3NlKCk7XHJcblx0dGhpcy50YXJnZXRMaW5lLm1hdGVyaWFsLmRpc3Bvc2UoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5EaXJlY3Rpb25hbExpZ2h0SGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0dmFyIHYyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHR2YXIgdjMgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHYxLnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5saWdodC5tYXRyaXhXb3JsZCApO1xyXG5cdFx0djIuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLmxpZ2h0LnRhcmdldC5tYXRyaXhXb3JsZCApO1xyXG5cdFx0djMuc3ViVmVjdG9ycyggdjIsIHYxICk7XHJcblxyXG5cdFx0dGhpcy5saWdodFBsYW5lLmxvb2tBdCggdjMgKTtcclxuXHRcdHRoaXMubGlnaHRQbGFuZS5tYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmxpZ2h0LmNvbG9yICkubXVsdGlwbHlTY2FsYXIoIHRoaXMubGlnaHQuaW50ZW5zaXR5ICk7XHJcblxyXG5cdFx0dGhpcy50YXJnZXRMaW5lLmdlb21ldHJ5LnZlcnRpY2VzWyAxIF0uY29weSggdjMgKTtcclxuXHRcdHRoaXMudGFyZ2V0TGluZS5nZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUgPSB0cnVlO1xyXG5cdFx0dGhpcy50YXJnZXRMaW5lLm1hdGVyaWFsLmNvbG9yLmNvcHkoIHRoaXMubGlnaHRQbGFuZS5tYXRlcmlhbC5jb2xvciApO1xyXG5cclxuXHR9O1xyXG5cclxufSgpO1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2hlbHBlcnMvRWRnZXNIZWxwZXIuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcclxuICogQHBhcmFtIG9iamVjdCBUSFJFRS5NZXNoIHdob3NlIGdlb21ldHJ5IHdpbGwgYmUgdXNlZFxyXG4gKiBAcGFyYW0gaGV4IGxpbmUgY29sb3JcclxuICogQHBhcmFtIHRocmVzaG9sZEFuZ2xlIHRoZSBtaW5pbXVtIGFuZ2xlIChpbiBkZWdyZWVzKSxcclxuICogYmV0d2VlbiB0aGUgZmFjZSBub3JtYWxzIG9mIGFkamFjZW50IGZhY2VzLFxyXG4gKiB0aGF0IGlzIHJlcXVpcmVkIHRvIHJlbmRlciBhbiBlZGdlLiBBIHZhbHVlIG9mIDEwIG1lYW5zXHJcbiAqIGFuIGVkZ2UgaXMgb25seSByZW5kZXJlZCBpZiB0aGUgYW5nbGUgaXMgYXQgbGVhc3QgMTAgZGVncmVlcy5cclxuICovXHJcblxyXG5USFJFRS5FZGdlc0hlbHBlciA9IGZ1bmN0aW9uICggb2JqZWN0LCBoZXgsIHRocmVzaG9sZEFuZ2xlICkge1xyXG5cclxuXHR2YXIgY29sb3IgPSAoIGhleCAhPT0gdW5kZWZpbmVkICkgPyBoZXggOiAweGZmZmZmZjtcclxuXHJcblx0VEhSRUUuTGluZVNlZ21lbnRzLmNhbGwoIHRoaXMsIG5ldyBUSFJFRS5FZGdlc0dlb21ldHJ5KCBvYmplY3QuZ2VvbWV0cnksIHRocmVzaG9sZEFuZ2xlICksIG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogY29sb3IgfSApICk7XHJcblxyXG5cdHRoaXMubWF0cml4ID0gb2JqZWN0Lm1hdHJpeFdvcmxkO1xyXG5cdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkVkZ2VzSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpbmVTZWdtZW50cy5wcm90b3R5cGUgKTtcclxuVEhSRUUuRWRnZXNIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuRWRnZXNIZWxwZXI7XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvaGVscGVycy9GYWNlTm9ybWFsc0hlbHBlci5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxyXG4qL1xyXG5cclxuVEhSRUUuRmFjZU5vcm1hbHNIZWxwZXIgPSBmdW5jdGlvbiAoIG9iamVjdCwgc2l6ZSwgaGV4LCBsaW5ld2lkdGggKSB7XHJcblxyXG5cdC8vIEZhY2VOb3JtYWxzSGVscGVyIG9ubHkgc3VwcG9ydHMgVEhSRUUuR2VvbWV0cnlcclxuXHJcblx0dGhpcy5vYmplY3QgPSBvYmplY3Q7XHJcblxyXG5cdHRoaXMuc2l6ZSA9ICggc2l6ZSAhPT0gdW5kZWZpbmVkICkgPyBzaXplIDogMTtcclxuXHJcblx0dmFyIGNvbG9yID0gKCBoZXggIT09IHVuZGVmaW5lZCApID8gaGV4IDogMHhmZmZmMDA7XHJcblxyXG5cdHZhciB3aWR0aCA9ICggbGluZXdpZHRoICE9PSB1bmRlZmluZWQgKSA/IGxpbmV3aWR0aCA6IDE7XHJcblxyXG5cdC8vXHJcblxyXG5cdHZhciBuTm9ybWFscyA9IDA7XHJcblxyXG5cdHZhciBvYmpHZW9tZXRyeSA9IHRoaXMub2JqZWN0Lmdlb21ldHJ5O1xyXG5cclxuXHRpZiAoIG9iakdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuR2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0bk5vcm1hbHMgPSBvYmpHZW9tZXRyeS5mYWNlcy5sZW5ndGg7XHJcblxyXG5cdH0gZWxzZSB7XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuRmFjZU5vcm1hbHNIZWxwZXI6IG9ubHkgVEhSRUUuR2VvbWV0cnkgaXMgc3VwcG9ydGVkLiBVc2UgVEhSRUUuVmVydGV4Tm9ybWFsc0hlbHBlciwgaW5zdGVhZC4nICk7XHJcblxyXG5cdH1cclxuXHJcblx0Ly9cclxuXHJcblx0dmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCk7XHJcblxyXG5cdHZhciBwb3NpdGlvbnMgPSBuZXcgVEhSRUUuRmxvYXQzMkF0dHJpYnV0ZSggbk5vcm1hbHMgKiAyICogMywgMyApO1xyXG5cclxuXHRnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIHBvc2l0aW9ucyApO1xyXG5cclxuXHRUSFJFRS5MaW5lU2VnbWVudHMuY2FsbCggdGhpcywgZ2VvbWV0cnksIG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogY29sb3IsIGxpbmV3aWR0aDogd2lkdGggfSApICk7XHJcblxyXG5cdC8vXHJcblxyXG5cdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xyXG5cdHRoaXMudXBkYXRlKCk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuRmFjZU5vcm1hbHNIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGluZVNlZ21lbnRzLnByb3RvdHlwZSApO1xyXG5USFJFRS5GYWNlTm9ybWFsc0hlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5GYWNlTm9ybWFsc0hlbHBlcjtcclxuXHJcblRIUkVFLkZhY2VOb3JtYWxzSGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSAoIGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHR2YXIgdjIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdHZhciBub3JtYWxNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4MygpO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlKCkge1xyXG5cclxuXHRcdHRoaXMub2JqZWN0LnVwZGF0ZU1hdHJpeFdvcmxkKCB0cnVlICk7XHJcblxyXG5cdFx0bm9ybWFsTWF0cml4LmdldE5vcm1hbE1hdHJpeCggdGhpcy5vYmplY3QubWF0cml4V29ybGQgKTtcclxuXHJcblx0XHR2YXIgbWF0cml4V29ybGQgPSB0aGlzLm9iamVjdC5tYXRyaXhXb3JsZDtcclxuXHJcblx0XHR2YXIgcG9zaXRpb24gPSB0aGlzLmdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHR2YXIgb2JqR2VvbWV0cnkgPSB0aGlzLm9iamVjdC5nZW9tZXRyeTtcclxuXHJcblx0XHR2YXIgdmVydGljZXMgPSBvYmpHZW9tZXRyeS52ZXJ0aWNlcztcclxuXHJcblx0XHR2YXIgZmFjZXMgPSBvYmpHZW9tZXRyeS5mYWNlcztcclxuXHJcblx0XHR2YXIgaWR4ID0gMDtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBmYWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIGZhY2UgPSBmYWNlc1sgaSBdO1xyXG5cclxuXHRcdFx0dmFyIG5vcm1hbCA9IGZhY2Uubm9ybWFsO1xyXG5cclxuXHRcdFx0djEuY29weSggdmVydGljZXNbIGZhY2UuYSBdIClcclxuXHRcdFx0XHQuYWRkKCB2ZXJ0aWNlc1sgZmFjZS5iIF0gKVxyXG5cdFx0XHRcdC5hZGQoIHZlcnRpY2VzWyBmYWNlLmMgXSApXHJcblx0XHRcdFx0LmRpdmlkZVNjYWxhciggMyApXHJcblx0XHRcdFx0LmFwcGx5TWF0cml4NCggbWF0cml4V29ybGQgKTtcclxuXHJcblx0XHRcdHYyLmNvcHkoIG5vcm1hbCApLmFwcGx5TWF0cml4Myggbm9ybWFsTWF0cml4ICkubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIoIHRoaXMuc2l6ZSApLmFkZCggdjEgKTtcclxuXHJcblx0XHRcdHBvc2l0aW9uLnNldFhZWiggaWR4LCB2MS54LCB2MS55LCB2MS56ICk7XHJcblxyXG5cdFx0XHRpZHggPSBpZHggKyAxO1xyXG5cclxuXHRcdFx0cG9zaXRpb24uc2V0WFlaKCBpZHgsIHYyLngsIHYyLnksIHYyLnogKTtcclxuXHJcblx0XHRcdGlkeCA9IGlkeCArIDE7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHBvc2l0aW9uLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxufSgpICk7XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvaGVscGVycy9HcmlkSGVscGVyLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5HcmlkSGVscGVyID0gZnVuY3Rpb24gKCBzaXplLCBzdGVwICkge1xyXG5cclxuXHR2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcclxuXHR2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHsgdmVydGV4Q29sb3JzOiBUSFJFRS5WZXJ0ZXhDb2xvcnMgfSApO1xyXG5cclxuXHR0aGlzLmNvbG9yMSA9IG5ldyBUSFJFRS5Db2xvciggMHg0NDQ0NDQgKTtcclxuXHR0aGlzLmNvbG9yMiA9IG5ldyBUSFJFRS5Db2xvciggMHg4ODg4ODggKTtcclxuXHJcblx0Zm9yICggdmFyIGkgPSAtIHNpemU7IGkgPD0gc2l6ZTsgaSArPSBzdGVwICkge1xyXG5cclxuXHRcdGdlb21ldHJ5LnZlcnRpY2VzLnB1c2goXHJcblx0XHRcdG5ldyBUSFJFRS5WZWN0b3IzKCAtIHNpemUsIDAsIGkgKSwgbmV3IFRIUkVFLlZlY3RvcjMoIHNpemUsIDAsIGkgKSxcclxuXHRcdFx0bmV3IFRIUkVFLlZlY3RvcjMoIGksIDAsIC0gc2l6ZSApLCBuZXcgVEhSRUUuVmVjdG9yMyggaSwgMCwgc2l6ZSApXHJcblx0XHQpO1xyXG5cclxuXHRcdHZhciBjb2xvciA9IGkgPT09IDAgPyB0aGlzLmNvbG9yMSA6IHRoaXMuY29sb3IyO1xyXG5cclxuXHRcdGdlb21ldHJ5LmNvbG9ycy5wdXNoKCBjb2xvciwgY29sb3IsIGNvbG9yLCBjb2xvciApO1xyXG5cclxuXHR9XHJcblxyXG5cdFRIUkVFLkxpbmVTZWdtZW50cy5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5HcmlkSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpbmVTZWdtZW50cy5wcm90b3R5cGUgKTtcclxuVEhSRUUuR3JpZEhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5HcmlkSGVscGVyO1xyXG5cclxuVEhSRUUuR3JpZEhlbHBlci5wcm90b3R5cGUuc2V0Q29sb3JzID0gZnVuY3Rpb24oIGNvbG9yQ2VudGVyTGluZSwgY29sb3JHcmlkICkge1xyXG5cclxuXHR0aGlzLmNvbG9yMS5zZXQoIGNvbG9yQ2VudGVyTGluZSApO1xyXG5cdHRoaXMuY29sb3IyLnNldCggY29sb3JHcmlkICk7XHJcblxyXG5cdHRoaXMuZ2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZSA9IHRydWU7XHJcblxyXG59O1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL2hlbHBlcnMvSGVtaXNwaGVyZUxpZ2h0SGVscGVyLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5IZW1pc3BoZXJlTGlnaHRIZWxwZXIgPSBmdW5jdGlvbiAoIGxpZ2h0LCBzcGhlcmVTaXplICkge1xyXG5cclxuXHRUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMubGlnaHQgPSBsaWdodDtcclxuXHR0aGlzLmxpZ2h0LnVwZGF0ZU1hdHJpeFdvcmxkKCk7XHJcblxyXG5cdHRoaXMubWF0cml4ID0gbGlnaHQubWF0cml4V29ybGQ7XHJcblx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XHJcblxyXG5cdHRoaXMuY29sb3JzID0gWyBuZXcgVEhSRUUuQ29sb3IoKSwgbmV3IFRIUkVFLkNvbG9yKCkgXTtcclxuXHJcblx0dmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLlNwaGVyZUdlb21ldHJ5KCBzcGhlcmVTaXplLCA0LCAyICk7XHJcblx0Z2VvbWV0cnkucm90YXRlWCggLSBNYXRoLlBJIC8gMiApO1xyXG5cclxuXHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gODsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdGdlb21ldHJ5LmZhY2VzWyBpIF0uY29sb3IgPSB0aGlzLmNvbG9yc1sgaSA8IDQgPyAwIDogMSBdO1xyXG5cclxuXHR9XHJcblxyXG5cdHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCggeyB2ZXJ0ZXhDb2xvcnM6IFRIUkVFLkZhY2VDb2xvcnMsIHdpcmVmcmFtZTogdHJ1ZSB9ICk7XHJcblxyXG5cdHRoaXMubGlnaHRTcGhlcmUgPSBuZXcgVEhSRUUuTWVzaCggZ2VvbWV0cnksIG1hdGVyaWFsICk7XHJcblx0dGhpcy5hZGQoIHRoaXMubGlnaHRTcGhlcmUgKTtcclxuXHJcblx0dGhpcy51cGRhdGUoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5IZW1pc3BoZXJlTGlnaHRIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XHJcblRIUkVFLkhlbWlzcGhlcmVMaWdodEhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5IZW1pc3BoZXJlTGlnaHRIZWxwZXI7XHJcblxyXG5USFJFRS5IZW1pc3BoZXJlTGlnaHRIZWxwZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHRoaXMubGlnaHRTcGhlcmUuZ2VvbWV0cnkuZGlzcG9zZSgpO1xyXG5cdHRoaXMubGlnaHRTcGhlcmUubWF0ZXJpYWwuZGlzcG9zZSgpO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkhlbWlzcGhlcmVMaWdodEhlbHBlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLmNvbG9yc1sgMCBdLmNvcHkoIHRoaXMubGlnaHQuY29sb3IgKS5tdWx0aXBseVNjYWxhciggdGhpcy5saWdodC5pbnRlbnNpdHkgKTtcclxuXHRcdHRoaXMuY29sb3JzWyAxIF0uY29weSggdGhpcy5saWdodC5ncm91bmRDb2xvciApLm11bHRpcGx5U2NhbGFyKCB0aGlzLmxpZ2h0LmludGVuc2l0eSApO1xyXG5cclxuXHRcdHRoaXMubGlnaHRTcGhlcmUubG9va0F0KCB2ZWN0b3Iuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLmxpZ2h0Lm1hdHJpeFdvcmxkICkubmVnYXRlKCkgKTtcclxuXHRcdHRoaXMubGlnaHRTcGhlcmUuZ2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZSA9IHRydWU7XHJcblxyXG5cdH1cclxuXHJcbn0oKTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL1BvaW50TGlnaHRIZWxwZXIuanNcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLlBvaW50TGlnaHRIZWxwZXIgPSBmdW5jdGlvbiAoIGxpZ2h0LCBzcGhlcmVTaXplICkge1xyXG5cclxuXHR0aGlzLmxpZ2h0ID0gbGlnaHQ7XHJcblx0dGhpcy5saWdodC51cGRhdGVNYXRyaXhXb3JsZCgpO1xyXG5cclxuXHR2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuU3BoZXJlR2VvbWV0cnkoIHNwaGVyZVNpemUsIDQsIDIgKTtcclxuXHR2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoIHsgd2lyZWZyYW1lOiB0cnVlLCBmb2c6IGZhbHNlIH0gKTtcclxuXHRtYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmxpZ2h0LmNvbG9yICkubXVsdGlwbHlTY2FsYXIoIHRoaXMubGlnaHQuaW50ZW5zaXR5ICk7XHJcblxyXG5cdFRIUkVFLk1lc2guY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsICk7XHJcblxyXG5cdHRoaXMubWF0cml4ID0gdGhpcy5saWdodC5tYXRyaXhXb3JsZDtcclxuXHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcclxuXHJcblx0LypcclxuXHR2YXIgZGlzdGFuY2VHZW9tZXRyeSA9IG5ldyBUSFJFRS5JY29zYWhlZHJvbkdlb21ldHJ5KCAxLCAyICk7XHJcblx0dmFyIGRpc3RhbmNlTWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGhleENvbG9yLCBmb2c6IGZhbHNlLCB3aXJlZnJhbWU6IHRydWUsIG9wYWNpdHk6IDAuMSwgdHJhbnNwYXJlbnQ6IHRydWUgfSApO1xyXG5cclxuXHR0aGlzLmxpZ2h0U3BoZXJlID0gbmV3IFRIUkVFLk1lc2goIGJ1bGJHZW9tZXRyeSwgYnVsYk1hdGVyaWFsICk7XHJcblx0dGhpcy5saWdodERpc3RhbmNlID0gbmV3IFRIUkVFLk1lc2goIGRpc3RhbmNlR2VvbWV0cnksIGRpc3RhbmNlTWF0ZXJpYWwgKTtcclxuXHJcblx0dmFyIGQgPSBsaWdodC5kaXN0YW5jZTtcclxuXHJcblx0aWYgKCBkID09PSAwLjAgKSB7XHJcblxyXG5cdFx0dGhpcy5saWdodERpc3RhbmNlLnZpc2libGUgPSBmYWxzZTtcclxuXHJcblx0fSBlbHNlIHtcclxuXHJcblx0XHR0aGlzLmxpZ2h0RGlzdGFuY2Uuc2NhbGUuc2V0KCBkLCBkLCBkICk7XHJcblxyXG5cdH1cclxuXHJcblx0dGhpcy5hZGQoIHRoaXMubGlnaHREaXN0YW5jZSApO1xyXG5cdCovXHJcblxyXG59O1xyXG5cclxuVEhSRUUuUG9pbnRMaWdodEhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NZXNoLnByb3RvdHlwZSApO1xyXG5USFJFRS5Qb2ludExpZ2h0SGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlBvaW50TGlnaHRIZWxwZXI7XHJcblxyXG5USFJFRS5Qb2ludExpZ2h0SGVscGVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR0aGlzLmdlb21ldHJ5LmRpc3Bvc2UoKTtcclxuXHR0aGlzLm1hdGVyaWFsLmRpc3Bvc2UoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Qb2ludExpZ2h0SGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHRoaXMubWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5saWdodC5jb2xvciApLm11bHRpcGx5U2NhbGFyKCB0aGlzLmxpZ2h0LmludGVuc2l0eSApO1xyXG5cclxuXHQvKlxyXG5cdHZhciBkID0gdGhpcy5saWdodC5kaXN0YW5jZTtcclxuXHJcblx0aWYgKCBkID09PSAwLjAgKSB7XHJcblxyXG5cdFx0dGhpcy5saWdodERpc3RhbmNlLnZpc2libGUgPSBmYWxzZTtcclxuXHJcblx0fSBlbHNlIHtcclxuXHJcblx0XHR0aGlzLmxpZ2h0RGlzdGFuY2UudmlzaWJsZSA9IHRydWU7XHJcblx0XHR0aGlzLmxpZ2h0RGlzdGFuY2Uuc2NhbGUuc2V0KCBkLCBkLCBkICk7XHJcblxyXG5cdH1cclxuXHQqL1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL1NrZWxldG9uSGVscGVyLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBTZWFuIEdyaWZmaW4gLyBodHRwOi8vdHdpdHRlci5jb20vc2dyaWZcclxuICogQGF1dGhvciBNaWNoYWVsIEd1ZXJyZXJvIC8gaHR0cDovL3JlYWxpdHltZWx0ZG93bi5jb21cclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBpa2VyciAvIGh0dHA6Ly92ZXJvbGQuY29tXHJcbiAqL1xyXG5cclxuVEhSRUUuU2tlbGV0b25IZWxwZXIgPSBmdW5jdGlvbiAoIG9iamVjdCApIHtcclxuXHJcblx0dGhpcy5ib25lcyA9IHRoaXMuZ2V0Qm9uZUxpc3QoIG9iamVjdCApO1xyXG5cclxuXHR2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcclxuXHJcblx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5ib25lcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0dmFyIGJvbmUgPSB0aGlzLmJvbmVzWyBpIF07XHJcblxyXG5cdFx0aWYgKCBib25lLnBhcmVudCBpbnN0YW5jZW9mIFRIUkVFLkJvbmUgKSB7XHJcblxyXG5cdFx0XHRnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMygpICk7XHJcblx0XHRcdGdlb21ldHJ5LnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCkgKTtcclxuXHRcdFx0Z2VvbWV0cnkuY29sb3JzLnB1c2goIG5ldyBUSFJFRS5Db2xvciggMCwgMCwgMSApICk7XHJcblx0XHRcdGdlb21ldHJ5LmNvbG9ycy5wdXNoKCBuZXcgVEhSRUUuQ29sb3IoIDAsIDEsIDAgKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRnZW9tZXRyeS5keW5hbWljID0gdHJ1ZTtcclxuXHJcblx0dmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCB7IHZlcnRleENvbG9yczogVEhSRUUuVmVydGV4Q29sb3JzLCBkZXB0aFRlc3Q6IGZhbHNlLCBkZXB0aFdyaXRlOiBmYWxzZSwgdHJhbnNwYXJlbnQ6IHRydWUgfSApO1xyXG5cclxuXHRUSFJFRS5MaW5lU2VnbWVudHMuY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsICk7XHJcblxyXG5cdHRoaXMucm9vdCA9IG9iamVjdDtcclxuXHJcblx0dGhpcy5tYXRyaXggPSBvYmplY3QubWF0cml4V29ybGQ7XHJcblx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XHJcblxyXG5cdHRoaXMudXBkYXRlKCk7XHJcblxyXG59O1xyXG5cclxuXHJcblRIUkVFLlNrZWxldG9uSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpbmVTZWdtZW50cy5wcm90b3R5cGUgKTtcclxuVEhSRUUuU2tlbGV0b25IZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuU2tlbGV0b25IZWxwZXI7XHJcblxyXG5USFJFRS5Ta2VsZXRvbkhlbHBlci5wcm90b3R5cGUuZ2V0Qm9uZUxpc3QgPSBmdW5jdGlvbiggb2JqZWN0ICkge1xyXG5cclxuXHR2YXIgYm9uZUxpc3QgPSBbXTtcclxuXHJcblx0aWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5Cb25lICkge1xyXG5cclxuXHRcdGJvbmVMaXN0LnB1c2goIG9iamVjdCApO1xyXG5cclxuXHR9XHJcblxyXG5cdGZvciAoIHZhciBpID0gMDsgaSA8IG9iamVjdC5jaGlsZHJlbi5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0Ym9uZUxpc3QucHVzaC5hcHBseSggYm9uZUxpc3QsIHRoaXMuZ2V0Qm9uZUxpc3QoIG9iamVjdC5jaGlsZHJlblsgaSBdICkgKTtcclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gYm9uZUxpc3Q7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuU2tlbGV0b25IZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dmFyIGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcclxuXHJcblx0dmFyIG1hdHJpeFdvcmxkSW52ID0gbmV3IFRIUkVFLk1hdHJpeDQoKS5nZXRJbnZlcnNlKCB0aGlzLnJvb3QubWF0cml4V29ybGQgKTtcclxuXHJcblx0dmFyIGJvbmVNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xyXG5cclxuXHR2YXIgaiA9IDA7XHJcblxyXG5cdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMuYm9uZXMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdHZhciBib25lID0gdGhpcy5ib25lc1sgaSBdO1xyXG5cclxuXHRcdGlmICggYm9uZS5wYXJlbnQgaW5zdGFuY2VvZiBUSFJFRS5Cb25lICkge1xyXG5cclxuXHRcdFx0Ym9uZU1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBtYXRyaXhXb3JsZEludiwgYm9uZS5tYXRyaXhXb3JsZCApO1xyXG5cdFx0XHRnZW9tZXRyeS52ZXJ0aWNlc1sgaiBdLnNldEZyb21NYXRyaXhQb3NpdGlvbiggYm9uZU1hdHJpeCApO1xyXG5cclxuXHRcdFx0Ym9uZU1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBtYXRyaXhXb3JsZEludiwgYm9uZS5wYXJlbnQubWF0cml4V29ybGQgKTtcclxuXHRcdFx0Z2VvbWV0cnkudmVydGljZXNbIGogKyAxIF0uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBib25lTWF0cml4ICk7XHJcblxyXG5cdFx0XHRqICs9IDI7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSA9IHRydWU7XHJcblxyXG5cdGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xyXG5cclxufTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL1Nwb3RMaWdodEhlbHBlci5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxyXG4qL1xyXG5cclxuVEhSRUUuU3BvdExpZ2h0SGVscGVyID0gZnVuY3Rpb24gKCBsaWdodCApIHtcclxuXHJcblx0VEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLmxpZ2h0ID0gbGlnaHQ7XHJcblx0dGhpcy5saWdodC51cGRhdGVNYXRyaXhXb3JsZCgpO1xyXG5cclxuXHR0aGlzLm1hdHJpeCA9IGxpZ2h0Lm1hdHJpeFdvcmxkO1xyXG5cdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHR2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQ3lsaW5kZXJHZW9tZXRyeSggMCwgMSwgMSwgOCwgMSwgdHJ1ZSApO1xyXG5cclxuXHRnZW9tZXRyeS50cmFuc2xhdGUoIDAsIC0gMC41LCAwICk7XHJcblx0Z2VvbWV0cnkucm90YXRlWCggLSBNYXRoLlBJIC8gMiApO1xyXG5cclxuXHR2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoIHsgd2lyZWZyYW1lOiB0cnVlLCBmb2c6IGZhbHNlIH0gKTtcclxuXHJcblx0dGhpcy5jb25lID0gbmV3IFRIUkVFLk1lc2goIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xyXG5cdHRoaXMuYWRkKCB0aGlzLmNvbmUgKTtcclxuXHJcblx0dGhpcy51cGRhdGUoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5TcG90TGlnaHRIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XHJcblRIUkVFLlNwb3RMaWdodEhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5TcG90TGlnaHRIZWxwZXI7XHJcblxyXG5USFJFRS5TcG90TGlnaHRIZWxwZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHRoaXMuY29uZS5nZW9tZXRyeS5kaXNwb3NlKCk7XHJcblx0dGhpcy5jb25lLm1hdGVyaWFsLmRpc3Bvc2UoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5TcG90TGlnaHRIZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dmFyIHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0dmFyIHZlY3RvcjIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBjb25lTGVuZ3RoID0gdGhpcy5saWdodC5kaXN0YW5jZSA/IHRoaXMubGlnaHQuZGlzdGFuY2UgOiAxMDAwMDtcclxuXHRcdHZhciBjb25lV2lkdGggPSBjb25lTGVuZ3RoICogTWF0aC50YW4oIHRoaXMubGlnaHQuYW5nbGUgKTtcclxuXHJcblx0XHR0aGlzLmNvbmUuc2NhbGUuc2V0KCBjb25lV2lkdGgsIGNvbmVXaWR0aCwgY29uZUxlbmd0aCApO1xyXG5cclxuXHRcdHZlY3Rvci5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubGlnaHQubWF0cml4V29ybGQgKTtcclxuXHRcdHZlY3RvcjIuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLmxpZ2h0LnRhcmdldC5tYXRyaXhXb3JsZCApO1xyXG5cclxuXHRcdHRoaXMuY29uZS5sb29rQXQoIHZlY3RvcjIuc3ViKCB2ZWN0b3IgKSApO1xyXG5cclxuXHRcdHRoaXMuY29uZS5tYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmxpZ2h0LmNvbG9yICkubXVsdGlwbHlTY2FsYXIoIHRoaXMubGlnaHQuaW50ZW5zaXR5ICk7XHJcblxyXG5cdH07XHJcblxyXG59KCk7XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvaGVscGVycy9WZXJ0ZXhOb3JtYWxzSGVscGVyLmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XHJcbiovXHJcblxyXG5USFJFRS5WZXJ0ZXhOb3JtYWxzSGVscGVyID0gZnVuY3Rpb24gKCBvYmplY3QsIHNpemUsIGhleCwgbGluZXdpZHRoICkge1xyXG5cclxuXHR0aGlzLm9iamVjdCA9IG9iamVjdDtcclxuXHJcblx0dGhpcy5zaXplID0gKCBzaXplICE9PSB1bmRlZmluZWQgKSA/IHNpemUgOiAxO1xyXG5cclxuXHR2YXIgY29sb3IgPSAoIGhleCAhPT0gdW5kZWZpbmVkICkgPyBoZXggOiAweGZmMDAwMDtcclxuXHJcblx0dmFyIHdpZHRoID0gKCBsaW5ld2lkdGggIT09IHVuZGVmaW5lZCApID8gbGluZXdpZHRoIDogMTtcclxuXHJcblx0Ly9cclxuXHJcblx0dmFyIG5Ob3JtYWxzID0gMDtcclxuXHJcblx0dmFyIG9iakdlb21ldHJ5ID0gdGhpcy5vYmplY3QuZ2VvbWV0cnk7XHJcblxyXG5cdGlmICggb2JqR2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5HZW9tZXRyeSApIHtcclxuXHJcblx0XHRuTm9ybWFscyA9IG9iakdlb21ldHJ5LmZhY2VzLmxlbmd0aCAqIDM7XHJcblxyXG5cdH0gZWxzZSBpZiAoIG9iakdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuQnVmZmVyR2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0bk5vcm1hbHMgPSBvYmpHZW9tZXRyeS5hdHRyaWJ1dGVzLm5vcm1hbC5jb3VudFxyXG5cclxuXHR9XHJcblxyXG5cdC8vXHJcblxyXG5cdHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpO1xyXG5cclxuXHR2YXIgcG9zaXRpb25zID0gbmV3IFRIUkVFLkZsb2F0MzJBdHRyaWJ1dGUoIG5Ob3JtYWxzICogMiAqIDMsIDMgKTtcclxuXHJcblx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBwb3NpdGlvbnMgKTtcclxuXHJcblx0VEhSRUUuTGluZVNlZ21lbnRzLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGNvbG9yLCBsaW5ld2lkdGg6IHdpZHRoIH0gKSApO1xyXG5cclxuXHQvL1xyXG5cclxuXHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcclxuXHJcblx0dGhpcy51cGRhdGUoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5WZXJ0ZXhOb3JtYWxzSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpbmVTZWdtZW50cy5wcm90b3R5cGUgKTtcclxuVEhSRUUuVmVydGV4Tm9ybWFsc0hlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5WZXJ0ZXhOb3JtYWxzSGVscGVyO1xyXG5cclxuVEhSRUUuVmVydGV4Tm9ybWFsc0hlbHBlci5wcm90b3R5cGUudXBkYXRlID0gKCBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0dmFyIHYyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHR2YXIgbm9ybWFsTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDMoKTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSgpIHtcclxuXHJcblx0XHR2YXIga2V5cyA9IFsgJ2EnLCAnYicsICdjJyBdO1xyXG5cclxuXHRcdHRoaXMub2JqZWN0LnVwZGF0ZU1hdHJpeFdvcmxkKCB0cnVlICk7XHJcblxyXG5cdFx0bm9ybWFsTWF0cml4LmdldE5vcm1hbE1hdHJpeCggdGhpcy5vYmplY3QubWF0cml4V29ybGQgKTtcclxuXHJcblx0XHR2YXIgbWF0cml4V29ybGQgPSB0aGlzLm9iamVjdC5tYXRyaXhXb3JsZDtcclxuXHJcblx0XHR2YXIgcG9zaXRpb24gPSB0aGlzLmdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHR2YXIgb2JqR2VvbWV0cnkgPSB0aGlzLm9iamVjdC5nZW9tZXRyeTtcclxuXHJcblx0XHRpZiAoIG9iakdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuR2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0XHR2YXIgdmVydGljZXMgPSBvYmpHZW9tZXRyeS52ZXJ0aWNlcztcclxuXHJcblx0XHRcdHZhciBmYWNlcyA9IG9iakdlb21ldHJ5LmZhY2VzO1xyXG5cclxuXHRcdFx0dmFyIGlkeCA9IDA7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBmYWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgZmFjZSA9IGZhY2VzWyBpIF07XHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSBmYWNlLnZlcnRleE5vcm1hbHMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIHZlcnRleCA9IHZlcnRpY2VzWyBmYWNlWyBrZXlzWyBqIF0gXSBdO1xyXG5cclxuXHRcdFx0XHRcdHZhciBub3JtYWwgPSBmYWNlLnZlcnRleE5vcm1hbHNbIGogXTtcclxuXHJcblx0XHRcdFx0XHR2MS5jb3B5KCB2ZXJ0ZXggKS5hcHBseU1hdHJpeDQoIG1hdHJpeFdvcmxkICk7XHJcblxyXG5cdFx0XHRcdFx0djIuY29weSggbm9ybWFsICkuYXBwbHlNYXRyaXgzKCBub3JtYWxNYXRyaXggKS5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhciggdGhpcy5zaXplICkuYWRkKCB2MSApO1xyXG5cclxuXHRcdFx0XHRcdHBvc2l0aW9uLnNldFhZWiggaWR4LCB2MS54LCB2MS55LCB2MS56ICk7XHJcblxyXG5cdFx0XHRcdFx0aWR4ID0gaWR4ICsgMTtcclxuXHJcblx0XHRcdFx0XHRwb3NpdGlvbi5zZXRYWVooIGlkeCwgdjIueCwgdjIueSwgdjIueiApO1xyXG5cclxuXHRcdFx0XHRcdGlkeCA9IGlkeCArIDE7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2UgaWYgKCBvYmpHZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkJ1ZmZlckdlb21ldHJ5ICkge1xyXG5cclxuXHRcdFx0dmFyIG9ialBvcyA9IG9iakdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XHJcblxyXG5cdFx0XHR2YXIgb2JqTm9ybSA9IG9iakdlb21ldHJ5LmF0dHJpYnV0ZXMubm9ybWFsO1xyXG5cclxuXHRcdFx0dmFyIGlkeCA9IDA7XHJcblxyXG5cdFx0XHQvLyBmb3Igc2ltcGxpY2l0eSwgaWdub3JlIGluZGV4IGFuZCBkcmF3Y2FsbHMsIGFuZCByZW5kZXIgZXZlcnkgbm9ybWFsXHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gb2JqUG9zLmNvdW50OyBqIDwgamw7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdHYxLnNldCggb2JqUG9zLmdldFgoIGogKSwgb2JqUG9zLmdldFkoIGogKSwgb2JqUG9zLmdldFooIGogKSApLmFwcGx5TWF0cml4NCggbWF0cml4V29ybGQgKTtcclxuXHJcblx0XHRcdFx0djIuc2V0KCBvYmpOb3JtLmdldFgoIGogKSwgb2JqTm9ybS5nZXRZKCBqICksIG9iak5vcm0uZ2V0WiggaiApICk7XHJcblxyXG5cdFx0XHRcdHYyLmFwcGx5TWF0cml4Myggbm9ybWFsTWF0cml4ICkubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIoIHRoaXMuc2l6ZSApLmFkZCggdjEgKTtcclxuXHJcblx0XHRcdFx0cG9zaXRpb24uc2V0WFlaKCBpZHgsIHYxLngsIHYxLnksIHYxLnogKTtcclxuXHJcblx0XHRcdFx0aWR4ID0gaWR4ICsgMTtcclxuXHJcblx0XHRcdFx0cG9zaXRpb24uc2V0WFlaKCBpZHgsIHYyLngsIHYyLnksIHYyLnogKTtcclxuXHJcblx0XHRcdFx0aWR4ID0gaWR4ICsgMTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cG9zaXRpb24ubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG59KCkgKTtcclxuXHJcbi8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL1dpcmVmcmFtZUhlbHBlci5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuV2lyZWZyYW1lSGVscGVyID0gZnVuY3Rpb24gKCBvYmplY3QsIGhleCApIHtcclxuXHJcblx0dmFyIGNvbG9yID0gKCBoZXggIT09IHVuZGVmaW5lZCApID8gaGV4IDogMHhmZmZmZmY7XHJcblxyXG5cdFRIUkVFLkxpbmVTZWdtZW50cy5jYWxsKCB0aGlzLCBuZXcgVEhSRUUuV2lyZWZyYW1lR2VvbWV0cnkoIG9iamVjdC5nZW9tZXRyeSApLCBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGNvbG9yIH0gKSApO1xyXG5cclxuXHR0aGlzLm1hdHJpeCA9IG9iamVjdC5tYXRyaXhXb3JsZDtcclxuXHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5XaXJlZnJhbWVIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGluZVNlZ21lbnRzLnByb3RvdHlwZSApO1xyXG5USFJFRS5XaXJlZnJhbWVIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuV2lyZWZyYW1lSGVscGVyO1xyXG5cclxuLy8gRmlsZTpzcmMvZXh0cmFzL29iamVjdHMvSW1tZWRpYXRlUmVuZGVyT2JqZWN0LmpzXHJcblxyXG4vKipcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5JbW1lZGlhdGVSZW5kZXJPYmplY3QgPSBmdW5jdGlvbiAoIG1hdGVyaWFsICkge1xyXG5cclxuXHRUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMubWF0ZXJpYWwgPSBtYXRlcmlhbDtcclxuXHR0aGlzLnJlbmRlciA9IGZ1bmN0aW9uICggcmVuZGVyQ2FsbGJhY2sgKSB7fTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5JbW1lZGlhdGVSZW5kZXJPYmplY3QucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XHJcblRIUkVFLkltbWVkaWF0ZVJlbmRlck9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5JbW1lZGlhdGVSZW5kZXJPYmplY3Q7XHJcblxyXG4vLyBGaWxlOnNyYy9leHRyYXMvb2JqZWN0cy9Nb3JwaEJsZW5kTWVzaC5qc1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuTW9ycGhCbGVuZE1lc2ggPSBmdW5jdGlvbiggZ2VvbWV0cnksIG1hdGVyaWFsICkge1xyXG5cclxuXHRUSFJFRS5NZXNoLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xyXG5cclxuXHR0aGlzLmFuaW1hdGlvbnNNYXAgPSB7fTtcclxuXHR0aGlzLmFuaW1hdGlvbnNMaXN0ID0gW107XHJcblxyXG5cdC8vIHByZXBhcmUgZGVmYXVsdCBhbmltYXRpb25cclxuXHQvLyAoYWxsIGZyYW1lcyBwbGF5ZWQgdG9nZXRoZXIgaW4gMSBzZWNvbmQpXHJcblxyXG5cdHZhciBudW1GcmFtZXMgPSB0aGlzLmdlb21ldHJ5Lm1vcnBoVGFyZ2V0cy5sZW5ndGg7XHJcblxyXG5cdHZhciBuYW1lID0gXCJfX2RlZmF1bHRcIjtcclxuXHJcblx0dmFyIHN0YXJ0RnJhbWUgPSAwO1xyXG5cdHZhciBlbmRGcmFtZSA9IG51bUZyYW1lcyAtIDE7XHJcblxyXG5cdHZhciBmcHMgPSBudW1GcmFtZXMgLyAxO1xyXG5cclxuXHR0aGlzLmNyZWF0ZUFuaW1hdGlvbiggbmFtZSwgc3RhcnRGcmFtZSwgZW5kRnJhbWUsIGZwcyApO1xyXG5cdHRoaXMuc2V0QW5pbWF0aW9uV2VpZ2h0KCBuYW1lLCAxICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWVzaC5wcm90b3R5cGUgKTtcclxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuTW9ycGhCbGVuZE1lc2g7XHJcblxyXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuY3JlYXRlQW5pbWF0aW9uID0gZnVuY3Rpb24gKCBuYW1lLCBzdGFydCwgZW5kLCBmcHMgKSB7XHJcblxyXG5cdHZhciBhbmltYXRpb24gPSB7XHJcblxyXG5cdFx0c3RhcnQ6IHN0YXJ0LFxyXG5cdFx0ZW5kOiBlbmQsXHJcblxyXG5cdFx0bGVuZ3RoOiBlbmQgLSBzdGFydCArIDEsXHJcblxyXG5cdFx0ZnBzOiBmcHMsXHJcblx0XHRkdXJhdGlvbjogKCBlbmQgLSBzdGFydCApIC8gZnBzLFxyXG5cclxuXHRcdGxhc3RGcmFtZTogMCxcclxuXHRcdGN1cnJlbnRGcmFtZTogMCxcclxuXHJcblx0XHRhY3RpdmU6IGZhbHNlLFxyXG5cclxuXHRcdHRpbWU6IDAsXHJcblx0XHRkaXJlY3Rpb246IDEsXHJcblx0XHR3ZWlnaHQ6IDEsXHJcblxyXG5cdFx0ZGlyZWN0aW9uQmFja3dhcmRzOiBmYWxzZSxcclxuXHRcdG1pcnJvcmVkTG9vcDogZmFsc2VcclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF0gPSBhbmltYXRpb247XHJcblx0dGhpcy5hbmltYXRpb25zTGlzdC5wdXNoKCBhbmltYXRpb24gKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuYXV0b0NyZWF0ZUFuaW1hdGlvbnMgPSBmdW5jdGlvbiAoIGZwcyApIHtcclxuXHJcblx0dmFyIHBhdHRlcm4gPSAvKFthLXpdKylfPyhcXGQrKS9pO1xyXG5cclxuXHR2YXIgZmlyc3RBbmltYXRpb24sIGZyYW1lUmFuZ2VzID0ge307XHJcblxyXG5cdHZhciBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XHJcblxyXG5cdGZvciAoIHZhciBpID0gMCwgaWwgPSBnZW9tZXRyeS5tb3JwaFRhcmdldHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0dmFyIG1vcnBoID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzWyBpIF07XHJcblx0XHR2YXIgY2h1bmtzID0gbW9ycGgubmFtZS5tYXRjaCggcGF0dGVybiApO1xyXG5cclxuXHRcdGlmICggY2h1bmtzICYmIGNodW5rcy5sZW5ndGggPiAxICkge1xyXG5cclxuXHRcdFx0dmFyIG5hbWUgPSBjaHVua3NbIDEgXTtcclxuXHJcblx0XHRcdGlmICggISBmcmFtZVJhbmdlc1sgbmFtZSBdICkgZnJhbWVSYW5nZXNbIG5hbWUgXSA9IHsgc3RhcnQ6IEluZmluaXR5LCBlbmQ6IC0gSW5maW5pdHkgfTtcclxuXHJcblx0XHRcdHZhciByYW5nZSA9IGZyYW1lUmFuZ2VzWyBuYW1lIF07XHJcblxyXG5cdFx0XHRpZiAoIGkgPCByYW5nZS5zdGFydCApIHJhbmdlLnN0YXJ0ID0gaTtcclxuXHRcdFx0aWYgKCBpID4gcmFuZ2UuZW5kICkgcmFuZ2UuZW5kID0gaTtcclxuXHJcblx0XHRcdGlmICggISBmaXJzdEFuaW1hdGlvbiApIGZpcnN0QW5pbWF0aW9uID0gbmFtZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0Zm9yICggdmFyIG5hbWUgaW4gZnJhbWVSYW5nZXMgKSB7XHJcblxyXG5cdFx0dmFyIHJhbmdlID0gZnJhbWVSYW5nZXNbIG5hbWUgXTtcclxuXHRcdHRoaXMuY3JlYXRlQW5pbWF0aW9uKCBuYW1lLCByYW5nZS5zdGFydCwgcmFuZ2UuZW5kLCBmcHMgKTtcclxuXHJcblx0fVxyXG5cclxuXHR0aGlzLmZpcnN0QW5pbWF0aW9uID0gZmlyc3RBbmltYXRpb247XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLnNldEFuaW1hdGlvbkRpcmVjdGlvbkZvcndhcmQgPSBmdW5jdGlvbiAoIG5hbWUgKSB7XHJcblxyXG5cdHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXTtcclxuXHJcblx0aWYgKCBhbmltYXRpb24gKSB7XHJcblxyXG5cdFx0YW5pbWF0aW9uLmRpcmVjdGlvbiA9IDE7XHJcblx0XHRhbmltYXRpb24uZGlyZWN0aW9uQmFja3dhcmRzID0gZmFsc2U7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuc2V0QW5pbWF0aW9uRGlyZWN0aW9uQmFja3dhcmQgPSBmdW5jdGlvbiAoIG5hbWUgKSB7XHJcblxyXG5cdHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXTtcclxuXHJcblx0aWYgKCBhbmltYXRpb24gKSB7XHJcblxyXG5cdFx0YW5pbWF0aW9uLmRpcmVjdGlvbiA9IC0gMTtcclxuXHRcdGFuaW1hdGlvbi5kaXJlY3Rpb25CYWNrd2FyZHMgPSB0cnVlO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLnNldEFuaW1hdGlvbkZQUyA9IGZ1bmN0aW9uICggbmFtZSwgZnBzICkge1xyXG5cclxuXHR2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF07XHJcblxyXG5cdGlmICggYW5pbWF0aW9uICkge1xyXG5cclxuXHRcdGFuaW1hdGlvbi5mcHMgPSBmcHM7XHJcblx0XHRhbmltYXRpb24uZHVyYXRpb24gPSAoIGFuaW1hdGlvbi5lbmQgLSBhbmltYXRpb24uc3RhcnQgKSAvIGFuaW1hdGlvbi5mcHM7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuc2V0QW5pbWF0aW9uRHVyYXRpb24gPSBmdW5jdGlvbiAoIG5hbWUsIGR1cmF0aW9uICkge1xyXG5cclxuXHR2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF07XHJcblxyXG5cdGlmICggYW5pbWF0aW9uICkge1xyXG5cclxuXHRcdGFuaW1hdGlvbi5kdXJhdGlvbiA9IGR1cmF0aW9uO1xyXG5cdFx0YW5pbWF0aW9uLmZwcyA9ICggYW5pbWF0aW9uLmVuZCAtIGFuaW1hdGlvbi5zdGFydCApIC8gYW5pbWF0aW9uLmR1cmF0aW9uO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLnNldEFuaW1hdGlvbldlaWdodCA9IGZ1bmN0aW9uICggbmFtZSwgd2VpZ2h0ICkge1xyXG5cclxuXHR2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF07XHJcblxyXG5cdGlmICggYW5pbWF0aW9uICkge1xyXG5cclxuXHRcdGFuaW1hdGlvbi53ZWlnaHQgPSB3ZWlnaHQ7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuc2V0QW5pbWF0aW9uVGltZSA9IGZ1bmN0aW9uICggbmFtZSwgdGltZSApIHtcclxuXHJcblx0dmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uc01hcFsgbmFtZSBdO1xyXG5cclxuXHRpZiAoIGFuaW1hdGlvbiApIHtcclxuXHJcblx0XHRhbmltYXRpb24udGltZSA9IHRpbWU7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuZ2V0QW5pbWF0aW9uVGltZSA9IGZ1bmN0aW9uICggbmFtZSApIHtcclxuXHJcblx0dmFyIHRpbWUgPSAwO1xyXG5cclxuXHR2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF07XHJcblxyXG5cdGlmICggYW5pbWF0aW9uICkge1xyXG5cclxuXHRcdHRpbWUgPSBhbmltYXRpb24udGltZTtcclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gdGltZTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuZ2V0QW5pbWF0aW9uRHVyYXRpb24gPSBmdW5jdGlvbiAoIG5hbWUgKSB7XHJcblxyXG5cdHZhciBkdXJhdGlvbiA9IC0gMTtcclxuXHJcblx0dmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uc01hcFsgbmFtZSBdO1xyXG5cclxuXHRpZiAoIGFuaW1hdGlvbiApIHtcclxuXHJcblx0XHRkdXJhdGlvbiA9IGFuaW1hdGlvbi5kdXJhdGlvbjtcclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gZHVyYXRpb247XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLnBsYXlBbmltYXRpb24gPSBmdW5jdGlvbiAoIG5hbWUgKSB7XHJcblxyXG5cdHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXTtcclxuXHJcblx0aWYgKCBhbmltYXRpb24gKSB7XHJcblxyXG5cdFx0YW5pbWF0aW9uLnRpbWUgPSAwO1xyXG5cdFx0YW5pbWF0aW9uLmFjdGl2ZSA9IHRydWU7XHJcblxyXG5cdH0gZWxzZSB7XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCBcIlRIUkVFLk1vcnBoQmxlbmRNZXNoOiBhbmltYXRpb25bXCIgKyBuYW1lICsgXCJdIHVuZGVmaW5lZCBpbiAucGxheUFuaW1hdGlvbigpXCIgKTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5zdG9wQW5pbWF0aW9uID0gZnVuY3Rpb24gKCBuYW1lICkge1xyXG5cclxuXHR2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF07XHJcblxyXG5cdGlmICggYW5pbWF0aW9uICkge1xyXG5cclxuXHRcdGFuaW1hdGlvbi5hY3RpdmUgPSBmYWxzZTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoIGRlbHRhICkge1xyXG5cclxuXHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gdGhpcy5hbmltYXRpb25zTGlzdC5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHR2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTGlzdFsgaSBdO1xyXG5cclxuXHRcdGlmICggISBhbmltYXRpb24uYWN0aXZlICkgY29udGludWU7XHJcblxyXG5cdFx0dmFyIGZyYW1lVGltZSA9IGFuaW1hdGlvbi5kdXJhdGlvbiAvIGFuaW1hdGlvbi5sZW5ndGg7XHJcblxyXG5cdFx0YW5pbWF0aW9uLnRpbWUgKz0gYW5pbWF0aW9uLmRpcmVjdGlvbiAqIGRlbHRhO1xyXG5cclxuXHRcdGlmICggYW5pbWF0aW9uLm1pcnJvcmVkTG9vcCApIHtcclxuXHJcblx0XHRcdGlmICggYW5pbWF0aW9uLnRpbWUgPiBhbmltYXRpb24uZHVyYXRpb24gfHwgYW5pbWF0aW9uLnRpbWUgPCAwICkge1xyXG5cclxuXHRcdFx0XHRhbmltYXRpb24uZGlyZWN0aW9uICo9IC0gMTtcclxuXHJcblx0XHRcdFx0aWYgKCBhbmltYXRpb24udGltZSA+IGFuaW1hdGlvbi5kdXJhdGlvbiApIHtcclxuXHJcblx0XHRcdFx0XHRhbmltYXRpb24udGltZSA9IGFuaW1hdGlvbi5kdXJhdGlvbjtcclxuXHRcdFx0XHRcdGFuaW1hdGlvbi5kaXJlY3Rpb25CYWNrd2FyZHMgPSB0cnVlO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggYW5pbWF0aW9uLnRpbWUgPCAwICkge1xyXG5cclxuXHRcdFx0XHRcdGFuaW1hdGlvbi50aW1lID0gMDtcclxuXHRcdFx0XHRcdGFuaW1hdGlvbi5kaXJlY3Rpb25CYWNrd2FyZHMgPSBmYWxzZTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRhbmltYXRpb24udGltZSA9IGFuaW1hdGlvbi50aW1lICUgYW5pbWF0aW9uLmR1cmF0aW9uO1xyXG5cclxuXHRcdFx0aWYgKCBhbmltYXRpb24udGltZSA8IDAgKSBhbmltYXRpb24udGltZSArPSBhbmltYXRpb24uZHVyYXRpb247XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBrZXlmcmFtZSA9IGFuaW1hdGlvbi5zdGFydCArIFRIUkVFLk1hdGguY2xhbXAoIE1hdGguZmxvb3IoIGFuaW1hdGlvbi50aW1lIC8gZnJhbWVUaW1lICksIDAsIGFuaW1hdGlvbi5sZW5ndGggLSAxICk7XHJcblx0XHR2YXIgd2VpZ2h0ID0gYW5pbWF0aW9uLndlaWdodDtcclxuXHJcblx0XHRpZiAoIGtleWZyYW1lICE9PSBhbmltYXRpb24uY3VycmVudEZyYW1lICkge1xyXG5cclxuXHRcdFx0dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXNbIGFuaW1hdGlvbi5sYXN0RnJhbWUgXSA9IDA7XHJcblx0XHRcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBhbmltYXRpb24uY3VycmVudEZyYW1lIF0gPSAxICogd2VpZ2h0O1xyXG5cclxuXHRcdFx0dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXNbIGtleWZyYW1lIF0gPSAwO1xyXG5cclxuXHRcdFx0YW5pbWF0aW9uLmxhc3RGcmFtZSA9IGFuaW1hdGlvbi5jdXJyZW50RnJhbWU7XHJcblx0XHRcdGFuaW1hdGlvbi5jdXJyZW50RnJhbWUgPSBrZXlmcmFtZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG1peCA9ICggYW5pbWF0aW9uLnRpbWUgJSBmcmFtZVRpbWUgKSAvIGZyYW1lVGltZTtcclxuXHJcblx0XHRpZiAoIGFuaW1hdGlvbi5kaXJlY3Rpb25CYWNrd2FyZHMgKSBtaXggPSAxIC0gbWl4O1xyXG5cclxuXHRcdGlmICggYW5pbWF0aW9uLmN1cnJlbnRGcmFtZSAhPT0gYW5pbWF0aW9uLmxhc3RGcmFtZSApIHtcclxuXHJcblx0XHRcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBhbmltYXRpb24uY3VycmVudEZyYW1lIF0gPSBtaXggKiB3ZWlnaHQ7XHJcblx0XHRcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBhbmltYXRpb24ubGFzdEZyYW1lIF0gPSAoIDEgLSBtaXggKSAqIHdlaWdodDtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXNbIGFuaW1hdGlvbi5jdXJyZW50RnJhbWUgXSA9IHdlaWdodDtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5cclxuLy8gRXhwb3J0IHRoZSBUSFJFRSBvYmplY3QgZm9yICoqTm9kZS5qcyoqLCB3aXRoXHJcbi8vIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IGZvciB0aGUgb2xkIGByZXF1aXJlKClgIEFQSS4gSWYgd2UncmUgaW5cclxuLy8gdGhlIGJyb3dzZXIsIGFkZCBgX2AgYXMgYSBnbG9iYWwgb2JqZWN0IHZpYSBhIHN0cmluZyBpZGVudGlmaWVyLFxyXG4vLyBmb3IgQ2xvc3VyZSBDb21waWxlciBcImFkdmFuY2VkXCIgbW9kZS5cclxuaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xyXG4gIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xyXG4gICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gVEhSRUU7XHJcbiAgfVxyXG4gIGV4cG9ydHMuVEhSRUUgPSBUSFJFRTtcclxufSBlbHNlIHtcclxuICB0aGlzWydUSFJFRSddID0gVEhSRUU7XHJcbn1cclxuXG59LHt9XSwyMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIFR3ZWVuLmpzIC0gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vc29sZS90d2Vlbi5qc1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICpcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vc29sZS90d2Vlbi5qcy9ncmFwaHMvY29udHJpYnV0b3JzIGZvciB0aGUgZnVsbCBsaXN0IG9mIGNvbnRyaWJ1dG9ycy5cbiAqIFRoYW5rIHlvdSBhbGwsIHlvdSdyZSBhd2Vzb21lIVxuICovXG5cbi8vIHBlcmZvcm1hbmNlLm5vdyBwb2x5ZmlsbFxuKCBmdW5jdGlvbiAoIHJvb3QgKSB7XG5cblx0aWYgKCAncGVyZm9ybWFuY2UnIGluIHJvb3QgPT09IGZhbHNlICkge1xuXHRcdHJvb3QucGVyZm9ybWFuY2UgPSB7fTtcblx0fVxuXG5cdC8vIElFIDhcblx0RGF0ZS5ub3cgPSAoIERhdGUubm93IHx8IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cdH0gKTtcblxuXHRpZiAoICdub3cnIGluIHJvb3QucGVyZm9ybWFuY2UgPT09IGZhbHNlICkge1xuXHRcdHZhciBvZmZzZXQgPSByb290LnBlcmZvcm1hbmNlLnRpbWluZyAmJiByb290LnBlcmZvcm1hbmNlLnRpbWluZy5uYXZpZ2F0aW9uU3RhcnQgPyBwZXJmb3JtYW5jZS50aW1pbmcubmF2aWdhdGlvblN0YXJ0XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IERhdGUubm93KCk7XG5cblx0XHRyb290LnBlcmZvcm1hbmNlLm5vdyA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBEYXRlLm5vdygpIC0gb2Zmc2V0O1xuXHRcdH07XG5cdH1cblxufSApKCB0aGlzICk7XG5cbnZhciBUV0VFTiA9IFRXRUVOIHx8ICggZnVuY3Rpb24gKCkge1xuXG5cdHZhciBfdHdlZW5zID0gW107XG5cblx0cmV0dXJuIHtcblxuXHRcdFJFVklTSU9OOiAnMTQnLFxuXG5cdFx0Z2V0QWxsOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiBfdHdlZW5zO1xuXG5cdFx0fSxcblxuXHRcdHJlbW92ZUFsbDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRfdHdlZW5zID0gW107XG5cblx0XHR9LFxuXG5cdFx0YWRkOiBmdW5jdGlvbiAoIHR3ZWVuICkge1xuXG5cdFx0XHRfdHdlZW5zLnB1c2goIHR3ZWVuICk7XG5cblx0XHR9LFxuXG5cdFx0cmVtb3ZlOiBmdW5jdGlvbiAoIHR3ZWVuICkge1xuXG5cdFx0XHR2YXIgaSA9IF90d2VlbnMuaW5kZXhPZiggdHdlZW4gKTtcblxuXHRcdFx0aWYgKCBpICE9PSAtMSApIHtcblxuXHRcdFx0XHRfdHdlZW5zLnNwbGljZSggaSwgMSApO1xuXG5cdFx0XHR9XG5cblx0XHR9LFxuXG5cdFx0dXBkYXRlOiBmdW5jdGlvbiAoIHRpbWUgKSB7XG5cblx0XHRcdGlmICggX3R3ZWVucy5sZW5ndGggPT09IDAgKSByZXR1cm4gZmFsc2U7XG5cblx0XHRcdHZhciBpID0gMDtcblxuXHRcdFx0dGltZSA9IHRpbWUgIT09IHVuZGVmaW5lZCA/IHRpbWUgOiB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCk7XG5cblx0XHRcdHdoaWxlICggaSA8IF90d2VlbnMubGVuZ3RoICkge1xuXG5cdFx0XHRcdGlmICggX3R3ZWVuc1sgaSBdLnVwZGF0ZSggdGltZSApICkge1xuXG5cdFx0XHRcdFx0aSsrO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRfdHdlZW5zLnNwbGljZSggaSwgMSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdH1cblx0fTtcblxufSApKCk7XG5cblRXRUVOLlR3ZWVuID0gZnVuY3Rpb24gKCBvYmplY3QgKSB7XG5cblx0dmFyIF9vYmplY3QgPSBvYmplY3Q7XG5cdHZhciBfdmFsdWVzU3RhcnQgPSB7fTtcblx0dmFyIF92YWx1ZXNFbmQgPSB7fTtcblx0dmFyIF92YWx1ZXNTdGFydFJlcGVhdCA9IHt9O1xuXHR2YXIgX2R1cmF0aW9uID0gMTAwMDtcblx0dmFyIF9yZXBlYXQgPSAwO1xuXHR2YXIgX3lveW8gPSBmYWxzZTtcblx0dmFyIF9pc1BsYXlpbmcgPSBmYWxzZTtcblx0dmFyIF9yZXZlcnNlZCA9IGZhbHNlO1xuXHR2YXIgX2RlbGF5VGltZSA9IDA7XG5cdHZhciBfc3RhcnRUaW1lID0gbnVsbDtcblx0dmFyIF9lYXNpbmdGdW5jdGlvbiA9IFRXRUVOLkVhc2luZy5MaW5lYXIuTm9uZTtcblx0dmFyIF9pbnRlcnBvbGF0aW9uRnVuY3Rpb24gPSBUV0VFTi5JbnRlcnBvbGF0aW9uLkxpbmVhcjtcblx0dmFyIF9jaGFpbmVkVHdlZW5zID0gW107XG5cdHZhciBfb25TdGFydENhbGxiYWNrID0gbnVsbDtcblx0dmFyIF9vblN0YXJ0Q2FsbGJhY2tGaXJlZCA9IGZhbHNlO1xuXHR2YXIgX29uVXBkYXRlQ2FsbGJhY2sgPSBudWxsO1xuXHR2YXIgX29uQ29tcGxldGVDYWxsYmFjayA9IG51bGw7XG5cdHZhciBfb25TdG9wQ2FsbGJhY2sgPSBudWxsO1xuXG5cdC8vIFNldCBhbGwgc3RhcnRpbmcgdmFsdWVzIHByZXNlbnQgb24gdGhlIHRhcmdldCBvYmplY3Rcblx0Zm9yICggdmFyIGZpZWxkIGluIG9iamVjdCApIHtcblxuXHRcdF92YWx1ZXNTdGFydFsgZmllbGQgXSA9IHBhcnNlRmxvYXQob2JqZWN0W2ZpZWxkXSwgMTApO1xuXG5cdH1cblxuXHR0aGlzLnRvID0gZnVuY3Rpb24gKCBwcm9wZXJ0aWVzLCBkdXJhdGlvbiApIHtcblxuXHRcdGlmICggZHVyYXRpb24gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0X2R1cmF0aW9uID0gZHVyYXRpb247XG5cblx0XHR9XG5cblx0XHRfdmFsdWVzRW5kID0gcHJvcGVydGllcztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblx0dGhpcy5zdGFydCA9IGZ1bmN0aW9uICggdGltZSApIHtcblxuXHRcdFRXRUVOLmFkZCggdGhpcyApO1xuXG5cdFx0X2lzUGxheWluZyA9IHRydWU7XG5cblx0XHRfb25TdGFydENhbGxiYWNrRmlyZWQgPSBmYWxzZTtcblxuXHRcdF9zdGFydFRpbWUgPSB0aW1lICE9PSB1bmRlZmluZWQgPyB0aW1lIDogd2luZG93LnBlcmZvcm1hbmNlLm5vdygpO1xuXHRcdF9zdGFydFRpbWUgKz0gX2RlbGF5VGltZTtcblxuXHRcdGZvciAoIHZhciBwcm9wZXJ0eSBpbiBfdmFsdWVzRW5kICkge1xuXG5cdFx0XHQvLyBjaGVjayBpZiBhbiBBcnJheSB3YXMgcHJvdmlkZWQgYXMgcHJvcGVydHkgdmFsdWVcblx0XHRcdGlmICggX3ZhbHVlc0VuZFsgcHJvcGVydHkgXSBpbnN0YW5jZW9mIEFycmF5ICkge1xuXG5cdFx0XHRcdGlmICggX3ZhbHVlc0VuZFsgcHJvcGVydHkgXS5sZW5ndGggPT09IDAgKSB7XG5cblx0XHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gY3JlYXRlIGEgbG9jYWwgY29weSBvZiB0aGUgQXJyYXkgd2l0aCB0aGUgc3RhcnQgdmFsdWUgYXQgdGhlIGZyb250XG5cdFx0XHRcdF92YWx1ZXNFbmRbIHByb3BlcnR5IF0gPSBbIF9vYmplY3RbIHByb3BlcnR5IF0gXS5jb25jYXQoIF92YWx1ZXNFbmRbIHByb3BlcnR5IF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRfdmFsdWVzU3RhcnRbIHByb3BlcnR5IF0gPSBfb2JqZWN0WyBwcm9wZXJ0eSBdO1xuXG5cdFx0XHRpZiggKCBfdmFsdWVzU3RhcnRbIHByb3BlcnR5IF0gaW5zdGFuY2VvZiBBcnJheSApID09PSBmYWxzZSApIHtcblx0XHRcdFx0X3ZhbHVlc1N0YXJ0WyBwcm9wZXJ0eSBdICo9IDEuMDsgLy8gRW5zdXJlcyB3ZSdyZSB1c2luZyBudW1iZXJzLCBub3Qgc3RyaW5nc1xuXHRcdFx0fVxuXG5cdFx0XHRfdmFsdWVzU3RhcnRSZXBlYXRbIHByb3BlcnR5IF0gPSBfdmFsdWVzU3RhcnRbIHByb3BlcnR5IF0gfHwgMDtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblx0dGhpcy5zdG9wID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0aWYgKCAhX2lzUGxheWluZyApIHtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdFRXRUVOLnJlbW92ZSggdGhpcyApO1xuXHRcdF9pc1BsYXlpbmcgPSBmYWxzZTtcblxuXHRcdGlmICggX29uU3RvcENhbGxiYWNrICE9PSBudWxsICkge1xuXG5cdFx0XHRfb25TdG9wQ2FsbGJhY2suY2FsbCggX29iamVjdCApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5zdG9wQ2hhaW5lZFR3ZWVucygpO1xuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblx0dGhpcy5zdG9wQ2hhaW5lZFR3ZWVucyA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdGZvciAoIHZhciBpID0gMCwgbnVtQ2hhaW5lZFR3ZWVucyA9IF9jaGFpbmVkVHdlZW5zLmxlbmd0aDsgaSA8IG51bUNoYWluZWRUd2VlbnM7IGkrKyApIHtcblxuXHRcdFx0X2NoYWluZWRUd2VlbnNbIGkgXS5zdG9wKCk7XG5cblx0XHR9XG5cblx0fTtcblxuXHR0aGlzLmRlbGF5ID0gZnVuY3Rpb24gKCBhbW91bnQgKSB7XG5cblx0XHRfZGVsYXlUaW1lID0gYW1vdW50O1xuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblx0dGhpcy5yZXBlYXQgPSBmdW5jdGlvbiAoIHRpbWVzICkge1xuXG5cdFx0X3JlcGVhdCA9IHRpbWVzO1xuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblx0dGhpcy55b3lvID0gZnVuY3Rpb24oIHlveW8gKSB7XG5cblx0XHRfeW95byA9IHlveW87XG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxuXG5cdHRoaXMuZWFzaW5nID0gZnVuY3Rpb24gKCBlYXNpbmcgKSB7XG5cblx0XHRfZWFzaW5nRnVuY3Rpb24gPSBlYXNpbmc7XG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxuXHR0aGlzLmludGVycG9sYXRpb24gPSBmdW5jdGlvbiAoIGludGVycG9sYXRpb24gKSB7XG5cblx0XHRfaW50ZXJwb2xhdGlvbkZ1bmN0aW9uID0gaW50ZXJwb2xhdGlvbjtcblx0XHRyZXR1cm4gdGhpcztcblxuXHR9O1xuXG5cdHRoaXMuY2hhaW4gPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRfY2hhaW5lZFR3ZWVucyA9IGFyZ3VtZW50cztcblx0XHRyZXR1cm4gdGhpcztcblxuXHR9O1xuXG5cdHRoaXMub25TdGFydCA9IGZ1bmN0aW9uICggY2FsbGJhY2sgKSB7XG5cblx0XHRfb25TdGFydENhbGxiYWNrID0gY2FsbGJhY2s7XG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxuXHR0aGlzLm9uVXBkYXRlID0gZnVuY3Rpb24gKCBjYWxsYmFjayApIHtcblxuXHRcdF9vblVwZGF0ZUNhbGxiYWNrID0gY2FsbGJhY2s7XG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxuXHR0aGlzLm9uQ29tcGxldGUgPSBmdW5jdGlvbiAoIGNhbGxiYWNrICkge1xuXG5cdFx0X29uQ29tcGxldGVDYWxsYmFjayA9IGNhbGxiYWNrO1xuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblx0dGhpcy5vblN0b3AgPSBmdW5jdGlvbiAoIGNhbGxiYWNrICkge1xuXG5cdFx0X29uU3RvcENhbGxiYWNrID0gY2FsbGJhY2s7XG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxuXHR0aGlzLnVwZGF0ZSA9IGZ1bmN0aW9uICggdGltZSApIHtcblxuXHRcdHZhciBwcm9wZXJ0eTtcblxuXHRcdGlmICggdGltZSA8IF9zdGFydFRpbWUgKSB7XG5cblx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBfb25TdGFydENhbGxiYWNrRmlyZWQgPT09IGZhbHNlICkge1xuXG5cdFx0XHRpZiAoIF9vblN0YXJ0Q2FsbGJhY2sgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0X29uU3RhcnRDYWxsYmFjay5jYWxsKCBfb2JqZWN0ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0X29uU3RhcnRDYWxsYmFja0ZpcmVkID0gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdHZhciBlbGFwc2VkID0gKCB0aW1lIC0gX3N0YXJ0VGltZSApIC8gX2R1cmF0aW9uO1xuXHRcdGVsYXBzZWQgPSBlbGFwc2VkID4gMSA/IDEgOiBlbGFwc2VkO1xuXG5cdFx0dmFyIHZhbHVlID0gX2Vhc2luZ0Z1bmN0aW9uKCBlbGFwc2VkICk7XG5cblx0XHRmb3IgKCBwcm9wZXJ0eSBpbiBfdmFsdWVzRW5kICkge1xuXG5cdFx0XHR2YXIgc3RhcnQgPSBfdmFsdWVzU3RhcnRbIHByb3BlcnR5IF0gfHwgMDtcblx0XHRcdHZhciBlbmQgPSBfdmFsdWVzRW5kWyBwcm9wZXJ0eSBdO1xuXG5cdFx0XHRpZiAoIGVuZCBpbnN0YW5jZW9mIEFycmF5ICkge1xuXG5cdFx0XHRcdF9vYmplY3RbIHByb3BlcnR5IF0gPSBfaW50ZXJwb2xhdGlvbkZ1bmN0aW9uKCBlbmQsIHZhbHVlICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gUGFyc2VzIHJlbGF0aXZlIGVuZCB2YWx1ZXMgd2l0aCBzdGFydCBhcyBiYXNlIChlLmcuOiArMTAsIC0zKVxuXHRcdFx0XHRpZiAoIHR5cGVvZihlbmQpID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHRcdGVuZCA9IHN0YXJ0ICsgcGFyc2VGbG9hdChlbmQsIDEwKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHByb3RlY3QgYWdhaW5zdCBub24gbnVtZXJpYyBwcm9wZXJ0aWVzLlxuXHRcdFx0XHRpZiAoIHR5cGVvZihlbmQpID09PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHRcdF9vYmplY3RbIHByb3BlcnR5IF0gPSBzdGFydCArICggZW5kIC0gc3RhcnQgKSAqIHZhbHVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggX29uVXBkYXRlQ2FsbGJhY2sgIT09IG51bGwgKSB7XG5cblx0XHRcdF9vblVwZGF0ZUNhbGxiYWNrLmNhbGwoIF9vYmplY3QsIHZhbHVlICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGVsYXBzZWQgPT0gMSApIHtcblxuXHRcdFx0aWYgKCBfcmVwZWF0ID4gMCApIHtcblxuXHRcdFx0XHRpZiggaXNGaW5pdGUoIF9yZXBlYXQgKSApIHtcblx0XHRcdFx0XHRfcmVwZWF0LS07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyByZWFzc2lnbiBzdGFydGluZyB2YWx1ZXMsIHJlc3RhcnQgYnkgbWFraW5nIHN0YXJ0VGltZSA9IG5vd1xuXHRcdFx0XHRmb3IoIHByb3BlcnR5IGluIF92YWx1ZXNTdGFydFJlcGVhdCApIHtcblxuXHRcdFx0XHRcdGlmICggdHlwZW9mKCBfdmFsdWVzRW5kWyBwcm9wZXJ0eSBdICkgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdFx0XHRfdmFsdWVzU3RhcnRSZXBlYXRbIHByb3BlcnR5IF0gPSBfdmFsdWVzU3RhcnRSZXBlYXRbIHByb3BlcnR5IF0gKyBwYXJzZUZsb2F0KF92YWx1ZXNFbmRbIHByb3BlcnR5IF0sIDEwKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoX3lveW8pIHtcblx0XHRcdFx0XHRcdHZhciB0bXAgPSBfdmFsdWVzU3RhcnRSZXBlYXRbIHByb3BlcnR5IF07XG5cdFx0XHRcdFx0XHRfdmFsdWVzU3RhcnRSZXBlYXRbIHByb3BlcnR5IF0gPSBfdmFsdWVzRW5kWyBwcm9wZXJ0eSBdO1xuXHRcdFx0XHRcdFx0X3ZhbHVlc0VuZFsgcHJvcGVydHkgXSA9IHRtcDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRfdmFsdWVzU3RhcnRbIHByb3BlcnR5IF0gPSBfdmFsdWVzU3RhcnRSZXBlYXRbIHByb3BlcnR5IF07XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChfeW95bykge1xuXHRcdFx0XHRcdF9yZXZlcnNlZCA9ICFfcmV2ZXJzZWQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRfc3RhcnRUaW1lID0gdGltZSArIF9kZWxheVRpbWU7XG5cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0aWYgKCBfb25Db21wbGV0ZUNhbGxiYWNrICE9PSBudWxsICkge1xuXG5cdFx0XHRcdFx0X29uQ29tcGxldGVDYWxsYmFjay5jYWxsKCBfb2JqZWN0ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbnVtQ2hhaW5lZFR3ZWVucyA9IF9jaGFpbmVkVHdlZW5zLmxlbmd0aDsgaSA8IG51bUNoYWluZWRUd2VlbnM7IGkrKyApIHtcblxuXHRcdFx0XHRcdF9jaGFpbmVkVHdlZW5zWyBpIF0uc3RhcnQoIHRpbWUgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblxuXHR9O1xuXG59O1xuXG5cblRXRUVOLkVhc2luZyA9IHtcblxuXHRMaW5lYXI6IHtcblxuXHRcdE5vbmU6IGZ1bmN0aW9uICggayApIHtcblxuXHRcdFx0cmV0dXJuIGs7XG5cblx0XHR9XG5cblx0fSxcblxuXHRRdWFkcmF0aWM6IHtcblxuXHRcdEluOiBmdW5jdGlvbiAoIGsgKSB7XG5cblx0XHRcdHJldHVybiBrICogaztcblxuXHRcdH0sXG5cblx0XHRPdXQ6IGZ1bmN0aW9uICggayApIHtcblxuXHRcdFx0cmV0dXJuIGsgKiAoIDIgLSBrICk7XG5cblx0XHR9LFxuXG5cdFx0SW5PdXQ6IGZ1bmN0aW9uICggayApIHtcblxuXHRcdFx0aWYgKCAoIGsgKj0gMiApIDwgMSApIHJldHVybiAwLjUgKiBrICogaztcblx0XHRcdHJldHVybiAtIDAuNSAqICggLS1rICogKCBrIC0gMiApIC0gMSApO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0Q3ViaWM6IHtcblxuXHRcdEluOiBmdW5jdGlvbiAoIGsgKSB7XG5cblx0XHRcdHJldHVybiBrICogayAqIGs7XG5cblx0XHR9LFxuXG5cdFx0T3V0OiBmdW5jdGlvbiAoIGsgKSB7XG5cblx0XHRcdHJldHVybiAtLWsgKiBrICogayArIDE7XG5cblx0XHR9LFxuXG5cdFx0SW5PdXQ6IGZ1bmN0aW9uICggayApIHtcblxuXHRcdFx0aWYgKCAoIGsgKj0gMiApIDwgMSApIHJldHVybiAwLjUgKiBrICogayAqIGs7XG5cdFx0XHRyZXR1cm4gMC41ICogKCAoIGsgLT0gMiApICogayAqIGsgKyAyICk7XG5cblx0XHR9XG5cblx0fSxcblxuXHRRdWFydGljOiB7XG5cblx0XHRJbjogZnVuY3Rpb24gKCBrICkge1xuXG5cdFx0XHRyZXR1cm4gayAqIGsgKiBrICogaztcblxuXHRcdH0sXG5cblx0XHRPdXQ6IGZ1bmN0aW9uICggayApIHtcblxuXHRcdFx0cmV0dXJuIDEgLSAoIC0tayAqIGsgKiBrICogayApO1xuXG5cdFx0fSxcblxuXHRcdEluT3V0OiBmdW5jdGlvbiAoIGsgKSB7XG5cblx0XHRcdGlmICggKCBrICo9IDIgKSA8IDEpIHJldHVybiAwLjUgKiBrICogayAqIGsgKiBrO1xuXHRcdFx0cmV0dXJuIC0gMC41ICogKCAoIGsgLT0gMiApICogayAqIGsgKiBrIC0gMiApO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0UXVpbnRpYzoge1xuXG5cdFx0SW46IGZ1bmN0aW9uICggayApIHtcblxuXHRcdFx0cmV0dXJuIGsgKiBrICogayAqIGsgKiBrO1xuXG5cdFx0fSxcblxuXHRcdE91dDogZnVuY3Rpb24gKCBrICkge1xuXG5cdFx0XHRyZXR1cm4gLS1rICogayAqIGsgKiBrICogayArIDE7XG5cblx0XHR9LFxuXG5cdFx0SW5PdXQ6IGZ1bmN0aW9uICggayApIHtcblxuXHRcdFx0aWYgKCAoIGsgKj0gMiApIDwgMSApIHJldHVybiAwLjUgKiBrICogayAqIGsgKiBrICogaztcblx0XHRcdHJldHVybiAwLjUgKiAoICggayAtPSAyICkgKiBrICogayAqIGsgKiBrICsgMiApO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0U2ludXNvaWRhbDoge1xuXG5cdFx0SW46IGZ1bmN0aW9uICggayApIHtcblxuXHRcdFx0cmV0dXJuIDEgLSBNYXRoLmNvcyggayAqIE1hdGguUEkgLyAyICk7XG5cblx0XHR9LFxuXG5cdFx0T3V0OiBmdW5jdGlvbiAoIGsgKSB7XG5cblx0XHRcdHJldHVybiBNYXRoLnNpbiggayAqIE1hdGguUEkgLyAyICk7XG5cblx0XHR9LFxuXG5cdFx0SW5PdXQ6IGZ1bmN0aW9uICggayApIHtcblxuXHRcdFx0cmV0dXJuIDAuNSAqICggMSAtIE1hdGguY29zKCBNYXRoLlBJICogayApICk7XG5cblx0XHR9XG5cblx0fSxcblxuXHRFeHBvbmVudGlhbDoge1xuXG5cdFx0SW46IGZ1bmN0aW9uICggayApIHtcblxuXHRcdFx0cmV0dXJuIGsgPT09IDAgPyAwIDogTWF0aC5wb3coIDEwMjQsIGsgLSAxICk7XG5cblx0XHR9LFxuXG5cdFx0T3V0OiBmdW5jdGlvbiAoIGsgKSB7XG5cblx0XHRcdHJldHVybiBrID09PSAxID8gMSA6IDEgLSBNYXRoLnBvdyggMiwgLSAxMCAqIGsgKTtcblxuXHRcdH0sXG5cblx0XHRJbk91dDogZnVuY3Rpb24gKCBrICkge1xuXG5cdFx0XHRpZiAoIGsgPT09IDAgKSByZXR1cm4gMDtcblx0XHRcdGlmICggayA9PT0gMSApIHJldHVybiAxO1xuXHRcdFx0aWYgKCAoIGsgKj0gMiApIDwgMSApIHJldHVybiAwLjUgKiBNYXRoLnBvdyggMTAyNCwgayAtIDEgKTtcblx0XHRcdHJldHVybiAwLjUgKiAoIC0gTWF0aC5wb3coIDIsIC0gMTAgKiAoIGsgLSAxICkgKSArIDIgKTtcblxuXHRcdH1cblxuXHR9LFxuXG5cdENpcmN1bGFyOiB7XG5cblx0XHRJbjogZnVuY3Rpb24gKCBrICkge1xuXG5cdFx0XHRyZXR1cm4gMSAtIE1hdGguc3FydCggMSAtIGsgKiBrICk7XG5cblx0XHR9LFxuXG5cdFx0T3V0OiBmdW5jdGlvbiAoIGsgKSB7XG5cblx0XHRcdHJldHVybiBNYXRoLnNxcnQoIDEgLSAoIC0tayAqIGsgKSApO1xuXG5cdFx0fSxcblxuXHRcdEluT3V0OiBmdW5jdGlvbiAoIGsgKSB7XG5cblx0XHRcdGlmICggKCBrICo9IDIgKSA8IDEpIHJldHVybiAtIDAuNSAqICggTWF0aC5zcXJ0KCAxIC0gayAqIGspIC0gMSk7XG5cdFx0XHRyZXR1cm4gMC41ICogKCBNYXRoLnNxcnQoIDEgLSAoIGsgLT0gMikgKiBrKSArIDEpO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0RWxhc3RpYzoge1xuXG5cdFx0SW46IGZ1bmN0aW9uICggayApIHtcblxuXHRcdFx0dmFyIHMsIGEgPSAwLjEsIHAgPSAwLjQ7XG5cdFx0XHRpZiAoIGsgPT09IDAgKSByZXR1cm4gMDtcblx0XHRcdGlmICggayA9PT0gMSApIHJldHVybiAxO1xuXHRcdFx0aWYgKCAhYSB8fCBhIDwgMSApIHsgYSA9IDE7IHMgPSBwIC8gNDsgfVxuXHRcdFx0ZWxzZSBzID0gcCAqIE1hdGguYXNpbiggMSAvIGEgKSAvICggMiAqIE1hdGguUEkgKTtcblx0XHRcdHJldHVybiAtICggYSAqIE1hdGgucG93KCAyLCAxMCAqICggayAtPSAxICkgKSAqIE1hdGguc2luKCAoIGsgLSBzICkgKiAoIDIgKiBNYXRoLlBJICkgLyBwICkgKTtcblxuXHRcdH0sXG5cblx0XHRPdXQ6IGZ1bmN0aW9uICggayApIHtcblxuXHRcdFx0dmFyIHMsIGEgPSAwLjEsIHAgPSAwLjQ7XG5cdFx0XHRpZiAoIGsgPT09IDAgKSByZXR1cm4gMDtcblx0XHRcdGlmICggayA9PT0gMSApIHJldHVybiAxO1xuXHRcdFx0aWYgKCAhYSB8fCBhIDwgMSApIHsgYSA9IDE7IHMgPSBwIC8gNDsgfVxuXHRcdFx0ZWxzZSBzID0gcCAqIE1hdGguYXNpbiggMSAvIGEgKSAvICggMiAqIE1hdGguUEkgKTtcblx0XHRcdHJldHVybiAoIGEgKiBNYXRoLnBvdyggMiwgLSAxMCAqIGspICogTWF0aC5zaW4oICggayAtIHMgKSAqICggMiAqIE1hdGguUEkgKSAvIHAgKSArIDEgKTtcblxuXHRcdH0sXG5cblx0XHRJbk91dDogZnVuY3Rpb24gKCBrICkge1xuXG5cdFx0XHR2YXIgcywgYSA9IDAuMSwgcCA9IDAuNDtcblx0XHRcdGlmICggayA9PT0gMCApIHJldHVybiAwO1xuXHRcdFx0aWYgKCBrID09PSAxICkgcmV0dXJuIDE7XG5cdFx0XHRpZiAoICFhIHx8IGEgPCAxICkgeyBhID0gMTsgcyA9IHAgLyA0OyB9XG5cdFx0XHRlbHNlIHMgPSBwICogTWF0aC5hc2luKCAxIC8gYSApIC8gKCAyICogTWF0aC5QSSApO1xuXHRcdFx0aWYgKCAoIGsgKj0gMiApIDwgMSApIHJldHVybiAtIDAuNSAqICggYSAqIE1hdGgucG93KCAyLCAxMCAqICggayAtPSAxICkgKSAqIE1hdGguc2luKCAoIGsgLSBzICkgKiAoIDIgKiBNYXRoLlBJICkgLyBwICkgKTtcblx0XHRcdHJldHVybiBhICogTWF0aC5wb3coIDIsIC0xMCAqICggayAtPSAxICkgKSAqIE1hdGguc2luKCAoIGsgLSBzICkgKiAoIDIgKiBNYXRoLlBJICkgLyBwICkgKiAwLjUgKyAxO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0QmFjazoge1xuXG5cdFx0SW46IGZ1bmN0aW9uICggayApIHtcblxuXHRcdFx0dmFyIHMgPSAxLjcwMTU4O1xuXHRcdFx0cmV0dXJuIGsgKiBrICogKCAoIHMgKyAxICkgKiBrIC0gcyApO1xuXG5cdFx0fSxcblxuXHRcdE91dDogZnVuY3Rpb24gKCBrICkge1xuXG5cdFx0XHR2YXIgcyA9IDEuNzAxNTg7XG5cdFx0XHRyZXR1cm4gLS1rICogayAqICggKCBzICsgMSApICogayArIHMgKSArIDE7XG5cblx0XHR9LFxuXG5cdFx0SW5PdXQ6IGZ1bmN0aW9uICggayApIHtcblxuXHRcdFx0dmFyIHMgPSAxLjcwMTU4ICogMS41MjU7XG5cdFx0XHRpZiAoICggayAqPSAyICkgPCAxICkgcmV0dXJuIDAuNSAqICggayAqIGsgKiAoICggcyArIDEgKSAqIGsgLSBzICkgKTtcblx0XHRcdHJldHVybiAwLjUgKiAoICggayAtPSAyICkgKiBrICogKCAoIHMgKyAxICkgKiBrICsgcyApICsgMiApO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0Qm91bmNlOiB7XG5cblx0XHRJbjogZnVuY3Rpb24gKCBrICkge1xuXG5cdFx0XHRyZXR1cm4gMSAtIFRXRUVOLkVhc2luZy5Cb3VuY2UuT3V0KCAxIC0gayApO1xuXG5cdFx0fSxcblxuXHRcdE91dDogZnVuY3Rpb24gKCBrICkge1xuXG5cdFx0XHRpZiAoIGsgPCAoIDEgLyAyLjc1ICkgKSB7XG5cblx0XHRcdFx0cmV0dXJuIDcuNTYyNSAqIGsgKiBrO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBrIDwgKCAyIC8gMi43NSApICkge1xuXG5cdFx0XHRcdHJldHVybiA3LjU2MjUgKiAoIGsgLT0gKCAxLjUgLyAyLjc1ICkgKSAqIGsgKyAwLjc1O1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBrIDwgKCAyLjUgLyAyLjc1ICkgKSB7XG5cblx0XHRcdFx0cmV0dXJuIDcuNTYyNSAqICggayAtPSAoIDIuMjUgLyAyLjc1ICkgKSAqIGsgKyAwLjkzNzU7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0cmV0dXJuIDcuNTYyNSAqICggayAtPSAoIDIuNjI1IC8gMi43NSApICkgKiBrICsgMC45ODQzNzU7XG5cblx0XHRcdH1cblxuXHRcdH0sXG5cblx0XHRJbk91dDogZnVuY3Rpb24gKCBrICkge1xuXG5cdFx0XHRpZiAoIGsgPCAwLjUgKSByZXR1cm4gVFdFRU4uRWFzaW5nLkJvdW5jZS5JbiggayAqIDIgKSAqIDAuNTtcblx0XHRcdHJldHVybiBUV0VFTi5FYXNpbmcuQm91bmNlLk91dCggayAqIDIgLSAxICkgKiAwLjUgKyAwLjU7XG5cblx0XHR9XG5cblx0fVxuXG59O1xuXG5UV0VFTi5JbnRlcnBvbGF0aW9uID0ge1xuXG5cdExpbmVhcjogZnVuY3Rpb24gKCB2LCBrICkge1xuXG5cdFx0dmFyIG0gPSB2Lmxlbmd0aCAtIDEsIGYgPSBtICogaywgaSA9IE1hdGguZmxvb3IoIGYgKSwgZm4gPSBUV0VFTi5JbnRlcnBvbGF0aW9uLlV0aWxzLkxpbmVhcjtcblxuXHRcdGlmICggayA8IDAgKSByZXR1cm4gZm4oIHZbIDAgXSwgdlsgMSBdLCBmICk7XG5cdFx0aWYgKCBrID4gMSApIHJldHVybiBmbiggdlsgbSBdLCB2WyBtIC0gMSBdLCBtIC0gZiApO1xuXG5cdFx0cmV0dXJuIGZuKCB2WyBpIF0sIHZbIGkgKyAxID4gbSA/IG0gOiBpICsgMSBdLCBmIC0gaSApO1xuXG5cdH0sXG5cblx0QmV6aWVyOiBmdW5jdGlvbiAoIHYsIGsgKSB7XG5cblx0XHR2YXIgYiA9IDAsIG4gPSB2Lmxlbmd0aCAtIDEsIHB3ID0gTWF0aC5wb3csIGJuID0gVFdFRU4uSW50ZXJwb2xhdGlvbi5VdGlscy5CZXJuc3RlaW4sIGk7XG5cblx0XHRmb3IgKCBpID0gMDsgaSA8PSBuOyBpKysgKSB7XG5cdFx0XHRiICs9IHB3KCAxIC0gaywgbiAtIGkgKSAqIHB3KCBrLCBpICkgKiB2WyBpIF0gKiBibiggbiwgaSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBiO1xuXG5cdH0sXG5cblx0Q2F0bXVsbFJvbTogZnVuY3Rpb24gKCB2LCBrICkge1xuXG5cdFx0dmFyIG0gPSB2Lmxlbmd0aCAtIDEsIGYgPSBtICogaywgaSA9IE1hdGguZmxvb3IoIGYgKSwgZm4gPSBUV0VFTi5JbnRlcnBvbGF0aW9uLlV0aWxzLkNhdG11bGxSb207XG5cblx0XHRpZiAoIHZbIDAgXSA9PT0gdlsgbSBdICkge1xuXG5cdFx0XHRpZiAoIGsgPCAwICkgaSA9IE1hdGguZmxvb3IoIGYgPSBtICogKCAxICsgayApICk7XG5cblx0XHRcdHJldHVybiBmbiggdlsgKCBpIC0gMSArIG0gKSAlIG0gXSwgdlsgaSBdLCB2WyAoIGkgKyAxICkgJSBtIF0sIHZbICggaSArIDIgKSAlIG0gXSwgZiAtIGkgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGlmICggayA8IDAgKSByZXR1cm4gdlsgMCBdIC0gKCBmbiggdlsgMCBdLCB2WyAwIF0sIHZbIDEgXSwgdlsgMSBdLCAtZiApIC0gdlsgMCBdICk7XG5cdFx0XHRpZiAoIGsgPiAxICkgcmV0dXJuIHZbIG0gXSAtICggZm4oIHZbIG0gXSwgdlsgbSBdLCB2WyBtIC0gMSBdLCB2WyBtIC0gMSBdLCBmIC0gbSApIC0gdlsgbSBdICk7XG5cblx0XHRcdHJldHVybiBmbiggdlsgaSA/IGkgLSAxIDogMCBdLCB2WyBpIF0sIHZbIG0gPCBpICsgMSA/IG0gOiBpICsgMSBdLCB2WyBtIDwgaSArIDIgPyBtIDogaSArIDIgXSwgZiAtIGkgKTtcblxuXHRcdH1cblxuXHR9LFxuXG5cdFV0aWxzOiB7XG5cblx0XHRMaW5lYXI6IGZ1bmN0aW9uICggcDAsIHAxLCB0ICkge1xuXG5cdFx0XHRyZXR1cm4gKCBwMSAtIHAwICkgKiB0ICsgcDA7XG5cblx0XHR9LFxuXG5cdFx0QmVybnN0ZWluOiBmdW5jdGlvbiAoIG4gLCBpICkge1xuXG5cdFx0XHR2YXIgZmMgPSBUV0VFTi5JbnRlcnBvbGF0aW9uLlV0aWxzLkZhY3RvcmlhbDtcblx0XHRcdHJldHVybiBmYyggbiApIC8gZmMoIGkgKSAvIGZjKCBuIC0gaSApO1xuXG5cdFx0fSxcblxuXHRcdEZhY3RvcmlhbDogKCBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciBhID0gWyAxIF07XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbiAoIG4gKSB7XG5cblx0XHRcdFx0dmFyIHMgPSAxLCBpO1xuXHRcdFx0XHRpZiAoIGFbIG4gXSApIHJldHVybiBhWyBuIF07XG5cdFx0XHRcdGZvciAoIGkgPSBuOyBpID4gMTsgaS0tICkgcyAqPSBpO1xuXHRcdFx0XHRyZXR1cm4gYVsgbiBdID0gcztcblxuXHRcdFx0fTtcblxuXHRcdH0gKSgpLFxuXG5cdFx0Q2F0bXVsbFJvbTogZnVuY3Rpb24gKCBwMCwgcDEsIHAyLCBwMywgdCApIHtcblxuXHRcdFx0dmFyIHYwID0gKCBwMiAtIHAwICkgKiAwLjUsIHYxID0gKCBwMyAtIHAxICkgKiAwLjUsIHQyID0gdCAqIHQsIHQzID0gdCAqIHQyO1xuXHRcdFx0cmV0dXJuICggMiAqIHAxIC0gMiAqIHAyICsgdjAgKyB2MSApICogdDMgKyAoIC0gMyAqIHAxICsgMyAqIHAyIC0gMiAqIHYwIC0gdjEgKSAqIHQyICsgdjAgKiB0ICsgcDE7XG5cblx0XHR9XG5cblx0fVxuXG59O1xuXG4vLyBVTUQgKFVuaXZlcnNhbCBNb2R1bGUgRGVmaW5pdGlvbilcbiggZnVuY3Rpb24gKCByb290ICkge1xuXG5cdGlmICggdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICkge1xuXG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKCBbXSwgZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIFRXRUVOO1xuXHRcdH0gKTtcblxuXHR9IGVsc2UgaWYgKCB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgKSB7XG5cblx0XHQvLyBOb2RlLmpzXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBUV0VFTjtcblxuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gR2xvYmFsIHZhcmlhYmxlXG5cdFx0cm9vdC5UV0VFTiA9IFRXRUVOO1xuXG5cdH1cblxufSApKCB0aGlzICk7XG5cbn0se31dLDIzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgX2RlcmVxXz09XCJmdW5jdGlvblwiJiZfZGVyZXFfO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiBfZGVyZXFfPT1cImZ1bmN0aW9uXCImJl9kZXJlcV87Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pKHsxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxNSBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogVGhlIGJhc2UgY2xhc3MgZm9yIGFsbCBWUiBkZXZpY2VzLlxuICovXG5mdW5jdGlvbiBWUkRldmljZSgpIHtcbiAgdGhpcy5oYXJkd2FyZVVuaXRJZCA9ICd3ZWJ2ci1wb2x5ZmlsbCBoYXJkd2FyZVVuaXRJZCc7XG4gIHRoaXMuZGV2aWNlSWQgPSAnd2VidnItcG9seWZpbGwgZGV2aWNlSWQnO1xuICB0aGlzLmRldmljZU5hbWUgPSAnd2VidnItcG9seWZpbGwgZGV2aWNlTmFtZSc7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgY2xhc3MgZm9yIGFsbCBWUiBITUQgZGV2aWNlcy5cbiAqL1xuZnVuY3Rpb24gSE1EVlJEZXZpY2UoKSB7XG59XG5ITURWUkRldmljZS5wcm90b3R5cGUgPSBuZXcgVlJEZXZpY2UoKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBjbGFzcyBmb3IgYWxsIFZSIHBvc2l0aW9uIHNlbnNvciBkZXZpY2VzLlxuICovXG5mdW5jdGlvbiBQb3NpdGlvblNlbnNvclZSRGV2aWNlKCkge1xufVxuUG9zaXRpb25TZW5zb3JWUkRldmljZS5wcm90b3R5cGUgPSBuZXcgVlJEZXZpY2UoKTtcblxubW9kdWxlLmV4cG9ydHMuVlJEZXZpY2UgPSBWUkRldmljZTtcbm1vZHVsZS5leHBvcnRzLkhNRFZSRGV2aWNlID0gSE1EVlJEZXZpY2U7XG5tb2R1bGUuZXhwb3J0cy5Qb3NpdGlvblNlbnNvclZSRGV2aWNlID0gUG9zaXRpb25TZW5zb3JWUkRldmljZTtcblxufSx7fV0sMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKlxuICogQ29weXJpZ2h0IDIwMTUgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIEhNRFZSRGV2aWNlID0gX2RlcmVxXygnLi9iYXNlLmpzJykuSE1EVlJEZXZpY2U7XG5cbi8vIENvbnN0YW50cyBmcm9tIHZydG9vbGtpdDogaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZXNhbXBsZXMvY2FyZGJvYXJkLWphdmEuXG52YXIgSU5URVJQVVBJTExBUllfRElTVEFOQ0UgPSAwLjA2O1xudmFyIERFRkFVTFRfTUFYX0ZPVl9MRUZUX1JJR0hUID0gNDA7XG52YXIgREVGQVVMVF9NQVhfRk9WX0JPVFRPTSA9IDQwO1xudmFyIERFRkFVTFRfTUFYX0ZPVl9UT1AgPSA0MDtcblxuLyoqXG4gKiBUaGUgSE1EIGl0c2VsZiwgcHJvdmlkaW5nIHJlbmRlcmluZyBwYXJhbWV0ZXJzLlxuICovXG5mdW5jdGlvbiBDYXJkYm9hcmRITURWUkRldmljZSgpIHtcbiAgLy8gRnJvbSBjb20vZ29vZ2xlL3ZydG9vbGtpdC9jYXJkYm9hcmQvRmllbGRPZlZpZXcuamF2YS5cbiAgdGhpcy5mb3YgPSB7XG4gICAgdXBEZWdyZWVzOiBERUZBVUxUX01BWF9GT1ZfVE9QLFxuICAgIGRvd25EZWdyZWVzOiBERUZBVUxUX01BWF9GT1ZfQk9UVE9NLFxuICAgIGxlZnREZWdyZWVzOiBERUZBVUxUX01BWF9GT1ZfTEVGVF9SSUdIVCxcbiAgICByaWdodERlZ3JlZXM6IERFRkFVTFRfTUFYX0ZPVl9MRUZUX1JJR0hUXG4gIH07XG4gIC8vIFNldCBkaXNwbGF5IGNvbnN0YW50cy5cbiAgdGhpcy5leWVUcmFuc2xhdGlvbkxlZnQgPSB7XG4gICAgeDogSU5URVJQVVBJTExBUllfRElTVEFOQ0UgKiAtMC41LFxuICAgIHk6IDAsXG4gICAgejogMFxuICB9O1xuICB0aGlzLmV5ZVRyYW5zbGF0aW9uUmlnaHQgPSB7XG4gICAgeDogSU5URVJQVVBJTExBUllfRElTVEFOQ0UgKiAwLjUsXG4gICAgeTogMCxcbiAgICB6OiAwXG4gIH07XG59XG5DYXJkYm9hcmRITURWUkRldmljZS5wcm90b3R5cGUgPSBuZXcgSE1EVlJEZXZpY2UoKTtcblxuQ2FyZGJvYXJkSE1EVlJEZXZpY2UucHJvdG90eXBlLmdldEV5ZVBhcmFtZXRlcnMgPSBmdW5jdGlvbih3aGljaEV5ZSkge1xuICB2YXIgZXllVHJhbnNsYXRpb247XG4gIGlmICh3aGljaEV5ZSA9PSAnbGVmdCcpIHtcbiAgICBleWVUcmFuc2xhdGlvbiA9IHRoaXMuZXllVHJhbnNsYXRpb25MZWZ0O1xuICB9IGVsc2UgaWYgKHdoaWNoRXllID09ICdyaWdodCcpIHtcbiAgICBleWVUcmFuc2xhdGlvbiA9IHRoaXMuZXllVHJhbnNsYXRpb25SaWdodDtcbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlLmVycm9yKCdJbnZhbGlkIGV5ZSBwcm92aWRlZDogJXMnLCB3aGljaEV5ZSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICByZWNvbW1lbmRlZEZpZWxkT2ZWaWV3OiB0aGlzLmZvdixcbiAgICBleWVUcmFuc2xhdGlvbjogZXllVHJhbnNsYXRpb25cbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ2FyZGJvYXJkSE1EVlJEZXZpY2U7XG5cbn0se1wiLi9iYXNlLmpzXCI6MX1dLDM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLypcbiAqIENvcHlyaWdodCAyMDE1IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBUT0RPOiBGaXggdXAgYWxsIFwibmV3IFRIUkVFXCIgaW5zdGFudGlhdGlvbnMgdG8gaW1wcm92ZSBwZXJmb3JtYW5jZS5cbiAqL1xudmFyIFNlbnNvclNhbXBsZSA9IF9kZXJlcV8oJy4vc2Vuc29yLXNhbXBsZS5qcycpO1xudmFyIFRIUkVFID0gX2RlcmVxXygnLi90aHJlZS1tYXRoLmpzJyk7XG52YXIgVXRpbCA9IF9kZXJlcV8oJy4vdXRpbC5qcycpO1xuXG52YXIgREVCVUcgPSBmYWxzZTtcblxuLyoqXG4gKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiBhIHNpbXBsZSBjb21wbGVtZW50YXJ5IGZpbHRlciwgd2hpY2ggZnVzZXMgZ3lyb3Njb3BlIGFuZFxuICogYWNjZWxlcm9tZXRlciBkYXRhIGZyb20gdGhlICdkZXZpY2Vtb3Rpb24nIGV2ZW50LlxuICpcbiAqIEFjY2VsZXJvbWV0ZXIgZGF0YSBpcyB2ZXJ5IG5vaXN5LCBidXQgc3RhYmxlIG92ZXIgdGhlIGxvbmcgdGVybS5cbiAqIEd5cm9zY29wZSBkYXRhIGlzIHNtb290aCwgYnV0IHRlbmRzIHRvIGRyaWZ0IG92ZXIgdGhlIGxvbmcgdGVybS5cbiAqXG4gKiBUaGlzIGZ1c2lvbiBpcyByZWxhdGl2ZWx5IHNpbXBsZTpcbiAqIDEuIEdldCBvcmllbnRhdGlvbiBlc3RpbWF0ZXMgZnJvbSBhY2NlbGVyb21ldGVyIGJ5IGFwcGx5aW5nIGEgbG93LXBhc3MgZmlsdGVyXG4gKiAgICBvbiB0aGF0IGRhdGEuXG4gKiAyLiBHZXQgb3JpZW50YXRpb24gZXN0aW1hdGVzIGZyb20gZ3lyb3Njb3BlIGJ5IGludGVncmF0aW5nIG92ZXIgdGltZS5cbiAqIDMuIENvbWJpbmUgdGhlIHR3byBlc3RpbWF0ZXMsIHdlaWdoaW5nICgxKSBpbiB0aGUgbG9uZyB0ZXJtLCBidXQgKDIpIGZvciB0aGVcbiAqICAgIHNob3J0IHRlcm0uXG4gKi9cbmZ1bmN0aW9uIENvbXBsZW1lbnRhcnlGaWx0ZXIoa0ZpbHRlcikge1xuICB0aGlzLmtGaWx0ZXIgPSBrRmlsdGVyO1xuXG4gIC8vIFJhdyBzZW5zb3IgbWVhc3VyZW1lbnRzLlxuICB0aGlzLmN1cnJlbnRBY2NlbE1lYXN1cmVtZW50ID0gbmV3IFNlbnNvclNhbXBsZSgpO1xuICB0aGlzLmN1cnJlbnRHeXJvTWVhc3VyZW1lbnQgPSBuZXcgU2Vuc29yU2FtcGxlKCk7XG4gIHRoaXMucHJldmlvdXNHeXJvTWVhc3VyZW1lbnQgPSBuZXcgU2Vuc29yU2FtcGxlKCk7XG5cbiAgLy8gQ3VycmVudCBmaWx0ZXIgb3JpZW50YXRpb25cbiAgdGhpcy5maWx0ZXJRID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcbiAgdGhpcy5wcmV2aW91c0ZpbHRlclEgPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xuXG4gIC8vIE9yaWVudGF0aW9uIGJhc2VkIG9uIHRoZSBhY2NlbGVyb21ldGVyLlxuICB0aGlzLmFjY2VsUSA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XG4gIC8vIFdoZXRoZXIgb3Igbm90IHRoZSBvcmllbnRhdGlvbiBoYXMgYmVlbiBpbml0aWFsaXplZC5cbiAgdGhpcy5pc09yaWVudGF0aW9uSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgLy8gUnVubmluZyBlc3RpbWF0ZSBvZiBncmF2aXR5IGJhc2VkIG9uIHRoZSBjdXJyZW50IG9yaWVudGF0aW9uLlxuICB0aGlzLmVzdGltYXRlZEdyYXZpdHkgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAvLyBNZWFzdXJlZCBncmF2aXR5IGJhc2VkIG9uIGFjY2VsZXJvbWV0ZXIuXG4gIHRoaXMubWVhc3VyZWRHcmF2aXR5ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAvLyBEZWJ1ZyBvbmx5IHF1YXRlcm5pb24gb2YgZ3lyby1iYXNlZCBvcmllbnRhdGlvbi5cbiAgdGhpcy5neXJvSW50ZWdyYWxRID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcbn1cblxuQ29tcGxlbWVudGFyeUZpbHRlci5wcm90b3R5cGUuYWRkQWNjZWxNZWFzdXJlbWVudCA9IGZ1bmN0aW9uKHZlY3RvciwgdGltZXN0YW1wUykge1xuICB0aGlzLmN1cnJlbnRBY2NlbE1lYXN1cmVtZW50LnNldCh2ZWN0b3IsIHRpbWVzdGFtcFMpO1xufTtcblxuQ29tcGxlbWVudGFyeUZpbHRlci5wcm90b3R5cGUuYWRkR3lyb01lYXN1cmVtZW50ID0gZnVuY3Rpb24odmVjdG9yLCB0aW1lc3RhbXBTKSB7XG4gIHRoaXMuY3VycmVudEd5cm9NZWFzdXJlbWVudC5zZXQodmVjdG9yLCB0aW1lc3RhbXBTKTtcblxuICB2YXIgZGVsdGFUID0gdGltZXN0YW1wUyAtIHRoaXMucHJldmlvdXNHeXJvTWVhc3VyZW1lbnQudGltZXN0YW1wUztcbiAgaWYgKFV0aWwuaXNUaW1lc3RhbXBEZWx0YVZhbGlkKGRlbHRhVCkpIHtcbiAgICB0aGlzLnJ1bl8oKTtcbiAgfVxuICBcbiAgdGhpcy5wcmV2aW91c0d5cm9NZWFzdXJlbWVudC5jb3B5KHRoaXMuY3VycmVudEd5cm9NZWFzdXJlbWVudCk7XG59O1xuXG5Db21wbGVtZW50YXJ5RmlsdGVyLnByb3RvdHlwZS5ydW5fID0gZnVuY3Rpb24oKSB7XG5cbiAgaWYgKCF0aGlzLmlzT3JpZW50YXRpb25Jbml0aWFsaXplZCkge1xuICAgIHRoaXMuYWNjZWxRID0gdGhpcy5hY2NlbFRvUXVhdGVybmlvbl8odGhpcy5jdXJyZW50QWNjZWxNZWFzdXJlbWVudC5zYW1wbGUpO1xuICAgIHRoaXMucHJldmlvdXNGaWx0ZXJRLmNvcHkodGhpcy5hY2NlbFEpO1xuICAgIHRoaXMuaXNPcmllbnRhdGlvbkluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZGVsdGFUID0gdGhpcy5jdXJyZW50R3lyb01lYXN1cmVtZW50LnRpbWVzdGFtcFMgLVxuICAgICAgdGhpcy5wcmV2aW91c0d5cm9NZWFzdXJlbWVudC50aW1lc3RhbXBTO1xuXG4gIC8vIENvbnZlcnQgZ3lybyByb3RhdGlvbiB2ZWN0b3IgdG8gYSBxdWF0ZXJuaW9uIGRlbHRhLlxuICB2YXIgZ3lyb0RlbHRhUSA9IHRoaXMuZ3lyb1RvUXVhdGVybmlvbkRlbHRhXyh0aGlzLmN1cnJlbnRHeXJvTWVhc3VyZW1lbnQuc2FtcGxlLCBkZWx0YVQpO1xuICB0aGlzLmd5cm9JbnRlZ3JhbFEubXVsdGlwbHkoZ3lyb0RlbHRhUSk7XG5cbiAgLy8gZmlsdGVyXzEgPSBLICogKGZpbHRlcl8wICsgZ3lybyAqIGRUKSArICgxIC0gSykgKiBhY2NlbC5cbiAgdGhpcy5maWx0ZXJRLmNvcHkodGhpcy5wcmV2aW91c0ZpbHRlclEpO1xuICB0aGlzLmZpbHRlclEubXVsdGlwbHkoZ3lyb0RlbHRhUSk7XG5cbiAgLy8gQ2FsY3VsYXRlIHRoZSBkZWx0YSBiZXR3ZWVuIHRoZSBjdXJyZW50IGVzdGltYXRlZCBncmF2aXR5IGFuZCB0aGUgcmVhbFxuICAvLyBncmF2aXR5IHZlY3RvciBmcm9tIGFjY2VsZXJvbWV0ZXIuXG4gIHZhciBpbnZGaWx0ZXJRID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcbiAgaW52RmlsdGVyUS5jb3B5KHRoaXMuZmlsdGVyUSk7XG4gIGludkZpbHRlclEuaW52ZXJzZSgpO1xuXG4gIHRoaXMuZXN0aW1hdGVkR3Jhdml0eS5zZXQoMCwgMCwgLTEpO1xuICB0aGlzLmVzdGltYXRlZEdyYXZpdHkuYXBwbHlRdWF0ZXJuaW9uKGludkZpbHRlclEpO1xuICB0aGlzLmVzdGltYXRlZEdyYXZpdHkubm9ybWFsaXplKCk7XG5cbiAgdGhpcy5tZWFzdXJlZEdyYXZpdHkuY29weSh0aGlzLmN1cnJlbnRBY2NlbE1lYXN1cmVtZW50LnNhbXBsZSk7XG4gIHRoaXMubWVhc3VyZWRHcmF2aXR5Lm5vcm1hbGl6ZSgpO1xuXG4gIC8vIENvbXBhcmUgZXN0aW1hdGVkIGdyYXZpdHkgd2l0aCBtZWFzdXJlZCBncmF2aXR5LCBnZXQgdGhlIGRlbHRhIHF1YXRlcm5pb25cbiAgLy8gYmV0d2VlbiB0aGUgdHdvLlxuICB2YXIgZGVsdGFRID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcbiAgZGVsdGFRLnNldEZyb21Vbml0VmVjdG9ycyh0aGlzLmVzdGltYXRlZEdyYXZpdHksIHRoaXMubWVhc3VyZWRHcmF2aXR5KTtcbiAgZGVsdGFRLmludmVyc2UoKTtcblxuICBpZiAoREVCVUcpIHtcbiAgICBjb25zb2xlLmxvZygnRGVsdGE6ICVkIGRlZywgR19lc3Q6ICglcywgJXMsICVzKSwgR19tZWFzOiAoJXMsICVzLCAlcyknLFxuICAgICAgICAgICAgICAgIFRIUkVFLk1hdGgucmFkVG9EZWcoVXRpbC5nZXRRdWF0ZXJuaW9uQW5nbGUoZGVsdGFRKSksXG4gICAgICAgICAgICAgICAgKHRoaXMuZXN0aW1hdGVkR3Jhdml0eS54KS50b0ZpeGVkKDEpLFxuICAgICAgICAgICAgICAgICh0aGlzLmVzdGltYXRlZEdyYXZpdHkueSkudG9GaXhlZCgxKSxcbiAgICAgICAgICAgICAgICAodGhpcy5lc3RpbWF0ZWRHcmF2aXR5LnopLnRvRml4ZWQoMSksXG4gICAgICAgICAgICAgICAgKHRoaXMubWVhc3VyZWRHcmF2aXR5LngpLnRvRml4ZWQoMSksXG4gICAgICAgICAgICAgICAgKHRoaXMubWVhc3VyZWRHcmF2aXR5LnkpLnRvRml4ZWQoMSksXG4gICAgICAgICAgICAgICAgKHRoaXMubWVhc3VyZWRHcmF2aXR5LnopLnRvRml4ZWQoMSkpO1xuICB9XG5cbiAgLy8gQ2FsY3VsYXRlIHRoZSBTTEVSUCB0YXJnZXQ6IGN1cnJlbnQgb3JpZW50YXRpb24gcGx1cyB0aGUgbWVhc3VyZWQtZXN0aW1hdGVkXG4gIC8vIHF1YXRlcm5pb24gZGVsdGEuXG4gIHZhciB0YXJnZXRRID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcbiAgdGFyZ2V0US5jb3B5KHRoaXMuZmlsdGVyUSk7XG4gIHRhcmdldFEubXVsdGlwbHkoZGVsdGFRKTtcblxuICAvLyBTTEVSUCBmYWN0b3I6IDAgaXMgcHVyZSBneXJvLCAxIGlzIHB1cmUgYWNjZWwuXG4gIHRoaXMuZmlsdGVyUS5zbGVycCh0YXJnZXRRLCAxIC0gdGhpcy5rRmlsdGVyKTtcblxuICB0aGlzLnByZXZpb3VzRmlsdGVyUS5jb3B5KHRoaXMuZmlsdGVyUSk7XG59O1xuXG5Db21wbGVtZW50YXJ5RmlsdGVyLnByb3RvdHlwZS5nZXRPcmllbnRhdGlvbiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5maWx0ZXJRO1xufTtcblxuQ29tcGxlbWVudGFyeUZpbHRlci5wcm90b3R5cGUuYWNjZWxUb1F1YXRlcm5pb25fID0gZnVuY3Rpb24oYWNjZWwpIHtcbiAgdmFyIG5vcm1BY2NlbCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gIG5vcm1BY2NlbC5jb3B5KGFjY2VsKTtcbiAgbm9ybUFjY2VsLm5vcm1hbGl6ZSgpO1xuICB2YXIgcXVhdCA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XG4gIHF1YXQuc2V0RnJvbVVuaXRWZWN0b3JzKG5ldyBUSFJFRS5WZWN0b3IzKDAsIDAsIC0xKSwgbm9ybUFjY2VsKTtcbiAgcXVhdC5pbnZlcnNlKCk7XG4gIHJldHVybiBxdWF0O1xufTtcblxuQ29tcGxlbWVudGFyeUZpbHRlci5wcm90b3R5cGUuZ3lyb1RvUXVhdGVybmlvbkRlbHRhXyA9IGZ1bmN0aW9uKGd5cm8sIGR0KSB7XG4gIC8vIEV4dHJhY3QgYXhpcyBhbmQgYW5nbGUgZnJvbSB0aGUgZ3lyb3Njb3BlIGRhdGEuXG4gIHZhciBxdWF0ID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcbiAgdmFyIGF4aXMgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICBheGlzLmNvcHkoZ3lybyk7XG4gIGF4aXMubm9ybWFsaXplKCk7XG4gIHF1YXQuc2V0RnJvbUF4aXNBbmdsZShheGlzLCBneXJvLmxlbmd0aCgpICogZHQpO1xuICByZXR1cm4gcXVhdDtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBDb21wbGVtZW50YXJ5RmlsdGVyO1xuXG59LHtcIi4vc2Vuc29yLXNhbXBsZS5qc1wiOjgsXCIuL3RocmVlLW1hdGguanNcIjo5LFwiLi91dGlsLmpzXCI6MTF9XSw0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxNSBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgUG9zaXRpb25TZW5zb3JWUkRldmljZSA9IF9kZXJlcV8oJy4vYmFzZS5qcycpLlBvc2l0aW9uU2Vuc29yVlJEZXZpY2U7XG5cbnZhciBDb21wbGVtZW50YXJ5RmlsdGVyID0gX2RlcmVxXygnLi9jb21wbGVtZW50YXJ5LWZpbHRlci5qcycpO1xudmFyIFBvc2VQcmVkaWN0b3IgPSBfZGVyZXFfKCcuL3Bvc2UtcHJlZGljdG9yLmpzJyk7XG52YXIgVG91Y2hQYW5uZXIgPSBfZGVyZXFfKCcuL3RvdWNoLXBhbm5lci5qcycpO1xudmFyIFRIUkVFID0gX2RlcmVxXygnLi90aHJlZS1tYXRoLmpzJyk7XG52YXIgVXRpbCA9IF9kZXJlcV8oJy4vdXRpbC5qcycpO1xuXG4vKipcbiAqIFRoZSBwb3NpdGlvbmFsIHNlbnNvciwgaW1wbGVtZW50ZWQgdXNpbmcgRGV2aWNlTW90aW9uIEFQSXMuXG4gKi9cbmZ1bmN0aW9uIEZ1c2lvblBvc2l0aW9uU2Vuc29yVlJEZXZpY2UoKSB7XG4gIHRoaXMuZGV2aWNlSWQgPSAnd2VidnItcG9seWZpbGw6ZnVzZWQnO1xuICB0aGlzLmRldmljZU5hbWUgPSAnVlIgUG9zaXRpb24gRGV2aWNlICh3ZWJ2ci1wb2x5ZmlsbDpmdXNlZCknO1xuXG4gIHRoaXMuYWNjZWxlcm9tZXRlciA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gIHRoaXMuZ3lyb3Njb3BlID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZGV2aWNlbW90aW9uJywgdGhpcy5vbkRldmljZU1vdGlvbkNoYW5nZV8uYmluZCh0aGlzKSk7XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdvcmllbnRhdGlvbmNoYW5nZScsIHRoaXMub25TY3JlZW5PcmllbnRhdGlvbkNoYW5nZV8uYmluZCh0aGlzKSk7XG5cbiAgdGhpcy5maWx0ZXIgPSBuZXcgQ29tcGxlbWVudGFyeUZpbHRlcihXZWJWUkNvbmZpZy5LX0ZJTFRFUiB8fCAwLjk4KTtcbiAgdGhpcy5wb3NlUHJlZGljdG9yID0gbmV3IFBvc2VQcmVkaWN0b3IoV2ViVlJDb25maWcuUFJFRElDVElPTl9USU1FX1MgfHwgMC4wNDApO1xuICB0aGlzLnRvdWNoUGFubmVyID0gbmV3IFRvdWNoUGFubmVyKCk7XG5cbiAgdGhpcy5maWx0ZXJUb1dvcmxkUSA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XG5cbiAgLy8gU2V0IHRoZSBmaWx0ZXIgdG8gd29ybGQgdHJhbnNmb3JtLCBkZXBlbmRpbmcgb24gT1MuXG4gIGlmIChVdGlsLmlzSU9TKCkpIHtcbiAgICB0aGlzLmZpbHRlclRvV29ybGRRLnNldEZyb21BeGlzQW5nbGUobmV3IFRIUkVFLlZlY3RvcjMoMSwgMCwgMCksIE1hdGguUEkvMik7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5maWx0ZXJUb1dvcmxkUS5zZXRGcm9tQXhpc0FuZ2xlKG5ldyBUSFJFRS5WZWN0b3IzKDEsIDAsIDApLCAtTWF0aC5QSS8yKTtcbiAgfVxuXG4gIHRoaXMud29ybGRUb1NjcmVlblEgPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xuICB0aGlzLnNldFNjcmVlblRyYW5zZm9ybV8oKTtcblxuICAvLyBLZWVwIHRyYWNrIG9mIGEgcmVzZXQgdHJhbnNmb3JtIGZvciByZXNldFNlbnNvci5cbiAgdGhpcy5yZXNldFEgPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xuXG4gIHRoaXMuaXNGaXJlZm94QW5kcm9pZCA9IFV0aWwuaXNGaXJlZm94QW5kcm9pZCgpO1xuICB0aGlzLmlzSU9TID0gVXRpbC5pc0lPUygpO1xufVxuRnVzaW9uUG9zaXRpb25TZW5zb3JWUkRldmljZS5wcm90b3R5cGUgPSBuZXcgUG9zaXRpb25TZW5zb3JWUkRldmljZSgpO1xuXG4vKipcbiAqIFJldHVybnMge29yaWVudGF0aW9uOiB7eCx5LHosd30sIHBvc2l0aW9uOiBudWxsfS5cbiAqIFBvc2l0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgc2luY2Ugd2UgY2FuJ3QgZG8gNkRPRi5cbiAqL1xuRnVzaW9uUG9zaXRpb25TZW5zb3JWUkRldmljZS5wcm90b3R5cGUuZ2V0U3RhdGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICBoYXNPcmllbnRhdGlvbjogdHJ1ZSxcbiAgICBvcmllbnRhdGlvbjogdGhpcy5nZXRPcmllbnRhdGlvbigpLFxuICAgIGhhc1Bvc2l0aW9uOiBmYWxzZSxcbiAgICBwb3NpdGlvbjogbnVsbFxuICB9XG59O1xuXG5GdXNpb25Qb3NpdGlvblNlbnNvclZSRGV2aWNlLnByb3RvdHlwZS5nZXRPcmllbnRhdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAvLyBDb252ZXJ0IGZyb20gZmlsdGVyIHNwYWNlIHRvIHRoZSB0aGUgc2FtZSBzeXN0ZW0gdXNlZCBieSB0aGVcbiAgLy8gZGV2aWNlb3JpZW50YXRpb24gZXZlbnQuXG4gIHZhciBvcmllbnRhdGlvbiA9IHRoaXMuZmlsdGVyLmdldE9yaWVudGF0aW9uKCk7XG5cbiAgLy8gUHJlZGljdCBvcmllbnRhdGlvbi5cbiAgdGhpcy5wcmVkaWN0ZWRRID0gdGhpcy5wb3NlUHJlZGljdG9yLmdldFByZWRpY3Rpb24ob3JpZW50YXRpb24sIHRoaXMuZ3lyb3Njb3BlLCB0aGlzLnByZXZpb3VzVGltZXN0YW1wUyk7XG5cbiAgLy8gQ29udmVydCB0byBUSFJFRSBjb29yZGluYXRlIHN5c3RlbTogLVogZm9yd2FyZCwgWSB1cCwgWCByaWdodC5cbiAgdmFyIG91dCA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XG4gIG91dC5jb3B5KHRoaXMuZmlsdGVyVG9Xb3JsZFEpO1xuICBvdXQubXVsdGlwbHkodGhpcy5yZXNldFEpO1xuICBpZiAoIVdlYlZSQ29uZmlnLlRPVUNIX1BBTk5FUl9ESVNBQkxFRCkge1xuICAgIG91dC5tdWx0aXBseSh0aGlzLnRvdWNoUGFubmVyLmdldE9yaWVudGF0aW9uKCkpO1xuICB9XG4gIG91dC5tdWx0aXBseSh0aGlzLnByZWRpY3RlZFEpO1xuICBvdXQubXVsdGlwbHkodGhpcy53b3JsZFRvU2NyZWVuUSk7XG5cbiAgLy8gSGFuZGxlIHRoZSB5YXctb25seSBjYXNlLlxuICBpZiAoV2ViVlJDb25maWcuWUFXX09OTFkpIHtcbiAgICAvLyBNYWtlIGEgcXVhdGVybmlvbiB0aGF0IG9ubHkgdHVybnMgYXJvdW5kIHRoZSBZLWF4aXMuXG4gICAgb3V0LnggPSAwO1xuICAgIG91dC56ID0gMDtcbiAgICBvdXQubm9ybWFsaXplKCk7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn07XG5cbkZ1c2lvblBvc2l0aW9uU2Vuc29yVlJEZXZpY2UucHJvdG90eXBlLnJlc2V0U2Vuc29yID0gZnVuY3Rpb24oKSB7XG4gIHZhciBldWxlciA9IG5ldyBUSFJFRS5FdWxlcigpO1xuICBldWxlci5zZXRGcm9tUXVhdGVybmlvbih0aGlzLmZpbHRlci5nZXRPcmllbnRhdGlvbigpKTtcbiAgdmFyIHlhdyA9IGV1bGVyLnk7XG4gIGNvbnNvbGUubG9nKCdyZXNldFNlbnNvciB3aXRoIHlhdzogJWYnLCB5YXcpO1xuICB0aGlzLnJlc2V0US5zZXRGcm9tQXhpc0FuZ2xlKG5ldyBUSFJFRS5WZWN0b3IzKDAsIDAsIDEpLCAteWF3KTtcbiAgaWYgKCFXZWJWUkNvbmZpZy5UT1VDSF9QQU5ORVJfRElTQUJMRUQpIHtcbiAgICB0aGlzLnRvdWNoUGFubmVyLnJlc2V0U2Vuc29yKCk7XG4gIH1cbn07XG5cbkZ1c2lvblBvc2l0aW9uU2Vuc29yVlJEZXZpY2UucHJvdG90eXBlLm9uRGV2aWNlTW90aW9uQ2hhbmdlXyA9IGZ1bmN0aW9uKGRldmljZU1vdGlvbikge1xuICB2YXIgYWNjR3Jhdml0eSA9IGRldmljZU1vdGlvbi5hY2NlbGVyYXRpb25JbmNsdWRpbmdHcmF2aXR5O1xuICB2YXIgcm90UmF0ZSA9IGRldmljZU1vdGlvbi5yb3RhdGlvblJhdGU7XG4gIHZhciB0aW1lc3RhbXBTID0gZGV2aWNlTW90aW9uLnRpbWVTdGFtcCAvIDEwMDA7XG5cbiAgLy8gRmlyZWZveCBBbmRyb2lkIHRpbWVTdGFtcCByZXR1cm5zIG9uZSB0aG91c2FuZHRoIG9mIGEgbWlsbGlzZWNvbmQuXG4gIGlmICh0aGlzLmlzRmlyZWZveEFuZHJvaWQpIHtcbiAgICB0aW1lc3RhbXBTIC89IDEwMDA7XG4gIH1cblxuICB2YXIgZGVsdGFTID0gdGltZXN0YW1wUyAtIHRoaXMucHJldmlvdXNUaW1lc3RhbXBTO1xuICBpZiAoZGVsdGFTIDw9IFV0aWwuTUlOX1RJTUVTVEVQIHx8IGRlbHRhUyA+IFV0aWwuTUFYX1RJTUVTVEVQKSB7XG4gICAgY29uc29sZS53YXJuKCdJbnZhbGlkIHRpbWVzdGFtcHMgZGV0ZWN0ZWQuIFRpbWUgc3RlcCBiZXR3ZWVuIHN1Y2Nlc3NpdmUgJyArXG4gICAgICAgICAgICAgICAgICdneXJvc2NvcGUgc2Vuc29yIHNhbXBsZXMgaXMgdmVyeSBzbWFsbCBvciBub3QgbW9ub3RvbmljJyk7XG4gICAgdGhpcy5wcmV2aW91c1RpbWVzdGFtcFMgPSB0aW1lc3RhbXBTO1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLmFjY2VsZXJvbWV0ZXIuc2V0KC1hY2NHcmF2aXR5LngsIC1hY2NHcmF2aXR5LnksIC1hY2NHcmF2aXR5LnopO1xuICB0aGlzLmd5cm9zY29wZS5zZXQocm90UmF0ZS5hbHBoYSwgcm90UmF0ZS5iZXRhLCByb3RSYXRlLmdhbW1hKTtcblxuICAvLyBXaXRoIGlPUyBhbmQgRmlyZWZveCBBbmRyb2lkLCByb3RhdGlvblJhdGUgaXMgcmVwb3J0ZWQgaW4gZGVncmVlcyxcbiAgLy8gc28gd2UgZmlyc3QgY29udmVydCB0byByYWRpYW5zLlxuICBpZiAodGhpcy5pc0lPUyB8fCB0aGlzLmlzRmlyZWZveEFuZHJvaWQpIHtcbiAgICB0aGlzLmd5cm9zY29wZS5tdWx0aXBseVNjYWxhcihNYXRoLlBJIC8gMTgwKTtcbiAgfVxuXG4gIHRoaXMuZmlsdGVyLmFkZEFjY2VsTWVhc3VyZW1lbnQodGhpcy5hY2NlbGVyb21ldGVyLCB0aW1lc3RhbXBTKTtcbiAgdGhpcy5maWx0ZXIuYWRkR3lyb01lYXN1cmVtZW50KHRoaXMuZ3lyb3Njb3BlLCB0aW1lc3RhbXBTKTtcblxuICB0aGlzLnByZXZpb3VzVGltZXN0YW1wUyA9IHRpbWVzdGFtcFM7XG59O1xuXG5GdXNpb25Qb3NpdGlvblNlbnNvclZSRGV2aWNlLnByb3RvdHlwZS5vblNjcmVlbk9yaWVudGF0aW9uQ2hhbmdlXyA9XG4gICAgZnVuY3Rpb24oc2NyZWVuT3JpZW50YXRpb24pIHtcbiAgdGhpcy5zZXRTY3JlZW5UcmFuc2Zvcm1fKCk7XG59O1xuXG5GdXNpb25Qb3NpdGlvblNlbnNvclZSRGV2aWNlLnByb3RvdHlwZS5zZXRTY3JlZW5UcmFuc2Zvcm1fID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMud29ybGRUb1NjcmVlblEuc2V0KDAsIDAsIDAsIDEpO1xuICBzd2l0Y2ggKHdpbmRvdy5vcmllbnRhdGlvbikge1xuICAgIGNhc2UgMDpcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgOTA6XG4gICAgICB0aGlzLndvcmxkVG9TY3JlZW5RLnNldEZyb21BeGlzQW5nbGUobmV3IFRIUkVFLlZlY3RvcjMoMCwgMCwgMSksIC1NYXRoLlBJLzIpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAtOTA6XG4gICAgICB0aGlzLndvcmxkVG9TY3JlZW5RLnNldEZyb21BeGlzQW5nbGUobmV3IFRIUkVFLlZlY3RvcjMoMCwgMCwgMSksIE1hdGguUEkvMik7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDE4MDpcbiAgICAgIC8vIFRPRE8uXG4gICAgICBicmVhaztcbiAgfVxufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEZ1c2lvblBvc2l0aW9uU2Vuc29yVlJEZXZpY2U7XG5cbn0se1wiLi9iYXNlLmpzXCI6MSxcIi4vY29tcGxlbWVudGFyeS1maWx0ZXIuanNcIjozLFwiLi9wb3NlLXByZWRpY3Rvci5qc1wiOjcsXCIuL3RocmVlLW1hdGguanNcIjo5LFwiLi90b3VjaC1wYW5uZXIuanNcIjoxMCxcIi4vdXRpbC5qc1wiOjExfV0sNTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKlxuICogQ29weXJpZ2h0IDIwMTUgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIFdlYlZSUG9seWZpbGwgPSBfZGVyZXFfKCcuL3dlYnZyLXBvbHlmaWxsLmpzJyk7XG5cbi8vIEluaXRpYWxpemUgYSBXZWJWUkNvbmZpZyBqdXN0IGluIGNhc2UuXG53aW5kb3cuV2ViVlJDb25maWcgPSB3aW5kb3cuV2ViVlJDb25maWcgfHwge307XG5uZXcgV2ViVlJQb2x5ZmlsbCgpO1xuXG59LHtcIi4vd2VidnItcG9seWZpbGwuanNcIjoxMn1dLDY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLypcbiAqIENvcHlyaWdodCAyMDE1IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBQb3NpdGlvblNlbnNvclZSRGV2aWNlID0gX2RlcmVxXygnLi9iYXNlLmpzJykuUG9zaXRpb25TZW5zb3JWUkRldmljZTtcbnZhciBUSFJFRSA9IF9kZXJlcV8oJy4vdGhyZWUtbWF0aC5qcycpO1xudmFyIFV0aWwgPSBfZGVyZXFfKCcuL3V0aWwuanMnKTtcblxuLy8gSG93IG11Y2ggdG8gcm90YXRlIHBlciBrZXkgc3Ryb2tlLlxudmFyIEtFWV9TUEVFRCA9IDAuMTU7XG52YXIgS0VZX0FOSU1BVElPTl9EVVJBVElPTiA9IDgwO1xuXG4vLyBIb3cgbXVjaCB0byByb3RhdGUgZm9yIG1vdXNlIGV2ZW50cy5cbnZhciBNT1VTRV9TUEVFRF9YID0gMC41O1xudmFyIE1PVVNFX1NQRUVEX1kgPSAwLjM7XG5cbi8qKlxuICogQSB2aXJ0dWFsIHBvc2l0aW9uIHNlbnNvciwgaW1wbGVtZW50ZWQgdXNpbmcga2V5Ym9hcmQgYW5kXG4gKiBtb3VzZSBBUElzLiBUaGlzIGlzIGRlc2lnbmVkIGFzIGZvciBkZXNrdG9wcy9sYXB0b3BzIHdoZXJlIG5vIERldmljZSpcbiAqIGV2ZW50cyB3b3JrLlxuICovXG5mdW5jdGlvbiBNb3VzZUtleWJvYXJkUG9zaXRpb25TZW5zb3JWUkRldmljZSgpIHtcbiAgdGhpcy5kZXZpY2VJZCA9ICd3ZWJ2ci1wb2x5ZmlsbDptb3VzZS1rZXlib2FyZCc7XG4gIHRoaXMuZGV2aWNlTmFtZSA9ICdWUiBQb3NpdGlvbiBEZXZpY2UgKHdlYnZyLXBvbHlmaWxsOm1vdXNlLWtleWJvYXJkKSc7XG5cbiAgLy8gQXR0YWNoIHRvIG1vdXNlIGFuZCBrZXlib2FyZCBldmVudHMuXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5vbktleURvd25fLmJpbmQodGhpcykpO1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5vbk1vdXNlTW92ZV8uYmluZCh0aGlzKSk7XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm9uTW91c2VEb3duXy5iaW5kKHRoaXMpKTtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uTW91c2VVcF8uYmluZCh0aGlzKSk7XG5cbiAgdGhpcy5waGkgPSAwO1xuICB0aGlzLnRoZXRhID0gMDtcblxuICAvLyBWYXJpYWJsZXMgZm9yIGtleWJvYXJkLWJhc2VkIHJvdGF0aW9uIGFuaW1hdGlvbi5cbiAgdGhpcy50YXJnZXRBbmdsZSA9IG51bGw7XG5cbiAgLy8gU3RhdGUgdmFyaWFibGVzIGZvciBjYWxjdWxhdGlvbnMuXG4gIHRoaXMuZXVsZXIgPSBuZXcgVEhSRUUuRXVsZXIoKTtcbiAgdGhpcy5vcmllbnRhdGlvbiA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XG5cbiAgLy8gVmFyaWFibGVzIGZvciBtb3VzZS1iYXNlZCByb3RhdGlvbi5cbiAgdGhpcy5yb3RhdGVTdGFydCA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG4gIHRoaXMucm90YXRlRW5kID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcbiAgdGhpcy5yb3RhdGVEZWx0YSA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG59XG5Nb3VzZUtleWJvYXJkUG9zaXRpb25TZW5zb3JWUkRldmljZS5wcm90b3R5cGUgPSBuZXcgUG9zaXRpb25TZW5zb3JWUkRldmljZSgpO1xuXG4vKipcbiAqIFJldHVybnMge29yaWVudGF0aW9uOiB7eCx5LHosd30sIHBvc2l0aW9uOiBudWxsfS5cbiAqIFBvc2l0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIHBhcml0eSB3aXRoIG90aGVyIFBvc2l0aW9uU2Vuc29ycy5cbiAqL1xuTW91c2VLZXlib2FyZFBvc2l0aW9uU2Vuc29yVlJEZXZpY2UucHJvdG90eXBlLmdldFN0YXRlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZXVsZXIuc2V0KHRoaXMucGhpLCB0aGlzLnRoZXRhLCAwLCAnWVhaJyk7XG4gIHRoaXMub3JpZW50YXRpb24uc2V0RnJvbUV1bGVyKHRoaXMuZXVsZXIpO1xuXG4gIHJldHVybiB7XG4gICAgaGFzT3JpZW50YXRpb246IHRydWUsXG4gICAgb3JpZW50YXRpb246IHRoaXMub3JpZW50YXRpb24sXG4gICAgaGFzUG9zaXRpb246IGZhbHNlLFxuICAgIHBvc2l0aW9uOiBudWxsXG4gIH1cbn07XG5cbk1vdXNlS2V5Ym9hcmRQb3NpdGlvblNlbnNvclZSRGV2aWNlLnByb3RvdHlwZS5vbktleURvd25fID0gZnVuY3Rpb24oZSkge1xuICAvLyBUcmFjayBXQVNEIGFuZCBhcnJvdyBrZXlzLlxuICBpZiAoZS5rZXlDb2RlID09IDM4KSB7IC8vIFVwIGtleS5cbiAgICB0aGlzLmFuaW1hdGVQaGlfKHRoaXMucGhpICsgS0VZX1NQRUVEKTtcbiAgfSBlbHNlIGlmIChlLmtleUNvZGUgPT0gMzkpIHsgLy8gUmlnaHQga2V5LlxuICAgIHRoaXMuYW5pbWF0ZVRoZXRhXyh0aGlzLnRoZXRhIC0gS0VZX1NQRUVEKTtcbiAgfSBlbHNlIGlmIChlLmtleUNvZGUgPT0gNDApIHsgLy8gRG93biBrZXkuXG4gICAgdGhpcy5hbmltYXRlUGhpXyh0aGlzLnBoaSAtIEtFWV9TUEVFRCk7XG4gIH0gZWxzZSBpZiAoZS5rZXlDb2RlID09IDM3KSB7IC8vIExlZnQga2V5LlxuICAgIHRoaXMuYW5pbWF0ZVRoZXRhXyh0aGlzLnRoZXRhICsgS0VZX1NQRUVEKTtcbiAgfVxufTtcblxuTW91c2VLZXlib2FyZFBvc2l0aW9uU2Vuc29yVlJEZXZpY2UucHJvdG90eXBlLmFuaW1hdGVUaGV0YV8gPSBmdW5jdGlvbih0YXJnZXRBbmdsZSkge1xuICB0aGlzLmFuaW1hdGVLZXlUcmFuc2l0aW9uc18oJ3RoZXRhJywgdGFyZ2V0QW5nbGUpO1xufTtcblxuTW91c2VLZXlib2FyZFBvc2l0aW9uU2Vuc29yVlJEZXZpY2UucHJvdG90eXBlLmFuaW1hdGVQaGlfID0gZnVuY3Rpb24odGFyZ2V0QW5nbGUpIHtcbiAgLy8gUHJldmVudCBsb29raW5nIHRvbyBmYXIgdXAgb3IgZG93bi5cbiAgdGFyZ2V0QW5nbGUgPSBVdGlsLmNsYW1wKHRhcmdldEFuZ2xlLCAtTWF0aC5QSS8yLCBNYXRoLlBJLzIpO1xuICB0aGlzLmFuaW1hdGVLZXlUcmFuc2l0aW9uc18oJ3BoaScsIHRhcmdldEFuZ2xlKTtcbn07XG5cbi8qKlxuICogU3RhcnQgYW4gYW5pbWF0aW9uIHRvIHRyYW5zaXRpb24gYW4gYW5nbGUgZnJvbSBvbmUgdmFsdWUgdG8gYW5vdGhlci5cbiAqL1xuTW91c2VLZXlib2FyZFBvc2l0aW9uU2Vuc29yVlJEZXZpY2UucHJvdG90eXBlLmFuaW1hdGVLZXlUcmFuc2l0aW9uc18gPSBmdW5jdGlvbihhbmdsZU5hbWUsIHRhcmdldEFuZ2xlKSB7XG4gIC8vIElmIGFuIGFuaW1hdGlvbiBpcyBjdXJyZW50bHkgcnVubmluZywgY2FuY2VsIGl0LlxuICBpZiAodGhpcy5hbmdsZUFuaW1hdGlvbikge1xuICAgIGNsZWFySW50ZXJ2YWwodGhpcy5hbmdsZUFuaW1hdGlvbik7XG4gIH1cbiAgdmFyIHN0YXJ0QW5nbGUgPSB0aGlzW2FuZ2xlTmFtZV07XG4gIHZhciBzdGFydFRpbWUgPSBuZXcgRGF0ZSgpO1xuICAvLyBTZXQgdXAgYW4gaW50ZXJ2YWwgdGltZXIgdG8gcGVyZm9ybSB0aGUgYW5pbWF0aW9uLlxuICB0aGlzLmFuZ2xlQW5pbWF0aW9uID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG4gICAgLy8gT25jZSB3ZSdyZSBmaW5pc2hlZCB0aGUgYW5pbWF0aW9uLCB3ZSdyZSBkb25lLlxuICAgIHZhciBlbGFwc2VkID0gbmV3IERhdGUoKSAtIHN0YXJ0VGltZTtcbiAgICBpZiAoZWxhcHNlZCA+PSBLRVlfQU5JTUFUSU9OX0RVUkFUSU9OKSB7XG4gICAgICB0aGlzW2FuZ2xlTmFtZV0gPSB0YXJnZXRBbmdsZTtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5hbmdsZUFuaW1hdGlvbik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIExpbmVhcmx5IGludGVycG9sYXRlIHRoZSBhbmdsZSBzb21lIGFtb3VudC5cbiAgICB2YXIgcGVyY2VudCA9IGVsYXBzZWQgLyBLRVlfQU5JTUFUSU9OX0RVUkFUSU9OO1xuICAgIHRoaXNbYW5nbGVOYW1lXSA9IHN0YXJ0QW5nbGUgKyAodGFyZ2V0QW5nbGUgLSBzdGFydEFuZ2xlKSAqIHBlcmNlbnQ7XG4gIH0uYmluZCh0aGlzKSwgMTAwMC82MCk7XG59O1xuXG5Nb3VzZUtleWJvYXJkUG9zaXRpb25TZW5zb3JWUkRldmljZS5wcm90b3R5cGUub25Nb3VzZURvd25fID0gZnVuY3Rpb24oZSkge1xuICB0aGlzLnJvdGF0ZVN0YXJ0LnNldChlLmNsaWVudFgsIGUuY2xpZW50WSk7XG4gIHRoaXMuaXNEcmFnZ2luZyA9IHRydWU7XG59O1xuXG4vLyBWZXJ5IHNpbWlsYXIgdG8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vbXJmbGl4LzgzNTEwMjBcbk1vdXNlS2V5Ym9hcmRQb3NpdGlvblNlbnNvclZSRGV2aWNlLnByb3RvdHlwZS5vbk1vdXNlTW92ZV8gPSBmdW5jdGlvbihlKSB7XG4gIGlmICghdGhpcy5pc0RyYWdnaW5nICYmICF0aGlzLmlzUG9pbnRlckxvY2tlZF8oKSkge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBTdXBwb3J0IHBvaW50ZXIgbG9jayBBUEkuXG4gIGlmICh0aGlzLmlzUG9pbnRlckxvY2tlZF8oKSkge1xuICAgIHZhciBtb3ZlbWVudFggPSBlLm1vdmVtZW50WCB8fCBlLm1vek1vdmVtZW50WCB8fCAwO1xuICAgIHZhciBtb3ZlbWVudFkgPSBlLm1vdmVtZW50WSB8fCBlLm1vek1vdmVtZW50WSB8fCAwO1xuICAgIHRoaXMucm90YXRlRW5kLnNldCh0aGlzLnJvdGF0ZVN0YXJ0LnggLSBtb3ZlbWVudFgsIHRoaXMucm90YXRlU3RhcnQueSAtIG1vdmVtZW50WSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5yb3RhdGVFbmQuc2V0KGUuY2xpZW50WCwgZS5jbGllbnRZKTtcbiAgfVxuICAvLyBDYWxjdWxhdGUgaG93IG11Y2ggd2UgbW92ZWQgaW4gbW91c2Ugc3BhY2UuXG4gIHRoaXMucm90YXRlRGVsdGEuc3ViVmVjdG9ycyh0aGlzLnJvdGF0ZUVuZCwgdGhpcy5yb3RhdGVTdGFydCk7XG4gIHRoaXMucm90YXRlU3RhcnQuY29weSh0aGlzLnJvdGF0ZUVuZCk7XG5cbiAgLy8gS2VlcCB0cmFjayBvZiB0aGUgY3VtdWxhdGl2ZSBldWxlciBhbmdsZXMuXG4gIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuYm9keTtcbiAgdGhpcy5waGkgKz0gMiAqIE1hdGguUEkgKiB0aGlzLnJvdGF0ZURlbHRhLnkgLyBlbGVtZW50LmNsaWVudEhlaWdodCAqIE1PVVNFX1NQRUVEX1k7XG4gIHRoaXMudGhldGEgKz0gMiAqIE1hdGguUEkgKiB0aGlzLnJvdGF0ZURlbHRhLnggLyBlbGVtZW50LmNsaWVudFdpZHRoICogTU9VU0VfU1BFRURfWDtcblxuICAvLyBQcmV2ZW50IGxvb2tpbmcgdG9vIGZhciB1cCBvciBkb3duLlxuICB0aGlzLnBoaSA9IFV0aWwuY2xhbXAodGhpcy5waGksIC1NYXRoLlBJLzIsIE1hdGguUEkvMik7XG59O1xuXG5Nb3VzZUtleWJvYXJkUG9zaXRpb25TZW5zb3JWUkRldmljZS5wcm90b3R5cGUub25Nb3VzZVVwXyA9IGZ1bmN0aW9uKGUpIHtcbiAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7XG59O1xuXG5Nb3VzZUtleWJvYXJkUG9zaXRpb25TZW5zb3JWUkRldmljZS5wcm90b3R5cGUuaXNQb2ludGVyTG9ja2VkXyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZWwgPSBkb2N1bWVudC5wb2ludGVyTG9ja0VsZW1lbnQgfHwgZG9jdW1lbnQubW96UG9pbnRlckxvY2tFbGVtZW50IHx8XG4gICAgICBkb2N1bWVudC53ZWJraXRQb2ludGVyTG9ja0VsZW1lbnQ7XG4gIHJldHVybiBlbCAhPT0gdW5kZWZpbmVkO1xufTtcblxuTW91c2VLZXlib2FyZFBvc2l0aW9uU2Vuc29yVlJEZXZpY2UucHJvdG90eXBlLnJlc2V0U2Vuc29yID0gZnVuY3Rpb24oKSB7XG4gIGNvbnNvbGUuZXJyb3IoJ05vdCBpbXBsZW1lbnRlZCB5ZXQuJyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1vdXNlS2V5Ym9hcmRQb3NpdGlvblNlbnNvclZSRGV2aWNlO1xuXG59LHtcIi4vYmFzZS5qc1wiOjEsXCIuL3RocmVlLW1hdGguanNcIjo5LFwiLi91dGlsLmpzXCI6MTF9XSw3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxNSBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgVEhSRUUgPSBfZGVyZXFfKCcuL3RocmVlLW1hdGguanMnKTtcblxudmFyIERFQlVHID0gZmFsc2U7XG5cbi8qKlxuICogR2l2ZW4gYW4gb3JpZW50YXRpb24gYW5kIHRoZSBneXJvc2NvcGUgZGF0YSwgcHJlZGljdHMgdGhlIGZ1dHVyZSBvcmllbnRhdGlvblxuICogb2YgdGhlIGhlYWQuIFRoaXMgbWFrZXMgcmVuZGVyaW5nIGFwcGVhciBmYXN0ZXIuXG4gKlxuICogQWxzbyBzZWU6IGh0dHA6Ly9tc2wuY3MudWl1Yy5lZHUvfmxhdmFsbGUvcGFwZXJzL0xhdlllckthdEFudDE0LnBkZlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBwcmVkaWN0aW9uVGltZVMgdGltZSBmcm9tIGhlYWQgbW92ZW1lbnQgdG8gdGhlIGFwcGVhcmFuY2Ugb2ZcbiAqIHRoZSBjb3JyZXNwb25kaW5nIGltYWdlLlxuICovXG5mdW5jdGlvbiBQb3NlUHJlZGljdG9yKHByZWRpY3Rpb25UaW1lUykge1xuICB0aGlzLnByZWRpY3Rpb25UaW1lUyA9IHByZWRpY3Rpb25UaW1lUztcblxuICAvLyBUaGUgcXVhdGVybmlvbiBjb3JyZXNwb25kaW5nIHRvIHRoZSBwcmV2aW91cyBzdGF0ZS5cbiAgdGhpcy5wcmV2aW91c1EgPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xuICAvLyBQcmV2aW91cyB0aW1lIGEgcHJlZGljdGlvbiBvY2N1cnJlZC5cbiAgdGhpcy5wcmV2aW91c1RpbWVzdGFtcFMgPSBudWxsO1xuXG4gIC8vIFRoZSBkZWx0YSBxdWF0ZXJuaW9uIHRoYXQgYWRqdXN0cyB0aGUgY3VycmVudCBwb3NlLlxuICB0aGlzLmRlbHRhUSA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XG4gIC8vIFRoZSBvdXRwdXQgcXVhdGVybmlvbi5cbiAgdGhpcy5vdXRRID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcbn1cblxuUG9zZVByZWRpY3Rvci5wcm90b3R5cGUuZ2V0UHJlZGljdGlvbiA9IGZ1bmN0aW9uKGN1cnJlbnRRLCBneXJvLCB0aW1lc3RhbXBTKSB7XG4gIGlmICghdGhpcy5wcmV2aW91c1RpbWVzdGFtcFMpIHtcbiAgICB0aGlzLnByZXZpb3VzUS5jb3B5KGN1cnJlbnRRKTtcbiAgICB0aGlzLnByZXZpb3VzVGltZXN0YW1wUyA9IHRpbWVzdGFtcFM7XG4gICAgcmV0dXJuIGN1cnJlbnRRO1xuICB9XG5cbiAgLy8gQ2FsY3VsYXRlIGF4aXMgYW5kIGFuZ2xlIGJhc2VkIG9uIGd5cm9zY29wZSByb3RhdGlvbiByYXRlIGRhdGEuXG4gIHZhciBheGlzID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgYXhpcy5jb3B5KGd5cm8pO1xuICBheGlzLm5vcm1hbGl6ZSgpO1xuXG4gIHZhciBhbmd1bGFyU3BlZWQgPSBneXJvLmxlbmd0aCgpO1xuXG4gIC8vIElmIHdlJ3JlIHJvdGF0aW5nIHNsb3dseSwgZG9uJ3QgZG8gcHJlZGljdGlvbi5cbiAgaWYgKGFuZ3VsYXJTcGVlZCA8IFRIUkVFLk1hdGguZGVnVG9SYWQoMjApKSB7XG4gICAgaWYgKERFQlVHKSB7XG4gICAgICBjb25zb2xlLmxvZygnTW92aW5nIHNsb3dseSwgYXQgJXMgZGVnL3M6IG5vIHByZWRpY3Rpb24nLFxuICAgICAgICAgICAgICAgICAgVEhSRUUuTWF0aC5yYWRUb0RlZyhhbmd1bGFyU3BlZWQpLnRvRml4ZWQoMSkpO1xuICAgIH1cbiAgICB0aGlzLm91dFEuY29weShjdXJyZW50USk7XG4gICAgdGhpcy5wcmV2aW91c1EuY29weShjdXJyZW50USk7XG4gICAgcmV0dXJuIHRoaXMub3V0UTtcbiAgfVxuXG4gIC8vIEdldCB0aGUgcHJlZGljdGVkIGFuZ2xlIGJhc2VkIG9uIHRoZSB0aW1lIGRlbHRhIGFuZCBsYXRlbmN5LlxuICB2YXIgZGVsdGFUID0gdGltZXN0YW1wUyAtIHRoaXMucHJldmlvdXNUaW1lc3RhbXBTO1xuICB2YXIgcHJlZGljdEFuZ2xlID0gYW5ndWxhclNwZWVkICogdGhpcy5wcmVkaWN0aW9uVGltZVM7XG5cbiAgdGhpcy5kZWx0YVEuc2V0RnJvbUF4aXNBbmdsZShheGlzLCBwcmVkaWN0QW5nbGUpO1xuICB0aGlzLm91dFEuY29weSh0aGlzLnByZXZpb3VzUSk7XG4gIHRoaXMub3V0US5tdWx0aXBseSh0aGlzLmRlbHRhUSk7XG5cbiAgdGhpcy5wcmV2aW91c1EuY29weShjdXJyZW50USk7XG5cbiAgcmV0dXJuIHRoaXMub3V0UTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBQb3NlUHJlZGljdG9yO1xuXG59LHtcIi4vdGhyZWUtbWF0aC5qc1wiOjl9XSw4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbmZ1bmN0aW9uIFNlbnNvclNhbXBsZShzYW1wbGUsIHRpbWVzdGFtcFMpIHtcbiAgdGhpcy5zZXQoc2FtcGxlLCB0aW1lc3RhbXBTKTtcbn07XG5cblNlbnNvclNhbXBsZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oc2FtcGxlLCB0aW1lc3RhbXBTKSB7XG4gIHRoaXMuc2FtcGxlID0gc2FtcGxlO1xuICB0aGlzLnRpbWVzdGFtcFMgPSB0aW1lc3RhbXBTO1xufTtcblxuU2Vuc29yU2FtcGxlLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24oc2Vuc29yU2FtcGxlKSB7XG4gIHRoaXMuc2V0KHNlbnNvclNhbXBsZS5zYW1wbGUsIHNlbnNvclNhbXBsZS50aW1lc3RhbXBTKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2Vuc29yU2FtcGxlO1xuXG59LHt9XSw5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qXG4gKiBBIHN1YnNldCBvZiBUSFJFRS5qcywgcHJvdmlkaW5nIG1vc3RseSBxdWF0ZXJuaW9uIGFuZCBldWxlci1yZWxhdGVkXG4gKiBvcGVyYXRpb25zLCBtYW51YWxseSBsaWZ0ZWQgZnJvbVxuICogaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy90cmVlL21hc3Rlci9zcmMvbWF0aCwgYXMgb2YgOWMzMDI4NmIzOGRmMDM5ZmNhMzg5OTg5ZmYwNmVhMWMxNWQ2YmFkMVxuICovXG5cbi8vIE9ubHkgdXNlIGlmIHRoZSByZWFsIFRIUkVFIGlzIG5vdCBwcm92aWRlZC5cbnZhciBUSFJFRSA9IHdpbmRvdy5USFJFRSB8fCB7fTtcblxuLy8gSWYgc29tZSBwaWVjZSBvZiBUSFJFRSBpcyBtaXNzaW5nLCBmaWxsIGl0IGluIGhlcmUuXG5pZiAoIVRIUkVFLlF1YXRlcm5pb24gfHwgIVRIUkVFLlZlY3RvcjMgfHwgIVRIUkVFLlZlY3RvcjIgfHwgIVRIUkVFLkV1bGVyIHx8ICFUSFJFRS5NYXRoKSB7XG5jb25zb2xlLmxvZygnTm8gVEhSRUUuanMgZm91bmQuJyk7XG5cblxuLyoqKiBTVEFSVCBRdWF0ZXJuaW9uICoqKi9cblxuLyoqXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9leG9jb3J0ZXguY29tXG4gKi9cblxuVEhSRUUuUXVhdGVybmlvbiA9IGZ1bmN0aW9uICggeCwgeSwgeiwgdyApIHtcblxuXHR0aGlzLl94ID0geCB8fCAwO1xuXHR0aGlzLl95ID0geSB8fCAwO1xuXHR0aGlzLl96ID0geiB8fCAwO1xuXHR0aGlzLl93ID0gKCB3ICE9PSB1bmRlZmluZWQgKSA/IHcgOiAxO1xuXG59O1xuXG5USFJFRS5RdWF0ZXJuaW9uLnByb3RvdHlwZSA9IHtcblxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuUXVhdGVybmlvbixcblxuXHRfeDogMCxfeTogMCwgX3o6IDAsIF93OiAwLFxuXG5cdGdldCB4ICgpIHtcblxuXHRcdHJldHVybiB0aGlzLl94O1xuXG5cdH0sXG5cblx0c2V0IHggKCB2YWx1ZSApIHtcblxuXHRcdHRoaXMuX3ggPSB2YWx1ZTtcblx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHR9LFxuXG5cdGdldCB5ICgpIHtcblxuXHRcdHJldHVybiB0aGlzLl95O1xuXG5cdH0sXG5cblx0c2V0IHkgKCB2YWx1ZSApIHtcblxuXHRcdHRoaXMuX3kgPSB2YWx1ZTtcblx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHR9LFxuXG5cdGdldCB6ICgpIHtcblxuXHRcdHJldHVybiB0aGlzLl96O1xuXG5cdH0sXG5cblx0c2V0IHogKCB2YWx1ZSApIHtcblxuXHRcdHRoaXMuX3ogPSB2YWx1ZTtcblx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHR9LFxuXG5cdGdldCB3ICgpIHtcblxuXHRcdHJldHVybiB0aGlzLl93O1xuXG5cdH0sXG5cblx0c2V0IHcgKCB2YWx1ZSApIHtcblxuXHRcdHRoaXMuX3cgPSB2YWx1ZTtcblx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHR9LFxuXG5cdHNldDogZnVuY3Rpb24gKCB4LCB5LCB6LCB3ICkge1xuXG5cdFx0dGhpcy5feCA9IHg7XG5cdFx0dGhpcy5feSA9IHk7XG5cdFx0dGhpcy5feiA9IHo7XG5cdFx0dGhpcy5fdyA9IHc7XG5cblx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Y29weTogZnVuY3Rpb24gKCBxdWF0ZXJuaW9uICkge1xuXG5cdFx0dGhpcy5feCA9IHF1YXRlcm5pb24ueDtcblx0XHR0aGlzLl95ID0gcXVhdGVybmlvbi55O1xuXHRcdHRoaXMuX3ogPSBxdWF0ZXJuaW9uLno7XG5cdFx0dGhpcy5fdyA9IHF1YXRlcm5pb24udztcblxuXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXRGcm9tRXVsZXI6IGZ1bmN0aW9uICggZXVsZXIsIHVwZGF0ZSApIHtcblxuXHRcdGlmICggZXVsZXIgaW5zdGFuY2VvZiBUSFJFRS5FdWxlciA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RIUkVFLlF1YXRlcm5pb246IC5zZXRGcm9tRXVsZXIoKSBub3cgZXhwZWN0cyBhIEV1bGVyIHJvdGF0aW9uIHJhdGhlciB0aGFuIGEgVmVjdG9yMyBhbmQgb3JkZXIuJyApO1xuXHRcdH1cblxuXHRcdC8vIGh0dHA6Ly93d3cubWF0aHdvcmtzLmNvbS9tYXRsYWJjZW50cmFsL2ZpbGVleGNoYW5nZS9cblx0XHQvLyBcdDIwNjk2LWZ1bmN0aW9uLXRvLWNvbnZlcnQtYmV0d2Vlbi1kY20tZXVsZXItYW5nbGVzLXF1YXRlcm5pb25zLWFuZC1ldWxlci12ZWN0b3JzL1xuXHRcdC8vXHRjb250ZW50L1NwaW5DYWxjLm1cblxuXHRcdHZhciBjMSA9IE1hdGguY29zKCBldWxlci5feCAvIDIgKTtcblx0XHR2YXIgYzIgPSBNYXRoLmNvcyggZXVsZXIuX3kgLyAyICk7XG5cdFx0dmFyIGMzID0gTWF0aC5jb3MoIGV1bGVyLl96IC8gMiApO1xuXHRcdHZhciBzMSA9IE1hdGguc2luKCBldWxlci5feCAvIDIgKTtcblx0XHR2YXIgczIgPSBNYXRoLnNpbiggZXVsZXIuX3kgLyAyICk7XG5cdFx0dmFyIHMzID0gTWF0aC5zaW4oIGV1bGVyLl96IC8gMiApO1xuXG5cdFx0aWYgKCBldWxlci5vcmRlciA9PT0gJ1hZWicgKSB7XG5cblx0XHRcdHRoaXMuX3ggPSBzMSAqIGMyICogYzMgKyBjMSAqIHMyICogczM7XG5cdFx0XHR0aGlzLl95ID0gYzEgKiBzMiAqIGMzIC0gczEgKiBjMiAqIHMzO1xuXHRcdFx0dGhpcy5feiA9IGMxICogYzIgKiBzMyArIHMxICogczIgKiBjMztcblx0XHRcdHRoaXMuX3cgPSBjMSAqIGMyICogYzMgLSBzMSAqIHMyICogczM7XG5cblx0XHR9IGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1lYWicgKSB7XG5cblx0XHRcdHRoaXMuX3ggPSBzMSAqIGMyICogYzMgKyBjMSAqIHMyICogczM7XG5cdFx0XHR0aGlzLl95ID0gYzEgKiBzMiAqIGMzIC0gczEgKiBjMiAqIHMzO1xuXHRcdFx0dGhpcy5feiA9IGMxICogYzIgKiBzMyAtIHMxICogczIgKiBjMztcblx0XHRcdHRoaXMuX3cgPSBjMSAqIGMyICogYzMgKyBzMSAqIHMyICogczM7XG5cblx0XHR9IGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1pYWScgKSB7XG5cblx0XHRcdHRoaXMuX3ggPSBzMSAqIGMyICogYzMgLSBjMSAqIHMyICogczM7XG5cdFx0XHR0aGlzLl95ID0gYzEgKiBzMiAqIGMzICsgczEgKiBjMiAqIHMzO1xuXHRcdFx0dGhpcy5feiA9IGMxICogYzIgKiBzMyArIHMxICogczIgKiBjMztcblx0XHRcdHRoaXMuX3cgPSBjMSAqIGMyICogYzMgLSBzMSAqIHMyICogczM7XG5cblx0XHR9IGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1pZWCcgKSB7XG5cblx0XHRcdHRoaXMuX3ggPSBzMSAqIGMyICogYzMgLSBjMSAqIHMyICogczM7XG5cdFx0XHR0aGlzLl95ID0gYzEgKiBzMiAqIGMzICsgczEgKiBjMiAqIHMzO1xuXHRcdFx0dGhpcy5feiA9IGMxICogYzIgKiBzMyAtIHMxICogczIgKiBjMztcblx0XHRcdHRoaXMuX3cgPSBjMSAqIGMyICogYzMgKyBzMSAqIHMyICogczM7XG5cblx0XHR9IGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1laWCcgKSB7XG5cblx0XHRcdHRoaXMuX3ggPSBzMSAqIGMyICogYzMgKyBjMSAqIHMyICogczM7XG5cdFx0XHR0aGlzLl95ID0gYzEgKiBzMiAqIGMzICsgczEgKiBjMiAqIHMzO1xuXHRcdFx0dGhpcy5feiA9IGMxICogYzIgKiBzMyAtIHMxICogczIgKiBjMztcblx0XHRcdHRoaXMuX3cgPSBjMSAqIGMyICogYzMgLSBzMSAqIHMyICogczM7XG5cblx0XHR9IGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1haWScgKSB7XG5cblx0XHRcdHRoaXMuX3ggPSBzMSAqIGMyICogYzMgLSBjMSAqIHMyICogczM7XG5cdFx0XHR0aGlzLl95ID0gYzEgKiBzMiAqIGMzIC0gczEgKiBjMiAqIHMzO1xuXHRcdFx0dGhpcy5feiA9IGMxICogYzIgKiBzMyArIHMxICogczIgKiBjMztcblx0XHRcdHRoaXMuX3cgPSBjMSAqIGMyICogYzMgKyBzMSAqIHMyICogczM7XG5cblx0XHR9XG5cblx0XHRpZiAoIHVwZGF0ZSAhPT0gZmFsc2UgKSB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0RnJvbUF4aXNBbmdsZTogZnVuY3Rpb24gKCBheGlzLCBhbmdsZSApIHtcblxuXHRcdC8vIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2dlb21ldHJ5L3JvdGF0aW9ucy9jb252ZXJzaW9ucy9hbmdsZVRvUXVhdGVybmlvbi9pbmRleC5odG1cblxuXHRcdC8vIGFzc3VtZXMgYXhpcyBpcyBub3JtYWxpemVkXG5cblx0XHR2YXIgaGFsZkFuZ2xlID0gYW5nbGUgLyAyLCBzID0gTWF0aC5zaW4oIGhhbGZBbmdsZSApO1xuXG5cdFx0dGhpcy5feCA9IGF4aXMueCAqIHM7XG5cdFx0dGhpcy5feSA9IGF4aXMueSAqIHM7XG5cdFx0dGhpcy5feiA9IGF4aXMueiAqIHM7XG5cdFx0dGhpcy5fdyA9IE1hdGguY29zKCBoYWxmQW5nbGUgKTtcblxuXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXRGcm9tUm90YXRpb25NYXRyaXg6IGZ1bmN0aW9uICggbSApIHtcblxuXHRcdC8vIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2dlb21ldHJ5L3JvdGF0aW9ucy9jb252ZXJzaW9ucy9tYXRyaXhUb1F1YXRlcm5pb24vaW5kZXguaHRtXG5cblx0XHQvLyBhc3N1bWVzIHRoZSB1cHBlciAzeDMgb2YgbSBpcyBhIHB1cmUgcm90YXRpb24gbWF0cml4IChpLmUsIHVuc2NhbGVkKVxuXG5cdFx0dmFyIHRlID0gbS5lbGVtZW50cyxcblxuXHRcdFx0bTExID0gdGVbIDAgXSwgbTEyID0gdGVbIDQgXSwgbTEzID0gdGVbIDggXSxcblx0XHRcdG0yMSA9IHRlWyAxIF0sIG0yMiA9IHRlWyA1IF0sIG0yMyA9IHRlWyA5IF0sXG5cdFx0XHRtMzEgPSB0ZVsgMiBdLCBtMzIgPSB0ZVsgNiBdLCBtMzMgPSB0ZVsgMTAgXSxcblxuXHRcdFx0dHJhY2UgPSBtMTEgKyBtMjIgKyBtMzMsXG5cdFx0XHRzO1xuXG5cdFx0aWYgKCB0cmFjZSA+IDAgKSB7XG5cblx0XHRcdHMgPSAwLjUgLyBNYXRoLnNxcnQoIHRyYWNlICsgMS4wICk7XG5cblx0XHRcdHRoaXMuX3cgPSAwLjI1IC8gcztcblx0XHRcdHRoaXMuX3ggPSAoIG0zMiAtIG0yMyApICogcztcblx0XHRcdHRoaXMuX3kgPSAoIG0xMyAtIG0zMSApICogcztcblx0XHRcdHRoaXMuX3ogPSAoIG0yMSAtIG0xMiApICogcztcblxuXHRcdH0gZWxzZSBpZiAoIG0xMSA+IG0yMiAmJiBtMTEgPiBtMzMgKSB7XG5cblx0XHRcdHMgPSAyLjAgKiBNYXRoLnNxcnQoIDEuMCArIG0xMSAtIG0yMiAtIG0zMyApO1xuXG5cdFx0XHR0aGlzLl93ID0gKCBtMzIgLSBtMjMgKSAvIHM7XG5cdFx0XHR0aGlzLl94ID0gMC4yNSAqIHM7XG5cdFx0XHR0aGlzLl95ID0gKCBtMTIgKyBtMjEgKSAvIHM7XG5cdFx0XHR0aGlzLl96ID0gKCBtMTMgKyBtMzEgKSAvIHM7XG5cblx0XHR9IGVsc2UgaWYgKCBtMjIgPiBtMzMgKSB7XG5cblx0XHRcdHMgPSAyLjAgKiBNYXRoLnNxcnQoIDEuMCArIG0yMiAtIG0xMSAtIG0zMyApO1xuXG5cdFx0XHR0aGlzLl93ID0gKCBtMTMgLSBtMzEgKSAvIHM7XG5cdFx0XHR0aGlzLl94ID0gKCBtMTIgKyBtMjEgKSAvIHM7XG5cdFx0XHR0aGlzLl95ID0gMC4yNSAqIHM7XG5cdFx0XHR0aGlzLl96ID0gKCBtMjMgKyBtMzIgKSAvIHM7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRzID0gMi4wICogTWF0aC5zcXJ0KCAxLjAgKyBtMzMgLSBtMTEgLSBtMjIgKTtcblxuXHRcdFx0dGhpcy5fdyA9ICggbTIxIC0gbTEyICkgLyBzO1xuXHRcdFx0dGhpcy5feCA9ICggbTEzICsgbTMxICkgLyBzO1xuXHRcdFx0dGhpcy5feSA9ICggbTIzICsgbTMyICkgLyBzO1xuXHRcdFx0dGhpcy5feiA9IDAuMjUgKiBzO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldEZyb21Vbml0VmVjdG9yczogZnVuY3Rpb24gKCkge1xuXG5cdFx0Ly8gaHR0cDovL2xvbGVuZ2luZS5uZXQvYmxvZy8yMDE0LzAyLzI0L3F1YXRlcm5pb24tZnJvbS10d28tdmVjdG9ycy1maW5hbFxuXG5cdFx0Ly8gYXNzdW1lcyBkaXJlY3Rpb24gdmVjdG9ycyB2RnJvbSBhbmQgdlRvIGFyZSBub3JtYWxpemVkXG5cblx0XHR2YXIgdjEsIHI7XG5cblx0XHR2YXIgRVBTID0gMC4wMDAwMDE7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCB2RnJvbSwgdlRvICkge1xuXG5cdFx0XHRpZiAoIHYxID09PSB1bmRlZmluZWQgKSB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRcdHIgPSB2RnJvbS5kb3QoIHZUbyApICsgMTtcblxuXHRcdFx0aWYgKCByIDwgRVBTICkge1xuXG5cdFx0XHRcdHIgPSAwO1xuXG5cdFx0XHRcdGlmICggTWF0aC5hYnMoIHZGcm9tLnggKSA+IE1hdGguYWJzKCB2RnJvbS56ICkgKSB7XG5cblx0XHRcdFx0XHR2MS5zZXQoIC0gdkZyb20ueSwgdkZyb20ueCwgMCApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR2MS5zZXQoIDAsIC0gdkZyb20ueiwgdkZyb20ueSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR2MS5jcm9zc1ZlY3RvcnMoIHZGcm9tLCB2VG8gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl94ID0gdjEueDtcblx0XHRcdHRoaXMuX3kgPSB2MS55O1xuXHRcdFx0dGhpcy5feiA9IHYxLno7XG5cdFx0XHR0aGlzLl93ID0gcjtcblxuXHRcdFx0dGhpcy5ub3JtYWxpemUoKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9XG5cblx0fSgpLFxuXG5cdGludmVyc2U6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHRoaXMuY29uanVnYXRlKCkubm9ybWFsaXplKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGNvbmp1Z2F0ZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy5feCAqPSAtIDE7XG5cdFx0dGhpcy5feSAqPSAtIDE7XG5cdFx0dGhpcy5feiAqPSAtIDE7XG5cblx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0ZG90OiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5feCAqIHYuX3ggKyB0aGlzLl95ICogdi5feSArIHRoaXMuX3ogKiB2Ll96ICsgdGhpcy5fdyAqIHYuX3c7XG5cblx0fSxcblxuXHRsZW5ndGhTcTogZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX3ggKiB0aGlzLl94ICsgdGhpcy5feSAqIHRoaXMuX3kgKyB0aGlzLl96ICogdGhpcy5feiArIHRoaXMuX3cgKiB0aGlzLl93O1xuXG5cdH0sXG5cblx0bGVuZ3RoOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLl94ICogdGhpcy5feCArIHRoaXMuX3kgKiB0aGlzLl95ICsgdGhpcy5feiAqIHRoaXMuX3ogKyB0aGlzLl93ICogdGhpcy5fdyApO1xuXG5cdH0sXG5cblx0bm9ybWFsaXplOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgbCA9IHRoaXMubGVuZ3RoKCk7XG5cblx0XHRpZiAoIGwgPT09IDAgKSB7XG5cblx0XHRcdHRoaXMuX3ggPSAwO1xuXHRcdFx0dGhpcy5feSA9IDA7XG5cdFx0XHR0aGlzLl96ID0gMDtcblx0XHRcdHRoaXMuX3cgPSAxO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0bCA9IDEgLyBsO1xuXG5cdFx0XHR0aGlzLl94ID0gdGhpcy5feCAqIGw7XG5cdFx0XHR0aGlzLl95ID0gdGhpcy5feSAqIGw7XG5cdFx0XHR0aGlzLl96ID0gdGhpcy5feiAqIGw7XG5cdFx0XHR0aGlzLl93ID0gdGhpcy5fdyAqIGw7XG5cblx0XHR9XG5cblx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bXVsdGlwbHk6IGZ1bmN0aW9uICggcSwgcCApIHtcblxuXHRcdGlmICggcCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5RdWF0ZXJuaW9uOiAubXVsdGlwbHkoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5tdWx0aXBseVF1YXRlcm5pb25zKCBhLCBiICkgaW5zdGVhZC4nICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseVF1YXRlcm5pb25zKCBxLCBwICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseVF1YXRlcm5pb25zKCB0aGlzLCBxICk7XG5cblx0fSxcblxuXHRtdWx0aXBseVF1YXRlcm5pb25zOiBmdW5jdGlvbiAoIGEsIGIgKSB7XG5cblx0XHQvLyBmcm9tIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2FsZ2VicmEvcmVhbE5vcm1lZEFsZ2VicmEvcXVhdGVybmlvbnMvY29kZS9pbmRleC5odG1cblxuXHRcdHZhciBxYXggPSBhLl94LCBxYXkgPSBhLl95LCBxYXogPSBhLl96LCBxYXcgPSBhLl93O1xuXHRcdHZhciBxYnggPSBiLl94LCBxYnkgPSBiLl95LCBxYnogPSBiLl96LCBxYncgPSBiLl93O1xuXG5cdFx0dGhpcy5feCA9IHFheCAqIHFidyArIHFhdyAqIHFieCArIHFheSAqIHFieiAtIHFheiAqIHFieTtcblx0XHR0aGlzLl95ID0gcWF5ICogcWJ3ICsgcWF3ICogcWJ5ICsgcWF6ICogcWJ4IC0gcWF4ICogcWJ6O1xuXHRcdHRoaXMuX3ogPSBxYXogKiBxYncgKyBxYXcgKiBxYnogKyBxYXggKiBxYnkgLSBxYXkgKiBxYng7XG5cdFx0dGhpcy5fdyA9IHFhdyAqIHFidyAtIHFheCAqIHFieCAtIHFheSAqIHFieSAtIHFheiAqIHFiejtcblxuXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRtdWx0aXBseVZlY3RvcjM6IGZ1bmN0aW9uICggdmVjdG9yICkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuUXVhdGVybmlvbjogLm11bHRpcGx5VmVjdG9yMygpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBpcyBub3cgdmVjdG9yLmFwcGx5UXVhdGVybmlvbiggcXVhdGVybmlvbiApIGluc3RlYWQuJyApO1xuXHRcdHJldHVybiB2ZWN0b3IuYXBwbHlRdWF0ZXJuaW9uKCB0aGlzICk7XG5cblx0fSxcblxuXHRzbGVycDogZnVuY3Rpb24gKCBxYiwgdCApIHtcblxuXHRcdGlmICggdCA9PT0gMCApIHJldHVybiB0aGlzO1xuXHRcdGlmICggdCA9PT0gMSApIHJldHVybiB0aGlzLmNvcHkoIHFiICk7XG5cblx0XHR2YXIgeCA9IHRoaXMuX3gsIHkgPSB0aGlzLl95LCB6ID0gdGhpcy5feiwgdyA9IHRoaXMuX3c7XG5cblx0XHQvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9hbGdlYnJhL3JlYWxOb3JtZWRBbGdlYnJhL3F1YXRlcm5pb25zL3NsZXJwL1xuXG5cdFx0dmFyIGNvc0hhbGZUaGV0YSA9IHcgKiBxYi5fdyArIHggKiBxYi5feCArIHkgKiBxYi5feSArIHogKiBxYi5fejtcblxuXHRcdGlmICggY29zSGFsZlRoZXRhIDwgMCApIHtcblxuXHRcdFx0dGhpcy5fdyA9IC0gcWIuX3c7XG5cdFx0XHR0aGlzLl94ID0gLSBxYi5feDtcblx0XHRcdHRoaXMuX3kgPSAtIHFiLl95O1xuXHRcdFx0dGhpcy5feiA9IC0gcWIuX3o7XG5cblx0XHRcdGNvc0hhbGZUaGV0YSA9IC0gY29zSGFsZlRoZXRhO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGhpcy5jb3B5KCBxYiApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBjb3NIYWxmVGhldGEgPj0gMS4wICkge1xuXG5cdFx0XHR0aGlzLl93ID0gdztcblx0XHRcdHRoaXMuX3ggPSB4O1xuXHRcdFx0dGhpcy5feSA9IHk7XG5cdFx0XHR0aGlzLl96ID0gejtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9XG5cblx0XHR2YXIgaGFsZlRoZXRhID0gTWF0aC5hY29zKCBjb3NIYWxmVGhldGEgKTtcblx0XHR2YXIgc2luSGFsZlRoZXRhID0gTWF0aC5zcXJ0KCAxLjAgLSBjb3NIYWxmVGhldGEgKiBjb3NIYWxmVGhldGEgKTtcblxuXHRcdGlmICggTWF0aC5hYnMoIHNpbkhhbGZUaGV0YSApIDwgMC4wMDEgKSB7XG5cblx0XHRcdHRoaXMuX3cgPSAwLjUgKiAoIHcgKyB0aGlzLl93ICk7XG5cdFx0XHR0aGlzLl94ID0gMC41ICogKCB4ICsgdGhpcy5feCApO1xuXHRcdFx0dGhpcy5feSA9IDAuNSAqICggeSArIHRoaXMuX3kgKTtcblx0XHRcdHRoaXMuX3ogPSAwLjUgKiAoIHogKyB0aGlzLl96ICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fVxuXG5cdFx0dmFyIHJhdGlvQSA9IE1hdGguc2luKCAoIDEgLSB0ICkgKiBoYWxmVGhldGEgKSAvIHNpbkhhbGZUaGV0YSxcblx0XHRyYXRpb0IgPSBNYXRoLnNpbiggdCAqIGhhbGZUaGV0YSApIC8gc2luSGFsZlRoZXRhO1xuXG5cdFx0dGhpcy5fdyA9ICggdyAqIHJhdGlvQSArIHRoaXMuX3cgKiByYXRpb0IgKTtcblx0XHR0aGlzLl94ID0gKCB4ICogcmF0aW9BICsgdGhpcy5feCAqIHJhdGlvQiApO1xuXHRcdHRoaXMuX3kgPSAoIHkgKiByYXRpb0EgKyB0aGlzLl95ICogcmF0aW9CICk7XG5cdFx0dGhpcy5feiA9ICggeiAqIHJhdGlvQSArIHRoaXMuX3ogKiByYXRpb0IgKTtcblxuXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRlcXVhbHM6IGZ1bmN0aW9uICggcXVhdGVybmlvbiApIHtcblxuXHRcdHJldHVybiAoIHF1YXRlcm5pb24uX3ggPT09IHRoaXMuX3ggKSAmJiAoIHF1YXRlcm5pb24uX3kgPT09IHRoaXMuX3kgKSAmJiAoIHF1YXRlcm5pb24uX3ogPT09IHRoaXMuX3ogKSAmJiAoIHF1YXRlcm5pb24uX3cgPT09IHRoaXMuX3cgKTtcblxuXHR9LFxuXG5cdGZyb21BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xuXG5cdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cblx0XHR0aGlzLl94ID0gYXJyYXlbIG9mZnNldCBdO1xuXHRcdHRoaXMuX3kgPSBhcnJheVsgb2Zmc2V0ICsgMSBdO1xuXHRcdHRoaXMuX3ogPSBhcnJheVsgb2Zmc2V0ICsgMiBdO1xuXHRcdHRoaXMuX3cgPSBhcnJheVsgb2Zmc2V0ICsgMyBdO1xuXG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHRvQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcblxuXHRcdGlmICggYXJyYXkgPT09IHVuZGVmaW5lZCApIGFycmF5ID0gW107XG5cdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cblx0XHRhcnJheVsgb2Zmc2V0IF0gPSB0aGlzLl94O1xuXHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLl95O1xuXHRcdGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0aGlzLl96O1xuXHRcdGFycmF5WyBvZmZzZXQgKyAzIF0gPSB0aGlzLl93O1xuXG5cdFx0cmV0dXJuIGFycmF5O1xuXG5cdH0sXG5cblx0b25DaGFuZ2U6IGZ1bmN0aW9uICggY2FsbGJhY2sgKSB7XG5cblx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2sgPSBjYWxsYmFjaztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0b25DaGFuZ2VDYWxsYmFjazogZnVuY3Rpb24gKCkge30sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBuZXcgVEhSRUUuUXVhdGVybmlvbiggdGhpcy5feCwgdGhpcy5feSwgdGhpcy5feiwgdGhpcy5fdyApO1xuXG5cdH1cblxufTtcblxuVEhSRUUuUXVhdGVybmlvbi5zbGVycCA9IGZ1bmN0aW9uICggcWEsIHFiLCBxbSwgdCApIHtcblxuXHRyZXR1cm4gcW0uY29weSggcWEgKS5zbGVycCggcWIsIHQgKTtcblxufVxuXG4vKioqIEVORCBRdWF0ZXJuaW9uICoqKi9cbi8qKiogU1RBUlQgVmVjdG9yMiAqKiovXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIHBoaWxvZ2IgLyBodHRwOi8vYmxvZy50aGVqaXQub3JnL1xuICogQGF1dGhvciBlZ3JhZXRoZXIgLyBodHRwOi8vZWdyYWV0aGVyLmNvbS9cbiAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcbiAqL1xuXG5USFJFRS5WZWN0b3IyID0gZnVuY3Rpb24gKCB4LCB5ICkge1xuXG5cdHRoaXMueCA9IHggfHwgMDtcblx0dGhpcy55ID0geSB8fCAwO1xuXG59O1xuXG5USFJFRS5WZWN0b3IyLnByb3RvdHlwZSA9IHtcblxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuVmVjdG9yMixcblxuXHRzZXQ6IGZ1bmN0aW9uICggeCwgeSApIHtcblxuXHRcdHRoaXMueCA9IHg7XG5cdFx0dGhpcy55ID0geTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0WDogZnVuY3Rpb24gKCB4ICkge1xuXG5cdFx0dGhpcy54ID0geDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0WTogZnVuY3Rpb24gKCB5ICkge1xuXG5cdFx0dGhpcy55ID0geTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0Q29tcG9uZW50OiBmdW5jdGlvbiAoIGluZGV4LCB2YWx1ZSApIHtcblxuXHRcdHN3aXRjaCAoIGluZGV4ICkge1xuXG5cdFx0XHRjYXNlIDA6IHRoaXMueCA9IHZhbHVlOyBicmVhaztcblx0XHRcdGNhc2UgMTogdGhpcy55ID0gdmFsdWU7IGJyZWFrO1xuXHRcdFx0ZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCAnaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAnICsgaW5kZXggKTtcblxuXHRcdH1cblxuXHR9LFxuXG5cdGdldENvbXBvbmVudDogZnVuY3Rpb24gKCBpbmRleCApIHtcblxuXHRcdHN3aXRjaCAoIGluZGV4ICkge1xuXG5cdFx0XHRjYXNlIDA6IHJldHVybiB0aGlzLng7XG5cdFx0XHRjYXNlIDE6IHJldHVybiB0aGlzLnk7XG5cdFx0XHRkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0Y29weTogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0dGhpcy54ID0gdi54O1xuXHRcdHRoaXMueSA9IHYueTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0YWRkOiBmdW5jdGlvbiAoIHYsIHcgKSB7XG5cblx0XHRpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMjogLmFkZCgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLmFkZFZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcblx0XHRcdHJldHVybiB0aGlzLmFkZFZlY3RvcnMoIHYsIHcgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMueCArPSB2Lng7XG5cdFx0dGhpcy55ICs9IHYueTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0YWRkVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xuXG5cdFx0dGhpcy54ID0gYS54ICsgYi54O1xuXHRcdHRoaXMueSA9IGEueSArIGIueTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0YWRkU2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XG5cblx0XHR0aGlzLnggKz0gcztcblx0XHR0aGlzLnkgKz0gcztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c3ViOiBmdW5jdGlvbiAoIHYsIHcgKSB7XG5cblx0XHRpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMjogLnN1YigpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLnN1YlZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcblx0XHRcdHJldHVybiB0aGlzLnN1YlZlY3RvcnMoIHYsIHcgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMueCAtPSB2Lng7XG5cdFx0dGhpcy55IC09IHYueTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c3ViVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xuXG5cdFx0dGhpcy54ID0gYS54IC0gYi54O1xuXHRcdHRoaXMueSA9IGEueSAtIGIueTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bXVsdGlwbHk6IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdHRoaXMueCAqPSB2Lng7XG5cdFx0dGhpcy55ICo9IHYueTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bXVsdGlwbHlTY2FsYXI6IGZ1bmN0aW9uICggcyApIHtcblxuXHRcdHRoaXMueCAqPSBzO1xuXHRcdHRoaXMueSAqPSBzO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRkaXZpZGU6IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdHRoaXMueCAvPSB2Lng7XG5cdFx0dGhpcy55IC89IHYueTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0ZGl2aWRlU2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcblxuXHRcdGlmICggc2NhbGFyICE9PSAwICkge1xuXG5cdFx0XHR2YXIgaW52U2NhbGFyID0gMSAvIHNjYWxhcjtcblxuXHRcdFx0dGhpcy54ICo9IGludlNjYWxhcjtcblx0XHRcdHRoaXMueSAqPSBpbnZTY2FsYXI7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aGlzLnggPSAwO1xuXHRcdFx0dGhpcy55ID0gMDtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bWluOiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHRpZiAoIHRoaXMueCA+IHYueCApIHtcblxuXHRcdFx0dGhpcy54ID0gdi54O1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLnkgPiB2LnkgKSB7XG5cblx0XHRcdHRoaXMueSA9IHYueTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bWF4OiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHRpZiAoIHRoaXMueCA8IHYueCApIHtcblxuXHRcdFx0dGhpcy54ID0gdi54O1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLnkgPCB2LnkgKSB7XG5cblx0XHRcdHRoaXMueSA9IHYueTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Y2xhbXA6IGZ1bmN0aW9uICggbWluLCBtYXggKSB7XG5cblx0XHQvLyBUaGlzIGZ1bmN0aW9uIGFzc3VtZXMgbWluIDwgbWF4LCBpZiB0aGlzIGFzc3VtcHRpb24gaXNuJ3QgdHJ1ZSBpdCB3aWxsIG5vdCBvcGVyYXRlIGNvcnJlY3RseVxuXG5cdFx0aWYgKCB0aGlzLnggPCBtaW4ueCApIHtcblxuXHRcdFx0dGhpcy54ID0gbWluLng7XG5cblx0XHR9IGVsc2UgaWYgKCB0aGlzLnggPiBtYXgueCApIHtcblxuXHRcdFx0dGhpcy54ID0gbWF4Lng7XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMueSA8IG1pbi55ICkge1xuXG5cdFx0XHR0aGlzLnkgPSBtaW4ueTtcblxuXHRcdH0gZWxzZSBpZiAoIHRoaXMueSA+IG1heC55ICkge1xuXG5cdFx0XHR0aGlzLnkgPSBtYXgueTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGNsYW1wU2NhbGFyOiAoIGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBtaW4sIG1heDtcblxuXHRcdHJldHVybiBmdW5jdGlvbiAoIG1pblZhbCwgbWF4VmFsICkge1xuXG5cdFx0XHRpZiAoIG1pbiA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdG1pbiA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cdFx0XHRcdG1heCA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cblx0XHRcdH1cblxuXHRcdFx0bWluLnNldCggbWluVmFsLCBtaW5WYWwgKTtcblx0XHRcdG1heC5zZXQoIG1heFZhbCwgbWF4VmFsICk7XG5cblx0XHRcdHJldHVybiB0aGlzLmNsYW1wKCBtaW4sIG1heCApO1xuXG5cdFx0fTtcblxuXHR9ICkoKSxcblxuXHRmbG9vcjogZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy54ID0gTWF0aC5mbG9vciggdGhpcy54ICk7XG5cdFx0dGhpcy55ID0gTWF0aC5mbG9vciggdGhpcy55ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGNlaWw6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHRoaXMueCA9IE1hdGguY2VpbCggdGhpcy54ICk7XG5cdFx0dGhpcy55ID0gTWF0aC5jZWlsKCB0aGlzLnkgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0cm91bmQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHRoaXMueCA9IE1hdGgucm91bmQoIHRoaXMueCApO1xuXHRcdHRoaXMueSA9IE1hdGgucm91bmQoIHRoaXMueSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRyb3VuZFRvWmVybzogZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy54ID0gKCB0aGlzLnggPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMueCApIDogTWF0aC5mbG9vciggdGhpcy54ICk7XG5cdFx0dGhpcy55ID0gKCB0aGlzLnkgPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMueSApIDogTWF0aC5mbG9vciggdGhpcy55ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdG5lZ2F0ZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy54ID0gLSB0aGlzLng7XG5cdFx0dGhpcy55ID0gLSB0aGlzLnk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGRvdDogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0cmV0dXJuIHRoaXMueCAqIHYueCArIHRoaXMueSAqIHYueTtcblxuXHR9LFxuXG5cdGxlbmd0aFNxOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55O1xuXG5cdH0sXG5cblx0bGVuZ3RoOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKTtcblxuXHR9LFxuXG5cdG5vcm1hbGl6ZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKCB0aGlzLmxlbmd0aCgpICk7XG5cblx0fSxcblxuXHRkaXN0YW5jZVRvOiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHRyZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLmRpc3RhbmNlVG9TcXVhcmVkKCB2ICkgKTtcblxuXHR9LFxuXG5cdGRpc3RhbmNlVG9TcXVhcmVkOiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHR2YXIgZHggPSB0aGlzLnggLSB2LngsIGR5ID0gdGhpcy55IC0gdi55O1xuXHRcdHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcblxuXHR9LFxuXG5cdHNldExlbmd0aDogZnVuY3Rpb24gKCBsICkge1xuXG5cdFx0dmFyIG9sZExlbmd0aCA9IHRoaXMubGVuZ3RoKCk7XG5cblx0XHRpZiAoIG9sZExlbmd0aCAhPT0gMCAmJiBsICE9PSBvbGRMZW5ndGggKSB7XG5cblx0XHRcdHRoaXMubXVsdGlwbHlTY2FsYXIoIGwgLyBvbGRMZW5ndGggKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGxlcnA6IGZ1bmN0aW9uICggdiwgYWxwaGEgKSB7XG5cblx0XHR0aGlzLnggKz0gKCB2LnggLSB0aGlzLnggKSAqIGFscGhhO1xuXHRcdHRoaXMueSArPSAoIHYueSAtIHRoaXMueSApICogYWxwaGE7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0cmV0dXJuICggKCB2LnggPT09IHRoaXMueCApICYmICggdi55ID09PSB0aGlzLnkgKSApO1xuXG5cdH0sXG5cblx0ZnJvbUFycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XG5cblx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuXHRcdHRoaXMueCA9IGFycmF5WyBvZmZzZXQgXTtcblx0XHR0aGlzLnkgPSBhcnJheVsgb2Zmc2V0ICsgMSBdO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHR0b0FycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XG5cblx0XHRpZiAoIGFycmF5ID09PSB1bmRlZmluZWQgKSBhcnJheSA9IFtdO1xuXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG5cdFx0YXJyYXlbIG9mZnNldCBdID0gdGhpcy54O1xuXHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLnk7XG5cblx0XHRyZXR1cm4gYXJyYXk7XG5cblx0fSxcblxuXHRmcm9tQXR0cmlidXRlOiBmdW5jdGlvbiAoIGF0dHJpYnV0ZSwgaW5kZXgsIG9mZnNldCApIHtcblxuXHQgICAgaWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cblx0ICAgIGluZGV4ID0gaW5kZXggKiBhdHRyaWJ1dGUuaXRlbVNpemUgKyBvZmZzZXQ7XG5cblx0ICAgIHRoaXMueCA9IGF0dHJpYnV0ZS5hcnJheVsgaW5kZXggXTtcblx0ICAgIHRoaXMueSA9IGF0dHJpYnV0ZS5hcnJheVsgaW5kZXggKyAxIF07XG5cblx0ICAgIHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMiggdGhpcy54LCB0aGlzLnkgKTtcblxuXHR9XG5cbn07XG4vKioqIEVORCBWZWN0b3IyICoqKi9cbi8qKiogU1RBUlQgVmVjdG9yMyAqKiovXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgKmtpbGUgLyBodHRwOi8va2lsZS5zdHJhdmFnYW56YS5vcmcvXG4gKiBAYXV0aG9yIHBoaWxvZ2IgLyBodHRwOi8vYmxvZy50aGVqaXQub3JnL1xuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqIEBhdXRob3IgZWdyYWV0aGVyIC8gaHR0cDovL2VncmFldGhlci5jb20vXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAqL1xuXG5USFJFRS5WZWN0b3IzID0gZnVuY3Rpb24gKCB4LCB5LCB6ICkge1xuXG5cdHRoaXMueCA9IHggfHwgMDtcblx0dGhpcy55ID0geSB8fCAwO1xuXHR0aGlzLnogPSB6IHx8IDA7XG5cbn07XG5cblRIUkVFLlZlY3RvcjMucHJvdG90eXBlID0ge1xuXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5WZWN0b3IzLFxuXG5cdHNldDogZnVuY3Rpb24gKCB4LCB5LCB6ICkge1xuXG5cdFx0dGhpcy54ID0geDtcblx0XHR0aGlzLnkgPSB5O1xuXHRcdHRoaXMueiA9IHo7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldFg6IGZ1bmN0aW9uICggeCApIHtcblxuXHRcdHRoaXMueCA9IHg7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldFk6IGZ1bmN0aW9uICggeSApIHtcblxuXHRcdHRoaXMueSA9IHk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldFo6IGZ1bmN0aW9uICggeiApIHtcblxuXHRcdHRoaXMueiA9IHo7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldENvbXBvbmVudDogZnVuY3Rpb24gKCBpbmRleCwgdmFsdWUgKSB7XG5cblx0XHRzd2l0Y2ggKCBpbmRleCApIHtcblxuXHRcdFx0Y2FzZSAwOiB0aGlzLnggPSB2YWx1ZTsgYnJlYWs7XG5cdFx0XHRjYXNlIDE6IHRoaXMueSA9IHZhbHVlOyBicmVhaztcblx0XHRcdGNhc2UgMjogdGhpcy56ID0gdmFsdWU7IGJyZWFrO1xuXHRcdFx0ZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCAnaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAnICsgaW5kZXggKTtcblxuXHRcdH1cblxuXHR9LFxuXG5cdGdldENvbXBvbmVudDogZnVuY3Rpb24gKCBpbmRleCApIHtcblxuXHRcdHN3aXRjaCAoIGluZGV4ICkge1xuXG5cdFx0XHRjYXNlIDA6IHJldHVybiB0aGlzLng7XG5cdFx0XHRjYXNlIDE6IHJldHVybiB0aGlzLnk7XG5cdFx0XHRjYXNlIDI6IHJldHVybiB0aGlzLno7XG5cdFx0XHRkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0Y29weTogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0dGhpcy54ID0gdi54O1xuXHRcdHRoaXMueSA9IHYueTtcblx0XHR0aGlzLnogPSB2Lno7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGFkZDogZnVuY3Rpb24gKCB2LCB3ICkge1xuXG5cdFx0aWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjM6IC5hZGQoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5hZGRWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5hZGRWZWN0b3JzKCB2LCB3ICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLnggKz0gdi54O1xuXHRcdHRoaXMueSArPSB2Lnk7XG5cdFx0dGhpcy56ICs9IHYuejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0YWRkU2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XG5cblx0XHR0aGlzLnggKz0gcztcblx0XHR0aGlzLnkgKz0gcztcblx0XHR0aGlzLnogKz0gcztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0YWRkVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xuXG5cdFx0dGhpcy54ID0gYS54ICsgYi54O1xuXHRcdHRoaXMueSA9IGEueSArIGIueTtcblx0XHR0aGlzLnogPSBhLnogKyBiLno7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHN1YjogZnVuY3Rpb24gKCB2LCB3ICkge1xuXG5cdFx0aWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjM6IC5zdWIoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5zdWJWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5zdWJWZWN0b3JzKCB2LCB3ICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLnggLT0gdi54O1xuXHRcdHRoaXMueSAtPSB2Lnk7XG5cdFx0dGhpcy56IC09IHYuejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c3ViVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xuXG5cdFx0dGhpcy54ID0gYS54IC0gYi54O1xuXHRcdHRoaXMueSA9IGEueSAtIGIueTtcblx0XHR0aGlzLnogPSBhLnogLSBiLno7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdG11bHRpcGx5OiBmdW5jdGlvbiAoIHYsIHcgKSB7XG5cblx0XHRpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLm11bHRpcGx5KCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAubXVsdGlwbHlWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseVZlY3RvcnMoIHYsIHcgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMueCAqPSB2Lng7XG5cdFx0dGhpcy55ICo9IHYueTtcblx0XHR0aGlzLnogKj0gdi56O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRtdWx0aXBseVNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XG5cblx0XHR0aGlzLnggKj0gc2NhbGFyO1xuXHRcdHRoaXMueSAqPSBzY2FsYXI7XG5cdFx0dGhpcy56ICo9IHNjYWxhcjtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bXVsdGlwbHlWZWN0b3JzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XG5cblx0XHR0aGlzLnggPSBhLnggKiBiLng7XG5cdFx0dGhpcy55ID0gYS55ICogYi55O1xuXHRcdHRoaXMueiA9IGEueiAqIGIuejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0YXBwbHlFdWxlcjogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHF1YXRlcm5pb247XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBldWxlciApIHtcblxuXHRcdFx0aWYgKCBldWxlciBpbnN0YW5jZW9mIFRIUkVFLkV1bGVyID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuVmVjdG9yMzogLmFwcGx5RXVsZXIoKSBub3cgZXhwZWN0cyBhIEV1bGVyIHJvdGF0aW9uIHJhdGhlciB0aGFuIGEgVmVjdG9yMyBhbmQgb3JkZXIuJyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggcXVhdGVybmlvbiA9PT0gdW5kZWZpbmVkICkgcXVhdGVybmlvbiA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XG5cblx0XHRcdHRoaXMuYXBwbHlRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uLnNldEZyb21FdWxlciggZXVsZXIgKSApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH07XG5cblx0fSgpLFxuXG5cdGFwcGx5QXhpc0FuZ2xlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgcXVhdGVybmlvbjtcblxuXHRcdHJldHVybiBmdW5jdGlvbiAoIGF4aXMsIGFuZ2xlICkge1xuXG5cdFx0XHRpZiAoIHF1YXRlcm5pb24gPT09IHVuZGVmaW5lZCApIHF1YXRlcm5pb24gPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xuXG5cdFx0XHR0aGlzLmFwcGx5UXVhdGVybmlvbiggcXVhdGVybmlvbi5zZXRGcm9tQXhpc0FuZ2xlKCBheGlzLCBhbmdsZSApICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fTtcblxuXHR9KCksXG5cblx0YXBwbHlNYXRyaXgzOiBmdW5jdGlvbiAoIG0gKSB7XG5cblx0XHR2YXIgeCA9IHRoaXMueDtcblx0XHR2YXIgeSA9IHRoaXMueTtcblx0XHR2YXIgeiA9IHRoaXMuejtcblxuXHRcdHZhciBlID0gbS5lbGVtZW50cztcblxuXHRcdHRoaXMueCA9IGVbIDAgXSAqIHggKyBlWyAzIF0gKiB5ICsgZVsgNiBdICogejtcblx0XHR0aGlzLnkgPSBlWyAxIF0gKiB4ICsgZVsgNCBdICogeSArIGVbIDcgXSAqIHo7XG5cdFx0dGhpcy56ID0gZVsgMiBdICogeCArIGVbIDUgXSAqIHkgKyBlWyA4IF0gKiB6O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRhcHBseU1hdHJpeDQ6IGZ1bmN0aW9uICggbSApIHtcblxuXHRcdC8vIGlucHV0OiBUSFJFRS5NYXRyaXg0IGFmZmluZSBtYXRyaXhcblxuXHRcdHZhciB4ID0gdGhpcy54LCB5ID0gdGhpcy55LCB6ID0gdGhpcy56O1xuXG5cdFx0dmFyIGUgPSBtLmVsZW1lbnRzO1xuXG5cdFx0dGhpcy54ID0gZVsgMCBdICogeCArIGVbIDQgXSAqIHkgKyBlWyA4IF0gICogeiArIGVbIDEyIF07XG5cdFx0dGhpcy55ID0gZVsgMSBdICogeCArIGVbIDUgXSAqIHkgKyBlWyA5IF0gICogeiArIGVbIDEzIF07XG5cdFx0dGhpcy56ID0gZVsgMiBdICogeCArIGVbIDYgXSAqIHkgKyBlWyAxMCBdICogeiArIGVbIDE0IF07XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGFwcGx5UHJvamVjdGlvbjogZnVuY3Rpb24gKCBtICkge1xuXG5cdFx0Ly8gaW5wdXQ6IFRIUkVFLk1hdHJpeDQgcHJvamVjdGlvbiBtYXRyaXhcblxuXHRcdHZhciB4ID0gdGhpcy54LCB5ID0gdGhpcy55LCB6ID0gdGhpcy56O1xuXG5cdFx0dmFyIGUgPSBtLmVsZW1lbnRzO1xuXHRcdHZhciBkID0gMSAvICggZVsgMyBdICogeCArIGVbIDcgXSAqIHkgKyBlWyAxMSBdICogeiArIGVbIDE1IF0gKTsgLy8gcGVyc3BlY3RpdmUgZGl2aWRlXG5cblx0XHR0aGlzLnggPSAoIGVbIDAgXSAqIHggKyBlWyA0IF0gKiB5ICsgZVsgOCBdICAqIHogKyBlWyAxMiBdICkgKiBkO1xuXHRcdHRoaXMueSA9ICggZVsgMSBdICogeCArIGVbIDUgXSAqIHkgKyBlWyA5IF0gICogeiArIGVbIDEzIF0gKSAqIGQ7XG5cdFx0dGhpcy56ID0gKCBlWyAyIF0gKiB4ICsgZVsgNiBdICogeSArIGVbIDEwIF0gKiB6ICsgZVsgMTQgXSApICogZDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0YXBwbHlRdWF0ZXJuaW9uOiBmdW5jdGlvbiAoIHEgKSB7XG5cblx0XHR2YXIgeCA9IHRoaXMueDtcblx0XHR2YXIgeSA9IHRoaXMueTtcblx0XHR2YXIgeiA9IHRoaXMuejtcblxuXHRcdHZhciBxeCA9IHEueDtcblx0XHR2YXIgcXkgPSBxLnk7XG5cdFx0dmFyIHF6ID0gcS56O1xuXHRcdHZhciBxdyA9IHEudztcblxuXHRcdC8vIGNhbGN1bGF0ZSBxdWF0ICogdmVjdG9yXG5cblx0XHR2YXIgaXggPSAgcXcgKiB4ICsgcXkgKiB6IC0gcXogKiB5O1xuXHRcdHZhciBpeSA9ICBxdyAqIHkgKyBxeiAqIHggLSBxeCAqIHo7XG5cdFx0dmFyIGl6ID0gIHF3ICogeiArIHF4ICogeSAtIHF5ICogeDtcblx0XHR2YXIgaXcgPSAtIHF4ICogeCAtIHF5ICogeSAtIHF6ICogejtcblxuXHRcdC8vIGNhbGN1bGF0ZSByZXN1bHQgKiBpbnZlcnNlIHF1YXRcblxuXHRcdHRoaXMueCA9IGl4ICogcXcgKyBpdyAqIC0gcXggKyBpeSAqIC0gcXogLSBpeiAqIC0gcXk7XG5cdFx0dGhpcy55ID0gaXkgKiBxdyArIGl3ICogLSBxeSArIGl6ICogLSBxeCAtIGl4ICogLSBxejtcblx0XHR0aGlzLnogPSBpeiAqIHF3ICsgaXcgKiAtIHF6ICsgaXggKiAtIHF5IC0gaXkgKiAtIHF4O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRwcm9qZWN0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgbWF0cml4O1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggY2FtZXJhICkge1xuXG5cdFx0XHRpZiAoIG1hdHJpeCA9PT0gdW5kZWZpbmVkICkgbWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuXHRcdFx0bWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4LCBtYXRyaXguZ2V0SW52ZXJzZSggY2FtZXJhLm1hdHJpeFdvcmxkICkgKTtcblx0XHRcdHJldHVybiB0aGlzLmFwcGx5UHJvamVjdGlvbiggbWF0cml4ICk7XG5cblx0XHR9O1xuXG5cdH0oKSxcblxuXHR1bnByb2plY3Q6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBtYXRyaXg7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBjYW1lcmEgKSB7XG5cblx0XHRcdGlmICggbWF0cml4ID09PSB1bmRlZmluZWQgKSBtYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG5cdFx0XHRtYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggY2FtZXJhLm1hdHJpeFdvcmxkLCBtYXRyaXguZ2V0SW52ZXJzZSggY2FtZXJhLnByb2plY3Rpb25NYXRyaXggKSApO1xuXHRcdFx0cmV0dXJuIHRoaXMuYXBwbHlQcm9qZWN0aW9uKCBtYXRyaXggKTtcblxuXHRcdH07XG5cblx0fSgpLFxuXG5cdHRyYW5zZm9ybURpcmVjdGlvbjogZnVuY3Rpb24gKCBtICkge1xuXG5cdFx0Ly8gaW5wdXQ6IFRIUkVFLk1hdHJpeDQgYWZmaW5lIG1hdHJpeFxuXHRcdC8vIHZlY3RvciBpbnRlcnByZXRlZCBhcyBhIGRpcmVjdGlvblxuXG5cdFx0dmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLno7XG5cblx0XHR2YXIgZSA9IG0uZWxlbWVudHM7XG5cblx0XHR0aGlzLnggPSBlWyAwIF0gKiB4ICsgZVsgNCBdICogeSArIGVbIDggXSAgKiB6O1xuXHRcdHRoaXMueSA9IGVbIDEgXSAqIHggKyBlWyA1IF0gKiB5ICsgZVsgOSBdICAqIHo7XG5cdFx0dGhpcy56ID0gZVsgMiBdICogeCArIGVbIDYgXSAqIHkgKyBlWyAxMCBdICogejtcblxuXHRcdHRoaXMubm9ybWFsaXplKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGRpdmlkZTogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0dGhpcy54IC89IHYueDtcblx0XHR0aGlzLnkgLz0gdi55O1xuXHRcdHRoaXMueiAvPSB2Lno7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGRpdmlkZVNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XG5cblx0XHRpZiAoIHNjYWxhciAhPT0gMCApIHtcblxuXHRcdFx0dmFyIGludlNjYWxhciA9IDEgLyBzY2FsYXI7XG5cblx0XHRcdHRoaXMueCAqPSBpbnZTY2FsYXI7XG5cdFx0XHR0aGlzLnkgKj0gaW52U2NhbGFyO1xuXHRcdFx0dGhpcy56ICo9IGludlNjYWxhcjtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRoaXMueCA9IDA7XG5cdFx0XHR0aGlzLnkgPSAwO1xuXHRcdFx0dGhpcy56ID0gMDtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bWluOiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHRpZiAoIHRoaXMueCA+IHYueCApIHtcblxuXHRcdFx0dGhpcy54ID0gdi54O1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLnkgPiB2LnkgKSB7XG5cblx0XHRcdHRoaXMueSA9IHYueTtcblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy56ID4gdi56ICkge1xuXG5cdFx0XHR0aGlzLnogPSB2Lno7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdG1heDogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0aWYgKCB0aGlzLnggPCB2LnggKSB7XG5cblx0XHRcdHRoaXMueCA9IHYueDtcblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy55IDwgdi55ICkge1xuXG5cdFx0XHR0aGlzLnkgPSB2Lnk7XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMueiA8IHYueiApIHtcblxuXHRcdFx0dGhpcy56ID0gdi56O1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRjbGFtcDogZnVuY3Rpb24gKCBtaW4sIG1heCApIHtcblxuXHRcdC8vIFRoaXMgZnVuY3Rpb24gYXNzdW1lcyBtaW4gPCBtYXgsIGlmIHRoaXMgYXNzdW1wdGlvbiBpc24ndCB0cnVlIGl0IHdpbGwgbm90IG9wZXJhdGUgY29ycmVjdGx5XG5cblx0XHRpZiAoIHRoaXMueCA8IG1pbi54ICkge1xuXG5cdFx0XHR0aGlzLnggPSBtaW4ueDtcblxuXHRcdH0gZWxzZSBpZiAoIHRoaXMueCA+IG1heC54ICkge1xuXG5cdFx0XHR0aGlzLnggPSBtYXgueDtcblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy55IDwgbWluLnkgKSB7XG5cblx0XHRcdHRoaXMueSA9IG1pbi55O1xuXG5cdFx0fSBlbHNlIGlmICggdGhpcy55ID4gbWF4LnkgKSB7XG5cblx0XHRcdHRoaXMueSA9IG1heC55O1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLnogPCBtaW4ueiApIHtcblxuXHRcdFx0dGhpcy56ID0gbWluLno7XG5cblx0XHR9IGVsc2UgaWYgKCB0aGlzLnogPiBtYXgueiApIHtcblxuXHRcdFx0dGhpcy56ID0gbWF4Lno7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGNsYW1wU2NhbGFyOiAoIGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBtaW4sIG1heDtcblxuXHRcdHJldHVybiBmdW5jdGlvbiAoIG1pblZhbCwgbWF4VmFsICkge1xuXG5cdFx0XHRpZiAoIG1pbiA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdG1pbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0XHRcdG1heCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRcdH1cblxuXHRcdFx0bWluLnNldCggbWluVmFsLCBtaW5WYWwsIG1pblZhbCApO1xuXHRcdFx0bWF4LnNldCggbWF4VmFsLCBtYXhWYWwsIG1heFZhbCApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5jbGFtcCggbWluLCBtYXggKTtcblxuXHRcdH07XG5cblx0fSApKCksXG5cblx0Zmxvb3I6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHRoaXMueCA9IE1hdGguZmxvb3IoIHRoaXMueCApO1xuXHRcdHRoaXMueSA9IE1hdGguZmxvb3IoIHRoaXMueSApO1xuXHRcdHRoaXMueiA9IE1hdGguZmxvb3IoIHRoaXMueiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRjZWlsOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLnggPSBNYXRoLmNlaWwoIHRoaXMueCApO1xuXHRcdHRoaXMueSA9IE1hdGguY2VpbCggdGhpcy55ICk7XG5cdFx0dGhpcy56ID0gTWF0aC5jZWlsKCB0aGlzLnogKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0cm91bmQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHRoaXMueCA9IE1hdGgucm91bmQoIHRoaXMueCApO1xuXHRcdHRoaXMueSA9IE1hdGgucm91bmQoIHRoaXMueSApO1xuXHRcdHRoaXMueiA9IE1hdGgucm91bmQoIHRoaXMueiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRyb3VuZFRvWmVybzogZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy54ID0gKCB0aGlzLnggPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMueCApIDogTWF0aC5mbG9vciggdGhpcy54ICk7XG5cdFx0dGhpcy55ID0gKCB0aGlzLnkgPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMueSApIDogTWF0aC5mbG9vciggdGhpcy55ICk7XG5cdFx0dGhpcy56ID0gKCB0aGlzLnogPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMueiApIDogTWF0aC5mbG9vciggdGhpcy56ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdG5lZ2F0ZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy54ID0gLSB0aGlzLng7XG5cdFx0dGhpcy55ID0gLSB0aGlzLnk7XG5cdFx0dGhpcy56ID0gLSB0aGlzLno7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGRvdDogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0cmV0dXJuIHRoaXMueCAqIHYueCArIHRoaXMueSAqIHYueSArIHRoaXMueiAqIHYuejtcblxuXHR9LFxuXG5cdGxlbmd0aFNxOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56O1xuXG5cdH0sXG5cblx0bGVuZ3RoOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLnogKTtcblxuXHR9LFxuXG5cdGxlbmd0aE1hbmhhdHRhbjogZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIE1hdGguYWJzKCB0aGlzLnggKSArIE1hdGguYWJzKCB0aGlzLnkgKSArIE1hdGguYWJzKCB0aGlzLnogKTtcblxuXHR9LFxuXG5cdG5vcm1hbGl6ZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKCB0aGlzLmxlbmd0aCgpICk7XG5cblx0fSxcblxuXHRzZXRMZW5ndGg6IGZ1bmN0aW9uICggbCApIHtcblxuXHRcdHZhciBvbGRMZW5ndGggPSB0aGlzLmxlbmd0aCgpO1xuXG5cdFx0aWYgKCBvbGRMZW5ndGggIT09IDAgJiYgbCAhPT0gb2xkTGVuZ3RoICApIHtcblxuXHRcdFx0dGhpcy5tdWx0aXBseVNjYWxhciggbCAvIG9sZExlbmd0aCApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bGVycDogZnVuY3Rpb24gKCB2LCBhbHBoYSApIHtcblxuXHRcdHRoaXMueCArPSAoIHYueCAtIHRoaXMueCApICogYWxwaGE7XG5cdFx0dGhpcy55ICs9ICggdi55IC0gdGhpcy55ICkgKiBhbHBoYTtcblx0XHR0aGlzLnogKz0gKCB2LnogLSB0aGlzLnogKSAqIGFscGhhO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRjcm9zczogZnVuY3Rpb24gKCB2LCB3ICkge1xuXG5cdFx0aWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjM6IC5jcm9zcygpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLmNyb3NzVmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyApO1xuXHRcdFx0cmV0dXJuIHRoaXMuY3Jvc3NWZWN0b3JzKCB2LCB3ICk7XG5cblx0XHR9XG5cblx0XHR2YXIgeCA9IHRoaXMueCwgeSA9IHRoaXMueSwgeiA9IHRoaXMuejtcblxuXHRcdHRoaXMueCA9IHkgKiB2LnogLSB6ICogdi55O1xuXHRcdHRoaXMueSA9IHogKiB2LnggLSB4ICogdi56O1xuXHRcdHRoaXMueiA9IHggKiB2LnkgLSB5ICogdi54O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRjcm9zc1ZlY3RvcnM6IGZ1bmN0aW9uICggYSwgYiApIHtcblxuXHRcdHZhciBheCA9IGEueCwgYXkgPSBhLnksIGF6ID0gYS56O1xuXHRcdHZhciBieCA9IGIueCwgYnkgPSBiLnksIGJ6ID0gYi56O1xuXG5cdFx0dGhpcy54ID0gYXkgKiBieiAtIGF6ICogYnk7XG5cdFx0dGhpcy55ID0gYXogKiBieCAtIGF4ICogYno7XG5cdFx0dGhpcy56ID0gYXggKiBieSAtIGF5ICogYng7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHByb2plY3RPblZlY3RvcjogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHYxLCBkb3Q7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XG5cblx0XHRcdGlmICggdjEgPT09IHVuZGVmaW5lZCApIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRcdFx0djEuY29weSggdmVjdG9yICkubm9ybWFsaXplKCk7XG5cblx0XHRcdGRvdCA9IHRoaXMuZG90KCB2MSApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5jb3B5KCB2MSApLm11bHRpcGx5U2NhbGFyKCBkb3QgKTtcblxuXHRcdH07XG5cblx0fSgpLFxuXG5cdHByb2plY3RPblBsYW5lOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgdjE7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBwbGFuZU5vcm1hbCApIHtcblxuXHRcdFx0aWYgKCB2MSA9PT0gdW5kZWZpbmVkICkgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0XHR2MS5jb3B5KCB0aGlzICkucHJvamVjdE9uVmVjdG9yKCBwbGFuZU5vcm1hbCApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5zdWIoIHYxICk7XG5cblx0XHR9XG5cblx0fSgpLFxuXG5cdHJlZmxlY3Q6IGZ1bmN0aW9uICgpIHtcblxuXHRcdC8vIHJlZmxlY3QgaW5jaWRlbnQgdmVjdG9yIG9mZiBwbGFuZSBvcnRob2dvbmFsIHRvIG5vcm1hbFxuXHRcdC8vIG5vcm1hbCBpcyBhc3N1bWVkIHRvIGhhdmUgdW5pdCBsZW5ndGhcblxuXHRcdHZhciB2MTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiAoIG5vcm1hbCApIHtcblxuXHRcdFx0aWYgKCB2MSA9PT0gdW5kZWZpbmVkICkgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5zdWIoIHYxLmNvcHkoIG5vcm1hbCApLm11bHRpcGx5U2NhbGFyKCAyICogdGhpcy5kb3QoIG5vcm1hbCApICkgKTtcblxuXHRcdH1cblxuXHR9KCksXG5cblx0YW5nbGVUbzogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0dmFyIHRoZXRhID0gdGhpcy5kb3QoIHYgKSAvICggdGhpcy5sZW5ndGgoKSAqIHYubGVuZ3RoKCkgKTtcblxuXHRcdC8vIGNsYW1wLCB0byBoYW5kbGUgbnVtZXJpY2FsIHByb2JsZW1zXG5cblx0XHRyZXR1cm4gTWF0aC5hY29zKCBUSFJFRS5NYXRoLmNsYW1wKCB0aGV0YSwgLSAxLCAxICkgKTtcblxuXHR9LFxuXG5cdGRpc3RhbmNlVG86IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMuZGlzdGFuY2VUb1NxdWFyZWQoIHYgKSApO1xuXG5cdH0sXG5cblx0ZGlzdGFuY2VUb1NxdWFyZWQ6IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdHZhciBkeCA9IHRoaXMueCAtIHYueDtcblx0XHR2YXIgZHkgPSB0aGlzLnkgLSB2Lnk7XG5cdFx0dmFyIGR6ID0gdGhpcy56IC0gdi56O1xuXG5cdFx0cmV0dXJuIGR4ICogZHggKyBkeSAqIGR5ICsgZHogKiBkejtcblxuXHR9LFxuXG5cdHNldEV1bGVyRnJvbVJvdGF0aW9uTWF0cml4OiBmdW5jdGlvbiAoIG0sIG9yZGVyICkge1xuXG5cdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlZlY3RvcjM6IC5zZXRFdWxlckZyb21Sb3RhdGlvbk1hdHJpeCgpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBFdWxlci5zZXRGcm9tUm90YXRpb25NYXRyaXgoKSBpbnN0ZWFkLicgKTtcblxuXHR9LFxuXG5cdHNldEV1bGVyRnJvbVF1YXRlcm5pb246IGZ1bmN0aW9uICggcSwgb3JkZXIgKSB7XG5cblx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuVmVjdG9yMzogLnNldEV1bGVyRnJvbVF1YXRlcm5pb24oKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgRXVsZXIuc2V0RnJvbVF1YXRlcm5pb24oKSBpbnN0ZWFkLicgKTtcblxuXHR9LFxuXG5cdGdldFBvc2l0aW9uRnJvbU1hdHJpeDogZnVuY3Rpb24gKCBtICkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLmdldFBvc2l0aW9uRnJvbU1hdHJpeCgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLnNldEZyb21NYXRyaXhQb3NpdGlvbigpLicgKTtcblxuXHRcdHJldHVybiB0aGlzLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbSApO1xuXG5cdH0sXG5cblx0Z2V0U2NhbGVGcm9tTWF0cml4OiBmdW5jdGlvbiAoIG0gKSB7XG5cblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IzOiAuZ2V0U2NhbGVGcm9tTWF0cml4KCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuc2V0RnJvbU1hdHJpeFNjYWxlKCkuJyApO1xuXG5cdFx0cmV0dXJuIHRoaXMuc2V0RnJvbU1hdHJpeFNjYWxlKCBtICk7XG5cdH0sXG5cblx0Z2V0Q29sdW1uRnJvbU1hdHJpeDogZnVuY3Rpb24gKCBpbmRleCwgbWF0cml4ICkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLmdldENvbHVtbkZyb21NYXRyaXgoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5zZXRGcm9tTWF0cml4Q29sdW1uKCkuJyApO1xuXG5cdFx0cmV0dXJuIHRoaXMuc2V0RnJvbU1hdHJpeENvbHVtbiggaW5kZXgsIG1hdHJpeCApO1xuXG5cdH0sXG5cblx0c2V0RnJvbU1hdHJpeFBvc2l0aW9uOiBmdW5jdGlvbiAoIG0gKSB7XG5cblx0XHR0aGlzLnggPSBtLmVsZW1lbnRzWyAxMiBdO1xuXHRcdHRoaXMueSA9IG0uZWxlbWVudHNbIDEzIF07XG5cdFx0dGhpcy56ID0gbS5lbGVtZW50c1sgMTQgXTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0RnJvbU1hdHJpeFNjYWxlOiBmdW5jdGlvbiAoIG0gKSB7XG5cblx0XHR2YXIgc3ggPSB0aGlzLnNldCggbS5lbGVtZW50c1sgMCBdLCBtLmVsZW1lbnRzWyAxIF0sIG0uZWxlbWVudHNbICAyIF0gKS5sZW5ndGgoKTtcblx0XHR2YXIgc3kgPSB0aGlzLnNldCggbS5lbGVtZW50c1sgNCBdLCBtLmVsZW1lbnRzWyA1IF0sIG0uZWxlbWVudHNbICA2IF0gKS5sZW5ndGgoKTtcblx0XHR2YXIgc3ogPSB0aGlzLnNldCggbS5lbGVtZW50c1sgOCBdLCBtLmVsZW1lbnRzWyA5IF0sIG0uZWxlbWVudHNbIDEwIF0gKS5sZW5ndGgoKTtcblxuXHRcdHRoaXMueCA9IHN4O1xuXHRcdHRoaXMueSA9IHN5O1xuXHRcdHRoaXMueiA9IHN6O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0c2V0RnJvbU1hdHJpeENvbHVtbjogZnVuY3Rpb24gKCBpbmRleCwgbWF0cml4ICkge1xuXG5cdFx0dmFyIG9mZnNldCA9IGluZGV4ICogNDtcblxuXHRcdHZhciBtZSA9IG1hdHJpeC5lbGVtZW50cztcblxuXHRcdHRoaXMueCA9IG1lWyBvZmZzZXQgXTtcblx0XHR0aGlzLnkgPSBtZVsgb2Zmc2V0ICsgMSBdO1xuXHRcdHRoaXMueiA9IG1lWyBvZmZzZXQgKyAyIF07XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0cmV0dXJuICggKCB2LnggPT09IHRoaXMueCApICYmICggdi55ID09PSB0aGlzLnkgKSAmJiAoIHYueiA9PT0gdGhpcy56ICkgKTtcblxuXHR9LFxuXG5cdGZyb21BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xuXG5cdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cblx0XHR0aGlzLnggPSBhcnJheVsgb2Zmc2V0IF07XG5cdFx0dGhpcy55ID0gYXJyYXlbIG9mZnNldCArIDEgXTtcblx0XHR0aGlzLnogPSBhcnJheVsgb2Zmc2V0ICsgMiBdO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHR0b0FycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XG5cblx0XHRpZiAoIGFycmF5ID09PSB1bmRlZmluZWQgKSBhcnJheSA9IFtdO1xuXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG5cdFx0YXJyYXlbIG9mZnNldCBdID0gdGhpcy54O1xuXHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLnk7XG5cdFx0YXJyYXlbIG9mZnNldCArIDIgXSA9IHRoaXMuejtcblxuXHRcdHJldHVybiBhcnJheTtcblxuXHR9LFxuXG5cdGZyb21BdHRyaWJ1dGU6IGZ1bmN0aW9uICggYXR0cmlidXRlLCBpbmRleCwgb2Zmc2V0ICkge1xuXG5cdCAgICBpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuXHQgICAgaW5kZXggPSBpbmRleCAqIGF0dHJpYnV0ZS5pdGVtU2l6ZSArIG9mZnNldDtcblxuXHQgICAgdGhpcy54ID0gYXR0cmlidXRlLmFycmF5WyBpbmRleCBdO1xuXHQgICAgdGhpcy55ID0gYXR0cmlidXRlLmFycmF5WyBpbmRleCArIDEgXTtcblx0ICAgIHRoaXMueiA9IGF0dHJpYnV0ZS5hcnJheVsgaW5kZXggKyAyIF07XG5cblx0ICAgIHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMyggdGhpcy54LCB0aGlzLnksIHRoaXMueiApO1xuXG5cdH1cblxufTtcbi8qKiogRU5EIFZlY3RvcjMgKioqL1xuLyoqKiBTVEFSVCBFdWxlciAqKiovXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vZXhvY29ydGV4LmNvbVxuICovXG5cblRIUkVFLkV1bGVyID0gZnVuY3Rpb24gKCB4LCB5LCB6LCBvcmRlciApIHtcblxuXHR0aGlzLl94ID0geCB8fCAwO1xuXHR0aGlzLl95ID0geSB8fCAwO1xuXHR0aGlzLl96ID0geiB8fCAwO1xuXHR0aGlzLl9vcmRlciA9IG9yZGVyIHx8IFRIUkVFLkV1bGVyLkRlZmF1bHRPcmRlcjtcblxufTtcblxuVEhSRUUuRXVsZXIuUm90YXRpb25PcmRlcnMgPSBbICdYWVonLCAnWVpYJywgJ1pYWScsICdYWlknLCAnWVhaJywgJ1pZWCcgXTtcblxuVEhSRUUuRXVsZXIuRGVmYXVsdE9yZGVyID0gJ1hZWic7XG5cblRIUkVFLkV1bGVyLnByb3RvdHlwZSA9IHtcblxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuRXVsZXIsXG5cblx0X3g6IDAsIF95OiAwLCBfejogMCwgX29yZGVyOiBUSFJFRS5FdWxlci5EZWZhdWx0T3JkZXIsXG5cblx0Z2V0IHggKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX3g7XG5cblx0fSxcblxuXHRzZXQgeCAoIHZhbHVlICkge1xuXG5cdFx0dGhpcy5feCA9IHZhbHVlO1xuXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdH0sXG5cblx0Z2V0IHkgKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX3k7XG5cblx0fSxcblxuXHRzZXQgeSAoIHZhbHVlICkge1xuXG5cdFx0dGhpcy5feSA9IHZhbHVlO1xuXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdH0sXG5cblx0Z2V0IHogKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX3o7XG5cblx0fSxcblxuXHRzZXQgeiAoIHZhbHVlICkge1xuXG5cdFx0dGhpcy5feiA9IHZhbHVlO1xuXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdH0sXG5cblx0Z2V0IG9yZGVyICgpIHtcblxuXHRcdHJldHVybiB0aGlzLl9vcmRlcjtcblxuXHR9LFxuXG5cdHNldCBvcmRlciAoIHZhbHVlICkge1xuXG5cdFx0dGhpcy5fb3JkZXIgPSB2YWx1ZTtcblx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHR9LFxuXG5cdHNldDogZnVuY3Rpb24gKCB4LCB5LCB6LCBvcmRlciApIHtcblxuXHRcdHRoaXMuX3ggPSB4O1xuXHRcdHRoaXMuX3kgPSB5O1xuXHRcdHRoaXMuX3ogPSB6O1xuXHRcdHRoaXMuX29yZGVyID0gb3JkZXIgfHwgdGhpcy5fb3JkZXI7XG5cblx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Y29weTogZnVuY3Rpb24gKCBldWxlciApIHtcblxuXHRcdHRoaXMuX3ggPSBldWxlci5feDtcblx0XHR0aGlzLl95ID0gZXVsZXIuX3k7XG5cdFx0dGhpcy5feiA9IGV1bGVyLl96O1xuXHRcdHRoaXMuX29yZGVyID0gZXVsZXIuX29yZGVyO1xuXG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldEZyb21Sb3RhdGlvbk1hdHJpeDogZnVuY3Rpb24gKCBtLCBvcmRlciwgdXBkYXRlICkge1xuXG5cdFx0dmFyIGNsYW1wID0gVEhSRUUuTWF0aC5jbGFtcDtcblxuXHRcdC8vIGFzc3VtZXMgdGhlIHVwcGVyIDN4MyBvZiBtIGlzIGEgcHVyZSByb3RhdGlvbiBtYXRyaXggKGkuZSwgdW5zY2FsZWQpXG5cblx0XHR2YXIgdGUgPSBtLmVsZW1lbnRzO1xuXHRcdHZhciBtMTEgPSB0ZVsgMCBdLCBtMTIgPSB0ZVsgNCBdLCBtMTMgPSB0ZVsgOCBdO1xuXHRcdHZhciBtMjEgPSB0ZVsgMSBdLCBtMjIgPSB0ZVsgNSBdLCBtMjMgPSB0ZVsgOSBdO1xuXHRcdHZhciBtMzEgPSB0ZVsgMiBdLCBtMzIgPSB0ZVsgNiBdLCBtMzMgPSB0ZVsgMTAgXTtcblxuXHRcdG9yZGVyID0gb3JkZXIgfHwgdGhpcy5fb3JkZXI7XG5cblx0XHRpZiAoIG9yZGVyID09PSAnWFlaJyApIHtcblxuXHRcdFx0dGhpcy5feSA9IE1hdGguYXNpbiggY2xhbXAoIG0xMywgLSAxLCAxICkgKTtcblxuXHRcdFx0aWYgKCBNYXRoLmFicyggbTEzICkgPCAwLjk5OTk5ICkge1xuXG5cdFx0XHRcdHRoaXMuX3ggPSBNYXRoLmF0YW4yKCAtIG0yMywgbTMzICk7XG5cdFx0XHRcdHRoaXMuX3ogPSBNYXRoLmF0YW4yKCAtIG0xMiwgbTExICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXRhbjIoIG0zMiwgbTIyICk7XG5cdFx0XHRcdHRoaXMuX3ogPSAwO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1lYWicgKSB7XG5cblx0XHRcdHRoaXMuX3ggPSBNYXRoLmFzaW4oIC0gY2xhbXAoIG0yMywgLSAxLCAxICkgKTtcblxuXHRcdFx0aWYgKCBNYXRoLmFicyggbTIzICkgPCAwLjk5OTk5ICkge1xuXG5cdFx0XHRcdHRoaXMuX3kgPSBNYXRoLmF0YW4yKCBtMTMsIG0zMyApO1xuXHRcdFx0XHR0aGlzLl96ID0gTWF0aC5hdGFuMiggbTIxLCBtMjIgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR0aGlzLl95ID0gTWF0aC5hdGFuMiggLSBtMzEsIG0xMSApO1xuXHRcdFx0XHR0aGlzLl96ID0gMDtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdaWFknICkge1xuXG5cdFx0XHR0aGlzLl94ID0gTWF0aC5hc2luKCBjbGFtcCggbTMyLCAtIDEsIDEgKSApO1xuXG5cdFx0XHRpZiAoIE1hdGguYWJzKCBtMzIgKSA8IDAuOTk5OTkgKSB7XG5cblx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXRhbjIoIC0gbTMxLCBtMzMgKTtcblx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXRhbjIoIC0gbTEyLCBtMjIgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR0aGlzLl95ID0gMDtcblx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXRhbjIoIG0yMSwgbTExICk7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWllYJyApIHtcblxuXHRcdFx0dGhpcy5feSA9IE1hdGguYXNpbiggLSBjbGFtcCggbTMxLCAtIDEsIDEgKSApO1xuXG5cdFx0XHRpZiAoIE1hdGguYWJzKCBtMzEgKSA8IDAuOTk5OTkgKSB7XG5cblx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXRhbjIoIG0zMiwgbTMzICk7XG5cdFx0XHRcdHRoaXMuX3ogPSBNYXRoLmF0YW4yKCBtMjEsIG0xMSApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHRoaXMuX3ggPSAwO1xuXHRcdFx0XHR0aGlzLl96ID0gTWF0aC5hdGFuMiggLSBtMTIsIG0yMiApO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1laWCcgKSB7XG5cblx0XHRcdHRoaXMuX3ogPSBNYXRoLmFzaW4oIGNsYW1wKCBtMjEsIC0gMSwgMSApICk7XG5cblx0XHRcdGlmICggTWF0aC5hYnMoIG0yMSApIDwgMC45OTk5OSApIHtcblxuXHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hdGFuMiggLSBtMjMsIG0yMiApO1xuXHRcdFx0XHR0aGlzLl95ID0gTWF0aC5hdGFuMiggLSBtMzEsIG0xMSApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHRoaXMuX3ggPSAwO1xuXHRcdFx0XHR0aGlzLl95ID0gTWF0aC5hdGFuMiggbTEzLCBtMzMgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdYWlknICkge1xuXG5cdFx0XHR0aGlzLl96ID0gTWF0aC5hc2luKCAtIGNsYW1wKCBtMTIsIC0gMSwgMSApICk7XG5cblx0XHRcdGlmICggTWF0aC5hYnMoIG0xMiApIDwgMC45OTk5OSApIHtcblxuXHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hdGFuMiggbTMyLCBtMjIgKTtcblx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXRhbjIoIG0xMywgbTExICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXRhbjIoIC0gbTIzLCBtMzMgKTtcblx0XHRcdFx0dGhpcy5feSA9IDA7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkV1bGVyOiAuc2V0RnJvbVJvdGF0aW9uTWF0cml4KCkgZ2l2ZW4gdW5zdXBwb3J0ZWQgb3JkZXI6ICcgKyBvcmRlciApXG5cblx0XHR9XG5cblx0XHR0aGlzLl9vcmRlciA9IG9yZGVyO1xuXG5cdFx0aWYgKCB1cGRhdGUgIT09IGZhbHNlICkgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldEZyb21RdWF0ZXJuaW9uOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgbWF0cml4O1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggcSwgb3JkZXIsIHVwZGF0ZSApIHtcblxuXHRcdFx0aWYgKCBtYXRyaXggPT09IHVuZGVmaW5lZCApIG1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cdFx0XHRtYXRyaXgubWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb24oIHEgKTtcblx0XHRcdHRoaXMuc2V0RnJvbVJvdGF0aW9uTWF0cml4KCBtYXRyaXgsIG9yZGVyLCB1cGRhdGUgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9O1xuXG5cdH0oKSxcblxuXHRzZXRGcm9tVmVjdG9yMzogZnVuY3Rpb24gKCB2LCBvcmRlciApIHtcblxuXHRcdHJldHVybiB0aGlzLnNldCggdi54LCB2LnksIHYueiwgb3JkZXIgfHwgdGhpcy5fb3JkZXIgKTtcblxuXHR9LFxuXG5cdHJlb3JkZXI6IGZ1bmN0aW9uICgpIHtcblxuXHRcdC8vIFdBUk5JTkc6IHRoaXMgZGlzY2FyZHMgcmV2b2x1dGlvbiBpbmZvcm1hdGlvbiAtYmhvdXN0b25cblxuXHRcdHZhciBxID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiAoIG5ld09yZGVyICkge1xuXG5cdFx0XHRxLnNldEZyb21FdWxlciggdGhpcyApO1xuXHRcdFx0dGhpcy5zZXRGcm9tUXVhdGVybmlvbiggcSwgbmV3T3JkZXIgKTtcblxuXHRcdH07XG5cblx0fSgpLFxuXG5cdGVxdWFsczogZnVuY3Rpb24gKCBldWxlciApIHtcblxuXHRcdHJldHVybiAoIGV1bGVyLl94ID09PSB0aGlzLl94ICkgJiYgKCBldWxlci5feSA9PT0gdGhpcy5feSApICYmICggZXVsZXIuX3ogPT09IHRoaXMuX3ogKSAmJiAoIGV1bGVyLl9vcmRlciA9PT0gdGhpcy5fb3JkZXIgKTtcblxuXHR9LFxuXG5cdGZyb21BcnJheTogZnVuY3Rpb24gKCBhcnJheSApIHtcblxuXHRcdHRoaXMuX3ggPSBhcnJheVsgMCBdO1xuXHRcdHRoaXMuX3kgPSBhcnJheVsgMSBdO1xuXHRcdHRoaXMuX3ogPSBhcnJheVsgMiBdO1xuXHRcdGlmICggYXJyYXlbIDMgXSAhPT0gdW5kZWZpbmVkICkgdGhpcy5fb3JkZXIgPSBhcnJheVsgMyBdO1xuXG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHRvQXJyYXk6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBbIHRoaXMuX3gsIHRoaXMuX3ksIHRoaXMuX3osIHRoaXMuX29yZGVyIF07XG5cblx0fSxcblxuXHR0b1ZlY3RvcjM6IGZ1bmN0aW9uICggb3B0aW9uYWxSZXN1bHQgKSB7XG5cblx0XHRpZiAoIG9wdGlvbmFsUmVzdWx0ICkge1xuXG5cdFx0XHRyZXR1cm4gb3B0aW9uYWxSZXN1bHQuc2V0KCB0aGlzLl94LCB0aGlzLl95LCB0aGlzLl96ICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRyZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjMoIHRoaXMuX3gsIHRoaXMuX3ksIHRoaXMuX3ogKTtcblxuXHRcdH1cblxuXHR9LFxuXG5cdG9uQ2hhbmdlOiBmdW5jdGlvbiAoIGNhbGxiYWNrICkge1xuXG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrID0gY2FsbGJhY2s7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdG9uQ2hhbmdlQ2FsbGJhY2s6IGZ1bmN0aW9uICgpIHt9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gbmV3IFRIUkVFLkV1bGVyKCB0aGlzLl94LCB0aGlzLl95LCB0aGlzLl96LCB0aGlzLl9vcmRlciApO1xuXG5cdH1cblxufTtcbi8qKiogRU5EIEV1bGVyICoqKi9cbi8qKiogU1RBUlQgTWF0aCAqKiovXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLk1hdGggPSB7XG5cblx0Z2VuZXJhdGVVVUlEOiBmdW5jdGlvbiAoKSB7XG5cblx0XHQvLyBodHRwOi8vd3d3LmJyb29mYS5jb20vVG9vbHMvTWF0aC51dWlkLmh0bVxuXG5cdFx0dmFyIGNoYXJzID0gJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6Jy5zcGxpdCggJycgKTtcblx0XHR2YXIgdXVpZCA9IG5ldyBBcnJheSggMzYgKTtcblx0XHR2YXIgcm5kID0gMCwgcjtcblxuXHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IDM2OyBpICsrICkge1xuXG5cdFx0XHRcdGlmICggaSA9PSA4IHx8IGkgPT0gMTMgfHwgaSA9PSAxOCB8fCBpID09IDIzICkge1xuXG5cdFx0XHRcdFx0dXVpZFsgaSBdID0gJy0nO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGkgPT0gMTQgKSB7XG5cblx0XHRcdFx0XHR1dWlkWyBpIF0gPSAnNCc7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGlmICggcm5kIDw9IDB4MDIgKSBybmQgPSAweDIwMDAwMDAgKyAoIE1hdGgucmFuZG9tKCkgKiAweDEwMDAwMDAgKSB8IDA7XG5cdFx0XHRcdFx0ciA9IHJuZCAmIDB4Zjtcblx0XHRcdFx0XHRybmQgPSBybmQgPj4gNDtcblx0XHRcdFx0XHR1dWlkWyBpIF0gPSBjaGFyc1sgKCBpID09IDE5ICkgPyAoIHIgJiAweDMgKSB8IDB4OCA6IHIgXTtcblxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB1dWlkLmpvaW4oICcnICk7XG5cblx0XHR9O1xuXG5cdH0oKSxcblxuXHQvLyBDbGFtcCB2YWx1ZSB0byByYW5nZSA8YSwgYj5cblxuXHRjbGFtcDogZnVuY3Rpb24gKCB4LCBhLCBiICkge1xuXG5cdFx0cmV0dXJuICggeCA8IGEgKSA/IGEgOiAoICggeCA+IGIgKSA/IGIgOiB4ICk7XG5cblx0fSxcblxuXHQvLyBDbGFtcCB2YWx1ZSB0byByYW5nZSA8YSwgaW5mKVxuXG5cdGNsYW1wQm90dG9tOiBmdW5jdGlvbiAoIHgsIGEgKSB7XG5cblx0XHRyZXR1cm4geCA8IGEgPyBhIDogeDtcblxuXHR9LFxuXG5cdC8vIExpbmVhciBtYXBwaW5nIGZyb20gcmFuZ2UgPGExLCBhMj4gdG8gcmFuZ2UgPGIxLCBiMj5cblxuXHRtYXBMaW5lYXI6IGZ1bmN0aW9uICggeCwgYTEsIGEyLCBiMSwgYjIgKSB7XG5cblx0XHRyZXR1cm4gYjEgKyAoIHggLSBhMSApICogKCBiMiAtIGIxICkgLyAoIGEyIC0gYTEgKTtcblxuXHR9LFxuXG5cdC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU21vb3Roc3RlcFxuXG5cdHNtb290aHN0ZXA6IGZ1bmN0aW9uICggeCwgbWluLCBtYXggKSB7XG5cblx0XHRpZiAoIHggPD0gbWluICkgcmV0dXJuIDA7XG5cdFx0aWYgKCB4ID49IG1heCApIHJldHVybiAxO1xuXG5cdFx0eCA9ICggeCAtIG1pbiApIC8gKCBtYXggLSBtaW4gKTtcblxuXHRcdHJldHVybiB4ICogeCAqICggMyAtIDIgKiB4ICk7XG5cblx0fSxcblxuXHRzbW9vdGhlcnN0ZXA6IGZ1bmN0aW9uICggeCwgbWluLCBtYXggKSB7XG5cblx0XHRpZiAoIHggPD0gbWluICkgcmV0dXJuIDA7XG5cdFx0aWYgKCB4ID49IG1heCApIHJldHVybiAxO1xuXG5cdFx0eCA9ICggeCAtIG1pbiApIC8gKCBtYXggLSBtaW4gKTtcblxuXHRcdHJldHVybiB4ICogeCAqIHggKiAoIHggKiAoIHggKiA2IC0gMTUgKSArIDEwICk7XG5cblx0fSxcblxuXHQvLyBSYW5kb20gZmxvYXQgZnJvbSA8MCwgMT4gd2l0aCAxNiBiaXRzIG9mIHJhbmRvbW5lc3Ncblx0Ly8gKHN0YW5kYXJkIE1hdGgucmFuZG9tKCkgY3JlYXRlcyByZXBldGl0aXZlIHBhdHRlcm5zIHdoZW4gYXBwbGllZCBvdmVyIGxhcmdlciBzcGFjZSlcblxuXHRyYW5kb20xNjogZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuICggNjUyODAgKiBNYXRoLnJhbmRvbSgpICsgMjU1ICogTWF0aC5yYW5kb20oKSApIC8gNjU1MzU7XG5cblx0fSxcblxuXHQvLyBSYW5kb20gaW50ZWdlciBmcm9tIDxsb3csIGhpZ2g+IGludGVydmFsXG5cblx0cmFuZEludDogZnVuY3Rpb24gKCBsb3csIGhpZ2ggKSB7XG5cblx0XHRyZXR1cm4gTWF0aC5mbG9vciggdGhpcy5yYW5kRmxvYXQoIGxvdywgaGlnaCApICk7XG5cblx0fSxcblxuXHQvLyBSYW5kb20gZmxvYXQgZnJvbSA8bG93LCBoaWdoPiBpbnRlcnZhbFxuXG5cdHJhbmRGbG9hdDogZnVuY3Rpb24gKCBsb3csIGhpZ2ggKSB7XG5cblx0XHRyZXR1cm4gbG93ICsgTWF0aC5yYW5kb20oKSAqICggaGlnaCAtIGxvdyApO1xuXG5cdH0sXG5cblx0Ly8gUmFuZG9tIGZsb2F0IGZyb20gPC1yYW5nZS8yLCByYW5nZS8yPiBpbnRlcnZhbFxuXG5cdHJhbmRGbG9hdFNwcmVhZDogZnVuY3Rpb24gKCByYW5nZSApIHtcblxuXHRcdHJldHVybiByYW5nZSAqICggMC41IC0gTWF0aC5yYW5kb20oKSApO1xuXG5cdH0sXG5cblx0ZGVnVG9SYWQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBkZWdyZWVUb1JhZGlhbnNGYWN0b3IgPSBNYXRoLlBJIC8gMTgwO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggZGVncmVlcyApIHtcblxuXHRcdFx0cmV0dXJuIGRlZ3JlZXMgKiBkZWdyZWVUb1JhZGlhbnNGYWN0b3I7XG5cblx0XHR9O1xuXG5cdH0oKSxcblxuXHRyYWRUb0RlZzogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHJhZGlhblRvRGVncmVlc0ZhY3RvciA9IDE4MCAvIE1hdGguUEk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCByYWRpYW5zICkge1xuXG5cdFx0XHRyZXR1cm4gcmFkaWFucyAqIHJhZGlhblRvRGVncmVlc0ZhY3RvcjtcblxuXHRcdH07XG5cblx0fSgpLFxuXG5cdGlzUG93ZXJPZlR3bzogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdHJldHVybiAoIHZhbHVlICYgKCB2YWx1ZSAtIDEgKSApID09PSAwICYmIHZhbHVlICE9PSAwO1xuXG5cdH0sXG5cblx0bmV4dFBvd2VyT2ZUd286IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHR2YWx1ZSAtLTtcblx0XHR2YWx1ZSB8PSB2YWx1ZSA+PiAxO1xuXHRcdHZhbHVlIHw9IHZhbHVlID4+IDI7XG5cdFx0dmFsdWUgfD0gdmFsdWUgPj4gNDtcblx0XHR2YWx1ZSB8PSB2YWx1ZSA+PiA4O1xuXHRcdHZhbHVlIHw9IHZhbHVlID4+IDE2O1xuXHRcdHZhbHVlICsrO1xuXG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9XG5cbn07XG5cbi8qKiogRU5EIE1hdGggKioqL1xuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gVEhSRUU7XG5cbn0se31dLDEwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxNSBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgVEhSRUUgPSBfZGVyZXFfKCcuL3RocmVlLW1hdGguanMnKTtcbnZhciBVdGlsID0gX2RlcmVxXygnLi91dGlsLmpzJyk7XG5cbnZhciBST1RBVEVfU1BFRUQgPSAwLjU7XG4vKipcbiAqIFByb3ZpZGVzIGEgcXVhdGVybmlvbiByZXNwb25zaWJsZSBmb3IgcHJlLXBhbm5pbmcgdGhlIHNjZW5lIGJlZm9yZSBmdXJ0aGVyXG4gKiB0cmFuc2Zvcm1hdGlvbnMgZHVlIHRvIGRldmljZSBzZW5zb3JzLlxuICovXG5mdW5jdGlvbiBUb3VjaFBhbm5lcigpIHtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLm9uVG91Y2hTdGFydF8uYmluZCh0aGlzKSk7XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLm9uVG91Y2hNb3ZlXy5iaW5kKHRoaXMpKTtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5vblRvdWNoRW5kXy5iaW5kKHRoaXMpKTtcblxuICB0aGlzLmlzVG91Y2hpbmcgPSBmYWxzZTtcbiAgdGhpcy5yb3RhdGVTdGFydCA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG4gIHRoaXMucm90YXRlRW5kID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcbiAgdGhpcy5yb3RhdGVEZWx0YSA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cbiAgdGhpcy50aGV0YSA9IDA7XG4gIHRoaXMub3JpZW50YXRpb24gPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xufVxuXG5Ub3VjaFBhbm5lci5wcm90b3R5cGUuZ2V0T3JpZW50YXRpb24gPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5vcmllbnRhdGlvbi5zZXRGcm9tRXVsZXIobmV3IFRIUkVFLkV1bGVyKDAsIDAsIHRoaXMudGhldGEpKTtcbiAgcmV0dXJuIHRoaXMub3JpZW50YXRpb247XG59O1xuXG5Ub3VjaFBhbm5lci5wcm90b3R5cGUucmVzZXRTZW5zb3IgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy50aGV0YSA9IDA7XG59O1xuXG5Ub3VjaFBhbm5lci5wcm90b3R5cGUub25Ub3VjaFN0YXJ0XyA9IGZ1bmN0aW9uKGUpIHtcbiAgLy8gT25seSByZXNwb25kIGlmIHRoZXJlIGlzIGV4YWN0bHkgb25lIHRvdWNoLlxuICBpZiAoZS50b3VjaGVzLmxlbmd0aCAhPSAxKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMucm90YXRlU3RhcnQuc2V0KGUudG91Y2hlc1swXS5wYWdlWCwgZS50b3VjaGVzWzBdLnBhZ2VZKTtcbiAgdGhpcy5pc1RvdWNoaW5nID0gdHJ1ZTtcbn07XG5cblRvdWNoUGFubmVyLnByb3RvdHlwZS5vblRvdWNoTW92ZV8gPSBmdW5jdGlvbihlKSB7XG4gIGlmICghdGhpcy5pc1RvdWNoaW5nKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMucm90YXRlRW5kLnNldChlLnRvdWNoZXNbMF0ucGFnZVgsIGUudG91Y2hlc1swXS5wYWdlWSk7XG4gIHRoaXMucm90YXRlRGVsdGEuc3ViVmVjdG9ycyh0aGlzLnJvdGF0ZUVuZCwgdGhpcy5yb3RhdGVTdGFydCk7XG4gIHRoaXMucm90YXRlU3RhcnQuY29weSh0aGlzLnJvdGF0ZUVuZCk7XG5cbiAgLy8gT24gaU9TLCBkaXJlY3Rpb24gaXMgaW52ZXJ0ZWQuXG4gIGlmIChVdGlsLmlzSU9TKCkpIHtcbiAgICB0aGlzLnJvdGF0ZURlbHRhLnggKj0gLTE7XG4gIH1cblxuICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmJvZHk7XG4gIHRoaXMudGhldGEgKz0gMiAqIE1hdGguUEkgKiB0aGlzLnJvdGF0ZURlbHRhLnggLyBlbGVtZW50LmNsaWVudFdpZHRoICogUk9UQVRFX1NQRUVEO1xufTtcblxuVG91Y2hQYW5uZXIucHJvdG90eXBlLm9uVG91Y2hFbmRfID0gZnVuY3Rpb24oZSkge1xuICB0aGlzLmlzVG91Y2hpbmcgPSBmYWxzZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVG91Y2hQYW5uZXI7XG5cbn0se1wiLi90aHJlZS1tYXRoLmpzXCI6OSxcIi4vdXRpbC5qc1wiOjExfV0sMTE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLypcbiAqIENvcHlyaWdodCAyMDE1IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBVdGlsID0gd2luZG93LlV0aWwgfHwge307XG5cblV0aWwuTUlOX1RJTUVTVEVQID0gMC4wMDE7XG5VdGlsLk1BWF9USU1FU1RFUCA9IDE7XG5cblV0aWwuY2xhbXAgPSBmdW5jdGlvbih2YWx1ZSwgbWluLCBtYXgpIHtcbiAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KG1pbiwgdmFsdWUpLCBtYXgpO1xufTtcblxuVXRpbC5pc0lPUyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gL2lQYWR8aVBob25lfGlQb2QvLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKTtcbn07XG5cblV0aWwuaXNGaXJlZm94QW5kcm9pZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdGaXJlZm94JykgIT09IC0xICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignQW5kcm9pZCcpICE9PSAtMTtcbn1cblxuLy8gSGVscGVyIG1ldGhvZCB0byB2YWxpZGF0ZSB0aGUgdGltZSBzdGVwcyBvZiBzZW5zb3IgdGltZXN0YW1wcy5cblV0aWwuaXNUaW1lc3RhbXBEZWx0YVZhbGlkID0gZnVuY3Rpb24odGltZXN0YW1wRGVsdGFTKSB7XG4gIGlmIChpc05hTih0aW1lc3RhbXBEZWx0YVMpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0aW1lc3RhbXBEZWx0YVMgPD0gVXRpbC5NSU5fVElNRVNURVApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHRpbWVzdGFtcERlbHRhUyA+IFV0aWwuTUFYX1RJTUVTVEVQKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFV0aWw7XG5cbn0se31dLDEyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxNSBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbnZhciBDYXJkYm9hcmRITURWUkRldmljZSA9IF9kZXJlcV8oJy4vY2FyZGJvYXJkLWhtZC12ci1kZXZpY2UuanMnKTtcbi8vdmFyIE9yaWVudGF0aW9uUG9zaXRpb25TZW5zb3JWUkRldmljZSA9IHJlcXVpcmUoJy4vb3JpZW50YXRpb24tcG9zaXRpb24tc2Vuc29yLXZyLWRldmljZS5qcycpO1xudmFyIEZ1c2lvblBvc2l0aW9uU2Vuc29yVlJEZXZpY2UgPSBfZGVyZXFfKCcuL2Z1c2lvbi1wb3NpdGlvbi1zZW5zb3ItdnItZGV2aWNlLmpzJyk7XG52YXIgTW91c2VLZXlib2FyZFBvc2l0aW9uU2Vuc29yVlJEZXZpY2UgPSBfZGVyZXFfKCcuL21vdXNlLWtleWJvYXJkLXBvc2l0aW9uLXNlbnNvci12ci1kZXZpY2UuanMnKTtcbi8vIFVuY29tbWVudCB0byBhZGQgcG9zaXRpb25hbCB0cmFja2luZyB2aWEgd2ViY2FtLlxuLy92YXIgV2ViY2FtUG9zaXRpb25TZW5zb3JWUkRldmljZSA9IHJlcXVpcmUoJy4vd2ViY2FtLXBvc2l0aW9uLXNlbnNvci12ci1kZXZpY2UuanMnKTtcbnZhciBITURWUkRldmljZSA9IF9kZXJlcV8oJy4vYmFzZS5qcycpLkhNRFZSRGV2aWNlO1xudmFyIFBvc2l0aW9uU2Vuc29yVlJEZXZpY2UgPSBfZGVyZXFfKCcuL2Jhc2UuanMnKS5Qb3NpdGlvblNlbnNvclZSRGV2aWNlO1xuXG5mdW5jdGlvbiBXZWJWUlBvbHlmaWxsKCkge1xuICB0aGlzLmRldmljZXMgPSBbXTtcblxuICBpZiAoIXRoaXMuaXNXZWJWUkF2YWlsYWJsZSgpKSB7XG4gICAgdGhpcy5lbmFibGVQb2x5ZmlsbCgpO1xuICB9XG59XG5cbldlYlZSUG9seWZpbGwucHJvdG90eXBlLmlzV2ViVlJBdmFpbGFibGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICgnZ2V0VlJEZXZpY2VzJyBpbiBuYXZpZ2F0b3IpIHx8ICgnbW96R2V0VlJEZXZpY2VzJyBpbiBuYXZpZ2F0b3IpO1xufTtcblxuXG5XZWJWUlBvbHlmaWxsLnByb3RvdHlwZS5lbmFibGVQb2x5ZmlsbCA9IGZ1bmN0aW9uKCkge1xuICAvLyBJbml0aWFsaXplIG91ciB2aXJ0dWFsIFZSIGRldmljZXMuXG4gIGlmICh0aGlzLmlzQ2FyZGJvYXJkQ29tcGF0aWJsZSgpKSB7XG4gICAgdGhpcy5kZXZpY2VzLnB1c2gobmV3IENhcmRib2FyZEhNRFZSRGV2aWNlKCkpO1xuICB9XG5cbiAgLy8gUG9seWZpbGwgdXNpbmcgdGhlIHJpZ2h0IHBvc2l0aW9uIHNlbnNvci5cbiAgaWYgKHRoaXMuaXNNb2JpbGUoKSkge1xuICAgIC8vdGhpcy5kZXZpY2VzLnB1c2gobmV3IE9yaWVudGF0aW9uUG9zaXRpb25TZW5zb3JWUkRldmljZSgpKTtcbiAgICB0aGlzLmRldmljZXMucHVzaChuZXcgRnVzaW9uUG9zaXRpb25TZW5zb3JWUkRldmljZSgpKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoIVdlYlZSQ29uZmlnLk1PVVNFX0tFWUJPQVJEX0NPTlRST0xTX0RJU0FCTEVEKSB7XG4gICAgICB0aGlzLmRldmljZXMucHVzaChuZXcgTW91c2VLZXlib2FyZFBvc2l0aW9uU2Vuc29yVlJEZXZpY2UoKSk7XG4gICAgfVxuICAgIC8vIFVuY29tbWVudCB0byBhZGQgcG9zaXRpb25hbCB0cmFja2luZyB2aWEgd2ViY2FtLlxuICAgIC8vdGhpcy5kZXZpY2VzLnB1c2gobmV3IFdlYmNhbVBvc2l0aW9uU2Vuc29yVlJEZXZpY2UoKSk7XG4gIH1cblxuICAvLyBQcm92aWRlIG5hdmlnYXRvci5nZXRWUkRldmljZXMuXG4gIG5hdmlnYXRvci5nZXRWUkRldmljZXMgPSB0aGlzLmdldFZSRGV2aWNlcy5iaW5kKHRoaXMpO1xuXG4gIC8vIFByb3ZpZGUgdGhlIENhcmRib2FyZEhNRFZSRGV2aWNlIGFuZCBQb3NpdGlvblNlbnNvclZSRGV2aWNlIG9iamVjdHMuXG4gIHdpbmRvdy5ITURWUkRldmljZSA9IEhNRFZSRGV2aWNlO1xuICB3aW5kb3cuUG9zaXRpb25TZW5zb3JWUkRldmljZSA9IFBvc2l0aW9uU2Vuc29yVlJEZXZpY2U7XG59O1xuXG5XZWJWUlBvbHlmaWxsLnByb3RvdHlwZS5nZXRWUkRldmljZXMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGRldmljZXMgPSB0aGlzLmRldmljZXM7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICB0cnkge1xuICAgICAgcmVzb2x2ZShkZXZpY2VzKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZWplY3QoZSk7XG4gICAgfVxuICB9KTtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgZGV2aWNlIGlzIG1vYmlsZS5cbiAqL1xuV2ViVlJQb2x5ZmlsbC5wcm90b3R5cGUuaXNNb2JpbGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIC9BbmRyb2lkL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSB8fFxuICAgICAgL2lQaG9uZXxpUGFkfGlQb2QvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xufTtcblxuV2ViVlJQb2x5ZmlsbC5wcm90b3R5cGUuaXNDYXJkYm9hcmRDb21wYXRpYmxlID0gZnVuY3Rpb24oKSB7XG4gIC8vIEZvciBub3csIHN1cHBvcnQgYWxsIGlPUyBhbmQgQW5kcm9pZCBkZXZpY2VzLlxuICAvLyBBbHNvIGVuYWJsZSB0aGUgV2ViVlJDb25maWcuRk9SQ0VfVlIgZmxhZyBmb3IgZGVidWdnaW5nLlxuICByZXR1cm4gdGhpcy5pc01vYmlsZSgpIHx8IFdlYlZSQ29uZmlnLkZPUkNFX0VOQUJMRV9WUjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gV2ViVlJQb2x5ZmlsbDtcblxufSx7XCIuL2Jhc2UuanNcIjoxLFwiLi9jYXJkYm9hcmQtaG1kLXZyLWRldmljZS5qc1wiOjIsXCIuL2Z1c2lvbi1wb3NpdGlvbi1zZW5zb3ItdnItZGV2aWNlLmpzXCI6NCxcIi4vbW91c2Uta2V5Ym9hcmQtcG9zaXRpb24tc2Vuc29yLXZyLWRldmljZS5qc1wiOjZ9XX0se30sWzVdKTtcblxufSx7fV0sMjQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHM9e1xuICBcIm5hbWVcIjogXCJhZnJhbWVcIixcbiAgXCJ2ZXJzaW9uXCI6IFwiMC4yLjAtcmMxXCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJCdWlsZGluZyBibG9ja3MgZm9yIHRoZSBWUiBXZWJcIixcbiAgXCJtYWluXCI6IFwiZGlzdC9hZnJhbWUuanNcIixcbiAgXCJzY3JpcHRzXCI6IHtcbiAgICBcImJyb3dzZXJpZnlcIjogXCJicm93c2VyaWZ5IHNyYy9pbmRleC5qcyAtcyAnQUZSQU1FJyAtcCBicm93c2VyaWZ5LWRlcmVxdWlyZVwiLFxuICAgIFwiYnVpbGRcIjogXCJta2RpcnAgYnVpbGQvICYmIG5wbSBydW4gYnJvd3NlcmlmeSAtLSAtLWRlYnVnIC1vIGJ1aWxkL2FmcmFtZS5qc1wiLFxuICAgIFwiZGV2XCI6IFwibnBtIHJ1biBidWlsZCAmJiBub2RlIC4vc2NyaXB0cy9idWRvXCIsXG4gICAgXCJkaXN0XCI6IFwibWtkaXJwIGRpc3QvICYmIG5wbSBydW4gYnJvd3NlcmlmeSAtcyAtLSAtLWRlYnVnIHwgZXhvcmNpc3QgZGlzdC9hZnJhbWUuanMubWFwID4gZGlzdC9hZnJhbWUuanMgJiYgdWdsaWZ5anMgZGlzdC9hZnJhbWUuanMgLWMgd2FybmluZ3M9ZmFsc2UgLW0gLW8gZGlzdC9hZnJhbWUubWluLmpzXCIsXG4gICAgXCJnaC1wYWdlc1wiOiBcIm5wbSBydW4gZ2hwYWdlc1wiLFxuICAgIFwiZ2hwYWdlc1wiOiBcIm5vZGUgLi9zY3JpcHRzL2doLXBhZ2VzXCIsXG4gICAgXCJsaW50XCI6IFwic2VtaXN0YW5kYXJkIC12IHwgc25henp5XCIsXG4gICAgXCJwcmVjb21taXRcIjogXCJucG0gcnVuIGxpbnRcIixcbiAgICBcInByZWdocGFnZXNcIjogXCJucG0gcnVuIGRpc3QgJiYgcmltcmFmIGdoLXBhZ2VzICYmIG1rZGlycCBnaC1wYWdlcyAmJiBjcCAtciB7Lm5vamVreWxsLGRpc3QsbGliLGV4YW1wbGVzLGluZGV4Lmh0bWwsc3R5bGV9IGdoLXBhZ2VzLy4gMj4vZGV2L251bGwgfHwgOiAmJiBnaXQgY2hlY2tvdXQgZGlzdC8gJiYgcmVwbGFjZSAnYnVpbGQvYWZyYW1lLmpzJyAnZGlzdC9hZnJhbWUubWluLmpzJyBnaC1wYWdlcy8gLXIgLS1zaWxlbnRcIixcbiAgICBcInJlbGVhc2U6YnVtcFwiOiBcIm5wbSBydW4gZGlzdCAmJiBnaXQgY29tbWl0IC1hbSAnYnVtcCBkaXN0JyAmJiBucG0gdmVyc2lvbiBwYXRjaCAtLXByZW1pbm9yXCIsXG4gICAgXCJyZWxlYXNlOnB1c2hcIjogXCJucG0gbG9naW4gJiYgbnBtIHB1Ymxpc2ggJiYgZ2l0IHB1c2ggLS1mb2xsb3ctdGFnc1wiLFxuICAgIFwic3RhcnRcIjogXCJucG0gcnVuIGRldlwiLFxuICAgIFwidGVzdFwiOiBcImthcm1hIHN0YXJ0IC4vdGVzdHMva2FybWEuY29uZi5qc1wiLFxuICAgIFwidGVzdDpjaVwiOiBcIlRFU1RfRU5WPWNpIGthcm1hIHN0YXJ0IC4vdGVzdHMva2FybWEuY29uZi5qcyAtLXNpbmdsZS1ydW5cIixcbiAgICBcInZlcnNpb25cIjogXCJucG0gcnVuIGRpc3RcIlxuICB9LFxuICBcInJlcG9zaXRvcnlcIjogXCJhZnJhbWV2ci9hZnJhbWVcIixcbiAgXCJsaWNlbnNlXCI6IFwiTUlUXCIsXG4gIFwiZGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcImJyb3dzZXJpZnktY3NzXCI6IFwiXjAuOC4yXCIsXG4gICAgXCJkZWJ1Z1wiOiBcIl4yLjIuMFwiLFxuICAgIFwiZGVlcC1hc3NpZ25cIjogXCJeMi4wLjBcIixcbiAgICBcImRvY3VtZW50LXJlZ2lzdGVyLWVsZW1lbnRcIjogXCJkbWFyY29zL2RvY3VtZW50LXJlZ2lzdGVyLWVsZW1lbnQjOGNjYzUzMmI3XCIsXG4gICAgXCJwcm9taXNlLXBvbHlmaWxsXCI6IFwiXjMuMS4wXCIsXG4gICAgXCJvYmplY3QtYXNzaWduXCI6IFwiXjQuMC4xXCIsXG4gICAgXCJwb2x5bWVyaXplXCI6IFwiXjEuMC4wXCIsXG4gICAgXCJwcmVzZW50XCI6IFwiMC4wLjZcIixcbiAgICBcInJlcXVlc3QtaW50ZXJ2YWxcIjogXCJeMS4wLjBcIixcbiAgICBcInN0eWxlLWF0dHJcIjogXCJeMS4wLjJcIixcbiAgICBcInRocmVlXCI6IFwiXjAuNzQuMFwiLFxuICAgIFwidHdlZW4uanNcIjogXCJeMTUuMC4wXCIsXG4gICAgXCJ3ZWJ2ci1wb2x5ZmlsbFwiOiBcImJvcmlzbXVzL3dlYnZyLXBvbHlmaWxsIzNmNDc3OTZcIlxuICB9LFxuICBcImRldkRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJicm93c2VyaWZ5XCI6IFwiXjExLjAuMVwiLFxuICAgIFwiYnJvd3NlcmlmeS1kZXJlcXVpcmVcIjogXCJeMC45LjRcIixcbiAgICBcImJ1ZG9cIjogXCJeOC4xLjBcIixcbiAgICBcImNoYWlcIjogXCJeMy41LjBcIixcbiAgICBcImNoYWktc2hhbGxvdy1kZWVwLWVxdWFsXCI6IFwiXjEuMy4wXCIsXG4gICAgXCJleG9yY2lzdFwiOiBcIl4wLjQuMFwiLFxuICAgIFwiZ2gtcGFnZXNcIjogXCJeMC42LjBcIixcbiAgICBcImh1c2t5XCI6IFwiXjAuMTAuMVwiLFxuICAgIFwia2FybWFcIjogXCJeMC4xMy4xNVwiLFxuICAgIFwia2FybWEtYnJvd3NlcmlmeVwiOiBcIl40LjQuMFwiLFxuICAgIFwia2FybWEtY2hhaS1zaGFsbG93LWRlZXAtZXF1YWxcIjogXCIwLjAuNFwiLFxuICAgIFwia2FybWEtZW52LXByZXByb2Nlc3NvclwiOiBcIl4wLjEuMVwiLFxuICAgIFwia2FybWEtZmlyZWZveC1sYXVuY2hlclwiOiBcIl4wLjEuNlwiLFxuICAgIFwia2FybWEtbW9jaGFcIjogXCJeMC4yLjBcIixcbiAgICBcImthcm1hLW1vY2hhLXJlcG9ydGVyXCI6IFwiXjEuMS4wXCIsXG4gICAgXCJrYXJtYS1zaW5vbi1jaGFpXCI6IFwiXjEuMS4wXCIsXG4gICAgXCJsb2xleFwiOiBcIl4xLjQuMFwiLFxuICAgIFwibWtkaXJwXCI6IFwiMC41LjFcIixcbiAgICBcIm1vY2hhXCI6IFwiXjIuMy4zXCIsXG4gICAgXCJtb3ppbGxhLWRvd25sb2FkXCI6IFwiXjEuMC41XCIsXG4gICAgXCJvcGVuXCI6IFwiMC4wLjVcIixcbiAgICBcInJlcGxhY2VcIjogXCJeMC4zLjBcIixcbiAgICBcInJpbXJhZlwiOiBcIjIuNS4wXCIsXG4gICAgXCJzZW1pc3RhbmRhcmRcIjogXCJeNy4wLjJcIixcbiAgICBcInNpbm9uXCI6IFwiXjEuMTcuM1wiLFxuICAgIFwic2lub24tY2hhaVwiOiBcIl4yLjguMFwiLFxuICAgIFwic25henp5XCIgOiBcIl4zLjAuMFwiLFxuICAgIFwidWdsaWZ5anNcIjogXCJeMi40LjEwXCJcbiAgfSxcbiAgXCJsaW5rXCI6IHRydWUsXG4gIFwiYnJvd3NlcmlmeVwiOiB7XG4gICAgXCJ0cmFuc2Zvcm1cIjogW1xuICAgICAgXCJicm93c2VyaWZ5LWNzc1wiLFxuICAgICAgW1xuICAgICAgICBcInBvbHltZXJpemVcIixcbiAgICAgICAge1xuICAgICAgICAgIFwibWF0Y2hcIjogXCIuKi5odG1sJFwiXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICBdXG4gIH0sXG4gIFwic2VtaXN0YW5kYXJkXCI6IHtcbiAgICBcImlnbm9yZVwiOiBbXG4gICAgICBcImJ1aWxkLyoqXCIsXG4gICAgICBcImRpc3QvKipcIixcbiAgICAgIFwiZXhhbXBsZXMvX2pzLyoqXCIsXG4gICAgICBcImV4YW1wbGVzLyoqL3NoYWRlcnMvKi5qc1wiLFxuICAgICAgXCJ2ZW5kb3IvKipcIlxuICAgIF1cbiAgfSxcbiAgXCJrZXl3b3Jkc1wiOiBbXG4gICAgXCJhZnJhbWVcIixcbiAgICBcInZyXCIsXG4gICAgXCJ3ZWJ2clwiLFxuICAgIFwiM2RcIixcbiAgICBcInRocmVlXCIsXG4gICAgXCJjb21wb25lbnRzXCIsXG4gICAgXCJlbGVtZW50c1wiXG4gIF0sXG4gIFwiYnJvd3NlcmlmeS1jc3NcIjoge1xuICAgIFwibWluaWZ5XCI6IHRydWVcbiAgfSxcbiAgXCJlbmdpbmVzXCI6IHtcbiAgICBcIm5vZGVcIjogXCI+PSAwLjEyLjdcIixcbiAgICBcIm5wbVwiOiBcIl4yLjEyLjFcIlxuICB9XG59XG5cbn0se31dLDI1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciByZWdpc3RlckNvbXBvbmVudCA9IF9kZXJlcV8oJy4uL2NvcmUvY29tcG9uZW50JykucmVnaXN0ZXJDb21wb25lbnQ7XG52YXIgVEhSRUUgPSBfZGVyZXFfKCcuLi9saWIvdGhyZWUnKTtcblxuLyoqXG4gKiBDYW1lcmEgY29tcG9uZW50LlxuICogUGFpcnMgYWxvbmcgd2l0aCBjYW1lcmEgc3lzdGVtIHRvIGhhbmRsZSB0cmFja2luZyB0aGUgYWN0aXZlIGNhbWVyYS5cbiAqL1xubW9kdWxlLmV4cG9ydHMuQ29tcG9uZW50ID0gcmVnaXN0ZXJDb21wb25lbnQoJ2NhbWVyYScsIHtcbiAgc2NoZW1hOiB7XG4gICAgYWN0aXZlOiB7IGRlZmF1bHQ6IHRydWUgfSxcbiAgICBmYXI6IHsgZGVmYXVsdDogMTAwMDAgfSxcbiAgICBmb3Y6IHsgZGVmYXVsdDogODAsIG1pbjogMCB9LFxuICAgIG5lYXI6IHsgZGVmYXVsdDogMC41LCBtaW46IDAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHRocmVlLmpzIGNhbWVyYSBhbmQgYWRkIGl0IHRvIHRoZSBlbnRpdHkuXG4gICAqIEFkZCByZWZlcmVuY2UgZnJvbSBzY2VuZSB0byB0aGlzIGVudGl0eSBhcyB0aGUgY2FtZXJhLlxuICAgKi9cbiAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBjYW1lcmEgPSB0aGlzLmNhbWVyYSA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSgpO1xuICAgIHRoaXMuZWwuc2V0T2JqZWN0M0QoJ2NhbWVyYScsIGNhbWVyYSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbW92ZSBjYW1lcmEgb24gcmVtb3ZlIChjYWxsYmFjaykuXG4gICAqL1xuICByZW1vdmU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmVsLnJlbW92ZU9iamVjdDNEKCdjYW1lcmEnKTtcbiAgfSxcblxuICAvKipcbiAgICogVXBkYXRlIHRocmVlLmpzIGNhbWVyYS5cbiAgICovXG4gIHVwZGF0ZTogZnVuY3Rpb24gKG9sZERhdGEpIHtcbiAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgIHZhciBjYW1lcmEgPSB0aGlzLmNhbWVyYTtcbiAgICB2YXIgc3lzdGVtID0gdGhpcy5zeXN0ZW07XG5cbiAgICAvLyBVcGRhdGUgcHJvcGVydGllcy5cbiAgICBjYW1lcmEuYXNwZWN0ID0gZGF0YS5hc3BlY3QgfHwgKHdpbmRvdy5pbm5lcldpZHRoIC8gd2luZG93LmlubmVySGVpZ2h0KTtcbiAgICBjYW1lcmEuZmFyID0gZGF0YS5mYXI7XG4gICAgY2FtZXJhLmZvdiA9IGRhdGEuZm92O1xuICAgIGNhbWVyYS5uZWFyID0gZGF0YS5uZWFyO1xuICAgIGNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG5cbiAgICAvLyBBY3RpdmUgcHJvcGVydHkgZGlkIG5vdCBjaGFuZ2UuXG4gICAgaWYgKG9sZERhdGEgJiYgb2xkRGF0YS5hY3RpdmUgPT09IGRhdGEuYWN0aXZlKSB7IHJldHVybjsgfVxuXG4gICAgLy8gSWYgYGFjdGl2ZWAgcHJvcGVydHkgY2hhbmdlcywgb3IgZmlyc3QgdXBkYXRlLCBoYW5kbGUgYWN0aXZlIGNhbWVyYSB3aXRoIHN5c3RlbS5cbiAgICBpZiAoZGF0YS5hY3RpdmUgJiYgc3lzdGVtLmFjdGl2ZUNhbWVyYUVsICE9PSB0aGlzLmVsKSB7XG4gICAgICAvLyBDYW1lcmEgZW5hYmxlZC4gU2V0IGNhbWVyYSB0byB0aGlzIGNhbWVyYS5cbiAgICAgIHN5c3RlbS5zZXRBY3RpdmVDYW1lcmEoZWwsIGNhbWVyYSk7XG4gICAgfSBlbHNlIGlmICghZGF0YS5hY3RpdmUgJiYgc3lzdGVtLmFjdGl2ZUNhbWVyYUVsID09PSB0aGlzLmVsKSB7XG4gICAgICAvLyBDYW1lcmEgZGlzYWJsZWQuIFNldCBjYW1lcmEgdG8gYW5vdGhlciBjYW1lcmEuXG4gICAgICBzeXN0ZW0uZGlzYWJsZUFjdGl2ZUNhbWVyYSgpO1xuICAgIH1cbiAgfVxufSk7XG5cbn0se1wiLi4vY29yZS9jb21wb25lbnRcIjo1NixcIi4uL2xpYi90aHJlZVwiOjkwfV0sMjY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIHJlZ2lzdGVyQ29tcG9uZW50ID0gX2RlcmVxXygnLi4vY29yZS9jb21wb25lbnQnKS5yZWdpc3RlckNvbXBvbmVudDtcbnZhciBUSFJFRSA9IF9kZXJlcV8oJy4uL2xpYi90aHJlZScpO1xuXG52YXIgbG9hZGVyID0gbmV3IFRIUkVFLkNvbGxhZGFMb2FkZXIoKTtcbmxvYWRlci5vcHRpb25zLmNvbnZlcnRVcEF4aXMgPSB0cnVlO1xuXG5tb2R1bGUuZXhwb3J0cy5Db21wb25lbnQgPSByZWdpc3RlckNvbXBvbmVudCgnY29sbGFkYS1tb2RlbCcsIHtcbiAgc2NoZW1hOiB7XG4gICAgdHlwZTogJ3NyYydcbiAgfSxcblxuICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5tb2RlbCA9IG51bGw7XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBlbCA9IHRoaXMuZWw7XG4gICAgdmFyIHNyYyA9IHRoaXMuZGF0YTtcblxuICAgIGlmICghc3JjKSB7IHJldHVybjsgfVxuXG4gICAgdGhpcy5yZW1vdmUoKTtcblxuICAgIGxvYWRlci5sb2FkKHNyYywgZnVuY3Rpb24gKGNvbGxhZGFNb2RlbCkge1xuICAgICAgc2VsZi5tb2RlbCA9IGNvbGxhZGFNb2RlbC5zY2VuZTtcbiAgICAgIGVsLnNldE9iamVjdDNEKCdtZXNoJywgc2VsZi5tb2RlbCk7XG4gICAgICBlbC5lbWl0KCdtb2RlbC1sb2FkZWQnLCB7Zm9ybWF0OiAnY29sbGFkYScsIG1vZGVsOiBzZWxmLm1vZGVsfSk7XG4gICAgfSk7XG4gIH0sXG5cbiAgcmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLm1vZGVsKSB7IHJldHVybjsgfVxuICAgIHRoaXMuZWwucmVtb3ZlT2JqZWN0M0QoJ21lc2gnKTtcbiAgfVxufSk7XG5cbn0se1wiLi4vY29yZS9jb21wb25lbnRcIjo1NixcIi4uL2xpYi90aHJlZVwiOjkwfV0sMjc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIHJlZ2lzdGVyQ29tcG9uZW50ID0gX2RlcmVxXygnLi4vY29yZS9jb21wb25lbnQnKS5yZWdpc3RlckNvbXBvbmVudDtcbnZhciB1dGlscyA9IF9kZXJlcV8oJy4uL3V0aWxzLycpO1xuXG5tb2R1bGUuZXhwb3J0cy5Db21wb25lbnQgPSByZWdpc3RlckNvbXBvbmVudCgnY3Vyc29yJywge1xuICBzY2hlbWE6IHtcbiAgICB0aW1lb3V0OiB7IGRlZmF1bHQ6IDE1MDAsIG1pbjogMCB9LFxuICAgIG1heERpc3RhbmNlOiB7IGRlZmF1bHQ6IDUsIG1pbjogMCB9LFxuICAgIGZ1c2U6IHsgZGVmYXVsdDogZmFsc2UgfVxuICB9LFxuXG4gIGRlcGVuZGVuY2llczogWyAncmF5Y2FzdGVyJyBdLFxuXG4gIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJheWNhc3RlciA9IHRoaXMuZWwuY29tcG9uZW50cy5yYXljYXN0ZXI7XG4gICAgLy8gVGhlIGN1cnNvciBkZWZhdWx0cyB0byBmdXNlIGluIG1vYmlsZSBlbnZpcm9ubWVudHNcbiAgICB0aGlzLnNjaGVtYS5mdXNlLmRlZmF1bHQgPSB1dGlscy5pc01vYmlsZSgpO1xuICAgIHRoaXMuYXR0YWNoRXZlbnRMaXN0ZW5lcnMoKTtcbiAgfSxcblxuICBhdHRhY2hFdmVudExpc3RlbmVyczogZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbCA9IHRoaXMuZWw7XG4gICAgdmFyIGNhbnZhcyA9IGVsLnNjZW5lRWwuY2FudmFzO1xuXG4gICAgLy8gbGlzdGVuIGZvciBjYW52YXMgdG8gbG9hZC5cbiAgICBpZiAoIWNhbnZhcykge1xuICAgICAgZWwuc2NlbmVFbC5hZGRFdmVudExpc3RlbmVyKCdyZW5kZXItdGFyZ2V0LWxvYWRlZCcsIHRoaXMuYXR0YWNoRXZlbnRMaXN0ZW5lcnMuYmluZCh0aGlzKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZURvd24uYmluZCh0aGlzKSk7XG4gICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uTW91c2VVcC5iaW5kKHRoaXMpKTtcblxuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2ludGVyc2VjdGlvbicsIHRoaXMub25JbnRlcnNlY3Rpb24uYmluZCh0aGlzKSk7XG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignaW50ZXJzZWN0aW9uY2xlYXJlZCcsIHRoaXMub25JbnRlcnNlY3Rpb25DbGVhcmVkLmJpbmQodGhpcykpO1xuICB9LFxuXG4gIG9uTW91c2VEb3duOiBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgdGhpcy5lbWl0KCdtb3VzZWRvd24nKTtcbiAgICB0aGlzLm1vdXNlRG93bkVsID0gdGhpcy5pbnRlcnNlY3RlZEVsO1xuICB9LFxuXG4gIG9uTW91c2VVcDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZW1pdCgnbW91c2V1cCcpO1xuICAgIGlmICh0aGlzLmRhdGEuZnVzZSkgeyByZXR1cm47IH1cbiAgICBpZiAoIXRoaXMuaW50ZXJzZWN0ZWRFbCkgeyByZXR1cm47IH1cbiAgICBpZiAodGhpcy5tb3VzZURvd25FbCA9PT0gdGhpcy5pbnRlcnNlY3RlZEVsKSB7XG4gICAgICB0aGlzLmVtaXQoJ2NsaWNrJyk7XG4gICAgfVxuICB9LFxuXG4gIGVtaXQ6IGZ1bmN0aW9uIChldnQpIHtcbiAgICB2YXIgaW50ZXJzZWN0ZWRFbCA9IHRoaXMuaW50ZXJzZWN0ZWRFbDtcbiAgICB0aGlzLmVsLmVtaXQoZXZ0LCB7IHRhcmdldDogdGhpcy5pbnRlcnNlY3RlZEVsIH0pO1xuICAgIGlmIChpbnRlcnNlY3RlZEVsKSB7IGludGVyc2VjdGVkRWwuZW1pdChldnQpOyB9XG4gIH0sXG5cbiAgZW1pdHRlcjogZnVuY3Rpb24gKGV2dCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmVtaXQoZXZ0KTtcbiAgICB9LmJpbmQodGhpcyk7XG4gIH0sXG5cbiAgb25JbnRlcnNlY3Rpb246IGZ1bmN0aW9uIChldnQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgdmFyIGVsID0gZXZ0LmRldGFpbC5lbDtcbiAgICB2YXIgZGlzdGFuY2UgPSBldnQuZGV0YWlsLmRpc3RhbmNlO1xuICAgIGlmICh0aGlzLmludGVyc2VjdGVkRWwgPT09IGVsKSB7IHJldHVybjsgfVxuICAgIGlmIChkaXN0YW5jZSA+PSB0aGlzLmRhdGEubWF4RGlzdGFuY2UpIHsgcmV0dXJuOyB9XG4gICAgdGhpcy5pbnRlcnNlY3RlZEVsID0gZWw7XG4gICAgZWwuYWRkU3RhdGUoJ2hvdmVyZWQnKTtcbiAgICBlbC5lbWl0KCdtb3VzZWVudGVyJyk7XG4gICAgdGhpcy5lbC5hZGRTdGF0ZSgnaG92ZXJpbmcnKTtcbiAgICBpZiAoZGF0YS50aW1lb3V0ID09PSAwKSB7IHJldHVybjsgfVxuICAgIGlmICghZGF0YS5mdXNlKSB7IHJldHVybjsgfVxuICAgIHRoaXMuZWwuYWRkU3RhdGUoJ2Z1c2luZycpO1xuICAgIHRoaXMuZnVzZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1c2UsIGRhdGEudGltZW91dCk7XG4gICAgZnVuY3Rpb24gZnVzZSAoKSB7XG4gICAgICBzZWxmLmVsLnJlbW92ZVN0YXRlKCdmdXNpbmcnKTtcbiAgICAgIHNlbGYuZW1pdCgnY2xpY2snKTtcbiAgICB9XG4gIH0sXG5cbiAgb25JbnRlcnNlY3Rpb25DbGVhcmVkOiBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgdmFyIGVsID0gZXZ0LmRldGFpbC5lbDtcbiAgICBpZiAoIWVsIHx8ICF0aGlzLmludGVyc2VjdGVkRWwpIHsgcmV0dXJuOyB9XG4gICAgZWwucmVtb3ZlU3RhdGUoJ2hvdmVyZWQnKTtcbiAgICBlbC5lbWl0KCdtb3VzZWxlYXZlJyk7XG4gICAgdGhpcy5lbC5yZW1vdmVTdGF0ZSgnaG92ZXJpbmcnKTtcbiAgICB0aGlzLmVsLnJlbW92ZVN0YXRlKCdmdXNpbmcnKTtcbiAgICB0aGlzLmludGVyc2VjdGVkRWwgPSBudWxsO1xuICAgIGNsZWFyVGltZW91dCh0aGlzLmZ1c2VUaW1lb3V0KTtcbiAgfVxufSk7XG5cbn0se1wiLi4vY29yZS9jb21wb25lbnRcIjo1NixcIi4uL3V0aWxzL1wiOjEwMn1dLDI4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBkZWJ1ZyA9IF9kZXJlcV8oJy4uL3V0aWxzL2RlYnVnJyk7XG52YXIgcmVnaXN0ZXJDb21wb25lbnQgPSBfZGVyZXFfKCcuLi9jb3JlL2NvbXBvbmVudCcpLnJlZ2lzdGVyQ29tcG9uZW50O1xudmFyIFRIUkVFID0gX2RlcmVxXygnLi4vbGliL3RocmVlJyk7XG52YXIgdXRpbHMgPSBfZGVyZXFfKCcuLi91dGlscycpO1xuXG52YXIgREVGQVVMVF9SQURJVVMgPSAxO1xudmFyIGhlbHBlck1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG52YXIgZGVnVG9SYWQgPSBUSFJFRS5NYXRoLmRlZ1RvUmFkO1xudmFyIHdhcm4gPSBkZWJ1ZygnY29tcG9uZW50czpnZW9tZXRyeTp3YXJuJyk7XG5cbi8qKlxuICogR2VvbWV0cnkgY29tcG9uZW50LiBDb21iaW5lZCB3aXRoIG1hdGVyaWFsIGNvbXBvbmVudCB0byBtYWtlIGEgbWVzaCBpbiAzRCBvYmplY3QuXG4gKi9cbm1vZHVsZS5leHBvcnRzLkNvbXBvbmVudCA9IHJlZ2lzdGVyQ29tcG9uZW50KCdnZW9tZXRyeScsIHtcbiAgc2NoZW1hOiB7XG4gICAgYXJjOiB7IGRlZmF1bHQ6IDM2MCwgaWY6IHsgcHJpbWl0aXZlOiBbJ3RvcnVzJ10gfSB9LFxuICAgIGRlcHRoOiB7IGRlZmF1bHQ6IDEsIG1pbjogMCwgaWY6IHsgcHJpbWl0aXZlOiBbJ2JveCddIH0gfSxcbiAgICBoZWlnaHQ6IHsgZGVmYXVsdDogMSwgbWluOiAwLCBpZjogeyBwcmltaXRpdmU6IFsnYm94JywgJ3BsYW5lJ10gfSB9LFxuICAgIG9wZW5FbmRlZDogeyBkZWZhdWx0OiBmYWxzZSwgaWY6IHsgcHJpbWl0aXZlOiBbJ2N5bGluZGVyJ10gfSB9LFxuICAgIHA6IHsgZGVmYXVsdDogMiwgaWY6IHsgcHJpbWl0aXZlOiBbJ3RvcnVzS25vdCddIH0sIHR5cGU6ICdpbnQnIH0sXG4gICAgcHJpbWl0aXZlOiB7XG4gICAgICBkZWZhdWx0OiAnJyxcbiAgICAgIG9uZU9mOiBbJycsICdib3gnLCAnY2lyY2xlJywgJ2N5bGluZGVyJywgJ3BsYW5lJyxcbiAgICAgICAgICAgICAgJ3JpbmcnLCAnc3BoZXJlJywgJ3RvcnVzJywgJ3RvcnVzS25vdCddIH0sXG4gICAgcTogeyBkZWZhdWx0OiAzLCBpZjogeyBwcmltaXRpdmU6IFsndG9ydXNLbm90J10gfSwgdHlwZTogJ2ludCcgfSxcbiAgICBwaGlMZW5ndGg6IHsgZGVmYXVsdDogMzYwLCBpZjogeyBwcmltaXRpdmU6IFsnc3BoZXJlJ10gfSB9LFxuICAgIHBoaVN0YXJ0OiB7IGRlZmF1bHQ6IDAsIG1pbjogMCwgaWY6IHsgcHJpbWl0aXZlOiBbJ3NwaGVyZSddIH0gfSxcbiAgICByYWRpdXM6IHsgZGVmYXVsdDogREVGQVVMVF9SQURJVVMsIG1pbjogMCwgaWY6IHsgcHJpbWl0aXZlOiBbJ2NpcmNsZScsICdjeWxpbmRlcicsICdzcGhlcmUnLCAndG9ydXMnLCAndG9ydXNLbm90J10gfSB9LFxuICAgIHJhZGl1c0JvdHRvbTogeyBkZWZhdWx0OiBERUZBVUxUX1JBRElVUywgbWluOiAwLCBpZjogeyBwcmltaXRpdmU6IFsnY3lsaW5kZXInXSB9IH0sXG4gICAgcmFkaXVzSW5uZXI6IHsgZGVmYXVsdDogMC44LCBtaW46IDAsIGlmOiB7IHByaW1pdGl2ZTogWydyaW5nJ10gfSB9LFxuICAgIHJhZGl1c091dGVyOiB7IGRlZmF1bHQ6IDEuMiwgbWluOiAwLCBpZjogeyBwcmltaXRpdmU6IFsncmluZyddIH0gfSxcbiAgICByYWRpdXNUb3A6IHsgZGVmYXVsdDogREVGQVVMVF9SQURJVVMsIGlmOiB7IHByaW1pdGl2ZTogWydjeWxpbmRlciddIH0gfSxcbiAgICByYWRpdXNUdWJ1bGFyOiB7IGRlZmF1bHQ6IDAuMiwgbWluOiAwLCBpZjogeyBwcmltaXRpdmU6IFsndG9ydXMnXSB9IH0sXG4gICAgc2NhbGVIZWlnaHQ6IHsgZGVmYXVsdDogMSwgbWluOiAwLCBpZjogeyBwcmltaXRpdmU6IFsndG9ydXNLbm90J10gfSB9LFxuICAgIHNlZ21lbnRzOiB7IGRlZmF1bHQ6IDMyLCBtaW46IDAsIGlmOiB7IHByaW1pdGl2ZTogWydjaXJjbGUnXSB9LCB0eXBlOiAnaW50JyB9LFxuICAgIHNlZ21lbnRzSGVpZ2h0OiB7IGRlZmF1bHQ6IDE4LCBtaW46IDAsIGlmOiB7IHByaW1pdGl2ZTogWydjeWxpbmRlcicsICdzcGhlcmUnXSB9LCB0eXBlOiAnaW50JyB9LFxuICAgIHNlZ21lbnRzUGhpOiB7IGRlZmF1bHQ6IDgsIG1pbjogMCwgaWY6IHsgcHJpbWl0aXZlOiBbJ3JpbmcnXSB9LCB0eXBlOiAnaW50JyB9LFxuICAgIHNlZ21lbnRzUmFkaWFsOiB7IGRlZmF1bHQ6IDM2LCBtaW46IDAsIGlmOiB7IHByaW1pdGl2ZTogWydjeWxpbmRlciddIH0sIHR5cGU6ICdpbnQnIH0sXG4gICAgc2VnbWVudHNUaGV0YTogeyBkZWZhdWx0OiAzMiwgbWluOiAwLCBpZjogeyBwcmltaXRpdmU6IFsncmluZyddIH0sIHR5cGU6ICdpbnQnIH0sXG4gICAgc2VnbWVudHNUdWJ1bGFyOiB7IGRlZmF1bHQ6IDMyLCBtaW46IDAsIGlmOiB7IHByaW1pdGl2ZTogWyd0b3J1cycsICd0b3J1c0tub3QnXSB9LCB0eXBlOiAnaW50JyB9LFxuICAgIHNlZ21lbnRzV2lkdGg6IHsgZGVmYXVsdDogMzYsIG1pbjogMCwgaWY6IHsgcHJpbWl0aXZlOiBbJ3NwaGVyZSddIH0sIHR5cGU6ICdpbnQnIH0sXG4gICAgdGhldGFMZW5ndGg6IHsgZGVmYXVsdDogMzYwLCBtaW46IDAsIGlmOiB7IHByaW1pdGl2ZTogWydjaXJjbGUnLCAnY3lsaW5kZXInLCAncmluZycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzcGhlcmUnXSB9IH0sXG4gICAgdGhldGFTdGFydDogeyBkZWZhdWx0OiAwLCBpZjogeyBwcmltaXRpdmU6IFsnY2lyY2xlJywgJ2N5bGluZGVyJywgJ3JpbmcnLCAnc3BoZXJlJ10gfSB9LFxuICAgIHRyYW5zbGF0ZTogeyB0eXBlOiAndmVjMycgfSxcbiAgICB3aWR0aDogeyBkZWZhdWx0OiAxLCBtaW46IDAsIGlmOiB7IHByaW1pdGl2ZTogWydib3gnLCAncGxhbmUnXSB9IH1cbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBnZW9tZXRyeSBvbiBldmVyeSB1cGRhdGUgYXMgdGhlcmUncyBub3QgYW4gZWFzeSB3YXkgdG9cbiAgICogdXBkYXRlIGEgZ2VvbWV0cnkgdGhhdCB3b3VsZCBiZSBmYXN0ZXIgdGhhbiBqdXN0IGNyZWF0aW5nIGEgbmV3IG9uZS5cbiAgICovXG4gIHVwZGF0ZTogZnVuY3Rpb24gKHByZXZpb3VzRGF0YSkge1xuICAgIHByZXZpb3VzRGF0YSA9IHByZXZpb3VzRGF0YSB8fCB7fTtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICB2YXIgY3VycmVudFRyYW5zbGF0ZSA9IHByZXZpb3VzRGF0YS50cmFuc2xhdGUgfHwgdGhpcy5zY2hlbWEudHJhbnNsYXRlLmRlZmF1bHQ7XG4gICAgdmFyIGRpZmYgPSB1dGlscy5kaWZmKHByZXZpb3VzRGF0YSwgZGF0YSk7XG4gICAgdmFyIG1lc2ggPSB0aGlzLmVsLmdldE9yQ3JlYXRlT2JqZWN0M0QoJ21lc2gnLCBUSFJFRS5NZXNoKTtcbiAgICB2YXIgZ2VvbWV0cnkgPSBtZXNoLmdlb21ldHJ5O1xuICAgIHZhciBnZW9tZXRyeU5lZWRzVXBkYXRlID0gIShPYmplY3Qua2V5cyhkaWZmKS5sZW5ndGggPT09IDEgJiYgJ3RyYW5zbGF0ZScgaW4gZGlmZik7XG4gICAgdmFyIHRyYW5zbGF0ZU5lZWRzVXBkYXRlID0gIXV0aWxzLmRlZXBFcXVhbChkYXRhLnRyYW5zbGF0ZSwgY3VycmVudFRyYW5zbGF0ZSk7XG5cbiAgICBpZiAoZ2VvbWV0cnlOZWVkc1VwZGF0ZSkge1xuICAgICAgZ2VvbWV0cnkgPSBtZXNoLmdlb21ldHJ5ID0gZ2V0R2VvbWV0cnkodGhpcy5kYXRhLCB0aGlzLnNjaGVtYSk7XG4gICAgfVxuICAgIGlmICh0cmFuc2xhdGVOZWVkc1VwZGF0ZSkge1xuICAgICAgYXBwbHlUcmFuc2xhdGUoZ2VvbWV0cnksIGRhdGEudHJhbnNsYXRlLCBjdXJyZW50VHJhbnNsYXRlKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgZ2VvbWV0cnkgb24gcmVtb3ZlIChjYWxsYmFjaykuXG4gICAqL1xuICByZW1vdmU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmVsLmdldE9iamVjdDNEKCdtZXNoJykuZ2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcbiAgfVxufSk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHRocmVlLmpzIGdlb21ldHJ5LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhXG4gKiBAcGFyYW0ge29iamVjdH0gc2NoZW1hXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBnZW9tZXRyeVxuICovXG5mdW5jdGlvbiBnZXRHZW9tZXRyeSAoZGF0YSwgc2NoZW1hKSB7XG4gIGlmIChkYXRhLnByaW1pdGl2ZSA9PT0gJ2N1YmUnKSB7XG4gICAgd2FybignZ2VvbWV0cnkucHJpbWl0aXZlPVwiY3ViZVwiIHNob3VsZCBiZSBcImJveFwiJyk7XG4gIH1cblxuICBzd2l0Y2ggKGRhdGEucHJpbWl0aXZlKSB7XG4gICAgY2FzZSAnYm94Jzoge1xuICAgICAgcmV0dXJuIG5ldyBUSFJFRS5Cb3hHZW9tZXRyeShkYXRhLndpZHRoLCBkYXRhLmhlaWdodCwgZGF0YS5kZXB0aCk7XG4gICAgfVxuICAgIGNhc2UgJ2NpcmNsZSc6IHtcbiAgICAgIHJldHVybiBuZXcgVEhSRUUuQ2lyY2xlR2VvbWV0cnkoXG4gICAgICAgIGRhdGEucmFkaXVzLCBkYXRhLnNlZ21lbnRzLCBkZWdUb1JhZChkYXRhLnRoZXRhU3RhcnQpLCBkZWdUb1JhZChkYXRhLnRoZXRhTGVuZ3RoKSk7XG4gICAgfVxuICAgIGNhc2UgJ2NvbmUnOiB7XG4gICAgICByZXR1cm4gbmV3IFRIUkVFLkN5bGluZGVyR2VvbWV0cnkoXG4gICAgICAgIGRhdGEucmFkaXVzVG9wLCBkYXRhLnJhZGl1c0JvdHRvbSwgZGF0YS5oZWlnaHQsXG4gICAgICAgIGRhdGEuc2VnbWVudHNSYWRpYWwsIGRhdGEuc2VnbWVudHNIZWlnaHQsXG4gICAgICAgIGRhdGEub3BlbkVuZGVkLCBkZWdUb1JhZChkYXRhLnRoZXRhU3RhcnQpLCBkZWdUb1JhZChkYXRhLnRoZXRhTGVuZ3RoKSk7XG4gICAgfVxuICAgIGNhc2UgJ2N5bGluZGVyJzoge1xuICAgICAgcmV0dXJuIG5ldyBUSFJFRS5DeWxpbmRlckdlb21ldHJ5KFxuICAgICAgICBkYXRhLnJhZGl1cywgZGF0YS5yYWRpdXMsIGRhdGEuaGVpZ2h0LFxuICAgICAgICBkYXRhLnNlZ21lbnRzUmFkaWFsLCBkYXRhLnNlZ21lbnRzSGVpZ2h0LFxuICAgICAgICBkYXRhLm9wZW5FbmRlZCwgZGVnVG9SYWQoZGF0YS50aGV0YVN0YXJ0KSwgZGVnVG9SYWQoZGF0YS50aGV0YUxlbmd0aCkpO1xuICAgIH1cbiAgICBjYXNlICdwbGFuZSc6IHtcbiAgICAgIHJldHVybiBuZXcgVEhSRUUuUGxhbmVCdWZmZXJHZW9tZXRyeShkYXRhLndpZHRoLCBkYXRhLmhlaWdodCk7XG4gICAgfVxuICAgIGNhc2UgJ3JpbmcnOiB7XG4gICAgICByZXR1cm4gbmV3IFRIUkVFLlJpbmdHZW9tZXRyeShcbiAgICAgICAgZGF0YS5yYWRpdXNJbm5lciwgZGF0YS5yYWRpdXNPdXRlciwgZGF0YS5zZWdtZW50c1RoZXRhLCBkYXRhLnNlZ21lbnRzUGhpLFxuICAgICAgICBkZWdUb1JhZChkYXRhLnRoZXRhU3RhcnQpLCBkZWdUb1JhZChkYXRhLnRoZXRhTGVuZ3RoKSk7XG4gICAgfVxuICAgIGNhc2UgJ3NwaGVyZSc6IHtcbiAgICAgIC8vIHRoZXRhTGVuZ3RoJ3MgZGVmYXVsdCBmb3Igc3BoZXJlcyBpcyBkaWZmZXJlbnQgZnJvbSB0aG9zZSBvZiB0aGUgb3RoZXIgZ2VvbWV0cmllcy5cbiAgICAgIC8vIEZvciBub3csIHdlIGRldGVjdCBpZiB0aGV0YUxlbmd0aCBpcyBleGFjdGx5IDM2MCB0byBzd2l0Y2ggdG8gYSBkaWZmZXJlbnQgZGVmYXVsdC5cbiAgICAgIGlmIChkYXRhLnRoZXRhTGVuZ3RoID09PSAzNjApIHsgZGF0YS50aGV0YUxlbmd0aCA9IDE4MDsgfVxuICAgICAgcmV0dXJuIG5ldyBUSFJFRS5TcGhlcmVCdWZmZXJHZW9tZXRyeShcbiAgICAgICAgZGF0YS5yYWRpdXMsIGRhdGEuc2VnbWVudHNXaWR0aCwgZGF0YS5zZWdtZW50c0hlaWdodCwgZGVnVG9SYWQoZGF0YS5waGlTdGFydCksXG4gICAgICAgIGRlZ1RvUmFkKGRhdGEucGhpTGVuZ3RoKSwgZGVnVG9SYWQoZGF0YS50aGV0YVN0YXJ0KSwgZGVnVG9SYWQoZGF0YS50aGV0YUxlbmd0aCkpO1xuICAgIH1cbiAgICBjYXNlICd0b3J1cyc6IHtcbiAgICAgIHJldHVybiBuZXcgVEhSRUUuVG9ydXNHZW9tZXRyeShcbiAgICAgICAgZGF0YS5yYWRpdXMsIGRhdGEucmFkaXVzVHVidWxhciAqIDIsIGRhdGEuc2VnbWVudHNSYWRpYWwsIGRhdGEuc2VnbWVudHNUdWJ1bGFyLFxuICAgICAgICBkZWdUb1JhZChkYXRhLmFyYykpO1xuICAgIH1cbiAgICBjYXNlICd0b3J1c0tub3QnOiB7XG4gICAgICByZXR1cm4gbmV3IFRIUkVFLlRvcnVzS25vdEdlb21ldHJ5KFxuICAgICAgICBkYXRhLnJhZGl1cywgZGF0YS5yYWRpdXNUdWJ1bGFyICogMiwgZGF0YS5zZWdtZW50c1JhZGlhbCwgZGF0YS5zZWdtZW50c1R1YnVsYXIsXG4gICAgICAgIGRhdGEucCwgZGF0YS5xLCBkYXRhLnNjYWxlSGVpZ2h0KTtcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgd2FybignUHJpbWl0aXZlIHR5cGUgbm90IHN1cHBvcnRlZDogJyArIGRhdGEucHJpbWl0aXZlKTtcbiAgICAgIHJldHVybiBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBUcmFuc2xhdGVzIGdlb21ldHJ5IHZlcnRpY2VzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBnZW9tZXRyeSAtIHRocmVlLmpzIGdlb21ldHJ5LlxuICogQHBhcmFtIHtvYmplY3R9IHRyYW5zbGF0ZSAtIE5ldyB0cmFuc2xhdGlvbi5cbiAqIEBwYXJhbSB7b2JqZWN0fSBjdXJyZW50VHJhbnNsYXRlIC0gQ3VycmVudGx5IGFwcGxpZWQgdHJhbnNsYXRpb24uXG4gKi9cbmZ1bmN0aW9uIGFwcGx5VHJhbnNsYXRlIChnZW9tZXRyeSwgdHJhbnNsYXRlLCBjdXJyZW50VHJhbnNsYXRlKSB7XG4gIHZhciB0cmFuc2xhdGlvbiA9IGhlbHBlck1hdHJpeC5tYWtlVHJhbnNsYXRpb24oXG4gICAgdHJhbnNsYXRlLnggLSBjdXJyZW50VHJhbnNsYXRlLngsXG4gICAgdHJhbnNsYXRlLnkgLSBjdXJyZW50VHJhbnNsYXRlLnksXG4gICAgdHJhbnNsYXRlLnogLSBjdXJyZW50VHJhbnNsYXRlLnpcbiAgKTtcbiAgZ2VvbWV0cnkuYXBwbHlNYXRyaXgodHJhbnNsYXRpb24pO1xuICBnZW9tZXRyeS52ZXJ0aWNlc05lZWRzVXBkYXRlID0gdHJ1ZTtcbn1cblxufSx7XCIuLi9jb3JlL2NvbXBvbmVudFwiOjU2LFwiLi4vbGliL3RocmVlXCI6OTAsXCIuLi91dGlsc1wiOjEwMixcIi4uL3V0aWxzL2RlYnVnXCI6MTAxfV0sMjk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuX2RlcmVxXygnLi9jYW1lcmEnKTtcbl9kZXJlcV8oJy4vY29sbGFkYS1tb2RlbCcpO1xuX2RlcmVxXygnLi9jdXJzb3InKTtcbl9kZXJlcV8oJy4vZ2VvbWV0cnknKTtcbl9kZXJlcV8oJy4vbGlnaHQnKTtcbl9kZXJlcV8oJy4vbG9vay1hdCcpO1xuX2RlcmVxXygnLi9sb29rLWNvbnRyb2xzJyk7XG5fZGVyZXFfKCcuL21hdGVyaWFsJyk7XG5fZGVyZXFfKCcuL29iai1tb2RlbCcpO1xuX2RlcmVxXygnLi9wb3NpdGlvbicpO1xuX2RlcmVxXygnLi9yYXljYXN0ZXInKTtcbl9kZXJlcV8oJy4vcm90YXRpb24nKTtcbl9kZXJlcV8oJy4vc2NhbGUnKTtcbl9kZXJlcV8oJy4vc291bmQnKTtcbl9kZXJlcV8oJy4vdmlzaWJsZScpO1xuX2RlcmVxXygnLi93YXNkLWNvbnRyb2xzJyk7XG5cbl9kZXJlcV8oJy4vc2NlbmUvY2FudmFzJyk7XG5fZGVyZXFfKCcuL3NjZW5lL2ZvZycpO1xuX2RlcmVxXygnLi9zY2VuZS9rZXlib2FyZC1zaG9ydGN1dHMnKTtcbl9kZXJlcV8oJy4vc2NlbmUvc3RhdHMnKTtcbl9kZXJlcV8oJy4vc2NlbmUvdnItbW9kZS11aScpO1xuXG4vLyBEZXByZWNhdGVkLlxuX2RlcmVxXygnLi9sb2FkZXInKTtcblxufSx7XCIuL2NhbWVyYVwiOjI1LFwiLi9jb2xsYWRhLW1vZGVsXCI6MjYsXCIuL2N1cnNvclwiOjI3LFwiLi9nZW9tZXRyeVwiOjI4LFwiLi9saWdodFwiOjMwLFwiLi9sb2FkZXJcIjozMSxcIi4vbG9vay1hdFwiOjMyLFwiLi9sb29rLWNvbnRyb2xzXCI6MzMsXCIuL21hdGVyaWFsXCI6MzQsXCIuL29iai1tb2RlbFwiOjM1LFwiLi9wb3NpdGlvblwiOjM2LFwiLi9yYXljYXN0ZXJcIjozNyxcIi4vcm90YXRpb25cIjozOCxcIi4vc2NhbGVcIjozOSxcIi4vc2NlbmUvY2FudmFzXCI6NDAsXCIuL3NjZW5lL2ZvZ1wiOjQxLFwiLi9zY2VuZS9rZXlib2FyZC1zaG9ydGN1dHNcIjo0MixcIi4vc2NlbmUvc3RhdHNcIjo0MyxcIi4vc2NlbmUvdnItbW9kZS11aVwiOjQ0LFwiLi9zb3VuZFwiOjQ1LFwiLi92aXNpYmxlXCI6NDYsXCIuL3dhc2QtY29udHJvbHNcIjo0N31dLDMwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBkaWZmID0gX2RlcmVxXygnLi4vdXRpbHMnKS5kaWZmO1xudmFyIGRlYnVnID0gX2RlcmVxXygnLi4vdXRpbHMvZGVidWcnKTtcbnZhciByZWdpc3RlckNvbXBvbmVudCA9IF9kZXJlcV8oJy4uL2NvcmUvY29tcG9uZW50JykucmVnaXN0ZXJDb21wb25lbnQ7XG52YXIgVEhSRUUgPSBfZGVyZXFfKCcuLi9saWIvdGhyZWUnKTtcblxudmFyIGRlZ1RvUmFkID0gVEhSRUUuTWF0aC5kZWdUb1JhZDtcbnZhciB3YXJuID0gZGVidWcoJ2NvbXBvbmVudHM6bGlnaHQ6d2FybicpO1xuXG4vKipcbiAqIExpZ2h0IGNvbXBvbmVudC5cbiAqL1xubW9kdWxlLmV4cG9ydHMuQ29tcG9uZW50ID0gcmVnaXN0ZXJDb21wb25lbnQoJ2xpZ2h0Jywge1xuICBzY2hlbWE6IHtcbiAgICBhbmdsZTogeyBkZWZhdWx0OiA2MCwgaWY6IHsgdHlwZTogWydzcG90J10gfSB9LFxuICAgIGNvbG9yOiB7IHR5cGU6ICdjb2xvcicgfSxcbiAgICBncm91bmRDb2xvcjogeyB0eXBlOiAnY29sb3InLCBpZjogeyB0eXBlOiBbJ2hlbWlzcGhlcmUnXSB9IH0sXG4gICAgZGVjYXk6IHsgZGVmYXVsdDogMSwgaWY6IHsgdHlwZTogWydwb2ludCcsICdzcG90J10gfSB9LFxuICAgIGRpc3RhbmNlOiB7IGRlZmF1bHQ6IDAuMCwgbWluOiAwLCBpZjogeyB0eXBlOiBbJ3BvaW50JywgJ3Nwb3QnXSB9IH0sXG4gICAgZXhwb25lbnQ6IHsgZGVmYXVsdDogMTAuMCwgaWY6IHsgdHlwZTogWydzcG90J10gfSB9LFxuICAgIGludGVuc2l0eTogeyBkZWZhdWx0OiAxLjAsIG1pbjogMCwgaWY6IHsgdHlwZTogWydkaXJlY3Rpb25hbCcsICdoZW1pc3BoZXJlJywgJ3BvaW50JywgJ3Nwb3QnXSB9IH0sXG4gICAgdHlwZTogeyBkZWZhdWx0OiAnZGlyZWN0aW9uYWwnLFxuICAgICAgICAgICAgb25lT2Y6IFsnYW1iaWVudCcsICdkaXJlY3Rpb25hbCcsICdoZW1pc3BoZXJlJywgJ3BvaW50JywgJ3Nwb3QnXVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogTm90aWZpZXMgc2NlbmUgYSBsaWdodCBoYXMgYmVlbiBhZGRlZCB0byByZW1vdmUgZGVmYXVsdCBsaWdodGluZy5cbiAgICovXG4gIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgIHRoaXMubGlnaHQgPSBudWxsO1xuICAgIHRoaXMuc3lzdGVtLnJlZ2lzdGVyTGlnaHQoZWwpO1xuICB9LFxuXG4gIC8qKlxuICAgKiAoUmUpY3JlYXRlIG9yIHVwZGF0ZSBsaWdodC5cbiAgICovXG4gIHVwZGF0ZTogZnVuY3Rpb24gKG9sZERhdGEpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICB2YXIgZGlmZkRhdGEgPSBkaWZmKGRhdGEsIG9sZERhdGEgfHwge30pO1xuICAgIHZhciBsaWdodCA9IHRoaXMubGlnaHQ7XG5cbiAgICAvLyBFeGlzdGluZyBsaWdodC5cbiAgICBpZiAobGlnaHQgJiYgISgndHlwZScgaW4gZGlmZkRhdGEpKSB7XG4gICAgICAvLyBMaWdodCB0eXBlIGhhcyBub3QgY2hhbmdlZC4gVXBkYXRlIGxpZ2h0LlxuICAgICAgT2JqZWN0LmtleXMoZGlmZkRhdGEpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBkYXRhW2tleV07XG4gICAgICAgIGlmIChbJ2NvbG9yJywgJ2dyb3VuZENvbG9yJ10uaW5kZXhPZihrZXkpICE9PSAtMSkge1xuICAgICAgICAgIHZhbHVlID0gbmV3IFRIUkVFLkNvbG9yKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBsaWdodFtrZXldID0gdmFsdWU7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBObyBsaWdodCB5ZXQgb3IgbGlnaHQgdHlwZSBoYXMgY2hhbmdlZC4gQ3JlYXRlIGFuZCBhZGQgbGlnaHQuXG4gICAgdGhpcy5zZXRMaWdodCh0aGlzLmRhdGEpO1xuICB9LFxuXG4gIHNldExpZ2h0OiBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBlbCA9IHRoaXMuZWw7XG5cbiAgICB2YXIgbmV3TGlnaHQgPSBnZXRMaWdodChkYXRhKTtcbiAgICBpZiAobmV3TGlnaHQpIHtcbiAgICAgIGlmICh0aGlzLmxpZ2h0KSB7XG4gICAgICAgIGVsLnJlbW92ZU9iamVjdDNEKCdsaWdodCcpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmxpZ2h0ID0gbmV3TGlnaHQ7XG4gICAgICB0aGlzLmxpZ2h0LmVsID0gZWw7XG4gICAgICBlbC5zZXRPYmplY3QzRCgnbGlnaHQnLCB0aGlzLmxpZ2h0KTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbW92ZSBsaWdodCBvbiByZW1vdmUgKGNhbGxiYWNrKS5cbiAgICovXG4gIHJlbW92ZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZWwucmVtb3ZlT2JqZWN0M0QoJ2xpZ2h0Jyk7XG4gIH1cbn0pO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdGhyZWUuanMgbGlnaHQgb2JqZWN0IGdpdmVuIGRhdGEgb2JqZWN0IGRlZmluaW5nIHRoZSBsaWdodC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZGF0YVxuICovXG5mdW5jdGlvbiBnZXRMaWdodCAoZGF0YSkge1xuICB2YXIgYW5nbGUgPSBkYXRhLmFuZ2xlO1xuICB2YXIgY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoZGF0YS5jb2xvcikuZ2V0SGV4KCk7XG4gIHZhciBkZWNheSA9IGRhdGEuZGVjYXk7XG4gIHZhciBkaXN0YW5jZSA9IGRhdGEuZGlzdGFuY2U7XG4gIHZhciBncm91bmRDb2xvciA9IG5ldyBUSFJFRS5Db2xvcihkYXRhLmdyb3VuZENvbG9yKS5nZXRIZXgoKTtcbiAgdmFyIGludGVuc2l0eSA9IGRhdGEuaW50ZW5zaXR5O1xuICB2YXIgdHlwZSA9IGRhdGEudHlwZTtcblxuICBzd2l0Y2ggKHR5cGUudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2FtYmllbnQnOiB7XG4gICAgICByZXR1cm4gbmV3IFRIUkVFLkFtYmllbnRMaWdodChjb2xvcik7XG4gICAgfVxuICAgIGNhc2UgJ2RpcmVjdGlvbmFsJzoge1xuICAgICAgcmV0dXJuIG5ldyBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0KGNvbG9yLCBpbnRlbnNpdHkpO1xuICAgIH1cbiAgICBjYXNlICdoZW1pc3BoZXJlJzoge1xuICAgICAgcmV0dXJuIG5ldyBUSFJFRS5IZW1pc3BoZXJlTGlnaHQoY29sb3IsIGdyb3VuZENvbG9yLCBpbnRlbnNpdHkpO1xuICAgIH1cbiAgICBjYXNlICdwb2ludCc6IHtcbiAgICAgIHJldHVybiBuZXcgVEhSRUUuUG9pbnRMaWdodChjb2xvciwgaW50ZW5zaXR5LCBkaXN0YW5jZSwgZGVjYXkpO1xuICAgIH1cbiAgICBjYXNlICdzcG90Jzoge1xuICAgICAgcmV0dXJuIG5ldyBUSFJFRS5TcG90TGlnaHQoY29sb3IsIGludGVuc2l0eSwgZGlzdGFuY2UsIGRlZ1RvUmFkKGFuZ2xlKSwgZGF0YS5leHBvbmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY2F5KTtcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgd2FybignJXMgaXMgbm90IGEgdmFsaWQgbGlnaHQgdHlwZS4gJyArXG4gICAgICAgICAgICdDaG9vc2UgZnJvbSBhbWJpZW50LCBkaXJlY3Rpb25hbCwgaGVtaXNwaGVyZSwgcG9pbnQsIHNwb3QuJywgdHlwZSk7XG4gICAgfVxuICB9XG59XG5cbn0se1wiLi4vY29yZS9jb21wb25lbnRcIjo1NixcIi4uL2xpYi90aHJlZVwiOjkwLFwiLi4vdXRpbHNcIjoxMDIsXCIuLi91dGlscy9kZWJ1Z1wiOjEwMX1dLDMxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBkZWJ1ZyA9IF9kZXJlcV8oJy4uL3V0aWxzL2RlYnVnJyk7XG52YXIgcmVnaXN0ZXJDb21wb25lbnQgPSBfZGVyZXFfKCcuLi9jb3JlL2NvbXBvbmVudCcpLnJlZ2lzdGVyQ29tcG9uZW50O1xudmFyIHBhcnNlVXJsID0gX2RlcmVxXygnLi4vdXRpbHMvc3JjLWxvYWRlcicpLnBhcnNlVXJsO1xudmFyIFRIUkVFID0gX2RlcmVxXygnLi4vbGliL3RocmVlJyk7XG5cbnZhciB3YXJuID0gZGVidWcoJ2NvbXBvbmVudHM6bG9hZGVyOndhcm4nKTtcblxubW9kdWxlLmV4cG9ydHMuQ29tcG9uZW50ID0gcmVnaXN0ZXJDb21wb25lbnQoJ2xvYWRlcicsIHtcbiAgZGVwZW5kZW5jaWVzOiBbICdtYXRlcmlhbCcgXSxcblxuICBzY2hlbWE6IHtcbiAgICBzcmM6IHsgZGVmYXVsdDogJycgfSxcbiAgICBmb3JtYXQ6IHtcbiAgICAgIGRlZmF1bHQ6ICdvYmonLFxuICAgICAgb25lT2Y6IFsnb2JqJywgJ2NvbGxhZGEnXVxuICAgIH1cbiAgfSxcblxuICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgd2FybignbG9hZGVyIGNvbXBvbmVudCBpcyBkZXByZWNhdGVkLiBVc2UgY29sbGFkYS1tb2RlbCBvciBvYmotbW9kZWwgY29tcG9uZW50IGluc3RlYWQuJyk7XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVsID0gdGhpcy5lbDtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICB2YXIgbW9kZWwgPSB0aGlzLm1vZGVsO1xuICAgIHZhciB1cmwgPSBwYXJzZVVybChkYXRhLnNyYyk7XG4gICAgdmFyIGZvcm1hdCA9IGRhdGEuZm9ybWF0O1xuICAgIGlmIChtb2RlbCkgeyBlbC5yZW1vdmVPYmplY3QzRCgnbWVzaCcpOyB9XG4gICAgaWYgKCF1cmwpIHtcbiAgICAgIHdhcm4oJ01vZGVsIFVSTCBub3QgcHJvdmlkZWQnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3dpdGNoIChmb3JtYXQpIHtcbiAgICAgIGNhc2UgJ29iaic6XG4gICAgICAgIHRoaXMubG9hZE9iaih1cmwpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2NvbGxhZGEnOlxuICAgICAgICB0aGlzLmxvYWRDb2xsYWRhKHVybCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgd2FybignTW9kZWwgZm9ybWF0IG5vdCBzdXBwb3J0ZWQnKTtcbiAgICB9XG4gIH0sXG5cbiAgbG9hZE9iajogZnVuY3Rpb24gKG9ialVybCkge1xuICAgIHZhciBlbCA9IHRoaXMuZWw7XG4gICAgdmFyIG9iakxvYWRlciA9IG5ldyBUSFJFRS5PQkpMb2FkZXIoKTtcbiAgICBvYmpMb2FkZXIubG9hZChvYmpVcmwsIGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgIHRoaXMubW9kZWwgPSBvYmplY3Q7XG4gICAgICB0aGlzLmFwcGx5TWF0ZXJpYWwoKTtcbiAgICAgIGVsLnNldE9iamVjdDNEKCdtZXNoJywgb2JqZWN0KTtcbiAgICB9KTtcbiAgfSxcblxuICBhcHBseU1hdGVyaWFsOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1hdGVyaWFsID0gdGhpcy5lbC5jb21wb25lbnRzLm1hdGVyaWFsLm1hdGVyaWFsO1xuICAgIGlmICghdGhpcy5tb2RlbCkgeyByZXR1cm47IH1cbiAgICB0aGlzLm1vZGVsLnRyYXZlcnNlKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgVEhSRUUuTWVzaCkge1xuICAgICAgICBjaGlsZC5tYXRlcmlhbCA9IG1hdGVyaWFsO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIGxvYWRDb2xsYWRhOiBmdW5jdGlvbiAodXJsKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBlbCA9IHRoaXMuZWw7XG4gICAgdmFyIGxvYWRlciA9IG5ldyBUSFJFRS5Db2xsYWRhTG9hZGVyKCk7XG4gICAgbG9hZGVyLm9wdGlvbnMuY29udmVydFVwQXhpcyA9IHRydWU7XG4gICAgbG9hZGVyLmxvYWQodXJsLCBmdW5jdGlvbiAoY29sbGFkYSkge1xuICAgICAgc2VsZi5tb2RlbCA9IGNvbGxhZGEuc2NlbmU7XG4gICAgICBlbC5zZXRPYmplY3QzRCgnbWVzaCcsIGNvbGxhZGEuc2NlbmUpO1xuICAgIH0pO1xuICB9XG59KTtcblxufSx7XCIuLi9jb3JlL2NvbXBvbmVudFwiOjU2LFwiLi4vbGliL3RocmVlXCI6OTAsXCIuLi91dGlscy9kZWJ1Z1wiOjEwMSxcIi4uL3V0aWxzL3NyYy1sb2FkZXJcIjoxMDN9XSwzMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgZGVidWcgPSBfZGVyZXFfKCcuLi91dGlscy9kZWJ1ZycpO1xudmFyIGNvb3JkaW5hdGVzID0gX2RlcmVxXygnLi4vdXRpbHMvY29vcmRpbmF0ZXMnKTtcbnZhciByZWdpc3RlckNvbXBvbmVudCA9IF9kZXJlcV8oJy4uL2NvcmUvY29tcG9uZW50JykucmVnaXN0ZXJDb21wb25lbnQ7XG52YXIgVEhSRUUgPSBfZGVyZXFfKCcuLi9saWIvdGhyZWUnKTtcblxudmFyIHdhcm4gPSBkZWJ1ZygnY29tcG9uZW50czpsb29rLWF0Ondhcm4nKTtcbnZhciBpc0Nvb3JkaW5hdGUgPSBjb29yZGluYXRlcy5pc0Nvb3JkaW5hdGU7XG5cbi8qKlxuICogTG9vay1hdCBjb21wb25lbnQuXG4gKlxuICogTW9kaWZpZXMgcm90YXRpb24gdG8gZWl0aGVyIHRyYWNrIGFub3RoZXIgZW50aXR5IE9SIGRvIGEgb25lLXRpbWUgdHVybiB0b3dhcmRzIGEgcG9zaXRpb25cbiAqIHZlY3Rvci5cbiAqXG4gKiBJZiB0cmFja2luZyBhbiBvYmplY3QgdmlhIHNldHRpbmcgdGhlIGNvbXBvbmVudCB2YWx1ZSB2aWEgYSBzZWxlY3RvciwgbG9vay1hdCB3aWxsIHJlZ2lzdGVyXG4gKiBhIGJlaGF2aW9yIHRvIHRoZSBzY2VuZSB0byB1cGRhdGUgcm90YXRpb24gb24gZXZlcnkgdGljay5cbiAqL1xubW9kdWxlLmV4cG9ydHMuQ29tcG9uZW50ID0gcmVnaXN0ZXJDb21wb25lbnQoJ2xvb2stYXQnLCB7XG4gIHNjaGVtYToge1xuICAgIGRlZmF1bHQ6ICcnLFxuXG4gICAgcGFyc2U6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgLy8gQSBzdGF0aWMgcG9zaXRpb24gdG8gbG9vayBhdC5cbiAgICAgIGlmIChpc0Nvb3JkaW5hdGUodmFsdWUpIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGNvb3JkaW5hdGVzLnBhcnNlKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIC8vIEEgc2VsZWN0b3IgdG8gYSB0YXJnZXQgZW50aXR5LlxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG5cbiAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBjb29yZGluYXRlcy5zdHJpbmdpZnkoZGF0YSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gIH0sXG5cbiAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMudGFyZ2V0M0QgPSBudWxsO1xuICAgIHRoaXMudmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgfSxcblxuICAvKipcbiAgICogSWYgdHJhY2tpbmcgYW4gb2JqZWN0LCB0aGlzIHdpbGwgYmUgY2FsbGVkIG9uIGV2ZXJ5IHRpY2suXG4gICAqIElmIGxvb2tpbmcgYXQgYSBwb3NpdGlvbiB2ZWN0b3IsIHRoaXMgd2lsbCBvbmx5IGJlIGNhbGxlZCBvbmNlICh1bnRpbCBmdXJ0aGVyIHVwZGF0ZXMpLlxuICAgKi9cbiAgdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciB0YXJnZXQgPSBzZWxmLmRhdGE7XG4gICAgdmFyIG9iamVjdDNEID0gc2VsZi5lbC5vYmplY3QzRDtcbiAgICB2YXIgdGFyZ2V0RWw7XG5cbiAgICAvLyBObyBsb25nZXIgbG9va2luZyBhdCBhbnl0aGluZyAoaS5lLiwgbG9vay1hdD1cIlwiKS5cbiAgICBpZiAoIXRhcmdldCB8fCAodHlwZW9mIHRhcmdldCA9PT0gJ29iamVjdCcgJiYgIU9iamVjdC5rZXlzKHRhcmdldCkubGVuZ3RoKSkge1xuICAgICAgcmV0dXJuIHNlbGYucmVtb3ZlKCk7XG4gICAgfVxuXG4gICAgLy8gTG9vayBhdCBhIHBvc2l0aW9uLlxuICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIG9iamVjdDNELmxvb2tBdChuZXcgVEhSRUUuVmVjdG9yMyh0YXJnZXQueCwgdGFyZ2V0LnksIHRhcmdldC56KSk7XG4gICAgfVxuXG4gICAgLy8gQXNzdW1lIHRhcmdldCBpcyBhIHN0cmluZy5cbiAgICAvLyBRdWVyeSBmb3IgdGhlIGVsZW1lbnQsIGdyYWIgaXRzIG9iamVjdDNELCB0aGVuIHJlZ2lzdGVyIGEgYmVoYXZpb3Igb24gdGhlIHNjZW5lIHRvXG4gICAgLy8gdHJhY2sgdGhlIHRhcmdldCBvbiBldmVyeSB0aWNrLlxuICAgIHRhcmdldEVsID0gc2VsZi5lbC5zY2VuZUVsLnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTtcbiAgICBpZiAoIXRhcmdldEVsKSB7XG4gICAgICB3YXJuKCdcIicgKyB0YXJnZXQgKyAnXCIgZG9lcyBub3QgcG9pbnQgdG8gYSB2YWxpZCBlbnRpdHkgdG8gbG9vay1hdCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRhcmdldEVsLmhhc0xvYWRlZCkge1xuICAgICAgcmV0dXJuIHRhcmdldEVsLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5iZWdpblRyYWNraW5nKHRhcmdldEVsKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZi5iZWdpblRyYWNraW5nKHRhcmdldEVsKTtcbiAgfSxcblxuICB0aWNrOiBmdW5jdGlvbiAodCkge1xuICAgIC8vIFRyYWNrIHRhcmdldCBvYmplY3QgcG9zaXRpb24uIERlcGVuZHMgb24gcGFyZW50IG9iamVjdCBrZWVwaW5nIGdsb2JhbCB0cmFuc2Zvcm1zIHVwXG4gICAgLy8gdG8gc3RhdGUgd2l0aCB1cGRhdGVNYXRyaXhXb3JsZCgpLiBJbiBwcmFjdGljZSwgdGhpcyBpcyBoYW5kbGVkIGJ5IHRoZSByZW5kZXJlci5cbiAgICB2YXIgdGFyZ2V0M0QgPSB0aGlzLnRhcmdldDNEO1xuICAgIGlmICh0YXJnZXQzRCkge1xuICAgICAgcmV0dXJuIHRoaXMuZWwub2JqZWN0M0QubG9va0F0KHRoaXMudmVjdG9yLnNldEZyb21NYXRyaXhQb3NpdGlvbih0YXJnZXQzRC5tYXRyaXhXb3JsZCkpO1xuICAgIH1cbiAgfSxcblxuICBiZWdpblRyYWNraW5nOiBmdW5jdGlvbiAodGFyZ2V0RWwpIHtcbiAgICB0aGlzLnRhcmdldDNEID0gdGFyZ2V0RWwub2JqZWN0M0Q7XG4gIH1cbn0pO1xuXG59LHtcIi4uL2NvcmUvY29tcG9uZW50XCI6NTYsXCIuLi9saWIvdGhyZWVcIjo5MCxcIi4uL3V0aWxzL2Nvb3JkaW5hdGVzXCI6MTAwLFwiLi4vdXRpbHMvZGVidWdcIjoxMDF9XSwzMzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgcmVnaXN0ZXJDb21wb25lbnQgPSBfZGVyZXFfKCcuLi9jb3JlL2NvbXBvbmVudCcpLnJlZ2lzdGVyQ29tcG9uZW50O1xudmFyIFRIUkVFID0gX2RlcmVxXygnLi4vbGliL3RocmVlJyk7XG5cbi8vIFRvIGF2b2lkIHJlY2FsY3VsYXRpb24gYXQgZXZlcnkgbW91c2UgbW92ZW1lbnQgdGlja1xudmFyIFBJXzIgPSBNYXRoLlBJIC8gMjtcblxubW9kdWxlLmV4cG9ydHMuQ29tcG9uZW50ID0gcmVnaXN0ZXJDb21wb25lbnQoJ2xvb2stY29udHJvbHMnLCB7XG4gIGRlcGVuZGVuY2llczogWydwb3NpdGlvbicsICdyb3RhdGlvbiddLFxuXG4gIHNjaGVtYToge1xuICAgIGVuYWJsZWQ6IHsgZGVmYXVsdDogdHJ1ZSB9XG4gIH0sXG5cbiAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucHJldmlvdXNQb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgdGhpcy5kZWx0YVBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICB0aGlzLnNldHVwTW91c2VDb250cm9scygpO1xuICAgIHRoaXMuc2V0dXBITURDb250cm9scygpO1xuICAgIHRoaXMuYmluZE1ldGhvZHMoKTtcbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuZGF0YS5lbmFibGVkKSB7IHJldHVybjsgfVxuICAgIHRoaXMuY29udHJvbHMudXBkYXRlKCk7XG4gICAgdGhpcy51cGRhdGVPcmllbnRhdGlvbigpO1xuICAgIHRoaXMudXBkYXRlUG9zaXRpb24oKTtcbiAgfSxcblxuICBwbGF5OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5wcmV2aW91c1Bvc2l0aW9uLnNldCgwLCAwLCAwKTtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXJzKCk7XG4gIH0sXG5cbiAgcGF1c2U6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXJzKCk7XG4gIH0sXG5cbiAgdGljazogZnVuY3Rpb24gKHQpIHtcbiAgICB0aGlzLnVwZGF0ZSgpO1xuICB9LFxuXG4gIHJlbW92ZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucGF1c2UoKTtcbiAgfSxcblxuICBiaW5kTWV0aG9kczogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMub25Nb3VzZURvd24gPSB0aGlzLm9uTW91c2VEb3duLmJpbmQodGhpcyk7XG4gICAgdGhpcy5vbk1vdXNlTW92ZSA9IHRoaXMub25Nb3VzZU1vdmUuYmluZCh0aGlzKTtcbiAgICB0aGlzLnJlbGVhc2VNb3VzZSA9IHRoaXMucmVsZWFzZU1vdXNlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5vblRvdWNoU3RhcnQgPSB0aGlzLm9uVG91Y2hTdGFydC5iaW5kKHRoaXMpO1xuICAgIHRoaXMub25Ub3VjaE1vdmUgPSB0aGlzLm9uVG91Y2hNb3ZlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5vblRvdWNoRW5kID0gdGhpcy5vblRvdWNoRW5kLmJpbmQodGhpcyk7XG4gIH0sXG5cbiAgc2V0dXBNb3VzZUNvbnRyb2xzOiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gVGhlIGNhbnZhcyB3aGVyZSB0aGUgc2NlbmUgaXMgcGFpbnRlZFxuICAgIHRoaXMubW91c2VEb3duID0gZmFsc2U7XG4gICAgdGhpcy5waXRjaE9iamVjdCA9IG5ldyBUSFJFRS5PYmplY3QzRCgpO1xuICAgIHRoaXMueWF3T2JqZWN0ID0gbmV3IFRIUkVFLk9iamVjdDNEKCk7XG4gICAgdGhpcy55YXdPYmplY3QucG9zaXRpb24ueSA9IDEwO1xuICAgIHRoaXMueWF3T2JqZWN0LmFkZCh0aGlzLnBpdGNoT2JqZWN0KTtcbiAgfSxcblxuICBzZXR1cEhNRENvbnRyb2xzOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5kb2xseSA9IG5ldyBUSFJFRS5PYmplY3QzRCgpO1xuICAgIHRoaXMuZXVsZXIgPSBuZXcgVEhSRUUuRXVsZXIoKTtcbiAgICB0aGlzLmNvbnRyb2xzID0gbmV3IFRIUkVFLlZSQ29udHJvbHModGhpcy5kb2xseSk7XG4gICAgdGhpcy56ZXJvUXVhdGVybmlvbiA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XG4gIH0sXG5cbiAgYWRkRXZlbnRMaXN0ZW5lcnM6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2NlbmVFbCA9IHRoaXMuZWwuc2NlbmVFbDtcbiAgICB2YXIgY2FudmFzRWwgPSBzY2VuZUVsLmNhbnZhcztcblxuICAgIC8vIGxpc3RlbiBmb3IgY2FudmFzIHRvIGxvYWQuXG4gICAgaWYgKCFjYW52YXNFbCkge1xuICAgICAgc2NlbmVFbC5hZGRFdmVudExpc3RlbmVyKCdyZW5kZXItdGFyZ2V0LWxvYWRlZCcsIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcnMuYmluZCh0aGlzKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gTW91c2UgRXZlbnRzXG4gICAgY2FudmFzRWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5vbk1vdXNlRG93biwgZmFsc2UpO1xuICAgIGNhbnZhc0VsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMub25Nb3VzZU1vdmUsIGZhbHNlKTtcbiAgICBjYW52YXNFbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5yZWxlYXNlTW91c2UsIGZhbHNlKTtcbiAgICBjYW52YXNFbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsIHRoaXMucmVsZWFzZU1vdXNlLCBmYWxzZSk7XG5cbiAgICAvLyBUb3VjaCBldmVudHNcbiAgICBjYW52YXNFbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5vblRvdWNoU3RhcnQpO1xuICAgIGNhbnZhc0VsLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMub25Ub3VjaE1vdmUpO1xuICAgIGNhbnZhc0VsLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5vblRvdWNoRW5kKTtcbiAgfSxcblxuICByZW1vdmVFdmVudExpc3RlbmVyczogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzY2VuZUVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYS1zY2VuZScpO1xuICAgIHZhciBjYW52YXNFbCA9IHNjZW5lRWwgJiYgc2NlbmVFbC5jYW52YXM7XG4gICAgaWYgKCFjYW52YXNFbCkgeyByZXR1cm47IH1cblxuICAgIC8vIE1vdXNlIEV2ZW50c1xuICAgIGNhbnZhc0VsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZURvd24pO1xuICAgIGNhbnZhc0VsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMub25Nb3VzZU1vdmUpO1xuICAgIGNhbnZhc0VsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLnJlbGVhc2VNb3VzZSk7XG4gICAgY2FudmFzRWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VvdXQnLCB0aGlzLnJlbGVhc2VNb3VzZSk7XG5cbiAgICAvLyBUb3VjaCBldmVudHNcbiAgICBjYW52YXNFbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5vblRvdWNoU3RhcnQpO1xuICAgIGNhbnZhc0VsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMub25Ub3VjaE1vdmUpO1xuICAgIGNhbnZhc0VsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5vblRvdWNoRW5kKTtcbiAgfSxcblxuICB1cGRhdGVPcmllbnRhdGlvbjogKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaG1kRXVsZXIgPSBuZXcgVEhSRUUuRXVsZXIoKTtcbiAgICBobWRFdWxlci5vcmRlciA9ICdZWFonO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcGl0Y2hPYmplY3QgPSB0aGlzLnBpdGNoT2JqZWN0O1xuICAgICAgdmFyIHlhd09iamVjdCA9IHRoaXMueWF3T2JqZWN0O1xuICAgICAgdmFyIGhtZFF1YXRlcm5pb24gPSB0aGlzLmNhbGN1bGF0ZUhNRFF1YXRlcm5pb24oKTtcbiAgICAgIGhtZEV1bGVyLnNldEZyb21RdWF0ZXJuaW9uKGhtZFF1YXRlcm5pb24pO1xuICAgICAgdGhpcy5lbC5zZXRBdHRyaWJ1dGUoJ3JvdGF0aW9uJywge1xuICAgICAgICB4OiBUSFJFRS5NYXRoLnJhZFRvRGVnKGhtZEV1bGVyLngpICsgVEhSRUUuTWF0aC5yYWRUb0RlZyhwaXRjaE9iamVjdC5yb3RhdGlvbi54KSxcbiAgICAgICAgeTogVEhSRUUuTWF0aC5yYWRUb0RlZyhobWRFdWxlci55KSArIFRIUkVFLk1hdGgucmFkVG9EZWcoeWF3T2JqZWN0LnJvdGF0aW9uLnkpLFxuICAgICAgICB6OiBUSFJFRS5NYXRoLnJhZFRvRGVnKGhtZEV1bGVyLnopXG4gICAgICB9KTtcbiAgICB9O1xuICB9KSgpLFxuXG4gIGNhbGN1bGF0ZUhNRFF1YXRlcm5pb246IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGhtZFF1YXRlcm5pb24gPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZG9sbHkgPSB0aGlzLmRvbGx5O1xuICAgICAgaWYgKCF0aGlzLnplcm9lZCAmJiAhZG9sbHkucXVhdGVybmlvbi5lcXVhbHModGhpcy56ZXJvUXVhdGVybmlvbikpIHtcbiAgICAgICAgdGhpcy56ZXJvT3JpZW50YXRpb24oKTtcbiAgICAgICAgdGhpcy56ZXJvZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaG1kUXVhdGVybmlvbi5jb3B5KHRoaXMuemVyb1F1YXRlcm5pb24pLm11bHRpcGx5KGRvbGx5LnF1YXRlcm5pb24pO1xuICAgICAgcmV0dXJuIGhtZFF1YXRlcm5pb247XG4gICAgfTtcbiAgfSkoKSxcblxuICB1cGRhdGVQb3NpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbCA9IHRoaXMuZWw7XG4gICAgdmFyIGRlbHRhUG9zaXRpb24gPSB0aGlzLmNhbGN1bGF0ZURlbHRhUG9zaXRpb24oKTtcbiAgICB2YXIgY3VycmVudFBvc2l0aW9uID0gZWwuZ2V0Q29tcHV0ZWRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJyk7XG4gICAgZWwuc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsIHtcbiAgICAgIHg6IGN1cnJlbnRQb3NpdGlvbi54ICsgZGVsdGFQb3NpdGlvbi54LFxuICAgICAgeTogY3VycmVudFBvc2l0aW9uLnkgKyBkZWx0YVBvc2l0aW9uLnksXG4gICAgICB6OiBjdXJyZW50UG9zaXRpb24ueiArIGRlbHRhUG9zaXRpb24uelxuICAgIH0pO1xuICB9LFxuXG4gIGNhbGN1bGF0ZURlbHRhUG9zaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZG9sbHkgPSB0aGlzLmRvbGx5O1xuICAgIHZhciBkZWx0YVBvc2l0aW9uID0gdGhpcy5kZWx0YVBvc2l0aW9uO1xuICAgIHZhciBwcmV2aW91c1Bvc2l0aW9uID0gdGhpcy5wcmV2aW91c1Bvc2l0aW9uO1xuICAgIGRlbHRhUG9zaXRpb24uY29weShkb2xseS5wb3NpdGlvbik7XG4gICAgZGVsdGFQb3NpdGlvbi5zdWIocHJldmlvdXNQb3NpdGlvbik7XG4gICAgcHJldmlvdXNQb3NpdGlvbi5jb3B5KGRvbGx5LnBvc2l0aW9uKTtcbiAgICByZXR1cm4gZGVsdGFQb3NpdGlvbjtcbiAgfSxcblxuICB1cGRhdGVITURRdWF0ZXJuaW9uOiAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBobWRRdWF0ZXJuaW9uID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGRvbGx5ID0gdGhpcy5kb2xseTtcbiAgICAgIHRoaXMuY29udHJvbHMudXBkYXRlKCk7XG4gICAgICBpZiAoIXRoaXMuemVyb2VkICYmICFkb2xseS5xdWF0ZXJuaW9uLmVxdWFscyh0aGlzLnplcm9RdWF0ZXJuaW9uKSkge1xuICAgICAgICB0aGlzLnplcm9PcmllbnRhdGlvbigpO1xuICAgICAgICB0aGlzLnplcm9lZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBobWRRdWF0ZXJuaW9uLmNvcHkodGhpcy56ZXJvUXVhdGVybmlvbikubXVsdGlwbHkoZG9sbHkucXVhdGVybmlvbik7XG4gICAgICByZXR1cm4gaG1kUXVhdGVybmlvbjtcbiAgICB9O1xuICB9KSgpLFxuXG4gIHplcm9PcmllbnRhdGlvbjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBldWxlciA9IG5ldyBUSFJFRS5FdWxlcigpO1xuICAgIGV1bGVyLnNldEZyb21RdWF0ZXJuaW9uKHRoaXMuZG9sbHkucXVhdGVybmlvbi5jbG9uZSgpLmludmVyc2UoKSk7XG4gICAgLy8gQ2FuY2VsIG91dCByb2xsIGFuZCBwaXRjaC4gV2Ugd2FudCB0byBvbmx5IHJlc2V0IHlhd1xuICAgIGV1bGVyLnogPSAwO1xuICAgIGV1bGVyLnggPSAwO1xuICAgIHRoaXMuemVyb1F1YXRlcm5pb24uc2V0RnJvbUV1bGVyKGV1bGVyKTtcbiAgfSxcblxuICBvbk1vdXNlTW92ZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIHBpdGNoT2JqZWN0ID0gdGhpcy5waXRjaE9iamVjdDtcbiAgICB2YXIgeWF3T2JqZWN0ID0gdGhpcy55YXdPYmplY3Q7XG4gICAgdmFyIHByZXZpb3VzTW91c2VFdmVudCA9IHRoaXMucHJldmlvdXNNb3VzZUV2ZW50O1xuXG4gICAgaWYgKCF0aGlzLm1vdXNlRG93biB8fCAhdGhpcy5kYXRhLmVuYWJsZWQpIHsgcmV0dXJuOyB9XG5cbiAgICB2YXIgbW92ZW1lbnRYID0gZXZlbnQubW92ZW1lbnRYIHx8IGV2ZW50Lm1vek1vdmVtZW50WDtcbiAgICB2YXIgbW92ZW1lbnRZID0gZXZlbnQubW92ZW1lbnRZIHx8IGV2ZW50Lm1vek1vdmVtZW50WTtcblxuICAgIGlmIChtb3ZlbWVudFggPT09IHVuZGVmaW5lZCB8fCBtb3ZlbWVudFkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbW92ZW1lbnRYID0gZXZlbnQuc2NyZWVuWCAtIHByZXZpb3VzTW91c2VFdmVudC5zY3JlZW5YO1xuICAgICAgbW92ZW1lbnRZID0gZXZlbnQuc2NyZWVuWSAtIHByZXZpb3VzTW91c2VFdmVudC5zY3JlZW5ZO1xuICAgIH1cbiAgICB0aGlzLnByZXZpb3VzTW91c2VFdmVudCA9IGV2ZW50O1xuXG4gICAgeWF3T2JqZWN0LnJvdGF0aW9uLnkgLT0gbW92ZW1lbnRYICogMC4wMDI7XG4gICAgcGl0Y2hPYmplY3Qucm90YXRpb24ueCAtPSBtb3ZlbWVudFkgKiAwLjAwMjtcbiAgICBwaXRjaE9iamVjdC5yb3RhdGlvbi54ID0gTWF0aC5tYXgoLVBJXzIsIE1hdGgubWluKFBJXzIsIHBpdGNoT2JqZWN0LnJvdGF0aW9uLngpKTtcbiAgfSxcblxuICBvbk1vdXNlRG93bjogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdGhpcy5tb3VzZURvd24gPSB0cnVlO1xuICAgIHRoaXMucHJldmlvdXNNb3VzZUV2ZW50ID0gZXZlbnQ7XG4gIH0sXG5cbiAgcmVsZWFzZU1vdXNlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5tb3VzZURvd24gPSBmYWxzZTtcbiAgfSxcblxuICBvblRvdWNoU3RhcnQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUudG91Y2hlcy5sZW5ndGggIT09IDEpIHsgcmV0dXJuOyB9XG4gICAgdGhpcy50b3VjaFN0YXJ0ID0ge1xuICAgICAgeDogZS50b3VjaGVzWzBdLnBhZ2VYLFxuICAgICAgeTogZS50b3VjaGVzWzBdLnBhZ2VZXG4gICAgfTtcbiAgICB0aGlzLnRvdWNoU3RhcnRlZCA9IHRydWU7XG4gIH0sXG5cbiAgb25Ub3VjaE1vdmU6IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIGRlbHRhWTtcbiAgICB2YXIgeWF3T2JqZWN0ID0gdGhpcy55YXdPYmplY3Q7XG4gICAgaWYgKCF0aGlzLnRvdWNoU3RhcnRlZCkgeyByZXR1cm47IH1cbiAgICBkZWx0YVkgPSAyICogTWF0aC5QSSAqIChlLnRvdWNoZXNbMF0ucGFnZVggLSB0aGlzLnRvdWNoU3RhcnQueCkgL1xuICAgICAgICAgICAgdGhpcy5lbC5zY2VuZUVsLmNhbnZhcy5jbGllbnRXaWR0aDtcbiAgICAvLyBMaW1pdHMgdG91Y2ggb3JpZW50YWlvbiB0byB0byB5YXcgKHkgYXhpcylcbiAgICB5YXdPYmplY3Qucm90YXRpb24ueSAtPSBkZWx0YVkgKiAwLjU7XG4gICAgdGhpcy50b3VjaFN0YXJ0ID0ge1xuICAgICAgeDogZS50b3VjaGVzWzBdLnBhZ2VYLFxuICAgICAgeTogZS50b3VjaGVzWzBdLnBhZ2VZXG4gICAgfTtcbiAgfSxcblxuICBvblRvdWNoRW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy50b3VjaFN0YXJ0ZWQgPSBmYWxzZTtcbiAgfVxufSk7XG5cbn0se1wiLi4vY29yZS9jb21wb25lbnRcIjo1NixcIi4uL2xpYi90aHJlZVwiOjkwfV0sMzQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLyogZ2xvYmFsIFByb21pc2UgKi9cbnZhciBkZWJ1ZyA9IF9kZXJlcV8oJy4uL3V0aWxzL2RlYnVnJyk7XG52YXIgdXRpbHMgPSBfZGVyZXFfKCcuLi91dGlscycpO1xudmFyIGNvbXBvbmVudCA9IF9kZXJlcV8oJy4uL2NvcmUvY29tcG9uZW50Jyk7XG52YXIgVEhSRUUgPSBfZGVyZXFfKCcuLi9saWIvdGhyZWUnKTtcbnZhciBzaGFkZXIgPSBfZGVyZXFfKCcuLi9jb3JlL3NoYWRlcicpO1xuXG52YXIgZXJyb3IgPSBkZWJ1ZygnY29tcG9uZW50czptYXRlcmlhbDplcnJvcicpO1xudmFyIGRpZmYgPSB1dGlscy5kaWZmO1xudmFyIHJlZ2lzdGVyQ29tcG9uZW50ID0gY29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50O1xudmFyIHNoYWRlcnMgPSBzaGFkZXIuc2hhZGVycztcbnZhciBzaGFkZXJOYW1lcyA9IHNoYWRlci5zaGFkZXJOYW1lcztcblxuLyoqXG4gKiBNYXRlcmlhbCBjb21wb25lbnQuXG4gKlxuICogQG1lbWJlciB7b2JqZWN0fSBzaGFkZXIgLSBEZXRlcm1pbmVzIGhvdyBtYXRlcmlhbCBpcyBzaGFkZWQuIERlZmF1bHRzIHRvIGBzdGFuZGFyZGAsXG4gKiAgICAgICAgIHRocmVlLmpzJ3MgaW1wbGVtZW50YXRpb24gb2YgUEJSLiBBbm90aGVyIHN0YW5kYXJkIHNoYWRpbmcgbW9kZWwgaXMgYGZsYXRgIHdoaWNoXG4gKiAgICAgICAgIHVzZXMgTWVzaEJhc2ljTWF0ZXJpYWwuXG4gKi9cbm1vZHVsZS5leHBvcnRzLkNvbXBvbmVudCA9IHJlZ2lzdGVyQ29tcG9uZW50KCdtYXRlcmlhbCcsIHtcbiAgc2NoZW1hOiB7XG4gICAgc2hhZGVyOiB7IGRlZmF1bHQ6ICdzdGFuZGFyZCcsIG9uZU9mOiBzaGFkZXJOYW1lcyB9LFxuICAgIHRyYW5zcGFyZW50OiB7IGRlZmF1bHQ6IGZhbHNlIH0sXG4gICAgb3BhY2l0eTogeyBkZWZhdWx0OiAxLjAsIG1pbjogMC4wLCBtYXg6IDEuMCB9LFxuICAgIHNpZGU6IHsgZGVmYXVsdDogJ2Zyb250Jywgb25lT2Y6IFsnZnJvbnQnLCAnYmFjaycsICdkb3VibGUnXSB9LFxuICAgIGRlcHRoVGVzdDogeyBkZWZhdWx0OiB0cnVlIH1cbiAgfSxcblxuICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5tYXRlcmlhbCA9IG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBvciBjcmVhdGUgbWF0ZXJpYWwuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fG51bGx9IG9sZERhdGFcbiAgICovXG4gIHVwZGF0ZTogZnVuY3Rpb24gKG9sZERhdGEpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICB2YXIgZGF0YURpZmYgPSBvbGREYXRhID8gZGlmZihvbGREYXRhLCBkYXRhKSA6IGRhdGE7XG5cbiAgICBpZiAoIXRoaXMuc2hhZGVyIHx8IGRhdGFEaWZmLnNoYWRlcikge1xuICAgICAgdGhpcy51cGRhdGVTaGFkZXIoZGF0YS5zaGFkZXIpO1xuICAgIH1cbiAgICB0aGlzLnNoYWRlci51cGRhdGUodGhpcy5kYXRhKTtcbiAgICB0aGlzLnVwZGF0ZU1hdGVyaWFsKCk7XG4gIH0sXG5cbiAgdXBkYXRlU2NoZW1hOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBuZXdTaGFkZXIgPSBkYXRhLnNoYWRlcjtcbiAgICB2YXIgY3VycmVudFNoYWRlciA9IHRoaXMuZGF0YSAmJiB0aGlzLmRhdGEuc2hhZGVyO1xuICAgIHZhciBzaGFkZXIgPSBuZXdTaGFkZXIgfHwgY3VycmVudFNoYWRlcjtcbiAgICB2YXIgc2NoZW1hID0gc2hhZGVyc1tzaGFkZXJdICYmIHNoYWRlcnNbc2hhZGVyXS5zY2hlbWE7XG4gICAgaWYgKCFzY2hlbWEpIHsgZXJyb3IoJ1Vua25vd24gc2hhZGVyIHNjaGVtYSAnICsgc2hhZGVyKTsgfVxuICAgIGlmIChjdXJyZW50U2hhZGVyICYmIG5ld1NoYWRlciA9PT0gY3VycmVudFNoYWRlcikgeyByZXR1cm47IH1cbiAgICB0aGlzLmV4dGVuZFNjaGVtYShzY2hlbWEpO1xuICAgIHRoaXMudXBkYXRlQmVoYXZpb3IoKTtcbiAgfSxcblxuICB1cGRhdGVCZWhhdmlvcjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzY2VuZSA9IHRoaXMuZWwuc2NlbmVFbDtcbiAgICB2YXIgc2NoZW1hID0gdGhpcy5zY2hlbWE7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciB0aWNrUHJvcGVydGllcyA9IHt9O1xuICAgIHZhciB0aWNrID0gZnVuY3Rpb24gKHRpbWUsIGRlbHRhKSB7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHRpY2tQcm9wZXJ0aWVzKTtcbiAgICAgIGtleXMuZm9yRWFjaCh1cGRhdGUpO1xuICAgICAgZnVuY3Rpb24gdXBkYXRlIChrZXkpIHsgdGlja1Byb3BlcnRpZXNba2V5XSA9IHRpbWU7IH1cbiAgICAgIHNlbGYuc2hhZGVyLnVwZGF0ZSh0aWNrUHJvcGVydGllcyk7XG4gICAgfTtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHNjaGVtYSk7XG4gICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGlmIChzY2hlbWFba2V5XS50eXBlID09PSAndGltZScpIHtcbiAgICAgICAgc2VsZi50aWNrID0gdGljaztcbiAgICAgICAgdGlja1Byb3BlcnRpZXNba2V5XSA9IHRydWU7XG4gICAgICAgIHNjZW5lLmFkZEJlaGF2aW9yKHNlbGYpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChPYmplY3Qua2V5cyh0aWNrUHJvcGVydGllcykubGVuZ3RoID09PSAwKSB7XG4gICAgICBzY2VuZS5yZW1vdmVCZWhhdmlvcih0aGlzKTtcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlU2hhZGVyOiBmdW5jdGlvbiAoc2hhZGVyTmFtZSkge1xuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgIHZhciBTaGFkZXIgPSBzaGFkZXJzW3NoYWRlck5hbWVdICYmIHNoYWRlcnNbc2hhZGVyTmFtZV0uU2hhZGVyO1xuICAgIHZhciBtYXRlcmlhbDtcbiAgICBpZiAoIVNoYWRlcikgeyB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gc2hhZGVyICcgKyBzaGFkZXJOYW1lKTsgfVxuICAgIHRoaXMuc2hhZGVyID0gbmV3IFNoYWRlcigpO1xuICAgIHRoaXMuc2hhZGVyLmVsID0gdGhpcy5lbDtcbiAgICBtYXRlcmlhbCA9IHRoaXMuc2hhZGVyLmluaXQoZGF0YSk7XG4gICAgdGhpcy5zZXRNYXRlcmlhbChtYXRlcmlhbCk7XG4gICAgdGhpcy51cGRhdGVTY2hlbWEoZGF0YSk7XG4gIH0sXG5cbiAgdXBkYXRlTWF0ZXJpYWw6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICB2YXIgbWF0ZXJpYWwgPSB0aGlzLm1hdGVyaWFsO1xuICAgIG1hdGVyaWFsLnNpZGUgPSBwYXJzZVNpZGUoZGF0YS5zaWRlKTtcbiAgICBtYXRlcmlhbC5vcGFjaXR5ID0gZGF0YS5vcGFjaXR5O1xuICAgIG1hdGVyaWFsLnRyYW5zcGFyZW50ID0gZGF0YS50cmFuc3BhcmVudCAhPT0gZmFsc2UgfHwgZGF0YS5vcGFjaXR5IDwgMS4wO1xuICAgIG1hdGVyaWFsLmRlcHRoVGVzdCA9IGRhdGEuZGVwdGhUZXN0ICE9PSBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogUmVtb3ZlIG1hdGVyaWFsIG9uIHJlbW92ZSAoY2FsbGJhY2spLlxuICAgKi9cbiAgcmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRlZmF1bHRNYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCgpO1xuICAgIHZhciBvYmplY3QzRCA9IHRoaXMuZWwuZ2V0T2JqZWN0M0QoJ21lc2gnKTtcbiAgICBpZiAob2JqZWN0M0QpIHsgb2JqZWN0M0QubWF0ZXJpYWwgPSBkZWZhdWx0TWF0ZXJpYWw7IH1cbiAgICB0aGlzLnN5c3RlbS51bnJlZ2lzdGVyTWF0ZXJpYWwodGhpcy5tYXRlcmlhbCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIChSZSljcmVhdGUgbmV3IG1hdGVyaWFsLiBIYXMgc2lkZS1lZmZlY3RzIG9mIHNldHRpbmcgYHRoaXMubWF0ZXJpYWxgIGFuZCB1cGRhdGluZ1xuICAgKiBtYXRlcmlhbCByZWdpc3RyYXRpb24gaW4gc2NlbmUuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhIC0gTWF0ZXJpYWwgY29tcG9uZW50IGRhdGEuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSB0eXBlIC0gTWF0ZXJpYWwgdHlwZSB0byBjcmVhdGUuXG4gICAqIEByZXR1cm5zIHtvYmplY3R9IE1hdGVyaWFsLlxuICAgKi9cbiAgc2V0TWF0ZXJpYWw6IGZ1bmN0aW9uIChtYXRlcmlhbCkge1xuICAgIHZhciBtZXNoID0gdGhpcy5lbC5nZXRPckNyZWF0ZU9iamVjdDNEKCdtZXNoJywgVEhSRUUuTWVzaCk7XG4gICAgdmFyIHN5c3RlbSA9IHRoaXMuc3lzdGVtO1xuICAgIGlmICh0aGlzLm1hdGVyaWFsKSB7IHN5c3RlbS51bnJlZ2lzdGVyTWF0ZXJpYWwodGhpcy5tYXRlcmlhbCk7IH1cbiAgICB0aGlzLm1hdGVyaWFsID0gbWVzaC5tYXRlcmlhbCA9IG1hdGVyaWFsO1xuICAgIHN5c3RlbS5yZWdpc3Rlck1hdGVyaWFsKG1hdGVyaWFsKTtcbiAgfVxufSk7XG5cbi8qKlxuICogUmV0dXJucyBhIHRocmVlLmpzIGNvbnN0YW50IGRldGVybWluaW5nIHdoaWNoIG1hdGVyaWFsIGZhY2Ugc2lkZXMgdG8gcmVuZGVyXG4gKiBiYXNlZCBvbiB0aGUgc2lkZSBwYXJhbWV0ZXIgKHBhc3NlZCBhcyBhIGNvbXBvbmVudCBwcm9wZXJ0eSkuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtzaWRlPWZyb250XSAtIGBmcm9udGAsIGBiYWNrYCwgb3IgYGRvdWJsZWAuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBUSFJFRS5Gcm9udFNpZGUsIFRIUkVFLkJhY2tTaWRlLCBvciBUSFJFRS5Eb3VibGVTaWRlLlxuICovXG5mdW5jdGlvbiBwYXJzZVNpZGUgKHNpZGUpIHtcbiAgc3dpdGNoIChzaWRlKSB7XG4gICAgY2FzZSAnYmFjayc6IHtcbiAgICAgIHJldHVybiBUSFJFRS5CYWNrU2lkZTtcbiAgICB9XG4gICAgY2FzZSAnZG91YmxlJzoge1xuICAgICAgcmV0dXJuIFRIUkVFLkRvdWJsZVNpZGU7XG4gICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIC8vIEluY2x1ZGluZyBjYXNlIGBmcm9udGAuXG4gICAgICByZXR1cm4gVEhSRUUuRnJvbnRTaWRlO1xuICAgIH1cbiAgfVxufVxuXG59LHtcIi4uL2NvcmUvY29tcG9uZW50XCI6NTYsXCIuLi9jb3JlL3NoYWRlclwiOjYzLFwiLi4vbGliL3RocmVlXCI6OTAsXCIuLi91dGlsc1wiOjEwMixcIi4uL3V0aWxzL2RlYnVnXCI6MTAxfV0sMzU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLyogZ2xvYmFsIEhUTUxFbGVtZW50ICovXG52YXIgZGVidWcgPSBfZGVyZXFfKCcuLi91dGlscy9kZWJ1ZycpO1xudmFyIHJlZ2lzdGVyQ29tcG9uZW50ID0gX2RlcmVxXygnLi4vY29yZS9jb21wb25lbnQnKS5yZWdpc3RlckNvbXBvbmVudDtcbnZhciBUSFJFRSA9IF9kZXJlcV8oJy4uL2xpYi90aHJlZScpO1xuXG52YXIgd2FybiA9IGRlYnVnKCdjb21wb25lbnRzOm9iai1tb2RlbDp3YXJuJyk7XG5cbm1vZHVsZS5leHBvcnRzLkNvbXBvbmVudCA9IHJlZ2lzdGVyQ29tcG9uZW50KCdvYmotbW9kZWwnLCB7XG4gIGRlcGVuZGVuY2llczogWydtYXRlcmlhbCddLFxuXG4gIHNjaGVtYToge1xuICAgIG10bDogeyB0eXBlOiAnc3JjJyB9LFxuICAgIG9iajogeyB0eXBlOiAnc3JjJyB9XG4gIH0sXG5cbiAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMubW9kZWwgPSBudWxsO1xuICAgIHRoaXMub2JqTG9hZGVyID0gbmV3IFRIUkVFLk9CSkxvYWRlcigpO1xuICAgIHRoaXMubXRsTG9hZGVyID0gbmV3IFRIUkVFLk1UTExvYWRlcih0aGlzLm9iakxvYWRlci5tYW5hZ2VyKTtcbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICBpZiAoIWRhdGEub2JqKSB7IHJldHVybjsgfVxuICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgdGhpcy5sb2FkT2JqKGRhdGEub2JqLCBkYXRhLm10bCk7XG4gIH0sXG5cbiAgcmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLm1vZGVsKSB7IHJldHVybjsgfVxuICAgIHRoaXMuZWwucmVtb3ZlT2JqZWN0M0QoJ21lc2gnKTtcbiAgfSxcblxuICBsb2FkT2JqOiBmdW5jdGlvbiAob2JqVXJsLCBtdGxVcmwpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGVsID0gdGhpcy5lbDtcbiAgICB2YXIgbXRsTG9hZGVyID0gdGhpcy5tdGxMb2FkZXI7XG4gICAgdmFyIG9iakxvYWRlciA9IHRoaXMub2JqTG9hZGVyO1xuXG4gICAgaWYgKG10bFVybCkge1xuICAgICAgLy8gLk9CSiB3aXRoIGFuIC5NVEwuXG4gICAgICBpZiAoSFRNTEVsZW1lbnQucHJvdG90eXBlLmdldEF0dHJpYnV0ZS5jYWxsKGVsLCAnbWF0ZXJpYWwnKSkge1xuICAgICAgICB3YXJuKCdNYXRlcmlhbCBjb21wb25lbnQgcHJvcGVydGllcyBhcmUgaWdub3JlZCB3aGVuIGEgLk1UTCBpcyBwcm92aWRlZCcpO1xuICAgICAgfVxuICAgICAgbXRsTG9hZGVyLnNldEJhc2VVcmwobXRsVXJsLnN1YnN0cigwLCBtdGxVcmwubGFzdEluZGV4T2YoJy8nKSArIDEpKTtcbiAgICAgIG10bExvYWRlci5sb2FkKG10bFVybCwgZnVuY3Rpb24gKG1hdGVyaWFscykge1xuICAgICAgICBtYXRlcmlhbHMucHJlbG9hZCgpO1xuICAgICAgICBvYmpMb2FkZXIuc2V0TWF0ZXJpYWxzKG1hdGVyaWFscyk7XG4gICAgICAgIG9iakxvYWRlci5sb2FkKG9ialVybCwgZnVuY3Rpb24gKG9iak1vZGVsKSB7XG4gICAgICAgICAgc2VsZi5tb2RlbCA9IG9iak1vZGVsO1xuICAgICAgICAgIGVsLnNldE9iamVjdDNEKCdtZXNoJywgb2JqTW9kZWwpO1xuICAgICAgICAgIGVsLmVtaXQoJ21vZGVsLWxvYWRlZCcsIHtmb3JtYXQ6ICdvYmonLCBtb2RlbDogb2JqTW9kZWx9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyAuT0JKIG9ubHkuXG4gICAgb2JqTG9hZGVyLmxvYWQob2JqVXJsLCBmdW5jdGlvbiAob2JqTW9kZWwpIHtcbiAgICAgIC8vIEFwcGx5IG1hdGVyaWFsLlxuICAgICAgdmFyIG1hdGVyaWFsID0gZWwuY29tcG9uZW50cy5tYXRlcmlhbC5tYXRlcmlhbDtcbiAgICAgIG9iak1vZGVsLnRyYXZlcnNlKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBUSFJFRS5NZXNoKSB7XG4gICAgICAgICAgY2hpbGQubWF0ZXJpYWwgPSBtYXRlcmlhbDtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHNlbGYubW9kZWwgPSBvYmpNb2RlbDtcbiAgICAgIGVsLnNldE9iamVjdDNEKCdtZXNoJywgb2JqTW9kZWwpO1xuICAgICAgZWwuZW1pdCgnbW9kZWwtbG9hZGVkJywge2Zvcm1hdDogJ29iaicsIG1vZGVsOiBvYmpNb2RlbH0pO1xuICAgIH0pO1xuICB9XG59KTtcblxufSx7XCIuLi9jb3JlL2NvbXBvbmVudFwiOjU2LFwiLi4vbGliL3RocmVlXCI6OTAsXCIuLi91dGlscy9kZWJ1Z1wiOjEwMX1dLDM2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciByZWdpc3RlckNvbXBvbmVudCA9IF9kZXJlcV8oJy4uL2NvcmUvY29tcG9uZW50JykucmVnaXN0ZXJDb21wb25lbnQ7XG5cbm1vZHVsZS5leHBvcnRzLkNvbXBvbmVudCA9IHJlZ2lzdGVyQ29tcG9uZW50KCdwb3NpdGlvbicsIHtcbiAgc2NoZW1hOiB7IHR5cGU6ICd2ZWMzJyB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBvYmplY3QzRCA9IHRoaXMuZWwub2JqZWN0M0Q7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgb2JqZWN0M0QucG9zaXRpb24uc2V0KGRhdGEueCwgZGF0YS55LCBkYXRhLnopO1xuICB9XG59KTtcblxufSx7XCIuLi9jb3JlL2NvbXBvbmVudFwiOjU2fV0sMzc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIHJlZ2lzdGVyQ29tcG9uZW50ID0gX2RlcmVxXygnLi4vY29yZS9jb21wb25lbnQnKS5yZWdpc3RlckNvbXBvbmVudDtcbnZhciByZXF1ZXN0SW50ZXJ2YWwgPSBfZGVyZXFfKCdyZXF1ZXN0LWludGVydmFsJyk7XG52YXIgVEhSRUUgPSBfZGVyZXFfKCcuLi9saWIvdGhyZWUnKTtcblxubW9kdWxlLmV4cG9ydHMuQ29tcG9uZW50ID0gcmVnaXN0ZXJDb21wb25lbnQoJ3JheWNhc3RlcicsIHtcbiAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucmF5Y2FzdGVyID0gbmV3IFRIUkVFLlJheWNhc3RlcigpO1xuICAgIHRoaXMuaW50ZXJzZWN0ZWRFbCA9IG51bGw7XG4gIH0sXG5cbiAgcGxheTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucG9sbEZvckhvdmVySW50ZXJzZWN0aW9ucygpO1xuICB9LFxuXG4gIHBhdXNlOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBvbGxJbnRlcnZhbCA9IHRoaXMucG9sbEludGVydmFsO1xuICAgIGlmICghcG9sbEludGVydmFsKSB7IHJldHVybjsgfVxuICAgIHJlcXVlc3RJbnRlcnZhbC5jbGVhcih0aGlzLnBvbGxJbnRlcnZhbCk7XG4gIH0sXG5cbiAgcmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5wYXVzZSgpO1xuICB9LFxuXG4gIHBvbGxGb3JIb3ZlckludGVyc2VjdGlvbnM6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnBvbGxJbnRlcnZhbCA9IHJlcXVlc3RJbnRlcnZhbCgxMDAsIHRoaXMuZ2V0SW50ZXJzZWN0aW9ucy5iaW5kKHRoaXMpKTtcbiAgfSxcblxuICBnZXRJbnRlcnNlY3Rpb25zOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNsb3Nlc3QgPSB0aGlzLmdldENsb3Nlc3RJbnRlcnNlY3RlZCgpO1xuICAgIGlmIChjbG9zZXN0KSB7XG4gICAgICB0aGlzLmhhbmRsZUludGVyc2VjdGlvbihjbG9zZXN0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gSWYgd2UgaGF2ZSBubyBpbnRlcnNlY3Rpb25zIG90aGVyIHRoYW4gdGhlIGN1cnNvciBpdHNlbGYsXG4gICAgLy8gYnV0IHdlIHN0aWxsIGhhdmUgYSBwcmV2aW91c2x5IGludGVyc2VjdGVkIGVsZW1lbnQsIGNsZWFyIGl0LlxuICAgIGlmICh0aGlzLmludGVyc2VjdGVkRWwpIHtcbiAgICAgIHRoaXMuY2xlYXJFeGlzdGluZ0ludGVyc2VjdGlvbigpO1xuICAgIH1cbiAgfSxcblxuICBpbnRlcnNlY3Q6IGZ1bmN0aW9uIChvYmplY3RzKSB7XG4gICAgdmFyIGVsID0gdGhpcy5lbDtcbiAgICB2YXIgcmF5Y2FzdGVyID0gdGhpcy5yYXljYXN0ZXI7XG4gICAgdmFyIGN1cnNvciA9IGVsLm9iamVjdDNEO1xuICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnROb2RlLm9iamVjdDNEO1xuICAgIHZhciBvcmlnaW5Qb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCkuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKHBhcmVudC5tYXRyaXhXb3JsZCk7XG4gICAgdmFyIGN1cnNvclBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKS5zZXRGcm9tTWF0cml4UG9zaXRpb24oY3Vyc29yLm1hdHJpeFdvcmxkKTtcbiAgICB2YXIgZGlyZWN0aW9uID0gY3Vyc29yUG9zaXRpb24uc3ViKG9yaWdpblBvc2l0aW9uKS5ub3JtYWxpemUoKTtcbiAgICByYXljYXN0ZXIuc2V0KG9yaWdpblBvc2l0aW9uLCBkaXJlY3Rpb24pO1xuICAgIHJldHVybiByYXljYXN0ZXIuaW50ZXJzZWN0T2JqZWN0cyhvYmplY3RzLCB0cnVlKTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY2xvc2VzdCBpbnRlcnNlY3RlZCBvYmplY3QuXG4gICAqXG4gICAqIEByZXR1cm5zIHtPYmplY3R8bnVsbH1cbiAgICogICBUaGUgY2xvc2VzdCBpbnRlcnNlY3RlZCBlbGVtZW50IHRoYXQgaXMgbm90IHRoZSBjdXJzb3IgaXRzZWxmLFxuICAgKiAgIGFuIGludmlzaWJsZSBlbGVtZW50LCBvciBub3QgYSBhLWZyYW1lIGVudGl0eSBlbGVtZW50LlxuICAgKiAgIElmIG5vIG9iamVjdHMgYXJlIGludGVyc2VjdGVkLCBgbnVsbGAgaXMgcmV0dXJuZWQuXG4gICAqL1xuICBnZXRDbG9zZXN0SW50ZXJzZWN0ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2NlbmUgPSB0aGlzLmVsLnNjZW5lRWwub2JqZWN0M0Q7XG4gICAgdmFyIGN1cnNvckVsID0gdGhpcy5lbDtcbiAgICB2YXIgaW50ZXJzZWN0ZWRPYmo7XG4gICAgdmFyIGludGVyc2VjdGVkT2JqcyA9IHRoaXMuaW50ZXJzZWN0KHNjZW5lLmNoaWxkcmVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGludGVyc2VjdGVkT2Jqcy5sZW5ndGg7ICsraSkge1xuICAgICAgaW50ZXJzZWN0ZWRPYmogPSBpbnRlcnNlY3RlZE9ianNbaV07XG5cbiAgICAgIHdoaWxlIChpbnRlcnNlY3RlZE9iai5vYmplY3QucGFyZW50ICYmIGludGVyc2VjdGVkT2JqLm9iamVjdC5lbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGludGVyc2VjdGVkT2JqLm9iamVjdCA9IGludGVyc2VjdGVkT2JqLm9iamVjdC5wYXJlbnQ7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoZSBpbnRlcnNlY3RlZCBvYmplY3QgaXMgdGhlIGN1cnNvciBpdHNlbGZcbiAgICAgIC8vIG9yIHRoZSBvYmplY3QgaXMgZnVydGhlciB0aGFuIHRoZSBtYXggZGlzdGFuY2VcblxuICAgICAgaWYgKGludGVyc2VjdGVkT2JqLm9iamVjdC5lbCA9PT0gdW5kZWZpbmVkKSB7IGNvbnRpbnVlOyB9XG4gICAgICBpZiAoaW50ZXJzZWN0ZWRPYmoub2JqZWN0LmVsID09PSBjdXJzb3JFbCkgeyBjb250aW51ZTsgfVxuICAgICAgaWYgKCFpbnRlcnNlY3RlZE9iai5vYmplY3QudmlzaWJsZSkgeyBjb250aW51ZTsgfVxuICAgICAgcmV0dXJuIGludGVyc2VjdGVkT2JqO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogUmVtZW1iZXJzIHRoZSBsYXN0IGludGVyc2VjdGVkIGVsZW1lbnRcbiAgICovXG4gIHNldEV4aXN0aW5nSW50ZXJzZWN0aW9uOiBmdW5jdGlvbiAoZWwsIGRpc3RhbmNlKSB7XG4gICAgdGhpcy5pbnRlcnNlY3RlZEVsID0gZWw7XG4gICAgdGhpcy5lbC5lbWl0KCdpbnRlcnNlY3Rpb24nLCB7IGVsOiBlbCwgZGlzdGFuY2U6IGRpc3RhbmNlIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFbWl0cyBhIGBtb3VzZWxlYXZlYCBldmVudCBhbmQgY2xlYXJzIGluZm8gYWJvdXQgdGhlIGxhc3QgaW50ZXJzZWN0aW9uLlxuICAgKi9cbiAgY2xlYXJFeGlzdGluZ0ludGVyc2VjdGlvbjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBpbnRlcnNlY3RlZEVsID0gdGhpcy5pbnRlcnNlY3RlZEVsO1xuICAgIHRoaXMuZWwuZW1pdCgnaW50ZXJzZWN0aW9uY2xlYXJlZCcsIHsgZWw6IGludGVyc2VjdGVkRWwgfSk7XG4gICAgdGhpcy5pbnRlcnNlY3RlZEVsID0gbnVsbDtcbiAgfSxcblxuICBoYW5kbGVJbnRlcnNlY3Rpb246IGZ1bmN0aW9uIChvYmopIHtcbiAgICB2YXIgZWwgPSBvYmoub2JqZWN0LmVsO1xuXG4gICAgLy8gQSBuZXcgaW50ZXJzZWN0aW9uIHdoZXJlIHByZXZpb3VzbHkgYSBkaWZmZXJlbnQgZWxlbWVudCB3YXNcbiAgICAvLyBhbmQgbm93IG5lZWRzIGEgbW91c2VsZWF2ZSBldmVudC5cbiAgICBpZiAodGhpcy5pbnRlcnNlY3RlZEVsICE9PSBlbCkge1xuICAgICAgdGhpcy5jbGVhckV4aXN0aW5nSW50ZXJzZWN0aW9uKCk7XG4gICAgfVxuICAgIHRoaXMuc2V0RXhpc3RpbmdJbnRlcnNlY3Rpb24oZWwsIG9iai5kaXN0YW5jZSk7XG4gIH1cbn0pO1xuXG59LHtcIi4uL2NvcmUvY29tcG9uZW50XCI6NTYsXCIuLi9saWIvdGhyZWVcIjo5MCxcInJlcXVlc3QtaW50ZXJ2YWxcIjoxMn1dLDM4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBkZWdUb1JhZCA9IF9kZXJlcV8oJy4uL2xpYi90aHJlZScpLk1hdGguZGVnVG9SYWQ7XG52YXIgcmVnaXN0ZXJDb21wb25lbnQgPSBfZGVyZXFfKCcuLi9jb3JlL2NvbXBvbmVudCcpLnJlZ2lzdGVyQ29tcG9uZW50O1xuXG5tb2R1bGUuZXhwb3J0cy5Db21wb25lbnQgPSByZWdpc3RlckNvbXBvbmVudCgncm90YXRpb24nLCB7XG4gIHNjaGVtYTogeyB0eXBlOiAndmVjMycgfSxcblxuICAvKipcbiAgICogVXBkYXRlcyBvYmplY3QzRCByb3RhdGlvbi5cbiAgICovXG4gIHVwZGF0ZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgIHZhciBvYmplY3QzRCA9IHRoaXMuZWwub2JqZWN0M0Q7XG4gICAgb2JqZWN0M0Qucm90YXRpb24uc2V0KGRlZ1RvUmFkKGRhdGEueCksIGRlZ1RvUmFkKGRhdGEueSksIGRlZ1RvUmFkKGRhdGEueikpO1xuICAgIG9iamVjdDNELnJvdGF0aW9uLm9yZGVyID0gJ1lYWic7XG4gIH1cbn0pO1xuXG59LHtcIi4uL2NvcmUvY29tcG9uZW50XCI6NTYsXCIuLi9saWIvdGhyZWVcIjo5MH1dLDM5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciByZWdpc3RlckNvbXBvbmVudCA9IF9kZXJlcV8oJy4uL2NvcmUvY29tcG9uZW50JykucmVnaXN0ZXJDb21wb25lbnQ7XG5cbi8vIEF2b2lkcyB0cmlnZ2VyaW5nIGEgemVyby1kZXRlcm1pbmFudCB3aGljaCBtYWtlcyBvYmplY3QzRCBtYXRyaXggbm9uLWludmVydGlibGUuXG52YXIgemVyb1NjYWxlID0gMC4wMDAwMTtcblxubW9kdWxlLmV4cG9ydHMuQ29tcG9uZW50ID0gcmVnaXN0ZXJDb21wb25lbnQoJ3NjYWxlJywge1xuICBzY2hlbWE6IHtcbiAgICB0eXBlOiAndmVjMycsXG4gICAgZGVmYXVsdDogeyB4OiAxLCB5OiAxLCB6OiAxIH1cbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICB2YXIgb2JqZWN0M0QgPSB0aGlzLmVsLm9iamVjdDNEO1xuICAgIHZhciB4ID0gZGF0YS54ID09PSAwID8gemVyb1NjYWxlIDogZGF0YS54O1xuICAgIHZhciB5ID0gZGF0YS55ID09PSAwID8gemVyb1NjYWxlIDogZGF0YS55O1xuICAgIHZhciB6ID0gZGF0YS56ID09PSAwID8gemVyb1NjYWxlIDogZGF0YS56O1xuICAgIG9iamVjdDNELnNjYWxlLnNldCh4LCB5LCB6KTtcbiAgfVxufSk7XG5cbn0se1wiLi4vY29yZS9jb21wb25lbnRcIjo1Nn1dLDQwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciByZWdpc3RlciA9IF9kZXJlcV8oJy4uLy4uL2NvcmUvY29tcG9uZW50JykucmVnaXN0ZXJDb21wb25lbnQ7XG5cbm1vZHVsZS5leHBvcnRzLkNvbXBvbmVudCA9IHJlZ2lzdGVyKCdjYW52YXMnLCB7XG4gIHNjaGVtYToge1xuICAgIGNhbnZhczoge1xuICAgICAgdHlwZTogJ3NlbGVjdG9yJyxcbiAgICAgIGRlZmF1bHQ6IHVuZGVmaW5lZFxuICAgIH0sXG4gICAgaGVpZ2h0OiB7XG4gICAgICBkZWZhdWx0OiAxMDBcbiAgICB9LFxuICAgIHdpZHRoOiB7XG4gICAgICBkZWZhdWx0OiAxMDBcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgdmFyIGNhbnZhcyA9IGRhdGEuY2FudmFzO1xuICAgIHZhciBzY2VuZSA9IHRoaXMuZWw7XG5cbiAgICAvLyBObyB1cGRhdGluZyBjYW52YXMuXG4gICAgaWYgKHNjZW5lLmNhbnZhcykgeyByZXR1cm47IH1cblxuICAgIC8vIEluamVjdCBjYW52YXMgaWYgb25lIG5vdCBzcGVjaWZpZWQgd2l0aCBoZWlnaHQgYW5kIHdpZHRoLlxuICAgIGlmICghY2FudmFzKSB7XG4gICAgICBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgIGNhbnZhcy5jbGFzc0xpc3QuYWRkKCdhLWNhbnZhcycpO1xuICAgICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IGRhdGEuaGVpZ2h0ICsgJyUnO1xuICAgICAgY2FudmFzLnN0eWxlLndpZHRoID0gZGF0YS53aWR0aCArICclJztcbiAgICAgIHNjZW5lLmFwcGVuZENoaWxkKGNhbnZhcyk7XG4gICAgfVxuXG4gICAgLy8gUHJldmVudCBvdmVyc2Nyb2xsIG9uIG1vYmlsZS5cbiAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0pO1xuXG4gICAgLy8gU2V0IGNhbnZhcyBvbiBzY2VuZS5cbiAgICBzY2VuZS5jYW52YXMgPSBjYW52YXM7XG4gICAgc2NlbmUuZW1pdCgncmVuZGVyLXRhcmdldC1sb2FkZWQnLCB7XG4gICAgICB0YXJnZXQ6IGNhbnZhc1xuICAgIH0pO1xuICB9XG59KTtcblxufSx7XCIuLi8uLi9jb3JlL2NvbXBvbmVudFwiOjU2fV0sNDE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIHJlZ2lzdGVyID0gX2RlcmVxXygnLi4vLi4vY29yZS9jb21wb25lbnQnKS5yZWdpc3RlckNvbXBvbmVudDtcbnZhciBUSFJFRSA9IF9kZXJlcV8oJy4uLy4uL2xpYi90aHJlZScpO1xudmFyIGRlYnVnID0gX2RlcmVxXygnLi4vLi4vdXRpbHMvZGVidWcnKTtcblxudmFyIHdhcm4gPSBkZWJ1ZygnY29tcG9uZW50czpmb2c6d2FybicpO1xuXG4vKipcbiAqIEZvZyBjb21wb25lbnQuXG4gKiBBcHBsaWVzIG9ubHkgdG8gdGhlIHNjZW5lIGVudGl0eS5cbiAqL1xubW9kdWxlLmV4cG9ydHMuQ29tcG9uZW50ID0gcmVnaXN0ZXIoJ2ZvZycsIHtcbiAgc2NoZW1hOiB7XG4gICAgY29sb3I6IHsgZGVmYXVsdDogJyMwMDAnIH0sXG4gICAgZGVuc2l0eTogeyBkZWZhdWx0OiAwLjAwMDI1IH0sXG4gICAgZmFyOiB7IGRlZmF1bHQ6IDEwMDAsIG1pbjogMCB9LFxuICAgIG5lYXI6IHsgZGVmYXVsdDogMSwgbWluOiAwIH0sXG4gICAgdHlwZTogeyBkZWZhdWx0OiAnbGluZWFyJywgb25lT2Y6IFsnbGluZWFyJywgJ2V4cG9uZW50aWFsJ10gfVxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgIHZhciBlbCA9IHRoaXMuZWw7XG4gICAgdmFyIGZvZyA9IHRoaXMuZWwub2JqZWN0M0QuZm9nO1xuXG4gICAgaWYgKCFlbC5pc1NjZW5lKSB7XG4gICAgICB3YXJuKCdGb2cgY29tcG9uZW50IGNhbiBvbmx5IGJlIGFwcGxpZWQgdG8gPGEtc2NlbmU+Jyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gKFJlKWNyZWF0ZSBmb2cgaWYgZm9nIGRvZXNuJ3QgZXhpc3Qgb3IgZm9nIHR5cGUgY2hhbmdlZC5cbiAgICBpZiAoIWZvZyB8fCBkYXRhLnR5cGUgIT09IGZvZy5uYW1lKSB7XG4gICAgICBlbC5vYmplY3QzRC5mb2cgPSBnZXRGb2coZGF0YSk7XG4gICAgICBlbC5zeXN0ZW1zLm1hdGVyaWFsLnVwZGF0ZU1hdGVyaWFscygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEZvZyBkYXRhIGNoYW5nZWQuIFVwZGF0ZSBmb2cuXG4gICAgT2JqZWN0LmtleXModGhpcy5zY2hlbWEpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgdmFyIHZhbHVlID0gZGF0YVtrZXldO1xuICAgICAgaWYgKGtleSA9PT0gJ2NvbG9yJykgeyB2YWx1ZSA9IG5ldyBUSFJFRS5Db2xvcih2YWx1ZSk7IH1cbiAgICAgIGZvZ1trZXldID0gdmFsdWU7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbW92ZSBmb2cgb24gcmVtb3ZlIChjYWxsYmFjaykuXG4gICAqL1xuICByZW1vdmU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZm9nID0gdGhpcy5lbC5vYmplY3QzRC5mb2c7XG4gICAgaWYgKGZvZykge1xuICAgICAgZm9nLmRlbnNpdHkgPSAwO1xuICAgICAgZm9nLmZhciA9IDA7XG4gICAgICBmb2cubmVhciA9IDA7XG4gICAgfVxuICB9XG59KTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZm9nIG9iamVjdC4gU2V0cyBmb2cubmFtZSB0byBiZSBhYmxlIHRvIGRldGVjdCBmb2cgdHlwZSBjaGFuZ2VzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhIC0gRm9nIGRhdGEuXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBmb2dcbiAqL1xuZnVuY3Rpb24gZ2V0Rm9nIChkYXRhKSB7XG4gIHZhciBmb2c7XG4gIGlmIChkYXRhLnR5cGUgPT09ICdleHBvbmVudGlhbCcpIHtcbiAgICBmb2cgPSBuZXcgVEhSRUUuRm9nRXhwMihkYXRhLmNvbG9yLCBkYXRhLmRlbnNpdHkpO1xuICB9IGVsc2Uge1xuICAgIGZvZyA9IG5ldyBUSFJFRS5Gb2coZGF0YS5jb2xvciwgZGF0YS5uZWFyLCBkYXRhLmZhcik7XG4gIH1cbiAgZm9nLm5hbWUgPSBkYXRhLnR5cGU7XG4gIHJldHVybiBmb2c7XG59XG5cbn0se1wiLi4vLi4vY29yZS9jb21wb25lbnRcIjo1NixcIi4uLy4uL2xpYi90aHJlZVwiOjkwLFwiLi4vLi4vdXRpbHMvZGVidWdcIjoxMDF9XSw0MjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgcmVnaXN0ZXJDb21wb25lbnQgPSBfZGVyZXFfKCcuLi8uLi9jb3JlL2NvbXBvbmVudCcpLnJlZ2lzdGVyQ29tcG9uZW50O1xudmFyIHNob3VsZENhcHR1cmVLZXlFdmVudCA9IF9kZXJlcV8oJy4uLy4uL3V0aWxzLycpLnNob3VsZENhcHR1cmVLZXlFdmVudDtcbnZhciBUSFJFRSA9IF9kZXJlcV8oJy4uLy4uL2xpYi90aHJlZScpO1xuXG52YXIgY29udHJvbHMgPSBuZXcgVEhSRUUuVlJDb250cm9scyhuZXcgVEhSRUUuT2JqZWN0M0QoKSk7XG5cbm1vZHVsZS5leHBvcnRzLkNvbXBvbmVudCA9IHJlZ2lzdGVyQ29tcG9uZW50KCdrZXlib2FyZC1zaG9ydGN1dHMnLCB7XG4gIHNjaGVtYToge1xuICAgIGVudGVyVlI6IHsgZGVmYXVsdDogdHJ1ZSB9LFxuICAgIHJlc2V0U2Vuc29yOiB7IGRlZmF1bHQ6IHRydWUgfVxuICB9LFxuXG4gIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHNjZW5lID0gdGhpcy5lbDtcblxuICAgIHRoaXMubGlzdGVuZXIgPSB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmICghc2hvdWxkQ2FwdHVyZUtleUV2ZW50KGV2ZW50KSkgeyByZXR1cm47IH1cbiAgICAgIGlmIChzZWxmLmVudGVyVlJFbmFibGVkICYmIGV2ZW50LmtleUNvZGUgPT09IDcwKSB7ICAvLyBmLlxuICAgICAgICBzY2VuZS5lbnRlclZSKCk7XG4gICAgICB9XG4gICAgICBpZiAoc2VsZi5yZXNldFNlbnNvckVuYWJsZWQgJiYgZXZlbnQua2V5Q29kZSA9PT0gOTApIHsgIC8vIHouXG4gICAgICAgIGNvbnRyb2xzLnJlc2V0U2Vuc29yKCk7XG4gICAgICB9XG4gICAgfSwgZmFsc2UpO1xuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gKG9sZERhdGEpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICB0aGlzLmVudGVyVlJFbmFibGVkID0gZGF0YS5lbnRlclZSO1xuICAgIHRoaXMucmVzZXRTZW5zb3JFbmFibGVkID0gZGF0YS5yZXNldFNlbnNvcjtcbiAgfSxcblxuICByZW1vdmU6IGZ1bmN0aW9uICgpIHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB0aGlzLmxpc3RlbmVyKTtcbiAgfVxufSk7XG5cbn0se1wiLi4vLi4vY29yZS9jb21wb25lbnRcIjo1NixcIi4uLy4uL2xpYi90aHJlZVwiOjkwLFwiLi4vLi4vdXRpbHMvXCI6MTAyfV0sNDM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIHJlZ2lzdGVyQ29tcG9uZW50ID0gX2RlcmVxXygnLi4vLi4vY29yZS9jb21wb25lbnQnKS5yZWdpc3RlckNvbXBvbmVudDtcbnZhciBSU3RhdHMgPSBfZGVyZXFfKCcuLi8uLi8uLi92ZW5kb3IvclN0YXRzJyk7XG5fZGVyZXFfKCcuLi8uLi8uLi92ZW5kb3IvclN0YXRzLmV4dHJhcycpO1xuX2RlcmVxXygnLi4vLi4vbGliL3JTdGF0c0FmcmFtZScpO1xuXG52YXIgSElEREVOX0NMQVNTID0gJ2EtaGlkZGVuJztcbnZhciBUaHJlZVN0YXRzID0gd2luZG93LnRocmVlU3RhdHM7XG52YXIgQUZyYW1lU3RhdHMgPSB3aW5kb3cuYWZyYW1lU3RhdHM7XG5cbi8qKlxuICogU3RhdHMgYXBwZW5kZWQgdG8gZG9jdW1lbnQuYm9keSBieSBSU3RhdHMuXG4gKi9cbm1vZHVsZS5leHBvcnRzLkNvbXBvbmVudCA9IHJlZ2lzdGVyQ29tcG9uZW50KCdzdGF0cycsIHtcbiAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzY2VuZSA9IHRoaXMuZWw7XG4gICAgdGhpcy5zdGF0cyA9IGNyZWF0ZVN0YXRzKHNjZW5lKTtcbiAgICB0aGlzLnN0YXRzRWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcucnMtYmFzZScpO1xuXG4gICAgdGhpcy5oaWRlQm91bmQgPSB0aGlzLmhpZGUuYmluZCh0aGlzKTtcbiAgICB0aGlzLnNob3dCb3VuZCA9IHRoaXMuc2hvdy5iaW5kKHRoaXMpO1xuXG4gICAgc2NlbmUuYWRkRXZlbnRMaXN0ZW5lcignZW50ZXItdnInLCB0aGlzLmhpZGVCb3VuZCk7XG4gICAgc2NlbmUuYWRkRXZlbnRMaXN0ZW5lcignZXhpdC12cicsIHRoaXMuc2hvd0JvdW5kKTtcbiAgfSxcblxuICByZW1vdmU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VudGVyLXZyJywgdGhpcy5oaWRlQm91bmQpO1xuICAgIHRoaXMuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXhpdC12cicsIHRoaXMuc2hvd0JvdW5kKTtcbiAgICB0aGlzLnN0YXRzRWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnN0YXRzRWwpO1xuICB9LFxuXG4gIHRpY2s6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3RhdHMgPSB0aGlzLnN0YXRzO1xuICAgIHN0YXRzKCdyQUYnKS50aWNrKCk7XG4gICAgc3RhdHMoJ0ZQUycpLmZyYW1lKCk7XG4gICAgc3RhdHMoKS51cGRhdGUoKTtcbiAgfSxcblxuICBoaWRlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5zdGF0c0VsLmNsYXNzTGlzdC5hZGQoSElEREVOX0NMQVNTKTtcbiAgfSxcblxuICBzaG93OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5zdGF0c0VsLmNsYXNzTGlzdC5yZW1vdmUoSElEREVOX0NMQVNTKTtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0YXRzIChzY2VuZSkge1xuICB2YXIgdGhyZWVTdGF0cyA9IG5ldyBUaHJlZVN0YXRzKHNjZW5lLnJlbmRlcmVyKTtcbiAgdmFyIGFmcmFtZVN0YXRzID0gbmV3IEFGcmFtZVN0YXRzKHNjZW5lKTtcbiAgdmFyIHBsdWdpbnMgPSBzY2VuZS5pc01vYmlsZSA/IFtdIDogW3RocmVlU3RhdHMsIGFmcmFtZVN0YXRzXTtcbiAgcmV0dXJuIG5ldyBSU3RhdHMoe1xuICAgIGNzczogW10sICAvLyBPdXIgc3R5bGVzaGVldCBpcyBpbmplY3RlZCBmcm9tIGBzcmMvaW5kZXguanNgLlxuICAgIHZhbHVlczoge1xuICAgICAgZnBzOiB7Y2FwdGlvbjogJ2ZwcycsIGJlbG93OiAzMH1cbiAgICB9LFxuICAgIGdyb3VwczogW1xuICAgICAge2NhcHRpb246ICdGcmFtZXJhdGUnLCB2YWx1ZXM6IFsnZnBzJywgJ3JhZiddfVxuICAgIF0sXG4gICAgcGx1Z2luczogcGx1Z2luc1xuICB9KTtcbn1cblxufSx7XCIuLi8uLi8uLi92ZW5kb3IvclN0YXRzXCI6MTA3LFwiLi4vLi4vLi4vdmVuZG9yL3JTdGF0cy5leHRyYXNcIjoxMDYsXCIuLi8uLi9jb3JlL2NvbXBvbmVudFwiOjU2LFwiLi4vLi4vbGliL3JTdGF0c0FmcmFtZVwiOjg5fV0sNDQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIHJlZ2lzdGVyQ29tcG9uZW50ID0gX2RlcmVxXygnLi4vLi4vY29yZS9jb21wb25lbnQnKS5yZWdpc3RlckNvbXBvbmVudDtcbnZhciBUSFJFRSA9IF9kZXJlcV8oJy4uLy4uL2xpYi90aHJlZScpO1xudmFyIHV0aWxzID0gX2RlcmVxXygnLi4vLi4vdXRpbHMvJyk7XG5cbnZhciBkdW1teURvbGx5ID0gbmV3IFRIUkVFLk9iamVjdDNEKCk7XG52YXIgY29udHJvbHMgPSBuZXcgVEhSRUUuVlJDb250cm9scyhkdW1teURvbGx5KTtcblxudmFyIEVOVEVSX1ZSX0NMQVNTID0gJ2EtZW50ZXItdnInO1xudmFyIEVOVEVSX1ZSX05PX0hFQURTRVQgPSAnZGF0YS1hLWVudGVyLXZyLW5vLWhlYWRzZXQnO1xudmFyIEVOVEVSX1ZSX05PX1dFQlZSID0gJ2RhdGEtYS1lbnRlci12ci1uby13ZWJ2cic7XG52YXIgRU5URVJfVlJfQlROX0NMQVNTID0gJ2EtZW50ZXItdnItYnV0dG9uJztcbnZhciBFTlRFUl9WUl9NT0RBTF9DTEFTUyA9ICdhLWVudGVyLXZyLW1vZGFsJztcbnZhciBISURERU5fQ0xBU1MgPSAnYS1oaWRkZW4nO1xudmFyIE9SSUVOVEFUSU9OX01PREFMX0NMQVNTID0gJ2Etb3JpZW50YXRpb24tbW9kYWwnO1xuXG4vKipcbiAqIFVJIGZvciBlbnRlcmluZyBWUiBtb2RlLlxuICovXG5tb2R1bGUuZXhwb3J0cy5Db21wb25lbnQgPSByZWdpc3RlckNvbXBvbmVudCgndnItbW9kZS11aScsIHtcbiAgZGVwZW5kZW5jaWVzOiBbICdjYW52YXMnIF0sXG5cbiAgc2NoZW1hOiB7XG4gICAgZW5hYmxlZDogeyBkZWZhdWx0OiB0cnVlIH1cbiAgfSxcblxuICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBzY2VuZSA9IHRoaXMuZWw7XG5cbiAgICB0aGlzLmVudGVyVlIgPSBzY2VuZS5lbnRlclZSLmJpbmQoc2NlbmUpO1xuICAgIHRoaXMuZXhpdFZSID0gc2NlbmUuZXhpdFZSLmJpbmQoc2NlbmUpO1xuICAgIHRoaXMuaW5zaWRlTG9hZGVyID0gZmFsc2U7XG4gICAgdGhpcy5lbnRlclZSRWwgPSBudWxsO1xuICAgIHRoaXMub3JpZW50YXRpb25Nb2RhbEVsID0gbnVsbDtcblxuICAgIC8vIEhpZGUvc2hvdyBWUiBVSSB3aGVuIGVudGVyaW5nL2V4aXRpbmcgVlIgbW9kZS5cbiAgICBzY2VuZS5hZGRFdmVudExpc3RlbmVyKCdlbnRlci12cicsIHRoaXMudXBkYXRlRW50ZXJWUkludGVyZmFjZS5iaW5kKHRoaXMpKTtcbiAgICBzY2VuZS5hZGRFdmVudExpc3RlbmVyKCdleGl0LXZyJywgdGhpcy51cGRhdGVFbnRlclZSSW50ZXJmYWNlLmJpbmQodGhpcykpO1xuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmIChldmVudC5kYXRhLnR5cGUgPT09ICdsb2FkZXJSZWFkeScpIHtcbiAgICAgICAgc2VsZi5pbnNpZGVMb2FkZXIgPSB0cnVlO1xuICAgICAgICBzZWxmLnJlbW92ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gTW9kYWwgdGhhdCB0ZWxscyB0aGUgdXNlciB0byBjaGFuZ2Ugb3JpZW50YXRpb24gaWYgaW4gcG9ydHJhaXQuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ29yaWVudGF0aW9uY2hhbmdlJywgdGhpcy50b2dnbGVPcmllbnRhdGlvbk1vZGFsSWZOZWVkZWQuYmluZCh0aGlzKSk7XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNjZW5lID0gdGhpcy5lbDtcblxuICAgIGlmICghdGhpcy5kYXRhLmVuYWJsZWQgfHwgdGhpcy5pbnNpZGVMb2FkZXIpIHsgcmV0dXJuIHRoaXMucmVtb3ZlKCk7IH1cbiAgICBpZiAodGhpcy5lbnRlclZSRWwgfHwgdGhpcy5vcmllbnRhdGlvbk1vZGFsRWwpIHsgcmV0dXJuOyB9XG5cbiAgICAvLyBBZGQgVUkgaWYgZW5hYmxlZCBhbmQgbm90IGFscmVhZHkgcHJlc2VudC5cbiAgICB0aGlzLmVudGVyVlJFbCA9IGNyZWF0ZUVudGVyVlIodGhpcy5lbnRlclZSLCBzY2VuZS5pc01vYmlsZSk7XG4gICAgdGhpcy5lbC5hcHBlbmRDaGlsZCh0aGlzLmVudGVyVlJFbCk7XG5cbiAgICB0aGlzLm9yaWVudGF0aW9uTW9kYWxFbCA9IGNyZWF0ZU9yaWVudGF0aW9uTW9kYWwodGhpcy5leGl0VlIpO1xuICAgIHRoaXMuZWwuYXBwZW5kQ2hpbGQodGhpcy5vcmllbnRhdGlvbk1vZGFsRWwpO1xuXG4gICAgdGhpcy51cGRhdGVFbnRlclZSSW50ZXJmYWNlKCk7XG4gIH0sXG5cbiAgcmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG4gICAgW3RoaXMuZW50ZXJWUkVsLCB0aGlzLm9yaWVudGF0aW9uTW9kYWxFbF0uZm9yRWFjaChmdW5jdGlvbiAodWlFbGVtZW50KSB7XG4gICAgICBpZiAodWlFbGVtZW50KSB7XG4gICAgICAgIHVpRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHVpRWxlbWVudCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgdXBkYXRlRW50ZXJWUkludGVyZmFjZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMudG9nZ2xlRW50ZXJWUkJ1dHRvbklmTmVlZGVkKCk7XG4gICAgdGhpcy50b2dnbGVPcmllbnRhdGlvbk1vZGFsSWZOZWVkZWQoKTtcbiAgfSxcblxuICB0b2dnbGVFbnRlclZSQnV0dG9uSWZOZWVkZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuZW50ZXJWUkVsKSB7IHJldHVybjsgfVxuICAgIHZhciBzY2VuZSA9IHRoaXMuZWw7XG4gICAgaWYgKHNjZW5lLmlzKCd2ci1tb2RlJykpIHtcbiAgICAgIHRoaXMuZW50ZXJWUkVsLmNsYXNzTGlzdC5hZGQoSElEREVOX0NMQVNTKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbnRlclZSRWwuY2xhc3NMaXN0LnJlbW92ZShISURERU5fQ0xBU1MpO1xuICAgIH1cbiAgfSxcblxuICB0b2dnbGVPcmllbnRhdGlvbk1vZGFsSWZOZWVkZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2NlbmUgPSB0aGlzLmVsO1xuICAgIGlmICghdGhpcy5vcmllbnRhdGlvbk1vZGFsRWwgfHwgIXNjZW5lLmlzTW9iaWxlKSB7IHJldHVybjsgfVxuICAgIGlmICghdXRpbHMuaXNMYW5kc2NhcGUoKSAmJiBzY2VuZS5pcygndnItbW9kZScpKSB7XG4gICAgICAvLyBTaG93IGlmIGluIFZSIG1vZGUgb24gcG9ydHJhaXQuXG4gICAgICB0aGlzLm9yaWVudGF0aW9uTW9kYWxFbC5jbGFzc0xpc3QucmVtb3ZlKEhJRERFTl9DTEFTUyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub3JpZW50YXRpb25Nb2RhbEVsLmNsYXNzTGlzdC5hZGQoSElEREVOX0NMQVNTKTtcbiAgICB9XG4gIH1cbn0pO1xuXG4vKipcbiAqIENyZWF0ZXMgRW50ZXIgVlIgZmxvdyAoYnV0dG9uIGFuZCBjb21wYXRpYmlsaXR5IG1vZGFsKS5cbiAqXG4gKiBDcmVhdGVzIGEgYnV0dG9uIHRoYXQgd2hlbiBjbGlja2VkIHdpbGwgZW50ZXIgaW50byBzdGVyZW8tcmVuZGVyaW5nIG1vZGUgZm9yIFZSLlxuICpcbiAqIEZvciBjb21wYXRpYmlsaXR5OlxuICogICAtIE1vYmlsZSBhbHdheXMgaGFzIGNvbXBhdGliaWxpdHkgdmlhIHBvbHlmaWxsLlxuICogICAtIElmIGRlc2t0b3AgYnJvd3NlciBkb2VzIG5vdCBoYXZlIFdlYlZSIGV4Y2x1ZGluZyBwb2x5ZmlsbCwgZGlzYWJsZSBidXR0b24sIHNob3cgbW9kYWwuXG4gKiAgIC0gSWYgZGVza3RvcCBicm93c2VyIGhhcyBXZWJWUiBleGNsdWRpbmcgcG9seWZpbGwgYnV0IG5vdCBoZWFkc2V0IGNvbm5lY3RlZCxcbiAqICAgICBkb24ndCBkaXNhYmxlIGJ1dHRvbiwgYnV0IHNob3cgbW9kYWwuXG4gKiAgIC0gSWYgZGVza3RvcCBicm93c2VyIGhhcyBXZWJWUiBleGNsdWRpbmcgcG9seWZpbGwgYW5kIGhhcyBoZWFkc2V0IGNvbm5lY3RlZCwgdGhlblxuICogICAgIHRoZW4gbm8gbW9kYWwuXG4gKlxuICogU3RydWN0dXJlOiA8ZGl2Pjxtb2RhbC8+PGJ1dHRvbj48L2Rpdj5cbiAqXG4gKiBAcmV0dXJucyB7RWxlbWVudH0gV3JhcHBlciA8ZGl2Pi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRW50ZXJWUiAoZW50ZXJWUkhhbmRsZXIsIGlzTW9iaWxlKSB7XG4gIHZhciBjb21wYXRNb2RhbDtcbiAgdmFyIGNvbXBhdE1vZGFsTGluaztcbiAgdmFyIGNvbXBhdE1vZGFsVGV4dDtcbiAgLy8gd2luZG93Lmhhc05vblBvbHlmaWxsV2ViVlJTdXBwb3J0IGlzIHNldCBpbiBzcmMvaW5kZXguanMuXG4gIHZhciBoYXNXZWJWUiA9IGlzTW9iaWxlIHx8IHdpbmRvdy5oYXNOb25Qb2x5ZmlsbFdlYlZSU3VwcG9ydDtcbiAgdmFyIG9yaWVudGF0aW9uO1xuICB2YXIgdnJCdXR0b247XG4gIHZhciB3cmFwcGVyO1xuXG4gIC8vIENyZWF0ZSBlbGVtZW50cy5cbiAgd3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB3cmFwcGVyLmNsYXNzTGlzdC5hZGQoRU5URVJfVlJfQ0xBU1MpO1xuICBjb21wYXRNb2RhbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBjb21wYXRNb2RhbC5jbGFzc05hbWUgPSBFTlRFUl9WUl9NT0RBTF9DTEFTUztcbiAgY29tcGF0TW9kYWxUZXh0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpO1xuICBjb21wYXRNb2RhbExpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gIGNvbXBhdE1vZGFsTGluay5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCAnaHR0cDovL21venZyLmNvbS8jc3RhcnQnKTtcbiAgY29tcGF0TW9kYWxMaW5rLnNldEF0dHJpYnV0ZSgndGFyZ2V0JywgJ19ibGFuaycpO1xuICBjb21wYXRNb2RhbExpbmsuaW5uZXJIVE1MID0gJ0xlYXJuIG1vcmUuJztcbiAgdnJCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgdnJCdXR0b24uY2xhc3NOYW1lID0gRU5URVJfVlJfQlROX0NMQVNTO1xuXG4gIC8vIEluc2VydCBlbGVtZW50cy5cbiAgd3JhcHBlci5hcHBlbmRDaGlsZCh2ckJ1dHRvbik7XG4gIGlmIChjb21wYXRNb2RhbCkge1xuICAgIGNvbXBhdE1vZGFsLmFwcGVuZENoaWxkKGNvbXBhdE1vZGFsVGV4dCk7XG4gICAgY29tcGF0TW9kYWwuYXBwZW5kQ2hpbGQoY29tcGF0TW9kYWxMaW5rKTtcbiAgICB3cmFwcGVyLmFwcGVuZENoaWxkKGNvbXBhdE1vZGFsKTtcbiAgfVxuXG4gIGlmICghY2hlY2tIZWFkc2V0Q29ubmVjdGVkKCkgJiYgIWlzTW9iaWxlKSB7XG4gICAgY29tcGF0TW9kYWxUZXh0LmlubmVySFRNTCA9ICdZb3VyIGJyb3dzZXIgc3VwcG9ydHMgV2ViVlIuIFRvIGVudGVyIFZSLCBjb25uZWN0IGEgaGVhZHNldCwgb3IgdXNlIGEgbW9iaWxlIHBob25lLic7XG4gICAgd3JhcHBlci5zZXRBdHRyaWJ1dGUoRU5URVJfVlJfTk9fSEVBRFNFVCwgJycpO1xuICB9XG5cbiAgLy8gSGFuZGxlIGVudGVyIFZSIGZsb3dzLlxuICBpZiAoIWhhc1dlYlZSKSB7XG4gICAgY29tcGF0TW9kYWxUZXh0LmlubmVySFRNTCA9ICdZb3VyIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBXZWJWUi4gVG8gZW50ZXIgVlIsIHVzZSBhIFZSLWNvbXBhdGlibGUgYnJvd3NlciBvciBhIG1vYmlsZSBwaG9uZS4nO1xuICAgIHdyYXBwZXIuc2V0QXR0cmlidXRlKEVOVEVSX1ZSX05PX1dFQlZSLCAnJyk7XG4gIH0gZWxzZSB7XG4gICAgdnJCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBlbnRlclZSSGFuZGxlcik7XG4gIH1cbiAgcmV0dXJuIHdyYXBwZXI7XG5cbiAgLyoqXG4gICAqIENoZWNrIGZvciBoZWFkc2V0IGNvbm5lY3Rpb24gYnkgbG9va2luZyBhdCBvcmllbnRhdGlvbiB7MCAwIDB9LlxuICAgKi9cbiAgZnVuY3Rpb24gY2hlY2tIZWFkc2V0Q29ubmVjdGVkICgpIHtcbiAgICBjb250cm9scy51cGRhdGUoKTtcbiAgICBvcmllbnRhdGlvbiA9IGR1bW15RG9sbHkucXVhdGVybmlvbjtcbiAgICBpZiAob3JpZW50YXRpb24uX3ggIT09IDAgfHwgb3JpZW50YXRpb24uX3kgIT09IDAgfHwgb3JpZW50YXRpb24uX3ogIT09IDApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIG1vZGFsIHRoYXQgdGVsbHMgbW9iaWxlIHVzZXJzIHRvIG9yaWVudCB0aGUgcGhvbmUgdG8gbGFuZHNjYXBlLlxuICogQWRkIGEgY2xvc2UgYnV0dG9uIHRoYXQgaWYgY2xpY2tlZCwgZXhpdHMgVlIgYW5kIGNsb3NlcyB0aGUgbW9kYWwuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU9yaWVudGF0aW9uTW9kYWwgKGV4aXRWUkhhbmRsZXIpIHtcbiAgdmFyIG1vZGFsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIG1vZGFsLmNsYXNzTmFtZSA9IE9SSUVOVEFUSU9OX01PREFMX0NMQVNTO1xuICBtb2RhbC5jbGFzc0xpc3QuYWRkKEhJRERFTl9DTEFTUyk7XG5cbiAgdmFyIGV4aXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgZXhpdC5pbm5lckhUTUwgPSAnRXhpdCBWUic7XG5cbiAgLy8gRXhpdCBWUiBvbiBjbG9zZS5cbiAgZXhpdC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGV4aXRWUkhhbmRsZXIpO1xuXG4gIG1vZGFsLmFwcGVuZENoaWxkKGV4aXQpO1xuXG4gIHJldHVybiBtb2RhbDtcbn1cblxufSx7XCIuLi8uLi9jb3JlL2NvbXBvbmVudFwiOjU2LFwiLi4vLi4vbGliL3RocmVlXCI6OTAsXCIuLi8uLi91dGlscy9cIjoxMDJ9XSw0NTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgZGVidWcgPSBfZGVyZXFfKCcuLi91dGlscy9kZWJ1ZycpO1xudmFyIGRpZmYgPSBfZGVyZXFfKCcuLi91dGlscycpLmRpZmY7XG52YXIgcmVnaXN0ZXJDb21wb25lbnQgPSBfZGVyZXFfKCcuLi9jb3JlL2NvbXBvbmVudCcpLnJlZ2lzdGVyQ29tcG9uZW50O1xudmFyIFRIUkVFID0gX2RlcmVxXygnLi4vbGliL3RocmVlJyk7XG5cbnZhciB3YXJuID0gZGVidWcoJ2NvbXBvbmVudHM6c291bmQ6d2FybicpO1xuXG4vKipcbiAqIFNvdW5kIGNvbXBvbmVudC5cbiAqL1xubW9kdWxlLmV4cG9ydHMuQ29tcG9uZW50ID0gcmVnaXN0ZXJDb21wb25lbnQoJ3NvdW5kJywge1xuICBzY2hlbWE6IHtcbiAgICBzcmM6IHsgZGVmYXVsdDogJycgfSxcbiAgICBvbjogeyBkZWZhdWx0OiAnY2xpY2snIH0sXG4gICAgYXV0b3BsYXk6IHsgZGVmYXVsdDogZmFsc2UgfSxcbiAgICBsb29wOiB7IGRlZmF1bHQ6IGZhbHNlIH0sXG4gICAgdm9sdW1lOiB7IGRlZmF1bHQ6IDEgfVxuICB9LFxuXG4gIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmxpc3RlbmVyID0gbnVsbDtcbiAgICB0aGlzLnNvdW5kID0gbnVsbDtcbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uIChvbGREYXRhKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgdmFyIGRpZmZEYXRhID0gZGlmZihvbGREYXRhIHx8IHt9LCBkYXRhKTtcbiAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgIHZhciBzb3VuZCA9IHRoaXMuc291bmQ7XG4gICAgdmFyIHNyYyA9IGRhdGEuc3JjO1xuICAgIHZhciBzcmNDaGFuZ2VkID0gJ3NyYycgaW4gZGlmZkRhdGE7XG5cbiAgICAvLyBDcmVhdGUgbmV3IHNvdW5kIGlmIG5vdCB5ZXQgY3JlYXRlZCBvciBjaGFuZ2luZyBgc3JjYC5cbiAgICBpZiAoc3JjQ2hhbmdlZCkge1xuICAgICAgaWYgKCFzcmMpIHtcbiAgICAgICAgd2FybignQXVkaW8gc291cmNlIHdhcyBub3Qgc3BlY2lmaWVkIHdpdGggYHNyY2AnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc291bmQgPSB0aGlzLnNldHVwU291bmQoKTtcbiAgICB9XG5cbiAgICBpZiAoc3JjQ2hhbmdlZCB8fCAnYXV0b3BsYXknIGluIGRpZmZEYXRhKSB7XG4gICAgICBzb3VuZC5hdXRvcGxheSA9IGRhdGEuYXV0b3BsYXk7XG4gICAgfVxuXG4gICAgaWYgKHNyY0NoYW5nZWQgfHwgJ2xvb3AnIGluIGRpZmZEYXRhKSB7XG4gICAgICBzb3VuZC5zZXRMb29wKGRhdGEubG9vcCk7XG4gICAgfVxuXG4gICAgaWYgKHNyY0NoYW5nZWQgfHwgJ3ZvbHVtZScgaW4gZGlmZkRhdGEpIHtcbiAgICAgIHNvdW5kLnNldFZvbHVtZShkYXRhLnZvbHVtZSk7XG4gICAgfVxuXG4gICAgaWYgKCdvbicgaW4gZGlmZkRhdGEpIHtcbiAgICAgIGlmIChvbGREYXRhICYmIG9sZERhdGEub24pIHtcbiAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihvbGREYXRhLm9uKTtcbiAgICAgIH1cbiAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoZGF0YS5vbiwgdGhpcy5wbGF5LmJpbmQodGhpcykpO1xuICAgIH1cblxuICAgIC8vIEFsbCBzb3VuZCB2YWx1ZXMgc2V0LiBMb2FkIGluIGBzcmMuXG4gICAgaWYgKHNyY0NoYW5nZWQpIHtcbiAgICAgIHNvdW5kLmxvYWQoc3JjKTtcbiAgICB9XG4gIH0sXG5cbiAgcmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5lbC5yZW1vdmVPYmplY3QzRCgnc291bmQnKTtcbiAgICB0aGlzLnNvdW5kLmRpc2Nvbm5lY3QoKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVtb3ZlcyBjdXJyZW50IHNvdW5kIG9iamVjdCwgY3JlYXRlcyBuZXcgc291bmQgb2JqZWN0LCBhZGRzIHRvIGVudGl0eS5cbiAgICpcbiAgICogQHJldHVybnMge29iamVjdH0gc291bmRcbiAgICovXG4gIHNldHVwU291bmQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgIHZhciBzY2VuZUVsID0gZWwuc2NlbmVFbDtcbiAgICB2YXIgc291bmQgPSB0aGlzLnNvdW5kO1xuXG4gICAgaWYgKHNvdW5kKSB7XG4gICAgICB0aGlzLnN0b3AoKTtcbiAgICAgIGVsLnJlbW92ZU9iamVjdDNEKCdzb3VuZCcpO1xuICAgIH1cblxuICAgIC8vIE9ubHkgd2FudCBvbmUgQXVkaW9MaXN0ZW5lci4gQ2FjaGUgaXQgb24gdGhlIHNjZW5lLlxuICAgIHZhciBsaXN0ZW5lciA9IHRoaXMubGlzdGVuZXIgPSBzY2VuZUVsLmF1ZGlvTGlzdGVuZXIgfHwgbmV3IFRIUkVFLkF1ZGlvTGlzdGVuZXIoKTtcbiAgICBzY2VuZUVsLmF1ZGlvTGlzdGVuZXIgPSBsaXN0ZW5lcjtcblxuICAgIGlmIChzY2VuZUVsLmNhbWVyYSkge1xuICAgICAgc2NlbmVFbC5jYW1lcmEuYWRkKGxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICAvLyBXYWl0IGZvciBjYW1lcmEgaWYgbmVjZXNzYXJ5LlxuICAgIHNjZW5lRWwuYWRkRXZlbnRMaXN0ZW5lcignY2FtZXJhLXNldC1hY3RpdmUnLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICBldnQuZGV0YWlsLmNhbWVyYUVsLmdldE9iamVjdDNEKCdjYW1lcmEnKS5hZGQobGlzdGVuZXIpO1xuICAgIH0pO1xuXG4gICAgc291bmQgPSB0aGlzLnNvdW5kID0gbmV3IFRIUkVFLlBvc2l0aW9uYWxBdWRpbyhsaXN0ZW5lcik7XG4gICAgZWwuc2V0T2JqZWN0M0QoJ3NvdW5kJywgc291bmQpO1xuXG4gICAgc291bmQuc291cmNlLm9uZW5kZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBzb3VuZC5vbkVuZGVkKCk7XG4gICAgICBlbC5lbWl0KCdzb3VuZC1lbmRlZCcpO1xuICAgIH07XG5cbiAgICByZXR1cm4gc291bmQ7XG4gIH0sXG5cbiAgcGxheTogZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5zb3VuZC5zb3VyY2UuYnVmZmVyKSB7IHJldHVybjsgfVxuICAgIHRoaXMuc291bmQucGxheSgpO1xuICB9LFxuXG4gIHN0b3A6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuc291bmQuc291cmNlLmJ1ZmZlcikgeyByZXR1cm47IH1cbiAgICB0aGlzLnNvdW5kLnN0b3AoKTtcbiAgfSxcblxuICBwYXVzZTogZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5zb3VuZC5zb3VyY2UuYnVmZmVyIHx8ICF0aGlzLnNvdW5kLmlzUGxheWluZykgeyByZXR1cm47IH1cbiAgICB0aGlzLnNvdW5kLnBhdXNlKCk7XG4gIH1cbn0pO1xuXG59LHtcIi4uL2NvcmUvY29tcG9uZW50XCI6NTYsXCIuLi9saWIvdGhyZWVcIjo5MCxcIi4uL3V0aWxzXCI6MTAyLFwiLi4vdXRpbHMvZGVidWdcIjoxMDF9XSw0NjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgcmVnaXN0ZXJDb21wb25lbnQgPSBfZGVyZXFfKCcuLi9jb3JlL2NvbXBvbmVudCcpLnJlZ2lzdGVyQ29tcG9uZW50O1xuXG4vKipcbiAqIFZpc2liaWxpdHkgY29tcG9uZW50LlxuICovXG5tb2R1bGUuZXhwb3J0cy5Db21wb25lbnQgPSByZWdpc3RlckNvbXBvbmVudCgndmlzaWJsZScsIHtcbiAgc2NoZW1hOiB7XG4gICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgIGRlZmF1bHQ6IHRydWVcbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmVsLm9iamVjdDNELnZpc2libGUgPSB0aGlzLmRhdGE7XG4gIH1cbn0pO1xuXG59LHtcIi4uL2NvcmUvY29tcG9uZW50XCI6NTZ9XSw0NzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgcmVnaXN0ZXJDb21wb25lbnQgPSBfZGVyZXFfKCcuLi9jb3JlL2NvbXBvbmVudCcpLnJlZ2lzdGVyQ29tcG9uZW50O1xudmFyIHNob3VsZENhcHR1cmVLZXlFdmVudCA9IF9kZXJlcV8oJy4uL3V0aWxzLycpLnNob3VsZENhcHR1cmVLZXlFdmVudDtcbnZhciBUSFJFRSA9IF9kZXJlcV8oJy4uL2xpYi90aHJlZScpO1xuXG52YXIgTUFYX0RFTFRBID0gMC4yO1xuXG4vKipcbiAqIFdBU0QgY29tcG9uZW50IHRvIGNvbnRyb2wgZW50aXRpZXMgdXNpbmcgV0FTRCBrZXlzLlxuICovXG5tb2R1bGUuZXhwb3J0cy5Db21wb25lbnQgPSByZWdpc3RlckNvbXBvbmVudCgnd2FzZC1jb250cm9scycsIHtcbiAgc2NoZW1hOiB7XG4gICAgZWFzaW5nOiB7IGRlZmF1bHQ6IDIwIH0sXG4gICAgYWNjZWxlcmF0aW9uOiB7IGRlZmF1bHQ6IDY1IH0sXG4gICAgZW5hYmxlZDogeyBkZWZhdWx0OiB0cnVlIH0sXG4gICAgZmx5OiB7IGRlZmF1bHQ6IGZhbHNlIH0sXG4gICAgd3NBeGlzOiB7IGRlZmF1bHQ6ICd6Jywgb25lT2Y6IFsgJ3gnLCAneScsICd6JyBdIH0sXG4gICAgYWRBeGlzOiB7IGRlZmF1bHQ6ICd4Jywgb25lT2Y6IFsgJ3gnLCAneScsICd6JyBdIH0sXG4gICAgd3NJbnZlcnRlZDogeyBkZWZhdWx0OiBmYWxzZSB9LFxuICAgIHdzRW5hYmxlZDogeyBkZWZhdWx0OiB0cnVlIH0sXG4gICAgYWRJbnZlcnRlZDogeyBkZWZhdWx0OiBmYWxzZSB9LFxuICAgIGFkRW5hYmxlZDogeyBkZWZhdWx0OiB0cnVlIH1cbiAgfSxcblxuICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy52ZWxvY2l0eSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgLy8gVG8ga2VlcCB0cmFjayBvZiB0aGUgcHJlc3NlZCBrZXlzXG4gICAgdGhpcy5rZXlzID0ge307XG4gICAgdGhpcy5vbkJsdXIgPSB0aGlzLm9uQmx1ci5iaW5kKHRoaXMpO1xuICAgIHRoaXMub25Gb2N1cyA9IHRoaXMub25Gb2N1cy5iaW5kKHRoaXMpO1xuICAgIHRoaXMub25WaXNpYmlsaXR5Q2hhbmdlID0gdGhpcy5vblZpc2liaWxpdHlDaGFuZ2UuYmluZCh0aGlzKTtcbiAgICB0aGlzLm9uS2V5RG93biA9IHRoaXMub25LZXlEb3duLmJpbmQodGhpcyk7XG4gICAgdGhpcy5vbktleVVwID0gdGhpcy5vbktleVVwLmJpbmQodGhpcyk7XG4gICAgdGhpcy5hdHRhY2hWaXNpYmlsaXR5RXZlbnRMaXN0ZW5lcnMoKTtcbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uIChwcmV2aW91c0RhdGEpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICB2YXIgYWNjZWxlcmF0aW9uID0gZGF0YS5hY2NlbGVyYXRpb247XG4gICAgdmFyIGVhc2luZyA9IGRhdGEuZWFzaW5nO1xuICAgIHZhciB2ZWxvY2l0eSA9IHRoaXMudmVsb2NpdHk7XG4gICAgdmFyIHByZXZUaW1lID0gdGhpcy5wcmV2VGltZSA9IHRoaXMucHJldlRpbWUgfHwgRGF0ZS5ub3coKTtcbiAgICB2YXIgdGltZSA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICB2YXIgZGVsdGEgPSAodGltZSAtIHByZXZUaW1lKSAvIDEwMDA7XG4gICAgdmFyIGtleXMgPSB0aGlzLmtleXM7XG4gICAgdmFyIG1vdmVtZW50VmVjdG9yO1xuICAgIHZhciBhZEF4aXMgPSBkYXRhLmFkQXhpcztcbiAgICB2YXIgd3NBeGlzID0gZGF0YS53c0F4aXM7XG4gICAgdmFyIGFkU2lnbiA9IGRhdGEuYWRJbnZlcnRlZCA/IC0xIDogMTtcbiAgICB2YXIgd3NTaWduID0gZGF0YS53c0ludmVydGVkID8gLTEgOiAxO1xuICAgIHZhciBlbCA9IHRoaXMuZWw7XG4gICAgdGhpcy5wcmV2VGltZSA9IHRpbWU7XG5cbiAgICAvLyBJZiBkYXRhIGNoYW5nZWQgb3IgRlBTIHRvbyBsb3csIHJlc2V0IHZlbG9jaXR5LlxuICAgIGlmIChwcmV2aW91c0RhdGEgfHwgZGVsdGEgPiBNQVhfREVMVEEpIHtcbiAgICAgIHZlbG9jaXR5W2FkQXhpc10gPSAwO1xuICAgICAgdmVsb2NpdHlbd3NBeGlzXSA9IDA7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmVsb2NpdHlbYWRBeGlzXSAtPSB2ZWxvY2l0eVthZEF4aXNdICogZWFzaW5nICogZGVsdGE7XG4gICAgdmVsb2NpdHlbd3NBeGlzXSAtPSB2ZWxvY2l0eVt3c0F4aXNdICogZWFzaW5nICogZGVsdGE7XG5cbiAgICB2YXIgcG9zaXRpb24gPSBlbC5nZXRDb21wdXRlZEF0dHJpYnV0ZSgncG9zaXRpb24nKTtcblxuICAgIGlmIChkYXRhLmVuYWJsZWQpIHtcbiAgICAgIGlmIChkYXRhLmFkRW5hYmxlZCkge1xuICAgICAgICBpZiAoa2V5c1s2NV0pIHsgdmVsb2NpdHlbYWRBeGlzXSAtPSBhZFNpZ24gKiBhY2NlbGVyYXRpb24gKiBkZWx0YTsgfSAvLyBMZWZ0XG4gICAgICAgIGlmIChrZXlzWzY4XSkgeyB2ZWxvY2l0eVthZEF4aXNdICs9IGFkU2lnbiAqIGFjY2VsZXJhdGlvbiAqIGRlbHRhOyB9IC8vIFJpZ2h0XG4gICAgICB9XG4gICAgICBpZiAoZGF0YS53c0VuYWJsZWQpIHtcbiAgICAgICAgaWYgKGtleXNbODddKSB7IHZlbG9jaXR5W3dzQXhpc10gLT0gd3NTaWduICogYWNjZWxlcmF0aW9uICogZGVsdGE7IH0gLy8gVXBcbiAgICAgICAgaWYgKGtleXNbODNdKSB7IHZlbG9jaXR5W3dzQXhpc10gKz0gd3NTaWduICogYWNjZWxlcmF0aW9uICogZGVsdGE7IH0gLy8gRG93blxuICAgICAgfVxuICAgIH1cblxuICAgIG1vdmVtZW50VmVjdG9yID0gdGhpcy5nZXRNb3ZlbWVudFZlY3RvcihkZWx0YSk7XG4gICAgZWwub2JqZWN0M0QudHJhbnNsYXRlWChtb3ZlbWVudFZlY3Rvci54KTtcbiAgICBlbC5vYmplY3QzRC50cmFuc2xhdGVZKG1vdmVtZW50VmVjdG9yLnkpO1xuICAgIGVsLm9iamVjdDNELnRyYW5zbGF0ZVoobW92ZW1lbnRWZWN0b3Iueik7XG5cbiAgICBlbC5zZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywge1xuICAgICAgeDogcG9zaXRpb24ueCArIG1vdmVtZW50VmVjdG9yLngsXG4gICAgICB5OiBwb3NpdGlvbi55ICsgbW92ZW1lbnRWZWN0b3IueSxcbiAgICAgIHo6IHBvc2l0aW9uLnogKyBtb3ZlbWVudFZlY3Rvci56XG4gICAgfSk7XG4gIH0sXG5cbiAgcGxheTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYXR0YWNoS2V5RXZlbnRMaXN0ZW5lcnMoKTtcbiAgfSxcblxuICBwYXVzZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMua2V5cyA9IHt9O1xuICAgIHRoaXMucmVtb3ZlS2V5RXZlbnRMaXN0ZW5lcnMoKTtcbiAgfSxcblxuICB0aWNrOiBmdW5jdGlvbiAodCkge1xuICAgIHRoaXMudXBkYXRlKCk7XG4gIH0sXG5cbiAgcmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5wYXVzZSgpO1xuICAgIHRoaXMucmVtb3ZlVmlzaWJpbGl0eUV2ZW50TGlzdGVuZXJzKCk7XG4gIH0sXG5cbiAgYXR0YWNoVmlzaWJpbGl0eUV2ZW50TGlzdGVuZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCB0aGlzLm9uQmx1cik7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgdGhpcy5vbkZvY3VzKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgdGhpcy5vblZpc2liaWxpdHlDaGFuZ2UpO1xuICB9LFxuXG4gIHJlbW92ZVZpc2liaWxpdHlFdmVudExpc3RlbmVyczogZnVuY3Rpb24gKCkge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdibHVyJywgdGhpcy5vbkJsdXIpO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1cycsIHRoaXMub25Gb2N1cyk7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIHRoaXMub25WaXNpYmlsaXR5Q2hhbmdlKTtcbiAgfSxcblxuICBhdHRhY2hLZXlFdmVudExpc3RlbmVyczogZnVuY3Rpb24gKCkge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5vbktleURvd24pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIHRoaXMub25LZXlVcCk7XG4gIH0sXG5cbiAgcmVtb3ZlS2V5RXZlbnRMaXN0ZW5lcnM6IGZ1bmN0aW9uICgpIHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMub25LZXlEb3duKTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB0aGlzLm9uS2V5VXApO1xuICB9LFxuXG4gIG9uQmx1cjogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucGF1c2UoKTtcbiAgfSxcblxuICBvbkZvY3VzOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5wbGF5KCk7XG4gIH0sXG5cbiAgb25WaXNpYmlsaXR5Q2hhbmdlOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGRvY3VtZW50LmhpZGRlbikge1xuICAgICAgdGhpcy5vbkJsdXIoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vbkZvY3VzKCk7XG4gICAgfVxuICB9LFxuXG4gIG9uS2V5RG93bjogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKCFzaG91bGRDYXB0dXJlS2V5RXZlbnQoZXZlbnQpKSB7IHJldHVybjsgfVxuICAgIHRoaXMua2V5c1tldmVudC5rZXlDb2RlXSA9IHRydWU7XG4gIH0sXG5cbiAgb25LZXlVcDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKCFzaG91bGRDYXB0dXJlS2V5RXZlbnQoZXZlbnQpKSB7IHJldHVybjsgfVxuICAgIHRoaXMua2V5c1tldmVudC5rZXlDb2RlXSA9IGZhbHNlO1xuICB9LFxuXG4gIGdldE1vdmVtZW50VmVjdG9yOiAoZnVuY3Rpb24gKGRlbHRhKSB7XG4gICAgdmFyIGRpcmVjdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKDAsIDAsIDApO1xuICAgIHZhciByb3RhdGlvbiA9IG5ldyBUSFJFRS5FdWxlcigwLCAwLCAwLCAnWVhaJyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkZWx0YSkge1xuICAgICAgdmFyIHZlbG9jaXR5ID0gdGhpcy52ZWxvY2l0eTtcbiAgICAgIHZhciBlbFJvdGF0aW9uID0gdGhpcy5lbC5nZXRBdHRyaWJ1dGUoJ3JvdGF0aW9uJyk7XG4gICAgICBkaXJlY3Rpb24uY29weSh2ZWxvY2l0eSk7XG4gICAgICBkaXJlY3Rpb24ubXVsdGlwbHlTY2FsYXIoZGVsdGEpO1xuICAgICAgaWYgKCFlbFJvdGF0aW9uKSB7IHJldHVybiBkaXJlY3Rpb247IH1cbiAgICAgIGlmICghdGhpcy5kYXRhLmZseSkgeyBlbFJvdGF0aW9uLnggPSAwOyB9XG4gICAgICByb3RhdGlvbi5zZXQoVEhSRUUuTWF0aC5kZWdUb1JhZChlbFJvdGF0aW9uLngpLFxuICAgICAgICAgICAgICAgICAgIFRIUkVFLk1hdGguZGVnVG9SYWQoZWxSb3RhdGlvbi55KSwgMCk7XG4gICAgICBkaXJlY3Rpb24uYXBwbHlFdWxlcihyb3RhdGlvbik7XG4gICAgICByZXR1cm4gZGlyZWN0aW9uO1xuICAgIH07XG4gIH0pKClcbn0pO1xuXG59LHtcIi4uL2NvcmUvY29tcG9uZW50XCI6NTYsXCIuLi9saWIvdGhyZWVcIjo5MCxcIi4uL3V0aWxzL1wiOjEwMn1dLDQ4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQW5pbWF0aW9uIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgVFdFRU4uanMgYW5pbWF0aW9ucy5cbiAqIFVzZWQgYnkgYDxhLWFuaW1hdGlvbj5gLlxuICovXG52YXIgVFdFRU4gPSBfZGVyZXFfKCd0d2Vlbi5qcycpO1xuXG52YXIgRElSRUNUSU9OUyA9IHtcbiAgYWx0ZXJuYXRlOiAnYWx0ZXJuYXRlJyxcbiAgYWx0ZXJuYXRlUmV2ZXJzZTogJ2FsdGVybmF0ZS1yZXZlcnNlJyxcbiAgbm9ybWFsOiAnbm9ybWFsJyxcbiAgcmV2ZXJzZTogJ3JldmVyc2UnXG59O1xuXG52YXIgRUFTSU5HX0ZVTkNUSU9OUyA9IHtcbiAgJ2xpbmVhcic6IFRXRUVOLkVhc2luZy5MaW5lYXIuTm9uZSxcblxuICAnZWFzZSc6IFRXRUVOLkVhc2luZy5DdWJpYy5Jbk91dCxcbiAgJ2Vhc2UtaW4nOiBUV0VFTi5FYXNpbmcuQ3ViaWMuSW4sXG4gICdlYXNlLW91dCc6IFRXRUVOLkVhc2luZy5DdWJpYy5PdXQsXG4gICdlYXNlLWluLW91dCc6IFRXRUVOLkVhc2luZy5DdWJpYy5Jbk91dCxcblxuICAnZWFzZS1jdWJpYyc6IFRXRUVOLkVhc2luZy5DdWJpYy5JbixcbiAgJ2Vhc2UtaW4tY3ViaWMnOiBUV0VFTi5FYXNpbmcuQ3ViaWMuSW4sXG4gICdlYXNlLW91dC1jdWJpYyc6IFRXRUVOLkVhc2luZy5DdWJpYy5PdXQsXG4gICdlYXNlLWluLW91dC1jdWJpYyc6IFRXRUVOLkVhc2luZy5DdWJpYy5Jbk91dCxcblxuICAnZWFzZS1xdWFkJzogVFdFRU4uRWFzaW5nLlF1YWRyYXRpYy5Jbk91dCxcbiAgJ2Vhc2UtaW4tcXVhZCc6IFRXRUVOLkVhc2luZy5RdWFkcmF0aWMuSW4sXG4gICdlYXNlLW91dC1xdWFkJzogVFdFRU4uRWFzaW5nLlF1YWRyYXRpYy5PdXQsXG4gICdlYXNlLWluLW91dC1xdWFkJzogVFdFRU4uRWFzaW5nLlF1YWRyYXRpYy5Jbk91dCxcblxuICAnZWFzZS1xdWFydCc6IFRXRUVOLkVhc2luZy5RdWFydGljLkluT3V0LFxuICAnZWFzZS1pbi1xdWFydCc6IFRXRUVOLkVhc2luZy5RdWFydGljLkluLFxuICAnZWFzZS1vdXQtcXVhcnQnOiBUV0VFTi5FYXNpbmcuUXVhcnRpYy5PdXQsXG4gICdlYXNlLWluLW91dC1xdWFydCc6IFRXRUVOLkVhc2luZy5RdWFydGljLkluT3V0LFxuXG4gICdlYXNlLXF1aW50JzogVFdFRU4uRWFzaW5nLlF1aW50aWMuSW5PdXQsXG4gICdlYXNlLWluLXF1aW50JzogVFdFRU4uRWFzaW5nLlF1aW50aWMuSW4sXG4gICdlYXNlLW91dC1xdWludCc6IFRXRUVOLkVhc2luZy5RdWludGljLk91dCxcbiAgJ2Vhc2UtaW4tb3V0LXF1aW50JzogVFdFRU4uRWFzaW5nLlF1aW50aWMuSW5PdXQsXG5cbiAgJ2Vhc2Utc2luZSc6IFRXRUVOLkVhc2luZy5TaW51c29pZGFsLkluT3V0LFxuICAnZWFzZS1pbi1zaW5lJzogVFdFRU4uRWFzaW5nLlNpbnVzb2lkYWwuSW4sXG4gICdlYXNlLW91dC1zaW5lJzogVFdFRU4uRWFzaW5nLlNpbnVzb2lkYWwuT3V0LFxuICAnZWFzZS1pbi1vdXQtc2luZSc6IFRXRUVOLkVhc2luZy5TaW51c29pZGFsLkluT3V0LFxuXG4gICdlYXNlLWV4cG8nOiBUV0VFTi5FYXNpbmcuRXhwb25lbnRpYWwuSW5PdXQsXG4gICdlYXNlLWluLWV4cG8nOiBUV0VFTi5FYXNpbmcuRXhwb25lbnRpYWwuSW4sXG4gICdlYXNlLW91dC1leHBvJzogVFdFRU4uRWFzaW5nLkV4cG9uZW50aWFsLk91dCxcbiAgJ2Vhc2UtaW4tb3V0LWV4cG8nOiBUV0VFTi5FYXNpbmcuRXhwb25lbnRpYWwuSW5PdXQsXG5cbiAgJ2Vhc2UtY2lyYyc6IFRXRUVOLkVhc2luZy5DaXJjdWxhci5Jbk91dCxcbiAgJ2Vhc2UtaW4tY2lyYyc6IFRXRUVOLkVhc2luZy5DaXJjdWxhci5JbixcbiAgJ2Vhc2Utb3V0LWNpcmMnOiBUV0VFTi5FYXNpbmcuQ2lyY3VsYXIuT3V0LFxuICAnZWFzZS1pbi1vdXQtY2lyYyc6IFRXRUVOLkVhc2luZy5DaXJjdWxhci5Jbk91dCxcblxuICAnZWFzZS1lbGFzdGljJzogVFdFRU4uRWFzaW5nLkVsYXN0aWMuSW5PdXQsXG4gICdlYXNlLWluLWVsYXN0aWMnOiBUV0VFTi5FYXNpbmcuRWxhc3RpYy5JbixcbiAgJ2Vhc2Utb3V0LWVsYXN0aWMnOiBUV0VFTi5FYXNpbmcuRWxhc3RpYy5PdXQsXG4gICdlYXNlLWluLW91dC1lbGFzdGljJzogVFdFRU4uRWFzaW5nLkVsYXN0aWMuSW5PdXQsXG5cbiAgJ2Vhc2UtYmFjayc6IFRXRUVOLkVhc2luZy5CYWNrLkluT3V0LFxuICAnZWFzZS1pbi1iYWNrJzogVFdFRU4uRWFzaW5nLkJhY2suSW4sXG4gICdlYXNlLW91dC1iYWNrJzogVFdFRU4uRWFzaW5nLkJhY2suT3V0LFxuICAnZWFzZS1pbi1vdXQtYmFjayc6IFRXRUVOLkVhc2luZy5CYWNrLkluT3V0LFxuXG4gICdlYXNlLWJvdW5jZSc6IFRXRUVOLkVhc2luZy5Cb3VuY2UuSW5PdXQsXG4gICdlYXNlLWluLWJvdW5jZSc6IFRXRUVOLkVhc2luZy5Cb3VuY2UuSW4sXG4gICdlYXNlLW91dC1ib3VuY2UnOiBUV0VFTi5FYXNpbmcuQm91bmNlLk91dCxcbiAgJ2Vhc2UtaW4tb3V0LWJvdW5jZSc6IFRXRUVOLkVhc2luZy5Cb3VuY2UuSW5PdXRcbn07XG5cbnZhciBGSUxMUyA9IHtcbiAgYmFja3dhcmRzOiAnYmFja3dhcmRzJyxcbiAgYm90aDogJ2JvdGgnLFxuICBmb3J3YXJkczogJ2ZvcndhcmRzJyxcbiAgbm9uZTogJ25vbmUnXG59O1xuXG52YXIgUkVQRUFUUyA9IHtcbiAgaW5kZWZpbml0ZTogJ2luZGVmaW5pdGUnXG59O1xuXG52YXIgREVGQVVMVFMgPSB7XG4gIGF0dHJpYnV0ZTogJ3JvdGF0aW9uJyxcbiAgYmVnaW46ICcwJyxcbiAgZHVyOiAxMDAwLFxuICBlYXNpbmc6ICdlYXNlJyxcbiAgZGlyZWN0aW9uOiBESVJFQ1RJT05TLm5vcm1hbCxcbiAgZmlsbDogRklMTFMuZm9yd2FyZHMsXG4gIGZyb206IHVuZGVmaW5lZCxcbiAgcmVwZWF0OiAwLFxuICB0bzogdW5kZWZpbmVkXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0cyA9IERFRkFVTFRTO1xubW9kdWxlLmV4cG9ydHMuZGlyZWN0aW9ucyA9IERJUkVDVElPTlM7XG5tb2R1bGUuZXhwb3J0cy5lYXNpbmdGdW5jdGlvbnMgPSBFQVNJTkdfRlVOQ1RJT05TO1xubW9kdWxlLmV4cG9ydHMuZmlsbHMgPSBGSUxMUztcbm1vZHVsZS5leHBvcnRzLnJlcGVhdHMgPSBSRVBFQVRTO1xuXG59LHtcInR3ZWVuLmpzXCI6MjJ9XSw0OTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgQU5vZGUgPSBfZGVyZXFfKCcuL2Etbm9kZScpO1xudmFyIGNvbnN0YW50cyA9IF9kZXJlcV8oJy4uL2NvbnN0YW50cy9hbmltYXRpb24nKTtcbnZhciBjb29yZGluYXRlcyA9IF9kZXJlcV8oJy4uL3V0aWxzLycpLmNvb3JkaW5hdGVzO1xudmFyIHBhcnNlUHJvcGVydHkgPSBfZGVyZXFfKCcuL3NjaGVtYScpLnBhcnNlUHJvcGVydHk7XG52YXIgcmVnaXN0ZXJFbGVtZW50ID0gX2RlcmVxXygnLi9hLXJlZ2lzdGVyLWVsZW1lbnQnKS5yZWdpc3RlckVsZW1lbnQ7XG52YXIgVFdFRU4gPSBfZGVyZXFfKCd0d2Vlbi5qcycpO1xudmFyIHV0aWxzID0gX2RlcmVxXygnLi4vdXRpbHMvJyk7XG5cbnZhciBERUZBVUxUUyA9IGNvbnN0YW50cy5kZWZhdWx0cztcbnZhciBESVJFQ1RJT05TID0gY29uc3RhbnRzLmRpcmVjdGlvbnM7XG52YXIgRUFTSU5HX0ZVTkNUSU9OUyA9IGNvbnN0YW50cy5lYXNpbmdGdW5jdGlvbnM7XG52YXIgRklMTFMgPSBjb25zdGFudHMuZmlsbHM7XG52YXIgUkVQRUFUUyA9IGNvbnN0YW50cy5yZXBlYXRzO1xudmFyIGlzQ29vcmRpbmF0ZSA9IGNvb3JkaW5hdGVzLmlzQ29vcmRpbmF0ZTtcblxuLyoqXG4gKiBBbmltYXRpb24gZWxlbWVudCB0aGF0IGFwcGxpZXMgVHdlZW4gYW5pbWF0aW9uIHRvIHBhcmVudCBlbGVtZW50IChlbnRpdHkpLlxuICogVGFrZXMgYWZ0ZXIgdGhlIFdlYiBBbmltYXRpb25zIHNwZWMuXG4gKlxuICogQG1lbWJlciB7bnVtYmVyfSBjb3VudCAtIERlY3JlbWVudGluZyBjb3VudGVyIGZvciBob3cgbWFueSBjeWNsZXMgb2YgYW5pbWF0aW9ucyBsZWZ0IHRvXG4gKiAgICAgICAgIHJ1bi5cbiAqIEBtZW1iZXIge0VsZW1lbnR9IGVsIC0gRW50aXR5IHdoaWNoIHRoZSBhbmltYXRpb24gaXMgbW9kaWZ5aW5nLlxuICogQG1lbWJlciBpbml0aWFsVmFsdWUgLSBWYWx1ZSBiZWZvcmUgYW5pbWF0aW9uIHN0YXJ0ZWQuIFVzZWQgdG8gcmVzdG9yZSBzdGF0ZS5cbiAqIEBtZW1iZXIge2Jvb2x9IGlzUnVubmluZyAtIFdoZXRoZXIgYW5pbWF0aW9uIGlzIGN1cnJlbnRseSBydW5uaW5nLlxuICogQG1lbWJlciB7ZnVuY3Rpb259IHBhcnRpYWxTZXRBdHRyaWJ1dGUgLVxuICogICBzZXRBdHRyaWJ1dGUgZnVuY3Rpb24gdGhhdCBpcyBhZ25vc3RpYyB0byB3aGV0aGVyIHdlIGFyZSBzZXR0aW5nIGFuIGF0dHJpYnV0ZSB2YWx1ZVxuICogICBvciBhIGNvbXBvbmVudCBwcm9wZXJ0eSB2YWx1ZS4gVGhlIGVsIGFuZCB0aGUgYXR0cmlidXRlIG5hbWVzIGFyZSBidW5kbGVkIHdpdGhcbiAqICAgdGhlIGZ1bmN0aW9uLlxuICogQG1lbWJlciB7b2JqZWN0fSB0d2VlbiAtIHR3ZWVuLmpzIG9iamVjdC5cbiAqL1xubW9kdWxlLmV4cG9ydHMuQUFuaW1hdGlvbiA9IHJlZ2lzdGVyRWxlbWVudCgnYS1hbmltYXRpb24nLCB7XG4gIHByb3RvdHlwZTogT2JqZWN0LmNyZWF0ZShBTm9kZS5wcm90b3R5cGUsIHtcbiAgICBjcmVhdGVkQ2FsbGJhY2s6IHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuYmluZE1ldGhvZHMoKTtcbiAgICAgICAgdGhpcy5pc1J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wYXJ0aWFsU2V0QXR0cmlidXRlID0gZnVuY3Rpb24gKCkgeyAvKiBuby1vcCAqLyB9O1xuICAgICAgICB0aGlzLnR3ZWVuID0gbnVsbDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYXR0YWNoZWRDYWxsYmFjazoge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgZWwgPSBzZWxmLmVsID0gc2VsZi5wYXJlbnROb2RlO1xuXG4gICAgICAgIGlmIChlbC5pc05vZGUpIHtcbiAgICAgICAgICBpZiAoZWwuaGFzTG9hZGVkKSB7XG4gICAgICAgICAgICBpbml0KCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRlZCcsIGluaXQuYmluZChzZWxmKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRvIGhhbmRsZSBlbGVtZW50cyB0aGF0IGFyZSBub3QgeWV0IGA8YS1lbnRpdHk+YHMgKGUuZy4sIHRlbXBsYXRlcykuXG4gICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignbm9kZXJlYWR5JywgaW5pdC5iaW5kKHNlbGYpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGluaXQgKCkge1xuICAgICAgICAgIHNlbGYuYXBwbHlNaXhpbigpO1xuICAgICAgICAgIHNlbGYudXBkYXRlKCk7XG4gICAgICAgICAgc2VsZi5sb2FkKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrOiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKGF0dHIsIG9sZFZhbCwgbmV3VmFsKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNMb2FkZWQgfHwgIXRoaXMuaXNSdW5uaW5nKSB7IHJldHVybjsgfVxuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgdGhpcy5hcHBseU1peGluKCk7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGRldGFjaGVkQ2FsbGJhY2s6IHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1J1bm5pbmcpIHsgcmV0dXJuOyB9XG4gICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBCdWlsZHMgYSBUd2VlbiBvYmplY3QgdG8gaGFuZGxlIGFuaW1hdGlvbnMuXG4gICAgICogVXNlcyB0d2Vlbi5qcydzIGZyb20sIHRvLCBkZWxheSwgZWFzaW5nLCByZXBlYXQsIG9uVXBkYXRlLCBhbmQgb25Db21wbGV0ZS5cbiAgICAgKiBOb3RlOiB0d2Vlbi5qcyB0YWtlcyBvYmplY3RzIGZvciBpdHMgYGZyb21gIGFuZCBgdG9gIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAgICovXG4gICAgZ2V0VHdlZW46IHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIGRhdGEgPSBzZWxmLmRhdGE7XG4gICAgICAgIHZhciBlbCA9IHNlbGYuZWw7XG4gICAgICAgIHZhciBhbmltYXRpb25WYWx1ZXM7XG4gICAgICAgIHZhciBhdHRyaWJ1dGUgPSBkYXRhLmF0dHJpYnV0ZTtcbiAgICAgICAgdmFyIGJlZ2luID0gcGFyc2VJbnQoZGF0YS5iZWdpbiwgMTApO1xuICAgICAgICB2YXIgY3VycmVudFZhbHVlID0gZWwuZ2V0Q29tcHV0ZWRBdHRyaWJ1dGUoYXR0cmlidXRlKTtcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IHNlbGYuZ2V0RGlyZWN0aW9uKGRhdGEuZGlyZWN0aW9uKTtcbiAgICAgICAgdmFyIGVhc2luZyA9IEVBU0lOR19GVU5DVElPTlNbZGF0YS5lYXNpbmddO1xuICAgICAgICB2YXIgZmlsbCA9IGRhdGEuZmlsbDtcbiAgICAgICAgdmFyIGZyb207XG4gICAgICAgIHZhciByZXBlYXQgPSBkYXRhLnJlcGVhdCA9PT0gUkVQRUFUUy5pbmRlZmluaXRlID8gSW5maW5pdHkgOiAwO1xuICAgICAgICB2YXIgdG87XG4gICAgICAgIHZhciB0b1RlbXA7XG4gICAgICAgIHZhciB5b3lvID0gZmFsc2U7XG5cbiAgICAgICAgYW5pbWF0aW9uVmFsdWVzID0gZ2V0QW5pbWF0aW9uVmFsdWVzKGVsLCBhdHRyaWJ1dGUsIGRhdGEuZnJvbSB8fCBzZWxmLmluaXRpYWxWYWx1ZSwgZGF0YS50bywgY3VycmVudFZhbHVlKTtcbiAgICAgICAgZnJvbSA9IGFuaW1hdGlvblZhbHVlcy5mcm9tO1xuICAgICAgICB0byA9IGFuaW1hdGlvblZhbHVlcy50bztcbiAgICAgICAgc2VsZi5wYXJ0aWFsU2V0QXR0cmlidXRlID0gYW5pbWF0aW9uVmFsdWVzLnBhcnRpYWxTZXRBdHRyaWJ1dGU7XG5cbiAgICAgICAgaWYgKHNlbGYuY291bnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHNlbGYuY291bnQgPSByZXBlYXQgPT09IEluZmluaXR5ID8gMCA6IHBhcnNlSW50KGRhdGEucmVwZWF0LCAxMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNOYU4oYmVnaW4pKSB7IGJlZ2luID0gMDsgfVxuXG4gICAgICAgIC8vIFN0b3JlIGluaXRpYWwgc3RhdGUuXG4gICAgICAgIHNlbGYuaW5pdGlhbFZhbHVlID0gc2VsZi5pbml0aWFsVmFsdWUgfHwgY2xvbmVWYWx1ZShjdXJyZW50VmFsdWUpO1xuXG4gICAgICAgIC8vIEhhbmRsZSBpbmRlZmluaXRlICsgZm9yd2FyZHMgKyBhbHRlcm5hdGUgeW95byBlZGdlLWNhc2UgKCM0MDUpLlxuICAgICAgICBpZiAocmVwZWF0ID09PSBJbmZpbml0eSAmJiBmaWxsID09PSBGSUxMUy5mb3J3YXJkcyAmJlxuICAgICAgICAgICAgW0RJUkVDVElPTlMuYWx0ZXJuYXRlLFxuICAgICAgICAgICAgIERJUkVDVElPTlMuYWx0ZXJuYXRlUmV2ZXJzZV0uaW5kZXhPZihkYXRhLmRpcmVjdGlvbikgIT09IC0xKSB7XG4gICAgICAgICAgeW95byA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiByZXZlcnNpbmcsIHN3YXAgZnJvbSBhbmQgdG8uXG4gICAgICAgIGlmIChkaXJlY3Rpb24gPT09IERJUkVDVElPTlMucmV2ZXJzZSkge1xuICAgICAgICAgIHRvVGVtcCA9IHRvO1xuICAgICAgICAgIHRvID0gY2xvbmVWYWx1ZShmcm9tKTtcbiAgICAgICAgICBmcm9tID0gY2xvbmVWYWx1ZSh0b1RlbXApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgZmlsbCBpcyBiYWNrd2FyZHMgb3IgYm90aCwgc3RhcnQgYW5pbWF0aW9uIGF0IHRoZSBzcGVjaWZpZWQgZnJvbS5cbiAgICAgICAgaWYgKFtGSUxMUy5iYWNrd2FyZHMsIEZJTExTLmJvdGhdLmluZGV4T2YoZmlsbCkgIT09IC0xKSB7XG4gICAgICAgICAgc2VsZi5wYXJ0aWFsU2V0QXR0cmlidXRlKGZyb20pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ3JlYXRlIFR3ZWVuLlxuICAgICAgICByZXR1cm4gbmV3IFRXRUVOLlR3ZWVuKGNsb25lVmFsdWUoZnJvbSkpXG4gICAgICAgICAgLnRvKHRvLCBkYXRhLmR1cilcbiAgICAgICAgICAuZGVsYXkoYmVnaW4pXG4gICAgICAgICAgLmVhc2luZyhlYXNpbmcpXG4gICAgICAgICAgLnJlcGVhdChyZXBlYXQpXG4gICAgICAgICAgLnlveW8oeW95bylcbiAgICAgICAgICAub25VcGRhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2VsZi5wYXJ0aWFsU2V0QXR0cmlidXRlKHRoaXMpO1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLm9uQ29tcGxldGUoc2VsZi5vbkNvbXBsZXRlZC5iaW5kKHNlbGYpKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQW5pbWF0aW9uIHBhcmFtZXRlcnMgY2hhbmdlZC4gU3RvcCBjdXJyZW50IGFuaW1hdGlvbiwgZ2V0IGEgbmV3IG9uZSwgYW5kIHN0YXJ0IGl0LlxuICAgICAqL1xuICAgIHVwZGF0ZToge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICAgIHZhciBiZWdpbiA9IGRhdGEuYmVnaW47XG4gICAgICAgIC8vIENhbmNlbCBwcmV2aW91cyBldmVudCBsaXN0ZW5lcnNcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVycyh0aGlzLmV2dCk7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcnMoYmVnaW4pO1xuICAgICAgICAvLyBTdG9yZSBuZXcgZXZlbnQgbmFtZS5cbiAgICAgICAgdGhpcy5ldnQgPSBiZWdpbjtcbiAgICAgICAgLy8gSWYgYGJlZ2luYCBpcyBhIG51bWJlciwgc3RhcnQgdGhlIGFuaW1hdGlvbiByaWdodCBhd2F5LlxuICAgICAgICBpZiAoIWlzTmFOKGJlZ2luKSkge1xuICAgICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHdyaXRhYmxlOiB3aW5kb3cuZGVidWdcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsbGJhY2sgZm9yIHdoZW4gYSBjeWNsZSBvZiBhbiBhbmltYXRpb24gaXMgY29tcGxldGUuIEhhbmRsZXMgd2hlbiB0byBjb21wbGV0ZWx5XG4gICAgICogZmluaXNoIHRoZSBhbmltYXRpb24uXG4gICAgICpcbiAgICAgKiBJZiBgcmVwZWF0YCBpcyBzZXQgdG8gYSB2YWx1ZSwgdGhpcyBtZXRob2QgaXMgY2FsbGVkIGFmdGVyIGVhY2ggcmVwZWF0LiBSZXBlYXRzIGFyZVxuICAgICAqIGhhbmRsZWQgYnkgZW5kaW5nIHRoZSBjdXJyZW50IGFuaW1hdGlvbiBhbmQgY3JlYXRpbmcgYSBuZXcgb25lIHdpdGggYGNvdW50YCB1cGRhdGVkLlxuICAgICAqIE5vdGUgdGhhdCB0aGlzIG1ldGhvZCBpcyAqbm90KiBjYWxsZWQgaWYgcmVwZWF0IGlzIHNldCB0byBgaW5kZWZpbml0ZWAuXG4gICAgICovXG4gICAgb25Db21wbGV0ZWQ6IHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgICAgICB0aGlzLmlzUnVubmluZyA9IGZhbHNlO1xuICAgICAgICBpZiAoW0ZJTExTLmJhY2t3YXJkcywgRklMTFMubm9uZV0uaW5kZXhPZihkYXRhLmZpbGwpICE9PSAtMSkge1xuICAgICAgICAgIHRoaXMucGFydGlhbFNldEF0dHJpYnV0ZSh0aGlzLmluaXRpYWxWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY291bnQgPT09IDApIHtcbiAgICAgICAgICB0aGlzLmNvdW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHRoaXMuZW1pdCgnYW5pbWF0aW9uZW5kJyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNSdW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY291bnQtLTtcbiAgICAgICAgdGhpcy5zdGFydCgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdGFydDoge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNSdW5uaW5nIHx8ICF0aGlzLmVsLmlzUGxheWluZykgeyByZXR1cm47IH1cbiAgICAgICAgdGhpcy50d2VlbiA9IHRoaXMuZ2V0VHdlZW4oKTtcbiAgICAgICAgdGhpcy5pc1J1bm5pbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLnR3ZWVuLnN0YXJ0KCk7XG4gICAgICAgIHRoaXMuZW1pdCgnYW5pbWF0aW9uc3RhcnQnKTtcbiAgICAgIH0sXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0sXG5cbiAgICBzdG9wOiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdHdlZW4gPSB0aGlzLnR3ZWVuO1xuICAgICAgICBpZiAoIXR3ZWVuKSB7IHJldHVybjsgfVxuICAgICAgICB0d2Vlbi5zdG9wKCk7XG4gICAgICAgIHRoaXMuaXNSdW5uaW5nID0gZmFsc2U7XG4gICAgICAgIGlmIChbRklMTFMuYmFja3dhcmRzLCBGSUxMUy5ub25lXS5pbmRleE9mKHRoaXMuZGF0YS5maWxsKSAhPT0gLTEpIHtcbiAgICAgICAgICB0aGlzLnBhcnRpYWxTZXRBdHRyaWJ1dGUodGhpcy5pbml0aWFsVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdCgnYW5pbWF0aW9uc3RvcCcpO1xuICAgICAgfSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBhbHRlcm5hdGluZyBkaXJlY3Rpb25zLiBHaXZlbiB0aGUgY3VycmVudCBkaXJlY3Rpb24sIGNhbGN1bGF0ZSB0aGUgbmV4dCBvbmUsXG4gICAgICogYW5kIHN0b3JlIHRoZSBjdXJyZW50IG9uZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkaXJlY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBEaXJlY3Rpb24gdGhhdCB0aGUgbmV4dCBpbmRpdmlkdWFsIGN5Y2xlIG9mIHRoZSBhbmltYXRpb24gd2lsbCBnb1xuICAgICAqICAgICAgICAgIHRvd2FyZHMuXG4gICAgICovXG4gICAgZ2V0RGlyZWN0aW9uOiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKGRpcmVjdGlvbikge1xuICAgICAgICBpZiAoZGlyZWN0aW9uID09PSBESVJFQ1RJT05TLmFsdGVybmF0ZSkge1xuICAgICAgICAgIHRoaXMucHJldkRpcmVjdGlvbiA9XG4gICAgICAgICAgICB0aGlzLnByZXZEaXJlY3Rpb24gPT09IERJUkVDVElPTlMubm9ybWFsID8gRElSRUNUSU9OUy5yZXZlcnNlIDogRElSRUNUSU9OUy5ub3JtYWw7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucHJldkRpcmVjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlyZWN0aW9uID09PSBESVJFQ1RJT05TLmFsdGVybmF0ZVJldmVyc2UpIHtcbiAgICAgICAgICB0aGlzLnByZXZEaXJlY3Rpb24gPVxuICAgICAgICAgICAgdGhpcy5wcmV2RGlyZWN0aW9uID09PSBESVJFQ1RJT05TLnJldmVyc2UgPyBESVJFQ1RJT05TLm5vcm1hbCA6IERJUkVDVElPTlMucmV2ZXJzZTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wcmV2RGlyZWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaXJlY3Rpb247XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByZWVtcHRpdmUgYmluZGluZyB0byBhdHRhY2gvZGV0YWNoIGV2ZW50IGxpc3RlbmVycyAoc2VlIGB1cGRhdGVgKS5cbiAgICAgKi9cbiAgICBiaW5kTWV0aG9kczoge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zdGFydCA9IHRoaXMuc3RhcnQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zdG9wID0gdGhpcy5zdG9wLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25TdGF0ZUFkZGVkID0gdGhpcy5vblN0YXRlQWRkZWQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vblN0YXRlUmVtb3ZlZCA9IHRoaXMub25TdGF0ZVJlbW92ZWQuYmluZCh0aGlzKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYWRkRXZlbnRMaXN0ZW5lcnM6IHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiAoZXZ0cykge1xuICAgICAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHV0aWxzLnNwbGl0U3RyaW5nKGV2dHMpLmZvckVhY2goZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZ0LCBzZWxmLnN0YXJ0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIElmIFwiYmVnaW5cIiBpcyBhbiBldmVudCBuYW1lLCB3YWl0LiBJZiBpdCBpcyBhIGRlbGF5IG9yIG5vdCBkZWZpbmVkLCBzdGFydC5cbiAgICAgICAgaWYgKCFpc05hTihldnRzKSkgeyBlbC5hZGRFdmVudExpc3RlbmVyKCdwbGF5JywgdGhpcy5zdGFydCk7IH1cbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcigncGF1c2UnLCB0aGlzLnN0b3ApO1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdzdGF0ZWFkZGVkJywgdGhpcy5vblN0YXRlQWRkZWQpO1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdzdGF0ZXJlbW92ZWQnLCB0aGlzLm9uU3RhdGVSZW1vdmVkKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcnM6IHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiAoZXZ0cykge1xuICAgICAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLnN0YXJ0O1xuICAgICAgICB1dGlscy5zcGxpdFN0cmluZyhldnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2dCwgc3RhcnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignc3RhdGVhZGRlZCcsIHRoaXMub25TdGF0ZUFkZGVkKTtcbiAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignc3RhdGVyZW1vdmVkJywgdGhpcy5vblN0YXRlUmVtb3ZlZCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIG9uU3RhdGVBZGRlZDoge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgaWYgKGV2dC5kZXRhaWwuc3RhdGUgPT09IHRoaXMuZGF0YS5iZWdpbikgeyB0aGlzLnN0YXJ0KCk7IH1cbiAgICAgIH0sXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0sXG5cbiAgICBvblN0YXRlUmVtb3ZlZDoge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgaWYgKGV2dC5kZXRhaWwuc3RhdGUgPT09IHRoaXMuZGF0YS5iZWdpbikgeyB0aGlzLnN0b3AoKTsgfVxuICAgICAgfSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgYW5pbWF0aW9uIGRhdGEgZnJvbSBhIG1peGluIGVsZW1lbnQuXG4gICAgICogV29ya3MgdGhlIHNhbWUgYXMgY29tcG9uZW50IG1peGlucyBidXQgcmVpbXBsZW1lbnRlZCBiZWNhdXNlIGFuaW1hdGlvbnNcbiAgICAgKiBhcmVuJ3QgY29tcG9uZW50cy5cbiAgICAgKi9cbiAgICBhcHBseU1peGluOiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGF0YSA9IHt9O1xuICAgICAgICB2YXIgZWxEYXRhO1xuICAgICAgICB2YXIgbWl4aW5EYXRhO1xuICAgICAgICB2YXIgbWl4aW5FbDtcblxuICAgICAgICAvLyBHZXQgbWl4aW4gZGF0YS5cbiAgICAgICAgbWl4aW5FbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyMnICsgdGhpcy5nZXRBdHRyaWJ1dGUoJ21peGluJykpO1xuICAgICAgICBtaXhpbkRhdGEgPSBtaXhpbkVsID8gdXRpbHMuZ2V0RWxEYXRhKG1peGluRWwsIERFRkFVTFRTKSA6IHt9O1xuXG4gICAgICAgIGVsRGF0YSA9IHV0aWxzLmdldEVsRGF0YSh0aGlzLCBERUZBVUxUUyk7XG4gICAgICAgIHV0aWxzLmV4dGVuZChkYXRhLCBERUZBVUxUUywgbWl4aW5EYXRhLCBlbERhdGEpO1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgfVxuICAgIH1cbiAgfSlcbn0pO1xuXG5mdW5jdGlvbiBjbG9uZVZhbHVlICh2YWwpIHtcbiAgcmV0dXJuIHV0aWxzLmV4dGVuZCh7fSwgdmFsKTtcbn1cblxuLyoqXG4gKiBEZWR1Y2VzIGRpZmZlcmVudCBhbmltYXRpb24gdmFsdWVzIGJhc2VkIG9uIHdoZXRoZXIgd2UgYXJlOlxuICogICAtIGFuaW1hdGluZyBhbiBpbm5lciBhdHRyaWJ1dGUgb2YgYSBjb21wb25lbnQuXG4gKiAgIC0gYW5pbWF0aW5nIGEgY29vcmRpbmF0ZSBjb21wb25lbnQuXG4gKiAgIC0gYW5pbWF0aW5nIGEgYm9vbGVhbi5cbiAqICAgLSBhbmltYXRpbmcgYSBudW1iZXIuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZSAtIFRlbGxzIHdoYXQgdG8gYW5pbWF0ZSBiYXNlZCBvbiB3aGV0aGVyIGl0IGlzIGRvdC1zZXBhcmF0ZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGF0YUZyb20gLSBEYXRhIGBmcm9tYCB2YWx1ZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhVG8gLSBEYXRhIGB0b2AgdmFsdWUuXG4gKiBAcGFyYW0gY3VycmVudFZhbHVlXG4gKiBAcmV0dXJucyB7b2JqZWN0fVxuICogICBPYmplY3Qgd2l0aCBrZXlzIFtmcm9tLCB0bywgcGFydGlhbFNldEF0dHJpYnV0ZV0uXG4gKiAgICAgYGZyb21gIGFuZCBgdG9gXG4gKiAgICAgICAgT2JqZWN0cyB3aGVyZSBrZXkgaXMgYXR0cmlidXRlIGJlaW5nIGFuaW1hdGVkIGFuZCB2YWx1ZSBpcyB2YWx1ZS5cbiAqICAgICBgcGFydGlhbFNldEF0dHJpYnV0ZWBcbiAqICAgICAgICBDbG9zdXJlZC1mdW5jdGlvbiB0aGF0IHRlbGxzIHR3ZWVuIGhvdyB0byB1cGRhdGUgdGhlIGNvbXBvbmVudC5cbiAqL1xuZnVuY3Rpb24gZ2V0QW5pbWF0aW9uVmFsdWVzIChlbCwgYXR0cmlidXRlLCBkYXRhRnJvbSwgZGF0YVRvLCBjdXJyZW50VmFsdWUpIHtcbiAgdmFyIGF0dHJpYnV0ZVNwbGl0ID0gYXR0cmlidXRlLnNwbGl0KCcuJyk7XG4gIHZhciBzY2hlbWE7XG4gIHZhciBjb21wb25lbnQ7XG4gIHZhciBjb21wb25lbnRQcm9wTmFtZTtcbiAgdmFyIGNvbXBvbmVudE5hbWU7XG4gIHZhciBmcm9tID0ge307XG4gIHZhciBwYXJ0aWFsU2V0QXR0cmlidXRlO1xuICB2YXIgdG8gPSB7fTtcblxuICBpZiAoYXR0cmlidXRlU3BsaXQubGVuZ3RoID09PSAyKSB7XG4gICAgZ2V0Rm9yQ29tcG9uZW50QXR0cmlidXRlKCk7XG4gIH0gZWxzZSBpZiAoZGF0YVRvICYmIGlzQ29vcmRpbmF0ZShkYXRhVG8pKSB7XG4gICAgZ2V0Rm9yQ29vcmRpbmF0ZUNvbXBvbmVudCgpO1xuICB9IGVsc2UgaWYgKFsndHJ1ZScsICdmYWxzZSddLmluZGV4T2YoZGF0YVRvKSAhPT0gLTEpIHtcbiAgICBnZXRGb3JCb29sZWFuKCk7XG4gIH0gZWxzZSB7XG4gICAgZ2V0Rm9yTnVtYmVyKCk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBmcm9tOiBmcm9tLFxuICAgIHBhcnRpYWxTZXRBdHRyaWJ1dGU6IHBhcnRpYWxTZXRBdHRyaWJ1dGUsXG4gICAgdG86IHRvXG4gIH07XG5cbiAgLyoqXG4gICAqIEFuaW1hdGluZyBhIGNvbXBvbmVudCB0aGF0IGhhcyBtdWx0aXBsZSBhdHRyaWJ1dGVzIChlLmcuLCBnZW9tZXRyeS53aWR0aCkuXG4gICAqL1xuICBmdW5jdGlvbiBnZXRGb3JDb21wb25lbnRBdHRyaWJ1dGUgKCkge1xuICAgIGNvbXBvbmVudE5hbWUgPSBhdHRyaWJ1dGVTcGxpdFswXTtcbiAgICBjb21wb25lbnRQcm9wTmFtZSA9IGF0dHJpYnV0ZVNwbGl0WzFdO1xuICAgIGNvbXBvbmVudCA9IGVsLmNvbXBvbmVudHNbY29tcG9uZW50TmFtZV07XG4gICAgaWYgKCFjb21wb25lbnQpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShjb21wb25lbnROYW1lLCAnJyk7XG4gICAgICBjb21wb25lbnQgPSBlbC5jb21wb25lbnRzW2NvbXBvbmVudE5hbWVdO1xuICAgIH1cbiAgICBzY2hlbWEgPSBjb21wb25lbnQuc2NoZW1hO1xuICAgIGlmIChkYXRhRnJvbSA9PT0gdW5kZWZpbmVkKSB7ICAvLyBkYXRhRnJvbSBjYW4gYmUgMC5cbiAgICAgIGZyb21bYXR0cmlidXRlXSA9IGVsLmdldENvbXB1dGVkQXR0cmlidXRlKGNvbXBvbmVudE5hbWUpW2NvbXBvbmVudFByb3BOYW1lXTtcbiAgICB9IGVsc2Uge1xuICAgICAgZnJvbVthdHRyaWJ1dGVdID0gZGF0YUZyb207XG4gICAgfVxuICAgIGZyb21bYXR0cmlidXRlXSA9IHBhcnNlUHJvcGVydHkoZnJvbVthdHRyaWJ1dGVdLCBzY2hlbWFbY29tcG9uZW50UHJvcE5hbWVdKTtcbiAgICB0b1thdHRyaWJ1dGVdID0gcGFyc2VQcm9wZXJ0eShkYXRhVG8sIHNjaGVtYVtjb21wb25lbnRQcm9wTmFtZV0pO1xuICAgIHBhcnRpYWxTZXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGlmICghKGF0dHJpYnV0ZSBpbiB2YWx1ZSkpIHsgcmV0dXJuOyB9XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoY29tcG9uZW50TmFtZSwgY29tcG9uZW50UHJvcE5hbWUsIHZhbHVlW2F0dHJpYnV0ZV0pO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQW5pbWF0aW5nIGEgY29tcG9uZW50IHRoYXQgaXMgYW4gWFlaIGNvb3JkaW5hdGUgKGUuZy4sIHBvc2l0aW9uKS5cbiAgICogV2lsbCBiZSB0d2VlbmluZyB7eCwgeSwgen0gYWxsIGF0IG9uY2UuXG4gICAqL1xuICBmdW5jdGlvbiBnZXRGb3JDb29yZGluYXRlQ29tcG9uZW50ICgpIHtcbiAgICBmcm9tID0gZGF0YUZyb20gPyBjb29yZGluYXRlcy5wYXJzZShkYXRhRnJvbSkgOiBjdXJyZW50VmFsdWU7XG4gICAgdG8gPSBjb29yZGluYXRlcy5wYXJzZShkYXRhVG8pO1xuICAgIHBhcnRpYWxTZXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGUsIHZhbHVlKTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEFuaW1hdGlvbiBhIGJvb2xlYW4gKGUuZy4sIHZpc2libGUpLlxuICAgKiBIYXZlIHRvIGNvbnZlcnQgZnJvbSBib29sZWFuIHRvIGFuIGludGVnZXIgKDAgaXMgZmFsc2UsID4gMCBpcyB0cnVlKSBmb3IgdHdlZW4uXG4gICAqL1xuICBmdW5jdGlvbiBnZXRGb3JCb29sZWFuICgpIHtcbiAgICBpZiAoZGF0YUZyb20gPT09IHVuZGVmaW5lZCkge1xuICAgICAgZnJvbVthdHRyaWJ1dGVdID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZyb21bYXR0cmlidXRlXSA9IHN0clRvQm9vbChkYXRhRnJvbSk7XG4gICAgfVxuICAgIGZyb21bYXR0cmlidXRlXSA9IGJvb2xUb051bShmcm9tW2F0dHJpYnV0ZV0pO1xuICAgIHRvW2F0dHJpYnV0ZV0gPSBib29sVG9OdW0oc3RyVG9Cb29sKGRhdGFUbykpO1xuICAgIHBhcnRpYWxTZXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGUsICEhdmFsdWVbYXR0cmlidXRlXSk7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbmltYXRpbmcgYSBudW1iZXJlZCBhdHRyaWJ1dGUgKGUuZy4sIG9wYWNpdHkpLlxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0Rm9yTnVtYmVyICgpIHtcbiAgICBpZiAoZGF0YUZyb20gPT09IHVuZGVmaW5lZCkgeyAgLy8gZGF0YUZyb20gY2FuIGJlIDAuXG4gICAgICBmcm9tW2F0dHJpYnV0ZV0gPSBwYXJzZUZsb2F0KGVsLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZnJvbVthdHRyaWJ1dGVdID0gcGFyc2VGbG9hdChkYXRhRnJvbSk7XG4gICAgfVxuICAgIHRvW2F0dHJpYnV0ZV0gPSBwYXJzZUZsb2F0KGRhdGFUbyk7XG4gICAgcGFydGlhbFNldEF0dHJpYnV0ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZSwgdmFsdWVbYXR0cmlidXRlXSk7XG4gICAgfTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMuZ2V0QW5pbWF0aW9uVmFsdWVzID0gZ2V0QW5pbWF0aW9uVmFsdWVzO1xuXG4vKipcbiAqIENvbnZlcnRzIHN0cmluZyB0byBib29sLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgLSBgdHJ1ZWAgb3IgYGZhbHNlYC5cbiAqIEByZXR1cm5zIHtib29sfVxuICovXG5mdW5jdGlvbiBzdHJUb0Jvb2wgKHN0cikge1xuICBpZiAoc3RyID09PSAndHJ1ZScpIHsgcmV0dXJuIHRydWU7IH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGJvb2xlYW4gdG8gbnVtYmVyLlxuICpcbiAqIEBwYXJhbSB7Ym9vbH1cbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGJvb2xUb051bSAoYm9vbCkge1xuICByZXR1cm4gYm9vbCA/IDEgOiAwO1xufVxuXG59LHtcIi4uL2NvbnN0YW50cy9hbmltYXRpb25cIjo0OCxcIi4uL3V0aWxzL1wiOjEwMixcIi4vYS1ub2RlXCI6NTQsXCIuL2EtcmVnaXN0ZXItZWxlbWVudFwiOjU1LFwiLi9zY2hlbWFcIjo2MixcInR3ZWVuLmpzXCI6MjJ9XSw1MDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgQU5vZGUgPSBfZGVyZXFfKCcuL2Etbm9kZScpO1xudmFyIGRlYnVnID0gX2RlcmVxXygnLi4vdXRpbHMvZGVidWcnKTtcbnZhciByZWdpc3RlckVsZW1lbnQgPSBfZGVyZXFfKCcuL2EtcmVnaXN0ZXItZWxlbWVudCcpLnJlZ2lzdGVyRWxlbWVudDtcbnZhciBUSFJFRSA9IF9kZXJlcV8oJy4uL2xpYi90aHJlZScpO1xuXG52YXIgeGhyTG9hZGVyID0gbmV3IFRIUkVFLlhIUkxvYWRlcigpO1xudmFyIHdhcm4gPSBkZWJ1ZygnY29yZTphLWFzc2V0czp3YXJuJyk7XG5cbi8qKlxuICogQXNzZXQgbWFuYWdlbWVudCBzeXN0ZW0uIEhhbmRsZXMgYmxvY2tpbmcgb24gYXNzZXQgbG9hZGluZy5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSByZWdpc3RlckVsZW1lbnQoJ2EtYXNzZXRzJywge1xuICBwcm90b3R5cGU6IE9iamVjdC5jcmVhdGUoQU5vZGUucHJvdG90eXBlLCB7XG4gICAgY3JlYXRlZENhbGxiYWNrOiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlzQXNzZXRzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYXR0YWNoZWRDYWxsYmFjazoge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgbG9hZGVkID0gW107XG4gICAgICAgIHZhciBhdWRpb3MgPSB0aGlzLnF1ZXJ5U2VsZWN0b3JBbGwoJ2F1ZGlvJyk7XG4gICAgICAgIHZhciBpbWdzID0gdGhpcy5xdWVyeVNlbGVjdG9yQWxsKCdpbWcnKTtcbiAgICAgICAgdmFyIHRpbWVvdXQgPSBwYXJzZUludCh0aGlzLmdldEF0dHJpYnV0ZSgndGltZW91dCcpLCAxMCkgfHwgMzAwMDtcbiAgICAgICAgdmFyIHZpZGVvcyA9IHRoaXMucXVlcnlTZWxlY3RvckFsbCgndmlkZW8nKTtcblxuICAgICAgICBpZiAodGhpcy5wYXJlbnROb2RlLnRhZ05hbWUgIT09ICdBLVNDRU5FJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignPGEtYXNzZXRzPiBtdXN0IGJlIGEgY2hpbGQgb2YgYSA8YS1zY2VuZT4uJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXYWl0IGZvciA8aW1nPnMuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW1ncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGxvYWRlZC5wdXNoKG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHZhciBpbWcgPSBpbWdzW2ldO1xuICAgICAgICAgICAgaW1nLm9ubG9hZCA9IHJlc29sdmU7XG4gICAgICAgICAgICBpbWcub25lcnJvciA9IHJlamVjdDtcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXYWl0IGZvciA8YXVkaW8+cy5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGF1ZGlvcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGxvYWRlZC5wdXNoKG1lZGlhRWxlbWVudExvYWRlZChhdWRpb3NbaV0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdhaXQgZm9yIDx2aWRlbz5zLlxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdmlkZW9zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbG9hZGVkLnB1c2gobWVkaWFFbGVtZW50TG9hZGVkKHZpZGVvc1tpXSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVHJpZ2dlciBsb2FkZWQgZm9yIHNjZW5lIHRvIHN0YXJ0IHJlbmRlcmluZy5cbiAgICAgICAgUHJvbWlzZS5hbGwobG9hZGVkKS50aGVuKHRoaXMubG9hZC5iaW5kKHRoaXMpKTtcblxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoc2VsZi5oYXNMb2FkZWQpIHsgcmV0dXJuOyB9XG4gICAgICAgICAgd2FybignQXNzZXQgbG9hZGluZyB0aW1lZCBvdXQgaW4gJywgdGltZW91dCwgJ21zJyk7XG4gICAgICAgICAgc2VsZi5lbWl0KCd0aW1lb3V0Jyk7XG4gICAgICAgICAgc2VsZi5sb2FkKCk7XG4gICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBsb2FkOiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBBTm9kZS5wcm90b3R5cGUubG9hZC5jYWxsKHRoaXMsIG51bGwsIGZ1bmN0aW9uIHdhaXRPbkZpbHRlciAoZWwpIHtcbiAgICAgICAgICByZXR1cm4gZWwuaXNBc3NldEl0ZW0gJiYgZWwuaGFzQXR0cmlidXRlKCdzcmMnKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9KVxufSk7XG5cbnJlZ2lzdGVyRWxlbWVudCgnYS1hc3NldC1pdGVtJywge1xuICBwcm90b3R5cGU6IE9iamVjdC5jcmVhdGUoQU5vZGUucHJvdG90eXBlLCB7XG4gICAgY3JlYXRlZENhbGxiYWNrOiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRhdGEgPSBudWxsO1xuICAgICAgICB0aGlzLmlzQXNzZXRJdGVtID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYXR0YWNoZWRDYWxsYmFjazoge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgc3JjID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3NyYycpO1xuXG4gICAgICAgIHhockxvYWRlci5sb2FkKHNyYywgZnVuY3Rpb24gKHRleHRSZXNwb25zZSkge1xuICAgICAgICAgIHNlbGYuZGF0YSA9IHRleHRSZXNwb25zZTtcbiAgICAgICAgICBBTm9kZS5wcm90b3R5cGUubG9hZC5jYWxsKHNlbGYpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pXG59KTtcblxuLyoqXG4gKiBDcmVhdGUgYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgb25jZSB0aGUgbWVkaWEgZWxlbWVudCBoYXMgZmluaXNoZWQgYnVmZmVyaW5nLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWwgLSBIVE1MTWVkaWFFbGVtZW50LlxuICogQHJldHVybnMge1Byb21pc2V9XG4gKi9cbmZ1bmN0aW9uIG1lZGlhRWxlbWVudExvYWRlZCAoZWwpIHtcbiAgaWYgKCFlbC5oYXNBdHRyaWJ1dGUoJ2F1dG9wbGF5JykgJiYgZWwuZ2V0QXR0cmlidXRlKCdwcmVsb2FkJykgIT09ICdhdXRvJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIElmIG1lZGlhIHNwZWNpZmllcyBhdXRvcGxheSBvciBwcmVsb2FkLCB3YWl0IHVudGlsIG1lZGlhIGlzIGNvbXBsZXRlbHkgYnVmZmVyZWQuXG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgaWYgKGVsLnJlYWR5U3RhdGUgPT09IDQpIHsgcmV0dXJuIHJlc29sdmUoKTsgfSAgLy8gQWxyZWFkeSBsb2FkZWQuXG4gICAgaWYgKGVsLmVycm9yKSB7IHJldHVybiByZWplY3QoKTsgfSAgLy8gRXJyb3IuXG5cbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdsb2FkZWRkYXRhJywgY2hlY2tQcm9ncmVzcywgZmFsc2UpO1xuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgY2hlY2tQcm9ncmVzcywgZmFsc2UpO1xuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgcmVqZWN0LCBmYWxzZSk7XG5cbiAgICBmdW5jdGlvbiBjaGVja1Byb2dyZXNzICgpIHtcbiAgICAgIC8vIEFkZCB1cCB0aGUgc2Vjb25kcyBidWZmZXJlZC5cbiAgICAgIHZhciBzZWNvbmRzQnVmZmVyZWQgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbC5idWZmZXJlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICBzZWNvbmRzQnVmZmVyZWQgKz0gZWwuYnVmZmVyZWQuZW5kKGkpIC0gZWwuYnVmZmVyZWQuc3RhcnQoaSk7XG4gICAgICB9XG5cbiAgICAgIC8vIENvbXBhcmUgc2Vjb25kcyBidWZmZXJlZCB0byBtZWRpYSBkdXJhdGlvbi5cbiAgICAgIGlmIChzZWNvbmRzQnVmZmVyZWQgPj0gZWwuZHVyYXRpb24pIHtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5cbn0se1wiLi4vbGliL3RocmVlXCI6OTAsXCIuLi91dGlscy9kZWJ1Z1wiOjEwMSxcIi4vYS1ub2RlXCI6NTQsXCIuL2EtcmVnaXN0ZXItZWxlbWVudFwiOjU1fV0sNTE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLyogZ2xvYmFsIEhUTUxFbGVtZW50ICovXG52YXIgZGVidWcgPSBfZGVyZXFfKCcuLi91dGlscy9kZWJ1ZycpO1xudmFyIHJlZ2lzdGVyRWxlbWVudCA9IF9kZXJlcV8oJy4vYS1yZWdpc3Rlci1lbGVtZW50JykucmVnaXN0ZXJFbGVtZW50O1xuXG52YXIgd2FybiA9IGRlYnVnKCdjb3JlOmN1YmVtYXA6d2FybicpO1xuXG4vKipcbiAqIEN1YmVtYXAgZWxlbWVudCB0aGF0IGhhbmRsZXMgdmFsaWRhdGlvbiBhbmQgZXhwb3NlcyBsaXN0IG9mIFVSTHMuXG4gKiBEb2VzIG5vdCBsaXN0ZW4gdG8gdXBkYXRlcy5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSByZWdpc3RlckVsZW1lbnQoJ2EtY3ViZW1hcCcsIHtcbiAgcHJvdG90eXBlOiBPYmplY3QuY3JlYXRlKEhUTUxFbGVtZW50LnByb3RvdHlwZSwge1xuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhpcy5zcmNzLlxuICAgICAqL1xuICAgIGF0dGFjaGVkQ2FsbGJhY2s6IHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc3JjcyA9IHRoaXMudmFsaWRhdGUoKTtcbiAgICAgIH0sXG4gICAgICB3cml0YWJsZTogd2luZG93LmRlYnVnXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBmb3IgZXhhY3RseSBzaXggZWxlbWVudHMgd2l0aCBbc3JjXS5cbiAgICAgKiBEb2VzIG5vdCBjaGVjayBleHBsaWNpdGx5IGZvciA8aW1nPnMgaW4gY2FzZSB1c2VyIGRvZXMgbm90IHdhbnRcbiAgICAgKiBwcmVmZXRjaGluZy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtBcnJheXxudWxsfSAtIHNpeCBVUkxzIGlmIHZhbGlkLCBlbHNlIG51bGwuXG4gICAgICovXG4gICAgdmFsaWRhdGU6IHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlbGVtZW50cyA9IHRoaXMucXVlcnlTZWxlY3RvckFsbCgnW3NyY10nKTtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBzcmNzID0gW107XG4gICAgICAgIGlmIChlbGVtZW50cy5sZW5ndGggPT09IDYpIHtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHNyY3MucHVzaChlbGVtZW50c1tpXS5nZXRBdHRyaWJ1dGUoJ3NyYycpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHNyY3M7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRWxzZSBpZiB0aGVyZSBhcmUgbm90IHNpeCBlbGVtZW50cywgdGhyb3cgYSB3YXJuaW5nLlxuICAgICAgICB3YXJuKFxuICAgICAgICAgICc8YS1jdWJlbWFwPiBkaWQgbm90IGNvbnRhaW4gZXhhY3RseSBzaXggZWxlbWVudHMgZWFjaCB3aXRoIGEgJyArXG4gICAgICAgICAgJ2BzcmNgIGF0dHJpYnV0ZS4nKTtcbiAgICAgIH0sXG4gICAgICB3cml0YWJsZTogd2luZG93LmRlYnVnXG4gICAgfVxuICB9KVxufSk7XG5cbn0se1wiLi4vdXRpbHMvZGVidWdcIjoxMDEsXCIuL2EtcmVnaXN0ZXItZWxlbWVudFwiOjU1fV0sNTI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLyogZ2xvYmFsIEhUTUxFbGVtZW50ICovXG52YXIgQU5vZGUgPSBfZGVyZXFfKCcuL2Etbm9kZScpO1xudmFyIGNvbXBvbmVudHMgPSBfZGVyZXFfKCcuL2NvbXBvbmVudCcpLmNvbXBvbmVudHM7XG52YXIgcmUgPSBfZGVyZXFfKCcuL2EtcmVnaXN0ZXItZWxlbWVudCcpO1xudmFyIFRIUkVFID0gX2RlcmVxXygnLi4vbGliL3RocmVlJyk7XG52YXIgdXRpbHMgPSBfZGVyZXFfKCcuLi91dGlscy8nKTtcblxudmFyIEFFbnRpdHk7XG52YXIgaXNOb2RlID0gcmUuaXNOb2RlO1xudmFyIGRlYnVnID0gdXRpbHMuZGVidWcoJ2NvcmU6YS1lbnRpdHk6ZGVidWcnKTtcbnZhciByZWdpc3RlckVsZW1lbnQgPSByZS5yZWdpc3RlckVsZW1lbnQ7XG52YXIgc3R5bGVQYXJzZXIgPSB1dGlscy5zdHlsZVBhcnNlcjtcblxuLyoqXG4gKiBFbnRpdHkgaXMgYSBjb250YWluZXIgb2JqZWN0IHRoYXQgY29tcG9uZW50cyBhcmUgcGx1Z2dlZCBpbnRvIHRvIGNvbXByaXNlIGV2ZXJ5dGhpbmcgaW5cbiAqIHRoZSBzY2VuZS4gSW4gQS1GcmFtZSwgdGhleSBpbmhlcmVudGx5IGhhdmUgcG9zaXRpb24sIHJvdGF0aW9uLCBhbmQgc2NhbGUuXG4gKlxuICogVG8gYmUgYWJsZSB0byB0YWtlIGNvbXBvbmVudHMsIHRoZSBzY2VuZSBlbGVtZW50IGluaGVyaXRzIGZyb20gdGhlIGVudGl0eSBkZWZpbml0aW9uLlxuICpcbiAqIEBtZW1iZXIge29iamVjdH0gY29tcG9uZW50cyAtIGVudGl0eSdzIGN1cnJlbnRseSBpbml0aWFsaXplZCBjb21wb25lbnRzLlxuICogQG1lbWJlciB7b2JqZWN0fSBvYmplY3QzRCAtIHRocmVlLmpzIG9iamVjdC5cbiAqIEBtZW1iZXIge2FycmF5fSBzdGF0ZXNcbiAqIEBtZW1iZXIge2Jvb2xlYW59IGlzUGxheWluZyAtIGZhbHNlIGlmIGR5bmFtaWMgYmVoYXZpb3Igb2YgdGhlIGVudGl0eSBpcyBwYXVzZWQuXG4gKi9cbnZhciBwcm90byA9IE9iamVjdC5jcmVhdGUoQU5vZGUucHJvdG90eXBlLCB7XG4gIGRlZmF1bHRDb21wb25lbnRzOiB7XG4gICAgdmFsdWU6IHtcbiAgICAgIHBvc2l0aW9uOiAnJyxcbiAgICAgIHJvdGF0aW9uOiAnJyxcbiAgICAgIHNjYWxlOiAnJyxcbiAgICAgIHZpc2libGU6ICcnXG4gICAgfVxuICB9LFxuXG4gIGNyZWF0ZWRDYWxsYmFjazoge1xuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmNvbXBvbmVudHMgPSB7fTtcbiAgICAgIHRoaXMuaXNFbnRpdHkgPSB0cnVlO1xuICAgICAgdGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMub2JqZWN0M0QgPSBuZXcgVEhSRUUuR3JvdXAoKTtcbiAgICAgIHRoaXMub2JqZWN0M0QuZWwgPSB0aGlzO1xuICAgICAgdGhpcy5vYmplY3QzRE1hcCA9IHt9O1xuICAgICAgdGhpcy5zdGF0ZXMgPSBbXTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEhhbmRsZSBjaGFuZ2VzIGNvbWluZyBmcm9tIHRoZSBicm93c2VyIERPTSBpbnNwZWN0b3IuXG4gICAqL1xuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2s6IHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKGF0dHIsIG9sZFZhbCwgbmV3VmFsKSB7XG4gICAgICB0aGlzLnNldEVudGl0eUF0dHJpYnV0ZShhdHRyLCBvbGRWYWwsIG5ld1ZhbCk7XG4gICAgfVxuICB9LFxuXG4gIGF0dGFjaGVkQ2FsbGJhY2s6IHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5hZGRUb1BhcmVudCgpO1xuICAgICAgaWYgKCF0aGlzLmlzU2NlbmUpIHtcbiAgICAgICAgdGhpcy5sb2FkKCk7XG4gICAgICAgIGlmICghdGhpcy5wYXJlbnROb2RlLnBhdXNlZCkgeyB0aGlzLnBsYXkoKTsgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogVGVsbCBwYXJlbnQgdG8gcmVtb3ZlIHRoaXMgZWxlbWVudCdzIG9iamVjdDNEIGZyb20gaXRzIG9iamVjdDNELlxuICAgKiBEbyBub3QgY2FsbCBvbiBzY2VuZSBlbGVtZW50IGJlY2F1c2UgdGhhdCB3aWxsIGNhdXNlIGEgY2FsbCB0byBkb2N1bWVudC5ib2R5LnJlbW92ZSgpLlxuICAgKi9cbiAgZGV0YWNoZWRDYWxsYmFjazoge1xuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXRoaXMucGFyZW50RWwgfHwgdGhpcy5pc1NjZW5lKSB7IHJldHVybjsgfVxuICAgICAgLy8gUmVtb3ZlIGNvbXBvbmVudHMuXG4gICAgICBPYmplY3Qua2V5cyh0aGlzLmNvbXBvbmVudHMpLmZvckVhY2godGhpcy5yZW1vdmVDb21wb25lbnQuYmluZCh0aGlzKSk7XG4gICAgICB0aGlzLnBhcmVudEVsLnJlbW92ZSh0aGlzKTtcbiAgICB9XG4gIH0sXG5cbiAgYXBwbHlNaXhpbjoge1xuICAgIHZhbHVlOiBmdW5jdGlvbiAoYXR0cikge1xuICAgICAgdmFyIGF0dHJWYWx1ZSA9IHRoaXMuZ2V0QXR0cmlidXRlKGF0dHIpO1xuICAgICAgaWYgKCFhdHRyKSB7XG4gICAgICAgIHRoaXMudXBkYXRlQ29tcG9uZW50cygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnVwZGF0ZUNvbXBvbmVudChhdHRyLCBhdHRyVmFsdWUpO1xuICAgIH1cbiAgfSxcblxuICBtYXBTdGF0ZU1peGluczoge1xuICAgIHZhbHVlOiBmdW5jdGlvbiAoc3RhdGUsIG9wKSB7XG4gICAgICB2YXIgbWl4aW5zID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ21peGluJyk7XG4gICAgICB2YXIgbWl4aW5JZHM7XG4gICAgICBpZiAoIW1peGlucykgeyByZXR1cm47IH1cbiAgICAgIG1peGluSWRzID0gbWl4aW5zLnNwbGl0KCcgJyk7XG4gICAgICBtaXhpbklkcy5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICB2YXIgbWl4aW5JZCA9IGlkICsgJy0nICsgc3RhdGU7XG4gICAgICAgIG9wKG1peGluSWQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnVwZGF0ZUNvbXBvbmVudHMoKTtcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlU3RhdGVNaXhpbnM6IHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKG5ld01peGlucywgb2xkTWl4aW5zKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICBvbGRNaXhpbnMgPSBvbGRNaXhpbnMgfHwgJyc7XG4gICAgICB2YXIgbmV3TWl4aW5zSWRzID0gbmV3TWl4aW5zLnNwbGl0KCcgJyk7XG4gICAgICB2YXIgb2xkTWl4aW5zSWRzID0gb2xkTWl4aW5zID8gb2xkTWl4aW5zLnNwbGl0KCcgJykgOiBbXTtcbiAgICAgIC8vIFRoZSBsaXN0IG9mIG1peGlucyB0aGF0IG1pZ2h0IGhhdmUgYmVlbiByZW1vdmVkIG9uIHVwZGF0ZVxuICAgICAgdmFyIGRpZmYgPSBvbGRNaXhpbnNJZHMuZmlsdGVyKGZ1bmN0aW9uIChpKSB7IHJldHVybiBuZXdNaXhpbnNJZHMuaW5kZXhPZihpKSA8IDA7IH0pO1xuICAgICAgLy8gUmVtb3ZlIHRoZSBtaXhpbnMgdGhhdCBhcmUgZ29uZSBvbiB1cGRhdGVcbiAgICAgIGRpZmYuZm9yRWFjaChmdW5jdGlvbiAobWl4aW5JZCkge1xuICAgICAgICB2YXIgZm9yRWFjaCA9IEFycmF5LnByb3RvdHlwZS5mb3JFYWNoO1xuICAgICAgICAvLyBTdGF0ZSBNaXhpbnNcbiAgICAgICAgdmFyIHN0YXRlTWl4aW5zRWxzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2lkXj0nICsgbWl4aW5JZCArICctXScpO1xuICAgICAgICB2YXIgc3RhdGVNaXhpbklkcyA9IFtdO1xuICAgICAgICBmb3JFYWNoLmNhbGwoc3RhdGVNaXhpbnNFbHMsIGZ1bmN0aW9uIChlbCkgeyBzdGF0ZU1peGluSWRzLnB1c2goZWwuaWQpOyB9KTtcbiAgICAgICAgc3RhdGVNaXhpbklkcy5mb3JFYWNoKHNlbGYudW5yZWdpc3Rlck1peGluLmJpbmQoc2VsZikpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnN0YXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICBuZXdNaXhpbnNJZHMuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICB2YXIgbWl4aW5JZCA9IGlkICsgJy0nICsgc3RhdGU7XG4gICAgICAgICAgc2VsZi5yZWdpc3Rlck1peGluKG1peGluSWQpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICBnZXRPYmplY3QzRDoge1xuICAgIHZhbHVlOiBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgcmV0dXJuIHRoaXMub2JqZWN0M0RNYXBbdHlwZV07XG4gICAgfVxuICB9LFxuXG4gIHNldE9iamVjdDNEOiB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uICh0eXBlLCBvYmopIHtcbiAgICAgIHZhciBvbGRPYmogPSB0aGlzLm9iamVjdDNETWFwW3R5cGVdO1xuICAgICAgaWYgKG9sZE9iaikgeyB0aGlzLm9iamVjdDNELnJlbW92ZShvbGRPYmopOyB9XG4gICAgICBpZiAob2JqIGluc3RhbmNlb2YgVEhSRUUuT2JqZWN0M0QpIHtcbiAgICAgICAgb2JqLmVsID0gdGhpcztcbiAgICAgICAgdGhpcy5vYmplY3QzRC5hZGQob2JqKTtcbiAgICAgIH1cbiAgICAgIHRoaXMub2JqZWN0M0RNYXBbdHlwZV0gPSBvYmo7XG4gICAgfVxuICB9LFxuXG4gIHJlbW92ZU9iamVjdDNEOiB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICB0aGlzLnNldE9iamVjdDNEKHR5cGUsIG51bGwpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogR2V0cyBvciBjcmVhdGVzIGFuIG9iamVjdDNEIG9mIGEgZ2l2ZW4gdHlwZS5cblxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIFR5cGUgb2YgdGhlIG9iamVjdDNELlxuICAgKiBAcGFyYW0ge3N0cmluZ30gQ29uc3RydWN0b3IgLSBDb25zdHJ1Y3RvciB0byB1c2UgaWYgbmVlZCB0byBjcmVhdGUgdGhlIG9iamVjdDNELlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0T3JDcmVhdGVPYmplY3QzRDoge1xuICAgIHZhbHVlOiBmdW5jdGlvbiAodHlwZSwgQ29uc3RydWN0b3IpIHtcbiAgICAgIHZhciBvYmplY3QzRCA9IHRoaXMuZ2V0T2JqZWN0M0QodHlwZSk7XG4gICAgICBpZiAoIW9iamVjdDNEICYmIENvbnN0cnVjdG9yKSB7XG4gICAgICAgIG9iamVjdDNEID0gbmV3IENvbnN0cnVjdG9yKCk7XG4gICAgICAgIHRoaXMuc2V0T2JqZWN0M0QodHlwZSwgb2JqZWN0M0QpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDNEO1xuICAgIH1cbiAgfSxcblxuICBhZGQ6IHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKGVsKSB7XG4gICAgICBpZiAoIWVsLm9iamVjdDNEKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyeWluZyB0byBhZGQgYW4gZWxlbWVudCB0aGF0IGRvZXNuJ3QgaGF2ZSBhbiBgb2JqZWN0M0RgXCIpO1xuICAgICAgfVxuICAgICAgdGhpcy5lbWl0KCdjaGlsZC1hdHRhY2hlZCcsIHsgZWw6IGVsIH0pO1xuICAgICAgdGhpcy5vYmplY3QzRC5hZGQoZWwub2JqZWN0M0QpO1xuICAgIH1cbiAgfSxcblxuICBhZGRUb1BhcmVudDoge1xuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnRFbCA9IHRoaXMucGFyZW50Tm9kZTtcbiAgICAgIHZhciBhdHRhY2hlZFRvUGFyZW50ID0gdGhpcy5hdHRhY2hlZFRvUGFyZW50O1xuICAgICAgaWYgKCFwYXJlbnQgfHwgYXR0YWNoZWRUb1BhcmVudCkgeyByZXR1cm47IH1cbiAgICAgIGlmIChpc05vZGUocGFyZW50KSkge1xuICAgICAgICBhdHRhY2goKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcGFyZW50LmFkZEV2ZW50TGlzdGVuZXIoJ25vZGVyZWFkeScsIGF0dGFjaCk7XG4gICAgICBmdW5jdGlvbiBhdHRhY2ggKCkge1xuICAgICAgICAvLyBUbyBwcmV2ZW50IGFuIG9iamVjdCB0byBhdHRhY2ggaXRzZWxmIG11bHRpcGxlIHRpbWVzIHRvIHRoZSBwYXJlbnQuXG4gICAgICAgIHNlbGYuYXR0YWNoZWRUb1BhcmVudCA9IHRydWU7XG4gICAgICAgIGlmIChwYXJlbnQuYWRkKSB7XG4gICAgICAgICAgcGFyZW50LmFkZChzZWxmKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBsb2FkOiB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLmhhc0xvYWRlZCkgeyByZXR1cm47IH1cblxuICAgICAgLy8gQXR0YWNoIHRvIHBhcmVudCBvYmplY3QzRC5cbiAgICAgIHRoaXMuYWRkVG9QYXJlbnQoKTtcblxuICAgICAgaWYgKHRoaXMuaXNTY2VuZSkge1xuICAgICAgICBBTm9kZS5wcm90b3R5cGUubG9hZC5jYWxsKHRoaXMsIHRoaXMudXBkYXRlQ29tcG9uZW50cy5iaW5kKHRoaXMpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIEFOb2RlLnByb3RvdHlwZS5sb2FkLmNhbGwodGhpcywgdGhpcy51cGRhdGVDb21wb25lbnRzLmJpbmQodGhpcyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGVsKSB7IHJldHVybiBlbC5pc0VudGl0eTsgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICB3cml0YWJsZTogd2luZG93LmRlYnVnXG4gIH0sXG5cbiAgcmVtb3ZlOiB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgdGhpcy5vYmplY3QzRC5yZW1vdmUoZWwub2JqZWN0M0QpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybnMge2FycmF5fSBEaXJlY3QgY2hpbGRyZW4gdGhhdCBhcmUgZW50aXRpZXMuXG4gICAqL1xuICBnZXRDaGlsZEVudGl0aWVzOiB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG4gICAgICB2YXIgY2hpbGRFbnRpdGllcyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBBRW50aXR5KSB7XG4gICAgICAgICAgY2hpbGRFbnRpdGllcy5wdXNoKGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2hpbGRFbnRpdGllcztcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgY29tcG9uZW50LlxuICAgKi9cbiAgaW5pdENvbXBvbmVudDoge1xuICAgIHZhbHVlOiBmdW5jdGlvbiAobmFtZSwgaXNEZXBlbmRlbmN5KSB7XG4gICAgICB2YXIgY29tcG9uZW50O1xuICAgICAgdmFyIGlzQ29tcG9uZW50RGVmaW5lZCA9IGNoZWNrQ29tcG9uZW50RGVmaW5lZCh0aGlzLCBuYW1lKTtcblxuICAgICAgLy8gQ2hlY2sgaWYgY29tcG9uZW50IGlzIHJlZ2lzdGVyZWQgYW5kIHdoZXRoZXIgY29tcG9uZW50IHNob3VsZCBiZSBpbmlpdGFsaXplZC5cbiAgICAgIGlmICghY29tcG9uZW50c1tuYW1lXSB8fCAoIWlzQ29tcG9uZW50RGVmaW5lZCAmJiAhaXNEZXBlbmRlbmN5KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIEluaXRpYWxpemUgZGVwZW5kZW5jaWVzLlxuICAgICAgdGhpcy5pbml0Q29tcG9uZW50RGVwZW5kZW5jaWVzKG5hbWUpO1xuXG4gICAgICBpZiAoaXNEZXBlbmRlbmN5ICYmICFpc0NvbXBvbmVudERlZmluZWQpIHtcbiAgICAgICAgLy8gQWRkIGNvbXBvbmVudCBpZiBpdCBpcyBhIGRlcGVuZGVuY3kgYW5kIG5vdCB5ZXQgZGVmaW5lZC5cbiAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUobmFtZSwgJycpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuaXNTY2VuZSAmJiAhdGhpcy5oYXNBdHRyaWJ1dGUobmFtZSkgJiYgbmFtZSBpbiB0aGlzLmRlZmF1bHRDb21wb25lbnRzKSB7XG4gICAgICAgICAgLy8gRm9yIHNjZW5lIGRlZmF1bHQgY29tcG9uZW50cywgZXhwb3NlIHRoZW0gaW4gdGhlIERPTS5cbiAgICAgICAgICBIVE1MRWxlbWVudC5wcm90b3R5cGUuc2V0QXR0cmlidXRlLmNhbGwodGhpcywgbmFtZSwgdGhpcy5kZWZhdWx0Q29tcG9uZW50c1tuYW1lXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBpZiBjb21wb25lbnQgYWxyZWFkeSBpbml0aWFsaXplZC5cbiAgICAgICAgaWYgKG5hbWUgaW4gdGhpcy5jb21wb25lbnRzKSB7IHJldHVybjsgfVxuXG4gICAgICAgIGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50c1tuYW1lXSA9IG5ldyBjb21wb25lbnRzW25hbWVdLkNvbXBvbmVudCh0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMuaXNQbGF5aW5nKSB7IHBsYXlDb21wb25lbnQoY29tcG9uZW50LCB0aGlzLnNjZW5lRWwpOyB9XG4gICAgICB9XG4gICAgICBkZWJ1ZygnQ29tcG9uZW50IGluaXRpYWxpemVkOiAlcycsIG5hbWUpO1xuICAgIH0sXG4gICAgd3JpdGFibGU6IHdpbmRvdy5kZWJ1Z1xuICB9LFxuXG4gIGluaXRDb21wb25lbnREZXBlbmRlbmNpZXM6IHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBjb21wb25lbnQgPSBjb21wb25lbnRzW25hbWVdO1xuICAgICAgdmFyIGRlcGVuZGVuY2llcztcbiAgICAgIGlmICghY29tcG9uZW50KSB7IHJldHVybjsgfVxuICAgICAgZGVwZW5kZW5jaWVzID0gY29tcG9uZW50c1tuYW1lXS5kZXBlbmRlbmNpZXM7XG4gICAgICBpZiAoIWRlcGVuZGVuY2llcykgeyByZXR1cm47IH1cbiAgICAgIGRlcGVuZGVuY2llcy5mb3JFYWNoKGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICAgICAgc2VsZi5pbml0Q29tcG9uZW50KGNvbXBvbmVudCwgdHJ1ZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgcmVtb3ZlQ29tcG9uZW50OiB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnRzW25hbWVdO1xuICAgICAgcGF1c2VDb21wb25lbnQoY29tcG9uZW50LCB0aGlzLnNjZW5lRWwpO1xuICAgICAgY29tcG9uZW50LnJlbW92ZSgpO1xuICAgICAgZGVsZXRlIHRoaXMuY29tcG9uZW50c1tuYW1lXTtcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlQ29tcG9uZW50czoge1xuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgYWxsQ29tcG9uZW50cyA9IE9iamVjdC5rZXlzKGNvbXBvbmVudHMpO1xuICAgICAgYWxsQ29tcG9uZW50cy5mb3JFYWNoKHVwZGF0ZUNvbXBvbmVudCk7XG4gICAgICBmdW5jdGlvbiB1cGRhdGVDb21wb25lbnQgKG5hbWUpIHtcbiAgICAgICAgdmFyIGVsVmFsdWUgPSBzZWxmLmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgc2VsZi51cGRhdGVDb21wb25lbnQobmFtZSwgZWxWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplLCB1cGRhdGUsIG9yIHJlbW92ZSBhIHNpbmdsZSBjb21wb25lbnQuXG4gICAqXG4gICAqIFdoZW4gaW5pdGlhbGl6aW5nLCB3ZSBzZXQgdGhlIGNvbXBvbmVudCBvbiBgdGhpcy5jb21wb25lbnRzYC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBDb21wb25lbnQgbmFtZS5cbiAgICogQHBhcmFtIHtvYmplY3R9IG5ld0RhdGEgLSBUaGUgbmV3IHByb3BlcnRpZXMgYXNzaWduZWQgdG8gdGhlIGNvbXBvbmVudFxuICAgKi9cbiAgdXBkYXRlQ29tcG9uZW50OiB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIChuYW1lLCBuZXdEYXRhKSB7XG4gICAgICB2YXIgY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnRzW25hbWVdO1xuICAgICAgdmFyIGlzRGVmYXVsdCA9IG5hbWUgaW4gdGhpcy5kZWZhdWx0Q29tcG9uZW50cztcbiAgICAgIHZhciBpc01peGVkSW4gPSBpc0NvbXBvbmVudE1peGVkSW4obmFtZSwgdGhpcy5taXhpbkVscyk7XG4gICAgICBpZiAoY29tcG9uZW50KSB7XG4gICAgICAgIC8vIEF0dHJpYnV0ZSB3YXMgcmVtb3ZlZCwgcmVtb3ZlIGNvbXBvbmVudCBpZjpcbiAgICAgICAgLy8gMS4gSWYgY29tcG9uZW50IG5vdCBkZWZpbmVkIGluIHRoZSBkZWZhdWx0cy9taXhpbnMvYXR0cmlidXRlLlxuICAgICAgICAvLyAyLiBJZiBuZXcgZGF0YSBpcyBudWxsLCB0aGVuIG5vdCBhIGRlZmF1bHQgY29tcG9uZW50IGFuZCBjb21wb25lbnQgaXMgbm90IGRlZmluZWRcbiAgICAgICAgLy8gICAgdmlhIG1peGluc1xuICAgICAgICBpZiAoIWNoZWNrQ29tcG9uZW50RGVmaW5lZCh0aGlzLCBuYW1lKSB8fFxuICAgICAgICAgICAgbmV3RGF0YSA9PT0gbnVsbCAmJiAhaXNEZWZhdWx0ICYmICFpc01peGVkSW4pIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUNvbXBvbmVudChuYW1lKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29tcG9uZW50IGFscmVhZHkgaW5pdGlhbGl6ZWQuIFVwZGF0ZSBjb21wb25lbnQuXG4gICAgICAgIGNvbXBvbmVudC51cGRhdGVQcm9wZXJ0aWVzKG5ld0RhdGEpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBDb21wb25lbnQgbm90IHlldCBpbml0aWFsaXplZC4gSW5pdGlhbGl6ZSBjb21wb25lbnQuXG4gICAgICB0aGlzLmluaXRDb21wb25lbnQobmFtZSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBJZiBgYXR0cmAgaXMgYSBjb21wb25lbnQgbmFtZSwgcmVtb3ZlQXR0cmlidXRlIGRldGFjaGVzIHRoZSBjb21wb25lbnQgZnJvbSB0aGVcbiAgICogZW50aXR5LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0ciAtIEF0dHJpYnV0ZSBuYW1lLCB3aGljaCBjb3VsZCBhbHNvIGJlIGEgY29tcG9uZW50IG5hbWUuXG4gICAqL1xuICByZW1vdmVBdHRyaWJ1dGU6IHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgIHZhciBjb21wb25lbnQgPSBjb21wb25lbnRzW2F0dHJdO1xuICAgICAgaWYgKGNvbXBvbmVudCkge1xuICAgICAgICB0aGlzLnNldEVudGl0eUF0dHJpYnV0ZShhdHRyLCB1bmRlZmluZWQsIG51bGwpO1xuICAgICAgfVxuICAgICAgSFRNTEVsZW1lbnQucHJvdG90eXBlLnJlbW92ZUF0dHJpYnV0ZS5jYWxsKHRoaXMsIGF0dHIpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogU3RhcnQgZHluYW1pYyBiZWhhdmlvciBhc3NvY2lhdGVkIHdpdGggZW50aXR5IHN1Y2ggYXMgZHluYW1pYyBjb21wb25lbnRzIGFuZCBhbmltYXRpb25zLlxuICAgKiBUZWxsIGFsbCBjaGlsZHJlbiBlbnRpdGllcyB0byBhbHNvIHBsYXkuXG4gICAqL1xuICBwbGF5OiB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjb21wb25lbnRzID0gdGhpcy5jb21wb25lbnRzO1xuICAgICAgdmFyIGNvbXBvbmVudEtleXMgPSBPYmplY3Qua2V5cyhjb21wb25lbnRzKTtcbiAgICAgIHZhciBzY2VuZUVsID0gdGhpcy5zY2VuZUVsO1xuXG4gICAgICAvLyBBbHJlYWR5IHBsYXlpbmcuXG4gICAgICBpZiAodGhpcy5pc1BsYXlpbmcpIHsgcmV0dXJuOyB9XG4gICAgICB0aGlzLmlzUGxheWluZyA9IHRydWU7XG5cbiAgICAgIC8vIFdha2UgdXAgYWxsIGNvbXBvbmVudHMuXG4gICAgICBjb21wb25lbnRLZXlzLmZvckVhY2goZnVuY3Rpb24gX3BsYXlDb21wb25lbnQgKGtleSkge1xuICAgICAgICBwbGF5Q29tcG9uZW50KGNvbXBvbmVudHNba2V5XSwgc2NlbmVFbCk7XG4gICAgICB9KTtcblxuICAgICAgLy8gVGVsbCBhbGwgY2hpbGQgZW50aXRpZXMgdG8gcGxheS5cbiAgICAgIHRoaXMuZ2V0Q2hpbGRFbnRpdGllcygpLmZvckVhY2goZnVuY3Rpb24gcGxheSAob2JqKSB7XG4gICAgICAgIG9iai5wbGF5KCk7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5lbWl0KCdwbGF5Jyk7XG4gICAgfSxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9LFxuXG4gIC8qKlxuICAgKiBQYXVzZSBkeW5hbWljIGJlaGF2aW9yIGFzc29jaWF0ZWQgd2l0aCBlbnRpdHkgc3VjaCBhcyBkeW5hbWljIGNvbXBvbmVudHMgYW5kIGFuaW1hdGlvbnMuXG4gICAqIFRlbGwgYWxsIGNoaWxkcmVuIGVudGl0aWVzIHRvIGFsc28gcGF1c2UuXG4gICAqL1xuICBwYXVzZToge1xuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY29tcG9uZW50cyA9IHRoaXMuY29tcG9uZW50cztcbiAgICAgIHZhciBjb21wb25lbnRLZXlzID0gT2JqZWN0LmtleXMoY29tcG9uZW50cyk7XG4gICAgICB2YXIgc2NlbmVFbCA9IHRoaXMuc2NlbmVFbDtcblxuICAgICAgaWYgKCF0aGlzLmlzUGxheWluZykgeyByZXR1cm47IH1cbiAgICAgIHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XG5cbiAgICAgIC8vIFNsZWVwIGFsbCBjb21wb25lbnRzLlxuICAgICAgY29tcG9uZW50S2V5cy5mb3JFYWNoKGZ1bmN0aW9uIF9wYXVzZUNvbXBvbmVudCAoa2V5KSB7XG4gICAgICAgIHBhdXNlQ29tcG9uZW50KGNvbXBvbmVudHNba2V5XSwgc2NlbmVFbCk7XG4gICAgICB9KTtcblxuICAgICAgLy8gVGVsbCBhbGwgY2hpbGQgZW50aXRpZXMgdG8gcGF1c2UuXG4gICAgICB0aGlzLmdldENoaWxkRW50aXRpZXMoKS5mb3JFYWNoKGZ1bmN0aW9uIHBhdXNlIChvYmopIHtcbiAgICAgICAgb2JqLnBhdXNlKCk7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5lbWl0KCdwYXVzZScpO1xuICAgIH0sXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSxcblxuICAvKipcbiAgICogRGVhbHMgd2l0aCB1cGRhdGVzIG9uIGVudGl0eS1zcGVjaWZpYyBhdHRyaWJ1dGVzIChpLmUuLCBjb21wb25lbnRzIGFuZCBtaXhpbnMpLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0clxuICAgKiBAcGFyYW0ge3N0cmluZ30gb2xkVmFsXG4gICAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gbmV3VmFsXG4gICAqL1xuICBzZXRFbnRpdHlBdHRyaWJ1dGU6IHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKGF0dHIsIG9sZFZhbCwgbmV3VmFsKSB7XG4gICAgICB2YXIgY29tcG9uZW50ID0gY29tcG9uZW50c1thdHRyXTtcbiAgICAgIG9sZFZhbCA9IG9sZFZhbCB8fCB0aGlzLmdldEF0dHJpYnV0ZShhdHRyKTtcbiAgICAgIC8vIFdoZW4gY3JlYXRpbmcgZW50aXRpZXMgcHJvZ3JhbWF0aWNhbGx5IGFuZCBzZXR0aW5nIGF0dHJpYnV0ZXMsIGl0IGlzIG5vdCBwYXJ0XG4gICAgICAvLyBvZiB0aGUgc2NlbmUgdW50aWwgaXQgaXMgaW5zZXJ0ZWQgaW50byB0aGUgRE9NLiBUaGlzIGRvZXMgbm90IGFwcGx5IHRvIHNjZW5lcyBhc1xuICAgICAgLy8gc2NlbmVzIGRlcGVuZCBvbiBpdHMgY2hpbGQgZW50aXRpZXMgdG8gbG9hZC5cbiAgICAgIGlmICghdGhpcy5oYXNMb2FkZWQgJiYgIXRoaXMuaXNTY2VuZSkgeyByZXR1cm47IH1cbiAgICAgIGlmIChhdHRyID09PSAnbWl4aW4nKSB7XG4gICAgICAgIHRoaXMudXBkYXRlU3RhdGVNaXhpbnMobmV3VmFsLCBvbGRWYWwpO1xuICAgICAgICB0aGlzLnVwZGF0ZUNvbXBvbmVudHMoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGNvbXBvbmVudCkgeyB0aGlzLnVwZGF0ZUNvbXBvbmVudChhdHRyLCBuZXdWYWwpOyB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBJZiBhdHRyaWJ1dGUgaXMgYSBjb21wb25lbnQsIHNldEF0dHJpYnV0ZSB3aWxsIGFwcGx5IHRoZSB2YWx1ZSB0byB0aGVcbiAgICogZXhpc3RpbmcgY29tcG9uZW50IGRhdGEsIG5vdCByZXBsYWNlIGl0LiBFeGFtcGxlczpcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqIHNldEF0dHJpYnV0ZSgnaWQnLCAnbXktZWxlbWVudCcpO1xuICAgKiBzZXRBdHRyaWJ1dGUoJ21hdGVyaWFsJywgeyBjb2xvcjogJ2NyaW1zb24nIH0pO1xuICAgKiBzZXRBdHRyaWJ1dGUoJ21hdGVyaWFsJywgJ2NvbG9yJywgJ2NyaW1zb24nKTtcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHIgLSBBdHRyaWJ1dGUgbmFtZS4gc2V0QXR0cmlidXRlIHdpbGwgaW5pdGlhbGl6ZSBvciB1cGRhdGVcbiAgICogICAgICAgIGEgY29tcG9uZW50IGlmIHRoZSBuYW1lIGNvcnJlc3BvbmRzIHRvIGEgcmVnaXN0ZXJlZCBjb21wb25lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gdmFsdWUgLSBJZiBhIHN0cmluZywgc2V0QXR0cmlidXRlIHdpbGwgdXBkYXRlIHRoZSBhdHRyaWJ1dGUgb3IuXG4gICAqICAgICAgICBjb21wb25lbnQuIElmIGFuIG9iamVjdCwgdGhlIHZhbHVlIHdpbGwgYmUgbWl4ZWQgaW50byB0aGUgY29tcG9uZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY29tcG9uZW50UHJvcFZhbHVlIC0gSWYgZGVmaW5lZCwgYHZhbHVlYCB3aWxsIGFjdCBhcyB0aGUgcHJvcGVydHlcbiAgICogICAgICAgIG5hbWUgYW5kIHNldEF0dHJpYnV0ZSB3aWxsIG9ubHkgc2V0IGEgc2luZ2xlIGNvbXBvbmVudCBwcm9wZXJ0eS5cbiAgICovXG4gIHNldEF0dHJpYnV0ZToge1xuICAgIHZhbHVlOiBmdW5jdGlvbiAoYXR0ciwgdmFsdWUsIGNvbXBvbmVudFByb3BWYWx1ZSkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50c1thdHRyXSB8fCBjb21wb25lbnRzW2F0dHJdO1xuICAgICAgdmFyIHBhcnRpYWxDb21wb25lbnREYXRhO1xuICAgICAgdmFsdWUgPSB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gJycgOiB2YWx1ZTtcbiAgICAgIHZhciBjb21wb25lbnRPYmogPSB2YWx1ZTsgIC8vIERlc2VyaWFsaXplZCB2YWx1ZSB0byBzZW5kIHRvIHRoZSBjb21wb25lbnQuXG4gICAgICB2YXIgY29tcG9uZW50U3RyID0gdmFsdWU7ICAvLyBTZXJpYWxpemVkIHZhbHVlIHRvIHNlbmQgdG8gdGhlIERPTS5cbiAgICAgIHZhciBvbGRWYWx1ZTtcblxuICAgICAgaWYgKGNvbXBvbmVudCkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiBjb21wb25lbnRQcm9wVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIFVwZGF0ZSBjdXJyZW50bHktZGVmaW5lZCBjb21wb25lbnQgZGF0YSB3aXRoIHRoZSBuZXcgcHJvcGVydHkgdmFsdWUuXG4gICAgICAgICAgLy8gVXNlIG5hdGl2ZSBzZXRBdHRyaWJ1dGUgaW4gb3JkZXIgbm90IHRvIGRvdWJsZS1wYXJzZSBwcm9wZXJ0aWVzLlxuICAgICAgICAgIHBhcnRpYWxDb21wb25lbnREYXRhID0gc3R5bGVQYXJzZXIucGFyc2UoXG4gICAgICAgICAgICBIVE1MRWxlbWVudC5wcm90b3R5cGUuZ2V0QXR0cmlidXRlLmNhbGwodGhpcywgYXR0cikpIHx8IHt9O1xuICAgICAgICAgIHBhcnRpYWxDb21wb25lbnREYXRhW3ZhbHVlXSA9IGNvbXBvbmVudFByb3BWYWx1ZTtcbiAgICAgICAgICBjb21wb25lbnRPYmogPSBwYXJ0aWFsQ29tcG9uZW50RGF0YTtcbiAgICAgICAgfVxuICAgICAgICBjb21wb25lbnRTdHIgPSBjb21wb25lbnQuc3RyaW5naWZ5KGNvbXBvbmVudE9iaik7XG4gICAgICB9XG4gICAgICBvbGRWYWx1ZSA9IHRoaXMuZ2V0QXR0cmlidXRlKGF0dHIpO1xuICAgICAgQU5vZGUucHJvdG90eXBlLnNldEF0dHJpYnV0ZS5jYWxsKHNlbGYsIGF0dHIsIGNvbXBvbmVudFN0cik7XG4gICAgICBzZWxmLnNldEVudGl0eUF0dHJpYnV0ZShhdHRyLCBvbGRWYWx1ZSwgY29tcG9uZW50T2JqKTtcbiAgICB9LFxuICAgIHdyaXRhYmxlOiB3aW5kb3cuZGVidWdcbiAgfSxcblxuICAvKipcbiAgICogSWYgYGF0dHJgIGlzIGEgY29tcG9uZW50LCByZXR1cm5zIEpVU1QgdGhlIGNvbXBvbmVudCBkYXRhIHNwZWNpZmllZCBpbiB0aGUgSFRNTFxuICAgKiBieSBwYXJzaW5nIHRoZSBzdHlsZS1saWtlIHN0cmluZyBpbnRvIGFuIG9iamVjdC4gTGlrZSBhIHBhcnRpYWwgdmVyc2lvbiBvZlxuICAgKiBgZ2V0Q29tcHV0ZWRBdHRyaWJ1dGVgIGFzIHJldHVybmVkIGNvbXBvbmVudCBkYXRhIGRvZXMgbm90IGluY2x1ZGUgYXBwbGllZCBtaXhpbnMgb3JcbiAgICogZGVmYXVsdHMuXG4gICAqXG4gICAqIElmIGBhdHRyYCBpcyBub3QgYSBjb21wb25lbnQsIGZhbGwgYmFjayB0byBIVE1MIGdldEF0dHJpYnV0ZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJcbiAgICogQHJldHVybnMge29iamVjdHxzdHJpbmd9IE9iamVjdCBpZiBjb21wb25lbnQsIGVsc2Ugc3RyaW5nLlxuICAgKi9cbiAgZ2V0QXR0cmlidXRlOiB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICB2YXIgY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnRzW2F0dHJdIHx8IGNvbXBvbmVudHNbYXR0cl07XG4gICAgICB2YXIgdmFsdWUgPSBIVE1MRWxlbWVudC5wcm90b3R5cGUuZ2V0QXR0cmlidXRlLmNhbGwodGhpcywgYXR0cik7XG4gICAgICBpZiAoIWNvbXBvbmVudCB8fCB0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7IHJldHVybiB2YWx1ZTsgfVxuICAgICAgcmV0dXJuIGNvbXBvbmVudC5wYXJzZSh2YWx1ZSwgdHJ1ZSk7XG4gICAgfSxcbiAgICB3cml0YWJsZTogd2luZG93LmRlYnVnXG4gIH0sXG5cbiAgLyoqXG4gICAqIElmIGBhdHRyYCBpcyBhIGNvbXBvbmVudCwgcmV0dXJucyBBTEwgY29tcG9uZW50IGRhdGEgaW5jbHVkaW5nIGFwcGxpZWQgbWl4aW5zIGFuZFxuICAgKiBkZWZhdWx0cy5cbiAgICpcbiAgICogSWYgYGF0dHJgIGlzIG5vdCBhIGNvbXBvbmVudCwgZmFsbCBiYWNrIHRvIEhUTUwgZ2V0QXR0cmlidXRlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0clxuICAgKiBAcmV0dXJucyB7b2JqZWN0fHN0cmluZ30gT2JqZWN0IGlmIGNvbXBvbmVudCwgZWxzZSBzdHJpbmcuXG4gICAqL1xuICBnZXRDb21wdXRlZEF0dHJpYnV0ZToge1xuICAgIHZhbHVlOiBmdW5jdGlvbiAoYXR0cikge1xuICAgICAgdmFyIGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50c1thdHRyXTtcbiAgICAgIGlmIChjb21wb25lbnQpIHsgcmV0dXJuIGNvbXBvbmVudC5nZXREYXRhKCk7IH1cbiAgICAgIHJldHVybiBIVE1MRWxlbWVudC5wcm90b3R5cGUuZ2V0QXR0cmlidXRlLmNhbGwodGhpcywgYXR0cik7XG4gICAgfVxuICB9LFxuXG4gIGFkZFN0YXRlOiB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgaWYgKHRoaXMuaXMoc3RhdGUpKSB7IHJldHVybjsgfVxuICAgICAgdGhpcy5zdGF0ZXMucHVzaChzdGF0ZSk7XG4gICAgICB0aGlzLm1hcFN0YXRlTWl4aW5zKHN0YXRlLCB0aGlzLnJlZ2lzdGVyTWl4aW4uYmluZCh0aGlzKSk7XG4gICAgICB0aGlzLmVtaXQoJ3N0YXRlYWRkZWQnLCB7c3RhdGU6IHN0YXRlfSk7XG4gICAgfVxuICB9LFxuXG4gIHJlbW92ZVN0YXRlOiB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgdmFyIHN0YXRlSW5kZXggPSB0aGlzLnN0YXRlcy5pbmRleE9mKHN0YXRlKTtcbiAgICAgIGlmIChzdGF0ZUluZGV4ID09PSAtMSkgeyByZXR1cm47IH1cbiAgICAgIHRoaXMuc3RhdGVzLnNwbGljZShzdGF0ZUluZGV4LCAxKTtcbiAgICAgIHRoaXMubWFwU3RhdGVNaXhpbnMoc3RhdGUsIHRoaXMudW5yZWdpc3Rlck1peGluLmJpbmQodGhpcykpO1xuICAgICAgdGhpcy5lbWl0KCdzdGF0ZXJlbW92ZWQnLCB7c3RhdGU6IHN0YXRlfSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGVsZW1lbnQgaXMgaW4gYSBnaXZlbiBzdGF0ZS4gZS5nLiBlbC5pcygnYWxpdmUnKTtcbiAgICogQHR5cGUge3N0cmluZ30gc3RhdGUgLSBOYW1lIG9mIHRoZSBzdGF0ZSB3ZSB3YW50IHRvIGNoZWNrXG4gICAqL1xuICBpczoge1xuICAgIHZhbHVlOiBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0YXRlcy5pbmRleE9mKHN0YXRlKSAhPT0gLTE7XG4gICAgfVxuICB9XG59KTtcblxuLyoqXG4gKiBDaGVjayBpZiBhIGNvbXBvbmVudCBpcyAqZGVmaW5lZCogZm9yIGFuIGVudGl0eSwgaW5jbHVkaW5nIGRlZmF1bHRzIGFuZCBtaXhpbnMuXG4gKiBEb2VzIG5vdCBjaGVjayB3aGV0aGVyIHRoZSBjb21wb25lbnQgaGFzIGJlZW4gKmluaXRpYWxpemVkKiBmb3IgYW4gZW50aXR5LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbCAtIEVudGl0eS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gQ29tcG9uZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gY2hlY2tDb21wb25lbnREZWZpbmVkIChlbCwgbmFtZSkge1xuICAvLyBDaGVjayBpZiBkZWZhdWx0IGNvbXBvbmVudHMgY29udGFpbiB0aGUgY29tcG9uZW50LlxuICBpZiAoZWwuZGVmYXVsdENvbXBvbmVudHNbbmFtZV0gIT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdHJ1ZTsgfVxuXG4gIC8vIENoZWNrIGlmIGVsZW1lbnQgY29udGFpbnMgdGhlIGNvbXBvbmVudC5cbiAgaWYgKGVsLmhhc0F0dHJpYnV0ZShuYW1lKSkgeyByZXR1cm4gdHJ1ZTsgfVxuXG4gIHJldHVybiBpc0NvbXBvbmVudE1peGVkSW4obmFtZSwgZWwubWl4aW5FbHMpO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGFueSBtaXhpbnMgY29udGFpbnMgYSBjb21wb25lbnQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBDb21wb25lbnQgbmFtZS5cbiAqIEBwYXJhbSB7YXJyYXl9IG1peGluRWxzIC0gQXJyYXkgb2YgPGEtbWl4aW4+cy5cbiAqL1xuZnVuY3Rpb24gaXNDb21wb25lbnRNaXhlZEluIChuYW1lLCBtaXhpbkVscykge1xuICB2YXIgaTtcbiAgdmFyIGluTWl4aW4gPSBmYWxzZTtcblxuICBmb3IgKGkgPSAwOyBpIDwgbWl4aW5FbHMubGVuZ3RoOyArK2kpIHtcbiAgICBpbk1peGluID0gbWl4aW5FbHNbaV0uaGFzQXR0cmlidXRlKG5hbWUpO1xuICAgIGlmIChpbk1peGluKSB7IGJyZWFrOyB9XG4gIH1cbiAgcmV0dXJuIGluTWl4aW47XG59XG5cbi8qKlxuICogUGF1c2UgY29tcG9uZW50IGJ5IHJlbW92aW5nIHRpY2sgYmVoYXZpb3IgYW5kIGNhbGxpbmcgcGF1c2UgaGFuZGxlci5cbiAqXG4gKiBAcGFyYW0gY29tcG9uZW50IHtvYmplY3R9IC0gQ29tcG9uZW50IHRvIHBhdXNlLlxuICogQHBhcmFtIHNjZW5lRWwge0VsZW1lbnR9IC0gU2NlbmUsIG5lZWRlZCB0byByZW1vdmUgdGhlIHRpY2sgYmVoYXZpb3IuXG4gKi9cbmZ1bmN0aW9uIHBhdXNlQ29tcG9uZW50IChjb21wb25lbnQsIHNjZW5lRWwpIHtcbiAgY29tcG9uZW50LnBhdXNlKCk7XG4gIC8vIFJlbW92ZSB0aWNrIGJlaGF2aW9yLlxuICBpZiAoIWNvbXBvbmVudC50aWNrKSB7IHJldHVybjsgfVxuICBzY2VuZUVsLnJlbW92ZUJlaGF2aW9yKGNvbXBvbmVudCk7XG59XG5cbi8qKlxuICogUGxheSBjb21wb25lbnQgYnkgYWRkaW5nIHRpY2sgYmVoYXZpb3IgYW5kIGNhbGxpbmcgcGxheSBoYW5kbGVyLlxuICpcbiAqIEBwYXJhbSBjb21wb25lbnQge29iamVjdH0gLSBDb21wb25lbnQgdG8gcGxheS5cbiAqIEBwYXJhbSBzY2VuZUVsIHtFbGVtZW50fSAtIFNjZW5lLCBuZWVkZWQgdG8gYWRkIHRoZSB0aWNrIGJlaGF2aW9yLlxuICovXG5mdW5jdGlvbiBwbGF5Q29tcG9uZW50IChjb21wb25lbnQsIHNjZW5lRWwpIHtcbiAgY29tcG9uZW50LnBsYXkoKTtcbiAgLy8gQWRkIHRpY2sgYmVoYXZpb3IuXG4gIGlmICghY29tcG9uZW50LnRpY2spIHsgcmV0dXJuOyB9XG4gIHNjZW5lRWwuYWRkQmVoYXZpb3IoY29tcG9uZW50KTtcbn1cblxuQUVudGl0eSA9IHJlZ2lzdGVyRWxlbWVudCgnYS1lbnRpdHknLCB7XG4gIHByb3RvdHlwZTogcHJvdG9cbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBBRW50aXR5O1xuXG59LHtcIi4uL2xpYi90aHJlZVwiOjkwLFwiLi4vdXRpbHMvXCI6MTAyLFwiLi9hLW5vZGVcIjo1NCxcIi4vYS1yZWdpc3Rlci1lbGVtZW50XCI6NTUsXCIuL2NvbXBvbmVudFwiOjU2fV0sNTM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLyogZ2xvYmFsIEhUTUxFbGVtZW50ICovXG52YXIgQUNvbXBvbmVudHMgPSBfZGVyZXFfKCcuL2NvbXBvbmVudCcpLmNvbXBvbmVudHM7XG52YXIgQU5vZGUgPSBfZGVyZXFfKCcuL2Etbm9kZScpO1xudmFyIHJlZ2lzdGVyRWxlbWVudCA9IF9kZXJlcV8oJy4vYS1yZWdpc3Rlci1lbGVtZW50JykucmVnaXN0ZXJFbGVtZW50O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlZ2lzdGVyRWxlbWVudCgnYS1taXhpbicsIHtcbiAgcHJvdG90eXBlOiBPYmplY3QuY3JlYXRlKFxuICAgIEFOb2RlLnByb3RvdHlwZSxcbiAgICB7XG4gICAgICBhdHRhY2hlZENhbGxiYWNrOiB7XG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy5sb2FkKCk7XG4gICAgICAgIH0sXG4gICAgICAgIHdyaXRhYmxlOiB3aW5kb3cuZGVidWdcbiAgICAgIH0sXG5cbiAgICAgIHNldEF0dHJpYnV0ZToge1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKGF0dHIsIHZhbHVlKSB7XG4gICAgICAgICAgdmFyIGNvbXBvbmVudCA9IEFDb21wb25lbnRzW2F0dHJdO1xuICAgICAgICAgIGlmIChjb21wb25lbnQgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdmFsdWUgPSBjb21wb25lbnQuc3RyaW5naWZ5KHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgSFRNTEVsZW1lbnQucHJvdG90eXBlLnNldEF0dHJpYnV0ZS5jYWxsKHRoaXMsIGF0dHIsIHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgd3JpdGFibGU6IHdpbmRvdy5kZWJ1Z1xuICAgICAgfSxcblxuICAgICAgZ2V0QXR0cmlidXRlOiB7XG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgIHZhciBjb21wb25lbnQgPSBBQ29tcG9uZW50c1thdHRyXTtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBIVE1MRWxlbWVudC5wcm90b3R5cGUuZ2V0QXR0cmlidXRlLmNhbGwodGhpcywgYXR0cik7XG4gICAgICAgICAgaWYgKCFjb21wb25lbnQgfHwgdHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykgeyByZXR1cm4gdmFsdWU7IH1cbiAgICAgICAgICByZXR1cm4gY29tcG9uZW50LnBhcnNlKHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgd3JpdGFibGU6IHdpbmRvdy5kZWJ1Z1xuICAgICAgfVxuICAgIH1cbiAgKVxufSk7XG5cbn0se1wiLi9hLW5vZGVcIjo1NCxcIi4vYS1yZWdpc3Rlci1lbGVtZW50XCI6NTUsXCIuL2NvbXBvbmVudFwiOjU2fV0sNTQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLyogZ2xvYmFsIEhUTUxFbGVtZW50LCBNdXRhdGlvbk9ic2VydmVyICovXG52YXIgcmVnaXN0ZXJFbGVtZW50ID0gX2RlcmVxXygnLi9hLXJlZ2lzdGVyLWVsZW1lbnQnKS5yZWdpc3RlckVsZW1lbnQ7XG52YXIgdXRpbHMgPSBfZGVyZXFfKCcuLi91dGlscy8nKTtcblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBBLUZyYW1lIHRoYXQgbWFuYWdlcyBsb2FkaW5nIG9mIG9iamVjdHMuXG4gKlxuICogTm9kZXMgY2FuIGJlIG1vZGlmaWVkIHVzaW5nIG1peGlucy5cbiAqIE5vZGVzIGVtaXQgYSBgbG9hZGVkYCBldmVudCB3aGVuIHRoZXkgYW5kIHRoZWlyIGNoaWxkcmVuIGhhdmUgaW5pdGlhbGl6ZWQuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gcmVnaXN0ZXJFbGVtZW50KCdhLW5vZGUnLCB7XG4gIHByb3RvdHlwZTogT2JqZWN0LmNyZWF0ZShIVE1MRWxlbWVudC5wcm90b3R5cGUsIHtcbiAgICBjcmVhdGVkQ2FsbGJhY2s6IHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaGFzTG9hZGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNOb2RlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5taXhpbkVscyA9IFtdO1xuICAgICAgICB0aGlzLm1peGluT2JzZXJ2ZXJzID0ge307XG4gICAgICB9XG4gICAgfSxcblxuICAgIGF0dGFjaGVkQ2FsbGJhY2s6IHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtaXhpbnMgPSB0aGlzLmdldEF0dHJpYnV0ZSgnbWl4aW4nKTtcbiAgICAgICAgdGhpcy5zY2VuZUVsID0gdGhpcy50YWdOYW1lID09PSAnQS1TQ0VORScgPyB0aGlzIDogdGhpcy5jbG9zZXN0KCdhLXNjZW5lJyk7XG4gICAgICAgIHRoaXMuZW1pdCgnbm9kZXJlYWR5Jywge30sIGZhbHNlKTtcbiAgICAgICAgaWYgKG1peGlucykgeyB0aGlzLnVwZGF0ZU1peGlucyhtaXhpbnMpOyB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjazoge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIChhdHRyLCBvbGRWYWwsIG5ld1ZhbCkge1xuICAgICAgICBpZiAoYXR0ciA9PT0gJ21peGluJykgeyB0aGlzLnVwZGF0ZU1peGlucyhuZXdWYWwsIG9sZFZhbCk7IH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBmaXJzdCBlbGVtZW50IG1hdGNoaW5nIGEgc2VsZWN0b3IgYnkgdHJhdmVyc2luZyB1cCB0aGUgdHJlZSBzdGFydGluZ1xuICAgICAqIGZyb20gYW5kIGluY2x1ZGluZyByZWNlaXZlciBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yIC0gU2VsZWN0b3Igb2YgZWxlbWVudCB0byBmaW5kLlxuICAgICAqL1xuICAgIGNsb3Nlc3Q6IHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZXN0IChzZWxlY3Rvcikge1xuICAgICAgICB2YXIgbWF0Y2hlcyA9IHRoaXMubWF0Y2hlcyB8fCB0aGlzLm1vek1hdGNoZXNTZWxlY3RvciB8fFxuICAgICAgICAgIHRoaXMubXNNYXRjaGVzU2VsZWN0b3IgfHwgdGhpcy5vTWF0Y2hlc1NlbGVjdG9yIHx8IHRoaXMud2Via2l0TWF0Y2hlc1NlbGVjdG9yO1xuICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXM7XG4gICAgICAgIHdoaWxlIChlbGVtZW50KSB7XG4gICAgICAgICAgaWYgKG1hdGNoZXMuY2FsbChlbGVtZW50LCBzZWxlY3RvcikpIHsgYnJlYWs7IH1cbiAgICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBkZXRhY2hlZENhbGxiYWNrOiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKCkgeyAvKiBuby1vcCAqLyB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdhaXQgZm9yIGNoaWxkcmVuIHRvIGxvYWQsIGlmIGFueS5cbiAgICAgKiBUaGVuIGVtaXQgYGxvYWRlZGAgZXZlbnQgYW5kIHNldCBgaGFzTG9hZGVkYC5cbiAgICAgKi9cbiAgICBsb2FkOiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKGNiLCBjaGlsZEZpbHRlcikge1xuICAgICAgICB2YXIgY2hpbGRyZW47XG4gICAgICAgIHZhciBjaGlsZHJlbkxvYWRlZDtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIGlmICh0aGlzLmhhc0xvYWRlZCkgeyByZXR1cm47IH1cblxuICAgICAgICAvLyBEZWZhdWx0IHRvIHdhaXRpbmcgZm9yIGFsbCBub2Rlcy5cbiAgICAgICAgY2hpbGRGaWx0ZXIgPSBjaGlsZEZpbHRlciB8fCBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIGVsLmlzTm9kZTsgfTtcblxuICAgICAgICAvLyBXYWl0IGZvciBjaGlsZHJlbiB0byBsb2FkIChpZiBhbnkpLCB0aGVuIGxvYWQuXG4gICAgICAgIGNoaWxkcmVuID0gdGhpcy5nZXRDaGlsZHJlbigpO1xuICAgICAgICBjaGlsZHJlbkxvYWRlZCA9IGNoaWxkcmVuLmZpbHRlcihjaGlsZEZpbHRlcikubWFwKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiB3YWl0Rm9yTG9hZGVkIChyZXNvbHZlKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQuaGFzTG9hZGVkKSB7IHJldHVybiByZXNvbHZlKCk7IH1cbiAgICAgICAgICAgIGNoaWxkLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRlZCcsIHJlc29sdmUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBQcm9taXNlLmFsbChjaGlsZHJlbkxvYWRlZCkudGhlbihmdW5jdGlvbiBlbWl0TG9hZGVkICgpIHtcbiAgICAgICAgICBpZiAoY2IpIHsgY2IoKTsgfVxuICAgICAgICAgIHNlbGYuaGFzTG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICBzZWxmLmVtaXQoJ2xvYWRlZCcsIHt9LCBmYWxzZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSxcblxuICAgIGdldENoaWxkcmVuOiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY2hpbGRyZW4ucHVzaCh0aGlzLmNoaWxkcmVuW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hpbGRyZW47XG4gICAgICB9XG4gICAgfSxcblxuICAgIHVwZGF0ZU1peGluczoge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIChuZXdNaXhpbnMsIG9sZE1peGlucykge1xuICAgICAgICB2YXIgbmV3TWl4aW5zSWRzID0gbmV3TWl4aW5zLnNwbGl0KCcgJyk7XG4gICAgICAgIHZhciBvbGRNaXhpbnNJZHMgPSBvbGRNaXhpbnMgPyBvbGRNaXhpbnMuc3BsaXQoJyAnKSA6IFtdO1xuICAgICAgICAvLyBUbyBkZXRlcm1pbmUgd2hhdCBsaXN0ZW5lcnMgd2lsbCBiZSByZW1vdmVkXG4gICAgICAgIHZhciBkaWZmID0gb2xkTWl4aW5zSWRzLmZpbHRlcihmdW5jdGlvbiAoaSkgeyByZXR1cm4gbmV3TWl4aW5zSWRzLmluZGV4T2YoaSkgPCAwOyB9KTtcbiAgICAgICAgdGhpcy5taXhpbkVscyA9IFtdO1xuICAgICAgICBkaWZmLmZvckVhY2godGhpcy51bnJlZ2lzdGVyTWl4aW4uYmluZCh0aGlzKSk7XG4gICAgICAgIG5ld01peGluc0lkcy5mb3JFYWNoKHRoaXMucmVnaXN0ZXJNaXhpbi5iaW5kKHRoaXMpKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYWRkTWl4aW46IHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiAobWl4aW5JZCkge1xuICAgICAgICB2YXIgbWl4aW5zID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ21peGluJyk7XG4gICAgICAgIHZhciBtaXhpbklkcyA9IG1peGlucy5zcGxpdCgnICcpO1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG1peGluSWRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgaWYgKG1peGluSWRzW2ldID09PSBtaXhpbklkKSB7IHJldHVybjsgfVxuICAgICAgICB9XG4gICAgICAgIG1peGluSWRzLnB1c2gobWl4aW5JZCk7XG4gICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdtaXhpbicsIG1peGluSWRzLmpvaW4oJyAnKSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHJlbW92ZU1peGluOiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKG1peGluSWQpIHtcbiAgICAgICAgdmFyIG1peGlucyA9IHRoaXMuZ2V0QXR0cmlidXRlKCdtaXhpbicpO1xuICAgICAgICB2YXIgbWl4aW5JZHMgPSBtaXhpbnMuc3BsaXQoJyAnKTtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBtaXhpbklkcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGlmIChtaXhpbklkc1tpXSA9PT0gbWl4aW5JZCkge1xuICAgICAgICAgICAgbWl4aW5JZHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ21peGluJywgbWl4aW5JZHMuam9pbignICcpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVnaXN0ZXJNaXhpbjoge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIChtaXhpbklkKSB7XG4gICAgICAgIGlmICghdGhpcy5zY2VuZUVsKSB7IHJldHVybjsgfVxuICAgICAgICB2YXIgbWl4aW5FbCA9IHRoaXMuc2NlbmVFbC5xdWVyeVNlbGVjdG9yKCdhLW1peGluIycgKyBtaXhpbklkKTtcbiAgICAgICAgaWYgKCFtaXhpbkVsKSB7IHJldHVybjsgfVxuICAgICAgICB0aGlzLmF0dGFjaE1peGluTGlzdGVuZXIobWl4aW5FbCk7XG4gICAgICAgIHRoaXMubWl4aW5FbHMucHVzaChtaXhpbkVsKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc2V0QXR0cmlidXRlOiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKGF0dHIsIG5ld1ZhbHVlKSB7XG4gICAgICAgIGlmIChhdHRyID09PSAnbWl4aW4nKSB7IHRoaXMudXBkYXRlTWl4aW5zKG5ld1ZhbHVlKTsgfVxuICAgICAgICBIVE1MRWxlbWVudC5wcm90b3R5cGUuc2V0QXR0cmlidXRlLmNhbGwodGhpcywgYXR0ciwgbmV3VmFsdWUpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICB1bnJlZ2lzdGVyTWl4aW46IHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiAobWl4aW5JZCkge1xuICAgICAgICB2YXIgbWl4aW5FbHMgPSB0aGlzLm1peGluRWxzO1xuICAgICAgICB2YXIgbWl4aW5FbDtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBtaXhpbkVscy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIG1peGluRWwgPSBtaXhpbkVsc1tpXTtcbiAgICAgICAgICBpZiAobWl4aW5JZCA9PT0gbWl4aW5FbC5pZCkge1xuICAgICAgICAgICAgbWl4aW5FbHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVtb3ZlTWl4aW5MaXN0ZW5lcihtaXhpbklkKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVtb3ZlTWl4aW5MaXN0ZW5lcjoge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIChtaXhpbklkKSB7XG4gICAgICAgIHZhciBvYnNlcnZlciA9IHRoaXMubWl4aW5PYnNlcnZlcnNbbWl4aW5JZF07XG4gICAgICAgIGlmICghb2JzZXJ2ZXIpIHsgcmV0dXJuOyB9XG4gICAgICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgdGhpcy5taXhpbk9ic2VydmVyc1ttaXhpbklkXSA9IG51bGw7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGF0dGFjaE1peGluTGlzdGVuZXI6IHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiAobWl4aW5FbCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBtaXhpbklkID0gbWl4aW5FbC5pZDtcbiAgICAgICAgdmFyIGN1cnJlbnRPYnNlcnZlciA9IHRoaXMubWl4aW5PYnNlcnZlcnNbbWl4aW5JZF07XG4gICAgICAgIGlmICghbWl4aW5FbCkgeyByZXR1cm47IH1cbiAgICAgICAgaWYgKGN1cnJlbnRPYnNlcnZlcikgeyByZXR1cm47IH1cbiAgICAgICAgdmFyIG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZnVuY3Rpb24gKG11dGF0aW9ucykge1xuICAgICAgICAgIHZhciBhdHRyID0gbXV0YXRpb25zWzBdLmF0dHJpYnV0ZU5hbWU7XG4gICAgICAgICAgc2VsZi5hcHBseU1peGluKGF0dHIpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGNvbmZpZyA9IHsgYXR0cmlidXRlczogdHJ1ZSB9O1xuICAgICAgICBvYnNlcnZlci5vYnNlcnZlKG1peGluRWwsIGNvbmZpZyk7XG4gICAgICAgIHRoaXMubWl4aW5PYnNlcnZlcnNbbWl4aW5JZF0gPSBvYnNlcnZlcjtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYXBwbHlNaXhpbjoge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHsgLyogbm8tb3AgKi8gfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFbWl0cyBhIERPTSBldmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAgICogICBOYW1lIG9mIGV2ZW50ICh1c2UgYSBzcGFjZS1kZWxpbWl0ZWQgc3RyaW5nIGZvciBtdWx0aXBsZSBldmVudHMpLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gW2RldGFpbD17fV1cbiAgICAgKiAgIEN1c3RvbSBkYXRhIHRvIHBhc3MgYXMgYGRldGFpbGAgdG8gdGhlIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbj19IFtidWJibGVzPXRydWVdXG4gICAgICogICBXaGV0aGVyIHRoZSBldmVudCBzaG91bGQgYnViYmxlLlxuICAgICAqL1xuICAgIGVtaXQ6IHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiAobmFtZSwgZGV0YWlsLCBidWJibGVzKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgZGV0YWlsID0gZGV0YWlsIHx8IHt9O1xuICAgICAgICBpZiAoYnViYmxlcyA9PT0gdW5kZWZpbmVkKSB7IGJ1YmJsZXMgPSB0cnVlOyB9XG4gICAgICAgIHZhciBkYXRhID0geyBidWJibGVzOiAhIWJ1YmJsZXMsIGRldGFpbDogZGV0YWlsIH07XG4gICAgICAgIHJldHVybiBuYW1lLnNwbGl0KCcgJykubWFwKGZ1bmN0aW9uIChldmVudE5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gdXRpbHMuZmlyZUV2ZW50KHNlbGYsIGV2ZW50TmFtZSwgZGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY2xvc3VyZSB0aGF0IGVtaXRzIGEgRE9NIGV2ZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgKiAgIE5hbWUgb2YgZXZlbnQgKHVzZSBhIHNwYWNlLWRlbGltaXRlZCBzdHJpbmcgZm9yIG11bHRpcGxlIGV2ZW50cykuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRldGFpbFxuICAgICAqICAgQ3VzdG9tIGRhdGEgKG9wdGlvbmFsKSB0byBwYXNzIGFzIGBkZXRhaWxgIGlmIHRoZSBldmVudCBpcyB0b1xuICAgICAqICAgYmUgYSBgQ3VzdG9tRXZlbnRgLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gYnViYmxlc1xuICAgICAqICAgV2hldGhlciB0aGUgZXZlbnQgc2hvdWxkIGJlIGJ1YmJsZS5cbiAgICAgKi9cbiAgICBlbWl0dGVyOiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKG5hbWUsIGRldGFpbCwgYnViYmxlcykge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc2VsZi5lbWl0KG5hbWUsIGRldGFpbCwgYnViYmxlcyk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9KVxufSk7XG5cbn0se1wiLi4vdXRpbHMvXCI6MTAyLFwiLi9hLXJlZ2lzdGVyLWVsZW1lbnRcIjo1NX1dLDU1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8vIFBvbHlmaWxsIGBkb2N1bWVudC5yZWdpc3RlckVsZW1lbnRgLlxuX2RlcmVxXygnZG9jdW1lbnQtcmVnaXN0ZXItZWxlbWVudCcpO1xuXG4vKlxuIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuIC0tLS0tLS0tLS0tLS0gV0FSTklORyBXQVJOSU5HIFdBUk5JTkcgV0FSTklORyAtLS0tLS0tLS0tLS0tLVxuIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gVGhpcyBtb2R1bGUgd3JhcHMgcmVnaXN0ZXJFbGVtZW50IHRvIGRlYWwgd2l0aFxuIGNvbXBvbmVudHMgdGhhdCBpbmhlcml0IGZyb20gYEFOb2RlYCBhbmQgYEFFbnRpdHlgLlxuIEl0J3MgYSBwYXNzIHRocm91Z2ggaW4gYW55IG90aGVyIGNhc2UuXG5cbiBJdCB3cmFwcyBzb21lIG9mIHRoZSBwcm90b3R5cGUgbWV0aG9kc1xuIG9mIHRoZSBjcmVhdGVkIGVsZW1lbnQgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIGNvcnJlc3BvbmRpbmdcbiBmdW5jdGlvbnMgaW4gdGhlIGJhc2UgY2xhc3NlcyAoYEFFbnRpdHlgIGFuZCBgQU5vZGVgKSBhcmUgYWxzb1xuIGludm9rZWQuIFRoZSBtZXRob2QgaW4gdGhlIGJhc2UgY2xhc3MgaXMgYWx3YXlzIGNhbGxlZCBiZWZvcmUgdGhlXG4gb25lIGluIHRoZSBkZXJpdmVkIG9iamVjdC5cblxuKi9cbnZhciByZWdpc3RlckVsZW1lbnQgPSBkb2N1bWVudC5yZWdpc3RlckVsZW1lbnQ7XG5cbnZhciBrbm93blRhZ3MgPSBtb2R1bGUuZXhwb3J0cy5rbm93blRhZ3MgPSB7fTtcblxudmFyIGFkZFRhZ05hbWUgPSBmdW5jdGlvbiAodGFnTmFtZSkge1xuICBrbm93blRhZ3NbdGFnTmFtZS50b0xvd2VyQ2FzZSgpXSA9IHRydWU7XG59O1xuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCB0eXBlIGlzIG9uZSBvZiBvdXIga25vd24gcmVnaXN0ZXJlZCBvbmVzXG4gKlxuICogQHBhcmFtICAge3N0cmluZ30gbm9kZSBUaGUgbmFtZSBvZiB0aGUgdGFnIHRvIHJlZ2lzdGVyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciB0aGUgdGFnIG5hbWUgbWF0Y2hlcyB0aGF0IG9mIG91ciByZWdpc3RlcmVkXG4gKiAgICAgICAgICAgICAgICAgICAgY3VzdG9tIGVsZW1lbnRzXG4gKi9cbm1vZHVsZS5leHBvcnRzLmlzTm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHJldHVybiBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSBpbiBrbm93blRhZ3MgfHwgbm9kZS5pc05vZGU7XG59O1xuXG4vKipcbiAqIEBwYXJhbSAgIHtzdHJpbmd9IHRhZ05hbWUgVGhlIG5hbWUgb2YgdGhlIHRhZyB0byByZWdpc3RlclxuICogQHBhcmFtICAge29iamVjdH0gb2JqIFRoZSBwcm90b3R5cGUgb2YgdGhlIG5ldyBlbGVtZW50XG4gKiBAcmV0dXJucyB7b2JqZWN0fSBUaGUgcHJvdG90eXBlIG9mIHRoZSBuZXcgZWxlbWVudFxuICovXG5tb2R1bGUuZXhwb3J0cy5yZWdpc3RlckVsZW1lbnQgPSBkb2N1bWVudC5yZWdpc3RlckVsZW1lbnQgPSBmdW5jdGlvbiAodGFnTmFtZSwgb2JqKSB7XG4gIHZhciBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmoucHJvdG90eXBlKTtcbiAgdmFyIG5ld09iaiA9IG9iajtcbiAgdmFyIGlzQU5vZGUgPSBBTm9kZSAmJiBwcm90byA9PT0gQU5vZGUucHJvdG90eXBlO1xuICB2YXIgaXNBRW50aXR5ID0gQUVudGl0eSAmJiBwcm90byA9PT0gQUVudGl0eS5wcm90b3R5cGU7XG5cbiAgaWYgKGlzQU5vZGUgfHwgaXNBRW50aXR5KSB7IGFkZFRhZ05hbWUodGFnTmFtZSk7IH1cblxuICAvLyBEb2VzIHRoZSBlbGVtZW50IGluaGVyaXQgZnJvbSBgQU5vZGVgP1xuICBpZiAoaXNBTm9kZSkge1xuICAgIG5ld09iaiA9IHdyYXBBTm9kZU1ldGhvZHMob2JqLnByb3RvdHlwZSk7XG4gICAgbmV3T2JqID0ge3Byb3RvdHlwZTogT2JqZWN0LmNyZWF0ZShwcm90bywgbmV3T2JqKX07XG4gIH1cblxuICAvLyBEb2VzIHRoZSBlbGVtZW50IGluaGVyaXQgZnJvbSBgQUVudGl0eWA/XG4gIGlmIChpc0FFbnRpdHkpIHtcbiAgICBuZXdPYmogPSB3cmFwQUVudGl0eU1ldGhvZHMob2JqLnByb3RvdHlwZSk7XG4gICAgbmV3T2JqID0ge3Byb3RvdHlwZTogT2JqZWN0LmNyZWF0ZShwcm90bywgbmV3T2JqKX07XG4gIH1cblxuICByZXR1cm4gcmVnaXN0ZXJFbGVtZW50LmNhbGwoZG9jdW1lbnQsIHRhZ05hbWUsIG5ld09iaik7XG59O1xuXG4vKipcbiAqIFRoaXMgd3JhcHMgc29tZSBvZiB0aGUgb2JqIG1ldGhvZHMgdG8gY2FsbCB0aG9zZSBvbiBgQU5vZGVgIGJhc2UgY2xhc2UuXG4gKiBAcGFyYW0gIHtvYmplY3R9IG9iaiBUaGUgb2JqZWN0cyB0aGF0IGNvbnRhaW5zIHRoZSBtZXRob2RzIHRoYXQgd2lsbCBiZSB3cmFwcGVkLlxuICogQHJldHVybiB7b2JqZWN0fSBBbiBvYmplY3Qgd2l0aCB0aGUgc2FtZSBwcm9wZXJ0aWVzIGFzIHRoZSBpbnB1dCBwYXJhbWV0ZXIgYnV0XG4gKiB3aXRoIHNvbWUgb2YgbWV0aG9kcyB3cmFwcGVkLlxuICovXG5mdW5jdGlvbiB3cmFwQU5vZGVNZXRob2RzIChvYmopIHtcbiAgdmFyIG5ld09iaiA9IHt9O1xuICB2YXIgQU5vZGVNZXRob2RzID0gW1xuICAgICdhdHRhY2hlZENhbGxiYWNrJyxcbiAgICAnYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrJyxcbiAgICAnY3JlYXRlZENhbGxiYWNrJ1xuICBdO1xuICB3cmFwTWV0aG9kcyhuZXdPYmosIEFOb2RlTWV0aG9kcywgb2JqLCBBTm9kZS5wcm90b3R5cGUpO1xuICBjb3B5UHJvcGVydGllcyhvYmosIG5ld09iaik7XG4gIHJldHVybiBuZXdPYmo7XG59XG5cbi8qKlxuICogVGhpcyB3cmFwcyBzb21lIG9mIHRoZSBvYmogbWV0aG9kcyB0byBjYWxsIHRob3NlIG9uIGBBRW50aXR5YCBiYXNlIGNsYXNzLlxuICogQHBhcmFtICB7b2JqZWN0fSBvYmogVGhlIG9iamVjdHMgdGhhdCBjb250YWlucyB0aGUgbWV0aG9kcyB0aGF0IHdpbGwgYmUgd3JhcHBlZC5cbiAqIEByZXR1cm4ge29iamVjdH0gQW4gb2JqZWN0IHdpdGggdGhlIHNhbWUgcHJvcGVydGllcyBhcyB0aGUgaW5wdXQgcGFyYW1ldGVyIGJ1dFxuICogd2l0aCBzb21lIG9mIG1ldGhvZHMgd3JhcHBlZC5cbiAqL1xuZnVuY3Rpb24gd3JhcEFFbnRpdHlNZXRob2RzIChvYmopIHtcbiAgdmFyIG5ld09iaiA9IHt9O1xuICB2YXIgQU5vZGVNZXRob2RzID0gW1xuICAgICdhdHRhY2hlZENhbGxiYWNrJyxcbiAgICAnYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrJyxcbiAgICAnY3JlYXRlZENhbGxiYWNrJ1xuICBdO1xuICB2YXIgQUVudGl0eU1ldGhvZHMgPSBbXG4gICAgJ2F0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjaycsXG4gICAgJ2F0dGFjaGVkQ2FsbGJhY2snLFxuICAgICdjcmVhdGVkQ2FsbGJhY2snLFxuICAgICdkZXRhY2hlZENhbGxiYWNrJ1xuICBdO1xuICB3cmFwTWV0aG9kcyhuZXdPYmosIEFOb2RlTWV0aG9kcywgb2JqLCBBTm9kZS5wcm90b3R5cGUpO1xuICB3cmFwTWV0aG9kcyhuZXdPYmosIEFFbnRpdHlNZXRob2RzLCBvYmosIEFFbnRpdHkucHJvdG90eXBlKTtcbiAgLy8gQ29waWVzIHRoZSByZW1haW5pbmcgcHJvcGVydGllcyBpbnRvIHRoZSBuZXcgb2JqZWN0XG4gIGNvcHlQcm9wZXJ0aWVzKG9iaiwgbmV3T2JqKTtcbiAgcmV0dXJuIG5ld09iajtcbn1cblxuLyoqXG4gKiBXcmFwcyBhIGxpc3QgYSBtZXRob2RzIHRvIGVuc3VyZSB0aGF0IHRob3NlIGluIHRoZSBiYXNlIGNsYXNzIGFyZSBjYWxsZWQgdGhyb3VnaCB0aGUgZGVyaXZlZCBvbmUuXG4gKiBAcGFyYW0gIHtvYmplY3R9IHRhcmdldE9iaiBPYmplY3QgdGhhdCB3aWxsIGNvbnRhaW4gdGhlIHdyYXBwZWQgbWV0aG9kc1xuICogQHBhcmFtICB7YXJyYXl9IG1ldGhvZExpc3QgTGlzdCBvZiBtZXRob2RzIGZyb20gdGhlIGRlcml2ZWRPYmogdGhhdCB3aWxsIGJlIHdyYXBwZWRcbiAqIEBwYXJhbSAge29iamVjdH0gZGVyaXZlZE9iamVjdCBPYmplY3QgdGhhdCBpbmhlcml0cyBmcm9tIHRoZSBiYXNlT2JqXG4gKiBAcGFyYW0gIHtvYmplY3R9IGJhc2VPYmogT2JqZWN0IHRoYXQgZGVyaXZlZE9iaiBpbmhlcml0cyBmcm9tXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9XG4gKi9cbmZ1bmN0aW9uIHdyYXBNZXRob2RzICh0YXJnZXRPYmosIG1ldGhvZExpc3QsIGRlcml2ZWRPYmosIGJhc2VPYmopIHtcbiAgbWV0aG9kTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2ROYW1lKSB7XG4gICAgd3JhcE1ldGhvZCh0YXJnZXRPYmosIG1ldGhvZE5hbWUsIGRlcml2ZWRPYmosIGJhc2VPYmopO1xuICB9KTtcbn1cblxuLyoqXG4gKiBXcmFwcyBvbmUgbWV0aG9kIHRvIGVuc3VyZSB0aGF0IHRoZSBvbmUgaW4gdGhlIGJhc2UgY2xhc3MgaXMgY2FsbGVkIGJlZm9yZSB0aGUgb25lXG4gKiBpbiB0aGUgZGVyaXZlZCBvbmVcbiAqIEBwYXJhbSAge29iamVjdH0gb2JqIE9iamVjdCB0aGF0IHdpbGwgY29udGFpbiB0aGUgd3JhcHBlZCBtZXRob2RcbiAqIEBwYXJhbSAge3N0cmluZ30gbWV0aG9kTmFtZSBUaGUgbmFtZSBvZiB0aGUgbWV0aG9kIHRoYXQgd2lsbCBiZSB3cmFwcGVkXG4gKiBAcGFyYW0gIHtvYmplY3R9IGRlcml2ZWRPYmplY3QgT2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSB0aGUgYmFzZU9ialxuICogQHBhcmFtICB7b2JqZWN0fSBiYXNlT2JqIE9iamVjdCB0aGF0IGRlcml2ZWRPYmogaW5oZXJpdHMgZnJvbVxuICogQHJldHVybiB7dW5kZWZpbmVkfVxuICovXG5mdW5jdGlvbiB3cmFwTWV0aG9kIChvYmosIG1ldGhvZE5hbWUsIGRlcml2ZWRPYmosIGJhc2VPYmopIHtcbiAgdmFyIGRlcml2ZWRNZXRob2QgPSBkZXJpdmVkT2JqW21ldGhvZE5hbWVdO1xuICB2YXIgYmFzZU1ldGhvZCA9IGJhc2VPYmpbbWV0aG9kTmFtZV07XG4gIGlmICghZGVyaXZlZE1ldGhvZCB8fCAhYmFzZU1ldGhvZCkgeyByZXR1cm47IH1cbiAgLy8gVGhlIGRlcml2ZWQgY2xhc3MgZG9lc24ndCBvdmVycmlkZSB0aGUgb25lIGluIHRoZSBiYXNlIG9uZVxuICBpZiAoZGVyaXZlZE1ldGhvZCA9PT0gYmFzZU1ldGhvZCkgeyByZXR1cm47IH1cbiAgLy8gV3JhcHBlclxuICAvLyBUaGUgYmFzZSBtZXRob2QgaXMgY2FsbGVkIGJlZm9yZSB0aGUgb25lIGluIHRoZSBkZXJpdmVkIGNsYXNzXG4gIHZhciB3cmFwcGVyTWV0aG9kID0gZnVuY3Rpb24gKCkge1xuICAgIGJhc2VNZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gZGVyaXZlZE1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xuICBvYmpbbWV0aG9kTmFtZV0gPSB7dmFsdWU6IHdyYXBwZXJNZXRob2QsIHdyaXRhYmxlOiB3aW5kb3cuZGVidWd9O1xufVxuXG4vKipcbiAqIEl0IGNvcGllcyB0aGUgcHJvcGVydGllcyBmcm9tIHNvdXJjZSB0byBkZXN0aW5hdGlvbiBvYmplY3RcbiAqIGlmIHRoZXkgZG9uJ3QgZXhpc3QgYWxyZWFkeVxuICogQHBhcmFtICB7b2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB3aGVyZSBwcm9wZXJ0aWVzIGFyZSBjb3BpZWQgZnJvbVxuICogQHBhcmFtICB7dHlwZX0gZGVzdGluYXRpb24gVGhlIG9iamVjdCB3aGVyZSBwcm9wZXJ0aWVzIGFyZSBjb3BpZWQgdG9cbiAqIEByZXR1cm4ge3VuZGVmaW5lZH1cbiAqL1xuZnVuY3Rpb24gY29weVByb3BlcnRpZXMgKHNvdXJjZSwgZGVzdGluYXRpb24pIHtcbiAgdmFyIHByb3BzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoc291cmNlKTtcbiAgcHJvcHMuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgIHZhciBkZXNjO1xuICAgIGlmICghZGVzdGluYXRpb25bcHJvcF0pIHtcbiAgICAgIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwgcHJvcCk7XG4gICAgICBkZXN0aW5hdGlvbltwcm9wXSA9IHt2YWx1ZTogc291cmNlW3Byb3BdLCB3cml0YWJsZTogZGVzYy53cml0YWJsZX07XG4gICAgfVxuICB9KTtcbn1cblxudmFyIEFOb2RlID0gX2RlcmVxXygnLi9hLW5vZGUnKTtcbnZhciBBRW50aXR5ID0gX2RlcmVxXygnLi9hLWVudGl0eScpO1xuXG59LHtcIi4vYS1lbnRpdHlcIjo1MixcIi4vYS1ub2RlXCI6NTQsXCJkb2N1bWVudC1yZWdpc3Rlci1lbGVtZW50XCI6OH1dLDU2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qIGdsb2JhbCBIVE1MRWxlbWVudCAqL1xudmFyIHNjaGVtYSA9IF9kZXJlcV8oJy4vc2NoZW1hJyk7XG52YXIgc3lzdGVtcyA9IF9kZXJlcV8oJy4vc3lzdGVtJyk7XG52YXIgdXRpbHMgPSBfZGVyZXFfKCcuLi91dGlscy8nKTtcblxudmFyIGNvbXBvbmVudHMgPSBtb2R1bGUuZXhwb3J0cy5jb21wb25lbnRzID0ge307IC8vIEtlZXAgdHJhY2sgb2YgcmVnaXN0ZXJlZCBjb21wb25lbnRzLlxudmFyIHBhcnNlUHJvcGVydGllcyA9IHNjaGVtYS5wYXJzZVByb3BlcnRpZXM7XG52YXIgcGFyc2VQcm9wZXJ0eSA9IHNjaGVtYS5wYXJzZVByb3BlcnR5O1xudmFyIHByb2Nlc3NTY2hlbWEgPSBzY2hlbWEucHJvY2VzcztcbnZhciBpc1NpbmdsZVByb3AgPSBzY2hlbWEuaXNTaW5nbGVQcm9wZXJ0eTtcbnZhciBzdHJpbmdpZnlQcm9wZXJ0aWVzID0gc2NoZW1hLnN0cmluZ2lmeVByb3BlcnRpZXM7XG52YXIgc3RyaW5naWZ5UHJvcGVydHkgPSBzY2hlbWEuc3RyaW5naWZ5UHJvcGVydHk7XG52YXIgc3R5bGVQYXJzZXIgPSB1dGlscy5zdHlsZVBhcnNlcjtcblxuLyoqXG4gKiBDb21wb25lbnQgY2xhc3MgZGVmaW5pdGlvbi5cbiAqXG4gKiBDb21wb25lbnRzIGNvbmZpZ3VyZSBhcHBlYXJhbmNlLCBtb2RpZnkgYmVoYXZpb3IsIG9yIGFkZCBmdW5jdGlvbmFsaXR5IHRvXG4gKiBlbnRpdGllcy4gVGhlIGJlaGF2aW9yIGFuZCBhcHBlYXJhbmNlIG9mIGFuIGVudGl0eSBjYW4gYmUgY2hhbmdlZCBhdCBydW50aW1lXG4gKiBieSBhZGRpbmcsIHJlbW92aW5nLCBvciB1cGRhdGluZyBjb21wb25lbnRzLiBFbnRpdGllcyBkbyBub3Qgc2hhcmUgaW5zdGFuY2VzXG4gKiBvZiBjb21wb25lbnRzLlxuICpcbiAqIEBtZW1iZXIge29iamVjdH0gZGF0YSAtIENvbXBvbmVudCBkYXRhIHBvcHVsYXRlZCBieSBwYXJzaW5nIHRoZVxuICogICAgICAgICBtYXBwZWQgYXR0cmlidXRlIG9mIHRoZSBjb21wb25lbnQgcGx1cyBhcHBseWluZyBkZWZhdWx0cyBhbmQgbWl4aW5zLlxuICogQG1lbWJlciB7b2JqZWN0fSBlbCAtIFJlZmVyZW5jZSB0byB0aGUgZW50aXR5IGVsZW1lbnQuXG4gKiBAbWVtYmVyIHtzdHJpbmd9IG5hbWUgLSBDb21wb25lbnQgbmFtZSBleHBvc2VkIGFzIGFuIEhUTUwgYXR0cmlidXRlLlxuICovXG52YXIgQ29tcG9uZW50ID0gbW9kdWxlLmV4cG9ydHMuQ29tcG9uZW50ID0gZnVuY3Rpb24gKGVsKSB7XG4gIHZhciBuYW1lID0gdGhpcy5uYW1lO1xuICB2YXIgZWxEYXRhID0gSFRNTEVsZW1lbnQucHJvdG90eXBlLmdldEF0dHJpYnV0ZS5jYWxsKGVsLCBuYW1lKTtcblxuICB0aGlzLmVsID0gZWw7XG4gIC8vIENoZWNrIHdoZXRoZXIgd2UgbmVlZCB0byByZWJ1aWxkIHRoZSBzY2hlbWEgZGVwZW5kaW5nIG9uIHRoZSBkYXRhLlxuICAvLyBDYWxsIGJ1aWxkRGF0YSB3aXRoIHNpbGVudCBmbGFnIHRvIHN1cHByZXNzIHdhcm5pbmdzIHdoZW4gcGFyc2luZyBkYXRhIGJlZm9yZSB1cGRhdGluZ1xuICAvLyB0aGUgc2NoZW1hLlxuICBpZiAodGhpcy51cGRhdGVTY2hlbWEpIHtcbiAgICB0aGlzLnVwZGF0ZVNjaGVtYShidWlsZERhdGEoZWwsIG5hbWUsIHRoaXMuc2NoZW1hLCBlbERhdGEsIHRydWUpKTtcbiAgfVxuICB0aGlzLmRhdGEgPSBidWlsZERhdGEoZWwsIG5hbWUsIHRoaXMuc2NoZW1hLCBlbERhdGEpO1xuICB0aGlzLmluaXQoKTtcbiAgdGhpcy51cGRhdGUoKTtcbn07XG5cbkNvbXBvbmVudC5wcm90b3R5cGUgPSB7XG4gIC8qKlxuICAgKiBDb250YWlucyB0aGUgdHlwZSBzY2hlbWEgYW5kIGRlZmF1bHRzIGZvciB0aGUgZGF0YSB2YWx1ZXMuXG4gICAqIERhdGEgaXMgY29lcmNlZCBpbnRvIHRoZSB0eXBlcyBvZiB0aGUgdmFsdWVzIG9mIHRoZSBkZWZhdWx0cy5cbiAgICovXG4gIHNjaGVtYTogeyB9LFxuXG4gIC8qKlxuICAgKiBJbml0IGhhbmRsZXIuIFNpbWlsYXIgdG8gYXR0YWNoZWRDYWxsYmFjay5cbiAgICogQ2FsbGVkIGR1cmluZyBjb21wb25lbnQgaW5pdGlhbGl6YXRpb24gYW5kIGlzIG9ubHkgcnVuIG9uY2UuXG4gICAqIENvbXBvbmVudHMgY2FuIHVzZSB0aGlzIHRvIHNldCBpbml0aWFsIHN0YXRlLlxuICAgKi9cbiAgaW5pdDogZnVuY3Rpb24gKCkgeyAvKiBuby1vcCAqLyB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGUgaGFuZGxlci4gU2ltaWxhciB0byBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2suXG4gICAqIENhbGxlZCB3aGVuZXZlciBjb21wb25lbnQncyBkYXRhIGNoYW5nZXMuXG4gICAqIEFsc28gY2FsbGVkIG9uIGNvbXBvbmVudCBpbml0aWFsaXphdGlvbiB3aGVuIHRoZSBjb21wb25lbnQgcmVjZWl2ZXMgaW5pdGlhbCBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gcHJldkRhdGEgLSBQcmV2aW91cyBhdHRyaWJ1dGVzIG9mIHRoZSBjb21wb25lbnQuXG4gICAqL1xuICB1cGRhdGU6IGZ1bmN0aW9uIChwcmV2RGF0YSkgeyAvKiBuby1vcCAqLyB9LFxuXG4gIHVwZGF0ZVNjaGVtYTogdW5kZWZpbmVkLFxuXG4gIC8qKlxuICAgKiBUaWNrIGhhbmRsZXIuXG4gICAqIENhbGxlZCBvbiBlYWNoIHRpY2sgb2YgdGhlIHNjZW5lIHJlbmRlciBsb29wLlxuICAgKiBBZmZlY3RlZCBieSBwbGF5IGFuZCBwYXVzZS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWUgLSBTY2VuZSB0aWNrIHRpbWUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lRGVsdGEgLSBEaWZmZXJlbmNlIGluIGN1cnJlbnQgcmVuZGVyIHRpbWUgYW5kIHByZXZpb3VzIHJlbmRlciB0aW1lLlxuICAgKi9cbiAgdGljazogdW5kZWZpbmVkLFxuXG4gIC8qKlxuICAgKiBDYWxsZWQgdG8gc3RhcnQgYW55IGR5bmFtaWMgYmVoYXZpb3IgKGUuZy4sIGFuaW1hdGlvbiwgQUksIGV2ZW50cywgcGh5c2ljcykuXG4gICAqL1xuICBwbGF5OiBmdW5jdGlvbiAoKSB7IC8qIG5vLW9wICovIH0sXG5cbiAgLyoqXG4gICAqIENhbGxlZCB0byBzdG9wIGFueSBkeW5hbWljIGJlaGF2aW9yIChlLmcuLCBhbmltYXRpb24sIEFJLCBldmVudHMsIHBoeXNpY3MpLlxuICAgKi9cbiAgcGF1c2U6IGZ1bmN0aW9uICgpIHsgLyogbm8tb3AgKi8gfSxcblxuICAvKipcbiAgICogUmVtb3ZlIGhhbmRsZXIuIFNpbWlsYXIgdG8gZGV0YWNoZWRDYWxsYmFjay5cbiAgICogQ2FsbGVkIHdoZW5ldmVyIGNvbXBvbmVudCBpcyByZW1vdmVkIGZyb20gdGhlIGVudGl0eSAoaS5lLiwgcmVtb3ZlQXR0cmlidXRlKS5cbiAgICogQ29tcG9uZW50cyBjYW4gdXNlIHRoaXMgdG8gcmVzZXQgYmVoYXZpb3Igb24gdGhlIGVudGl0eS5cbiAgICovXG4gIHJlbW92ZTogZnVuY3Rpb24gKCkgeyAvKiBuby1vcCAqLyB9LFxuXG4gIC8qKlxuICAgKiBQYXJzZXMgZWFjaCBwcm9wZXJ0eSBiYXNlZCBvbiBwcm9wZXJ0eSB0eXBlLlxuICAgKiBJZiBjb21wb25lbnQgaXMgc2luZ2xlLXByb3BlcnR5LCB0aGVuIHBhcnNlcyB0aGUgc2luZ2xlIHByb3BlcnR5IHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSBIVE1MIGF0dHJpYnV0ZSB2YWx1ZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBzaWxlbnQgLSBTdXBwcmVzcyB3YXJuaW5nIG1lc3NhZ2VzLlxuICAgKiBAcmV0dXJucyB7b2JqZWN0fSBDb21wb25lbnQgZGF0YS5cbiAgICovXG4gIHBhcnNlOiBmdW5jdGlvbiAodmFsdWUsIHNpbGVudCkge1xuICAgIHZhciBzY2hlbWEgPSB0aGlzLnNjaGVtYTtcbiAgICBpZiAoaXNTaW5nbGVQcm9wKHNjaGVtYSkpIHsgcmV0dXJuIHBhcnNlUHJvcGVydHkodmFsdWUsIHNjaGVtYSk7IH1cbiAgICByZXR1cm4gcGFyc2VQcm9wZXJ0aWVzKHN0eWxlUGFyc2VyLnBhcnNlKHZhbHVlKSwgc2NoZW1hLCB0cnVlLCBzaWxlbnQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTdHJpbmdpZnkgcHJvcGVydGllcyBpZiBuZWNlc3NhcnkuXG4gICAqXG4gICAqIE9ubHkgY2FsbGVkIGZyb20gYEVudGl0eS5zZXRBdHRyaWJ1dGVgIGZvciBwcm9wZXJ0aWVzIHdob3NlIHBhcnNlcnMgYWNjZXB0IGEgbm9uLXN0cmluZ1xuICAgKiB2YWx1ZSAoZS5nLiwgc2VsZWN0b3IsIHZlYzMgcHJvcGVydHkgdHlwZXMpLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YSAtIENvbXBsZXRlIGNvbXBvbmVudCBkYXRhLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgc3RyaW5naWZ5OiBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBzY2hlbWEgPSB0aGlzLnNjaGVtYTtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7IHJldHVybiBkYXRhOyB9XG5cbiAgICBpZiAoaXNTaW5nbGVQcm9wKHNjaGVtYSkpIHsgcmV0dXJuIHN0cmluZ2lmeVByb3BlcnR5KGRhdGEsIHNjaGVtYSk7IH1cbiAgICBkYXRhID0gc3RyaW5naWZ5UHJvcGVydGllcyhkYXRhLCBzY2hlbWEpO1xuICAgIHJldHVybiBzdHlsZVBhcnNlci5zdHJpbmdpZnkoZGF0YSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBjb3B5IG9mIGRhdGEgc3VjaCB0aGF0IHdlIGRvbid0IGV4cG9zZSB0aGUgcHJpdmF0ZSB0aGlzLmRhdGEuXG4gICAqXG4gICAqIEByZXR1cm5zIHtvYmplY3R9IGRhdGFcbiAgICovXG4gIGdldERhdGE6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICBpZiAodHlwZW9mIGRhdGEgIT09ICdvYmplY3QnKSB7IHJldHVybiBkYXRhOyB9XG4gICAgcmV0dXJuIHV0aWxzLmV4dGVuZCh7fSwgZGF0YSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFwcGx5IG5ldyBjb21wb25lbnQgZGF0YSBpZiBkYXRhIGhhcyBjaGFuZ2VkLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSBIVE1MIGF0dHJpYnV0ZSB2YWx1ZS5cbiAgICovXG4gIHVwZGF0ZVByb3BlcnRpZXM6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhciBlbCA9IHRoaXMuZWw7XG4gICAgdmFyIGlzU2luZ2xlUHJvcFNjaGVtYSA9IGlzU2luZ2xlUHJvcCh0aGlzLnNjaGVtYSk7XG4gICAgdmFyIHByZXZpb3VzRGF0YSA9IGV4dGVuZFByb3BlcnRpZXMoe30sIHRoaXMuZGF0YSwgaXNTaW5nbGVQcm9wU2NoZW1hKTtcblxuICAgIGlmICh0aGlzLnVwZGF0ZVNjaGVtYSkge1xuICAgICAgdGhpcy51cGRhdGVTY2hlbWEoYnVpbGREYXRhKGVsLCB0aGlzLm5hbWUsIHRoaXMuc2NoZW1hLCB2YWx1ZSwgdHJ1ZSkpO1xuICAgIH1cbiAgICB0aGlzLmRhdGEgPSBidWlsZERhdGEoZWwsIHRoaXMubmFtZSwgdGhpcy5zY2hlbWEsIHZhbHVlKTtcblxuICAgIC8vIERvbid0IHVwZGF0ZSBpZiBwcm9wZXJ0aWVzIGhhdmVuJ3QgY2hhbmdlZFxuICAgIGlmICghaXNTaW5nbGVQcm9wU2NoZW1hICYmIHV0aWxzLmRlZXBFcXVhbChwcmV2aW91c0RhdGEsIHRoaXMuZGF0YSkpIHsgcmV0dXJuOyB9XG5cbiAgICB0aGlzLnVwZGF0ZShwcmV2aW91c0RhdGEpO1xuXG4gICAgZWwuZW1pdCgnY29tcG9uZW50Y2hhbmdlZCcsIHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIG5ld0RhdGE6IHRoaXMuZ2V0RGF0YSgpLFxuICAgICAgb2xkRGF0YTogcHJldmlvdXNEYXRhXG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEV4dGVuZCBzY2hlbWEgb2YgY29tcG9uZW50IGdpdmVuIGEgcGFydGlhbCBzY2hlbWEuXG4gICAqXG4gICAqIFNvbWUgY29tcG9uZW50cyBtaWdodCB3YW50IHRvIG11dGF0ZSB0aGVpciBzY2hlbWEgYmFzZWQgb24gY2VydGFpbiBwcm9wZXJ0aWVzLlxuICAgKiBlLmcuLCBNYXRlcmlhbCBjb21wb25lbnQgY2hhbmdlcyBpdHMgc2NoZW1hIGJhc2VkIG9uIGBzaGFkZXJgIHRvIGFjY291bnQgZm9yIGRpZmZlcmVudFxuICAgKiB1bmlmb3Jtc1xuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gc2NoZW1hQWRkb24gLSBTY2hlbWEgY2h1bmsgdGhhdCBleHRlbmQgYmFzZSBzY2hlbWEuXG4gICAqL1xuICBleHRlbmRTY2hlbWE6IGZ1bmN0aW9uIChzY2hlbWFBZGRvbikge1xuICAgIC8vIENsb25lIGJhc2Ugc2NoZW1hLlxuICAgIHZhciBleHRlbmRlZFNjaGVtYSA9IHV0aWxzLmV4dGVuZCh7fSwgY29tcG9uZW50c1t0aGlzLm5hbWVdLnNjaGVtYSk7XG4gICAgLy8gRXh0ZW5kIGJhc2Ugc2NoZW1hIHdpdGggbmV3IHNjaGVtYSBjaHVuay5cbiAgICB1dGlscy5leHRlbmQoZXh0ZW5kZWRTY2hlbWEsIHNjaGVtYUFkZG9uKTtcbiAgICB0aGlzLnNjaGVtYSA9IHByb2Nlc3NTY2hlbWEoZXh0ZW5kZWRTY2hlbWEpO1xuICAgIHRoaXMuZWwuZW1pdCgnc2NoZW1hY2hhbmdlZCcsIHsgY29tcG9uZW50OiB0aGlzLm5hbWUgfSk7XG4gIH1cbn07XG5cbi8qKlxuICogUmVnaXN0ZXJzIGEgY29tcG9uZW50IHRvIEEtRnJhbWUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBDb21wb25lbnQgbmFtZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBkZWZpbml0aW9uIC0gQ29tcG9uZW50IHNjaGVtYSBhbmQgbGlmZWN5Y2xlIG1ldGhvZCBoYW5kbGVycy5cbiAqIEByZXR1cm5zIHtvYmplY3R9IENvbXBvbmVudC5cbiAqL1xubW9kdWxlLmV4cG9ydHMucmVnaXN0ZXJDb21wb25lbnQgPSBmdW5jdGlvbiAobmFtZSwgZGVmaW5pdGlvbikge1xuICB2YXIgTmV3Q29tcG9uZW50O1xuICB2YXIgcHJvdG8gPSB7fTtcblxuICAvLyBGb3JtYXQgZGVmaW5pdGlvbiBvYmplY3QgdG8gcHJvdG90eXBlIG9iamVjdC5cbiAgT2JqZWN0LmtleXMoZGVmaW5pdGlvbikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgcHJvdG9ba2V5XSA9IHtcbiAgICAgIHZhbHVlOiBkZWZpbml0aW9uW2tleV0sXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH07XG4gIH0pO1xuXG4gIGlmIChjb21wb25lbnRzW25hbWVdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgY29tcG9uZW50IGAnICsgbmFtZSArICdgIGhhcyBiZWVuIGFscmVhZHkgcmVnaXN0ZXJlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICdDaGVjayB0aGF0IHlvdSBhcmUgbm90IGxvYWRpbmcgdHdvIHZlcnNpb25zIG9mIHRoZSBzYW1lIGNvbXBvbmVudCAnICtcbiAgICAgICAgICAgICAgICAgICAgJ29yIHR3byBkaWZmZXJlbnQgY29tcG9uZW50cyBvZiB0aGUgc2FtZSBuYW1lLicpO1xuICB9XG4gIE5ld0NvbXBvbmVudCA9IGZ1bmN0aW9uIChlbCkge1xuICAgIENvbXBvbmVudC5jYWxsKHRoaXMsIGVsKTtcbiAgfTtcbiAgTmV3Q29tcG9uZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ29tcG9uZW50LnByb3RvdHlwZSwgcHJvdG8pO1xuICBOZXdDb21wb25lbnQucHJvdG90eXBlLm5hbWUgPSBuYW1lO1xuICBOZXdDb21wb25lbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTmV3Q29tcG9uZW50O1xuICBOZXdDb21wb25lbnQucHJvdG90eXBlLnN5c3RlbSA9IHN5c3RlbXMgJiYgc3lzdGVtcy5zeXN0ZW1zW25hbWVdO1xuXG4gIGNvbXBvbmVudHNbbmFtZV0gPSB7XG4gICAgQ29tcG9uZW50OiBOZXdDb21wb25lbnQsXG4gICAgZGVwZW5kZW5jaWVzOiBOZXdDb21wb25lbnQucHJvdG90eXBlLmRlcGVuZGVuY2llcyxcbiAgICBwYXJzZTogTmV3Q29tcG9uZW50LnByb3RvdHlwZS5wYXJzZS5iaW5kKE5ld0NvbXBvbmVudC5wcm90b3R5cGUpLFxuICAgIHNjaGVtYTogdXRpbHMuZXh0ZW5kKHByb2Nlc3NTY2hlbWEoTmV3Q29tcG9uZW50LnByb3RvdHlwZS5zY2hlbWEpKSxcbiAgICBzdHJpbmdpZnk6IE5ld0NvbXBvbmVudC5wcm90b3R5cGUuc3RyaW5naWZ5LmJpbmQoTmV3Q29tcG9uZW50LnByb3RvdHlwZSksXG4gICAgdHlwZTogTmV3Q29tcG9uZW50LnByb3RvdHlwZS50eXBlXG4gIH07XG4gIHJldHVybiBOZXdDb21wb25lbnQ7XG59O1xuXG4vKipcbiAqIEJ1aWxkcyBjb21wb25lbnQgZGF0YSBmcm9tIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBlbnRpdHksIHVsdGltYXRlbHlcbiAqIHVwZGF0aW5nIHRoaXMuZGF0YS5cbiAqXG4gKiBJZiB0aGUgY29tcG9uZW50IHdhcyBkZXRhY2hlZCBjb21wbGV0ZWx5LCBzZXQgZGF0YSB0byBudWxsLlxuICpcbiAqIFByZWNlZGVuY2U6XG4gKiAxLiBEZWZhdWx0cyBkYXRhXG4gKiAyLiBNaXhpbiBkYXRhLlxuICogMy4gQXR0cmlidXRlIGRhdGEuXG4gKlxuICogRmluYWxseSBjb2VyY2UgdGhlIGRhdGEgdG8gdGhlIHR5cGVzIG9mIHRoZSBkZWZhdWx0cy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZWwgLSBFbGVtZW50IHRvIGJ1aWxkIGRhdGEgZnJvbS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYW1lIC0gQ29tcG9uZW50IG5hbWUuXG4gKiBAcGFyYW0ge29iamVjdH0gc2NoZW1hIC0gQ29tcG9uZW50IHNjaGVtYS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBlbERhdGEgLSBFbGVtZW50IGN1cnJlbnQgZGF0YS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2lsZW50IC0gU3VwcHJlc3Mgd2FybmluZyBtZXNzYWdlcy5cbiAqIEByZXR1cm4ge29iamVjdH0gVGhlIGNvbXBvbmVudCBkYXRhXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkRGF0YSAoZWwsIG5hbWUsIHNjaGVtYSwgZWxEYXRhLCBzaWxlbnQpIHtcbiAgdmFyIGNvbXBvbmVudERlZmluZWQgPSBlbERhdGEgIT09IG51bGw7XG4gIHZhciBkYXRhID0ge307XG4gIHZhciBpc1NpbmdsZVByb3BTY2hlbWEgPSBpc1NpbmdsZVByb3Aoc2NoZW1hKTtcbiAgdmFyIG1peGluRWxzID0gZWwubWl4aW5FbHM7XG5cbiAgaWYgKCFpc1NpbmdsZVByb3BTY2hlbWEgJiYgdHlwZW9mIGVsRGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICBlbERhdGEgPSBzdHlsZVBhcnNlci5wYXJzZShlbERhdGEpO1xuICB9XG5cbiAgLy8gMS4gRGVmYXVsdCB2YWx1ZXMgKGxvd2VzdCBwcmVjZW5kZW5jZSkuXG4gIGlmIChpc1NpbmdsZVByb3BTY2hlbWEpIHtcbiAgICBkYXRhID0gc2NoZW1hLmRlZmF1bHQ7XG4gIH0gZWxzZSB7XG4gICAgT2JqZWN0LmtleXMoc2NoZW1hKS5mb3JFYWNoKGZ1bmN0aW9uIGFwcGx5RGVmYXVsdCAoa2V5KSB7XG4gICAgICBkYXRhW2tleV0gPSBzY2hlbWFba2V5XS5kZWZhdWx0O1xuICAgIH0pO1xuICB9XG5cbiAgLy8gMi4gTWl4aW4gdmFsdWVzLlxuICBtaXhpbkVscy5mb3JFYWNoKGFwcGx5TWl4aW4pO1xuICBmdW5jdGlvbiBhcHBseU1peGluIChtaXhpbkVsKSB7XG4gICAgdmFyIG1peGluRGF0YSA9IEhUTUxFbGVtZW50LnByb3RvdHlwZS5nZXRBdHRyaWJ1dGUuY2FsbChtaXhpbkVsLCBuYW1lKTtcbiAgICBpZiAobWl4aW5EYXRhKSB7XG4gICAgICBtaXhpbkRhdGEgPSBpc1NpbmdsZVByb3BTY2hlbWFcbiAgICAgICAgPyBtaXhpbkRhdGEgOiBzdHlsZVBhcnNlci5wYXJzZShtaXhpbkRhdGEpO1xuICAgICAgZGF0YSA9IGV4dGVuZFByb3BlcnRpZXMoZGF0YSwgbWl4aW5EYXRhLCBpc1NpbmdsZVByb3BTY2hlbWEpO1xuICAgIH1cbiAgfVxuXG4gIC8vIDMuIEF0dHJpYnV0ZSB2YWx1ZXMgKGhpZ2hlc3QgcHJlY2VuZGVuY2UpLlxuICBpZiAoY29tcG9uZW50RGVmaW5lZCkge1xuICAgIGRhdGEgPSBleHRlbmRQcm9wZXJ0aWVzKGRhdGEsIGVsRGF0YSwgaXNTaW5nbGVQcm9wU2NoZW1hKTtcbiAgfVxuXG4gIC8vIFBhcnNlIGFuZCBjb2VyY2UgdXNpbmcgdGhlIHNjaGVtYS5cbiAgaWYgKGlzU2luZ2xlUHJvcChzY2hlbWEpKSB7XG4gICAgcmV0dXJuIHBhcnNlUHJvcGVydHkoZGF0YSwgc2NoZW1hKTtcbiAgfVxuXG4gIHJldHVybiBwYXJzZVByb3BlcnRpZXMoZGF0YSwgc2NoZW1hLCB1bmRlZmluZWQsIHNpbGVudCk7XG59XG5tb2R1bGUuZXhwb3J0cy5idWlsZERhdGEgPSBidWlsZERhdGE7XG5cbi8qKlxuKiBPYmplY3QgZXh0ZW5kaW5nIHdpdGggY2hlY2tpbmcgZm9yIHNpbmdsZS1wcm9wZXJ0eSBzY2hlbWEuXG4qXG4qIEBwYXJhbSBkZXN0IC0gRGVzdGluYXRpb24gb2JqZWN0IG9yIHZhbHVlLlxuKiBAcGFyYW0gc291cmNlIC0gU291cmNlIG9iamVjdCBvciB2YWx1ZVxuKiBAcGFyYW0ge2Jvb2xlYW59IGlzU2luZ2xlUHJvcFNjaGVtYSAtIFdoZXRoZXIgb3Igbm90IHNjaGVtYSBpcyBvbmx5IGEgc2luZ2xlIHByb3BlcnR5LlxuKiBAcmV0dXJucyBPdmVycmlkZGVuIG9iamVjdCBvciB2YWx1ZS5cbiovXG5mdW5jdGlvbiBleHRlbmRQcm9wZXJ0aWVzIChkZXN0LCBzb3VyY2UsIGlzU2luZ2xlUHJvcFNjaGVtYSkge1xuICBpZiAoaXNTaW5nbGVQcm9wU2NoZW1hKSB7XG4gICAgaWYgKHNvdXJjZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICh0eXBlb2Ygc291cmNlID09PSAnb2JqZWN0JyAmJiBPYmplY3Qua2V5cyhzb3VyY2UpLmxlbmd0aCA9PT0gMCkpIHtcbiAgICAgIHJldHVybiBkZXN0O1xuICAgIH1cbiAgICByZXR1cm4gc291cmNlO1xuICB9XG4gIHJldHVybiB1dGlscy5leHRlbmQoZGVzdCwgc291cmNlKTtcbn1cblxufSx7XCIuLi91dGlscy9cIjoxMDIsXCIuL3NjaGVtYVwiOjYyLFwiLi9zeXN0ZW1cIjo2NH1dLDU3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBjb29yZGluYXRlcyA9IF9kZXJlcV8oJy4uL3V0aWxzL2Nvb3JkaW5hdGVzJyk7XG52YXIgZGVidWcgPSBfZGVyZXFfKCdkZWJ1ZycpO1xuXG52YXIgZXJyb3IgPSBkZWJ1ZygnY29yZTpwcm9wZXJ0eVR5cGVzOndhcm4nKTtcblxudmFyIHByb3BlcnR5VHlwZXMgPSBtb2R1bGUuZXhwb3J0cy5wcm9wZXJ0eVR5cGVzID0ge307XG5cbi8vIEJ1aWx0LWluIHByb3BlcnR5IHR5cGVzLlxucmVnaXN0ZXJQcm9wZXJ0eVR5cGUoJ2FycmF5JywgW10sIGFycmF5UGFyc2UsIGFycmF5U3RyaW5naWZ5KTtcbnJlZ2lzdGVyUHJvcGVydHlUeXBlKCdib29sZWFuJywgZmFsc2UsIGJvb2xQYXJzZSk7XG5yZWdpc3RlclByb3BlcnR5VHlwZSgnY29sb3InLCAnI0ZGRicsIGRlZmF1bHRQYXJzZSwgZGVmYXVsdFN0cmluZ2lmeSk7XG5yZWdpc3RlclByb3BlcnR5VHlwZSgnaW50JywgMCwgaW50UGFyc2UpO1xucmVnaXN0ZXJQcm9wZXJ0eVR5cGUoJ251bWJlcicsIDAsIG51bWJlclBhcnNlKTtcbnJlZ2lzdGVyUHJvcGVydHlUeXBlKCdzZWxlY3RvcicsICcnLCBzZWxlY3RvclBhcnNlLCBzZWxlY3RvclN0cmluZ2lmeSk7XG5yZWdpc3RlclByb3BlcnR5VHlwZSgnc2VsZWN0b3JBbGwnLCAnJywgc2VsZWN0b3JBbGxQYXJzZSwgc2VsZWN0b3JBbGxTdHJpbmdpZnkpO1xucmVnaXN0ZXJQcm9wZXJ0eVR5cGUoJ3NyYycsICcnLCBzcmNQYXJzZSk7XG5yZWdpc3RlclByb3BlcnR5VHlwZSgnc3RyaW5nJywgJycsIGRlZmF1bHRQYXJzZSwgZGVmYXVsdFN0cmluZ2lmeSk7XG5yZWdpc3RlclByb3BlcnR5VHlwZSgndGltZScsIDAsIGludFBhcnNlKTtcbnJlZ2lzdGVyUHJvcGVydHlUeXBlKCd2ZWMyJywgeyB4OiAwLCB5OiAwIH0sIHZlY1BhcnNlLCBjb29yZGluYXRlcy5zdHJpbmdpZnkpO1xucmVnaXN0ZXJQcm9wZXJ0eVR5cGUoJ3ZlYzMnLCB7IHg6IDAsIHk6IDAsIHo6IDAgfSwgdmVjUGFyc2UsIGNvb3JkaW5hdGVzLnN0cmluZ2lmeSk7XG5yZWdpc3RlclByb3BlcnR5VHlwZSgndmVjNCcsIHsgeDogMCwgeTogMCwgejogMCwgdzogMCB9LCB2ZWNQYXJzZSwgY29vcmRpbmF0ZXMuc3RyaW5naWZ5KTtcblxuLyoqXG4gKiBSZWdpc3RlciBhIHBhcnNlciBmb3IgcmUtdXNlIHN1Y2ggdGhhdCB3aGVuIHNvbWVvbmUgdXNlcyBgdHlwZWAgaW4gdGhlIHNjaGVtYSxcbiAqIGBzY2hlbWEucHJvY2Vzc2Agd2lsbCBzZXQgdGhlIHByb3BlcnR5IGBwYXJzZWAgYW5kIGBzdHJpbmdpZnlgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gVHlwZSBuYW1lLlxuICogQHBhcmFtIFtkZWZhdWx0VmFsdWU9bnVsbF0gLVxuICogICBEZWZhdWx0IHZhbHVlIHRvIHVzZSBpZiBjb21wb25lbnQgZG9lcyBub3QgZGVmaW5lIGRlZmF1bHQgdmFsdWUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbcGFyc2U9ZGVmYXVsdFBhcnNlXSAtIFBhcnNlIHN0cmluZyBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtzdHJpbmdpZnk9ZGVmYXVsdFN0cmluZ2lmeV0gLSBTdHJpbmdpZnkgdG8gRE9NIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiByZWdpc3RlclByb3BlcnR5VHlwZSAodHlwZSwgZGVmYXVsdFZhbHVlLCBwYXJzZSwgc3RyaW5naWZ5KSB7XG4gIGlmICgndHlwZScgaW4gcHJvcGVydHlUeXBlcykge1xuICAgIGVycm9yKCdQcm9wZXJ0eSB0eXBlICcgKyB0eXBlICsgJyBpcyBhbHJlYWR5IHJlZ2lzdGVyZWQuJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcHJvcGVydHlUeXBlc1t0eXBlXSA9IHtcbiAgICBkZWZhdWx0OiBkZWZhdWx0VmFsdWUsXG4gICAgcGFyc2U6IHBhcnNlIHx8IGRlZmF1bHRQYXJzZSxcbiAgICBzdHJpbmdpZnk6IHN0cmluZ2lmeSB8fCBkZWZhdWx0U3RyaW5naWZ5XG4gIH07XG59XG5tb2R1bGUuZXhwb3J0cy5yZWdpc3RlclByb3BlcnR5VHlwZSA9IHJlZ2lzdGVyUHJvcGVydHlUeXBlO1xuXG5mdW5jdGlvbiBhcnJheVBhcnNlICh2YWx1ZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHsgcmV0dXJuIHZhbHVlOyB9XG4gIGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykgeyByZXR1cm4gW107IH1cbiAgcmV0dXJuIHZhbHVlLnNwbGl0KCcsJykubWFwKHRyaW0pO1xuICBmdW5jdGlvbiB0cmltIChzdHIpIHsgcmV0dXJuIHN0ci50cmltKCk7IH1cbn1cblxuZnVuY3Rpb24gYXJyYXlTdHJpbmdpZnkgKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZS5qb2luKCcsICcpO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0UGFyc2UgKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFN0cmluZ2lmeSAodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSBudWxsKSB7IHJldHVybiAnbnVsbCc7IH1cbiAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG59XG5cbmZ1bmN0aW9uIGJvb2xQYXJzZSAodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSAnZmFsc2UnICYmIHZhbHVlICE9PSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaW50UGFyc2UgKHZhbHVlKSB7XG4gIHJldHVybiBwYXJzZUludCh2YWx1ZSwgMTApO1xufVxuXG5mdW5jdGlvbiBudW1iZXJQYXJzZSAodmFsdWUpIHtcbiAgcmV0dXJuIHBhcnNlRmxvYXQodmFsdWUsIDEwKTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0b3JQYXJzZSAodmFsdWUpIHtcbiAgaWYgKCF2YWx1ZSkgeyByZXR1cm4gbnVsbDsgfVxuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykgeyByZXR1cm4gdmFsdWU7IH1cbiAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodmFsdWUpO1xufVxuXG5mdW5jdGlvbiBzZWxlY3RvckFsbFBhcnNlICh2YWx1ZSkge1xuICBpZiAoIXZhbHVlKSB7IHJldHVybiBudWxsOyB9XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7IHJldHVybiB2YWx1ZTsgfVxuICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCh2YWx1ZSk7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdG9yU3RyaW5naWZ5ICh2YWx1ZSkge1xuICBpZiAodmFsdWUuZ2V0QXR0cmlidXRlKSB7XG4gICAgcmV0dXJuICcjJyArIHZhbHVlLmdldEF0dHJpYnV0ZSgnaWQnKTtcbiAgfVxuICByZXR1cm4gZGVmYXVsdFN0cmluZ2lmeSh2YWx1ZSk7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdG9yQWxsU3RyaW5naWZ5ICh2YWx1ZSkge1xuICBpZiAodmFsdWUuaXRlbSkge1xuICAgIHZhciBlbHMgPSAnJztcbiAgICB2YXIgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAgIGVscyArPSAnIycgKyB2YWx1ZVtpXS5nZXRBdHRyaWJ1dGUoJ2lkJyk7XG4gICAgICBpZiAoaSAhPT0gdmFsdWUubGVuZ3RoIC0gMSkgeyBlbHMgKz0gJywgJzsgfVxuICAgIH1cbiAgICByZXR1cm4gZWxzO1xuICB9XG4gIHJldHVybiBkZWZhdWx0U3RyaW5naWZ5KHZhbHVlKTtcbn1cblxuLyoqXG4gKiBgc3JjYCBwYXJzZXIgZm9yIGFzc2V0cy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSBDYW4gZWl0aGVyIGJlIGB1cmwoPHZhbHVlPilgIG9yIGEgc2VsZWN0b3IgdG8gYW4gYXNzZXQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBQYXJzZWQgdmFsdWUgZnJvbSBgdXJsKDx2YWx1ZT4pYCBvciBzcmMgZnJvbSBgPHNvbWVhc3NldCBzcmM+YC5cbiAqL1xuZnVuY3Rpb24gc3JjUGFyc2UgKHZhbHVlKSB7XG4gIHZhciBwYXJzZWRVcmwgPSB2YWx1ZS5tYXRjaCgvXFx1cmxcXCgoLispXFwpLyk7XG4gIGlmIChwYXJzZWRVcmwpIHsgcmV0dXJuIHBhcnNlZFVybFsxXTsgfVxuXG4gIHZhciBlbCA9IHNlbGVjdG9yUGFyc2UodmFsdWUpO1xuICBpZiAoZWwpIHsgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZSgnc3JjJyk7IH1cblxuICByZXR1cm4gJyc7XG59XG5cbmZ1bmN0aW9uIHZlY1BhcnNlICh2YWx1ZSkge1xuICByZXR1cm4gY29vcmRpbmF0ZXMucGFyc2UodmFsdWUsIHRoaXMuZGVmYXVsdCk7XG59XG5cbn0se1wiLi4vdXRpbHMvY29vcmRpbmF0ZXNcIjoxMDAsXCJkZWJ1Z1wiOjN9XSw1ODpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKiBnbG9iYWwgUHJvbWlzZSAqL1xudmFyIGluaXRGdWxsc2NyZWVuID0gX2RlcmVxXygnLi9mdWxsc2NyZWVuJyk7XG52YXIgaW5pdE1ldGFUYWdzID0gX2RlcmVxXygnLi9tZXRhVGFncycpLmluamVjdDtcbnZhciBpbml0V2FrZWxvY2sgPSBfZGVyZXFfKCcuL3dha2Vsb2NrJyk7XG52YXIgcmUgPSBfZGVyZXFfKCcuLi9hLXJlZ2lzdGVyLWVsZW1lbnQnKTtcbnZhciBzeXN0ZW1zID0gX2RlcmVxXygnLi4vc3lzdGVtJykuc3lzdGVtcztcbnZhciBUSFJFRSA9IF9kZXJlcV8oJy4uLy4uL2xpYi90aHJlZScpO1xudmFyIFRXRUVOID0gX2RlcmVxXygndHdlZW4uanMnKTtcbnZhciB1dGlscyA9IF9kZXJlcV8oJy4uLy4uL3V0aWxzLycpO1xuLy8gUmVxdWlyZSBhZnRlci5cbnZhciBBRW50aXR5ID0gX2RlcmVxXygnLi4vYS1lbnRpdHknKTtcbnZhciBBTm9kZSA9IF9kZXJlcV8oJy4uL2Etbm9kZScpO1xuXG52YXIgcmVnaXN0ZXJFbGVtZW50ID0gcmUucmVnaXN0ZXJFbGVtZW50O1xudmFyIGlzSU9TID0gdXRpbHMuaXNJT1MoKTtcbnZhciBpc01vYmlsZSA9IHV0aWxzLmlzTW9iaWxlKCk7XG5cbi8qKlxuICogU2NlbmUgZWxlbWVudCwgaG9sZHMgYWxsIGVudGl0aWVzLlxuICpcbiAqIEBtZW1iZXIge251bWJlcn0gYW5pbWF0aW9uRnJhbWVJRFxuICogQG1lbWJlciB7YXJyYXl9IGJlaGF2aW9ycyAtIENvbXBvbmVudCBpbnN0YW5jZXMgdGhhdCBoYXZlIHJlZ2lzdGVyZWQgdGhlbXNlbHZlcyB0byBiZVxuICAgICAgICAgICB1cGRhdGVkIG9uIGV2ZXJ5IHRpY2suXG4gKiBAbWVtYmVyIHtvYmplY3R9IGNhbWVyYSAtIHRocmVlLmpzIENhbWVyYSBvYmplY3QuXG4gKiBAbWVtYmVyIHtvYmplY3R9IGNhbnZhc1xuICogQG1lbWJlciB7Ym9vbH0gaXNTY2VuZSAtIERpZmZlcmVudGlhdGVzIGFzIHNjZW5lIGVudGl0eSBhcyBvcHBvc2VkIHRvIG90aGVyIGVudGl0ZXMuXG4gKiBAbWVtYmVyIHtib29sfSBpc01vYmlsZSAtIFdoZXRoZXIgYnJvd3NlciBpcyBtb2JpbGUgKHZpYSBVQSBkZXRlY3Rpb24pLlxuICogQG1lbWJlciB7b2JqZWN0fSBvYmplY3QzRCAtIFJvb3QgdGhyZWUuanMgU2NlbmUgb2JqZWN0LlxuICogQG1lbWJlciB7b2JqZWN0fSBtb25vUmVuZGVyZXJcbiAqIEBtZW1iZXIge29iamVjdH0gcmVuZGVyZXJcbiAqIEBtZW1iZXIge2Jvb2x9IHJlbmRlclN0YXJ0ZWRcbiAqIEBtZW1iZXIge29iamVjdH0gc3RlcmVvUmVuZGVyZXJcbiAqIEBtZW1iZXIge29iamVjdH0gc3lzdGVtcyAtIFJlZ2lzdGVyZWQgaW5zdGFudGlhdGVkIHN5c3RlbXMuXG4gKiBAbWVtYmVyIHtudW1iZXJ9IHRpbWVcbiAqL1xudmFyIEFTY2VuZSA9IG1vZHVsZS5leHBvcnRzID0gcmVnaXN0ZXJFbGVtZW50KCdhLXNjZW5lJywge1xuICBwcm90b3R5cGU6IE9iamVjdC5jcmVhdGUoQUVudGl0eS5wcm90b3R5cGUsIHtcbiAgICBkZWZhdWx0Q29tcG9uZW50czoge1xuICAgICAgdmFsdWU6IHtcbiAgICAgICAgJ2NhbnZhcyc6ICcnLFxuICAgICAgICAna2V5Ym9hcmQtc2hvcnRjdXRzJzogJycsXG4gICAgICAgICd2ci1tb2RlLXVpJzogJydcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgY3JlYXRlZENhbGxiYWNrOiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlzTW9iaWxlID0gaXNNb2JpbGU7XG4gICAgICAgIHRoaXMuaXNJT1MgPSBpc0lPUztcbiAgICAgICAgdGhpcy5pc1NjZW5lID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vYmplY3QzRCA9IG5ldyBUSFJFRS5TY2VuZSgpO1xuICAgICAgICB0aGlzLnN5c3RlbXMgPSB7fTtcbiAgICAgICAgdGhpcy50aW1lID0gMDtcbiAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGluaXQ6IHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuYmVoYXZpb3JzID0gW107XG4gICAgICAgIHRoaXMuaGFzTG9hZGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNQbGF5aW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vcmlnaW5hbEhUTUwgPSB0aGlzLmlubmVySFRNTDtcbiAgICAgICAgdGhpcy5zZXR1cFN5c3RlbXMoKTtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdyZW5kZXItdGFyZ2V0LWxvYWRlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzLnNldHVwUmVuZGVyZXIoKTtcbiAgICAgICAgICB0aGlzLnJlc2l6ZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0sXG5cbiAgICBhdHRhY2hlZENhbGxiYWNrOiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBpbml0RnVsbHNjcmVlbih0aGlzKTtcbiAgICAgICAgaW5pdE1ldGFUYWdzKHRoaXMpO1xuICAgICAgICBpbml0V2FrZWxvY2sodGhpcyk7XG5cbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCB0aGlzLnJlc2l6ZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMucmVzaXplLmJpbmQodGhpcyksIGZhbHNlKTtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdmdWxsc2NyZWVuLWV4aXQnLCB0aGlzLmV4aXRWUi5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5wbGF5KCk7XG4gICAgICB9LFxuICAgICAgd3JpdGFibGU6IHdpbmRvdy5kZWJ1Z1xuICAgIH0sXG5cbiAgICBzZXR1cFN5c3RlbXM6IHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzeXN0ZW1zS2V5cyA9IE9iamVjdC5rZXlzKHN5c3RlbXMpO1xuICAgICAgICBzeXN0ZW1zS2V5cy5mb3JFYWNoKHRoaXMuaW5pdFN5c3RlbS5iaW5kKHRoaXMpKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgaW5pdFN5c3RlbToge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHZhciBzeXN0ZW07XG4gICAgICAgIGlmICh0aGlzLnN5c3RlbXNbbmFtZV0pIHsgcmV0dXJuOyB9XG4gICAgICAgIHN5c3RlbSA9IHRoaXMuc3lzdGVtc1tuYW1lXSA9IG5ldyBzeXN0ZW1zW25hbWVdKCk7XG4gICAgICAgIHN5c3RlbS5zY2VuZUVsID0gdGhpcztcbiAgICAgICAgc3lzdGVtLmluaXQoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2h1dHMgZG93biBzY2VuZSBvbiBkZXRhY2guXG4gICAgICovXG4gICAgZGV0YWNoZWRDYWxsYmFjazoge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuYW5pbWF0aW9uRnJhbWVJRCk7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uRnJhbWVJRCA9IG51bGw7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBiZWhhdmlvciAtIEdlbmVyYWxseSBhIGNvbXBvbmVudC4gTXVzdCBpbXBsZW1lbnQgYSAudXBkYXRlKCkgbWV0aG9kIHRvXG4gICAgICogICAgICAgIGJlIGNhbGxlZCBvbiBldmVyeSB0aWNrLlxuICAgICAqL1xuICAgIGFkZEJlaGF2aW9yOiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKGJlaGF2aW9yKSB7XG4gICAgICAgIHZhciBiZWhhdmlvcnMgPSB0aGlzLmJlaGF2aW9ycztcbiAgICAgICAgaWYgKGJlaGF2aW9ycy5pbmRleE9mKGJlaGF2aW9yKSAhPT0gLTEpIHsgcmV0dXJuOyB9XG4gICAgICAgIGJlaGF2aW9ycy5wdXNoKGJlaGF2aW9yKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhbGx5IG11c3QgYmUgdHJpZ2dlcmVkIG9uIHVzZXIgYWN0aW9uIGZvciByZXF1ZXN0aW5nIGZ1bGxzY3JlZW4uXG4gICAgICovXG4gICAgZW50ZXJWUjoge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB0aGlzLnNldFN0ZXJlb1JlbmRlcmVyKCk7XG4gICAgICAgIGlmIChpc01vYmlsZSkge1xuICAgICAgICAgIHNldEZ1bGxzY3JlZW4odGhpcy5jYW52YXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc3RlcmVvUmVuZGVyZXIuc2V0RnVsbFNjcmVlbih0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZFN0YXRlKCd2ci1tb2RlJyk7XG4gICAgICAgIHRoaXMuZW1pdCgnZW50ZXItdnInLCBldmVudCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGV4aXRWUjoge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zZXRNb25vUmVuZGVyZXIoKTtcbiAgICAgICAgdGhpcy5yZW1vdmVTdGF0ZSgndnItbW9kZScpO1xuICAgICAgICB0aGlzLmVtaXQoJ2V4aXQtdnInLCB7IHRhcmdldDogdGhpcyB9KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGJlaGF2aW9yIC0gR2VuZXJhbGx5IGEgY29tcG9uZW50LiBIYXMgcmVnaXN0ZXJlZCBpdHNlbGYgdG8gYmVoYXZpb3JzLlxuICAgICAqL1xuICAgIHJlbW92ZUJlaGF2aW9yOiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKGJlaGF2aW9yKSB7XG4gICAgICAgIHZhciBiZWhhdmlvcnMgPSB0aGlzLmJlaGF2aW9ycztcbiAgICAgICAgdmFyIGluZGV4ID0gYmVoYXZpb3JzLmluZGV4T2YoYmVoYXZpb3IpO1xuICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7IHJldHVybjsgfVxuICAgICAgICBiZWhhdmlvcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVzaXplOiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2FtZXJhID0gdGhpcy5jYW1lcmE7XG4gICAgICAgIHZhciBjYW52YXMgPSB0aGlzLmNhbnZhcztcbiAgICAgICAgdmFyIHNpemU7XG5cbiAgICAgICAgLy8gUG9zc2libGUgY2FtZXJhIG9yIGNhbnZhcyBub3QgaW5qZWN0ZWQgeWV0LlxuICAgICAgICBpZiAoIWNhbWVyYSB8fCAhY2FudmFzKSB7IHJldHVybjsgfVxuXG4gICAgICAgIC8vIFVwZGF0ZSBjYW52YXMuXG4gICAgICAgIGlmICghaXNNb2JpbGUpIHtcbiAgICAgICAgICBjYW52YXMuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgICAgICAgY2FudmFzLnN0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwZGF0ZSBjYW1lcmEuXG4gICAgICAgIHNpemUgPSBnZXRDYW52YXNTaXplKGNhbnZhcywgaXNNb2JpbGUpO1xuICAgICAgICBjYW1lcmEuYXNwZWN0ID0gc2l6ZS53aWR0aCAvIHNpemUuaGVpZ2h0O1xuICAgICAgICBjYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuXG4gICAgICAgIC8vIE5vdGlmeSByZW5kZXJlciBvZiBzaXplIGNoYW5nZS5cbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTaXplKHNpemUud2lkdGgsIHNpemUuaGVpZ2h0LCB0cnVlKTtcbiAgICAgIH0sXG4gICAgICB3cml0YWJsZTogd2luZG93LmRlYnVnXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgcmVuZGVyZXIgdG8gbW9ubyAob25lIGV5ZSkuXG4gICAgICovXG4gICAgc2V0TW9ub1JlbmRlcmVyOiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gdGhpcy5tb25vUmVuZGVyZXI7XG4gICAgICAgIHRoaXMucmVzaXplKCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgcmVuZGVyZXIgdG8gc3RlcmVvICh0d28gZXllcykuXG4gICAgICovXG4gICAgc2V0U3RlcmVvUmVuZGVyZXI6IHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSB0aGlzLnN0ZXJlb1JlbmRlcmVyO1xuICAgICAgICB0aGlzLnJlc2l6ZSgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBzZXR1cFJlbmRlcmVyOiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2FudmFzID0gdGhpcy5jYW52YXM7XG4gICAgICAgIC8vIFNldCBhdCBzdGFydHVwLiBUbyBlbmFibGUvZGlzYWJsZSBhbnRpYWxpYXNcbiAgICAgICAgLy8gYXQgcnVudHRpbWUgd2Ugd291bGQgaGF2ZSB0byByZWNyZWF0ZSB0aGUgd2hvbGUgY29udGV4dFxuICAgICAgICB2YXIgYW50aWFsaWFzID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2FudGlhbGlhcycpID09PSAndHJ1ZSc7XG4gICAgICAgIHZhciByZW5kZXJlciA9IHRoaXMucmVuZGVyZXIgPSB0aGlzLm1vbm9SZW5kZXJlciA9XG4gICAgICAgICAgbmV3IFRIUkVFLldlYkdMUmVuZGVyZXIoe1xuICAgICAgICAgICAgY2FudmFzOiBjYW52YXMsXG4gICAgICAgICAgICBhbnRpYWxpYXM6IGFudGlhbGlhcyxcbiAgICAgICAgICAgIGFscGhhOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIHJlbmRlcmVyLnNldFBpeGVsUmF0aW8od2luZG93LmRldmljZVBpeGVsUmF0aW8pO1xuICAgICAgICByZW5kZXJlci5zb3J0T2JqZWN0cyA9IGZhbHNlO1xuICAgICAgICBBU2NlbmUucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgdGhpcy5zdGVyZW9SZW5kZXJlciA9IG5ldyBUSFJFRS5WUkVmZmVjdChyZW5kZXJlcik7XG4gICAgICB9LFxuICAgICAgd3JpdGFibGU6IHdpbmRvdy5kZWJ1Z1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVyIGF0dGFjaGVkIHRvIGVsZW1lbnRzIHRvIGhlbHAgc2NlbmUga25vdyB3aGVuIHRvIGtpY2sgb2ZmLlxuICAgICAqIFNjZW5lIHdhaXRzIGZvciBhbGwgZW50aXRpZXMgdG8gbG9hZC5cbiAgICAgKi9cbiAgICBwbGF5OiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHRoaXMucmVuZGVyU3RhcnRlZCkge1xuICAgICAgICAgIEFFbnRpdHkucHJvdG90eXBlLnBsYXkuY2FsbCh0aGlzKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAodGhpcy5yZW5kZXJTdGFydGVkKSB7IHJldHVybjsgfVxuXG4gICAgICAgICAgQUVudGl0eS5wcm90b3R5cGUucGxheS5jYWxsKHRoaXMpO1xuICAgICAgICAgIHRoaXMucmVzaXplKCk7XG5cbiAgICAgICAgICAvLyBLaWNrIG9mZiByZW5kZXIgbG9vcC5cbiAgICAgICAgICBpZiAodGhpcy5yZW5kZXJlcikge1xuICAgICAgICAgICAgaWYgKHdpbmRvdy5wZXJmb3JtYW5jZSkge1xuICAgICAgICAgICAgICB3aW5kb3cucGVyZm9ybWFuY2UubWFyaygncmVuZGVyLXN0YXJ0ZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlclN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZW5kZXJzdGFydCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gc2V0VGltZW91dCB0byB3YWl0IGZvciBhbGwgbm9kZXMgdG8gYXR0YWNoIGFuZCBydW4gdGhlaXIgY2FsbGJhY2tzLlxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBBRW50aXR5LnByb3RvdHlwZS5sb2FkLmNhbGwoc2VsZik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZWxvYWQgdGhlIHNjZW5lIHRvIHRoZSBvcmlnaW5hbCBET00gY29udGVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbH0gZG9QYXVzZSAtIFdoZXRoZXIgdG8gcmVsb2FkIHRoZSBzY2VuZSB3aXRoIGFsbCBkeW5hbWljIGJlaGF2aW9yIHBhdXNlZC5cbiAgICAgKi9cbiAgICByZWxvYWQ6IHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiAoZG9QYXVzZSkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlmIChkb1BhdXNlKSB7IHRoaXMucGF1c2UoKTsgfVxuICAgICAgICB0aGlzLmlubmVySFRNTCA9IHRoaXMub3JpZ2luYWxIVE1MO1xuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICAgICAgQU5vZGUucHJvdG90eXBlLmxvYWQuY2FsbCh0aGlzLCBwbGF5KTtcbiAgICAgICAgZnVuY3Rpb24gcGxheSAoKSB7XG4gICAgICAgICAgaWYgKCFzZWxmLmlzUGxheWluZykgeyByZXR1cm47IH1cbiAgICAgICAgICBBRW50aXR5LnByb3RvdHlwZS5wbGF5LmNhbGwoc2VsZik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIHJlbmRlciBsb29wLlxuICAgICAqXG4gICAgICogVXBkYXRlcyBhbmltYXRpb25zLlxuICAgICAqIFVwZGF0ZXMgYmVoYXZpb3JzLlxuICAgICAqIFJlbmRlcnMgd2l0aCByZXF1ZXN0IGFuaW1hdGlvbiBmcmFtZS5cbiAgICAgKi9cbiAgICByZW5kZXI6IHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiAodGltZSkge1xuICAgICAgICB2YXIgY2FtZXJhID0gdGhpcy5jYW1lcmE7XG4gICAgICAgIHZhciB0aW1lRGVsdGEgPSB0aW1lIC0gdGhpcy50aW1lO1xuICAgICAgICB2YXIgc3lzdGVtcyA9IHRoaXMuc3lzdGVtcztcblxuICAgICAgICBpZiAodGhpcy5pc1BsYXlpbmcpIHtcbiAgICAgICAgICBUV0VFTi51cGRhdGUodGltZSk7XG4gICAgICAgICAgdGhpcy5iZWhhdmlvcnMuZm9yRWFjaChmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICAgICAgICBpZiAoIWNvbXBvbmVudC5lbC5pc1BsYXlpbmcpIHsgcmV0dXJuOyB9XG4gICAgICAgICAgICBjb21wb25lbnQudGljayh0aW1lLCB0aW1lRGVsdGEpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIE9iamVjdC5rZXlzKHN5c3RlbXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgaWYgKCFzeXN0ZW1zW2tleV0udGljaykgeyByZXR1cm47IH1cbiAgICAgICAgICAgIHN5c3RlbXNba2V5XS50aWNrKHRpbWUsIHRpbWVEZWx0YSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbmRlcih0aGlzLm9iamVjdDNELCBjYW1lcmEpO1xuXG4gICAgICAgIHRoaXMudGltZSA9IHRpbWU7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uRnJhbWVJRCA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5yZW5kZXIuYmluZCh0aGlzKSk7XG4gICAgICB9LFxuICAgICAgd3JpdGFibGU6IHdpbmRvdy5kZWJ1Z1xuICAgIH1cbiAgfSlcbn0pO1xuXG5mdW5jdGlvbiBnZXRDYW52YXNTaXplIChjYW52YXMpIHtcbiAgaWYgKGlzTW9iaWxlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhlaWdodDogd2luZG93LmlubmVySGVpZ2h0LFxuICAgICAgd2lkdGg6IHdpbmRvdy5pbm5lcldpZHRoXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGhlaWdodDogY2FudmFzLm9mZnNldEhlaWdodCxcbiAgICB3aWR0aDogY2FudmFzLm9mZnNldFdpZHRoXG4gIH07XG59XG5cbi8qKlxuICogTWFudWFsbHkgaGFuZGxlcyBmdWxsc2NyZWVuIGZvciBub24tVlIgbW9iaWxlIHdoZXJlIHRoZSByZW5kZXJlcicgVlJcbiAqIGRpc3BsYXkgaXMgbm90IHBvbHlmaWxsZWQuXG4gKlxuICogRGVza3RvcCBqdXN0IHdvcmtzIHNvIHVzZSB0aGUgcmVuZGVyZXIuc2V0RnVsbFNjcmVlbiBpbiB0aGF0IGNhc2UuXG4gKi9cbmZ1bmN0aW9uIHNldEZ1bGxzY3JlZW4gKGNhbnZhcykge1xuICBpZiAoY2FudmFzLnJlcXVlc3RGdWxsc2NyZWVuKSB7XG4gICAgY2FudmFzLnJlcXVlc3RGdWxsc2NyZWVuKCk7XG4gIH0gZWxzZSBpZiAoY2FudmFzLm1velJlcXVlc3RGdWxsU2NyZWVuKSB7XG4gICAgY2FudmFzLm1velJlcXVlc3RGdWxsU2NyZWVuKCk7XG4gIH0gZWxzZSBpZiAoY2FudmFzLndlYmtpdFJlcXVlc3RGdWxsc2NyZWVuKSB7XG4gICAgY2FudmFzLndlYmtpdFJlcXVlc3RGdWxsc2NyZWVuKCk7XG4gIH1cbn1cblxufSx7XCIuLi8uLi9saWIvdGhyZWVcIjo5MCxcIi4uLy4uL3V0aWxzL1wiOjEwMixcIi4uL2EtZW50aXR5XCI6NTIsXCIuLi9hLW5vZGVcIjo1NCxcIi4uL2EtcmVnaXN0ZXItZWxlbWVudFwiOjU1LFwiLi4vc3lzdGVtXCI6NjQsXCIuL2Z1bGxzY3JlZW5cIjo1OSxcIi4vbWV0YVRhZ3NcIjo2MCxcIi4vd2FrZWxvY2tcIjo2MSxcInR3ZWVuLmpzXCI6MjJ9XSw1OTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgaXNJZnJhbWVkID0gX2RlcmVxXygnLi4vLi4vdXRpbHMvJykuaXNJZnJhbWVkO1xuXG4vKipcbiAqIFJlZ2lzdGVyIGZ1bGxzY3JlZW4gbGlzdGVuZXIgdG8gc2NlbmUuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5pdEZ1bGxzY3JlZW5MaXN0ZW5lciAoc2NlbmUpIHtcbiAgdmFyIGhhbmRsZXIgPSBmdWxsc2NyZWVuQ2hhbmdlSGFuZGxlci5iaW5kKHNjZW5lKTtcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW96ZnVsbHNjcmVlbmNoYW5nZScsIGhhbmRsZXIpO1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd3ZWJraXRmdWxsc2NyZWVuY2hhbmdlJywgaGFuZGxlcik7XG5cbiAgLy8gSGFuZGxlcyBmdWxsc2NyZWVuIGJlaGF2aW9yIHdoZW4gaW5zaWRlIGFuIGlmcmFtZS5cbiAgaWYgKCFpc0lmcmFtZWQoKSkgeyByZXR1cm47IH1cbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBpZnJhbWVkRnVsbHNjcmVlbkNoYW5nZUhhbmRsZXIuYmluZChzY2VuZSkpO1xufTtcblxuZnVuY3Rpb24gZnVsbHNjcmVlbkNoYW5nZUhhbmRsZXIgKGV2ZW50KSB7XG4gIHZhciBmdWxsc2NyZWVuRWxlbWVudCA9IGRvY3VtZW50LmZ1bGxzY3JlZW5FbGVtZW50IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50Lm1vekZ1bGxTY3JlZW5FbGVtZW50IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LndlYmtpdEZ1bGxzY3JlZW5FbGVtZW50O1xuICB2YXIgc2NlbmUgPSB0aGlzO1xuXG4gIC8vIExvY2sgdG8gbGFuZHNjYXBlIG9yaWVudGF0aW9uIG9uIG1vYmlsZS5cbiAgaWYgKHNjZW5lLmlzTW9iaWxlICYmIHdpbmRvdy5zY3JlZW4ub3JpZW50YXRpb24pIHtcbiAgICBpZiAoZnVsbHNjcmVlbkVsZW1lbnQpIHtcbiAgICAgIHdpbmRvdy5zY3JlZW4ub3JpZW50YXRpb24ubG9jaygnbGFuZHNjYXBlJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpbmRvdy5zY3JlZW4ub3JpZW50YXRpb24udW5sb2NrKCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGZ1bGxzY3JlZW5FbGVtZW50KSB7XG4gICAgZW50ZXJGdWxsc2NyZWVuSGFuZGxlcihzY2VuZSk7XG4gIH0gZWxzZSB7XG4gICAgZXhpdEZ1bGxzY3JlZW5IYW5kbGVyKHNjZW5lKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpZnJhbWVkRnVsbHNjcmVlbkNoYW5nZUhhbmRsZXIgKGV2ZW50KSB7XG4gIHZhciBzY2VuZSA9IHRoaXM7XG4gIGlmICghZXZlbnQuZGF0YSkgeyByZXR1cm47IH1cblxuICBzd2l0Y2ggKGV2ZW50LmRhdGEudHlwZSkge1xuICAgIGNhc2UgJ2Z1bGxzY3JlZW4nOiB7XG4gICAgICBzd2l0Y2ggKGV2ZW50LmRhdGEuZGF0YSkge1xuICAgICAgICBjYXNlICdlbnRlcic6XG4gICAgICAgICAgZW50ZXJGdWxsc2NyZWVuSGFuZGxlcihzY2VuZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2V4aXQnOlxuICAgICAgICAgIGV4aXRGdWxsc2NyZWVuSGFuZGxlcihzY2VuZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGVudGVyRnVsbHNjcmVlbkhhbmRsZXIgKHNjZW5lKSB7XG4gIHNjZW5lLmFkZFN0YXRlKCdmdWxsc2NyZWVuJyk7XG4gIHNjZW5lLmVtaXQoJ2Z1bGxzY3JlZW4tZW50ZXInKTtcbn1cblxuZnVuY3Rpb24gZXhpdEZ1bGxzY3JlZW5IYW5kbGVyIChzY2VuZSkge1xuICBzY2VuZS5yZW1vdmVTdGF0ZSgnZnVsbHNjcmVlbicpO1xuICBzY2VuZS5lbWl0KCdmdWxsc2NyZWVuLWV4aXQnKTtcbn1cblxufSx7XCIuLi8uLi91dGlscy9cIjoxMDJ9XSw2MDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgZXh0ZW5kID0gX2RlcmVxXygnLi4vLi4vdXRpbHMnKS5leHRlbmQ7XG5cbnZhciBNT0JJTEVfSEVBRF9UQUdTID0gbW9kdWxlLmV4cG9ydHMuTU9CSUxFX0hFQURfVEFHUyA9IFtcbiAgTWV0YSh7bmFtZTogJ3ZpZXdwb3J0JywgY29udGVudDogJ3dpZHRoPWRldmljZS13aWR0aCxpbml0aWFsLXNjYWxlPTEsbWF4aW11bS1zY2FsZT0xLHNocmluay10by1maXQ9bm8sdXNlci1zY2FsYWJsZT1ubyxtaW5pbWFsLXVpJ30pLFxuXG4gIC8vIFczQy1zdGFuZGFyZGlzZWQgbWV0YSB0YWdzLlxuICBNZXRhKHtuYW1lOiAnbW9iaWxlLXdlYi1hcHAtY2FwYWJsZScsIGNvbnRlbnQ6ICd5ZXMnfSksXG4gIE1ldGEoe25hbWU6ICd0aGVtZS1jb2xvcicsIGNvbnRlbnQ6ICdibGFjayd9KSxcbiAgTGluayh7cmVsOiAnaWNvbicsIHNpemVzOiAnMTkyeDE5MicsIGhyZWY6ICdodHRwczovL2FmcmFtZS5pby9pbWFnZXMvYWZyYW1lLWxvZ28tMTkyLnBuZyd9KVxuXTtcblxudmFyIE1PQklMRV9JT1NfSEVBRF9UQUdTID0gW1xuICAvLyBpT1Mtc3BlY2lmaWMgbWV0YSB0YWdzIGZvciBmdWxsc2NyZWVuIHdoZW4gcGlubmluZyB0byBob21lc2NyZWVuLlxuICBNZXRhKHtuYW1lOiAnYXBwbGUtbW9iaWxlLXdlYi1hcHAtY2FwYWJsZScsIGNvbnRlbnQ6ICd5ZXMnfSksXG4gIE1ldGEoe25hbWU6ICdhcHBsZS1tb2JpbGUtd2ViLWFwcC1zdGF0dXMtYmFyLXN0eWxlJywgY29udGVudDogJ2JsYWNrJ30pLFxuICBMaW5rKHtyZWw6ICdhcHBsZS10b3VjaC1pY29uJywgaHJlZjogJ2h0dHBzOi8vYWZyYW1lLmlvL2ltYWdlcy9hZnJhbWUtbG9nby0xNTIucG5nJ30pXG5dO1xuXG5mdW5jdGlvbiBNZXRhIChhdHRycykge1xuICByZXR1cm4ge1xuICAgIHRhZ05hbWU6ICdtZXRhJyxcbiAgICBhdHRyaWJ1dGVzOiBhdHRycyxcbiAgICBleGlzdHM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ21ldGFbbmFtZT1cIicgKyBhdHRycy5uYW1lICsgJ1wiXScpOyB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIExpbmsgKGF0dHJzKSB7XG4gIHJldHVybiB7XG4gICAgdGFnTmFtZTogJ2xpbmsnLFxuICAgIGF0dHJpYnV0ZXM6IGF0dHJzLFxuICAgIGV4aXN0czogZnVuY3Rpb24gKCkgeyByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignbGlua1tyZWw9XCInICsgYXR0cnMucmVsICsgJ1wiXScpOyB9XG4gIH07XG59XG5cbi8qKlxuICogSW5qZWN0cyB0aGUgbmVjZXNzYXJ5IG1ldGF0YWdzIGluIHRoZSBkb2N1bWVudCBmb3IgbW9iaWxlIHN1cHBvcnQ6XG4gKiAxLiBQcmV2ZW50IHRoZSB1c2VyIHRvIHpvb20gaW4gdGhlIGRvY3VtZW50LlxuICogMi4gRW5zdXJlIHRoYXQgd2luZG93LmlubmVyV2lkdGggYW5kIHdpbmRvdy5pbm5lckhlaWdodCBoYXZlIHRoZSBjb3JyZWN0XG4gKiAgICB2YWx1ZXMgYW5kIHRoZSBjYW52YXMgaXMgcHJvcGVybHkgc2NhbGVkLlxuICogMy4gVG8gYWxsb3cgZnVsbHNjcmVlbiBtb2RlIHdoZW4gcGlubmluZyBhIHdlYiBhcHAgb24gdGhlIGhvbWUgc2NyZWVuIG9uXG4gKiAgICBpT1MuXG4gKiBBZGFwdGVkIGZyb20gaHR0cHM6Ly93d3cucmVkZGl0LmNvbS9yL3dlYl9kZXNpZ24vY29tbWVudHMvM2xhMDRwL1xuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBzY2VuZSAtIFNjZW5lIGVsZW1lbnRcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xubW9kdWxlLmV4cG9ydHMuaW5qZWN0ID0gZnVuY3Rpb24gaW5qZWN0SGVhZFRhZ3MgKHNjZW5lKSB7XG4gIHZhciBoZWFkRWwgPSBkb2N1bWVudC5oZWFkO1xuICB2YXIgaGVhZFNjcmlwdEVsID0gaGVhZEVsLnF1ZXJ5U2VsZWN0b3IoJ3NjcmlwdCcpO1xuICB2YXIgdGFnO1xuICB2YXIgaGVhZFRhZ3MgPSBbXTtcbiAgTU9CSUxFX0hFQURfVEFHUy5mb3JFYWNoKGNyZWF0ZUFuZEluamVjdFRhZyk7XG4gIGlmIChzY2VuZS5pc0lPUykge1xuICAgIE1PQklMRV9JT1NfSEVBRF9UQUdTLmZvckVhY2goY3JlYXRlQW5kSW5qZWN0VGFnKTtcbiAgfVxuICByZXR1cm4gaGVhZFRhZ3M7XG5cbiAgZnVuY3Rpb24gY3JlYXRlQW5kSW5qZWN0VGFnICh0YWdPYmopIHtcbiAgICBpZiAoIXRhZ09iaiB8fCB0YWdPYmouZXhpc3RzKCkpIHsgcmV0dXJuOyB9XG5cbiAgICB0YWcgPSBjcmVhdGVUYWcodGFnT2JqKTtcbiAgICBpZiAoIXRhZykgeyByZXR1cm47IH1cblxuICAgIGlmIChoZWFkU2NyaXB0RWwpIHtcbiAgICAgIGhlYWRTY3JpcHRFbC5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0YWcsIGhlYWRTY3JpcHRFbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhlYWRFbC5hcHBlbmRDaGlsZCh0YWcpO1xuICAgIH1cblxuICAgIGhlYWRUYWdzLnB1c2godGFnKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gY3JlYXRlVGFnICh0YWdPYmopIHtcbiAgaWYgKCF0YWdPYmogfHwgIXRhZ09iai50YWdOYW1lKSB7IHJldHVybjsgfVxuICB2YXIgbWV0YSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnT2JqLnRhZ05hbWUpO1xuICByZXR1cm4gZXh0ZW5kKG1ldGEsIHRhZ09iai5hdHRyaWJ1dGVzKTtcbn1cblxufSx7XCIuLi8uLi91dGlsc1wiOjEwMn1dLDYxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBXYWtlbG9jayA9IF9kZXJlcV8oJy4uLy4uLy4uL3ZlbmRvci93YWtlbG9jay93YWtlbG9jaycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaXRXYWtlbG9jayAoc2NlbmUpIHtcbiAgaWYgKCFzY2VuZS5pc01vYmlsZSkgeyByZXR1cm47IH1cblxuICB2YXIgd2FrZWxvY2sgPSBzY2VuZS53YWtlbG9jayA9IG5ldyBXYWtlbG9jaygpO1xuICBzY2VuZS5hZGRFdmVudExpc3RlbmVyKCdlbnRlci12cicsIGZ1bmN0aW9uICgpIHsgd2FrZWxvY2sucmVxdWVzdCgpOyB9KTtcbiAgc2NlbmUuYWRkRXZlbnRMaXN0ZW5lcignZXhpdC12cicsIGZ1bmN0aW9uICgpIHsgd2FrZWxvY2sucmVsZWFzZSgpOyB9KTtcbn07XG5cbn0se1wiLi4vLi4vLi4vdmVuZG9yL3dha2Vsb2NrL3dha2Vsb2NrXCI6MTA5fV0sNjI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIGRlYnVnID0gX2RlcmVxXygnLi4vdXRpbHMvZGVidWcnKTtcbnZhciBwcm9wZXJ0eVR5cGVzID0gX2RlcmVxXygnLi9wcm9wZXJ0eVR5cGVzJykucHJvcGVydHlUeXBlcztcbnZhciB3YXJuID0gZGVidWcoJ2NvcmU6c2NoZW1hOndhcm4nKTtcblxuLyoqXG4gKiBBIHNjaGVtYSBpcyBjbGFzc2lmaWVkIGFzIGEgc2NoZW1hIGZvciBhIHNpbmdsZSBwcm9wZXJ0eSBpZjpcbiAqIC0gYHR5cGVgIGlzIGRlZmluZWQgb24gdGhlIHNjaGVtYSBhcyBhIHN0cmluZy5cbiAqIC0gT1IgYGRlZmF1bHRgIGlzIGRlZmluZWQgb24gdGhlIHNjaGVtYSwgYXMgYSByZXNlcnZlZCBrZXl3b3JkLlxuICogLSBPUiBzY2hlbWEgaXMgZW1wdHkuXG4gKi9cbmZ1bmN0aW9uIGlzU2luZ2xlUHJvcGVydHkgKHNjaGVtYSkge1xuICBpZiAoJ3R5cGUnIGluIHNjaGVtYSkge1xuICAgIHJldHVybiB0eXBlb2Ygc2NoZW1hLnR5cGUgPT09ICdzdHJpbmcnO1xuICB9XG4gIHJldHVybiAnZGVmYXVsdCcgaW4gc2NoZW1hO1xufVxubW9kdWxlLmV4cG9ydHMuaXNTaW5nbGVQcm9wZXJ0eSA9IGlzU2luZ2xlUHJvcGVydHk7XG5cbi8qKlxuICogQnVpbGQgc3RlcCB0byBzY2hlbWEgdG8gdXNlIGB0eXBlYCB0byBpbmplY3QgZGVmYXVsdCB2YWx1ZSwgcGFyc2VyLCBhbmQgc3RyaW5naWZpZXIuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHNjaGVtYVxuICogQHJldHVybnMge29iamVjdH0gU2NoZW1hLlxuICovXG5tb2R1bGUuZXhwb3J0cy5wcm9jZXNzID0gZnVuY3Rpb24gKHNjaGVtYSkge1xuICAvLyBGb3Igc2luZ2xlIHByb3BlcnR5IHNjaGVtYSwgcnVuIHByb2Nlc3NQcm9wRGVmaW5pdGlvbiBvdmVyIHRoZSB3aG9sZSBzY2hlbWEuXG4gIGlmIChpc1NpbmdsZVByb3BlcnR5KHNjaGVtYSkpIHtcbiAgICByZXR1cm4gcHJvY2Vzc1Byb3BlcnR5RGVmaW5pdGlvbihzY2hlbWEpO1xuICB9XG5cbiAgLy8gRm9yIG11bHRpLXByb3BlcnR5IHNjaGVtYSwgcnVuIHByb2Nlc3NQcm9wRGVmaW5pdGlvbiBvdmVyIGVhY2ggcHJvcGVydHkgZGVmaW5pdGlvbi5cbiAgT2JqZWN0LmtleXMoc2NoZW1hKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wTmFtZSkge1xuICAgIHNjaGVtYVtwcm9wTmFtZV0gPSBwcm9jZXNzUHJvcGVydHlEZWZpbml0aW9uKHNjaGVtYVtwcm9wTmFtZV0pO1xuICB9KTtcbiAgcmV0dXJuIHNjaGVtYTtcbn07XG5cbi8qKlxuICogSW5qZWN0IGRlZmF1bHQgdmFsdWUsIHBhcnNlciwgc3RyaW5naWZpZXIgZm9yIHNpbmdsZSBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gcHJvY2Vzc1Byb3BlcnR5RGVmaW5pdGlvbiAocHJvcERlZmluaXRpb24pIHtcbiAgdmFyIGRlZmF1bHRWYWwgPSBwcm9wRGVmaW5pdGlvbi5kZWZhdWx0O1xuICB2YXIgcHJvcFR5cGU7XG4gIHZhciB0eXBlTmFtZSA9IHByb3BEZWZpbml0aW9uLnR5cGU7XG5cbiAgLy8gVHlwZSBpbmZlcmVuY2UuXG4gIGlmICghcHJvcERlZmluaXRpb24udHlwZSkge1xuICAgIGlmIChkZWZhdWx0VmFsICE9PSB1bmRlZmluZWQgJiYgWydib29sZWFuJywgJ251bWJlciddLmluZGV4T2YodHlwZW9mIGRlZmF1bHRWYWwpICE9PSAtMSkge1xuICAgICAgLy8gVHlwZSBpbmZlcmVuY2UuXG4gICAgICB0eXBlTmFtZSA9IHR5cGVvZiBkZWZhdWx0VmFsO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShkZWZhdWx0VmFsKSkge1xuICAgICAgdHlwZU5hbWUgPSAnYXJyYXknO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGYWxsIGJhY2sgdG8gc3RyaW5nLlxuICAgICAgdHlwZU5hbWUgPSAnc3RyaW5nJztcbiAgICB9XG4gIH0gZWxzZSBpZiAocHJvcERlZmluaXRpb24udHlwZSA9PT0gJ2Jvb2wnKSB7XG4gICAgdHlwZU5hbWUgPSAnYm9vbGVhbic7XG4gIH0gZWxzZSBpZiAocHJvcERlZmluaXRpb24udHlwZSA9PT0gJ2Zsb2F0Jykge1xuICAgIHR5cGVOYW1lID0gJ251bWJlcic7XG4gIH1cblxuICBwcm9wVHlwZSA9IHByb3BlcnR5VHlwZXNbdHlwZU5hbWVdO1xuICBpZiAoIXByb3BUeXBlKSB7XG4gICAgd2FybignVW5rbm93biBwcm9wZXJ0eSB0eXBlOiAnICsgdHlwZU5hbWUpO1xuICB9XG5cbiAgLy8gRmlsbCBpbiBwYXJzZSBhbmQgc3RyaW5naWZ5IHVzaW5nIHByb3BlcnR5IHR5cGVzLlxuICBwcm9wRGVmaW5pdGlvbi5wYXJzZSA9IHByb3BEZWZpbml0aW9uLnBhcnNlIHx8IHByb3BUeXBlLnBhcnNlO1xuICBwcm9wRGVmaW5pdGlvbi5zdHJpbmdpZnkgPSBwcm9wRGVmaW5pdGlvbi5zdHJpbmdpZnkgfHwgcHJvcFR5cGUuc3RyaW5naWZ5O1xuXG4gIC8vIEZpbGwgaW4gdHlwZSBuYW1lLlxuICBwcm9wRGVmaW5pdGlvbi50eXBlID0gdHlwZU5hbWU7XG5cbiAgLy8gRmlsbCBpbiBkZWZhdWx0IHZhbHVlLlxuICBpZiAoISgnZGVmYXVsdCcgaW4gcHJvcERlZmluaXRpb24pKSB7XG4gICAgcHJvcERlZmluaXRpb24uZGVmYXVsdCA9IHByb3BUeXBlLmRlZmF1bHQ7XG4gIH1cblxuICByZXR1cm4gcHJvcERlZmluaXRpb247XG59XG5tb2R1bGUuZXhwb3J0cy5wcm9jZXNzUHJvcGVydHlEZWZpbml0aW9uID0gcHJvY2Vzc1Byb3BlcnR5RGVmaW5pdGlvbjtcblxuLyoqXG4gKiBQYXJzZSBwcm9wRGF0YSB1c2luZyBzY2hlbWEuIFVzZSBkZWZhdWx0IHZhbHVlcyBpZiBub3QgZXhpc3RpbmcgaW4gcHJvcERhdGEuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHByb3BEYXRhIC0gVW5wYXJzZWQgcHJvcGVydGllcy5cbiAqIEBwYXJhbSB7b2JqZWN0fSBzY2hlbWEgLSBQcm9wZXJ0eSB0eXBlcyBkZWZpbml0aW9uLlxuICogQHBhcmFtIHtib29sZWFufSBnZXRQYXJ0aWFsRGF0YSAtIFdoZXRoZXIgdG8gcmV0dXJuIGZ1bGwgY29tcG9uZW50IGRhdGEgb3IganVzdCB0aGUgZGF0YVxuICogICAgICAgIHdpdGgga2V5cyBpbiBgcHJvcERhdGFgLlxuICogQHBhcmFtIHtib29sZWFufSBzaWxlbnQgLSBTdXBwcmVzcyB3YXJuaW5nIG1lc3NhZ2VzLlxuICovXG5tb2R1bGUuZXhwb3J0cy5wYXJzZVByb3BlcnRpZXMgPSBmdW5jdGlvbiAocHJvcERhdGEsIHNjaGVtYSwgZ2V0UGFydGlhbERhdGEsIHNpbGVudCkge1xuICB2YXIgcHJvcE5hbWVzID0gT2JqZWN0LmtleXMoZ2V0UGFydGlhbERhdGEgPyBwcm9wRGF0YSA6IHNjaGVtYSk7XG5cbiAgaWYgKHByb3BEYXRhID09PSBudWxsIHx8IHR5cGVvZiBwcm9wRGF0YSAhPT0gJ29iamVjdCcpIHsgcmV0dXJuIHByb3BEYXRhOyB9XG5cbiAgLy8gVmFsaWRhdGlvbiBlcnJvcnMuXG4gIE9iamVjdC5rZXlzKHByb3BEYXRhKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wTmFtZSkge1xuICAgIGlmICghc2NoZW1hW3Byb3BOYW1lXSAmJiAhc2lsZW50KSB7XG4gICAgICB3YXJuKCdVbmtub3duIGNvbXBvbmVudCBwcm9wZXJ0eTogJyArIHByb3BOYW1lKTtcbiAgICB9XG4gIH0pO1xuXG4gIHByb3BOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIHBhcnNlIChwcm9wTmFtZSkge1xuICAgIHZhciBwcm9wRGVmaW5pdGlvbiA9IHNjaGVtYVtwcm9wTmFtZV07XG4gICAgdmFyIHByb3BWYWx1ZSA9IHByb3BEYXRhW3Byb3BOYW1lXTtcblxuICAgIGlmICghKHNjaGVtYVtwcm9wTmFtZV0pKSB7IHJldHVybjsgfVxuXG4gICAgcHJvcFZhbHVlID0gcHJvcFZhbHVlID09PSB1bmRlZmluZWQgPyBwcm9wRGVmaW5pdGlvbi5kZWZhdWx0IDogcHJvcFZhbHVlO1xuICAgIHByb3BEYXRhW3Byb3BOYW1lXSA9IHBhcnNlUHJvcGVydHkocHJvcFZhbHVlLCBwcm9wRGVmaW5pdGlvbik7XG4gIH0pO1xuXG4gIHJldHVybiBwcm9wRGF0YTtcbn07XG5cbi8qKlxuICogRGVzZXJpYWxpemUgYSBzaW5nbGUgcHJvcGVydHkuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlUHJvcGVydHkgKHZhbHVlLCBwcm9wRGVmaW5pdGlvbikge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykgeyByZXR1cm4gdmFsdWU7IH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuIHZhbHVlOyB9XG4gIHJldHVybiBwcm9wRGVmaW5pdGlvbi5wYXJzZSh2YWx1ZSk7XG59XG5tb2R1bGUuZXhwb3J0cy5wYXJzZVByb3BlcnR5ID0gcGFyc2VQcm9wZXJ0eTtcblxuLyoqXG4gKiBTZXJpYWxpemUgYSBncm91cCBvZiBwcm9wZXJ0aWVzLlxuICovXG5tb2R1bGUuZXhwb3J0cy5zdHJpbmdpZnlQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKHByb3BEYXRhLCBzY2hlbWEpIHtcbiAgdmFyIHN0cmluZ2lmaWVkRGF0YSA9IHt9O1xuICBPYmplY3Qua2V5cyhwcm9wRGF0YSkuZm9yRWFjaChmdW5jdGlvbiAocHJvcE5hbWUpIHtcbiAgICB2YXIgcHJvcERlZmluaXRpb24gPSBzY2hlbWFbcHJvcE5hbWVdO1xuICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wRGF0YVtwcm9wTmFtZV07XG4gICAgdmFyIHZhbHVlID0gcHJvcFZhbHVlO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YWx1ZSA9IHN0cmluZ2lmeVByb3BlcnR5KHByb3BWYWx1ZSwgcHJvcERlZmluaXRpb24pO1xuICAgICAgaWYgKCFwcm9wRGVmaW5pdGlvbikgeyB3YXJuKCdVbmtub3duIGNvbXBvbmVudCBwcm9wZXJ0eTogJyArIHByb3BOYW1lKTsgfVxuICAgIH1cbiAgICBzdHJpbmdpZmllZERhdGFbcHJvcE5hbWVdID0gdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gc3RyaW5naWZpZWREYXRhO1xufTtcblxuLyoqXG4gKiBTZXJpYWxpemUgYSBzaW5nbGUgcHJvcGVydHkuXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ2lmeVByb3BlcnR5ICh2YWx1ZSwgcHJvcERlZmluaXRpb24pIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHsgcmV0dXJuIHZhbHVlOyB9XG4gIC8vIGlmIHRoZXJlJ3Mgbm8gc2NoZW1hIGZvciB0aGUgcHJvcGVydHkgd2UgdXNlIHN0YW5kYXIgSlNPTiBzdHJpbmdpZnlcbiAgaWYgKCFwcm9wRGVmaW5pdGlvbikgeyByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpOyB9XG4gIHJldHVybiBwcm9wRGVmaW5pdGlvbi5zdHJpbmdpZnkodmFsdWUpO1xufVxubW9kdWxlLmV4cG9ydHMuc3RyaW5naWZ5UHJvcGVydHkgPSBzdHJpbmdpZnlQcm9wZXJ0eTtcblxufSx7XCIuLi91dGlscy9kZWJ1Z1wiOjEwMSxcIi4vcHJvcGVydHlUeXBlc1wiOjU3fV0sNjM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIHNjaGVtYSA9IF9kZXJlcV8oJy4vc2NoZW1hJyk7XG5cbnZhciBwcm9jZXNzU2NoZW1hID0gc2NoZW1hLnByb2Nlc3M7XG52YXIgc2hhZGVycyA9IG1vZHVsZS5leHBvcnRzLnNoYWRlcnMgPSB7fTsgIC8vIEtlZXAgdHJhY2sgb2YgcmVnaXN0ZXJlZCBzaGFkZXJzLlxudmFyIHNoYWRlck5hbWVzID0gbW9kdWxlLmV4cG9ydHMuc2hhZGVyTmFtZXMgPSBbXTsgIC8vIEtlZXAgdHJhY2sgb2YgdGhlIG5hbWVzIG9mIHJlZ2lzdGVyZWQgc2hhZGVycy5cbnZhciBUSFJFRSA9IF9kZXJlcV8oJy4uL2xpYi90aHJlZScpO1xuXG52YXIgcHJvcGVydHlUb1RocmVlTWFwcGluZyA9IHtcbiAgbnVtYmVyOiAnZicsXG4gIHRpbWU6ICdmJyxcbiAgdmVjNDogJ3Y0JyxcbiAgdmVjMzogJ3YzJyxcbiAgdmVjMjogJ3YyJyxcbiAgY29sb3I6ICd2Mydcbn07XG5cbi8qKlxuICogU2hhZGVyIGNsYXNzIGRlZmluaXRpb24uXG4gKlxuICogU2hhZGVycyBleHRlbmQgdGhlIG1hdGVyaWFsIGNvbXBvbmVudCBBUEkgc28geW91IGNhbiBjcmVhdGUgeW91ciBvd24gbGlicmFyeVxuICogb2YgY3VzdG9taXplZCBtYXRlcmlhbHNcbiAqXG4gKi9cbnZhciBTaGFkZXIgPSBtb2R1bGUuZXhwb3J0cy5TaGFkZXIgPSBmdW5jdGlvbiAoKSB7fTtcblxuU2hhZGVyLnByb3RvdHlwZSA9IHtcbiAgLyoqXG4gICAqIENvbnRhaW5zIHRoZSB0eXBlIHNjaGVtYSBhbmQgZGVmYXVsdHMgZm9yIHRoZSBkYXRhIHZhbHVlcy5cbiAgICogRGF0YSBpcyBjb2VyY2VkIGludG8gdGhlIHR5cGVzIG9mIHRoZSB2YWx1ZXMgb2YgdGhlIGRlZmF1bHRzLlxuICAgKi9cbiAgc2NoZW1hOiB7IH0sXG5cbiAgdmVydGV4U2hhZGVyOlxuICAgICd2b2lkIG1haW4oKSB7JyArXG4gICAgICAnZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wKTsnICtcbiAgICAnfScsXG5cbiAgZnJhZ21lbnRTaGFkZXI6XG4gICAgJ3ZvaWQgbWFpbigpIHsnICtcbiAgICAgICdnbF9GcmFnQ29sb3IgPSB2ZWM0KDEuMCwwLjAsMS4wLDEuMCk7JyArXG4gICAgJ30nLFxuXG4gIC8qKlxuICAgKiBJbml0IGhhbmRsZXIuIFNpbWlsYXIgdG8gYXR0YWNoZWRDYWxsYmFjay5cbiAgICogQ2FsbGVkIGR1cmluZyBzaGFkZXIgaW5pdGlhbGl6YXRpb24gYW5kIGlzIG9ubHkgcnVuIG9uY2UuXG4gICAqL1xuICBpbml0OiBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHRoaXMuYXR0cmlidXRlcyA9IHRoaXMuaW5pdFZhcmlhYmxlcyhkYXRhLCAnYXR0cmlidXRlJyk7XG4gICAgdGhpcy51bmlmb3JtcyA9IHRoaXMuaW5pdFZhcmlhYmxlcyhkYXRhLCAndW5pZm9ybScpO1xuICAgIHRoaXMubWF0ZXJpYWwgPSBuZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwoe1xuICAgICAgLy8gYXR0cmlidXRlczogdGhpcy5hdHRyaWJ1dGVzLFxuICAgICAgdW5pZm9ybXM6IHRoaXMudW5pZm9ybXMsXG4gICAgICB2ZXJ0ZXhTaGFkZXI6IHRoaXMudmVydGV4U2hhZGVyLFxuICAgICAgZnJhZ21lbnRTaGFkZXI6IHRoaXMuZnJhZ21lbnRTaGFkZXJcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5tYXRlcmlhbDtcbiAgfSxcblxuICBpbml0VmFyaWFibGVzOiBmdW5jdGlvbiAoZGF0YSwgdHlwZSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgdmFyaWFibGVzID0ge307XG4gICAgdmFyIHNjaGVtYSA9IHRoaXMuc2NoZW1hO1xuICAgIHZhciBzcXVlbWFLZXlzID0gT2JqZWN0LmtleXMoc2NoZW1hKTtcbiAgICBzcXVlbWFLZXlzLmZvckVhY2gocHJvY2Vzc1NxdWVtYSk7XG4gICAgZnVuY3Rpb24gcHJvY2Vzc1NxdWVtYSAoa2V5KSB7XG4gICAgICBpZiAoc2NoZW1hW2tleV0uaXMgIT09IHR5cGUpIHsgcmV0dXJuOyB9XG4gICAgICB2YXIgdmFyVHlwZSA9IHByb3BlcnR5VG9UaHJlZU1hcHBpbmdbc2NoZW1hW2tleV0udHlwZV07XG4gICAgICB2YXIgdmFyVmFsdWUgPSBzY2hlbWFba2V5XS5wYXJzZShkYXRhW2tleV0gfHwgc2NoZW1hW2tleV0uZGVmYXVsdCk7XG4gICAgICB2YXJpYWJsZXNba2V5XSA9IHtcbiAgICAgICAgdHlwZTogdmFyVHlwZSxcbiAgICAgICAgdmFsdWU6IHNlbGYucGFyc2VWYWx1ZShzY2hlbWFba2V5XS50eXBlLCB2YXJWYWx1ZSlcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB2YXJpYWJsZXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBoYW5kbGVyLiBTaW1pbGFyIHRvIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjay5cbiAgICogQ2FsbGVkIHdoZW5ldmVyIHRoZSBhc3NvY2lhdGVkIG1hdGVyaWFsIGRhdGEgY2hhbmdlcy5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGRhdGEgLSBOZXcgbWF0ZXJpYWwgZGF0YS5cbiAgICovXG4gIHVwZGF0ZTogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB0aGlzLnVwZGF0ZVZhcmlhYmxlcyhkYXRhLCAnYXR0cmlidXRlJyk7XG4gICAgdGhpcy51cGRhdGVWYXJpYWJsZXMoZGF0YSwgJ3VuaWZvcm0nKTtcbiAgfSxcblxuICB1cGRhdGVWYXJpYWJsZXM6IGZ1bmN0aW9uIChkYXRhLCB0eXBlKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciB2YXJpYWJsZXMgPSB0eXBlID09PSAndW5pZm9ybScgPyB0aGlzLnVuaWZvcm1zIDogdGhpcy5hdHRyaWJ1dGVzO1xuICAgIHZhciBkYXRhS2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICAgIHZhciBzY2hlbWEgPSB0aGlzLnNjaGVtYTtcbiAgICBkYXRhS2V5cy5mb3JFYWNoKHByb2Nlc3NEYXRhKTtcbiAgICBmdW5jdGlvbiBwcm9jZXNzRGF0YSAoa2V5KSB7XG4gICAgICBpZiAoIXNjaGVtYVtrZXldIHx8IHNjaGVtYVtrZXldLmlzICE9PSB0eXBlKSB7IHJldHVybjsgfVxuICAgICAgaWYgKHZhcmlhYmxlc1trZXldLnZhbHVlID09PSBkYXRhW2tleV0pIHsgcmV0dXJuOyB9XG4gICAgICB2YXJpYWJsZXNba2V5XS52YWx1ZSA9IHNlbGYucGFyc2VWYWx1ZShzY2hlbWFba2V5XS50eXBlLCBkYXRhW2tleV0pO1xuICAgICAgdmFyaWFibGVzW2tleV0ubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIH1cbiAgfSxcblxuICBwYXJzZVZhbHVlOiBmdW5jdGlvbiAodHlwZSwgdmFsdWUpIHtcbiAgICB2YXIgY29sb3I7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICd2ZWMyJzoge1xuICAgICAgICByZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjIodmFsdWUueCwgdmFsdWUueSk7XG4gICAgICB9XG4gICAgICBjYXNlICd2ZWMzJzoge1xuICAgICAgICByZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjModmFsdWUueCwgdmFsdWUueSwgdmFsdWUueik7XG4gICAgICB9XG4gICAgICBjYXNlICd2ZWM0Jzoge1xuICAgICAgICByZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjQodmFsdWUueCwgdmFsdWUueSwgdmFsdWUueiwgdmFsdWUudyk7XG4gICAgICB9XG4gICAgICBjYXNlICdjb2xvcic6IHtcbiAgICAgICAgY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IodmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjMoY29sb3IuciwgY29sb3IuZywgY29sb3IuYik7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogUmVnaXN0ZXJzIGEgc2hhZGVyIHRvIEEtRnJhbWUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBzaGFkZXIgbmFtZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBkZWZpbml0aW9uIC0gc2hhZGVyIHByb3BlcnR5IGFuZCBtZXRob2RzLlxuICogQHJldHVybnMge29iamVjdH0gU2hhZGVyLlxuICovXG5tb2R1bGUuZXhwb3J0cy5yZWdpc3RlclNoYWRlciA9IGZ1bmN0aW9uIChuYW1lLCBkZWZpbml0aW9uKSB7XG4gIHZhciBOZXdTaGFkZXI7XG4gIHZhciBwcm90byA9IHt9O1xuXG4gIC8vIEZvcm1hdCBkZWZpbml0aW9uIG9iamVjdCB0byBwcm90b3R5cGUgb2JqZWN0LlxuICBPYmplY3Qua2V5cyhkZWZpbml0aW9uKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBwcm90b1trZXldID0ge1xuICAgICAgdmFsdWU6IGRlZmluaXRpb25ba2V5XSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfTtcbiAgfSk7XG5cbiAgaWYgKHNoYWRlcnNbbmFtZV0pIHtcbiAgICB0aHJvdyBFcnJvcignVGhlIHNoYWRlciAnICsgbmFtZSArICcgaGFzIGJlZW4gYWxyZWFkeSByZWdpc3RlcmVkJyk7XG4gIH1cbiAgTmV3U2hhZGVyID0gZnVuY3Rpb24gKCkgeyBTaGFkZXIuY2FsbCh0aGlzKTsgfTtcbiAgTmV3U2hhZGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU2hhZGVyLnByb3RvdHlwZSwgcHJvdG8pO1xuICBOZXdTaGFkZXIucHJvdG90eXBlLm5hbWUgPSBuYW1lO1xuICBOZXdTaGFkZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTmV3U2hhZGVyO1xuICBzaGFkZXJzW25hbWVdID0ge1xuICAgIFNoYWRlcjogTmV3U2hhZGVyLFxuICAgIHNjaGVtYTogcHJvY2Vzc1NjaGVtYShOZXdTaGFkZXIucHJvdG90eXBlLnNjaGVtYSlcbiAgfTtcbiAgc2hhZGVyTmFtZXMucHVzaChuYW1lKTtcbiAgcmV0dXJuIE5ld1NoYWRlcjtcbn07XG5cbn0se1wiLi4vbGliL3RocmVlXCI6OTAsXCIuL3NjaGVtYVwiOjYyfV0sNjQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIGNvbXBvbmVudHMgPSBfZGVyZXFfKCcuL2NvbXBvbmVudCcpO1xyXG52YXIgc3lzdGVtcyA9IG1vZHVsZS5leHBvcnRzLnN5c3RlbXMgPSB7fTsgIC8vIEtlZXAgdHJhY2sgb2YgcmVnaXN0ZXJlZCBjb21wb25lbnRzLlxyXG5cclxuLyoqXHJcbiAqIFN5c3RlbSBjbGFzcyBkZWZpbml0aW9uLlxyXG4gKlxyXG4gKiBTeXN0ZW1zIHByb3ZpZGUgZ2xvYmFsIHNjb3BlIGFuZCBzZXJ2aWNlcyB0byBhIGdyb3VwIG9mIGluc3RhbnRpYXRlZCBjb21wb25lbnRzIG9mIHRoZS5cclxuICogc2FtZSBjbGFzcy4gRm9yIGV4YW1wbGUsIGEgcGh5c2ljcyBjb21wb25lbnQgdGhhdCBjcmVhdGVzIGEgcGh5c2ljcyB3b3JsZCB0aGF0IG92ZXJzZWVzXHJcbiAqIGFsbCBlbnRpdGllcyB3aXRoIGEgcGh5c2ljcyBvciByaWdpZCBib2R5IGNvbXBvbmVudC5cclxuICpcclxuICogQG1lbWJlciB7c3RyaW5nfSBuYW1lIC0gTmFtZSB0aGF0IHN5c3RlbSBpcyByZWdpc3RlcmVkIHVuZGVyLlxyXG4gKiBAbWVtYmVyIHtFbGVtZW50fSBzY2VuZUVsIC0gSGFuZGxlIHRvIHRoZSBzY2VuZSBlbGVtZW50IHdoZXJlIHN5c3RlbSBhcHBsaWVzIHRvLlxyXG4gKi9cclxudmFyIFN5c3RlbSA9IG1vZHVsZS5leHBvcnRzLlN5c3RlbSA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgY29tcG9uZW50ID0gY29tcG9uZW50cyAmJiBjb21wb25lbnRzLmNvbXBvbmVudHNbdGhpcy5uYW1lXTtcclxuICBpZiAoY29tcG9uZW50KSB7IGNvbXBvbmVudC5Db21wb25lbnQucHJvdG90eXBlLnN5c3RlbSA9IHRoaXM7IH1cclxufTtcclxuXHJcblN5c3RlbS5wcm90b3R5cGUgPSB7XHJcblxyXG4gIC8qKlxyXG4gICAqIEluaXQgaGFuZGxlci4gQ2FsbGVkIGR1cmluZyBzY2VuZSBpbml0aWFsaXphdGlvbiBhbmQgaXMgb25seSBydW4gb25jZS5cclxuICAgKiBTeXN0ZW1zIGNhbiB1c2UgdGhpcyB0byBzZXQgaW5pdGlhbCBzdGF0ZS5cclxuICAgKi9cclxuICBpbml0OiBmdW5jdGlvbiAoKSB7IC8qIG5vLW9wICovIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIFRpY2sgaGFuZGxlci5cclxuICAgKiBDYWxsZWQgb24gZWFjaCB0aWNrIG9mIHRoZSBzY2VuZSByZW5kZXIgbG9vcC5cclxuICAgKiBBZmZlY3RlZCBieSBwbGF5IGFuZCBwYXVzZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lIC0gU2NlbmUgdGljayB0aW1lLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lRGVsdGEgLSBEaWZmZXJlbmNlIGluIGN1cnJlbnQgcmVuZGVyIHRpbWUgYW5kIHByZXZpb3VzIHJlbmRlciB0aW1lLlxyXG4gICAqL1xyXG4gIHRpY2s6IHVuZGVmaW5lZCxcclxuXHJcbiAgLyoqXHJcbiAgICogQ2FsbGVkIHRvIHN0YXJ0IGFueSBkeW5hbWljIGJlaGF2aW9yIChlLmcuLCBhbmltYXRpb24sIEFJLCBldmVudHMsIHBoeXNpY3MpLlxyXG4gICAqL1xyXG4gIHBsYXk6IGZ1bmN0aW9uICgpIHsgLyogbm8tb3AgKi8gfSxcclxuXHJcbiAgLyoqXHJcbiAgICogQ2FsbGVkIHRvIHN0b3AgYW55IGR5bmFtaWMgYmVoYXZpb3IgKGUuZy4sIGFuaW1hdGlvbiwgQUksIGV2ZW50cywgcGh5c2ljcykuXHJcbiAgICovXHJcbiAgcGF1c2U6IGZ1bmN0aW9uICgpIHsgLyogbm8tb3AgKi8gfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlZ2lzdGVycyBhIHN5c3RlbSB0byBBLUZyYW1lLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIENvbXBvbmVudCBuYW1lLlxyXG4gKiBAcGFyYW0ge29iamVjdH0gZGVmaW5pdGlvbiAtIENvbXBvbmVudCBwcm9wZXJ0eSBhbmQgbWV0aG9kcy5cclxuICogQHJldHVybnMge29iamVjdH0gQ29tcG9uZW50LlxyXG4gKi9cclxubW9kdWxlLmV4cG9ydHMucmVnaXN0ZXJTeXN0ZW0gPSBmdW5jdGlvbiAobmFtZSwgZGVmaW5pdGlvbikge1xyXG4gIHZhciBpO1xyXG4gIHZhciBOZXdTeXN0ZW07XHJcbiAgdmFyIHByb3RvID0ge307XHJcbiAgdmFyIHNjZW5lcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2Etc2NlbmUnKTtcclxuXHJcbiAgLy8gRm9ybWF0IGRlZmluaXRpb24gb2JqZWN0IHRvIHByb3RvdHlwZSBvYmplY3QuXHJcbiAgT2JqZWN0LmtleXMoZGVmaW5pdGlvbikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICBwcm90b1trZXldID0ge1xyXG4gICAgICB2YWx1ZTogZGVmaW5pdGlvbltrZXldLFxyXG4gICAgICB3cml0YWJsZTogdHJ1ZVxyXG4gICAgfTtcclxuICB9KTtcclxuXHJcbiAgaWYgKHN5c3RlbXNbbmFtZV0pIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignVGhlIHN5c3RlbSBgJyArIG5hbWUgKyAnYCBoYXMgYmVlbiBhbHJlYWR5IHJlZ2lzdGVyZWQuICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICdDaGVjayB0aGF0IHlvdSBhcmUgbm90IGxvYWRpbmcgdHdvIHZlcnNpb25zIG9mIHRoZSBzYW1lIHN5c3RlbSAnICtcclxuICAgICAgICAgICAgICAgICAgICAnb3IgdHdvIGRpZmZlcmVudCBzeXN0ZW1zIG9mIHRoZSBzYW1lIG5hbWUuJyk7XHJcbiAgfVxyXG4gIE5ld1N5c3RlbSA9IGZ1bmN0aW9uICgpIHsgU3lzdGVtLmNhbGwodGhpcyk7IH07XHJcbiAgTmV3U3lzdGVtLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU3lzdGVtLnByb3RvdHlwZSwgcHJvdG8pO1xyXG4gIE5ld1N5c3RlbS5wcm90b3R5cGUubmFtZSA9IG5hbWU7XHJcbiAgTmV3U3lzdGVtLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE5ld1N5c3RlbTtcclxuICBzeXN0ZW1zW25hbWVdID0gTmV3U3lzdGVtO1xyXG5cclxuICAvLyBJbml0aWFsaXplIHN5c3RlbXMgZm9yIGV4aXN0aW5nIHNjZW5lc1xyXG4gIGZvciAoaSA9IDA7IGkgPCBzY2VuZXMubGVuZ3RoOyBpKyspIHsgc2NlbmVzW2ldLmluaXRTeXN0ZW0obmFtZSk7IH1cclxufTtcclxuXG59LHtcIi4vY29tcG9uZW50XCI6NTZ9XSw2NTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgQU5vZGUgPSBfZGVyZXFfKCcuLi8uLi9jb3JlL2Etbm9kZScpO1xudmFyIHJlZ2lzdGVyRWxlbWVudCA9IF9kZXJlcV8oJy4uLy4uL2NvcmUvYS1yZWdpc3Rlci1lbGVtZW50JykucmVnaXN0ZXJFbGVtZW50O1xuXG4vKipcbiAqIERlY2xhcmF0aXZlIGV2ZW50cyB0byBoZWxwIHJlZ2lzdGVyIGV2ZW50IGxpc3RlbmVycyB0aGF0IHNldCBhdHRyaWJ1dGVzIG9uIG90aGVyIGVudGl0aWVzLlxuICogQSBjb252ZW5pZW5jZSBsYXllciBhbmQgaGVscGVyIGZvciB0aG9zZSB0aGF0IG1pZ2h0IG5vdCBrbm93IEphdmFzY3JpcHQuXG4gKlxuICogTm90ZSB0aGF0IHRoZSBldmVudCB0aGF0IDxhLWV2ZW50PiByZWdpc3RlcnMgaXMgbm90IGRlbGVnYXRlZCBhcyB0aGlzIGhlbHBlciBpcyBtYWlubHlcbiAqIGZvciB0aG9zZSB0aGF0IGRvIG5vdCBrbm93IEphdmFzY3JpcHQgYW5kIHdyaXRpbmcgcmF3IG1hcmt1cC4gSW4gd2hpY2ggY2FzZSwgZGVsZWdhdGVkXG4gKiBldmVudHMgYXJlIG5vdCBuZWVkZWQuIEFsc28gaGVscHMgcmVkdWNlIHNjb3BlIG9mIHRoaXMgaGVscGVyIGFuZCBlbmNvdXJhZ2VzIHBlb3BsZSB0b1xuICogbGVhcm4gdG8gcmVnaXN0ZXIgdGhlaXIgb3duIGV2ZW50IGhhbmRsZXJzLlxuICpcbiAqIEBtZW1iZXIge3N0cmluZ30gbmFtZSAtIEV2ZW50IG5hbWUuXG4gKiBAbWVtYmVyIHthcnJheX0gdGFyZ2V0RWxzIC0gRWxlbWVudHMgdG8gbW9kaWZ5IG9uIGV2ZW50LiBEZWZhdWx0cyB0byBwYXJlbnQgZWxlbWVudC5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSByZWdpc3RlckVsZW1lbnQoJ2EtZXZlbnQnLCB7XG4gIHByb3RvdHlwZTogT2JqZWN0LmNyZWF0ZShBTm9kZS5wcm90b3R5cGUsIHtcbiAgICBjcmVhdGVkQ2FsbGJhY2s6IHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZWwgPSBudWxsO1xuICAgICAgICB0aGlzLmlzQUV2ZW50ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5uYW1lID0gJyc7XG4gICAgICAgIHRoaXMudGFyZ2V0RWxzID0gW107XG4gICAgICB9XG4gICAgfSxcblxuICAgIGF0dGFjaGVkQ2FsbGJhY2s6IHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0YXJnZXRTZWxlY3RvciA9IHRoaXMuZ2V0QXR0cmlidXRlKCd0YXJnZXQnKTtcbiAgICAgICAgdGhpcy5lbCA9IHRoaXMucGFyZW50Tm9kZTtcbiAgICAgICAgdGhpcy5uYW1lID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ25hbWUnKSB8fCB0aGlzLmdldEF0dHJpYnV0ZSgndHlwZScpO1xuXG4gICAgICAgIGlmICh0YXJnZXRTZWxlY3Rvcikge1xuICAgICAgICAgIHRoaXMudGFyZ2V0RWxzID0gdGhpcy5jbG9zZXN0KCdhLXNjZW5lJykucXVlcnlTZWxlY3RvckFsbCh0YXJnZXRTZWxlY3Rvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy50YXJnZXRFbHMgPSBbdGhpcy5lbF07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5kZXByZWNhdGVkKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgJzwnICsgdGhpcy50YWdOYW1lLnRvTG93ZXJDYXNlKCkgKyAnPicgK1xuICAgICAgICAgICAgJyBoYXMgYmVlbiBERVBSRUNBVEVELiBVc2UgPGEtZXZlbnQgbmFtZT1cIicgKyB0aGlzLm5hbWUgKyAnXCI+JyArXG4gICAgICAgICAgICAnIGluc3RlYWQuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZXByZWNhdGUgYHR5cGVgIGZvciBgbmFtZWAuXG4gICAgICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgndHlwZScpKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAnPGEtZXZlbnQgdHlwZT4gaGFzIGJlZW4gREVQUkVDQVRFRC4gVXNlIDxhLWV2ZW50IG5hbWU+IGluc3RlYWQuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxpc3RlbmVyID0gdGhpcy5hdHRhY2hFdmVudExpc3RlbmVyKCk7XG4gICAgICAgIHRoaXMubG9hZCgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBkZXRhY2hlZENhbGxiYWNrOiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbGlzdGVuZXIgPSB0aGlzLmxpc3RlbmVyO1xuICAgICAgICBpZiAoIWxpc3RlbmVyKSB7IHJldHVybjsgfVxuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcy5uYW1lLCBsaXN0ZW5lcik7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGF0dGFjaEV2ZW50TGlzdGVuZXI6IHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzO1xuICAgICAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgICAgICB2YXIgbmFtZSA9IHRoaXMubmFtZTtcbiAgICAgICAgdmFyIHRhcmdldEVscyA9IHRoaXMudGFyZ2V0RWxzO1xuXG4gICAgICAgIHJldHVybiBlbC5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgYXR0cmlidXRlO1xuICAgICAgICAgIHZhciBhdHRyaWJ1dGVOYW1lO1xuICAgICAgICAgIHZhciBhdHRyaWJ1dGVTcGxpdDtcbiAgICAgICAgICB2YXIgYXR0cmlidXRlVmFsdWU7XG4gICAgICAgICAgdmFyIHRhcmdldEVsO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0YXJnZXRFbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYXR0cmlidXRlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2pdO1xuICAgICAgICAgICAgICBhdHRyaWJ1dGVOYW1lID0gYXR0cmlidXRlLm5hbWU7XG4gICAgICAgICAgICAgIGF0dHJpYnV0ZVZhbHVlID0gYXR0cmlidXRlLnZhbHVlO1xuICAgICAgICAgICAgICB0YXJnZXRFbCA9IHRhcmdldEVsc1tpXTtcblxuICAgICAgICAgICAgICAvLyB0YXJnZXQgaXMgYSBrZXl3b3JkIGZvciA8YS1ldmVudD4uXG4gICAgICAgICAgICAgIGlmIChhdHRyaWJ1dGVOYW1lID09PSAndGFyZ2V0JykgeyBjb250aW51ZTsgfVxuXG4gICAgICAgICAgICAgIC8vIEhhbmRsZSBjb21wb25lbnQgcHJvcGVydHkgc2VsZWN0b3IgbGlrZSBgbWF0ZXJpYWwuY29sb3JgLlxuICAgICAgICAgICAgICBpZiAoYXR0cmlidXRlTmFtZS5pbmRleE9mKCcuJykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgYXR0cmlidXRlU3BsaXQgPSBhdHRyaWJ1dGVOYW1lLnNwbGl0KCcuJyk7XG4gICAgICAgICAgICAgICAgdGFyZ2V0RWwuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZVNwbGl0WzBdLCBhdHRyaWJ1dGVTcGxpdFsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlVmFsdWUpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gU2V0IHBsYWluIGF0dHJpYnV0ZS5cbiAgICAgICAgICAgICAgdGFyZ2V0RWwuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZVZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSlcbn0pO1xuXG59LHtcIi4uLy4uL2NvcmUvYS1ub2RlXCI6NTQsXCIuLi8uLi9jb3JlL2EtcmVnaXN0ZXItZWxlbWVudFwiOjU1fV0sNjY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBDb21tb24gbWVzaCBkZWZhdWx0cywgbWFwcGluZ3MsIGFuZCB0cmFuc2Zvcm1zLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldE1lc2hNaXhpbiAoKSB7XG4gIHJldHVybiB7XG4gICAgZGVmYXVsdEF0dHJpYnV0ZXM6IHtcbiAgICAgIG1hdGVyaWFsOiB7IH1cbiAgICB9LFxuXG4gICAgbWFwcGluZ3M6IHtcbiAgICAgIGNvbG9yOiAnbWF0ZXJpYWwuY29sb3InLFxuICAgICAgbWV0YWxuZXNzOiAnbWF0ZXJpYWwubWV0YWxuZXNzJyxcbiAgICAgIG9wYWNpdHk6ICdtYXRlcmlhbC5vcGFjaXR5JyxcbiAgICAgIHJlcGVhdDogJ21hdGVyaWFsLnJlcGVhdCcsXG4gICAgICByb3VnaG5lc3M6ICdtYXRlcmlhbC5yb3VnaG5lc3MnLFxuICAgICAgc2hhZGVyOiAnbWF0ZXJpYWwuc2hhZGVyJyxcbiAgICAgIHNpZGU6ICdtYXRlcmlhbC5zaWRlJyxcbiAgICAgIHNyYzogJ21hdGVyaWFsLnNyYycsXG4gICAgICB0cmFuc2xhdGU6ICdnZW9tZXRyeS50cmFuc2xhdGUnLFxuICAgICAgdHJhbnNwYXJlbnQ6ICdtYXRlcmlhbC50cmFuc3BhcmVudCdcbiAgICB9LFxuXG4gICAgdHJhbnNmb3Jtczoge1xuICAgICAgc3JjOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgLy8gU2VsZWN0b3IuXG4gICAgICAgIGlmICh2YWx1ZVswXSA9PT0gJyMnKSB7IHJldHVybiB2YWx1ZTsgfVxuICAgICAgICAvLyBJbmxpbmUgdXJsKCkuXG4gICAgICAgIHJldHVybiAndXJsKCcgKyB2YWx1ZSArICcpJztcbiAgICAgIH1cbiAgICB9XG4gIH07XG59O1xuXG59LHt9XSw2NzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5fZGVyZXFfKCcuL3ByaW1pdGl2ZXMvYS1ib3gnKTtcbl9kZXJlcV8oJy4vcHJpbWl0aXZlcy9hLWNhbWVyYScpO1xuX2RlcmVxXygnLi9wcmltaXRpdmVzL2EtY2lyY2xlJyk7XG5fZGVyZXFfKCcuL3ByaW1pdGl2ZXMvYS1jb2xsYWRhLW1vZGVsJyk7XG5fZGVyZXFfKCcuL3ByaW1pdGl2ZXMvYS1jb25lJyk7XG5fZGVyZXFfKCcuL3ByaW1pdGl2ZXMvYS1jdXJzb3InKTtcbl9kZXJlcV8oJy4vcHJpbWl0aXZlcy9hLWN1cnZlZGltYWdlJyk7XG5fZGVyZXFfKCcuL3ByaW1pdGl2ZXMvYS1jeWxpbmRlcicpO1xuX2RlcmVxXygnLi9wcmltaXRpdmVzL2EtaW1hZ2UnKTtcbl9kZXJlcV8oJy4vcHJpbWl0aXZlcy9hLWxpZ2h0Jyk7XG5fZGVyZXFfKCcuL3ByaW1pdGl2ZXMvYS1tb2RlbCcpO1xuX2RlcmVxXygnLi9wcmltaXRpdmVzL2Etb2JqLW1vZGVsJyk7XG5fZGVyZXFfKCcuL3ByaW1pdGl2ZXMvYS1wbGFuZScpO1xuX2RlcmVxXygnLi9wcmltaXRpdmVzL2EtcmluZycpO1xuX2RlcmVxXygnLi9wcmltaXRpdmVzL2Etc2t5Jyk7XG5fZGVyZXFfKCcuL3ByaW1pdGl2ZXMvYS1zcGhlcmUnKTtcbl9kZXJlcV8oJy4vcHJpbWl0aXZlcy9hLXRvcnVzJyk7XG5fZGVyZXFfKCcuL3ByaW1pdGl2ZXMvYS12aWRlbycpO1xuX2RlcmVxXygnLi9wcmltaXRpdmVzL2EtdmlkZW9zcGhlcmUnKTtcblxufSx7XCIuL3ByaW1pdGl2ZXMvYS1ib3hcIjo2OCxcIi4vcHJpbWl0aXZlcy9hLWNhbWVyYVwiOjY5LFwiLi9wcmltaXRpdmVzL2EtY2lyY2xlXCI6NzAsXCIuL3ByaW1pdGl2ZXMvYS1jb2xsYWRhLW1vZGVsXCI6NzEsXCIuL3ByaW1pdGl2ZXMvYS1jb25lXCI6NzIsXCIuL3ByaW1pdGl2ZXMvYS1jdXJzb3JcIjo3MyxcIi4vcHJpbWl0aXZlcy9hLWN1cnZlZGltYWdlXCI6NzQsXCIuL3ByaW1pdGl2ZXMvYS1jeWxpbmRlclwiOjc1LFwiLi9wcmltaXRpdmVzL2EtaW1hZ2VcIjo3NixcIi4vcHJpbWl0aXZlcy9hLWxpZ2h0XCI6NzcsXCIuL3ByaW1pdGl2ZXMvYS1tb2RlbFwiOjc4LFwiLi9wcmltaXRpdmVzL2Etb2JqLW1vZGVsXCI6NzksXCIuL3ByaW1pdGl2ZXMvYS1wbGFuZVwiOjgwLFwiLi9wcmltaXRpdmVzL2EtcmluZ1wiOjgxLFwiLi9wcmltaXRpdmVzL2Etc2t5XCI6ODIsXCIuL3ByaW1pdGl2ZXMvYS1zcGhlcmVcIjo4MyxcIi4vcHJpbWl0aXZlcy9hLXRvcnVzXCI6ODQsXCIuL3ByaW1pdGl2ZXMvYS12aWRlb1wiOjg1LFwiLi9wcmltaXRpdmVzL2EtdmlkZW9zcGhlcmVcIjo4Nn1dLDY4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBnZXRNZXNoTWl4aW4gPSBfZGVyZXFfKCcuLi9nZXRNZXNoTWl4aW4nKTtcbnZhciByZWdpc3RlclByaW1pdGl2ZSA9IF9kZXJlcV8oJy4uL3JlZ2lzdGVyUHJpbWl0aXZlJyk7XG52YXIgdXRpbHMgPSBfZGVyZXFfKCcuLi8uLi8uLi91dGlscy8nKTtcblxudmFyIGJveERlZmluaXRpb24gPSB1dGlscy5leHRlbmREZWVwKHt9LCBnZXRNZXNoTWl4aW4oKSwge1xuICBkZWZhdWx0QXR0cmlidXRlczoge1xuICAgIGdlb21ldHJ5OiB7XG4gICAgICBwcmltaXRpdmU6ICdib3gnXG4gICAgfVxuICB9LFxuXG4gIG1hcHBpbmdzOiB7XG4gICAgZGVwdGg6ICdnZW9tZXRyeS5kZXB0aCcsXG4gICAgaGVpZ2h0OiAnZ2VvbWV0cnkuaGVpZ2h0JyxcbiAgICB0cmFuc2xhdGU6ICdnZW9tZXRyeS50cmFuc2xhdGUnLFxuICAgIHdpZHRoOiAnZ2VvbWV0cnkud2lkdGgnXG4gIH1cbn0pO1xuXG5yZWdpc3RlclByaW1pdGl2ZSgnYS1ib3gnLCBib3hEZWZpbml0aW9uKTtcbnJlZ2lzdGVyUHJpbWl0aXZlKCdhLWN1YmUnLCB1dGlscy5leHRlbmREZWVwKHtcbiAgZGVwcmVjYXRlZDogJzxhLWN1YmU+IGlzIGRlcHJlY2F0ZWQuIFVzZSA8YS1ib3g+IGluc3RlYWQuJ1xufSwgYm94RGVmaW5pdGlvbikpO1xuXG59LHtcIi4uLy4uLy4uL3V0aWxzL1wiOjEwMixcIi4uL2dldE1lc2hNaXhpblwiOjY2LFwiLi4vcmVnaXN0ZXJQcmltaXRpdmVcIjo4N31dLDY5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciByZWdpc3RlclByaW1pdGl2ZSA9IF9kZXJlcV8oJy4uL3JlZ2lzdGVyUHJpbWl0aXZlJyk7XG5cbnJlZ2lzdGVyUHJpbWl0aXZlKCdhLWNhbWVyYScsIHtcbiAgZGVmYXVsdEF0dHJpYnV0ZXM6IHtcbiAgICBjYW1lcmE6IHt9LFxuICAgICdsb29rLWNvbnRyb2xzJzoge30sXG4gICAgJ3dhc2QtY29udHJvbHMnOiB7fVxuICB9LFxuXG4gIG1hcHBpbmdzOiB7XG4gICAgYWN0aXZlOiAnY2FtZXJhLmFjdGl2ZScsXG4gICAgZmFyOiAnY2FtZXJhLmZhcicsXG4gICAgZm92OiAnY2FtZXJhLmZvdicsXG4gICAgJ2xvb2stY29udHJvbHMtZW5hYmxlZCc6ICdsb29rLWNvbnRyb2xzLmVuYWJsZWQnLFxuICAgIG5lYXI6ICdjYW1lcmEubmVhcicsXG4gICAgJ3dhc2QtY29udHJvbHMtZW5hYmxlZCc6ICd3YXNkLWNvbnRyb2xzLmVuYWJsZWQnXG4gIH0sXG5cbiAgZGVwcmVjYXRlZE1hcHBpbmdzOiB7XG4gICAgJ2N1cnNvci1jb2xvcic6ICdhLWNhbWVyYVtjdXJzb3ItY29sb3JdIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBhLWN1cnNvcltjb2xvcl0gaW5zdGVhZC4nLFxuICAgICdjdXJzb3ItbWF4ZGlzdGFuY2UnOiAnYS1jYW1lcmFbY3Vyc29yLW1heGRpc3RhbmNlXSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgYS1jdXJzb3JbbWF4LWRpc3RhbmNlXSBpbnN0ZWFkLicsXG4gICAgJ2N1cnNvci1vZmZzZXQnOiAnYS1jYW1lcmFbY3Vyc29yLW9mZnNldF0gaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIGEtY3Vyc29yW3Bvc2l0aW9uXSBpbnN0ZWFkLicsXG4gICAgJ2N1cnNvci1vcGFjaXR5JzogJ2EtY2FtZXJhW2N1cnNvci1vZmZzZXRdIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBhLWN1cnNvcltvcGFjaXR5XSBpbnN0ZWFkLicsXG4gICAgJ2N1cnNvci1zY2FsZSc6ICdhLWNhbWVyYVtjdXJzb3Itc2NhbGVdIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBhLWN1cnNvcltzY2FsZV0gaW5zdGVhZC4nLFxuICAgICdjdXJzb3ItdmlzaWJsZSc6ICdhLWNhbWVyYVtjdXJzb3ItdmlzaWJsZV0gaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIGEtY3Vyc29yW3Zpc2libGVdIGluc3RlYWQuJ1xuICB9XG59KTtcblxufSx7XCIuLi9yZWdpc3RlclByaW1pdGl2ZVwiOjg3fV0sNzA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIGdldE1lc2hNaXhpbiA9IF9kZXJlcV8oJy4uL2dldE1lc2hNaXhpbicpO1xudmFyIHJlZ2lzdGVyUHJpbWl0aXZlID0gX2RlcmVxXygnLi4vcmVnaXN0ZXJQcmltaXRpdmUnKTtcbnZhciB1dGlscyA9IF9kZXJlcV8oJy4uLy4uLy4uL3V0aWxzLycpO1xuXG5yZWdpc3RlclByaW1pdGl2ZSgnYS1jaXJjbGUnLCB1dGlscy5leHRlbmREZWVwKHt9LCBnZXRNZXNoTWl4aW4oKSwge1xuICBkZWZhdWx0QXR0cmlidXRlczoge1xuICAgIGdlb21ldHJ5OiB7XG4gICAgICBwcmltaXRpdmU6ICdjaXJjbGUnXG4gICAgfVxuICB9LFxuXG4gIG1hcHBpbmdzOiB7XG4gICAgJ3JhZGl1cyc6ICdnZW9tZXRyeS5yYWRpdXMnLFxuICAgICdzZWdtZW50cyc6ICdnZW9tZXRyeS5zZWdtZW50cycsXG4gICAgJ3RoZXRhLWxlbmd0aCc6ICdnZW9tZXRyeS50aGV0YS1sZW5ndGgnLFxuICAgICd0aGV0YS1zdGFydCc6ICdnZW9tZXRyeS50aGV0YS1zdGFydCdcbiAgfVxufSkpO1xuXG59LHtcIi4uLy4uLy4uL3V0aWxzL1wiOjEwMixcIi4uL2dldE1lc2hNaXhpblwiOjY2LFwiLi4vcmVnaXN0ZXJQcmltaXRpdmVcIjo4N31dLDcxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBnZXRNZXNoTWl4aW4gPSBfZGVyZXFfKCcuLi9nZXRNZXNoTWl4aW4nKTtcbnZhciByZWdpc3RlclByaW1pdGl2ZSA9IF9kZXJlcV8oJy4uL3JlZ2lzdGVyUHJpbWl0aXZlJyk7XG52YXIgdXRpbHMgPSBfZGVyZXFfKCcuLi8uLi8uLi91dGlscy8nKTtcblxucmVnaXN0ZXJQcmltaXRpdmUoJ2EtY29sbGFkYS1tb2RlbCcsIHV0aWxzLmV4dGVuZERlZXAoe30sIGdldE1lc2hNaXhpbigpLCB7XG4gIG1hcHBpbmdzOiB7XG4gICAgc3JjOiAnY29sbGFkYS1tb2RlbCdcbiAgfVxufSkpO1xuXG59LHtcIi4uLy4uLy4uL3V0aWxzL1wiOjEwMixcIi4uL2dldE1lc2hNaXhpblwiOjY2LFwiLi4vcmVnaXN0ZXJQcmltaXRpdmVcIjo4N31dLDcyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBnZXRNZXNoTWl4aW4gPSBfZGVyZXFfKCcuLi9nZXRNZXNoTWl4aW4nKTtcbnZhciByZWdpc3RlclByaW1pdGl2ZSA9IF9kZXJlcV8oJy4uL3JlZ2lzdGVyUHJpbWl0aXZlJyk7XG52YXIgdXRpbHMgPSBfZGVyZXFfKCcuLi8uLi8uLi91dGlscy8nKTtcblxucmVnaXN0ZXJQcmltaXRpdmUoJ2EtY29uZScsIHV0aWxzLmV4dGVuZERlZXAoe30sIGdldE1lc2hNaXhpbigpLCB7XG4gIGRlZmF1bHRBdHRyaWJ1dGVzOiB7XG4gICAgZ2VvbWV0cnk6IHtcbiAgICAgIHByaW1pdGl2ZTogJ2NvbmUnXG4gICAgfVxuICB9LFxuXG4gIG1hcHBpbmdzOiB7XG4gICAgaGVpZ2h0OiAnZ2VvbWV0cnkuaGVpZ2h0JyxcbiAgICAnb3Blbi1lbmRlZCc6ICdnZW9tZXRyeS5vcGVuRW5kZWQnLFxuICAgICdyYWRpdXMtYm90dG9tJzogJ2dlb21ldHJ5LnJhZGl1c0JvdHRvbScsXG4gICAgJ3JhZGl1cy10b3AnOiAnZ2VvbWV0cnkucmFkaXVzVG9wJyxcbiAgICAnc2VnbWVudHMtaGVpZ2h0JzogJ2dlb21ldHJ5LnNlZ21lbnRzSGVpZ2h0JyxcbiAgICAnc2VnbWVudHMtcmFkaWFsJzogJ2dlb21ldHJ5LnNlZ21lbnRzUmFkaWFsJyxcbiAgICAndGhldGEtbGVuZ3RoJzogJ2dlb21ldHJ5LnRoZXRhTGVuZ3RoJyxcbiAgICAndGhldGEtc3RhcnQnOiAnZ2VvbWV0cnkudGhldGFTdGFydCcsXG4gICAgdHJhbnNsYXRlOiAnZ2VvbWV0cnkudHJhbnNsYXRlJ1xuICB9XG59KSk7XG5cbn0se1wiLi4vLi4vLi4vdXRpbHMvXCI6MTAyLFwiLi4vZ2V0TWVzaE1peGluXCI6NjYsXCIuLi9yZWdpc3RlclByaW1pdGl2ZVwiOjg3fV0sNzM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIGdldE1lc2hNaXhpbiA9IF9kZXJlcV8oJy4uL2dldE1lc2hNaXhpbicpO1xudmFyIHJlZ2lzdGVyUHJpbWl0aXZlID0gX2RlcmVxXygnLi4vcmVnaXN0ZXJQcmltaXRpdmUnKTtcbnZhciB1dGlscyA9IF9kZXJlcV8oJy4uLy4uLy4uL3V0aWxzLycpO1xuXG5yZWdpc3RlclByaW1pdGl2ZSgnYS1jdXJzb3InLCB1dGlscy5leHRlbmREZWVwKHt9LCBnZXRNZXNoTWl4aW4oKSwge1xuICBkZWZhdWx0QXR0cmlidXRlczoge1xuICAgIGN1cnNvcjoge1xuICAgICAgbWF4RGlzdGFuY2U6IDEwMDBcbiAgICB9LFxuICAgIGdlb21ldHJ5OiB7XG4gICAgICBwcmltaXRpdmU6ICdyaW5nJyxcbiAgICAgIHJhZGl1c091dGVyOiAwLjAxNixcbiAgICAgIHJhZGl1c0lubmVyOiAwLjAxLFxuICAgICAgc2VnbWVudHNUaGV0YTogNjRcbiAgICB9LFxuICAgIG1hdGVyaWFsOiB7XG4gICAgICBzaGFkZXI6ICdmbGF0JyxcbiAgICAgIG9wYWNpdHk6IDAuOFxuICAgIH0sXG4gICAgcG9zaXRpb246IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwLFxuICAgICAgejogLTFcbiAgICB9XG4gIH0sXG5cbiAgbWFwcGluZ3M6IHtcbiAgICBmdXNlOiAnY3Vyc29yLmZ1c2UnLFxuICAgICdtYXgtZGlzdGFuY2UnOiAnY3Vyc29yLm1heERpc3RhbmNlJyxcbiAgICB0aW1lb3V0OiAnY3Vyc29yLnRpbWVvdXQnXG4gIH1cbn0pKTtcblxufSx7XCIuLi8uLi8uLi91dGlscy9cIjoxMDIsXCIuLi9nZXRNZXNoTWl4aW5cIjo2NixcIi4uL3JlZ2lzdGVyUHJpbWl0aXZlXCI6ODd9XSw3NDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgZ2V0TWVzaE1peGluID0gX2RlcmVxXygnLi4vZ2V0TWVzaE1peGluJyk7XG52YXIgcmVnaXN0ZXJQcmltaXRpdmUgPSBfZGVyZXFfKCcuLi9yZWdpc3RlclByaW1pdGl2ZScpO1xudmFyIHV0aWxzID0gX2RlcmVxXygnLi4vLi4vLi4vdXRpbHMvJyk7XG5cbnJlZ2lzdGVyUHJpbWl0aXZlKCdhLWN1cnZlZGltYWdlJywgdXRpbHMuZXh0ZW5kRGVlcCh7fSwgZ2V0TWVzaE1peGluKCksIHtcbiAgZGVmYXVsdEF0dHJpYnV0ZXM6IHtcbiAgICBnZW9tZXRyeToge1xuICAgICAgaGVpZ2h0OiAxLFxuICAgICAgcHJpbWl0aXZlOiAnY3lsaW5kZXInLFxuICAgICAgcmFkaXVzOiAyLFxuICAgICAgc2VnbWVudHNSYWRpYWw6IDQ4LFxuICAgICAgdGhldGFMZW5ndGg6IDI3MCxcbiAgICAgIG9wZW5FbmRlZDogdHJ1ZSxcbiAgICAgIHRoZXRhU3RhcnQ6IDBcbiAgICB9LFxuICAgIG1hdGVyaWFsOiB7XG4gICAgICBjb2xvcjogJyNGRkYnLFxuICAgICAgc2hhZGVyOiAnZmxhdCcsXG4gICAgICBzaWRlOiAnZG91YmxlJyxcbiAgICAgIHRyYW5zcGFyZW50OiB0cnVlLFxuICAgICAgcmVwZWF0OiAnLTEgMSdcbiAgICB9XG4gIH0sXG5cbiAgbWFwcGluZ3M6IHtcbiAgICBoZWlnaHQ6ICdnZW9tZXRyeS5oZWlnaHQnLFxuICAgICdvcGVuLWVuZGVkJzogJ2dlb21ldHJ5Lm9wZW5FbmRlZCcsXG4gICAgcmFkaXVzOiAnZ2VvbWV0cnkucmFkaXVzJyxcbiAgICBzZWdtZW50czogJ2dlb21ldHJ5LnNlZ21lbnRzUmFkaWFsJyxcbiAgICBzdGFydDogJ2dlb21ldHJ5LnRoZXRhU3RhcnQnLFxuICAgICd0aGV0YS1sZW5ndGgnOiAnZ2VvbWV0cnkudGhldGFMZW5ndGgnLFxuICAgICd0aGV0YS1zdGFydCc6ICdnZW9tZXRyeS50aGV0YVN0YXJ0JyxcbiAgICB0cmFuc2xhdGU6ICdnZW9tZXRyeS50cmFuc2xhdGUnLFxuICAgICd3aWR0aCc6ICdnZW9tZXRyeS50aGV0YUxlbmd0aCdcbiAgfVxufSkpO1xuXG59LHtcIi4uLy4uLy4uL3V0aWxzL1wiOjEwMixcIi4uL2dldE1lc2hNaXhpblwiOjY2LFwiLi4vcmVnaXN0ZXJQcmltaXRpdmVcIjo4N31dLDc1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBnZXRNZXNoTWl4aW4gPSBfZGVyZXFfKCcuLi9nZXRNZXNoTWl4aW4nKTtcbnZhciByZWdpc3RlclByaW1pdGl2ZSA9IF9kZXJlcV8oJy4uL3JlZ2lzdGVyUHJpbWl0aXZlJyk7XG52YXIgdXRpbHMgPSBfZGVyZXFfKCcuLi8uLi8uLi91dGlscy8nKTtcblxucmVnaXN0ZXJQcmltaXRpdmUoJ2EtY3lsaW5kZXInLCB1dGlscy5leHRlbmREZWVwKHt9LCBnZXRNZXNoTWl4aW4oKSwge1xuICBkZWZhdWx0QXR0cmlidXRlczoge1xuICAgIGdlb21ldHJ5OiB7XG4gICAgICBwcmltaXRpdmU6ICdjeWxpbmRlcidcbiAgICB9XG4gIH0sXG5cbiAgbWFwcGluZ3M6IHtcbiAgICBoZWlnaHQ6ICdnZW9tZXRyeS5oZWlnaHQnLFxuICAgICdvcGVuLWVuZGVkJzogJ2dlb21ldHJ5Lm9wZW5FbmRlZCcsXG4gICAgcmFkaXVzOiAnZ2VvbWV0cnkucmFkaXVzJyxcbiAgICAncmFkaXVzLWJvdHRvbSc6ICdnZW9tZXRyeS5yYWRpdXNCb3R0b20nLFxuICAgICdyYWRpdXMtdG9wJzogJ2dlb21ldHJ5LnJhZGl1c1RvcCcsXG4gICAgJ3NlZ21lbnRzLXJhZGlhbCc6ICdnZW9tZXRyeS5zZWdtZW50c1JhZGlhbCcsXG4gICAgJ3RoZXRhLWxlbmd0aCc6ICdnZW9tZXRyeS50aGV0YUxlbmd0aCcsXG4gICAgJ3RoZXRhLXN0YXJ0JzogJ2dlb21ldHJ5LnRoZXRhU3RhcnQnLFxuICAgIHRyYW5zbGF0ZTogJ2dlb21ldHJ5LnRyYW5zbGF0ZSdcbiAgfVxufSkpO1xuXG59LHtcIi4uLy4uLy4uL3V0aWxzL1wiOjEwMixcIi4uL2dldE1lc2hNaXhpblwiOjY2LFwiLi4vcmVnaXN0ZXJQcmltaXRpdmVcIjo4N31dLDc2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBnZXRNZXNoTWl4aW4gPSBfZGVyZXFfKCcuLi9nZXRNZXNoTWl4aW4nKTtcbnZhciByZWdpc3RlclByaW1pdGl2ZSA9IF9kZXJlcV8oJy4uL3JlZ2lzdGVyUHJpbWl0aXZlJyk7XG52YXIgdXRpbHMgPSBfZGVyZXFfKCcuLi8uLi8uLi91dGlscy8nKTtcblxucmVnaXN0ZXJQcmltaXRpdmUoJ2EtaW1hZ2UnLCB1dGlscy5leHRlbmREZWVwKHt9LCBnZXRNZXNoTWl4aW4oKSwge1xuICBkZWZhdWx0QXR0cmlidXRlczoge1xuICAgIGdlb21ldHJ5OiB7XG4gICAgICBwcmltaXRpdmU6ICdwbGFuZSdcbiAgICB9LFxuICAgIG1hdGVyaWFsOiB7XG4gICAgICBjb2xvcjogJyNGRkYnLFxuICAgICAgc2hhZGVyOiAnZmxhdCcsXG4gICAgICBzaWRlOiAnZG91YmxlJyxcbiAgICAgIHRyYW5zcGFyZW50OiB0cnVlXG4gICAgfVxuICB9LFxuXG4gIG1hcHBpbmdzOiB7XG4gICAgaGVpZ2h0OiAnZ2VvbWV0cnkuaGVpZ2h0JyxcbiAgICB0cmFuc2xhdGU6ICdnZW9tZXRyeS50cmFuc2xhdGUnLFxuICAgIHdpZHRoOiAnZ2VvbWV0cnkud2lkdGgnXG4gIH1cbn0pKTtcblxufSx7XCIuLi8uLi8uLi91dGlscy9cIjoxMDIsXCIuLi9nZXRNZXNoTWl4aW5cIjo2NixcIi4uL3JlZ2lzdGVyUHJpbWl0aXZlXCI6ODd9XSw3NzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgcmVnaXN0ZXJQcmltaXRpdmUgPSBfZGVyZXFfKCcuLi9yZWdpc3RlclByaW1pdGl2ZScpO1xuXG5yZWdpc3RlclByaW1pdGl2ZSgnYS1saWdodCcsIHtcbiAgZGVmYXVsdEF0dHJpYnV0ZXM6IHtcbiAgICBsaWdodDoge31cbiAgfSxcblxuICBtYXBwaW5nczoge1xuICAgIGFuZ2xlOiAnbGlnaHQuYW5nbGUnLFxuICAgIGNvbG9yOiAnbGlnaHQuY29sb3InLFxuICAgICdncm91bmQtY29sb3InOiAnbGlnaHQuZ3JvdW5kQ29sb3InLFxuICAgIGRlY2F5OiAnbGlnaHQuZGVjYXknLFxuICAgIGRpc3RhbmNlOiAnbGlnaHQuZGlzdGFuY2UnLFxuICAgIGV4cG9uZW50OiAnbGlnaHQuZXhwb25lbnQnLFxuICAgIGludGVuc2l0eTogJ2xpZ2h0LmludGVuc2l0eScsXG4gICAgdHlwZTogJ2xpZ2h0LnR5cGUnXG4gIH1cbn0pO1xuXG59LHtcIi4uL3JlZ2lzdGVyUHJpbWl0aXZlXCI6ODd9XSw3ODpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgZ2V0TWVzaE1peGluID0gX2RlcmVxXygnLi4vZ2V0TWVzaE1peGluJyk7XG52YXIgcmVnaXN0ZXJQcmltaXRpdmUgPSBfZGVyZXFfKCcuLi9yZWdpc3RlclByaW1pdGl2ZScpO1xudmFyIHV0aWxzID0gX2RlcmVxXygnLi4vLi4vLi4vdXRpbHMvJyk7XG5cbnJlZ2lzdGVyUHJpbWl0aXZlKCdhLW1vZGVsJywgdXRpbHMuZXh0ZW5kKHt9LCBnZXRNZXNoTWl4aW4oKSwge1xuICBkZXByZWNhdGVkOiAnPGEtbW9kZWw+IGlzIGRlcHJlY2F0ZWQuIFVzZSA8YS1vYmotbW9kZWw+IG9yIDxhLWNvbGxhZGEtbW9kZWw+IGluc3RlYWQuJyxcblxuICBkZWZhdWx0QXR0cmlidXRlczoge1xuICAgIGxvYWRlcjoge1xuICAgICAgZm9ybWF0OiAnY29sbGFkYSdcbiAgICB9LFxuICAgIG1hdGVyaWFsOiB7XG4gICAgICBjb2xvcjogJyNGRkYnXG4gICAgfVxuICB9LFxuXG4gIG1hcHBpbmdzOiB7XG4gICAgc3JjOiAnbG9hZGVyLnNyYycsXG4gICAgZm9ybWF0OiAnbG9hZGVyLmZvcm1hdCdcbiAgfVxufSkpO1xuXG59LHtcIi4uLy4uLy4uL3V0aWxzL1wiOjEwMixcIi4uL2dldE1lc2hNaXhpblwiOjY2LFwiLi4vcmVnaXN0ZXJQcmltaXRpdmVcIjo4N31dLDc5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBtZXNoTWl4aW4gPSBfZGVyZXFfKCcuLi9nZXRNZXNoTWl4aW4nKSgpO1xudmFyIHJlZ2lzdGVyUHJpbWl0aXZlID0gX2RlcmVxXygnLi4vcmVnaXN0ZXJQcmltaXRpdmUnKTtcbnZhciB1dGlscyA9IF9kZXJlcV8oJy4uLy4uLy4uL3V0aWxzLycpO1xuXG5yZWdpc3RlclByaW1pdGl2ZSgnYS1vYmotbW9kZWwnLCB1dGlscy5leHRlbmREZWVwKHt9LCBtZXNoTWl4aW4sIHtcbiAgbWFwcGluZ3M6IHtcbiAgICBzcmM6ICdvYmotbW9kZWwub2JqJyxcbiAgICBtdGw6ICdvYmotbW9kZWwubXRsJ1xuICB9LFxuXG4gIHRyYW5zZm9ybXM6IHtcbiAgICBtdGw6IG1lc2hNaXhpbi50cmFuc2Zvcm1zLnNyY1xuICB9XG59KSk7XG5cbn0se1wiLi4vLi4vLi4vdXRpbHMvXCI6MTAyLFwiLi4vZ2V0TWVzaE1peGluXCI6NjYsXCIuLi9yZWdpc3RlclByaW1pdGl2ZVwiOjg3fV0sODA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIGdldE1lc2hNaXhpbiA9IF9kZXJlcV8oJy4uL2dldE1lc2hNaXhpbicpO1xudmFyIHJlZ2lzdGVyUHJpbWl0aXZlID0gX2RlcmVxXygnLi4vcmVnaXN0ZXJQcmltaXRpdmUnKTtcbnZhciB1dGlscyA9IF9kZXJlcV8oJy4uLy4uLy4uL3V0aWxzLycpO1xuXG5yZWdpc3RlclByaW1pdGl2ZSgnYS1wbGFuZScsIHV0aWxzLmV4dGVuZERlZXAoe30sIGdldE1lc2hNaXhpbigpLCB7XG4gIGRlZmF1bHRBdHRyaWJ1dGVzOiB7XG4gICAgZ2VvbWV0cnk6IHtcbiAgICAgIHByaW1pdGl2ZTogJ3BsYW5lJ1xuICAgIH1cbiAgfSxcblxuICBtYXBwaW5nczoge1xuICAgIGhlaWdodDogJ2dlb21ldHJ5LmhlaWdodCcsXG4gICAgdHJhbnNsYXRlOiAnZ2VvbWV0cnkudHJhbnNsYXRlJyxcbiAgICB3aWR0aDogJ2dlb21ldHJ5LndpZHRoJ1xuICB9XG59KSk7XG5cbn0se1wiLi4vLi4vLi4vdXRpbHMvXCI6MTAyLFwiLi4vZ2V0TWVzaE1peGluXCI6NjYsXCIuLi9yZWdpc3RlclByaW1pdGl2ZVwiOjg3fV0sODE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIGdldE1lc2hNaXhpbiA9IF9kZXJlcV8oJy4uL2dldE1lc2hNaXhpbicpO1xudmFyIHJlZ2lzdGVyUHJpbWl0aXZlID0gX2RlcmVxXygnLi4vcmVnaXN0ZXJQcmltaXRpdmUnKTtcbnZhciB1dGlscyA9IF9kZXJlcV8oJy4uLy4uLy4uL3V0aWxzLycpO1xuXG5yZWdpc3RlclByaW1pdGl2ZSgnYS1yaW5nJywgdXRpbHMuZXh0ZW5kRGVlcCh7fSwgZ2V0TWVzaE1peGluKCksIHtcbiAgZGVmYXVsdEF0dHJpYnV0ZXM6IHtcbiAgICBnZW9tZXRyeToge1xuICAgICAgcHJpbWl0aXZlOiAncmluZydcbiAgICB9XG4gIH0sXG5cbiAgbWFwcGluZ3M6IHtcbiAgICAncmFkaXVzLWlubmVyJzogJ2dlb21ldHJ5LnJhZGl1c0lubmVyJyxcbiAgICAncmFkaXVzLW91dGVyJzogJ2dlb21ldHJ5LnJhZGl1c091dGVyJyxcbiAgICAnc2VnbWVudHMtcGhpJzogJ2dlb21ldHJ5LnNlZ21lbnRzLXBoaScsXG4gICAgJ3NlZ21lbnRzLXRoZXRhJzogJ2dlb21ldHJ5LnNlZ21lbnRzLXRoZXRhJyxcbiAgICAndGhldGEtbGVuZ3RoJzogJ2dlb21ldHJ5LnRoZXRhLWxlbmd0aCcsXG4gICAgJ3RoZXRhLXN0YXJ0JzogJ2dlb21ldHJ5LnRoZXRhLXN0YXJ0J1xuICB9XG59KSk7XG5cbn0se1wiLi4vLi4vLi4vdXRpbHMvXCI6MTAyLFwiLi4vZ2V0TWVzaE1peGluXCI6NjYsXCIuLi9yZWdpc3RlclByaW1pdGl2ZVwiOjg3fV0sODI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIGdldE1lc2hNaXhpbiA9IF9kZXJlcV8oJy4uL2dldE1lc2hNaXhpbicpO1xudmFyIHJlZ2lzdGVyUHJpbWl0aXZlID0gX2RlcmVxXygnLi4vcmVnaXN0ZXJQcmltaXRpdmUnKTtcbnZhciB1dGlscyA9IF9kZXJlcV8oJy4uLy4uLy4uL3V0aWxzLycpO1xuXG5yZWdpc3RlclByaW1pdGl2ZSgnYS1za3knLCB1dGlscy5leHRlbmREZWVwKHt9LCBnZXRNZXNoTWl4aW4oKSwge1xuICBkZWZhdWx0QXR0cmlidXRlczoge1xuICAgIGdlb21ldHJ5OiB7XG4gICAgICBwcmltaXRpdmU6ICdzcGhlcmUnLFxuICAgICAgcmFkaXVzOiA1MDAwLFxuICAgICAgc2VnbWVudHNXaWR0aDogNjQsXG4gICAgICBzZWdtZW50c0hlaWdodDogNjRcbiAgICB9LFxuICAgIG1hdGVyaWFsOiB7XG4gICAgICBjb2xvcjogJyNGRkYnLFxuICAgICAgc2hhZGVyOiAnZmxhdCdcbiAgICB9LFxuICAgIHNjYWxlOiAnLTEgMSAxJ1xuICB9LFxuXG4gIG1hcHBpbmdzOiB7XG4gICAgcmFkaXVzOiAnZ2VvbWV0cnkucmFkaXVzJyxcbiAgICAnc2VnbWVudHMtd2lkdGgnOiAnZ2VvbWV0cnkuc2VnbWVudHNXaWR0aCcsXG4gICAgJ3NlZ21lbnRzLWhlaWdodCc6ICdnZW9tZXRyeS5zZWdtZW50c0hlaWdodCdcbiAgfVxufSkpO1xuXG59LHtcIi4uLy4uLy4uL3V0aWxzL1wiOjEwMixcIi4uL2dldE1lc2hNaXhpblwiOjY2LFwiLi4vcmVnaXN0ZXJQcmltaXRpdmVcIjo4N31dLDgzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBnZXRNZXNoTWl4aW4gPSBfZGVyZXFfKCcuLi9nZXRNZXNoTWl4aW4nKTtcbnZhciByZWdpc3RlclByaW1pdGl2ZSA9IF9kZXJlcV8oJy4uL3JlZ2lzdGVyUHJpbWl0aXZlJyk7XG52YXIgdXRpbHMgPSBfZGVyZXFfKCcuLi8uLi8uLi91dGlscy8nKTtcblxucmVnaXN0ZXJQcmltaXRpdmUoJ2Etc3BoZXJlJywgdXRpbHMuZXh0ZW5kRGVlcCh7fSwgZ2V0TWVzaE1peGluKCksIHtcbiAgZGVmYXVsdEF0dHJpYnV0ZXM6IHtcbiAgICBnZW9tZXRyeToge1xuICAgICAgcHJpbWl0aXZlOiAnc3BoZXJlJ1xuICAgIH1cbiAgfSxcblxuICBtYXBwaW5nczoge1xuICAgIHJhZGl1czogJ2dlb21ldHJ5LnJhZGl1cycsXG4gICAgJ3NlZ21lbnRzLWhlaWdodCc6ICdnZW9tZXRyeS5zZWdtZW50c0hlaWdodCcsXG4gICAgJ3NlZ21lbnRzLXdpZHRoJzogJ2dlb21ldHJ5LnNlZ21lbnRzV2lkdGgnLFxuICAgIHRyYW5zbGF0ZTogJ2dlb21ldHJ5LnRyYW5zbGF0ZSdcbiAgfVxufSkpO1xuXG59LHtcIi4uLy4uLy4uL3V0aWxzL1wiOjEwMixcIi4uL2dldE1lc2hNaXhpblwiOjY2LFwiLi4vcmVnaXN0ZXJQcmltaXRpdmVcIjo4N31dLDg0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBnZXRNZXNoTWl4aW4gPSBfZGVyZXFfKCcuLi9nZXRNZXNoTWl4aW4nKTtcbnZhciByZWdpc3RlclByaW1pdGl2ZSA9IF9kZXJlcV8oJy4uL3JlZ2lzdGVyUHJpbWl0aXZlJyk7XG52YXIgdXRpbHMgPSBfZGVyZXFfKCcuLi8uLi8uLi91dGlscy8nKTtcblxucmVnaXN0ZXJQcmltaXRpdmUoJ2EtdG9ydXMnLCB1dGlscy5leHRlbmREZWVwKHt9LCBnZXRNZXNoTWl4aW4oKSwge1xuICBkZWZhdWx0QXR0cmlidXRlczoge1xuICAgIGdlb21ldHJ5OiB7XG4gICAgICBwcmltaXRpdmU6ICd0b3J1cydcbiAgICB9XG4gIH0sXG5cbiAgbWFwcGluZ3M6IHtcbiAgICAnYXJjJzogJ2dlb21ldHJ5LmFyYycsXG4gICAgJ3JhZGl1cyc6ICdnZW9tZXRyeS5yYWRpdXMnLFxuICAgICdyYWRpdXMtdHVidWxhcic6ICdnZW9tZXRyeS5yYWRpdXNUdWJ1bGFyJyxcbiAgICAnc2VnbWVudHMtcmFkaWFsJzogJ2dlb21ldHJ5LnNlZ21lbnRzUmFkaWFsJyxcbiAgICAnc2VnbWVudHMtdHVidWxhcic6ICdnZW9tZXRyeS5zZWdtZW50c1R1YnVsYXInXG4gIH1cbn0pKTtcblxufSx7XCIuLi8uLi8uLi91dGlscy9cIjoxMDIsXCIuLi9nZXRNZXNoTWl4aW5cIjo2NixcIi4uL3JlZ2lzdGVyUHJpbWl0aXZlXCI6ODd9XSw4NTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgZ2V0TWVzaE1peGluID0gX2RlcmVxXygnLi4vZ2V0TWVzaE1peGluJyk7XG52YXIgcmVnaXN0ZXJQcmltaXRpdmUgPSBfZGVyZXFfKCcuLi9yZWdpc3RlclByaW1pdGl2ZScpO1xudmFyIHV0aWxzID0gX2RlcmVxXygnLi4vLi4vLi4vdXRpbHMvJyk7XG5cbnJlZ2lzdGVyUHJpbWl0aXZlKCdhLXZpZGVvJywgdXRpbHMuZXh0ZW5kRGVlcCh7fSwgZ2V0TWVzaE1peGluKCksIHtcbiAgZGVmYXVsdEF0dHJpYnV0ZXM6IHtcbiAgICBnZW9tZXRyeToge1xuICAgICAgcHJpbWl0aXZlOiAncGxhbmUnXG4gICAgfSxcbiAgICBtYXRlcmlhbDoge1xuICAgICAgY29sb3I6ICcjRkZGJyxcbiAgICAgIHNoYWRlcjogJ2ZsYXQnLFxuICAgICAgc2lkZTogJ2RvdWJsZScsXG4gICAgICB0cmFuc3BhcmVudDogdHJ1ZVxuICAgIH1cbiAgfSxcblxuICBtYXBwaW5nczoge1xuICAgIGhlaWdodDogJ2dlb21ldHJ5LmhlaWdodCcsXG4gICAgdHJhbnNsYXRlOiAnZ2VvbWV0cnkudHJhbnNsYXRlJyxcbiAgICB3aWR0aDogJ2dlb21ldHJ5LndpZHRoJ1xuICB9XG59KSk7XG5cbn0se1wiLi4vLi4vLi4vdXRpbHMvXCI6MTAyLFwiLi4vZ2V0TWVzaE1peGluXCI6NjYsXCIuLi9yZWdpc3RlclByaW1pdGl2ZVwiOjg3fV0sODY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIGdldE1lc2hNaXhpbiA9IF9kZXJlcV8oJy4uL2dldE1lc2hNaXhpbicpO1xudmFyIHJlZ2lzdGVyUHJpbWl0aXZlID0gX2RlcmVxXygnLi4vcmVnaXN0ZXJQcmltaXRpdmUnKTtcbnZhciB1dGlscyA9IF9kZXJlcV8oJy4uLy4uLy4uL3V0aWxzLycpO1xuXG5yZWdpc3RlclByaW1pdGl2ZSgnYS12aWRlb3NwaGVyZScsIHV0aWxzLmV4dGVuZERlZXAoe30sIGdldE1lc2hNaXhpbigpLCB7XG4gIGRlZmF1bHRBdHRyaWJ1dGVzOiB7XG4gICAgZ2VvbWV0cnk6IHtcbiAgICAgIHByaW1pdGl2ZTogJ3NwaGVyZScsXG4gICAgICByYWRpdXM6IDUwMDAsXG4gICAgICBzZWdtZW50c1dpZHRoOiA2NCxcbiAgICAgIHNlZ21lbnRzSGVpZ2h0OiA2NFxuICAgIH0sXG4gICAgbWF0ZXJpYWw6IHtcbiAgICAgIGNvbG9yOiAnI0ZGRicsXG4gICAgICBzaGFkZXI6ICdmbGF0J1xuICAgIH0sXG4gICAgc2NhbGU6ICctMSAxIDEnXG4gIH0sXG5cbiAgbWFwcGluZ3M6IHtcbiAgICByYWRpdXM6ICdnZW9tZXRyeS5yYWRpdXMnLFxuICAgICdzZWdtZW50cy1oZWlnaHQnOiAnZ2VvbWV0cnkuc2VnbWVudHNIZWlnaHQnLFxuICAgICdzZWdtZW50cy13aWR0aCc6ICdnZW9tZXRyeS5zZWdtZW50c1dpZHRoJ1xuICB9XG59KSk7XG5cbn0se1wiLi4vLi4vLi4vdXRpbHMvXCI6MTAyLFwiLi4vZ2V0TWVzaE1peGluXCI6NjYsXCIuLi9yZWdpc3RlclByaW1pdGl2ZVwiOjg3fV0sODc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIEFFbnRpdHkgPSBfZGVyZXFfKCcuLi8uLi9jb3JlL2EtZW50aXR5Jyk7XG52YXIgY29tcG9uZW50cyA9IF9kZXJlcV8oJy4uLy4uL2NvcmUvY29tcG9uZW50JykuY29tcG9uZW50cztcbnZhciByZWdpc3RlckVsZW1lbnQgPSBfZGVyZXFfKCcuLi8uLi9jb3JlL2EtcmVnaXN0ZXItZWxlbWVudCcpLnJlZ2lzdGVyRWxlbWVudDtcbnZhciB1dGlscyA9IF9kZXJlcV8oJy4uLy4uL3V0aWxzLycpO1xuXG52YXIgZGVidWcgPSB1dGlscy5kZWJ1ZztcbnZhciBsb2cgPSBkZWJ1ZygnZXh0cmFzOnByaW1pdGl2ZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiByZWdpc3RlclByaW1pdGl2ZSAobmFtZSwgZGVmaW5pdGlvbikge1xuICBuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICBsb2coJ1JlZ2lzdGVyaW5nIDwlcz4nLCBuYW1lKTtcblxuICByZXR1cm4gcmVnaXN0ZXJFbGVtZW50KG5hbWUsIHtcbiAgICBwcm90b3R5cGU6IE9iamVjdC5jcmVhdGUoQUVudGl0eS5wcm90b3R5cGUsIHtcbiAgICAgIGRlZmF1bHRBdHRyaWJ1dGVzOiB7XG4gICAgICAgIHZhbHVlOiBkZWZpbml0aW9uLmRlZmF1bHRBdHRyaWJ1dGVzIHx8IHt9XG4gICAgICB9LFxuXG4gICAgICBkZXByZWNhdGVkOiB7XG4gICAgICAgIHZhbHVlOiBkZWZpbml0aW9uLmRlcHJlY2F0ZWQgfHwgbnVsbFxuICAgICAgfSxcblxuICAgICAgZGVwcmVjYXRlZE1hcHBpbmdzOiB7XG4gICAgICAgIHZhbHVlOiBkZWZpbml0aW9uLmRlcHJlY2F0ZWRNYXBwaW5ncyB8fCB7fVxuICAgICAgfSxcblxuICAgICAgbWFwcGluZ3M6IHtcbiAgICAgICAgdmFsdWU6IGRlZmluaXRpb24ubWFwcGluZ3MgfHwge31cbiAgICAgIH0sXG5cbiAgICAgIHRyYW5zZm9ybXM6IHtcbiAgICAgICAgdmFsdWU6IGRlZmluaXRpb24udHJhbnNmb3JtcyB8fCB7fVxuICAgICAgfSxcblxuICAgICAgY3JlYXRlZENhbGxiYWNrOiB7XG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy5jb21wb25lbnREYXRhID0ge307XG4gICAgICAgICAgaWYgKGRlZmluaXRpb24uZGVwcmVjYXRlZCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGRlZmluaXRpb24uZGVwcmVjYXRlZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBhdHRhY2hlZENhbGxiYWNrOiB7XG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgIHZhciBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzO1xuXG4gICAgICAgICAgLy8gQXBwbHkgZGVmYXVsdCBjb21wb25lbnRzLlxuICAgICAgICAgIHRoaXMuY29tcG9uZW50RGF0YSA9IGNsb25lT2JqZWN0KHRoaXMuZGVmYXVsdEF0dHJpYnV0ZXMpO1xuICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMuY29tcG9uZW50RGF0YSkuZm9yRWFjaChmdW5jdGlvbiAoY29tcG9uZW50TmFtZSkge1xuICAgICAgICAgICAgaWYgKCFzZWxmLmhhc0F0dHJpYnV0ZShjb21wb25lbnROYW1lKSkge1xuICAgICAgICAgICAgICBzZWxmLnNldEF0dHJpYnV0ZShjb21wb25lbnROYW1lLCBzZWxmLmNvbXBvbmVudERhdGFbY29tcG9uZW50TmFtZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gQXBwbHkgaW5pdGlhbCBhdHRyaWJ1dGVzLlxuICAgICAgICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWUpIHtcbiAgICAgICAgICAgIHZhciBhdHRyID0gYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXTtcbiAgICAgICAgICAgIHNlbGYuc3luY0F0dHJpYnV0ZVRvQ29tcG9uZW50KGF0dHIubmFtZSwgYXR0ci52YWx1ZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogU3luYyB0byBhdHRyaWJ1dGUgdG8gY29tcG9uZW50IHByb3BlcnR5IHdoZW5ldmVyIG1hcHBlZCBhdHRyaWJ1dGUgY2hhbmdlcy5cbiAgICAgICAqL1xuICAgICAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrOiB7XG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoYXR0ciwgb2xkVmFsLCBuZXdWYWwpIHtcbiAgICAgICAgICBpZiAoIXRoaXMubWFwcGluZ3NbYXR0cl0pIHtcbiAgICAgICAgICAgIEFFbnRpdHkucHJvdG90eXBlLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjay5jYWxsKHRoaXMsIGF0dHIsIG9sZFZhbCwgbmV3VmFsKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5zeW5jQXR0cmlidXRlVG9Db21wb25lbnQoYXR0ciwgbmV3VmFsKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBJZiBhdHRyaWJ1dGUgaXMgbWFwcGVkIHRvIGEgY29tcG9uZW50IHByb3BlcnR5LCBzZXQgdGhlIGNvbXBvbmVudCBwcm9wZXJ0eSB1c2luZ1xuICAgICAgICogdGhlIGF0dHJpYnV0ZSB2YWx1ZS5cbiAgICAgICAqL1xuICAgICAgc3luY0F0dHJpYnV0ZVRvQ29tcG9uZW50OiB7XG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoYXR0ciwgdmFsdWUpIHtcbiAgICAgICAgICB2YXIgY29tcG9uZW50TmFtZTtcbiAgICAgICAgICB2YXIgc3BsaXQ7XG4gICAgICAgICAgdmFyIHByb3BlcnR5TmFtZTtcblxuICAgICAgICAgIGlmIChhdHRyIGluIHRoaXMuZGVwcmVjYXRlZE1hcHBpbmdzKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4odGhpcy5kZXByZWNhdGVkTWFwcGluZ3NbYXR0cl0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghYXR0ciB8fCAhdGhpcy5tYXBwaW5nc1thdHRyXSkgeyByZXR1cm47IH1cblxuICAgICAgICAgIC8vIERpZmZlcmVudGlhdGUgYmV0d2VlbiBzaW5nbGUtcHJvcGVydHkgYW5kIG11bHRpLXByb3BlcnR5IGNvbXBvbmVudC5cbiAgICAgICAgICBjb21wb25lbnROYW1lID0gdGhpcy5tYXBwaW5nc1thdHRyXTtcbiAgICAgICAgICBpZiAoY29tcG9uZW50TmFtZS5pbmRleE9mKCcuJykgIT09IC0xKSB7XG4gICAgICAgICAgICBzcGxpdCA9IHRoaXMubWFwcGluZ3NbYXR0cl0uc3BsaXQoJy4nKTtcbiAgICAgICAgICAgIGNvbXBvbmVudE5hbWUgPSBzcGxpdFswXTtcbiAgICAgICAgICAgIHByb3BlcnR5TmFtZSA9IHNwbGl0WzFdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghY29tcG9uZW50c1tjb21wb25lbnROYW1lXSkgeyByZXR1cm47IH1cblxuICAgICAgICAgIC8vIFJ1biB0cmFuc2Zvcm0uXG4gICAgICAgICAgdmFsdWUgPSB0aGlzLmdldFRyYW5zZm9ybWVkVmFsdWUoYXR0ciwgdmFsdWUpO1xuXG4gICAgICAgICAgLy8gSW5pdGlhbGl6ZSBpbnRlcm5hbCBjb21wb25lbnQgZGF0YSBpZiBuZWNlc3NhcnkuXG4gICAgICAgICAgaWYgKCF0aGlzLmNvbXBvbmVudERhdGFbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50RGF0YVtjb21wb25lbnROYW1lXSA9IHRoaXMuZGVmYXVsdEF0dHJpYnV0ZXNbY29tcG9uZW50TmFtZV0gfHwge307XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gVXBkYXRlIGludGVybmFsIGNvbXBvbmVudCBkYXRhLlxuICAgICAgICAgIGlmIChwcm9wZXJ0eU5hbWUpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50RGF0YVtjb21wb25lbnROYW1lXVtwcm9wZXJ0eU5hbWVdID0gdmFsdWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50RGF0YVtjb21wb25lbnROYW1lXSA9IHZhbHVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFB1dCBjb21wb25lbnQgZGF0YS5cbiAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZShjb21wb25lbnROYW1lLCB0aGlzLmNvbXBvbmVudERhdGFbY29tcG9uZW50TmFtZV0pO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIENhbGxzIGRlZmluZWQgdHJhbnNmb3JtIGZ1bmN0aW9uIG9uIHZhbHVlIGlmIGFueS5cbiAgICAgICAqL1xuICAgICAgZ2V0VHJhbnNmb3JtZWRWYWx1ZToge1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKGF0dHIsIHZhbHVlKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLnRyYW5zZm9ybXMgfHwgIXRoaXMudHJhbnNmb3Jtc1thdHRyXSkgeyByZXR1cm4gdmFsdWU7IH1cbiAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1zW2F0dHJdLmJpbmQodGhpcykodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgfSk7XG59O1xuXG4vKipcbiAqIENsb25lIGFuIG9iamVjdCwgaW5jbHVkaW5nIGlubmVyIG9iamVjdHMgb25lLWxldmVsIGRlZXAuXG4gKiBVc2VkIGZvciBjb3B5aW5nIGRlZmF1bHRBdHRyaWJ1dGVzIHRvIGNvbXBvbmVudERhdGEgc28gcHJpbWl0aXZlcyBvZiB0aGUgc2FtZSB0eXBlIGRvbid0XG4gKiBhZmZlY3QgZWFjaCBvdGhlcnMnIGRlZmF1bHRBdHRyaWJ1dGVzIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gY2xvbmVPYmplY3QgKG9iaikge1xuICB2YXIgY2xvbmUgPSB7fTtcbiAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgdmFsdWUgPSBvYmpba2V5XTtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgY2xvbmVba2V5XSA9IHV0aWxzLmV4dGVuZCh7fSwgdmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjbG9uZVtrZXldID0gdmFsdWU7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGNsb25lO1xufVxuXG59LHtcIi4uLy4uL2NvcmUvYS1lbnRpdHlcIjo1MixcIi4uLy4uL2NvcmUvYS1yZWdpc3Rlci1lbGVtZW50XCI6NTUsXCIuLi8uLi9jb3JlL2NvbXBvbmVudFwiOjU2LFwiLi4vLi4vdXRpbHMvXCI6MTAyfV0sODg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLy8gUG9seWZpbGwgYFByb21pc2VgLlxud2luZG93LlByb21pc2UgPSB3aW5kb3cuUHJvbWlzZSB8fCBfZGVyZXFfKCdwcm9taXNlLXBvbHlmaWxsJyk7XG5cbl9kZXJlcV8oJ3ByZXNlbnQnKTsgLy8gUG9seWZpbGwgYHBlcmZvcm1hbmNlLm5vdygpYC5cbi8vIENTUy5cbl9kZXJlcV8oJy4vc3R5bGUvYWZyYW1lLmNzcycpO1xuX2RlcmVxXygnLi9zdHlsZS9yU3RhdHMuY3NzJyk7XG5cbi8vIFJlcXVpcmVkIGJlZm9yZSBgQUVudGl0eWAgc28gdGhhdCBhbGwgY29tcG9uZW50cyBhcmUgcmVnaXN0ZXJlZC5cbnZhciBBU2NlbmUgPSBfZGVyZXFfKCcuL2NvcmUvc2NlbmUvYS1zY2VuZScpO1xudmFyIGNvbXBvbmVudHMgPSBfZGVyZXFfKCcuL2NvcmUvY29tcG9uZW50JykuY29tcG9uZW50cztcbnZhciByZWdpc3RlckNvbXBvbmVudCA9IF9kZXJlcV8oJy4vY29yZS9jb21wb25lbnQnKS5yZWdpc3RlckNvbXBvbmVudDtcbnZhciByZWdpc3RlclByaW1pdGl2ZSA9IF9kZXJlcV8oJy4vZXh0cmFzL3ByaW1pdGl2ZXMvcmVnaXN0ZXJQcmltaXRpdmUnKTtcbnZhciByZWdpc3RlclNoYWRlciA9IF9kZXJlcV8oJy4vY29yZS9zaGFkZXInKS5yZWdpc3RlclNoYWRlcjtcbnZhciByZWdpc3RlclN5c3RlbSA9IF9kZXJlcV8oJy4vY29yZS9zeXN0ZW0nKS5yZWdpc3RlclN5c3RlbTtcbnZhciBzaGFkZXJzID0gX2RlcmVxXygnLi9jb3JlL3NoYWRlcicpLnNoYWRlcnM7XG52YXIgc3lzdGVtcyA9IF9kZXJlcV8oJy4vY29yZS9zeXN0ZW0nKS5zeXN0ZW1zO1xuLy8gRXhwb3J0cyBUSFJFRSB0byB3aW5kb3cgc28gdGhyZWUuanMgY2FuIGJlIHVzZWQgd2l0aG91dCBhbHRlcmF0aW9uLlxudmFyIFRIUkVFID0gd2luZG93LlRIUkVFID0gX2RlcmVxXygnLi9saWIvdGhyZWUnKTtcbnZhciBUV0VFTiA9IHdpbmRvdy5UV0VFTiA9IF9kZXJlcV8oJ3R3ZWVuLmpzJyk7XG5cbnZhciBwa2cgPSBfZGVyZXFfKCcuLi9wYWNrYWdlJyk7XG52YXIgdXRpbHMgPSBfZGVyZXFfKCcuL3V0aWxzLycpO1xuXG5fZGVyZXFfKCcuL3N5c3RlbXMvaW5kZXgnKTsgLy8gUmVnaXN0ZXIgY29yZSBzeXN0ZW1zLlxuX2RlcmVxXygnLi9jb21wb25lbnRzL2luZGV4Jyk7IC8vIFJlZ2lzdGVyIGNvcmUgY29tcG9uZW50cy5cbl9kZXJlcV8oJy4vc2hhZGVycy9pbmRleCcpOyAvLyBSZWdpc3RlciBjb3JlIHNoYWRlcnMuXG52YXIgQU5vZGUgPSBfZGVyZXFfKCcuL2NvcmUvYS1ub2RlJyk7XG52YXIgQUVudGl0eSA9IF9kZXJlcV8oJy4vY29yZS9hLWVudGl0eScpOyAvLyBEZXBlbmRzIG9uIEFOb2RlIGFuZCBjb3JlIGNvbXBvbmVudHMuXG5cbi8vIFdlYnZyIHBvbHlmaWxsIGNvbmZpZ3VyYXRpb24uXG53aW5kb3cuaGFzTm9uUG9seWZpbGxXZWJWUlN1cHBvcnQgPSAhIW5hdmlnYXRvci5nZXRWUkRldmljZXM7XG53aW5kb3cuV2ViVlJDb25maWcgPSB7XG4gIFRPVUNIX1BBTk5FUl9ESVNBQkxFRDogdHJ1ZSxcbiAgTU9VU0VfS0VZQk9BUkRfQ09OVFJPTFNfRElTQUJMRUQ6IHRydWVcbn07XG5fZGVyZXFfKCd3ZWJ2ci1wb2x5ZmlsbCcpO1xuXG5fZGVyZXFfKCcuL2NvcmUvYS1hbmltYXRpb24nKTtcbl9kZXJlcV8oJy4vY29yZS9hLWFzc2V0cycpO1xuX2RlcmVxXygnLi9jb3JlL2EtY3ViZW1hcCcpO1xuX2RlcmVxXygnLi9jb3JlL2EtbWl4aW4nKTtcblxuLy8gRXh0cmFzLlxuX2RlcmVxXygnLi9leHRyYXMvZGVjbGFyYXRpdmUtZXZlbnRzLycpO1xuX2RlcmVxXygnLi9leHRyYXMvcHJpbWl0aXZlcy8nKTtcblxuY29uc29sZS5sb2coJ0EtRnJhbWUgVmVyc2lvbjonLCBwa2cudmVyc2lvbik7XG5jb25zb2xlLmxvZygndGhyZWUgVmVyc2lvbjonLCBwa2cuZGVwZW5kZW5jaWVzWyd0aHJlZSddKTtcbmNvbnNvbGUubG9nKCdXZWJWUiBQb2x5ZmlsbCBWZXJzaW9uOicsIHBrZy5kZXBlbmRlbmNpZXNbJ3dlYnZyLXBvbHlmaWxsJ10pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHdpbmRvdy5BRlJBTUUgPSB7XG4gIEFFbnRpdHk6IEFFbnRpdHksXG4gIEFOb2RlOiBBTm9kZSxcbiAgQVNjZW5lOiBBU2NlbmUsXG4gIGNvbXBvbmVudHM6IGNvbXBvbmVudHMsXG4gIHJlZ2lzdGVyQ29tcG9uZW50OiByZWdpc3RlckNvbXBvbmVudCxcbiAgcmVnaXN0ZXJTaGFkZXI6IHJlZ2lzdGVyU2hhZGVyLFxuICByZWdpc3RlclN5c3RlbTogcmVnaXN0ZXJTeXN0ZW0sXG4gIHJlZ2lzdGVyUHJpbWl0aXZlOiByZWdpc3RlclByaW1pdGl2ZSxcbiAgc2hhZGVyczogc2hhZGVycyxcbiAgc3lzdGVtczogc3lzdGVtcyxcbiAgVEhSRUU6IFRIUkVFLFxuICBUV0VFTjogVFdFRU4sXG4gIHV0aWxzOiB1dGlscyxcbiAgdmVyc2lvbjogcGtnLnZlcnNpb25cbn07XG5cbn0se1wiLi4vcGFja2FnZVwiOjI0LFwiLi9jb21wb25lbnRzL2luZGV4XCI6MjksXCIuL2NvcmUvYS1hbmltYXRpb25cIjo0OSxcIi4vY29yZS9hLWFzc2V0c1wiOjUwLFwiLi9jb3JlL2EtY3ViZW1hcFwiOjUxLFwiLi9jb3JlL2EtZW50aXR5XCI6NTIsXCIuL2NvcmUvYS1taXhpblwiOjUzLFwiLi9jb3JlL2Etbm9kZVwiOjU0LFwiLi9jb3JlL2NvbXBvbmVudFwiOjU2LFwiLi9jb3JlL3NjZW5lL2Etc2NlbmVcIjo1OCxcIi4vY29yZS9zaGFkZXJcIjo2MyxcIi4vY29yZS9zeXN0ZW1cIjo2NCxcIi4vZXh0cmFzL2RlY2xhcmF0aXZlLWV2ZW50cy9cIjo2NSxcIi4vZXh0cmFzL3ByaW1pdGl2ZXMvXCI6NjcsXCIuL2V4dHJhcy9wcmltaXRpdmVzL3JlZ2lzdGVyUHJpbWl0aXZlXCI6ODcsXCIuL2xpYi90aHJlZVwiOjkwLFwiLi9zaGFkZXJzL2luZGV4XCI6OTIsXCIuL3N0eWxlL2FmcmFtZS5jc3NcIjo5NCxcIi4vc3R5bGUvclN0YXRzLmNzc1wiOjk1LFwiLi9zeXN0ZW1zL2luZGV4XCI6OTcsXCIuL3V0aWxzL1wiOjEwMixcInByZXNlbnRcIjoxMCxcInByb21pc2UtcG9seWZpbGxcIjoxMSxcInR3ZWVuLmpzXCI6MjIsXCJ3ZWJ2ci1wb2x5ZmlsbFwiOjIzfV0sODk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xud2luZG93LmFmcmFtZVN0YXRzID0gZnVuY3Rpb24gKHNjZW5lKSB7XHJcbiAgdmFyIF9yUyA9IG51bGw7XHJcbiAgdmFyIF9zY2VuZSA9IHNjZW5lO1xyXG4gIHZhciBfdmFsdWVzID0ge1xyXG4gICAgdGU6IHtcclxuICAgICAgY2FwdGlvbjogJ0VudGl0aWVzJ1xyXG4gICAgfSxcclxuICAgIGx0OiB7XHJcbiAgICAgIGNhcHRpb246ICdMb2FkIFRpbWUnXHJcbiAgICB9XHJcbiAgfTtcclxuICB2YXIgX2dyb3VwcyA9IFsge1xyXG4gICAgY2FwdGlvbjogJ0EtRnJhbWUnLFxyXG4gICAgdmFsdWVzOiBbICd0ZScsICdsdCcgXVxyXG4gIH0gXTtcclxuXHJcbiAgZnVuY3Rpb24gX3VwZGF0ZSAoKSB7XHJcbiAgICBfclMoJ3RlJykuc2V0KF9zY2VuZS5xdWVyeVNlbGVjdG9yQWxsKCdhLWVudGl0eScpLmxlbmd0aCk7XHJcbiAgICBfclMoJ2x0Jykuc2V0KHdpbmRvdy5wZXJmb3JtYW5jZS5nZXRFbnRyaWVzQnlOYW1lKCdyZW5kZXItc3RhcnRlZCcpWzBdLnN0YXJ0VGltZS50b0ZpeGVkKDApKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIF9zdGFydCAoKSB7fVxyXG5cclxuICBmdW5jdGlvbiBfZW5kICgpIHt9XHJcblxyXG4gIGZ1bmN0aW9uIF9hdHRhY2ggKHIpIHtcclxuICAgIF9yUyA9IHI7XHJcbiAgfVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgdXBkYXRlOiBfdXBkYXRlLFxyXG4gICAgc3RhcnQ6IF9zdGFydCxcclxuICAgIGVuZDogX2VuZCxcclxuICAgIGF0dGFjaDogX2F0dGFjaCxcclxuICAgIHZhbHVlczogX3ZhbHVlcyxcclxuICAgIGdyb3VwczogX2dyb3VwcyxcclxuICAgIGZyYWN0aW9uczogW11cclxuICB9O1xyXG59O1xyXG5cclxuaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKSB7XHJcbiAgbW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBhZnJhbWVTdGF0czogd2luZG93LmFmcmFtZVN0YXRzXHJcbiAgfTtcclxufVxyXG5cbn0se31dLDkwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbnZhciBUSFJFRSA9IGdsb2JhbC5USFJFRSA9IF9kZXJlcV8oJ3RocmVlJyk7XG5cbi8vIEFsbG93IGNyb3NzLW9yaWdpbiBpbWFnZXMgdG8gYmUgbG9hZGVkLlxuXG4vLyBUaGlzIHNob3VsZCBub3QgYmUgb24gYFRIUkVFLkxvYWRlcmAgbm9yIGBUSFJFRS5JbWFnZVV0aWxzYC5cbi8vIE11c3QgYmUgb24gYFRIUkVFLlRleHR1cmVMb2FkZXJgLlxuaWYgKFRIUkVFLlRleHR1cmVMb2FkZXIpIHtcbiAgVEhSRUUuVGV4dHVyZUxvYWRlci5wcm90b3R5cGUuY3Jvc3NPcmlnaW4gPSAnJztcbn1cblxuLy8gVGhpcyBpcyBmb3IgaW1hZ2VzIGxvYWRlZCBmcm9tIHRoZSBtb2RlbCBsb2FkZXJzLlxuaWYgKFRIUkVFLkltYWdlTG9hZGVyKSB7XG4gIFRIUkVFLkltYWdlTG9hZGVyLnByb3RvdHlwZS5jcm9zc09yaWdpbiA9ICcnO1xufVxuXG4vLyBJbi1tZW1vcnkgY2FjaGluZyBmb3IgWEhScyAoZm9yIGltYWdlcywgYXVkaW8gZmlsZXMsIHRleHR1cmVzLCBldGMuKS5cbmlmIChUSFJFRS5DYWNoZSkge1xuICBUSFJFRS5DYWNoZS5lbmFibGVkID0gdHJ1ZTtcbn1cblxuLy8gVE9ETzogRXZlbnR1YWxseSBpbmNsdWRlIHRoZXNlIG9ubHkgaWYgdGhleSBhcmUgbmVlZGVkIGJ5IGEgY29tcG9uZW50LlxuX2RlcmVxXygnLi4vLi4vbm9kZV9tb2R1bGVzL3RocmVlL2V4YW1wbGVzL2pzL2xvYWRlcnMvT0JKTG9hZGVyJyk7ICAvLyBUSFJFRS5PQkpMb2FkZXJcbl9kZXJlcV8oJy4uLy4uL25vZGVfbW9kdWxlcy90aHJlZS9leGFtcGxlcy9qcy9sb2FkZXJzL01UTExvYWRlcicpOyAgLy8gVEhSRUUuTVRMTG9hZGVyXG5fZGVyZXFfKCcuLi8uLi9ub2RlX21vZHVsZXMvdGhyZWUvZXhhbXBsZXMvanMvbG9hZGVycy9Db2xsYWRhTG9hZGVyJyk7ICAvLyBUSFJFRS5Db2xsYWRhTG9hZGVyXG5fZGVyZXFfKCcuLi8uLi9ub2RlX21vZHVsZXMvdGhyZWUvZXhhbXBsZXMvanMvY29udHJvbHMvVlJDb250cm9scycpOyAgLy8gVEhSRUUuVlJDb250cm9sc1xuX2RlcmVxXygnLi4vLi4vbm9kZV9tb2R1bGVzL3RocmVlL2V4YW1wbGVzL2pzL2VmZmVjdHMvVlJFZmZlY3QnKTsgIC8vIFRIUkVFLlZSRWZmZWN0XG5cbm1vZHVsZS5leHBvcnRzID0gVEhSRUU7XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHtcIi4uLy4uL25vZGVfbW9kdWxlcy90aHJlZS9leGFtcGxlcy9qcy9jb250cm9scy9WUkNvbnRyb2xzXCI6MTYsXCIuLi8uLi9ub2RlX21vZHVsZXMvdGhyZWUvZXhhbXBsZXMvanMvZWZmZWN0cy9WUkVmZmVjdFwiOjE3LFwiLi4vLi4vbm9kZV9tb2R1bGVzL3RocmVlL2V4YW1wbGVzL2pzL2xvYWRlcnMvQ29sbGFkYUxvYWRlclwiOjE4LFwiLi4vLi4vbm9kZV9tb2R1bGVzL3RocmVlL2V4YW1wbGVzL2pzL2xvYWRlcnMvTVRMTG9hZGVyXCI6MTksXCIuLi8uLi9ub2RlX21vZHVsZXMvdGhyZWUvZXhhbXBsZXMvanMvbG9hZGVycy9PQkpMb2FkZXJcIjoyMCxcInRocmVlXCI6MjF9XSw5MTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgcmVnaXN0ZXJTaGFkZXIgPSBfZGVyZXFfKCcuLi9jb3JlL3NoYWRlcicpLnJlZ2lzdGVyU2hhZGVyO1xyXG52YXIgc3JjTG9hZGVyID0gX2RlcmVxXygnLi4vdXRpbHMvc3JjLWxvYWRlcicpO1xyXG52YXIgVEhSRUUgPSBfZGVyZXFfKCcuLi9saWIvdGhyZWUnKTtcclxudmFyIHV0aWxzID0gX2RlcmVxXygnLi4vdXRpbHMvdGV4dHVyZScpO1xyXG5cclxuLyoqXHJcbiAqIEZsYXQgc2hhZGVyIHVzaW5nIFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsLlxyXG4gKi9cclxubW9kdWxlLmV4cG9ydHMuQ29tcG9uZW50ID0gcmVnaXN0ZXJTaGFkZXIoJ2ZsYXQnLCB7XHJcbiAgc2NoZW1hOiB7XHJcbiAgICBjb2xvcjogeyB0eXBlOiAnY29sb3InIH0sXHJcbiAgICBmb2c6IHsgZGVmYXVsdDogdHJ1ZSB9LFxyXG4gICAgaGVpZ2h0OiB7IGRlZmF1bHQ6IDI1NiB9LFxyXG4gICAgcmVwZWF0OiB7IGRlZmF1bHQ6ICcnIH0sXHJcbiAgICBzcmM6IHsgZGVmYXVsdDogJycgfSxcclxuICAgIHdpZHRoOiB7IGRlZmF1bHQ6IDUxMiB9XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogSW5pdGlhbGl6ZXMgdGhlIHNoYWRlci5cclxuICAgKiBBZGRzIGEgcmVmZXJlbmNlIGZyb20gdGhlIHNjZW5lIHRvIHRoaXMgZW50aXR5IGFzIHRoZSBjYW1lcmEuXHJcbiAgICovXHJcbiAgaW5pdDogZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgIHRoaXMudGV4dHVyZVNyYyA9IG51bGw7XHJcbiAgICB0aGlzLm1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKGdldE1hdGVyaWFsRGF0YShkYXRhKSk7XHJcbiAgICB0aGlzLnVwZGF0ZVRleHR1cmUoZGF0YSk7XHJcbiAgICByZXR1cm4gdGhpcy5tYXRlcmlhbDtcclxuICB9LFxyXG5cclxuICB1cGRhdGU6IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICB0aGlzLnVwZGF0ZU1hdGVyaWFsKGRhdGEpO1xyXG4gICAgdGhpcy51cGRhdGVUZXh0dXJlKGRhdGEpO1xyXG4gICAgcmV0dXJuIHRoaXMubWF0ZXJpYWw7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlIG9yIGNyZWF0ZSBtYXRlcmlhbC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fG51bGx9IG9sZERhdGFcclxuICAgKi9cclxuICB1cGRhdGVUZXh0dXJlOiBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgdmFyIHNyYyA9IGRhdGEuc3JjO1xyXG4gICAgdmFyIG1hdGVyaWFsID0gdGhpcy5tYXRlcmlhbDtcclxuICAgIGlmIChzcmMpIHtcclxuICAgICAgaWYgKHNyYyA9PT0gdGhpcy50ZXh0dXJlU3JjKSB7IHJldHVybjsgfVxyXG4gICAgICAvLyBUZXh0dXJlIGFkZGVkIG9yIGNoYW5nZWQuXHJcbiAgICAgIHRoaXMudGV4dHVyZVNyYyA9IHNyYztcclxuICAgICAgc3JjTG9hZGVyLnZhbGlkYXRlU3JjKHNyYyxcclxuICAgICAgICB1dGlscy5sb2FkSW1hZ2UuYmluZCh0aGlzLCBtYXRlcmlhbCwgZGF0YSksXHJcbiAgICAgICAgdXRpbHMubG9hZFZpZGVvLmJpbmQodGhpcywgbWF0ZXJpYWwsIGRhdGEpXHJcbiAgICAgICk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBUZXh0dXJlIHJlbW92ZWQuXHJcbiAgICAgIHV0aWxzLnVwZGF0ZU1hdGVyaWFsKG1hdGVyaWFsLCBudWxsKTtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGluZyBleGlzdGluZyBtYXRlcmlhbC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhIC0gTWF0ZXJpYWwgY29tcG9uZW50IGRhdGEuXHJcbiAgICovXHJcbiAgdXBkYXRlTWF0ZXJpYWw6IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICB2YXIgbWF0ZXJpYWwgPSB0aGlzLm1hdGVyaWFsO1xyXG4gICAgZGF0YSA9IGdldE1hdGVyaWFsRGF0YShkYXRhKTtcclxuICAgIE9iamVjdC5rZXlzKGRhdGEpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICBtYXRlcmlhbFtrZXldID0gZGF0YVtrZXldO1xyXG4gICAgfSk7XHJcbiAgfVxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBCdWlsZHMgYW5kIG5vcm1hbGl6ZSBtYXRlcmlhbCBkYXRhLCBub3JtYWxpemluZyBzdHVmZiBhbG9uZyB0aGUgd2F5LlxyXG4gKlxyXG4gKiBAcGFyYW0ge29iamVjdH0gZGF0YSAtIE1hdGVyaWFsIGRhdGEuXHJcbiAqIEByZXR1cm5zIHtvYmplY3R9IGRhdGEgLSBQcm9jZXNzZWQgbWF0ZXJpYWwgZGF0YS5cclxuICovXHJcbmZ1bmN0aW9uIGdldE1hdGVyaWFsRGF0YSAoZGF0YSkge1xyXG4gIHZhciBtYXRlcmlhbERhdGEgPSB7XHJcbiAgICBmb2c6IGRhdGEuZm9nLFxyXG4gICAgY29sb3I6IG5ldyBUSFJFRS5Db2xvcihkYXRhLmNvbG9yKVxyXG4gIH07XHJcbiAgcmV0dXJuIG1hdGVyaWFsRGF0YTtcclxufVxyXG5cbn0se1wiLi4vY29yZS9zaGFkZXJcIjo2MyxcIi4uL2xpYi90aHJlZVwiOjkwLFwiLi4vdXRpbHMvc3JjLWxvYWRlclwiOjEwMyxcIi4uL3V0aWxzL3RleHR1cmVcIjoxMDV9XSw5MjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5fZGVyZXFfKCcuL2ZsYXQnKTtcbl9kZXJlcV8oJy4vc3RhbmRhcmQnKTtcblxufSx7XCIuL2ZsYXRcIjo5MSxcIi4vc3RhbmRhcmRcIjo5M31dLDkzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciByZWdpc3RlclNoYWRlciA9IF9kZXJlcV8oJy4uL2NvcmUvc2hhZGVyJykucmVnaXN0ZXJTaGFkZXI7XG52YXIgc3JjTG9hZGVyID0gX2RlcmVxXygnLi4vdXRpbHMvc3JjLWxvYWRlcicpO1xudmFyIFRIUkVFID0gX2RlcmVxXygnLi4vbGliL3RocmVlJyk7XG52YXIgdXRpbHMgPSBfZGVyZXFfKCcuLi91dGlscy8nKTtcblxudmFyIEN1YmVMb2FkZXIgPSBuZXcgVEhSRUUuQ3ViZVRleHR1cmVMb2FkZXIoKTtcbnZhciB0ZXh0dXJlUHJvbWlzZXMgPSB7fTtcblxuLyoqXG4gKiBTdGFuZGFyZCAocGh5c2ljYWxseS1iYXNlZCkgc2hhZGVyIHVzaW5nIFRIUkVFLk1lc2hTdGFuZGFyZE1hdGVyaWFsLlxuICovXG5tb2R1bGUuZXhwb3J0cy5Db21wb25lbnQgPSByZWdpc3RlclNoYWRlcignc3RhbmRhcmQnLCB7XG4gIHNjaGVtYToge1xuICAgIGNvbG9yOiB7IHR5cGU6ICdjb2xvcicgfSxcbiAgICBlbnZNYXA6IHsgZGVmYXVsdDogJycgfSxcbiAgICBmb2c6IHsgZGVmYXVsdDogdHJ1ZSB9LFxuICAgIGhlaWdodDogeyBkZWZhdWx0OiAyNTYgfSxcbiAgICBtZXRhbG5lc3M6IHsgZGVmYXVsdDogMC4wLCBtaW46IDAuMCwgbWF4OiAxLjAgfSxcbiAgICByZXBlYXQ6IHsgZGVmYXVsdDogJycgfSxcbiAgICBzcmM6IHsgZGVmYXVsdDogJycgfSxcbiAgICByb3VnaG5lc3M6IHsgZGVmYXVsdDogMC41LCBtaW46IDAuMCwgbWF4OiAxLjAgfSxcbiAgICB3aWR0aDogeyBkZWZhdWx0OiA1MTIgfVxuICB9LFxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIHNoYWRlci5cbiAgICogQWRkcyBhIHJlZmVyZW5jZSBmcm9tIHRoZSBzY2VuZSB0byB0aGlzIGVudGl0eSBhcyB0aGUgY2FtZXJhLlxuICAgKi9cbiAgaW5pdDogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB0aGlzLm1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hTdGFuZGFyZE1hdGVyaWFsKGdldE1hdGVyaWFsRGF0YShkYXRhKSk7XG4gICAgdGhpcy51cGRhdGVUZXh0dXJlKGRhdGEpO1xuICAgIHRoaXMudXBkYXRlRW52TWFwKGRhdGEpO1xuICAgIHJldHVybiB0aGlzLm1hdGVyaWFsO1xuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB0aGlzLnVwZGF0ZU1hdGVyaWFsKGRhdGEpO1xuICAgIHRoaXMudXBkYXRlVGV4dHVyZShkYXRhKTtcbiAgICB0aGlzLnVwZGF0ZUVudk1hcChkYXRhKTtcbiAgICByZXR1cm4gdGhpcy5tYXRlcmlhbDtcbiAgfSxcblxuICAvKipcbiAgICogVXBkYXRlIG9yIGNyZWF0ZSBtYXRlcmlhbC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R8bnVsbH0gb2xkRGF0YVxuICAgKi9cbiAgdXBkYXRlVGV4dHVyZTogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgc3JjID0gZGF0YS5zcmM7XG4gICAgdmFyIG1hdGVyaWFsID0gdGhpcy5tYXRlcmlhbDtcbiAgICBpZiAoc3JjKSB7XG4gICAgICBpZiAoc3JjID09PSB0aGlzLnRleHR1cmVTcmMpIHsgcmV0dXJuOyB9XG4gICAgICAvLyBUZXh0dXJlIGFkZGVkIG9yIGNoYW5nZWQuXG4gICAgICB0aGlzLnRleHR1cmVTcmMgPSBzcmM7XG4gICAgICBzcmNMb2FkZXIudmFsaWRhdGVTcmMoc3JjLFxuICAgICAgICB1dGlscy50ZXh0dXJlLmxvYWRJbWFnZS5iaW5kKHRoaXMsIG1hdGVyaWFsLCBkYXRhKSxcbiAgICAgICAgdXRpbHMudGV4dHVyZS5sb2FkVmlkZW8uYmluZCh0aGlzLCBtYXRlcmlhbCwgZGF0YSlcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRleHR1cmUgcmVtb3ZlZC5cbiAgICAgIHV0aWxzLnRleHR1cmUudXBkYXRlTWF0ZXJpYWwobWF0ZXJpYWwsIG51bGwpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogVXBkYXRpbmcgZXhpc3RpbmcgbWF0ZXJpYWwuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhIC0gTWF0ZXJpYWwgY29tcG9uZW50IGRhdGEuXG4gICAqIEByZXR1cm5zIHtvYmplY3R9IE1hdGVyaWFsLlxuICAgKi9cbiAgdXBkYXRlTWF0ZXJpYWw6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIG1hdGVyaWFsID0gdGhpcy5tYXRlcmlhbDtcbiAgICBkYXRhID0gZ2V0TWF0ZXJpYWxEYXRhKGRhdGEpO1xuICAgIE9iamVjdC5rZXlzKGRhdGEpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgbWF0ZXJpYWxba2V5XSA9IGRhdGFba2V5XTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogSGFuZGxlIGVudmlyb25tZW50IGN1YmVtYXAuIFRleHR1cmVzIGFyZSBjYWNoZWQgaW4gdGV4dHVyZVByb21pc2VzLlxuICAgKi9cbiAgdXBkYXRlRW52TWFwOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgbWF0ZXJpYWwgPSB0aGlzLm1hdGVyaWFsO1xuICAgIHZhciBlbnZNYXAgPSBkYXRhLmVudk1hcDtcblxuICAgIC8vIE5vIGVudk1hcCBkZWZpbmVkIG9yIGFscmVhZHkgbG9hZGluZy5cbiAgICBpZiAoIWVudk1hcCB8fCB0aGlzLmlzTG9hZGluZ0Vudk1hcCkge1xuICAgICAgbWF0ZXJpYWwuZW52TWFwID0gbnVsbDtcbiAgICAgIG1hdGVyaWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5pc0xvYWRpbmdFbnZNYXAgPSB0cnVlO1xuXG4gICAgLy8gQW5vdGhlciBtYXRlcmlhbCBpcyBhbHJlYWR5IGxvYWRpbmcgdGhpcyB0ZXh0dXJlLiBXYWl0IG9uIHByb21pc2UuXG4gICAgaWYgKHRleHR1cmVQcm9taXNlc1tlbnZNYXBdKSB7XG4gICAgICB0ZXh0dXJlUHJvbWlzZXNbZW52TWFwXS50aGVuKGZ1bmN0aW9uIChjdWJlKSB7XG4gICAgICAgIHNlbGYuaXNMb2FkaW5nRW52TWFwID0gZmFsc2U7XG4gICAgICAgIG1hdGVyaWFsLmVudk1hcCA9IGN1YmU7XG4gICAgICAgIG1hdGVyaWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIE1hdGVyaWFsIGlzIGZpcnN0IHRvIGxvYWQgdGhpcyB0ZXh0dXJlLiBMb2FkIGFuZCByZXNvbHZlIHRleHR1cmUuXG4gICAgdGV4dHVyZVByb21pc2VzW2Vudk1hcF0gPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgc3JjTG9hZGVyLnZhbGlkYXRlQ3ViZW1hcFNyYyhlbnZNYXAsIGZ1bmN0aW9uIGxvYWRFbnZNYXAgKHVybHMpIHtcbiAgICAgICAgQ3ViZUxvYWRlci5sb2FkKHVybHMsIGZ1bmN0aW9uIChjdWJlKSB7XG4gICAgICAgICAgLy8gVGV4dHVyZSBsb2FkZWQuXG4gICAgICAgICAgc2VsZi5pc0xvYWRpbmdFbnZNYXAgPSBmYWxzZTtcbiAgICAgICAgICBtYXRlcmlhbC5lbnZNYXAgPSBjdWJlO1xuICAgICAgICAgIHJlc29sdmUoY3ViZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn0pO1xuXG4vKipcbiAqIEJ1aWxkcyBhbmQgbm9ybWFsaXplIG1hdGVyaWFsIGRhdGEsIG5vcm1hbGl6aW5nIHN0dWZmIGFsb25nIHRoZSB3YXkuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGRhdGEgLSBNYXRlcmlhbCBkYXRhLlxuICogQHJldHVybnMge29iamVjdH0gZGF0YSAtIFByb2Nlc3NlZCBtYXRlcmlhbCBkYXRhLlxuICovXG5mdW5jdGlvbiBnZXRNYXRlcmlhbERhdGEgKGRhdGEpIHtcbiAgdmFyIG1hdGVyaWFsRGF0YSA9IHtcbiAgICBjb2xvcjogbmV3IFRIUkVFLkNvbG9yKGRhdGEuY29sb3IpLFxuICAgIG1ldGFsbmVzczogZGF0YS5tZXRhbG5lc3MsXG4gICAgcm91Z2huZXNzOiBkYXRhLnJvdWdobmVzc1xuICB9O1xuICByZXR1cm4gbWF0ZXJpYWxEYXRhO1xufVxuXG59LHtcIi4uL2NvcmUvc2hhZGVyXCI6NjMsXCIuLi9saWIvdGhyZWVcIjo5MCxcIi4uL3V0aWxzL1wiOjEwMixcIi4uL3V0aWxzL3NyYy1sb2FkZXJcIjoxMDN9XSw5NDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgY3NzID0gXCJodG1se2JvdHRvbTowO2xlZnQ6MDtwb3NpdGlvbjpmaXhlZDtyaWdodDowO3RvcDowfWJvZHl7aGVpZ2h0OjEwMCU7bWFyZ2luOjA7b3ZlcmZsb3c6aGlkZGVuO3BhZGRpbmc6MDt3aWR0aDoxMDAlfS5hLWhpZGRlbntkaXNwbGF5Om5vbmUhaW1wb3J0YW50fS5hLWNhbnZhc3toZWlnaHQ6MTAwJTtsZWZ0OjA7cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7d2lkdGg6MTAwJX1hLWFzc2V0cyxhLXNjZW5lIGltZyxhLXNjZW5lIHZpZGVve2Rpc3BsYXk6bm9uZX0uYS1lbnRlci12cnthbGlnbi1pdGVtczpmbGV4LWVuZDstd2Via2l0LWFsaWduLWl0ZW1zOmZsZXgtZW5kO2JvdHRvbTo1cHg7ZGlzcGxheTpmbGV4O2Rpc3BsYXk6LXdlYmtpdC1mbGV4O2ZvbnQtZmFtaWx5OnNhbnMtc2VyaWYsbW9ub3NwYWNlO2ZvbnQtc2l6ZToxM3B4O2ZvbnQtd2VpZ2h0OjIwMDtsaW5lLWhlaWdodDoxNnB4O2hlaWdodDo3MnB4O3Bvc2l0aW9uOmZpeGVkO3JpZ2h0OjVweH0uYS1lbnRlci12ci1idXR0b257YmFja2dyb3VuZDp1cmwoZGF0YTppbWFnZS9zdmcreG1sLCUzQ3N2ZyUyMHhtbG5zJTNEJTIyaHR0cCUzQSUyRiUyRnd3dy53My5vcmclMkYyMDAwJTJGc3ZnJTIyJTIwdmlld0JveCUzRCUyMjAlMjAwJTIwMjQ1LjgyJTIwMTQxLjczJTIyJTNFJTNDZGVmcyUzRSUzQ3N0eWxlJTNFLmElN0JmaWxsJTNBJTIzZmZmJTNCZmlsbC1ydWxlJTNBZXZlbm9kZCUzQiU3RCUzQyUyRnN0eWxlJTNFJTNDJTJGZGVmcyUzRSUzQ3RpdGxlJTNFbWFzayUzQyUyRnRpdGxlJTNFJTNDcGF0aCUyMGNsYXNzJTNEJTIyYSUyMiUyMGQlM0QlMjJNMTc1LjU2JTJDMTExLjM3Yy0yMi41MiUyQzAtNDAuNzctMTguODQtNDAuNzctNDIuMDdTMTUzJTJDMjcuMjQlMkMxNzUuNTYlMkMyNy4yNHM0MC43NyUyQzE4Ljg0JTJDNDAuNzclMkM0Mi4wN1MxOTguMDglMkMxMTEuMzclMkMxNzUuNTYlMkMxMTEuMzdaTTI2Ljg0JTJDNjkuMzFjMC0yMy4yMyUyQzE4LjI1LTQyLjA3JTJDNDAuNzctNDIuMDdzNDAuNzclMkMxOC44NCUyQzQwLjc3JTJDNDIuMDctMTguMjYlMkM0Mi4wNy00MC43NyUyQzQyLjA3UzI2Ljg0JTJDOTIuNTQlMkMyNi44NCUyQzY5LjMxWk0yNy4yNyUyQzBDMTEuNTQlMkMwJTJDMCUyQzEyLjM0JTJDMCUyQzI4LjU4VjExMC45YzAlMkMxNi4yNCUyQzExLjU0JTJDMzAuODMlMkMyNy4yNyUyQzMwLjgzSDk5LjU3YzIuMTclMkMwJTJDNC4xOS0xLjgzJTJDNS40LTMuN0wxMTYuNDclMkMxMThhOCUyQzglMkMwJTJDMCUyQzElMkMxMi41Mi0uMThsMTEuNTElMkMyMC4zNGMxLjIlMkMxLjg2JTJDMy4yMiUyQzMuNjElMkM1LjM5JTJDMy42MWg3Mi4yOWMxNS43NCUyQzAlMkMyNy42My0xNC42JTJDMjcuNjMtMzAuODNWMjguNThDMjQ1LjgyJTJDMTIuMzQlMkMyMzMuOTMlMkMwJTJDMjE4LjE5JTJDMEgyNy4yN1olMjIlMkYlM0UlM0MlMkZzdmclM0UpIDUwJSA1MCUvNzAlIDcwJSBuby1yZXBlYXQgcmdiYSgwLDAsMCwuMzUpO2JvcmRlcjowO2JvdHRvbTowO2NvbG9yOiNGRkY7Y3Vyc29yOnBvaW50ZXI7aGVpZ2h0OjUwcHg7cG9zaXRpb246YWJzb2x1dGU7cmlnaHQ6MDt0cmFuc2l0aW9uOmJhY2tncm91bmQtY29sb3IgLjA1cyBlYXNlOy13ZWJraXQtdHJhbnNpdGlvbjpiYWNrZ3JvdW5kLWNvbG9yIC4wNXMgZWFzZTt3aWR0aDo2MHB4O3otaW5kZXg6OTk5OTk5fS5hLWVudGVyLXZyLWJ1dHRvbjphY3RpdmUsLmEtZW50ZXItdnItYnV0dG9uOmhvdmVye2JhY2tncm91bmQtY29sb3I6IzY2Nn1bZGF0YS1hLWVudGVyLXZyLW5vLXdlYnZyXSAuYS1lbnRlci12ci1idXR0b257Ym9yZGVyLWNvbG9yOiM2NjY7b3BhY2l0eTouNjV9W2RhdGEtYS1lbnRlci12ci1uby13ZWJ2cl0gLmEtZW50ZXItdnItYnV0dG9uOmFjdGl2ZSxbZGF0YS1hLWVudGVyLXZyLW5vLXdlYnZyXSAuYS1lbnRlci12ci1idXR0b246aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjpyZ2JhKDAsMCwwLC4zNSk7Y3Vyc29yOm5vdC1hbGxvd2VkfS5hLWVudGVyLXZyLW1vZGFse2JhY2tncm91bmQtY29sb3I6IzY2Njtib3JkZXItcmFkaXVzOjA7Y29sb3I6I0ZGRjtoZWlnaHQ6MzJweDttYXJnaW4tcmlnaHQ6NzBweDtwYWRkaW5nOjlweDt3aWR0aDoyODBweDtwb3NpdGlvbjpyZWxhdGl2ZTtkaXNwbGF5Om5vbmV9LmEtZW50ZXItdnItbW9kYWw6YWZ0ZXJ7Ym9yZGVyLWJvdHRvbToxMHB4IHNvbGlkIHRyYW5zcGFyZW50O2JvcmRlci1sZWZ0OjEwcHggc29saWQgIzY2Njtib3JkZXItdG9wOjEwcHggc29saWQgdHJhbnNwYXJlbnQ7ZGlzcGxheTppbmxpbmUtYmxvY2s7Y29udGVudDonJztwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDotNXB4O3RvcDo1cHg7d2lkdGg6MDtoZWlnaHQ6MH0uYS1lbnRlci12ci1tb2RhbCBwe21hcmdpbjowO2Rpc3BsYXk6aW5saW5lfS5hLWVudGVyLXZyLW1vZGFsIHA6YWZ0ZXJ7Y29udGVudDonICd9LmEtZW50ZXItdnItbW9kYWwgYXtjb2xvcjojRkZGO2Rpc3BsYXk6aW5saW5lfVtkYXRhLWEtZW50ZXItdnItbm8taGVhZHNldF0uYS1lbnRlci12cjpob3ZlciAuYS1lbnRlci12ci1tb2RhbCxbZGF0YS1hLWVudGVyLXZyLW5vLXdlYnZyXS5hLWVudGVyLXZyOmhvdmVyIC5hLWVudGVyLXZyLW1vZGFse2Rpc3BsYXk6YmxvY2t9LmEtb3JpZW50YXRpb24tbW9kYWx7cG9zaXRpb246YWJzb2x1dGU7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJTt0b3A6MDtsZWZ0OjA7YmFja2dyb3VuZDp1cmwoZGF0YTppbWFnZS9zdmcreG1sLCUzQ3N2ZyUyMHhtbG5zJTNEJTIyaHR0cCUzQS8vd3d3LnczLm9yZy8yMDAwL3N2ZyUyMiUyMHhtbG5zJTNBeGxpbmslM0QlMjJodHRwJTNBLy93d3cudzMub3JnLzE5OTkveGxpbmslMjIlMjB2ZXJzaW9uJTNEJTIyMS4xJTIyJTIweCUzRCUyMjBweCUyMiUyMHklM0QlMjIwcHglMjIlMjB2aWV3Qm94JTNEJTIyMCUyMDAlMjA5MCUyMDkwJTIyJTIwZW5hYmxlLWJhY2tncm91bmQlM0QlMjJuZXclMjAwJTIwMCUyMDkwJTIwOTAlMjIlMjB4bWwlM0FzcGFjZSUzRCUyMnByZXNlcnZlJTIyJTNFJTNDcG9seWdvbiUyMHBvaW50cyUzRCUyMjAlMkMwJTIwMCUyQzAlMjAwJTJDMCUyMCUyMiUzRSUzQy9wb2x5Z29uJTNFJTNDZyUzRSUzQ3BhdGglMjBkJTNEJTIyTTcxLjU0NSUyQzQ4LjE0NWgtMzEuOThWMjAuNzQzYzAtMi42MjctMi4xMzgtNC43NjUtNC43NjUtNC43NjVIMTguNDU2Yy0yLjYyOCUyQzAtNC43NjclMkMyLjEzOC00Ljc2NyUyQzQuNzY1djQyLjc4OSUyMCUyMCUyMGMwJTJDMi42MjglMkMyLjEzOCUyQzQuNzY2JTJDNC43NjclMkM0Ljc2Nmg1LjUzNXYwLjk1OWMwJTJDMi42MjglMkMyLjEzOCUyQzQuNzY1JTJDNC43NjYlMkM0Ljc2NWg0Mi43ODhjMi42MjglMkMwJTJDNC43NjYtMi4xMzclMkM0Ljc2Ni00Ljc2NVY1Mi45MTQlMjAlMjAlMjBDNzYuMzExJTJDNTAuMjg0JTJDNzQuMTczJTJDNDguMTQ1JTJDNzEuNTQ1JTJDNDguMTQ1eiUyME0xOC40NTUlMkMxNi45MzVoMTYuMzQ0YzIuMSUyQzAlMkMzLjgwOCUyQzEuNzA4JTJDMy44MDglMkMzLjgwOHYyNy40MDFIMzcuMjVWMjIuNjM2JTIwJTIwJTIwYzAtMC4yNjQtMC4yMTUtMC40NzgtMC40NzktMC40NzhIMTYuNDgyYy0wLjI2NCUyQzAtMC40NzklMkMwLjIxNC0wLjQ3OSUyQzAuNDc4djM2LjU4NWMwJTJDMC4yNjQlMkMwLjIxNSUyQzAuNDc4JTJDMC40NzklMkMwLjQ3OGg3LjUwN3Y3LjY0NCUyMCUyMCUyMGgtNS41MzRjLTIuMTAxJTJDMC0zLjgxLTEuNzA5LTMuODEtMy44MVYyMC43NDNDMTQuNjQ1JTJDMTguNjQzJTJDMTYuMzU0JTJDMTYuOTM1JTJDMTguNDU1JTJDMTYuOTM1eiUyME0xNi45NiUyQzIzLjExNmgxOS4zMzF2MjUuMDMxaC03LjUzNSUyMCUyMCUyMGMtMi42MjglMkMwLTQuNzY2JTJDMi4xMzktNC43NjYlMkM0Ljc2OHY1LjgyOGgtNy4wM1YyMy4xMTZ6JTIwTTcxLjU0NSUyQzczLjA2NEgyOC43NTdjLTIuMTAxJTJDMC0zLjgxLTEuNzA4LTMuODEtMy44MDhWNTIuOTE0JTIwJTIwJTIwYzAtMi4xMDIlMkMxLjcwOS0zLjgxMiUyQzMuODEtMy44MTJoNDIuNzg4YzIuMSUyQzAlMkMzLjgwOSUyQzEuNzElMkMzLjgwOSUyQzMuODEydjE2LjM0M0M3NS4zNTQlMkM3MS4zNTYlMkM3My42NDUlMkM3My4wNjQlMkM3MS41NDUlMkM3My4wNjR6JTIyJTNFJTNDL3BhdGglM0UlM0NwYXRoJTIwZCUzRCUyMk0yOC45MTklMkM1OC40MjRjLTEuNDY2JTJDMC0yLjY1OSUyQzEuMTkzLTIuNjU5JTJDMi42NmMwJTJDMS40NjYlMkMxLjE5MyUyQzIuNjU4JTJDMi42NTklMkMyLjY1OGMxLjQ2OCUyQzAlMkMyLjY2Mi0xLjE5MiUyQzIuNjYyLTIuNjU4JTIwJTIwJTIwQzMxLjU4MSUyQzU5LjYxNyUyQzMwLjM4NyUyQzU4LjQyNCUyQzI4LjkxOSUyQzU4LjQyNHolMjBNMjguOTE5JTJDNjIuNzg2Yy0wLjkzOSUyQzAtMS43MDMtMC43NjQtMS43MDMtMS43MDJjMC0wLjkzOSUyQzAuNzY0LTEuNzA0JTJDMS43MDMtMS43MDQlMjAlMjAlMjBjMC45NCUyQzAlMkMxLjcwNSUyQzAuNzY1JTJDMS43MDUlMkMxLjcwNEMzMC42MjMlMkM2Mi4wMjIlMkMyOS44NTglMkM2Mi43ODYlMkMyOC45MTklMkM2Mi43ODZ6JTIyJTNFJTNDL3BhdGglM0UlM0NwYXRoJTIwZCUzRCUyMk02OS42NTQlMkM1MC40NjFIMzMuMDY5Yy0wLjI2NCUyQzAtMC40NzklMkMwLjIxNS0wLjQ3OSUyQzAuNDc5djIwLjI4OGMwJTJDMC4yNjQlMkMwLjIxNSUyQzAuNDc4JTJDMC40NzklMkMwLjQ3OGgzNi41ODUlMjAlMjAlMjBjMC4yNjMlMkMwJTJDMC40NzctMC4yMTQlMkMwLjQ3Ny0wLjQ3OFY1MC45MzlDNzAuMTMxJTJDNTAuNjc2JTJDNjkuOTE3JTJDNTAuNDYxJTJDNjkuNjU0JTJDNTAuNDYxeiUyME02OS4xNzQlMkM1MS40MTdWNzAuNzVIMzMuNTQ4VjUxLjQxN0g2OS4xNzR6JTIyJTNFJTNDL3BhdGglM0UlM0NwYXRoJTIwZCUzRCUyMk00NS4yMDElMkMzMC4yOTZjNi42NTElMkMwJTJDMTIuMjMzJTJDNS4zNTElMkMxMi41NTElMkMxMS45NzdsLTMuMDMzLTIuNjM4Yy0wLjE5My0wLjE2NS0wLjUwNy0wLjE0Mi0wLjY3NSUyQzAuMDQ4JTIwJTIwJTIwYy0wLjE3NCUyQzAuMTk4LTAuMTUzJTJDMC41MDElMkMwLjA0NSUyQzAuNjc2bDMuODgzJTJDMy4zNzVjMC4wOSUyQzAuMDc1JTJDMC4xOTglMkMwLjExNSUyQzAuMzEyJTJDMC4xMTVjMC4xNDElMkMwJTJDMC4yNzMtMC4wNjElMkMwLjM2Mi0wLjE2NiUyMCUyMCUyMGwzLjM3MS0zLjg3N2MwLjE3My0wLjIlMkMwLjE1MS0wLjUwMi0wLjA0Ny0wLjY3NWMtMC4xOTQtMC4xNjYtMC41MDgtMC4xNDQtMC42NzYlMkMwLjA0OGwtMi41OTIlMkMyLjk3OSUyMCUyMCUyMGMtMC4xOC0zLjQxNy0xLjYyOS02LjYwNS00LjA5OS05LjAwMWMtMi41MzgtMi40NjEtNS44NzctMy44MTctOS40MDQtMy44MTdjLTAuMjY0JTJDMC0wLjQ3OSUyQzAuMjE1LTAuNDc5JTJDMC40NzklMjAlMjAlMjBDNDQuNzIlMkMzMC4wODMlMkM0NC45MzYlMkMzMC4yOTYlMkM0NS4yMDElMkMzMC4yOTZ6JTIyJTNFJTNDL3BhdGglM0UlM0MvZyUzRSUzQy9zdmclM0UpIGNlbnRlciBjZW50ZXIvNTAlIDUwJSBuby1yZXBlYXQgcmdiYSgyNDQsMjQ0LDI0NCwxKX0uYS1vcmllbnRhdGlvbi1tb2RhbDphZnRlcntkaXNwbGF5OmJsb2NrO2NvbnRlbnQ6XFxcIkluc2VydCBwaG9uZSBpbnRvIENhcmRib2FyZCBob2xkZXIuXFxcIjtjb2xvcjojMzMzO2ZvbnQtZmFtaWx5OnNhbnMtc2VyaWYsbW9ub3NwYWNlO2ZvbnQtc2l6ZToxM3B4O3RleHQtYWxpZ246Y2VudGVyO3Bvc2l0aW9uOmFic29sdXRlO3dpZHRoOjEwMCU7dG9wOjcwJTt0cmFuc2Zvcm06dHJhbnNsYXRlWSgtNzAlKX0uYS1vcmllbnRhdGlvbi1tb2RhbCBidXR0b257YmFja2dyb3VuZDp1cmwoZGF0YTppbWFnZS9zdmcreG1sLCUzQ3N2ZyUyMHhtbG5zJTNEJTIyaHR0cCUzQS8vd3d3LnczLm9yZy8yMDAwL3N2ZyUyMiUyMHhtbG5zJTNBeGxpbmslM0QlMjJodHRwJTNBLy93d3cudzMub3JnLzE5OTkveGxpbmslMjIlMjB2ZXJzaW9uJTNEJTIyMS4xJTIyJTIweCUzRCUyMjBweCUyMiUyMHklM0QlMjIwcHglMjIlMjB2aWV3Qm94JTNEJTIyMCUyMDAlMjAxMDAlMjAxMDAlMjIlMjBlbmFibGUtYmFja2dyb3VuZCUzRCUyMm5ldyUyMDAlMjAwJTIwMTAwJTIwMTAwJTIyJTIweG1sJTNBc3BhY2UlM0QlMjJwcmVzZXJ2ZSUyMiUzRSUzQ3BhdGglMjBmaWxsJTNEJTIyJTIzMDAwMDAwJTIyJTIwZCUzRCUyMk01NS4yMDklMkM1MGwxNy44MDMtMTcuODAzYzEuNDE2LTEuNDE2JTJDMS40MTYtMy43MTMlMkMwLTUuMTI5Yy0xLjQxNi0xLjQxNy0zLjcxMy0xLjQxNy01LjEyOSUyQzBMNTAuMDglMkM0NC44NzIlMjAlMjBMMzIuMjc4JTJDMjcuMDY5Yy0xLjQxNi0xLjQxNy0zLjcxNC0xLjQxNy01LjEyOSUyQzBjLTEuNDE3JTJDMS40MTYtMS40MTclMkMzLjcxMyUyQzAlMkM1LjEyOUw0NC45NTElMkM1MEwyNy4xNDklMkM2Ny44MDMlMjAlMjBjLTEuNDE3JTJDMS40MTYtMS40MTclMkMzLjcxMyUyQzAlMkM1LjEyOWMwLjcwOCUyQzAuNzA4JTJDMS42MzYlMkMxLjA2MiUyQzIuNTY0JTJDMS4wNjJjMC45MjglMkMwJTJDMS44NTYtMC4zNTQlMkMyLjU2NC0xLjA2Mkw1MC4wOCUyQzU1LjEzbDE3LjgwMyUyQzE3LjgwMiUyMCUyMGMwLjcwOCUyQzAuNzA4JTJDMS42MzclMkMxLjA2MiUyQzIuNTY0JTJDMS4wNjJzMS44NTYtMC4zNTQlMkMyLjU2NC0xLjA2MmMxLjQxNi0xLjQxNiUyQzEuNDE2LTMuNzEzJTJDMC01LjEyOUw1NS4yMDklMkM1MHolMjIlM0UlM0MvcGF0aCUzRSUzQy9zdmclM0UpO3dpZHRoOjUwcHg7aGVpZ2h0OjUwcHg7Ym9yZGVyOm5vbmU7dGV4dC1pbmRlbnQ6LTk5OTlweH1AbWVkaWEgKG1pbi13aWR0aDo0ODBweCl7LmEtZW50ZXItdnJ7Ym90dG9tOjIwcHg7cmlnaHQ6MjBweH0uYS1lbnRlci12ci1tb2RhbHt3aWR0aDo0MDBweH19XCI7IChfZGVyZXFfKFwiYnJvd3NlcmlmeS1jc3NcIikuY3JlYXRlU3R5bGUoY3NzLCB7IFwiaHJlZlwiOiBcInNyYy9zdHlsZS9hZnJhbWUuY3NzXCJ9KSk7IG1vZHVsZS5leHBvcnRzID0gY3NzO1xufSx7XCJicm93c2VyaWZ5LWNzc1wiOjF9XSw5NTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgY3NzID0gXCIucnMtYmFzZXtiYWNrZ3JvdW5kLWNvbG9yOiNFRjJENUU7Ym9yZGVyLXJhZGl1czowO2ZvbnQ6MTBweCBtb25vc3BhY2U7bGVmdDo1cHg7bGluZS1oZWlnaHQ6MWVtO29wYWNpdHk6Ljc1O292ZXJmbG93OmhpZGRlbjtwYWRkaW5nOjEwcHg7cG9zaXRpb246Zml4ZWQ7dG9wOjVweDt3aWR0aDozMDBweDt6LWluZGV4OjEwMDAwfS5ycy1iYXNlIGRpdi5oaWRkZW57ZGlzcGxheTpub25lfS5ycy1iYXNlIGgxe2NvbG9yOiNmZmY7Y3Vyc29yOnBvaW50ZXI7Zm9udC1zaXplOjEuNGVtO2ZvbnQtd2VpZ2h0OjMwMDttYXJnaW46MCAwIDVweDtwYWRkaW5nOjB9LnJzLWdyb3Vwe2Rpc3BsYXk6LXdlYmtpdC1ib3g7ZGlzcGxheTotd2Via2l0LWZsZXg7ZGlzcGxheTpmbGV4Oy13ZWJraXQtZmxleC1kaXJlY3Rpb246Y29sdW1uLXJldmVyc2U7ZmxleC1kaXJlY3Rpb246Y29sdW1uLXJldmVyc2U7bWFyZ2luLWJvdHRvbTo1cHh9LnJzLWdyb3VwOmxhc3QtY2hpbGR7bWFyZ2luLWJvdHRvbTowfS5ycy1jb3VudGVyLWJhc2V7YWxpZ24taXRlbXM6Y2VudGVyO2Rpc3BsYXk6LXdlYmtpdC1ib3g7ZGlzcGxheTotd2Via2l0LWZsZXg7ZGlzcGxheTpmbGV4O2hlaWdodDoxMHB4Oy13ZWJraXQtanVzdGlmeS1jb250ZW50OnNwYWNlLWJldHdlZW47anVzdGlmeS1jb250ZW50OnNwYWNlLWJldHdlZW47bWFyZ2luOjJweCAwfS5ycy1jb3VudGVyLWlke2ZvbnQtd2VpZ2h0OjMwMDstd2Via2l0LWJveC1vcmRpbmFsLWdyb3VwOjA7LXdlYmtpdC1vcmRlcjowO29yZGVyOjA7d2lkdGg6NTBweH0ucnMtY291bnRlci12YWx1ZXtmb250LXdlaWdodDozMDA7LXdlYmtpdC1ib3gtb3JkaW5hbC1ncm91cDoxOy13ZWJraXQtb3JkZXI6MTtvcmRlcjoxO3RleHQtYWxpZ246cmlnaHQ7d2lkdGg6MzVweH0ucnMtY2FudmFzey13ZWJraXQtYm94LW9yZGluYWwtZ3JvdXA6Mjstd2Via2l0LW9yZGVyOjI7b3JkZXI6Mn1AbWVkaWEgKG1pbi13aWR0aDo0ODBweCl7LnJzLWJhc2V7bGVmdDoyMHB4O3RvcDoyMHB4fX1cIjsgKF9kZXJlcV8oXCJicm93c2VyaWZ5LWNzc1wiKS5jcmVhdGVTdHlsZShjc3MsIHsgXCJocmVmXCI6IFwic3JjL3N0eWxlL3JTdGF0cy5jc3NcIn0pKTsgbW9kdWxlLmV4cG9ydHMgPSBjc3M7XG59LHtcImJyb3dzZXJpZnktY3NzXCI6MX1dLDk2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciByZWdpc3RlclN5c3RlbSA9IF9kZXJlcV8oJy4uL2NvcmUvc3lzdGVtJykucmVnaXN0ZXJTeXN0ZW07XHJcblxyXG52YXIgREVGQVVMVF9DQU1FUkFfQVRUUiA9ICdkYXRhLWFmcmFtZS1kZWZhdWx0LWNhbWVyYSc7XHJcblxyXG4vKipcclxuICogQ2FtZXJhIHN5c3RlbS4gTWFuYWdlcyB3aGljaCBjYW1lcmEgaXMgYWN0aXZlIGFtb25nIG11bHRpcGxlIGNhbWVyYXMgaW4gc2NlbmUuXHJcbiAqXHJcbiAqIEBtZW1iZXIge29iamVjdH0gYWN0aXZlQ2FtZXJhRWwgLSBBY3RpdmUgY2FtZXJhIGVudGl0eS5cclxuICovXHJcbm1vZHVsZS5leHBvcnRzLlN5c3RlbSA9IHJlZ2lzdGVyU3lzdGVtKCdjYW1lcmEnLCB7XHJcbiAgaW5pdDogZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy5hY3RpdmVDYW1lcmFFbCA9IG51bGw7XHJcbiAgICB0aGlzLnNldHVwRGVmYXVsdENhbWVyYSgpO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYSBkZWZhdWx0IGNhbWVyYSBpZiB1c2VyIGhhcyBub3QgYWRkZWQgb25lIGR1cmluZyB0aGUgaW5pdGlhbCBzY2VuZSB0cmF2ZXJzYWwuXHJcbiAgICpcclxuICAgKiBEZWZhdWx0IGNhbWVyYSBoZWlnaHQgaXMgYXQgaHVtYW4gbGV2ZWwgKH4xLjhtKSBhbmQgYmFjayBzdWNoIHRoYXRcclxuICAgKiBlbnRpdGllcyBhdCB0aGUgb3JpZ2luICgwLCAwLCAwKSBhcmUgd2VsbC1jZW50ZXJlZC5cclxuICAgKi9cclxuICBzZXR1cERlZmF1bHRDYW1lcmE6IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBzY2VuZUVsID0gdGhpcy5zY2VuZUVsO1xyXG4gICAgdmFyIGNhbWVyYVdyYXBwZXJFbDtcclxuICAgIHZhciBkZWZhdWx0Q2FtZXJhRWw7XHJcblxyXG4gICAgLy8gc2V0VGltZW91dCBpbiBjYXNlIHRoZSBjYW1lcmEgaXMgYmVpbmcgc2V0IGR5bmFtaWNhbGx5IHdpdGggYSBzZXRBdHRyaWJ1dGUuXHJcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uIGNoZWNrRm9yQ2FtZXJhICgpIHtcclxuICAgICAgdmFyIGNhbWVyYUVsID0gc2NlbmVFbC5xdWVyeVNlbGVjdG9yKCdbY2FtZXJhXScpO1xyXG5cclxuICAgICAgaWYgKGNhbWVyYUVsICYmIGNhbWVyYUVsLmlzRW50aXR5KSB7XHJcbiAgICAgICAgc2NlbmVFbC5lbWl0KCdjYW1lcmEtcmVhZHknLCB7Y2FtZXJhRWw6IGNhbWVyYUVsfSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBET00gY2FsbHMgdG8gY3JlYXRlIGNhbWVyYS5cclxuICAgICAgY2FtZXJhV3JhcHBlckVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYS1lbnRpdHknKTtcclxuICAgICAgY2FtZXJhV3JhcHBlckVsLnNldEF0dHJpYnV0ZSgncG9zaXRpb24nLCB7eDogMCwgeTogMS44LCB6OiA0fSk7XHJcbiAgICAgIGNhbWVyYVdyYXBwZXJFbC5zZXRBdHRyaWJ1dGUoREVGQVVMVF9DQU1FUkFfQVRUUiwgJycpO1xyXG4gICAgICBkZWZhdWx0Q2FtZXJhRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhLWVudGl0eScpO1xyXG4gICAgICBkZWZhdWx0Q2FtZXJhRWwuc2V0QXR0cmlidXRlKCdjYW1lcmEnLCB7J2FjdGl2ZSc6IHRydWV9KTtcclxuICAgICAgZGVmYXVsdENhbWVyYUVsLnNldEF0dHJpYnV0ZSgnd2FzZC1jb250cm9scycpO1xyXG4gICAgICBkZWZhdWx0Q2FtZXJhRWwuc2V0QXR0cmlidXRlKCdsb29rLWNvbnRyb2xzJyk7XHJcbiAgICAgIGNhbWVyYVdyYXBwZXJFbC5hcHBlbmRDaGlsZChkZWZhdWx0Q2FtZXJhRWwpO1xyXG4gICAgICBzY2VuZUVsLmFwcGVuZENoaWxkKGNhbWVyYVdyYXBwZXJFbCk7XHJcbiAgICAgIHNjZW5lRWwuZW1pdCgnY2FtZXJhLXJlYWR5Jywge2NhbWVyYUVsOiBkZWZhdWx0Q2FtZXJhRWx9KTtcclxuICAgIH0pO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIFNldCBhIGRpZmZlcmVudCBhY3RpdmUgY2FtZXJhLlxyXG4gICAqIFdoZW4gd2UgY2hvb3NlIGEgKHNvcnQgb2YpIHJhbmRvbSBzY2VuZSBjYW1lcmEgYXMgdGhlIHJlcGxhY2VtZW50LCBzZXQgaXRzIGBhY3RpdmVgIHRvXHJcbiAgICogdHJ1ZS4gVGhlIGNhbWVyYSBjb21wb25lbnQgd2lsbCBjYWxsIGBzZXRBY3RpdmVDYW1lcmFgIGFuZCBoYW5kbGUgcGFzc2luZyB0aGUgdG9yY2ggdG9cclxuICAgKiB0aGUgbmV3IGNhbWVyYS5cclxuICAgKi9cclxuICBkaXNhYmxlQWN0aXZlQ2FtZXJhOiBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgc2NlbmVFbCA9IHRoaXMuc2NlbmVFbDtcclxuICAgIHZhciBzY2VuZUNhbWVyYXMgPSBzY2VuZUVsLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tjYW1lcmFdJyk7XHJcbiAgICB2YXIgbmV3QWN0aXZlQ2FtZXJhRWwgPSBzY2VuZUNhbWVyYXNbc2NlbmVDYW1lcmFzLmxlbmd0aCAtIDFdO1xyXG4gICAgbmV3QWN0aXZlQ2FtZXJhRWwuc2V0QXR0cmlidXRlKCdjYW1lcmEnLCAnYWN0aXZlJywgdHJ1ZSk7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogU2V0IGFjdGl2ZSBjYW1lcmEgdG8gYmUgdXNlZCBieSByZW5kZXJlci5cclxuICAgKiBSZW1vdmVzIHRoZSBkZWZhdWx0IGNhbWVyYSAoaWYgcHJlc2VudCkuXHJcbiAgICogRGlzYWJsZXMgYWxsIG90aGVyIGNhbWVyYXMgaW4gdGhlIHNjZW5lLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtFbGVtZW50fSBuZXdDYW1lcmFFbCAtIEVudGl0eSB3aXRoIGNhbWVyYSBjb21wb25lbnQuXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IG5ld0NhbWVyYSAtIHRocmVlLmpzIENhbWVyYSBvYmplY3QuXHJcbiAgICovXHJcbiAgc2V0QWN0aXZlQ2FtZXJhOiBmdW5jdGlvbiAobmV3Q2FtZXJhRWwsIG5ld0NhbWVyYSkge1xyXG4gICAgdmFyIGNhbWVyYUVsO1xyXG4gICAgdmFyIGk7XHJcbiAgICB2YXIgc2NlbmVFbCA9IHRoaXMuc2NlbmVFbDtcclxuICAgIHZhciBzY2VuZUNhbWVyYUVscyA9IHNjZW5lRWwucXVlcnlTZWxlY3RvckFsbCgnW2NhbWVyYV0nKTtcclxuXHJcbiAgICAvLyBHcmFiIHRoZSBkZWZhdWx0IGNhbWVyYS5cclxuICAgIHZhciBkZWZhdWx0Q2FtZXJhV3JhcHBlciA9IHNjZW5lRWwucXVlcnlTZWxlY3RvcignWycgKyBERUZBVUxUX0NBTUVSQV9BVFRSICsgJ10nKTtcclxuICAgIHZhciBkZWZhdWx0Q2FtZXJhRWwgPSBkZWZhdWx0Q2FtZXJhV3JhcHBlciAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRDYW1lcmFXcmFwcGVyLnF1ZXJ5U2VsZWN0b3IoJ1tjYW1lcmFdJyk7XHJcbiAgICAvLyBSZW1vdmUgZGVmYXVsdCBjYW1lcmEgaWYgbmV3IGNhbWVyYSBpcyBub3QgdGhlIGRlZmF1bHQgY2FtZXJhLlxyXG4gICAgaWYgKG5ld0NhbWVyYUVsICE9PSBkZWZhdWx0Q2FtZXJhRWwpIHsgcmVtb3ZlRGVmYXVsdENhbWVyYShzY2VuZUVsKTsgfVxyXG5cclxuICAgIC8vIE1ha2UgbmV3IGNhbWVyYSBhY3RpdmUuXHJcbiAgICB0aGlzLmFjdGl2ZUNhbWVyYUVsID0gbmV3Q2FtZXJhRWw7XHJcbiAgICBpZiAoc2NlbmVFbC5pc1BsYXlpbmcpIHsgbmV3Q2FtZXJhRWwucGxheSgpOyB9XHJcbiAgICBuZXdDYW1lcmFFbC5zZXRBdHRyaWJ1dGUoJ2NhbWVyYScsICdhY3RpdmUnLCB0cnVlKTtcclxuICAgIHNjZW5lRWwuY2FtZXJhID0gbmV3Q2FtZXJhO1xyXG4gICAgc2NlbmVFbC5lbWl0KCdjYW1lcmEtc2V0LWFjdGl2ZScsIHtjYW1lcmFFbDogbmV3Q2FtZXJhRWx9KTtcclxuXHJcbiAgICAvLyBEaXNhYmxlIG90aGVyIGNhbWVyYXMuXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgc2NlbmVDYW1lcmFFbHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgY2FtZXJhRWwgPSBzY2VuZUNhbWVyYUVsc1tpXTtcclxuICAgICAgaWYgKG5ld0NhbWVyYUVsID09PSBjYW1lcmFFbCkgeyBjb250aW51ZTsgfVxyXG4gICAgICBjYW1lcmFFbC5zZXRBdHRyaWJ1dGUoJ2NhbWVyYScsICdhY3RpdmUnLCBmYWxzZSk7XHJcbiAgICAgIGNhbWVyYUVsLnBhdXNlKCk7XHJcbiAgICB9XHJcbiAgfVxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBSZW1vdmUgaW5qZWN0ZWQgZGVmYXVsdCBjYW1lcmEgZnJvbSBzY2VuZSwgaWYgcHJlc2VudC5cclxuICpcclxuICogQHBhcmFtIHtFbGVtZW50fSBzY2VuZUVsXHJcbiAqL1xyXG5mdW5jdGlvbiByZW1vdmVEZWZhdWx0Q2FtZXJhIChzY2VuZUVsKSB7XHJcbiAgdmFyIGRlZmF1bHRDYW1lcmFXcmFwcGVyO1xyXG4gIHZhciBjYW1lcmEgPSBzY2VuZUVsLmNhbWVyYTtcclxuICBpZiAoIWNhbWVyYSkgeyByZXR1cm47IH1cclxuXHJcbiAgLy8gUmVtb3ZlIGRlZmF1bHQgY2FtZXJhIGlmIHByZXNlbnQuXHJcbiAgZGVmYXVsdENhbWVyYVdyYXBwZXIgPSBzY2VuZUVsLnF1ZXJ5U2VsZWN0b3IoJ1snICsgREVGQVVMVF9DQU1FUkFfQVRUUiArICddJyk7XHJcbiAgaWYgKCFkZWZhdWx0Q2FtZXJhV3JhcHBlcikgeyByZXR1cm47IH1cclxuICBzY2VuZUVsLnJlbW92ZUNoaWxkKGRlZmF1bHRDYW1lcmFXcmFwcGVyKTtcclxufVxyXG5cbn0se1wiLi4vY29yZS9zeXN0ZW1cIjo2NH1dLDk3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbl9kZXJlcV8oJy4vY2FtZXJhJyk7XG5fZGVyZXFfKCcuL21hdGVyaWFsJyk7XG5fZGVyZXFfKCcuL2xpZ2h0Jyk7XG5cbn0se1wiLi9jYW1lcmFcIjo5NixcIi4vbGlnaHRcIjo5OCxcIi4vbWF0ZXJpYWxcIjo5OX1dLDk4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciByZWdpc3RlclN5c3RlbSA9IF9kZXJlcV8oJy4uL2NvcmUvc3lzdGVtJykucmVnaXN0ZXJTeXN0ZW07XHJcblxyXG52YXIgREVGQVVMVF9MSUdIVF9BVFRSID0gJ2RhdGEtYWZyYW1lLWRlZmF1bHQtbGlnaHQnO1xyXG5cclxuLyoqXHJcbiAqIExpZ2h0IHN5c3RlbS5cclxuICpcclxuICogUHJlc2NyaWJlcyBkZWZhdWx0IGxpZ2h0aW5nIGlmIG5vdCBzcGVjaWZpZWQgKG9uZSBhbWJpZW50LCBvbmUgZGlyZWN0aW9uYWwpLlxyXG4gKiBSZW1vdmVzIGRlZmF1bHQgbGlnaHRpbmcgZnJvbSB0aGUgc2NlbmUgd2hlbiBhIG5ldyBsaWdodCBpcyBhZGRlZC5cclxuICpcclxuICogQHBhcmFtIHtib29sfSBkZWZhdWx0TGlnaHRzRW5hYmxlZCAtIFdoZXRoZXIgZGVmYXVsdCBsaWdodGluZyBpcyBhY3RpdmUuXHJcbiAqL1xyXG5tb2R1bGUuZXhwb3J0cy5TeXN0ZW0gPSByZWdpc3RlclN5c3RlbSgnbGlnaHQnLCB7XHJcbiAgaW5pdDogZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy5kZWZhdWx0TGlnaHRzRW5hYmxlZCA9IG51bGw7XHJcbiAgICB0aGlzLnNldHVwRGVmYXVsdExpZ2h0cygpO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIE5vdGlmeSBzY2VuZSB0aGF0IGxpZ2h0IGhhcyBiZWVuIGFkZGVkIGFuZCB0byByZW1vdmUgdGhlIGRlZmF1bHQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge29iamVjdH0gZWwgLSBlbGVtZW50IGhvbGRpbmcgdGhlIGxpZ2h0IGNvbXBvbmVudC5cclxuICAgKi9cclxuICByZWdpc3RlckxpZ2h0OiBmdW5jdGlvbiAoZWwpIHtcclxuICAgIHZhciBkZWZhdWx0TGlnaHRzO1xyXG4gICAgdmFyIHNjZW5lRWwgPSB0aGlzLnNjZW5lRWw7XHJcblxyXG4gICAgaWYgKHRoaXMuZGVmYXVsdExpZ2h0c0VuYWJsZWQgJiYgIWVsLmhhc0F0dHJpYnV0ZShERUZBVUxUX0xJR0hUX0FUVFIpKSB7XHJcbiAgICAgIC8vIFVzZXIgYWRkZWQgYSBsaWdodCwgcmVtb3ZlIGRlZmF1bHQgbGlnaHRzIHRocm91Z2ggRE9NLlxyXG4gICAgICBkZWZhdWx0TGlnaHRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnWycgKyBERUZBVUxUX0xJR0hUX0FUVFIgKyAnXScpO1xyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlZmF1bHRMaWdodHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBzY2VuZUVsLnJlbW92ZUNoaWxkKGRlZmF1bHRMaWdodHNbaV0pO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuZGVmYXVsdExpZ2h0c0VuYWJsZWQgPSBmYWxzZTtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBQcmVzY2liZSBkZWZhdWx0IGxpZ2h0cyB0byB0aGUgc2NlbmUuXHJcbiAgICogRG9lcyBzbyBieSBpbmplY3RpbmcgbWFya3VwIHN1Y2ggdGhhdCB0aGlzIHN0YXRlIGlzIG5vdCBpbnZpc2libGUuXHJcbiAgICogVGhlc2UgbGlnaHRzIGFyZSByZW1vdmVkIGlmIHRoZSB1c2VyIGFkZHMgYW55IGxpZ2h0cy5cclxuICAgKi9cclxuICBzZXR1cERlZmF1bHRMaWdodHM6IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBzY2VuZUVsID0gdGhpcy5zY2VuZUVsO1xyXG4gICAgdmFyIGFtYmllbnRMaWdodCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EtZW50aXR5Jyk7XHJcbiAgICB2YXIgZGlyZWN0aW9uYWxMaWdodCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EtZW50aXR5Jyk7XHJcblxyXG4gICAgYW1iaWVudExpZ2h0LnNldEF0dHJpYnV0ZSgnbGlnaHQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7Y29sb3I6ICcjZmZmJywgdHlwZTogJ2FtYmllbnQnfSk7XHJcbiAgICBhbWJpZW50TGlnaHQuc2V0QXR0cmlidXRlKERFRkFVTFRfTElHSFRfQVRUUiwgJycpO1xyXG4gICAgc2NlbmVFbC5hcHBlbmRDaGlsZChhbWJpZW50TGlnaHQpO1xyXG5cclxuICAgIGRpcmVjdGlvbmFsTGlnaHQuc2V0QXR0cmlidXRlKCdsaWdodCcsIHsgY29sb3I6ICcjZmZmJywgaW50ZW5zaXR5OiAwLjIgfSk7XHJcbiAgICBkaXJlY3Rpb25hbExpZ2h0LnNldEF0dHJpYnV0ZSgncG9zaXRpb24nLCB7IHg6IC0xLCB5OiAyLCB6OiAxIH0pO1xyXG4gICAgZGlyZWN0aW9uYWxMaWdodC5zZXRBdHRyaWJ1dGUoREVGQVVMVF9MSUdIVF9BVFRSLCAnJyk7XHJcbiAgICBzY2VuZUVsLmFwcGVuZENoaWxkKGRpcmVjdGlvbmFsTGlnaHQpO1xyXG5cclxuICAgIHRoaXMuZGVmYXVsdExpZ2h0c0VuYWJsZWQgPSB0cnVlO1xyXG4gIH1cclxufSk7XHJcblxufSx7XCIuLi9jb3JlL3N5c3RlbVwiOjY0fV0sOTk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIHJlZ2lzdGVyU3lzdGVtID0gX2RlcmVxXygnLi4vY29yZS9zeXN0ZW0nKS5yZWdpc3RlclN5c3RlbTtcclxuXHJcbm1vZHVsZS5leHBvcnRzLlN5c3RlbSA9IHJlZ2lzdGVyU3lzdGVtKCdtYXRlcmlhbCcsIHtcclxuICBpbml0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLm1hdGVyaWFscyA9IHt9O1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIEtlZXAgdHJhY2sgb2YgbWF0ZXJpYWwgaW4gY2FzZSBhbiB1cGRhdGUgdHJpZ2dlciBpcyBuZWVkZWQgKGUuZy4sIGZvZykuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge29iamVjdH0gbWF0ZXJpYWxcclxuICAgKi9cclxuICByZWdpc3Rlck1hdGVyaWFsOiBmdW5jdGlvbiAobWF0ZXJpYWwpIHtcclxuICAgIHRoaXMubWF0ZXJpYWxzW21hdGVyaWFsLnV1aWRdID0gbWF0ZXJpYWw7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogU3RvcHMgdHJhY2tpbmcgbWF0ZXJpYWwuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge29iamVjdH0gbWF0ZXJpYWxcclxuICAgKi9cclxuICB1bnJlZ2lzdGVyTWF0ZXJpYWw6IGZ1bmN0aW9uIChtYXRlcmlhbCkge1xyXG4gICAgZGVsZXRlIHRoaXMubWF0ZXJpYWxzW21hdGVyaWFsLnV1aWRdO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIFRyaWdnZXIgdXBkYXRlIHRvIGFsbCByZWdpc3RlcmVkIG1hdGVyaWFscy5cclxuICAgKi9cclxuICB1cGRhdGVNYXRlcmlhbHM6IGZ1bmN0aW9uIChtYXRlcmlhbCkge1xyXG4gICAgdmFyIG1hdGVyaWFscyA9IHRoaXMubWF0ZXJpYWxzO1xyXG4gICAgT2JqZWN0LmtleXMobWF0ZXJpYWxzKS5mb3JFYWNoKGZ1bmN0aW9uICh1dWlkKSB7XHJcbiAgICAgIG1hdGVyaWFsc1t1dWlkXS5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG59KTtcclxuXG59LHtcIi4uL2NvcmUvc3lzdGVtXCI6NjR9XSwxMDA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLy8gQ29vcmRpbmF0ZSBzdHJpbmcgcmVnZXguIEhhbmRsZXMgbmVnYXRpdmUsIHBvc2l0aXZlLCBhbmQgZGVjaW1hbHMuXG52YXIgcmVnZXggPSAvXFxzKigtP1xcZCpcXC57MCwxfVxcZCspXFxzKigtP1xcZCpcXC57MCwxfVxcZCspXFxzKigtP1xcZCpcXC57MCwxfVxcZCspXFxzKi87XG5tb2R1bGUuZXhwb3J0cy5yZWdleCA9IHJlZ2V4O1xuXG4vKipcbiAqIFBhcnNlcyBjb29yZGluYXRlcyBmcm9tIGFuIFwieCB5IHpcIiBzdHJpbmcuXG4gKiBFeGFtcGxlOiBcIjMgMTAgLTVcIiB0byB7eDogMywgeTogMTAsIHo6IC01fS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsIC0gQW4gXCJ4IHkgelwiIHN0cmluZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkZWZhdWx0cyAtIGZhbGxiYWNrIHZhbHVlLlxuICogQHJldHVybnMge29iamVjdH0gQW4gb2JqZWN0IHdpdGgga2V5cyBbeCwgeSwgel0uXG4gKi9cbmZ1bmN0aW9uIHBhcnNlICh2YWx1ZSwgZGVmYXVsdFZlYykge1xuICB2YXIgY29vcmRpbmF0ZTtcbiAgdmFyIHZlYyA9IHt9O1xuXG4gIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIHZlY1BhcnNlRmxvYXQodmFsdWUpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZGVmYXVsdFZlYztcbiAgfVxuXG4gIGNvb3JkaW5hdGUgPSB2YWx1ZS50cmltKCkucmVwbGFjZSgvXFxzKy9nLCAnICcpLnNwbGl0KCcgJyk7XG4gIHZlYy54ID0gY29vcmRpbmF0ZVswXSB8fCBkZWZhdWx0VmVjICYmIGRlZmF1bHRWZWMueDtcbiAgdmVjLnkgPSBjb29yZGluYXRlWzFdIHx8IGRlZmF1bHRWZWMgJiYgZGVmYXVsdFZlYy55O1xuICB2ZWMueiA9IGNvb3JkaW5hdGVbMl0gfHwgZGVmYXVsdFZlYyAmJiBkZWZhdWx0VmVjLno7XG4gIHZlYy53ID0gY29vcmRpbmF0ZVszXSB8fCBkZWZhdWx0VmVjICYmIGRlZmF1bHRWZWMudztcbiAgcmV0dXJuIHZlY1BhcnNlRmxvYXQodmVjKTtcbn1cbm1vZHVsZS5leHBvcnRzLnBhcnNlID0gcGFyc2U7XG5cbi8qKlxuICogU3RyaW5naWZpZXMgY29vcmRpbmF0ZXMgZnJvbSBhbiBvYmplY3Qgd2l0aCBrZXlzIFt4IHkgel0uXG4gKiBFeGFtcGxlOiB7eDogMywgeTogMTAsIHo6IC01fSB0byBcIjMgMTAgLTVcIi5cbiAqXG4gKiBAcGFyYW0ge29iamVjdHxzdHJpbmd9IGRhdGEgLSBBbiBvYmplY3Qgd2l0aCBrZXlzIFt4IHkgel0uXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBBbiBcInggeSB6XCIgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBzdHJpbmdpZnkgKGRhdGEpIHtcbiAgaWYgKHR5cGVvZiBkYXRhICE9PSAnb2JqZWN0JykgeyByZXR1cm4gZGF0YTsgfVxuICByZXR1cm4gW2RhdGEueCwgZGF0YS55LCBkYXRhLnpdLmpvaW4oJyAnKTtcbn1cbm1vZHVsZS5leHBvcnRzLnN0cmluZ2lmeSA9IHN0cmluZ2lmeTtcblxuLyoqXG4gKiBAcmV0dXJucyB7Ym9vbH1cbiAqL1xubW9kdWxlLmV4cG9ydHMuaXNDb29yZGluYXRlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHJldHVybiByZWdleC50ZXN0KHZhbHVlKTtcbn07XG5cbmZ1bmN0aW9uIHZlY1BhcnNlRmxvYXQgKHZlYykge1xuICBPYmplY3Qua2V5cyh2ZWMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIGlmICh2ZWNba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBkZWxldGUgdmVjW2tleV07XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZlY1trZXldID0gcGFyc2VGbG9hdCh2ZWNba2V5XSwgMTApO1xuICB9KTtcbiAgcmV0dXJuIHZlYztcbn1cblxufSx7fV0sMTAxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG52YXIgZGVidWdMaWIgPSBfZGVyZXFfKCdkZWJ1ZycpO1xudmFyIGV4dGVuZCA9IF9kZXJlcV8oJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIHNldHRpbmdzID0ge1xuICBjb2xvcnM6IHtcbiAgICBkZWJ1ZzogJ2dyYXknLFxuICAgIGVycm9yOiAncmVkJyxcbiAgICBpbmZvOiAnZ3JheScsXG4gICAgd2FybjogJ29yYW5nZSdcbiAgfVxufTtcblxuLyoqXG4gKiBNb25rZXlwYXRjaGVzIGBkZWJ1Z2Agc28gd2UgY2FuIGNvbG9yaXplIGVycm9yL3dhcm5pbmcgbWVzc2FnZXMuXG4gKlxuICogKFNlZSBpc3N1ZTogaHR0cHM6Ly9naXRodWIuY29tL3Zpc2lvbm1lZGlhL2RlYnVnL2lzc3Vlcy8xMzcpXG4gKi9cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uIChuYW1lc3BhY2UpIHtcbiAgdmFyIGQgPSBkZWJ1Z0xpYihuYW1lc3BhY2UpO1xuXG4gIGQuY29sb3IgPSBnZXREZWJ1Z05hbWVzcGFjZUNvbG9yKG5hbWVzcGFjZSk7XG5cbiAgcmV0dXJuIGQ7XG59O1xuZXh0ZW5kKGRlYnVnLCBkZWJ1Z0xpYik7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgdHlwZSBvZiB0aGUgbmFtZXNwYWNlIChlLmcuLCBgZXJyb3JgLCBgd2FybmApLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAqICAgVGhlIGRlYnVnIGxvZ2dlcidzIG5hbWVzcGFjZSAoZS5nLiwgYGNvbXBvbmVudHM6Z2VvbWV0cnk6d2FybmApLlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIHR5cGUgb2YgdGhlIG5hbWVzcGFjZSAoZS5nLiwgYHdhcm5gKS5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBnZXREZWJ1Z05hbWVzcGFjZVR5cGUgKG5hbWVzcGFjZSkge1xuICB2YXIgY2h1bmtzID0gbmFtZXNwYWNlLnNwbGl0KCc6Jyk7XG5cbiAgcmV0dXJuIGNodW5rc1tjaHVua3MubGVuZ3RoIC0gMV07ICAvLyBSZXR1cm4gdGhlIGxhc3Qgb25lXG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY29sb3Igb2YgdGhlIG5hbWVzcGFjZSAoZS5nLiwgYG9yYW5nZWApLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAqICAgVGhlIGRlYnVnIGxvZ2dlcidzIG5hbWVzcGFjZSAoZS5nLiwgYGNvbXBvbmVudHM6Z2VvbWV0cnk6d2FybmApLlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIGNvbG9yIG9mIHRoZSBuYW1lc3BhY2UgKGUuZy4sIGBvcmFuZ2VgKS5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBnZXREZWJ1Z05hbWVzcGFjZUNvbG9yIChuYW1lc3BhY2UpIHtcbiAgdmFyIHR5cGUgPSBnZXREZWJ1Z05hbWVzcGFjZVR5cGUobmFtZXNwYWNlKTtcblxuICB2YXIgY29sb3IgPSBzZXR0aW5ncy5jb2xvcnMgJiYgc2V0dGluZ3MuY29sb3JzW3R5cGVdO1xuXG4gIHJldHVybiBjb2xvciB8fCBudWxsO1xufVxuXG4vKipcbiAqIFJldHVybnMgYGxvY2FsU3RvcmFnZWAgaWYgcG9zc2libGUuXG4gKlxuICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBTYWZhcmkgdGhyb3dzIHdoZW4gYSB1c2VyIGRpc2FibGVzXG4gKiBjb29raWVzIG9yIGBsb2NhbFN0b3JhZ2VgIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG4gKlxuICogQHJldHVybnMge2xvY2FsU3RvcmFnZX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzdG9yYWdlICgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gd2luZG93LmxvY2FsU3RvcmFnZTtcbiAgfSBjYXRjaCAoZSkge1xuICB9XG59XG5cbi8qKlxuICogVG8gZW5hYmxlIGNvbnNvbGUgbG9nZ2luZywgdHlwZSB0aGlzIGluIHRoZSBDb25zb2xlIG9mIHlvdXIgRGV2IFRvb2xzOlxuICpcbiAqICAgbG9jYWxTdG9yYWdlLmxvZ3MgPSAxXG4gKlxuICogVG8gZGlzYWJsZSBjb25zb2xlIGxvZ2dpbmc6XG4gKlxuICogICBsb2NhbFN0b3JhZ2UubG9ncyA9IDBcbiAqXG4gKi9cbnZhciBscyA9IHN0b3JhZ2UoKTtcbmlmIChscyAmJiAocGFyc2VJbnQobHMubG9ncywgMTApIHx8IGxzLmxvZ3MgPT09ICd0cnVlJykpIHtcbiAgZGVidWcuZW5hYmxlKCcqJyk7XG59IGVsc2Uge1xuICBkZWJ1Zy5lbmFibGUoJyo6ZXJyb3IsKjppbmZvLCo6d2FybicpO1xufVxuXG5pZiAocHJvY2Vzcy5icm93c2VyKSB7IHdpbmRvdy5sb2dzID0gZGVidWc7IH1cblxubW9kdWxlLmV4cG9ydHMgPSBkZWJ1ZztcblxufSkuY2FsbCh0aGlzLF9kZXJlcV8oJ19wcm9jZXNzJykpXG5cbn0se1wiX3Byb2Nlc3NcIjoyLFwiZGVidWdcIjozLFwib2JqZWN0LWFzc2lnblwiOjl9XSwxMDI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLyogZ2xvYmFsIEN1c3RvbUV2ZW50LCBsb2NhdGlvbiAqL1xuLyogQ2VudHJhbGl6ZWQgcGxhY2UgdG8gcmVmZXJlbmNlIHV0aWxpdGllcyBzaW5jZSB1dGlscyBpcyBleHBvc2VkIHRvIHRoZSB1c2VyLiAqL1xuXG52YXIgZGVlcEFzc2lnbiA9IF9kZXJlcV8oJ2RlZXAtYXNzaWduJyk7XG52YXIgb2JqZWN0QXNzaWduID0gX2RlcmVxXygnb2JqZWN0LWFzc2lnbicpO1xuXG5tb2R1bGUuZXhwb3J0cy5jb29yZGluYXRlcyA9IF9kZXJlcV8oJy4vY29vcmRpbmF0ZXMnKTtcbm1vZHVsZS5leHBvcnRzLmRlYnVnID0gX2RlcmVxXygnLi9kZWJ1ZycpO1xubW9kdWxlLmV4cG9ydHMuc3R5bGVQYXJzZXIgPSBfZGVyZXFfKCcuL3N0eWxlUGFyc2VyJyk7XG5tb2R1bGUuZXhwb3J0cy50ZXh0dXJlID0gX2RlcmVxXygnLi90ZXh0dXJlJyk7XG5cbi8qKlxuICogRmlyZXMgYSBjdXN0b20gRE9NIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWwgRWxlbWVudCBvbiB3aGljaCB0byBmaXJlIHRoZSBldmVudC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIE5hbWUgb2YgdGhlIGV2ZW50LlxuICogQHBhcmFtIHtPYmplY3Q9fSBbZGF0YT17YnViYmxlczogdHJ1ZSwge2RldGFpbDogPGVsPn19XVxuICogICBEYXRhIHRvIHBhc3MgYXMgYGN1c3RvbUV2ZW50SW5pdGAgdG8gdGhlIGV2ZW50LlxuICovXG5tb2R1bGUuZXhwb3J0cy5maXJlRXZlbnQgPSBmdW5jdGlvbiAoZWwsIG5hbWUsIGRhdGEpIHtcbiAgZGF0YSA9IGRhdGEgfHwge307XG4gIGRhdGEuZGV0YWlsID0gZGF0YS5kZXRhaWwgfHwge307XG4gIGRhdGEuZGV0YWlsLnRhcmdldCA9IGRhdGEuZGV0YWlsLnRhcmdldCB8fCBlbDtcbiAgdmFyIGV2dCA9IG5ldyBDdXN0b21FdmVudChuYW1lLCBkYXRhKTtcbiAgZXZ0LnRhcmdldCA9IGVsO1xuICBlbC5kaXNwYXRjaEV2ZW50KGV2dCk7XG59O1xuXG4vKipcbiAqIFRocm93cyBhbiBlcnJvciBnaXZlbiBhIG1lc3NhZ2UuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1zZyBFcnJvciBtZXNzYWdlLlxuICovXG5tb2R1bGUuZXhwb3J0cy5lcnJvciA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG59O1xuXG4vKipcbiAqIEVtaXRzIGEgY29uc29sZSB3YXJuaW5nIGdpdmVuIHBhc3NlZCBtZXNzYWdlIGFyZ3VtZW50KHMpLlxuICovXG5tb2R1bGUuZXhwb3J0cy53YXJuID0gZnVuY3Rpb24gKCkge1xuICBjb25zb2xlLndhcm4uYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKTtcbn07XG5cbi8qKlxuICogRW1pdHMgYSBjb25zb2xlIGxvZyBnaXZlbiBwYXNzZWQgbWVzc2FnZSBhcmd1bWVudChzKS5cbiAqL1xubW9kdWxlLmV4cG9ydHMubG9nID0gZnVuY3Rpb24gKCkge1xuICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpO1xufTtcblxuLyoqXG4gKiBNaXggdGhlIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdChzKSBpbnRvIGEgZGVzdGluYXRpb24gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSAge29iamVjdH0gZGVzdCAtIFRoZSBvYmplY3QgdG8gd2hpY2ggcHJvcGVydGllcyB3aWxsIGJlIGNvcGllZC5cbiAqIEBwYXJhbSAgey4uLm9iamVjdH0gc291cmNlIC0gVGhlIG9iamVjdChzKSBmcm9tIHdoaWNoIHByb3BlcnRpZXMgd2lsbCBiZSBjb3BpZWQuXG4gKi9cbm1vZHVsZS5leHBvcnRzLmV4dGVuZCA9IG9iamVjdEFzc2lnbjtcbm1vZHVsZS5leHBvcnRzLmV4dGVuZERlZXAgPSBkZWVwQXNzaWduO1xuXG4vKipcbiAqIENoZWNrcyBpZiB0d28gb2JqZWN0cyBoYXZlIHRoZSBzYW1lIGF0dHJpYnV0ZXMgYW5kIHZhbHVlcywgaW5jbHVkaW5nIG5lc3RlZCBvYmplY3RzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBhIC0gRmlyc3Qgb2JqZWN0LlxuICogQHBhcmFtIHtvYmplY3R9IGIgLSBTZWNvbmQgb2JqZWN0LlxuICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgdHdvIG9iamVjdHMgYXJlIGRlZXBseSBlcXVhbC5cbiAqL1xuZnVuY3Rpb24gZGVlcEVxdWFsIChhLCBiKSB7XG4gIHZhciBrZXlzQSA9IE9iamVjdC5rZXlzKGEpO1xuICB2YXIga2V5c0IgPSBPYmplY3Qua2V5cyhiKTtcbiAgdmFyIGk7XG4gIGlmIChrZXlzQS5sZW5ndGggIT09IGtleXNCLmxlbmd0aCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgLy8gSWYgdGhlcmUgYXJlIG5vIGtleXMsIGNvbXBhcmUgdGhlIG9iamVjdHMuXG4gIGlmIChrZXlzQS5sZW5ndGggPT09IDApIHsgcmV0dXJuIGEgPT09IGI7IH1cbiAgZm9yIChpID0gMDsgaSA8IGtleXNBLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGFba2V5c0FbaV1dICE9PSBiW2tleXNBW2ldXSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbm1vZHVsZS5leHBvcnRzLmRlZXBFcXVhbCA9IGRlZXBFcXVhbDtcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHR3byBvYmplY3RzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBhIC0gRmlyc3Qgb2JqZWN0IHRvIGNvbXBhcmUgKGUuZy4sIG9sZERhdGEpLlxuICogQHBhcmFtIHtvYmplY3R9IGIgLSBTZWNvbmQgb2JqZWN0IHRvIGNvbXBhcmUgKGUuZy4sIG5ld0RhdGEpLlxuICogQHJldHVybnMge29iamVjdH1cbiAqICAgRGlmZmVyZW5jZSBvYmplY3Qgd2hlcmUgc2V0IG9mIGtleXMgbm90ZSB3aGljaCB2YWx1ZXMgd2VyZSBub3QgZXF1YWwsIGFuZCB2YWx1ZXMgYXJlXG4gKiAgIGBiYCdzIHZhbHVlcy5cbiAqL1xubW9kdWxlLmV4cG9ydHMuZGlmZiA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gIHZhciBkaWZmID0ge307XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYSk7XG4gIE9iamVjdC5rZXlzKGIpLmZvckVhY2goZnVuY3Rpb24gY29sbGVjdEtleXMgKGJLZXkpIHtcbiAgICBpZiAoa2V5cy5pbmRleE9mKGJLZXkpID09PSAtMSkge1xuICAgICAga2V5cy5wdXNoKGJLZXkpO1xuICAgIH1cbiAgfSk7XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbiBkb0RpZmYgKGtleSkge1xuICAgIHZhciBhVmFsID0gYVtrZXldO1xuICAgIHZhciBiVmFsID0gYltrZXldO1xuICAgIHZhciBpc0NvbXBhcmluZ09iamVjdHMgPSBhVmFsICYmIGJWYWwgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYVZhbC5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0ICYmIGJWYWwuY29uc3RydWN0b3IgPT09IE9iamVjdDtcbiAgICBpZiAoKGlzQ29tcGFyaW5nT2JqZWN0cyAmJiAhZGVlcEVxdWFsKGFWYWwsIGJWYWwpKSB8fFxuICAgICAgICAoIWlzQ29tcGFyaW5nT2JqZWN0cyAmJiBhVmFsICE9PSBiVmFsKSkge1xuICAgICAgZGlmZltrZXldID0gYlZhbDtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZGlmZjtcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIGJyb3dzZXIgaXMgbW9iaWxlLlxuICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiBtb2JpbGUgYnJvd3NlciBkZXRlY3RlZC5cbiAqL1xubW9kdWxlLmV4cG9ydHMuaXNNb2JpbGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBjaGVjayA9IGZhbHNlO1xuICAoZnVuY3Rpb24gKGEpIHtcbiAgICBpZiAoLyhhbmRyb2lkfGJiXFxkK3xtZWVnbykuK21vYmlsZXxhdmFudGdvfGJhZGFcXC98YmxhY2tiZXJyeXxibGF6ZXJ8Y29tcGFsfGVsYWluZXxmZW5uZWN8aGlwdG9wfGllbW9iaWxlfGlwKGhvbmV8b2QpfGlyaXN8a2luZGxlfGxnZSB8bWFlbW98bWlkcHxtbXB8bW9iaWxlLitmaXJlZm94fG5ldGZyb250fG9wZXJhIG0ob2J8aW4paXxwYWxtKCBvcyk/fHBob25lfHAoaXhpfHJlKVxcL3xwbHVja2VyfHBvY2tldHxwc3B8c2VyaWVzKDR8NikwfHN5bWJpYW58dHJlb3x1cFxcLihicm93c2VyfGxpbmspfHZvZGFmb25lfHdhcHx3aW5kb3dzIGNlfHhkYXx4aWluby9pLnRlc3QoYSkgfHwgLzEyMDd8NjMxMHw2NTkwfDNnc298NHRocHw1MFsxLTZdaXw3NzBzfDgwMnN8YSB3YXxhYmFjfGFjKGVyfG9vfHNcXC0pfGFpKGtvfHJuKXxhbChhdnxjYXxjbyl8YW1vaXxhbihleHxueXx5dyl8YXB0dXxhcihjaHxnbyl8YXModGV8dXMpfGF0dHd8YXUoZGl8XFwtbXxyIHxzICl8YXZhbnxiZShja3xsbHxucSl8YmkobGJ8cmQpfGJsKGFjfGF6KXxicihlfHYpd3xidW1ifGJ3XFwtKG58dSl8YzU1XFwvfGNhcGl8Y2N3YXxjZG1cXC18Y2VsbHxjaHRtfGNsZGN8Y21kXFwtfGNvKG1wfG5kKXxjcmF3fGRhKGl0fGxsfG5nKXxkYnRlfGRjXFwtc3xkZXZpfGRpY2F8ZG1vYnxkbyhjfHApb3xkcygxMnxcXC1kKXxlbCg0OXxhaSl8ZW0obDJ8dWwpfGVyKGljfGswKXxlc2w4fGV6KFs0LTddMHxvc3x3YXx6ZSl8ZmV0Y3xmbHkoXFwtfF8pfGcxIHV8ZzU2MHxnZW5lfGdmXFwtNXxnXFwtbW98Z28oXFwud3xvZCl8Z3IoYWR8dW4pfGhhaWV8aGNpdHxoZFxcLShtfHB8dCl8aGVpXFwtfGhpKHB0fHRhKXxocCggaXxpcCl8aHNcXC1jfGh0KGMoXFwtfCB8X3xhfGd8cHxzfHQpfHRwKXxodShhd3x0Yyl8aVxcLSgyMHxnb3xtYSl8aTIzMHxpYWMoIHxcXC18XFwvKXxpYnJvfGlkZWF8aWcwMXxpa29tfGltMWt8aW5ub3xpcGFxfGlyaXN8amEodHx2KWF8amJyb3xqZW11fGppZ3N8a2RkaXxrZWppfGtndCggfFxcLyl8a2xvbnxrcHQgfGt3Y1xcLXxreW8oY3xrKXxsZShub3x4aSl8bGcoIGd8XFwvKGt8bHx1KXw1MHw1NHxcXC1bYS13XSl8bGlid3xseW54fG0xXFwtd3xtM2dhfG01MFxcL3xtYSh0ZXx1aXx4byl8bWMoMDF8MjF8Y2EpfG1cXC1jcnxtZShyY3xyaSl8bWkobzh8b2F8dHMpfG1tZWZ8bW8oMDF8MDJ8Yml8ZGV8ZG98dChcXC18IHxvfHYpfHp6KXxtdCg1MHxwMXx2ICl8bXdicHxteXdhfG4xMFswLTJdfG4yMFsyLTNdfG4zMCgwfDIpfG41MCgwfDJ8NSl8bjcoMCgwfDEpfDEwKXxuZSgoY3xtKVxcLXxvbnx0Znx3Znx3Z3x3dCl8bm9rKDZ8aSl8bnpwaHxvMmltfG9wKHRpfHd2KXxvcmFufG93ZzF8cDgwMHxwYW4oYXxkfHQpfHBkeGd8cGcoMTN8XFwtKFsxLThdfGMpKXxwaGlsfHBpcmV8cGwoYXl8dWMpfHBuXFwtMnxwbyhja3xydHxzZSl8cHJveHxwc2lvfHB0XFwtZ3xxYVxcLWF8cWMoMDd8MTJ8MjF8MzJ8NjB8XFwtWzItN118aVxcLSl8cXRla3xyMzgwfHI2MDB8cmFrc3xyaW05fHJvKHZlfHpvKXxzNTVcXC98c2EoZ2V8bWF8bW18bXN8bnl8dmEpfHNjKDAxfGhcXC18b298cFxcLSl8c2RrXFwvfHNlKGMoXFwtfDB8MSl8NDd8bWN8bmR8cmkpfHNnaFxcLXxzaGFyfHNpZShcXC18bSl8c2tcXC0wfHNsKDQ1fGlkKXxzbShhbHxhcnxiM3xpdHx0NSl8c28oZnR8bnkpfHNwKDAxfGhcXC18dlxcLXx2ICl8c3koMDF8bWIpfHQyKDE4fDUwKXx0NigwMHwxMHwxOCl8dGEoZ3R8bGspfHRjbFxcLXx0ZGdcXC18dGVsKGl8bSl8dGltXFwtfHRcXC1tb3x0byhwbHxzaCl8dHMoNzB8bVxcLXxtM3xtNSl8dHhcXC05fHVwKFxcLmJ8ZzF8c2kpfHV0c3R8djQwMHx2NzUwfHZlcml8dmkocmd8dGUpfHZrKDQwfDVbMC0zXXxcXC12KXx2bTQwfHZvZGF8dnVsY3x2eCg1Mnw1M3w2MHw2MXw3MHw4MHw4MXw4M3w4NXw5OCl8dzNjKFxcLXwgKXx3ZWJjfHdoaXR8d2koZyB8bmN8bncpfHdtbGJ8d29udXx4NzAwfHlhc1xcLXx5b3VyfHpldG98enRlXFwtL2kudGVzdChhLnN1YnN0cigwLCA0KSkpIHtcbiAgICAgIGNoZWNrID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGlzSU9TKCkpIHtcbiAgICAgIGNoZWNrID0gdHJ1ZTtcbiAgICB9XG4gIH0pKG5hdmlnYXRvci51c2VyQWdlbnQgfHwgbmF2aWdhdG9yLnZlbmRvciB8fCB3aW5kb3cub3BlcmEpO1xuICByZXR1cm4gY2hlY2s7XG59O1xuXG52YXIgaXNJT1MgPSBtb2R1bGUuZXhwb3J0cy5pc0lPUyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIC9pUGFkfGlQaG9uZXxpUG9kLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSk7XG59O1xuXG4vKipcbiAqIENoZWNrcyBtb2JpbGUgZGV2aWNlIG9yaWVudGF0aW9uLlxuICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiBsYW5kc2NhcGUgb3JpZW50YXRpb24uXG4gKi9cbm1vZHVsZS5leHBvcnRzLmlzTGFuZHNjYXBlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gd2luZG93Lm9yaWVudGF0aW9uID09PSA5MCB8fCB3aW5kb3cub3JpZW50YXRpb24gPT09IC05MDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIHdlIHNob3VsZCBjYXB0dXJlIHRoaXMga2V5Ym9hcmQgZXZlbnQgZm9yIGtleWJvYXJkIHNob3J0Y3V0cy5cbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IEV2ZW50IG9iamVjdC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIHRoZSBrZXkgZXZlbnQgc2hvdWxkIGJlIGNhcHR1cmVkLlxuICovXG5tb2R1bGUuZXhwb3J0cy5zaG91bGRDYXB0dXJlS2V5RXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgaWYgKGV2ZW50LnNoaWZ0S2V5IHx8IGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuYWx0S2V5IHx8IGV2ZW50LmN0cmxLZXkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGRvY3VtZW50LmJvZHk7XG59O1xuXG4vKipcbiAqIFNwbGl0cyBhIHN0cmluZyBpbnRvIGFuIGFycmF5IGJhc2VkIG9uIGEgZGVsaW1pdGVyLlxuICpcbiAqIEBwYXJhbSAgIHtzdHJpbmc9fSBbc3RyPScnXSAgICAgICAgU291cmNlIHN0cmluZ1xuICogQHBhcmFtICAge3N0cmluZz19IFtkZWxpbWl0ZXI9JyAnXSBEZWxpbWl0ZXIgdG8gdXNlXG4gKiBAcmV0dXJucyB7YXJyYXl9ICAgICAgICAgICAgICAgICAgIEFycmF5IG9mIGRlbGltaXRlZCBzdHJpbmdzXG4gKi9cbm1vZHVsZS5leHBvcnRzLnNwbGl0U3RyaW5nID0gZnVuY3Rpb24gKHN0ciwgZGVsaW1pdGVyKSB7XG4gIGlmICh0eXBlb2YgZGVsaW1pdGVyID09PSAndW5kZWZpbmVkJykgeyBkZWxpbWl0ZXIgPSAnICc7IH1cbiAgLy8gRmlyc3QgY29sbGFwc2UgdGhlIHdoaXRlc3BhY2UgKG9yIHdoYXRldmVyIHRoZSBkZWxpbWl0ZXIgaXMpLlxuICB2YXIgcmVnZXggPSBuZXcgUmVnRXhwKGRlbGltaXRlciwgJ2cnKTtcbiAgc3RyID0gKHN0ciB8fCAnJykucmVwbGFjZShyZWdleCwgZGVsaW1pdGVyKTtcbiAgLy8gVGhlbiBzcGxpdC5cbiAgcmV0dXJuIHN0ci5zcGxpdChkZWxpbWl0ZXIpO1xufTtcblxuLyoqXG4gKiBFeHRyYWN0cyBkYXRhIGZyb20gdGhlIGVsZW1lbnQgZ2l2ZW4gYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgZXhwZWN0ZWQga2V5cy5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IFNvdXJjZSBlbGVtZW50LlxuICogQHBhcmFtIHtPYmplY3R9IFtkZWZhdWx0cz17fV0gT2JqZWN0IG9mIGRlZmF1bHQga2V5LXZhbHVlIHBhaXJzLlxuICogQHJldHVybnMge09iamVjdH1cbiAqL1xubW9kdWxlLmV4cG9ydHMuZ2V0RWxEYXRhID0gZnVuY3Rpb24gKGVsLCBkZWZhdWx0cykge1xuICBkZWZhdWx0cyA9IGRlZmF1bHRzIHx8IHt9O1xuICB2YXIgZGF0YSA9IHt9O1xuICBPYmplY3Qua2V5cyhkZWZhdWx0cykuZm9yRWFjaChjb3B5QXR0cmlidXRlKTtcbiAgZnVuY3Rpb24gY29weUF0dHJpYnV0ZSAoa2V5KSB7XG4gICAgaWYgKGVsLmhhc0F0dHJpYnV0ZShrZXkpKSB7XG4gICAgICBkYXRhW2tleV0gPSBlbC5nZXRBdHRyaWJ1dGUoa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRhdGE7XG59O1xuXG4vKipcbiAqIFJldHJpZXZlcyBxdWVyeXN0cmluZyB2YWx1ZS5cbiAqIEBwYXJhbSAge1N0cmluZ30gbmFtZSBOYW1lIG9mIHF1ZXJ5c3RyaW5nIGtleS5cbiAqIEByZXR1cm4ge1N0cmluZ30gICAgICBWYWx1ZVxuICovXG5tb2R1bGUuZXhwb3J0cy5nZXRVcmxQYXJhbWV0ZXIgPSBmdW5jdGlvbiAobmFtZSkge1xuICBuYW1lID0gbmFtZS5yZXBsYWNlKC9bXFxbXS8sICdcXFxcWycpLnJlcGxhY2UoL1tcXF1dLywgJ1xcXFxdJyk7XG4gIHZhciByZWdleCA9IG5ldyBSZWdFeHAoJ1tcXFxcPyZdJyArIG5hbWUgKyAnPShbXiYjXSopJyk7XG4gIHZhciByZXN1bHRzID0gcmVnZXguZXhlYyhsb2NhdGlvbi5zZWFyY2gpO1xuICByZXR1cm4gcmVzdWx0cyA9PT0gbnVsbCA/ICcnIDogZGVjb2RlVVJJQ29tcG9uZW50KHJlc3VsdHNbMV0ucmVwbGFjZSgvXFwrL2csICcgJykpO1xufTtcblxuLyoqXG4gKiBEZXRlY3RzIHdoZXRoZXIgY29udGV4dCBpcyB3aXRoaW4gaWZyYW1lLlxuICovXG5tb2R1bGUuZXhwb3J0cy5pc0lmcmFtZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB3aW5kb3cudG9wICE9PSB3aW5kb3cuc2VsZjtcbn07XG5cbi8vIE11c3QgYmUgYXQgYm90dG9tIHRvIGF2b2lkIGNpcmN1bGFyIGRlcGVuZGVuY3kuXG5tb2R1bGUuZXhwb3J0cy5zcmNMb2FkZXIgPSBfZGVyZXFfKCcuL3NyYy1sb2FkZXInKTtcblxufSx7XCIuL2Nvb3JkaW5hdGVzXCI6MTAwLFwiLi9kZWJ1Z1wiOjEwMSxcIi4vc3JjLWxvYWRlclwiOjEwMyxcIi4vc3R5bGVQYXJzZXJcIjoxMDQsXCIuL3RleHR1cmVcIjoxMDUsXCJkZWVwLWFzc2lnblwiOjYsXCJvYmplY3QtYXNzaWduXCI6OX1dLDEwMzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKiBnbG9iYWwgSW1hZ2UgKi9cbnZhciBkZWJ1ZyA9IF9kZXJlcV8oJy4vZGVidWcnKTtcblxudmFyIHdhcm4gPSBkZWJ1ZygndXRpbHM6c3JjLWxvYWRlcjp3YXJuJyk7XG5cbi8qKlxuICogVmFsaWRhdGVzIGEgdGV4dHVyZSwgZWl0aGVyIGFzIGEgc2VsZWN0b3Igb3IgYXMgYSBVUkwuXG4gKiBEZXRlY3RzIHdoZXRoZXIgYHNyY2AgaXMgcG9pbnRpbmcgdG8gYW4gaW1hZ2Ugb3IgdG8gYSB2aWRlbywgYW5kIGludm9rZXMgdGhlXG4gKiBhcHByb3ByaWF0ZSBjYWxsYmFjay5cbiAqXG4gKiBJZiBgc3JjYCBpcyBzZWxlY3RvciwgY2hlY2sgaWYgaXQncyB2YWxpZCwgcmV0dXJuIHRoZSBlbCBpbiB0aGUgY2FsbGJhY2suXG4gKiBBbiBlbCBpcyByZXR1cm5lZCBzbyB0aGF0IGl0IGNhbiBiZSByZXVzZWQgZm9yIHRleHR1cmUgbG9hZGluZy5cbiAqXG4gKiBJZiBgc3JjYCBpcyBhIFVSTCwgY2hlY2sgaWYgaXQncyB2YWxpZCwgcmV0dXJuIHRoZSBzcmMgaW4gdGhlIGNhbGxiYWNrLlxuICpcbiAqIEBwYXJhbXMge3N0cmluZ30gc3JjIC0gQSBzZWxlY3RvciBvciBhIFVSTC4gVVJMcyBtdXN0IGJlIHdyYXBwZWQgYnkgYHVybCgpYC5cbiAqIEBwYXJhbXMge2Z1bmN0aW9ufSBpc0ltYWdlQ2IgLSBjYWxsYmFjayBpZiB0ZXh0dXJlIGlzIGFuIGltYWdlLlxuICogQHBhcmFtcyB7ZnVuY3Rpb259IGlzVmlkZW9DYiAtIGNhbGxiYWNrIGlmIHRleHR1cmUgaXMgYSB2aWRlby5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVTcmMgKHNyYywgaXNJbWFnZUNiLCBpc1ZpZGVvQ2IpIHtcbiAgdmFyIHRleHR1cmVFbDtcbiAgdmFyIGlzSW1hZ2U7XG4gIHZhciBpc1ZpZGVvO1xuICB2YXIgdXJsID0gcGFyc2VVcmwoc3JjKTtcblxuICAvLyBzcmMgaXMgYSB1cmwuXG4gIGlmICh1cmwpIHtcbiAgICB2YWxpZGF0ZUltYWdlVXJsKHVybCwgZnVuY3Rpb24gaXNBbkltYWdlVXJsIChpc0ltYWdlKSB7XG4gICAgICBpZiAoIWlzSW1hZ2UpIHsgaXNWaWRlb0NiKHVybCk7IHJldHVybjsgfVxuICAgICAgaXNJbWFnZUNiKHVybCk7XG4gICAgfSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gc3JjIGlzIGEgcXVlcnkgc2VsZWN0b3IuXG4gIHRleHR1cmVFbCA9IHZhbGlkYXRlQW5kR2V0UXVlcnlTZWxlY3RvcihzcmMpO1xuICBpZiAoIXRleHR1cmVFbCkgeyByZXR1cm47IH1cbiAgaXNJbWFnZSA9IHRleHR1cmVFbCAmJiB0ZXh0dXJlRWwudGFnTmFtZSA9PT0gJ0lNRyc7XG4gIGlzVmlkZW8gPSB0ZXh0dXJlRWwgJiYgdGV4dHVyZUVsLnRhZ05hbWUgPT09ICdWSURFTyc7XG4gIGlmIChpc0ltYWdlKSB7IHJldHVybiBpc0ltYWdlQ2IodGV4dHVyZUVsKTsgfVxuICBpZiAoaXNWaWRlbykgeyByZXR1cm4gaXNWaWRlb0NiKHRleHR1cmVFbCk7IH1cblxuICAvLyBzcmMgaXMgYSB2YWxpZCBzZWxlY3RvciBidXQgZG9lc24ndCBtYXRjaCB3aXRoIGEgPGltZz4gb3IgPHZpZGVvPiBlbGVtZW50LlxuICB3YXJuKCdcIiVzXCIgZG9lcyBub3QgcG9pbnQgdG8gYSB2YWxpZCA8aW1nPiBvciA8dmlkZW8+IGVsZW1lbnQnLCBzcmMpO1xufVxuXG4vKipcbiAqIFZhbGlkYXRlcyBzaXggaW1hZ2VzIGFzIGEgY3ViZW1hcCwgZWl0aGVyIGFzIHNlbGVjdG9yIG9yIGNvbW1hLXNlcGFyYXRlZFxuICogVVJMcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3JjIC0gQSBzZWxlY3RvciBvciBjb21tYS1zZXBhcmF0ZWQgaW1hZ2UgVVJMcy4gSW1hZ2UgVVJMc1xuICAgICAgICAgIG11c3QgYmUgd3JhcHBlZCBieSBgdXJsKClgLlxuICogQHBhcmFtIHtzdHJpbmd9IHNyYyAtIEEgc2VsZWN0b3Igb3IgY29tbWEtc2VwYXJhdGVkIGltYWdlIFVSTHMuIEltYWdlIFVSTHNcbiAgICAgICAgICBtdXN0IGJlIHdyYXBwZWQgYnkgYHVybCgpYC5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVDdWJlbWFwU3JjIChzcmMsIGNiKSB7XG4gIHZhciBhQ3ViZW1hcDtcbiAgdmFyIGN1YmVtYXBTcmNSZWdleCA9ICcnO1xuICB2YXIgaTtcbiAgdmFyIHVybHM7XG4gIHZhciB2YWxpZGF0ZWRVcmxzID0gW107XG5cbiAgZm9yIChpID0gMDsgaSA8IDY7IGkrKykge1xuICAgIGN1YmVtYXBTcmNSZWdleCArPSAndXJsXFwoKC4rKVxcKVxccyosXFxzKic7XG4gIH1cbiAgdXJscyA9IHNyYy5tYXRjaChjdWJlbWFwU3JjUmVnZXgpO1xuXG4gIC8vIGBzcmNgIGlzIGEgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgVVJMcy5cbiAgLy8gSW4gdGhpcyBjYXNlLCByZS11c2UgdmFsaWRhdGVTcmMgZm9yIGVhY2ggc2lkZSBvZiB0aGUgY3ViZS5cbiAgZnVuY3Rpb24gaXNJbWFnZUNiICh1cmwpIHtcbiAgICB2YWxpZGF0ZWRVcmxzLnB1c2godXJsKTtcbiAgICBpZiAodmFsaWRhdGVkVXJscy5sZW5ndGggPT09IDYpIHtcbiAgICAgIGNiKHZhbGlkYXRlZFVybHMpO1xuICAgIH1cbiAgfVxuICBpZiAodXJscykge1xuICAgIGZvciAoaSA9IDE7IGkgPCA3OyBpKyspIHtcbiAgICAgIHZhbGlkYXRlU3JjKHVybHNbaV0sIGlzSW1hZ2VDYik7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGBzcmNgIGlzIGEgcXVlcnkgc2VsZWN0b3IgdG8gPGEtY3ViZW1hcD4gY29udGFpbmluZyBzaXggJChbc3JjXSlzLlxuICBhQ3ViZW1hcCA9IHZhbGlkYXRlQW5kR2V0UXVlcnlTZWxlY3RvcihzcmMpO1xuICBpZiAoIWFDdWJlbWFwKSB7IHJldHVybjsgfVxuICBpZiAoYUN1YmVtYXAudGFnTmFtZSA9PT0gJ0EtQ1VCRU1BUCcgJiYgYUN1YmVtYXAuc3Jjcykge1xuICAgIHJldHVybiBjYihhQ3ViZW1hcC5zcmNzKTtcbiAgfVxuICAvLyBFbHNlIGlmIGFDdWJlTWFwIGlzIG5vdCBhIDxhLWN1YmVtYXA+LlxuICB3YXJuKCdTZWxlY3RvciBcIiVzXCIgZG9lcyBub3QgcG9pbnQgdG8gPGEtY3ViZW1hcD4nLCBzcmMpO1xufVxuXG4vKipcbiAqIFBhcnNlcyBzcmMgZnJvbSBgdXJsKHNyYylgLlxuICogQHBhcmFtICB7c3RyaW5nfSBzcmMgLSBTdHJpbmcgdG8gcGFyc2UuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBwYXJzZWQgc3JjLCBpZiBwYXJzZWFibGUuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlVXJsIChzcmMpIHtcbiAgdmFyIHBhcnNlZFNyYyA9IHNyYy5tYXRjaCgvXFx1cmxcXCgoLispXFwpLyk7XG4gIGlmICghcGFyc2VkU3JjKSB7IHJldHVybjsgfVxuICByZXR1cm4gcGFyc2VkU3JjWzFdO1xufVxuXG4vKipcbiAqIFZhbGlkYXRlIHNyYyBpcyBhIHZhbGlkIGltYWdlIHVybFxuICogQHBhcmFtICB7c3RyaW5nfSBzcmMgLSB1cmwgdGhhdCB3aWxsIGJlIHRlc3RlZFxuICogQHBhcmFtICB7ZnVuY3Rpb259IG9uUmVzdWx0IC0gY2FsbGJhY2sgd2l0aCB0aGUgdGVzdCByZXN1bHRcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVJbWFnZVVybCAoc3JjLCBvblJlc3VsdCkge1xuICB2YXIgdGVzdGVyID0gbmV3IEltYWdlKCk7XG4gIHRlc3Rlci5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgb25Mb2FkKTtcbiAgZnVuY3Rpb24gb25Mb2FkICgpIHsgb25SZXN1bHQodHJ1ZSk7IH1cbiAgdGVzdGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgb25FcnJvcik7XG4gIGZ1bmN0aW9uIG9uRXJyb3IgKCkgeyBvblJlc3VsdChmYWxzZSk7IH1cbiAgdGVzdGVyLnNyYyA9IHNyYztcbn1cblxuLyoqXG4gKiBRdWVyeSBhbmQgdmFsaWRhdGUgYSBxdWVyeSBzZWxlY3RvcixcbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHNlbGVjdG9yIC0gRE9NIHNlbGVjdG9yLlxuICogQHJldHVybiB7b2JqZWN0fG51bGx8dW5kZWZpbmVkfSBTZWxlY3RlZCBET00gZWxlbWVudCBpZiBleGlzdHMuXG4gICAgICAgICAgIG51bGwgaWYgcXVlcnkgeWllbGRzIG5vIHJlc3VsdHMuXG4gICAgICAgICAgIHVuZGVmaW5lZCBpZiBgc2VsZWN0b3JgIGlzIG5vdCBhIHZhbGlkIHNlbGVjdG9yLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUFuZEdldFF1ZXJ5U2VsZWN0b3IgKHNlbGVjdG9yKSB7XG4gIHRyeSB7XG4gICAgdmFyIGVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgaWYgKCFlbCkge1xuICAgICAgd2FybignTm8gZWxlbWVudCB3YXMgZm91bmQgbWF0Y2hpbmcgdGhlIHNlbGVjdG9yOiBcIiVzXCInLCBzZWxlY3Rvcik7XG4gICAgfVxuICAgIHJldHVybiBlbDtcbiAgfSBjYXRjaCAoZSkgeyAgLy8gQ2FwdHVyZSBleGNlcHRpb24gaWYgaXQncyBub3QgYSB2YWxpZCBzZWxlY3Rvci5cbiAgICB3YXJuKCdcIiVzXCIgaXMgbm90IGEgdmFsaWQgc2VsZWN0b3InLCBzZWxlY3Rvcik7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcGFyc2VVcmw6IHBhcnNlVXJsLFxuICB2YWxpZGF0ZVNyYzogdmFsaWRhdGVTcmMsXG4gIHZhbGlkYXRlQ3ViZW1hcFNyYzogdmFsaWRhdGVDdWJlbWFwU3JjXG59O1xuXG59LHtcIi4vZGVidWdcIjoxMDF9XSwxMDQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLyogVXRpbHMgZm9yIHBhcnNpbmcgc3R5bGUtbGlrZSBzdHJpbmdzIChlLmcuLCBcInByaW1pdGl2ZTogYm94OyB3aWR0aDogNTsgaGVpZ2h0OiA0LjVcIikuICovXG52YXIgc3R5bGVQYXJzZXIgPSBfZGVyZXFfKCdzdHlsZS1hdHRyJyk7XG5cbi8qKlxuICogRGVzZXJpYWxpemVzIHN0eWxlLWxpa2Ugc3RyaW5nIGludG8gYW4gb2JqZWN0IG9mIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIC0gSFRNTCBhdHRyaWJ1dGUgdmFsdWUuXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBQcm9wZXJ0eSBkYXRhLlxuICovXG5tb2R1bGUuZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICB2YXIgcGFyc2VkRGF0YTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHsgcmV0dXJuIHZhbHVlOyB9XG4gIHBhcnNlZERhdGEgPSBzdHlsZVBhcnNlci5wYXJzZSh2YWx1ZSk7XG4gIHJldHVybiB0cmFuc2Zvcm1LZXlzVG9DYW1lbENhc2UocGFyc2VkRGF0YSk7XG59O1xuXG4vKipcbiAqIFNlcmlhbGl6ZSBhbiBvYmplY3Qgb2YgcHJvcGVydGllcyBpbnRvIGEgc3R5bGUtbGlrZSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGRhdGEgLSBQcm9wZXJ0eSBkYXRhLlxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xubW9kdWxlLmV4cG9ydHMuc3RyaW5naWZ5ID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykgeyByZXR1cm4gZGF0YTsgfVxuICByZXR1cm4gc3R5bGVQYXJzZXIuc3RyaW5naWZ5KGRhdGEpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBzdHJpbmcgZnJvbSBoeXBoZW4gdG8gY2FtZWxDYXNlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgLSBTdHJpbmcgdG8gY2FtZWxDYXNlLlxuICogQHJldHVybiB7c3RyaW5nfSBDYW1lbENhc2VkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gdG9DYW1lbENhc2UgKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoLy0oW2Etel0pL2csIGNhbWVsQ2FzZSk7XG4gIGZ1bmN0aW9uIGNhbWVsQ2FzZSAoZykgeyByZXR1cm4gZ1sxXS50b1VwcGVyQ2FzZSgpOyB9XG59XG5tb2R1bGUuZXhwb3J0cy50b0NhbWVsQ2FzZSA9IHRvQ2FtZWxDYXNlO1xuXG4vKipcbiAqIENvbnZlcnRzIG9iamVjdCdzIGtleXMgZnJvbSBoeXBoZW5zIHRvIGNhbWVsQ2FzZSAoZS5nLiwgYG1heC12YWx1ZWAgdG9cbiAqIGBtYXhWYWx1ZWApLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBvYmogLSBUaGUgb2JqZWN0IHRvIGNhbWVsQ2FzZSBrZXlzLlxuICogQHJldHVybiB7b2JqZWN0fSBUaGUgb2JqZWN0IHdpdGgga2V5cyBjYW1lbENhc2VkLlxuICovXG5mdW5jdGlvbiB0cmFuc2Zvcm1LZXlzVG9DYW1lbENhc2UgKG9iaikge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gIHZhciBjYW1lbENhc2VPYmogPSB7fTtcbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgY2FtZWxDYXNlS2V5ID0gdG9DYW1lbENhc2Uoa2V5KTtcbiAgICBjYW1lbENhc2VPYmpbY2FtZWxDYXNlS2V5XSA9IG9ialtrZXldO1xuICB9KTtcbiAgcmV0dXJuIGNhbWVsQ2FzZU9iajtcbn1cbm1vZHVsZS5leHBvcnRzLnRyYW5zZm9ybUtleXNUb0NhbWVsQ2FzZSA9IHRyYW5zZm9ybUtleXNUb0NhbWVsQ2FzZTtcblxufSx7XCJzdHlsZS1hdHRyXCI6MTV9XSwxMDU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBUZXh0dXJlIGhlbHBlcnMgZm9yIHN0YW5kYXJkIG1hdGVyaWFsIGNvbXBvbmVudC5cbiAqXG4gKiBAbWVtYmVyIHRleHR1cmVDYWNoZSB7b2JqZWN0fSAtIFRleHR1cmUgY2FjaGUgZm9yOlxuICogICAtIEltYWdlczogdGV4dHVyZUNhY2hlIGhhcyBtYXBwaW5nIG9mIHNyYyAtPiByZXBlYXQgLT4gY2FjaGVkIHRocmVlLmpzIHRleHR1cmUuXG4gKiAgIC0gVmlkZW9zOiB0ZXh0dXJlQ2FjaGUgaGFzIG1hcHBpbmcgb2YgdmlkZW9FbGVtZW50IC0+IGNhY2hlZCB0aHJlZS5qcyB0ZXh0dXJlLlxuICogQG1lbWJlciB2aWRlb0NhY2hlIHtvYmplY3R9IC0gQ2FjaGUgb2YgdmlkZW8gZWxlbWVudHMuXG4gKi9cbnZhciBkZWJ1ZyA9IF9kZXJlcV8oJy4vZGVidWcnKTtcbnZhciBUSFJFRSA9IF9kZXJlcV8oJy4uL2xpYi90aHJlZScpO1xuXG52YXIgRVZFTlRTID0ge1xuICBURVhUVVJFX0xPQURFRDogJ21hdGVyaWFsLXRleHR1cmUtbG9hZGVkJ1xufTtcbnZhciBlcnJvciA9IGRlYnVnKCdjb21wb25lbnRzOnRleHR1cmU6ZXJyb3InKTtcbnZhciB0ZXh0dXJlQ2FjaGUgPSB7fTtcbnZhciBUZXh0dXJlTG9hZGVyID0gbmV3IFRIUkVFLlRleHR1cmVMb2FkZXIoKTtcbnZhciB3YXJuID0gZGVidWcoJ2NvbXBvbmVudHM6dGV4dHVyZTp3YXJuJyk7XG5cbi8qKlxuICogSGlnaC1sZXZlbCBmdW5jdGlvbiBmb3IgbG9hZGluZyBpbWFnZSB0ZXh0dXJlcy4gTWVhdCBvZiBsb2dpYyBpcyBpbiBgbG9hZEltYWdlVGV4dHVyZWAuXG4gKiBCb3VuZCB0byBtYXRlcmlhbCBjb21wb25lbnQgaW5zdGFuY2UgYW5kIHRocmVlLmpzIG1hdGVyaWFsLlxuICpcbiAqIEBwYXJhbSBtYXRlcmlhbCB7b2JqZWN0fSAtIHRocmVlLmpzIG1hdGVyaWFsLCBib3VuZCBieSB0aGUgQS1GcmFtZSBzaGFkZXIuXG4gKiBAcGFyYW0gZGF0YSB7b2JqZWN0fSAtIFNoYWRlciBkYXRhLCBib3VuZCBieSB0aGUgQS1GcmFtZSBzaGFkZXIuXG4gKiBAcGFyYW0gc3JjIHtFbGVtZW50fHN0cmluZ30gLSBUZXh0dXJlIHNvdXJjZSwgYm91bmQgYnkgYHNyYy1sb2FkZXJgIHV0aWxzLlxuICovXG5mdW5jdGlvbiBsb2FkSW1hZ2UgKG1hdGVyaWFsLCBkYXRhLCBzcmMpIHtcbiAgdmFyIGVsID0gdGhpcy5lbDtcbiAgdmFyIHJlcGVhdCA9IGRhdGEucmVwZWF0IHx8ICcxIDEnO1xuICB2YXIgc3JjU3RyaW5nID0gc3JjO1xuXG4gIGlmICh0eXBlb2Ygc3JjICE9PSAnc3RyaW5nJykgeyBzcmNTdHJpbmcgPSBzcmMuZ2V0QXR0cmlidXRlKCdzcmMnKTsgfVxuXG4gIC8vIEFub3RoZXIgbWF0ZXJpYWwgaXMgYWxyZWFkeSBsb2FkaW5nIHRoaXMgdGV4dHVyZS4gV2FpdCBvbiBwcm9taXNlLlxuICBpZiAodGV4dHVyZUNhY2hlW3NyY10gJiYgdGV4dHVyZUNhY2hlW3NyY11bcmVwZWF0XSkge1xuICAgIHRleHR1cmVDYWNoZVtzcmNdW3JlcGVhdF0udGhlbihoYW5kbGVJbWFnZVRleHR1cmVMb2FkZWQpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIE1hdGVyaWFsIGluc3RhbmNlIGlzIGZpcnN0IHRvIHRyeSB0byBsb2FkIHRoaXMgdGV4dHVyZS4gTG9hZCBpdC5cbiAgdGV4dHVyZUNhY2hlW3NyY1N0cmluZ10gPSB0ZXh0dXJlQ2FjaGVbc3JjU3RyaW5nXSB8fCB7fTtcbiAgdGV4dHVyZUNhY2hlW3NyY1N0cmluZ11bcmVwZWF0XSA9IHRleHR1cmVDYWNoZVtzcmNTdHJpbmddW3JlcGVhdF0gfHwge307XG4gIHRleHR1cmVDYWNoZVtzcmNTdHJpbmddW3JlcGVhdF0gPSBsb2FkSW1hZ2VUZXh0dXJlKG1hdGVyaWFsLCBzcmMsIHJlcGVhdCk7XG4gIHRleHR1cmVDYWNoZVtzcmNTdHJpbmddW3JlcGVhdF0udGhlbihoYW5kbGVJbWFnZVRleHR1cmVMb2FkZWQpO1xuXG4gIGZ1bmN0aW9uIGhhbmRsZUltYWdlVGV4dHVyZUxvYWRlZCAodGV4dHVyZSkge1xuICAgIHVwZGF0ZU1hdGVyaWFsKG1hdGVyaWFsLCB0ZXh0dXJlKTtcbiAgICBlbC5lbWl0KEVWRU5UUy5URVhUVVJFX0xPQURFRCwgeyBzcmM6IHNyYywgdGV4dHVyZTogdGV4dHVyZSB9KTtcbiAgfVxufVxuXG4vKipcbiAqIExvYWQgdmlkZW8gdGV4dHVyZS5cbiAqIEJvdW5kIHRvIG1hdGVyaWFsIGNvbXBvbmVudCBpbnN0YW5jZSBhbmQgdGhyZWUuanMgbWF0ZXJpYWwuXG4gKiBOb3RlIHRoYXQgY3JlYXRpbmcgYSB2aWRlbyB0ZXh0dXJlIGlzIG1vcmUgc3luY2hyb25vdXMgdGhhbiBjcmVhdGluZyBhbiBpbWFnZSB0ZXh0dXJlLlxuICpcbiAqIEBwYXJhbSBtYXRlcmlhbCB7b2JqZWN0fSAtIHRocmVlLmpzIG1hdGVyaWFsLCBib3VuZCBieSB0aGUgQS1GcmFtZSBzaGFkZXIuXG4gKiBAcGFyYW0gZGF0YSB7b2JqZWN0fSAtIFNoYWRlciBkYXRhLCBib3VuZCBieSB0aGUgQS1GcmFtZSBzaGFkZXIuXG4gKiBAcGFyYW0gc3JjIHtFbGVtZW50fHN0cmluZ30gLSBUZXh0dXJlIHNvdXJjZSwgYm91bmQgYnkgYHNyYy1sb2FkZXJgIHV0aWxzLlxuICovXG5mdW5jdGlvbiBsb2FkVmlkZW8gKG1hdGVyaWFsLCBkYXRhLCBzcmMpIHtcbiAgdmFyIGVsID0gdGhpcy5lbDtcbiAgdmFyIGhhc2g7XG4gIHZhciB0ZXh0dXJlO1xuICB2YXIgdmlkZW9FbDtcbiAgdmFyIHZpZGVvVGV4dHVyZVJlc3VsdDtcblxuICBpZiAodHlwZW9mIHNyYyAhPT0gJ3N0cmluZycpIHtcbiAgICAvLyBDaGVjayBjYWNoZSBiZWZvcmUgY3JlYXRpbmcgdGV4dHVyZS5cbiAgICB2aWRlb0VsID0gc3JjO1xuICAgIGhhc2ggPSBjYWxjdWxhdGVWaWRlb0NhY2hlSGFzaCh2aWRlb0VsKTtcbiAgICBpZiAodGV4dHVyZUNhY2hlW2hhc2hdKSB7XG4gICAgICB0ZXh0dXJlQ2FjaGVbaGFzaF0udGhlbihoYW5kbGVWaWRlb1RleHR1cmVMb2FkZWQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIElmIG5vdCBpbiBjYWNoZSwgZml4IHVwIHRoZSBhdHRyaWJ1dGVzIHRoZW4gc3RhcnQgdG8gY3JlYXRlIHRoZSB0ZXh0dXJlLlxuICAgIGZpeFZpZGVvQXR0cmlidXRlcyh2aWRlb0VsKTtcbiAgfVxuXG4gIC8vIFVzZSB2aWRlbyBlbGVtZW50IHRvIGNyZWF0ZSB0ZXh0dXJlLlxuICB2aWRlb0VsID0gdmlkZW9FbCB8fCBjcmVhdGVWaWRlb0VsKG1hdGVyaWFsLCBzcmMsIGRhdGEud2lkdGgsIGRhdGEuaGVpZ2h0KTtcblxuICAvLyBHZW5lcmF0ZWQgdmlkZW8gZWxlbWVudCBhbHJlYWR5IGNhY2hlZC4gVXNlIHRoYXQuXG4gIGhhc2ggPSBjYWxjdWxhdGVWaWRlb0NhY2hlSGFzaCh2aWRlb0VsKTtcbiAgaWYgKHRleHR1cmVDYWNoZVtoYXNoXSkge1xuICAgIHRleHR1cmVDYWNoZVtoYXNoXS50aGVuKGhhbmRsZVZpZGVvVGV4dHVyZUxvYWRlZCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gQ3JlYXRlIG5ldyB2aWRlbyB0ZXh0dXJlLlxuICB0ZXh0dXJlID0gbmV3IFRIUkVFLlZpZGVvVGV4dHVyZSh2aWRlb0VsKTtcbiAgdGV4dHVyZS5taW5GaWx0ZXIgPSBUSFJFRS5MaW5lYXJGaWx0ZXI7XG5cbiAgdmlkZW9UZXh0dXJlUmVzdWx0ID0ge1xuICAgIHRleHR1cmU6IHRleHR1cmUsXG4gICAgdmlkZW9FbDogdmlkZW9FbFxuICB9O1xuXG4gIC8vIENhY2hlIGFzIHByb21pc2UgdG8gYmUgY29uc2lzdGVudCB3aXRoIGltYWdlIHRleHR1cmUgY2FjaGluZy5cbiAgdGV4dHVyZUNhY2hlW2hhc2hdID0gUHJvbWlzZS5yZXNvbHZlKHZpZGVvVGV4dHVyZVJlc3VsdCk7XG4gIGhhbmRsZVZpZGVvVGV4dHVyZUxvYWRlZCh2aWRlb1RleHR1cmVSZXN1bHQpO1xuXG4gIGZ1bmN0aW9uIGhhbmRsZVZpZGVvVGV4dHVyZUxvYWRlZCAocmVzKSB7XG4gICAgdGV4dHVyZSA9IHJlcy50ZXh0dXJlO1xuICAgIHZpZGVvRWwgPSByZXMudmlkZW9FbDtcbiAgICB1cGRhdGVNYXRlcmlhbChtYXRlcmlhbCwgdGV4dHVyZSk7XG4gICAgZWwuZW1pdChFVkVOVFMuVEVYVFVSRV9MT0FERUQsIHsgZWxlbWVudDogdmlkZW9FbCwgc3JjOiBzcmMgfSk7XG4gICAgdmlkZW9FbC5hZGRFdmVudExpc3RlbmVyKCdsb2FkZWRkYXRhJywgZnVuY3Rpb24gKCkge1xuICAgICAgZWwuZW1pdCgnbWF0ZXJpYWwtdmlkZW8tbG9hZGVkZGF0YScsIHsgZWxlbWVudDogdmlkZW9FbCwgc3JjOiBzcmMgfSk7XG4gICAgfSk7XG4gICAgdmlkZW9FbC5hZGRFdmVudExpc3RlbmVyKCdlbmRlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIFdvcmtzIGZvciBub24tbG9vcGluZyB2aWRlb3Mgb25seS5cbiAgICAgIGVsLmVtaXQoJ21hdGVyaWFsLXZpZGVvLWVuZGVkJywgeyBlbGVtZW50OiB2aWRlb0VsLCBzcmM6IHNyYyB9KTtcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgY29uc2lzdGVudCBoYXNoIGZyb20gYSB2aWRlbyBlbGVtZW50IHVzaW5nIGl0cyBhdHRyaWJ1dGVzLlxuICogSWYgdGhlIHZpZGVvIGVsZW1lbnQgaGFzIGFuIElELCB1c2UgdGhhdC5cbiAqIEVsc2UgYnVpbGQgYSBoYXNoIHRoYXQgbG9va3MgbGlrZSBgc3JjOm15dmlkZW8ubXA0O2hlaWdodDoyMDA7d2lkdGg6NDAwO2AuXG4gKlxuICogQHBhcmFtIHZpZGVvRWwge0VsZW1lbnR9IC0gVmlkZW8gZWxlbWVudC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGNhbGN1bGF0ZVZpZGVvQ2FjaGVIYXNoICh2aWRlb0VsKSB7XG4gIHZhciBpO1xuICB2YXIgaWQgPSB2aWRlb0VsLmdldEF0dHJpYnV0ZSgnaWQnKTtcbiAgdmFyIGhhc2g7XG4gIHZhciB2aWRlb0F0dHJpYnV0ZXM7XG5cbiAgaWYgKGlkKSB7IHJldHVybiBpZDsgfVxuXG4gIC8vIENhbGN1bGF0ZSBoYXNoIHVzaW5nIHNvcnRlZCB2aWRlbyBhdHRyaWJ1dGVzLlxuICBoYXNoID0gJyc7XG4gIHZpZGVvQXR0cmlidXRlcyA9IHt9O1xuICBmb3IgKGkgPSAwOyBpIDwgdmlkZW9FbC5hdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmlkZW9BdHRyaWJ1dGVzW3ZpZGVvRWwuYXR0cmlidXRlc1tpXS5uYW1lXSA9IHZpZGVvRWwuYXR0cmlidXRlc1tpXS52YWx1ZTtcbiAgfVxuICBPYmplY3Qua2V5cyh2aWRlb0F0dHJpYnV0ZXMpLnNvcnQoKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaGFzaCArPSBuYW1lICsgJzonICsgdmlkZW9BdHRyaWJ1dGVzW25hbWVdICsgJzsnO1xuICB9KTtcblxuICByZXR1cm4gaGFzaDtcbn1cblxuLyoqXG4gKiBTZXQgbWF0ZXJpYWwgdGV4dHVyZSBhbmQgdXBkYXRlIGlmIG5lY2Vzc2FyeS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbWF0ZXJpYWxcbiAqIEBwYXJhbSB7b2JqZWN0fSB0ZXh0dXJlXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZU1hdGVyaWFsIChtYXRlcmlhbCwgdGV4dHVyZSkge1xuICB2YXIgb2xkTWFwID0gbWF0ZXJpYWwubWFwO1xuICBpZiAodGV4dHVyZSkgeyB0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTsgfVxuICBtYXRlcmlhbC5tYXAgPSB0ZXh0dXJlO1xuXG4gIC8vIE9ubHkgbmVlZCB0byB1cGRhdGUgdGhyZWUuanMgbWF0ZXJpYWwgaWYgcHJlc2VuY2Ugb3Igbm90IG9mIHRleHR1cmUgaGFzIGNoYW5nZWQuXG4gIGlmIChvbGRNYXAgPT09IG51bGwgJiYgbWF0ZXJpYWwubWFwIHx8IG1hdGVyaWFsLm1hcCA9PT0gbnVsbCAmJiBvbGRNYXApIHtcbiAgICBtYXRlcmlhbC5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cbn1cblxuLyoqXG4gKiBTZXQgaW1hZ2UgdGV4dHVyZSBvbiBtYXRlcmlhbCBhcyBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtvYmplY3R9IGVsIC0gRW50aXR5IGVsZW1lbnQuXG4gKiBAcGFyYW0ge29iamVjdH0gbWF0ZXJpYWwgLSB0aHJlZS5qcyBtYXRlcmlhbC5cbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gc3JjIC0gQW4gPGltZz4gZWxlbWVudCBvciB1cmwgdG8gYW4gaW1hZ2UgZmlsZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSByZXBlYXQgLSBYIGFuZCBZIHZhbHVlIGZvciBzaXplIG9mIHRleHR1cmUgcmVwZWF0aW5nIChpbiBVViB1bml0cykuXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gUmVzb2x2ZXMgb25jZSB0ZXh0dXJlIGlzIGxvYWRlZC5cbiAqL1xuZnVuY3Rpb24gbG9hZEltYWdlVGV4dHVyZSAobWF0ZXJpYWwsIHNyYywgcmVwZWF0KSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShkb0xvYWRJbWFnZVRleHR1cmUpO1xuXG4gIGZ1bmN0aW9uIGRvTG9hZEltYWdlVGV4dHVyZSAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFyIGlzRWwgPSB0eXBlb2Ygc3JjICE9PSAnc3RyaW5nJztcblxuICAgIC8vIENyZWF0ZSB0ZXh0dXJlIGZyb20gYW4gZWxlbWVudC5cbiAgICBpZiAoaXNFbCkge1xuICAgICAgY3JlYXRlVGV4dHVyZShzcmMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIExvYWQgdGV4dHVyZSBmcm9tIHNyYyBzdHJpbmcuIFRIUkVFIHdpbGwgY3JlYXRlIHVuZGVybHlpbmcgZWxlbWVudC5cbiAgICAvLyBVc2UgVEhSRUUuVGV4dHVyZUxvYWRlciAoc3JjLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IpIHRvIGxvYWQgdGV4dHVyZS5cbiAgICBUZXh0dXJlTG9hZGVyLmxvYWQoXG4gICAgICBzcmMsXG4gICAgICBjcmVhdGVUZXh0dXJlLFxuICAgICAgZnVuY3Rpb24gKCkgeyAvKiBuby1vcCAqLyB9LFxuICAgICAgZnVuY3Rpb24gKHhocikge1xuICAgICAgICBlcnJvcignYCRzYCBjb3VsZCBub3QgYmUgZmV0Y2hlZCAoRXJyb3IgY29kZTogJXM7IFJlc3BvbnNlOiAlcyknLCB4aHIuc3RhdHVzLFxuICAgICAgICAgICAgICB4aHIuc3RhdHVzVGV4dCk7XG4gICAgICB9XG4gICAgKTtcblxuICAgIC8qKlxuICAgICAqIFRleHR1cmUgbG9hZGVkLiBTZXQgaXQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlVGV4dHVyZSAodGV4dHVyZSkge1xuICAgICAgdmFyIHJlcGVhdFhZO1xuICAgICAgaWYgKCEodGV4dHVyZSBpbnN0YW5jZW9mIFRIUkVFLlRleHR1cmUpKSB7IHRleHR1cmUgPSBuZXcgVEhSRUUuVGV4dHVyZSh0ZXh0dXJlKTsgfVxuXG4gICAgICAvLyBIYW5kbGUgVVYgcmVwZWF0LlxuICAgICAgcmVwZWF0WFkgPSByZXBlYXQuc3BsaXQoJyAnKTtcbiAgICAgIGlmIChyZXBlYXRYWS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgdGV4dHVyZS53cmFwUyA9IFRIUkVFLlJlcGVhdFdyYXBwaW5nO1xuICAgICAgICB0ZXh0dXJlLndyYXBUID0gVEhSRUUuUmVwZWF0V3JhcHBpbmc7XG4gICAgICAgIHRleHR1cmUucmVwZWF0LnNldChwYXJzZUludChyZXBlYXRYWVswXSwgMTApLCBwYXJzZUludChyZXBlYXRYWVsxXSwgMTApKTtcbiAgICAgIH1cblxuICAgICAgcmVzb2x2ZSh0ZXh0dXJlKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDcmVhdGUgdmlkZW8gZWxlbWVudCB0byBiZSB1c2VkIGFzIGEgdGV4dHVyZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbWF0ZXJpYWwgLSB0aHJlZS5qcyBtYXRlcmlhbC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzcmMgLSBVcmwgdG8gYSB2aWRlbyBmaWxlLlxuICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gV2lkdGggb2YgdGhlIHZpZGVvLlxuICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIEhlaWdodCBvZiB0aGUgdmlkZW8uXG4gKiBAcmV0dXJucyB7RWxlbWVudH0gVmlkZW8gZWxlbWVudC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlVmlkZW9FbCAobWF0ZXJpYWwsIHNyYywgd2lkdGgsIGhlaWdodCkge1xuICB2YXIgZWwgPSBtYXRlcmlhbC52aWRlb0VsIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ZpZGVvJyk7XG4gIGVsLndpZHRoID0gd2lkdGg7XG4gIGVsLmhlaWdodCA9IGhlaWdodDtcbiAgaWYgKGVsICE9PSB0aGlzLnZpZGVvRWwpIHtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoJ3dlYmtpdC1wbGF5c2lubGluZScsICcnKTsgIC8vIFRvIHN1cHBvcnQgaW5saW5lIHZpZGVvcyBpbiBpT1Mgd2Vidmlld3MuXG4gICAgZWwuYXV0b3BsYXkgPSB0cnVlO1xuICAgIGVsLmxvb3AgPSB0cnVlO1xuICAgIGVsLmNyb3NzT3JpZ2luID0gdHJ1ZTtcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHdhcm4oJ2Akc2AgaXMgbm90IGEgdmFsaWQgdmlkZW8nLCBzcmMpO1xuICAgIH0sIHRydWUpO1xuICAgIG1hdGVyaWFsLnZpZGVvRWwgPSBlbDtcbiAgfVxuICBlbC5zcmMgPSBzcmM7XG4gIHJldHVybiBlbDtcbn1cblxuLyoqXG4gKiBGaXhlcyBhIHZpZGVvIGVsZW1lbnQncyBhdHRyaWJ1dGVzIHRvIHByZXZlbnQgZGV2ZWxvcGVycyBmcm9tIGFjY2lkZW50YWxseSBwYXNzaW5nIHRoZVxuICogd3JvbmcgYXR0cmlidXRlIHZhbHVlcyB0byBjb21tb25seSBtaXN1c2VkIHZpZGVvIGF0dHJpYnV0ZXMuXG4gKlxuICogPHZpZGVvPiBkb2VzIG5vdCB0cmVhdCBgYXV0b3BsYXlgLCBgY29udHJvbHNgLCBgY3Jvc3NvcmlnaW5gLCBgbG9vcGAsIGFuZCBgcHJlbG9hZGAgYXNcbiAqIGFzIGJvb2xlYW5zLiBFeGlzdGVuY2Ugb2YgdGhvc2UgYXR0cmlidXRlcyB3aWxsIG1lYW4gdHJ1dGh5LlxuICpcbiAqIEZvciBleGFtcGxlLCB0cmFuc2xhdGVzIDx2aWRlbyBsb29wPVwiZmFsc2VcIj4gdG8gPHZpZGVvPi5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0hUTUwvRWxlbWVudC92aWRlbyNBdHRyaWJ1dGVzXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHZpZGVvRWwgLSBWaWRlbyBlbGVtZW50LlxuICogQHJldHVybnMge0VsZW1lbnR9IFZpZGVvIGVsZW1lbnQgd2l0aCB0aGUgY29ycmVjdCBwcm9wZXJ0aWVzIHVwZGF0ZWQuXG4gKi9cbmZ1bmN0aW9uIGZpeFZpZGVvQXR0cmlidXRlcyAodmlkZW9FbCkge1xuICB2aWRlb0VsLmF1dG9wbGF5ID0gdmlkZW9FbC5nZXRBdHRyaWJ1dGUoJ2F1dG9wbGF5JykgIT09ICdmYWxzZSc7XG4gIHZpZGVvRWwuY29udHJvbHMgPSB2aWRlb0VsLmdldEF0dHJpYnV0ZSgnY29udHJvbHMnKSAhPT0gJ2ZhbHNlJztcbiAgaWYgKHZpZGVvRWwuZ2V0QXR0cmlidXRlKCdsb29wJykgPT09ICdmYWxzZScpIHtcbiAgICB2aWRlb0VsLnJlbW92ZUF0dHJpYnV0ZSgnbG9vcCcpO1xuICB9XG4gIGlmICh2aWRlb0VsLmdldEF0dHJpYnV0ZSgncHJlbG9hZCcpID09PSAnZmFsc2UnKSB7XG4gICAgdmlkZW9FbC5wcmVsb2FkID0gJ25vbmUnO1xuICB9XG4gIGlmICghdmlkZW9FbC5oYXNBdHRyaWJ1dGUoJ2Nyb3Nzb3JpZ2luJykpIHtcbiAgICB2aWRlb0VsLmNyb3NzT3JpZ2luID0gdHJ1ZTtcbiAgfVxuICBpZiAoIXZpZGVvRWwuaGFzQXR0cmlidXRlKCd3ZWJraXQtcGxheXNpbmxpbmUnKSkge1xuICAgIHZpZGVvRWwuc2V0QXR0cmlidXRlKCd3ZWJraXQtcGxheXNpbmxpbmUnLCAnJyk7ICAvLyBUbyBzdXBwb3J0IGlubGluZSB2aWRlb3MgaW4gaU9TIHdlYnZpZXdzLlxuICB9XG4gIHJldHVybiB2aWRlb0VsO1xufVxuXG5mdW5jdGlvbiBjbGVhclRleHR1cmVDYWNoZSAoKSB7XG4gIHRleHR1cmVDYWNoZSA9IHt9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY2xlYXJUZXh0dXJlQ2FjaGU6IGNsZWFyVGV4dHVyZUNhY2hlLFxuICBjcmVhdGVWaWRlb0VsOiBjcmVhdGVWaWRlb0VsLFxuICBmaXhWaWRlb0F0dHJpYnV0ZXM6IGZpeFZpZGVvQXR0cmlidXRlcyxcbiAgbG9hZEltYWdlOiBsb2FkSW1hZ2UsXG4gIGxvYWRWaWRlbzogbG9hZFZpZGVvLFxuICB0ZXh0dXJlQ2FjaGU6IHRleHR1cmVDYWNoZSxcbiAgdXBkYXRlTWF0ZXJpYWw6IHVwZGF0ZU1hdGVyaWFsXG59O1xuXG59LHtcIi4uL2xpYi90aHJlZVwiOjkwLFwiLi9kZWJ1Z1wiOjEwMX1dLDEwNjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG53aW5kb3cuZ2xTdGF0cyA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBfclMgPSBudWxsO1xuXG4gICAgdmFyIF90b3RhbERyYXdBcnJheXNDYWxscyA9IDAsXG4gICAgICAgIF90b3RhbERyYXdFbGVtZW50c0NhbGxzID0gMCxcbiAgICAgICAgX3RvdGFsVXNlUHJvZ3JhbUNhbGxzID0gMCxcbiAgICAgICAgX3RvdGFsRmFjZXMgPSAwLFxuICAgICAgICBfdG90YWxWZXJ0aWNlcyA9IDAsXG4gICAgICAgIF90b3RhbFBvaW50cyA9IDAsXG4gICAgICAgIF90b3RhbEJpbmRUZXh1cmVzID0gMDtcblxuICAgIGZ1bmN0aW9uIF9oICggZiwgYyApIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGMuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuICAgICAgICAgICAgZi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgV2ViR0xSZW5kZXJpbmdDb250ZXh0LnByb3RvdHlwZS5kcmF3QXJyYXlzID0gX2goIFdlYkdMUmVuZGVyaW5nQ29udGV4dC5wcm90b3R5cGUuZHJhd0FycmF5cywgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdG90YWxEcmF3QXJyYXlzQ2FsbHMrKztcbiAgICAgICAgaWYgKCBhcmd1bWVudHNbIDAgXSA9PSB0aGlzLlBPSU5UUyApIF90b3RhbFBvaW50cyArPSBhcmd1bWVudHNbIDIgXTtcbiAgICAgICAgZWxzZSBfdG90YWxWZXJ0aWNlcyArPSBhcmd1bWVudHNbIDIgXTtcbiAgICB9ICk7XG5cbiAgICBXZWJHTFJlbmRlcmluZ0NvbnRleHQucHJvdG90eXBlLmRyYXdFbGVtZW50cyA9IF9oKCBXZWJHTFJlbmRlcmluZ0NvbnRleHQucHJvdG90eXBlLmRyYXdFbGVtZW50cywgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdG90YWxEcmF3RWxlbWVudHNDYWxscysrO1xuICAgICAgICBfdG90YWxGYWNlcyArPSBhcmd1bWVudHNbIDEgXSAvIDM7XG4gICAgICAgIF90b3RhbFZlcnRpY2VzICs9IGFyZ3VtZW50c1sgMSBdO1xuICAgIH0gKTtcblxuICAgIFdlYkdMUmVuZGVyaW5nQ29udGV4dC5wcm90b3R5cGUudXNlUHJvZ3JhbSA9IF9oKCBXZWJHTFJlbmRlcmluZ0NvbnRleHQucHJvdG90eXBlLnVzZVByb2dyYW0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RvdGFsVXNlUHJvZ3JhbUNhbGxzKys7XG4gICAgfSApO1xuXG4gICAgV2ViR0xSZW5kZXJpbmdDb250ZXh0LnByb3RvdHlwZS5iaW5kVGV4dHVyZSA9IF9oKCBXZWJHTFJlbmRlcmluZ0NvbnRleHQucHJvdG90eXBlLmJpbmRUZXh0dXJlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90b3RhbEJpbmRUZXh1cmVzKys7XG4gICAgfSApO1xuXG4gICAgdmFyIF92YWx1ZXMgPSB7XG4gICAgICAgIGFsbGNhbGxzOiB7XG4gICAgICAgICAgICBvdmVyOiAzMDAwLFxuICAgICAgICAgICAgY2FwdGlvbjogJ0NhbGxzIChob29rKSdcbiAgICAgICAgfSxcbiAgICAgICAgZHJhd2VsZW1lbnRzOiB7XG4gICAgICAgICAgICBjYXB0aW9uOiAnZHJhd0VsZW1lbnRzIChob29rKSdcbiAgICAgICAgfSxcbiAgICAgICAgZHJhd2FycmF5czoge1xuICAgICAgICAgICAgY2FwdGlvbjogJ2RyYXdBcnJheXMgKGhvb2spJ1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBfZ3JvdXBzID0gWyB7XG4gICAgICAgIGNhcHRpb246ICdXZWJHTCcsXG4gICAgICAgIHZhbHVlczogWyAnYWxsY2FsbHMnLCAnZHJhd2VsZW1lbnRzJywgJ2RyYXdhcnJheXMnLCAndXNlcHJvZ3JhbScsICdiaW5kdGV4dHVyZScsICdnbGZhY2VzJywgJ2dsdmVydGljZXMnLCAnZ2xwb2ludHMnIF1cbiAgICB9IF07XG5cbiAgICB2YXIgX2ZyYWN0aW9ucyA9IFsge1xuICAgICAgICBiYXNlOiAnYWxsY2FsbHMnLFxuICAgICAgICBzdGVwczogWyAnZHJhd2VsZW1lbnRzJywgJ2RyYXdhcnJheXMnIF1cbiAgICB9IF07XG5cbiAgICBmdW5jdGlvbiBfdXBkYXRlICgpIHtcbiAgICAgICAgX3JTKCAnYWxsY2FsbHMnICkuc2V0KCBfdG90YWxEcmF3QXJyYXlzQ2FsbHMgKyBfdG90YWxEcmF3RWxlbWVudHNDYWxscyApO1xuICAgICAgICBfclMoICdkcmF3RWxlbWVudHMnICkuc2V0KCBfdG90YWxEcmF3RWxlbWVudHNDYWxscyApO1xuICAgICAgICBfclMoICdkcmF3QXJyYXlzJyApLnNldCggX3RvdGFsRHJhd0FycmF5c0NhbGxzICk7XG4gICAgICAgIF9yUyggJ2JpbmRUZXh0dXJlJyApLnNldCggX3RvdGFsQmluZFRleHVyZXMgKTtcbiAgICAgICAgX3JTKCAndXNlUHJvZ3JhbScgKS5zZXQoIF90b3RhbFVzZVByb2dyYW1DYWxscyApO1xuICAgICAgICBfclMoICdnbGZhY2VzJyApLnNldCggX3RvdGFsRmFjZXMgKTtcbiAgICAgICAgX3JTKCAnZ2x2ZXJ0aWNlcycgKS5zZXQoIF90b3RhbFZlcnRpY2VzICk7XG4gICAgICAgIF9yUyggJ2dscG9pbnRzJyApLnNldCggX3RvdGFsUG9pbnRzICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX3N0YXJ0ICgpIHtcbiAgICAgICAgX3RvdGFsRHJhd0FycmF5c0NhbGxzID0gMDtcbiAgICAgICAgX3RvdGFsRHJhd0VsZW1lbnRzQ2FsbHMgPSAwO1xuICAgICAgICBfdG90YWxVc2VQcm9ncmFtQ2FsbHMgPSAwO1xuICAgICAgICBfdG90YWxGYWNlcyA9IDA7XG4gICAgICAgIF90b3RhbFZlcnRpY2VzID0gMDtcbiAgICAgICAgX3RvdGFsUG9pbnRzID0gMDtcbiAgICAgICAgX3RvdGFsQmluZFRleHVyZXMgPSAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9lbmQgKCkge31cblxuICAgIGZ1bmN0aW9uIF9hdHRhY2ggKCByICkge1xuICAgICAgICBfclMgPSByO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIHVwZGF0ZTogX3VwZGF0ZSxcbiAgICAgICAgc3RhcnQ6IF9zdGFydCxcbiAgICAgICAgZW5kOiBfZW5kLFxuICAgICAgICBhdHRhY2g6IF9hdHRhY2gsXG4gICAgICAgIHZhbHVlczogX3ZhbHVlcyxcbiAgICAgICAgZ3JvdXBzOiBfZ3JvdXBzLFxuICAgICAgICBmcmFjdGlvbnM6IF9mcmFjdGlvbnNcbiAgICB9O1xuXG59O1xuXG53aW5kb3cudGhyZWVTdGF0cyA9IGZ1bmN0aW9uICggcmVuZGVyZXIgKSB7XG5cbiAgICB2YXIgX3JTID0gbnVsbDtcblxuICAgIHZhciBfdmFsdWVzID0ge1xuICAgICAgICAncmVuZGVyZXIuaW5mby5tZW1vcnkuZ2VvbWV0cmllcyc6IHtcbiAgICAgICAgICAgIGNhcHRpb246ICdHZW9tZXRyaWVzJ1xuICAgICAgICB9LFxuICAgICAgICAncmVuZGVyZXIuaW5mby5tZW1vcnkudGV4dHVyZXMnOiB7XG4gICAgICAgICAgICBjYXB0aW9uOiAnVGV4dHVyZXMnXG4gICAgICAgIH0sXG4gICAgICAgICdyZW5kZXJlci5pbmZvLm1lbW9yeS5wcm9ncmFtcyc6IHtcbiAgICAgICAgICAgIGNhcHRpb246ICdQcm9ncmFtcydcbiAgICAgICAgfSxcbiAgICAgICAgJ3JlbmRlcmVyLmluZm8ucmVuZGVyLmNhbGxzJzoge1xuICAgICAgICAgICAgY2FwdGlvbjogJ0NhbGxzJ1xuICAgICAgICB9LFxuICAgICAgICAncmVuZGVyZXIuaW5mby5yZW5kZXIuZmFjZXMnOiB7XG4gICAgICAgICAgICBjYXB0aW9uOiAnRmFjZXMnLFxuICAgICAgICAgICAgb3ZlcjogMTAwMFxuICAgICAgICB9LFxuICAgICAgICAncmVuZGVyZXIuaW5mby5yZW5kZXIucG9pbnRzJzoge1xuICAgICAgICAgICAgY2FwdGlvbjogJ1BvaW50cydcbiAgICAgICAgfSxcbiAgICAgICAgJ3JlbmRlcmVyLmluZm8ucmVuZGVyLnZlcnRpY2VzJzoge1xuICAgICAgICAgICAgY2FwdGlvbjogJ1ZlcnRpY2VzJ1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBfZ3JvdXBzID0gWyB7XG4gICAgICAgIGNhcHRpb246ICdUaHJlZS5qcyAtIG1lbW9yeScsXG4gICAgICAgIHZhbHVlczogWyAncmVuZGVyZXIuaW5mby5tZW1vcnkuZ2VvbWV0cmllcycsICdyZW5kZXJlci5pbmZvLm1lbW9yeS5wcm9ncmFtcycsICdyZW5kZXJlci5pbmZvLm1lbW9yeS50ZXh0dXJlcycgXVxuICAgIH0sIHtcbiAgICAgICAgY2FwdGlvbjogJ1RocmVlLmpzIC0gcmVuZGVyJyxcbiAgICAgICAgdmFsdWVzOiBbICdyZW5kZXJlci5pbmZvLnJlbmRlci5jYWxscycsICdyZW5kZXJlci5pbmZvLnJlbmRlci5mYWNlcycsICdyZW5kZXJlci5pbmZvLnJlbmRlci5wb2ludHMnLCAncmVuZGVyZXIuaW5mby5yZW5kZXIudmVydGljZXMnIF1cbiAgICB9IF07XG5cbiAgICB2YXIgX2ZyYWN0aW9ucyA9IFtdO1xuXG4gICAgZnVuY3Rpb24gX3VwZGF0ZSAoKSB7XG5cbiAgICAgICAgX3JTKCAncmVuZGVyZXIuaW5mby5tZW1vcnkuZ2VvbWV0cmllcycgKS5zZXQoIHJlbmRlcmVyLmluZm8ubWVtb3J5Lmdlb21ldHJpZXMgKTtcbiAgICAgICAgX3JTKCAncmVuZGVyZXIuaW5mby5tZW1vcnkucHJvZ3JhbXMnICkuc2V0KCByZW5kZXJlci5pbmZvLm1lbW9yeS5wcm9ncmFtcyApO1xuICAgICAgICBfclMoICdyZW5kZXJlci5pbmZvLm1lbW9yeS50ZXh0dXJlcycgKS5zZXQoIHJlbmRlcmVyLmluZm8ubWVtb3J5LnRleHR1cmVzICk7XG4gICAgICAgIF9yUyggJ3JlbmRlcmVyLmluZm8ucmVuZGVyLmNhbGxzJyApLnNldCggcmVuZGVyZXIuaW5mby5yZW5kZXIuY2FsbHMgKTtcbiAgICAgICAgX3JTKCAncmVuZGVyZXIuaW5mby5yZW5kZXIuZmFjZXMnICkuc2V0KCByZW5kZXJlci5pbmZvLnJlbmRlci5mYWNlcyApO1xuICAgICAgICBfclMoICdyZW5kZXJlci5pbmZvLnJlbmRlci5wb2ludHMnICkuc2V0KCByZW5kZXJlci5pbmZvLnJlbmRlci5wb2ludHMgKTtcbiAgICAgICAgX3JTKCAncmVuZGVyZXIuaW5mby5yZW5kZXIudmVydGljZXMnICkuc2V0KCByZW5kZXJlci5pbmZvLnJlbmRlci52ZXJ0aWNlcyApO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX3N0YXJ0ICgpIHt9XG5cbiAgICBmdW5jdGlvbiBfZW5kICgpIHt9XG5cbiAgICBmdW5jdGlvbiBfYXR0YWNoICggciApIHtcbiAgICAgICAgX3JTID0gcjtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB1cGRhdGU6IF91cGRhdGUsXG4gICAgICAgIHN0YXJ0OiBfc3RhcnQsXG4gICAgICAgIGVuZDogX2VuZCxcbiAgICAgICAgYXR0YWNoOiBfYXR0YWNoLFxuICAgICAgICB2YWx1ZXM6IF92YWx1ZXMsXG4gICAgICAgIGdyb3VwczogX2dyb3VwcyxcbiAgICAgICAgZnJhY3Rpb25zOiBfZnJhY3Rpb25zXG4gICAgfTtcblxufTtcblxuLypcbiAqICAgRnJvbSBodHRwczovL2dpdGh1Yi5jb20vcGF1bGlyaXNoL21lbW9yeS1zdGF0cy5qc1xuICovXG5cbndpbmRvdy5Ccm93c2VyU3RhdHMgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgX3JTID0gbnVsbDtcblxuICAgIHZhciBfdXNlZEpTSGVhcFNpemUgPSAwLFxuICAgICAgICBfdG90YWxKU0hlYXBTaXplID0gMDtcblxuICAgIGlmICggd2luZG93LnBlcmZvcm1hbmNlICYmICFwZXJmb3JtYW5jZS5tZW1vcnkgKSB7XG4gICAgICAgIHBlcmZvcm1hbmNlLm1lbW9yeSA9IHtcbiAgICAgICAgICAgIHVzZWRKU0hlYXBTaXplOiAwLFxuICAgICAgICAgICAgdG90YWxKU0hlYXBTaXplOiAwXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKCBwZXJmb3JtYW5jZS5tZW1vcnkudG90YWxKU0hlYXBTaXplID09PSAwICkge1xuICAgICAgICBjb25zb2xlLndhcm4oICd0b3RhbEpTSGVhcFNpemUgPT09IDAuLi4gcGVyZm9ybWFuY2UubWVtb3J5IGlzIG9ubHkgYXZhaWxhYmxlIGluIENocm9tZSAuJyApO1xuICAgIH1cblxuICAgIHZhciBfdmFsdWVzID0ge1xuICAgICAgICBtZW1vcnk6IHtcbiAgICAgICAgICAgIGNhcHRpb246ICdVc2VkIE1lbW9yeScsXG4gICAgICAgICAgICBhdmVyYWdlOiB0cnVlLFxuICAgICAgICAgICAgYXZnTXM6IDEwMDAsXG4gICAgICAgICAgICBvdmVyOiAyMlxuICAgICAgICB9LFxuICAgICAgICB0b3RhbDoge1xuICAgICAgICAgICAgY2FwdGlvbjogJ1RvdGFsIE1lbW9yeSdcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgX2dyb3VwcyA9IFsge1xuICAgICAgICBjYXB0aW9uOiAnQnJvd3NlcicsXG4gICAgICAgIHZhbHVlczogWyAnbWVtb3J5JywgJ3RvdGFsJyBdXG4gICAgfSBdO1xuXG4gICAgdmFyIF9mcmFjdGlvbnMgPSBbIHtcbiAgICAgICAgYmFzZTogJ3RvdGFsJyxcbiAgICAgICAgc3RlcHM6IFsgJ21lbW9yeScgXVxuICAgIH0gXTtcblxuICAgIHZhciBsb2cxMDI0ID0gTWF0aC5sb2coIDEwMjQgKTtcblxuICAgIGZ1bmN0aW9uIF9zaXplICggdiApIHtcblxuICAgICAgICB2YXIgcHJlY2lzaW9uID0gMTAwOyAvL01hdGgucG93KDEwLCAyKTtcbiAgICAgICAgdmFyIGkgPSBNYXRoLmZsb29yKCBNYXRoLmxvZyggdiApIC8gbG9nMTAyNCApO1xuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCggdiAqIHByZWNpc2lvbiAvIE1hdGgucG93KCAxMDI0LCBpICkgKSAvIHByZWNpc2lvbjsgLy8gKyAnICcgKyBzaXplc1tpXTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF91cGRhdGUgKCkge1xuICAgICAgICBfdXNlZEpTSGVhcFNpemUgPSBfc2l6ZSggcGVyZm9ybWFuY2UubWVtb3J5LnVzZWRKU0hlYXBTaXplICk7XG4gICAgICAgIF90b3RhbEpTSGVhcFNpemUgPSBfc2l6ZSggcGVyZm9ybWFuY2UubWVtb3J5LnRvdGFsSlNIZWFwU2l6ZSApO1xuXG4gICAgICAgIF9yUyggJ21lbW9yeScgKS5zZXQoIF91c2VkSlNIZWFwU2l6ZSApO1xuICAgICAgICBfclMoICd0b3RhbCcgKS5zZXQoIF90b3RhbEpTSGVhcFNpemUgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfc3RhcnQgKCkge1xuICAgICAgICBfdXNlZEpTSGVhcFNpemUgPSAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9lbmQgKCkge31cblxuICAgIGZ1bmN0aW9uIF9hdHRhY2ggKCByICkge1xuICAgICAgICBfclMgPSByO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIHVwZGF0ZTogX3VwZGF0ZSxcbiAgICAgICAgc3RhcnQ6IF9zdGFydCxcbiAgICAgICAgZW5kOiBfZW5kLFxuICAgICAgICBhdHRhY2g6IF9hdHRhY2gsXG4gICAgICAgIHZhbHVlczogX3ZhbHVlcyxcbiAgICAgICAgZ3JvdXBzOiBfZ3JvdXBzLFxuICAgICAgICBmcmFjdGlvbnM6IF9mcmFjdGlvbnNcbiAgICB9O1xuXG59O1xuXG5pZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgYWZyYW1lU3RhdHM6IHdpbmRvdy5hZnJhbWVTdGF0cyxcbiAgICBnbFN0YXRzOiB3aW5kb3cuZ2xTdGF0cyxcbiAgICB0aHJlZVN0YXRzOiB3aW5kb3cudGhyZWVTdGF0cyxcbiAgICBCcm93c2VyU3RhdHM6IHdpbmRvdy5Ccm93c2VyU3RhdHNcbiAgfTtcbn1cblxufSx7fV0sMTA3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8vIHBlcmZvcm1hbmNlLm5vdygpIHBvbHlmaWxsIGZyb20gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vcGF1bGlyaXNoLzU0Mzg2NTBcbid1c2Ugc3RyaWN0JztcblxuKCBmdW5jdGlvbiAoKSB7XG5cbiAgICAvLyBwcmVwYXJlIGJhc2UgcGVyZiBvYmplY3RcbiAgICBpZiAoIHR5cGVvZiB3aW5kb3cucGVyZm9ybWFuY2UgPT09ICd1bmRlZmluZWQnICkge1xuICAgICAgICB3aW5kb3cucGVyZm9ybWFuY2UgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAoICF3aW5kb3cucGVyZm9ybWFuY2Uubm93ICkge1xuXG4gICAgICAgIHZhciBub3dPZmZzZXQgPSBEYXRlLm5vdygpO1xuXG4gICAgICAgIGlmICggcGVyZm9ybWFuY2UudGltaW5nICYmIHBlcmZvcm1hbmNlLnRpbWluZy5uYXZpZ2F0aW9uU3RhcnQgKSB7XG4gICAgICAgICAgICBub3dPZmZzZXQgPSBwZXJmb3JtYW5jZS50aW1pbmcubmF2aWdhdGlvblN0YXJ0O1xuICAgICAgICB9XG5cbiAgICAgICAgd2luZG93LnBlcmZvcm1hbmNlLm5vdyA9IGZ1bmN0aW9uIG5vdyAoKSB7XG4gICAgICAgICAgICByZXR1cm4gRGF0ZS5ub3coKSAtIG5vd09mZnNldDtcbiAgICAgICAgfTtcblxuICAgIH1cblxuICAgIGlmKCAhd2luZG93LnBlcmZvcm1hbmNlLm1hcmsgKSB7XG4gICAgICAgIHdpbmRvdy5wZXJmb3JtYW5jZS5tYXJrID0gZnVuY3Rpb24oKXt9XG4gICAgfVxuXG4gICAgaWYoICF3aW5kb3cucGVyZm9ybWFuY2UubWVhc3VyZSApIHtcbiAgICAgICAgd2luZG93LnBlcmZvcm1hbmNlLm1lYXN1cmUgPSBmdW5jdGlvbigpe31cbiAgICB9XG5cbn0gKSgpO1xuXG53aW5kb3cuclN0YXRzID0gZnVuY3Rpb24gclN0YXRzICggc2V0dGluZ3MgKSB7XG5cbiAgICBmdW5jdGlvbiBpdGVyYXRlS2V5cyAoIGFycmF5LCBjYWxsYmFjayApIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyggYXJyYXkgKTtcbiAgICAgICAgZm9yICggdmFyIGogPSAwLCBsID0ga2V5cy5sZW5ndGg7IGogPCBsOyBqKysgKSB7XG4gICAgICAgICAgICBjYWxsYmFjaygga2V5c1sgaiBdICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbXBvcnRDU1MgKCB1cmwgKSB7XG5cbiAgICAgICAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnbGluaycgKTtcbiAgICAgICAgZWxlbWVudC5ocmVmID0gdXJsO1xuICAgICAgICBlbGVtZW50LnJlbCA9ICdzdHlsZXNoZWV0JztcbiAgICAgICAgZWxlbWVudC50eXBlID0gJ3RleHQvY3NzJztcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoICdoZWFkJyApWyAwIF0uYXBwZW5kQ2hpbGQoIGVsZW1lbnQgKTtcblxuICAgIH1cblxuICAgIHZhciBfc2V0dGluZ3MgPSBzZXR0aW5ncyB8fCB7fTtcbiAgICB2YXIgX2NvbG91cnMgPSBfc2V0dGluZ3MuY29sb3VycyB8fCBbICcjODUwNzAwJywgJyNjNzQ5MDAnLCAnI2ZjYjMwMCcsICcjMjg0MjgwJywgJyM0YzdjMGMnIF07XG5cbiAgICB2YXIgX2Nzc0ZvbnQgPSAnLy9mb250cy5nb29nbGVhcGlzLmNvbS9jc3M/ZmFtaWx5PVJvYm90bytDb25kZW5zZWQ6NDAwLDcwMCwzMDAnO1xuICAgIHZhciBfY3NzUlN0YXRzID0gKCBfc2V0dGluZ3MuQ1NTUGF0aCA/IF9zZXR0aW5ncy5DU1NQYXRoIDogJycgKSArICdyU3RhdHMuY3NzJztcblxuICAgIHZhciBfY3NzID0gX3NldHRpbmdzLmNzcyB8fCBbIF9jc3NGb250LCBfY3NzUlN0YXRzIF07XG4gICAgX2Nzcy5mb3JFYWNoKGZ1bmN0aW9uICh1cmkpIHtcbiAgICAgICAgaW1wb3J0Q1NTKCB1cmkgKTtcbiAgICB9KTtcblxuICAgIGlmICggIV9zZXR0aW5ncy52YWx1ZXMgKSBfc2V0dGluZ3MudmFsdWVzID0ge307XG5cbiAgICB2YXIgX2Jhc2UsIF9kaXYsIF9lbEhlaWdodCA9IDEwLCBfZWxXaWR0aCA9IDIwMDtcbiAgICB2YXIgX3BlcmZDb3VudGVycyA9IHt9O1xuXG5cbiAgICBmdW5jdGlvbiBHcmFwaCAoIF9kb20sIF9pZCwgX2RlZkFyZyApIHtcblxuICAgICAgICB2YXIgX2RlZiA9IF9kZWZBcmcgfHwge307XG4gICAgICAgIHZhciBfY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2NhbnZhcycgKSxcbiAgICAgICAgICAgIF9jdHggPSBfY2FudmFzLmdldENvbnRleHQoICcyZCcgKSxcbiAgICAgICAgICAgIF9tYXggPSAwLFxuICAgICAgICAgICAgX2N1cnJlbnQgPSAwO1xuXG4gICAgICAgIHZhciBjID0gX2RlZi5jb2xvciA/IF9kZWYuY29sb3IgOiAnIzY2NjY2Nic7XG5cbiAgICAgICAgdmFyIF9kb3RDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnY2FudmFzJyApLFxuICAgICAgICAgICAgX2RvdEN0eCA9IF9kb3RDYW52YXMuZ2V0Q29udGV4dCggJzJkJyApO1xuICAgICAgICBfZG90Q2FudmFzLndpZHRoID0gMTtcbiAgICAgICAgX2RvdENhbnZhcy5oZWlnaHQgPSAyICogX2VsSGVpZ2h0O1xuICAgICAgICBfZG90Q3R4LmZpbGxTdHlsZSA9ICcjNDQ0NDQ0JztcbiAgICAgICAgX2RvdEN0eC5maWxsUmVjdCggMCwgMCwgMSwgMiAqIF9lbEhlaWdodCApO1xuICAgICAgICBfZG90Q3R4LmZpbGxTdHlsZSA9IGM7XG4gICAgICAgIF9kb3RDdHguZmlsbFJlY3QoIDAsIF9lbEhlaWdodCwgMSwgX2VsSGVpZ2h0ICk7XG4gICAgICAgIF9kb3RDdHguZmlsbFN0eWxlID0gJyNmZmZmZmYnO1xuICAgICAgICBfZG90Q3R4Lmdsb2JhbEFscGhhID0gMC41O1xuICAgICAgICBfZG90Q3R4LmZpbGxSZWN0KCAwLCBfZWxIZWlnaHQsIDEsIDEgKTtcbiAgICAgICAgX2RvdEN0eC5nbG9iYWxBbHBoYSA9IDE7XG5cbiAgICAgICAgdmFyIF9hbGFybUNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdjYW52YXMnICksXG4gICAgICAgICAgICBfYWxhcm1DdHggPSBfYWxhcm1DYW52YXMuZ2V0Q29udGV4dCggJzJkJyApO1xuICAgICAgICBfYWxhcm1DYW52YXMud2lkdGggPSAxO1xuICAgICAgICBfYWxhcm1DYW52YXMuaGVpZ2h0ID0gMiAqIF9lbEhlaWdodDtcbiAgICAgICAgX2FsYXJtQ3R4LmZpbGxTdHlsZSA9ICcjNDQ0NDQ0JztcbiAgICAgICAgX2FsYXJtQ3R4LmZpbGxSZWN0KCAwLCAwLCAxLCAyICogX2VsSGVpZ2h0ICk7XG4gICAgICAgIF9hbGFybUN0eC5maWxsU3R5bGUgPSAnI2I3MDAwMCc7XG4gICAgICAgIF9hbGFybUN0eC5maWxsUmVjdCggMCwgX2VsSGVpZ2h0LCAxLCBfZWxIZWlnaHQgKTtcbiAgICAgICAgX2FsYXJtQ3R4Lmdsb2JhbEFscGhhID0gMC41O1xuICAgICAgICBfYWxhcm1DdHguZmlsbFN0eWxlID0gJyNmZmZmZmYnO1xuICAgICAgICBfYWxhcm1DdHguZmlsbFJlY3QoIDAsIF9lbEhlaWdodCwgMSwgMSApO1xuICAgICAgICBfYWxhcm1DdHguZ2xvYmFsQWxwaGEgPSAxO1xuXG4gICAgICAgIGZ1bmN0aW9uIF9pbml0ICgpIHtcblxuICAgICAgICAgICAgX2NhbnZhcy53aWR0aCA9IF9lbFdpZHRoO1xuICAgICAgICAgICAgX2NhbnZhcy5oZWlnaHQgPSBfZWxIZWlnaHQ7XG4gICAgICAgICAgICBfY2FudmFzLnN0eWxlLndpZHRoID0gX2NhbnZhcy53aWR0aCArICdweCc7XG4gICAgICAgICAgICBfY2FudmFzLnN0eWxlLmhlaWdodCA9IF9jYW52YXMuaGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgICAgIF9jYW52YXMuY2xhc3NOYW1lID0gJ3JzLWNhbnZhcyc7XG4gICAgICAgICAgICBfZG9tLmFwcGVuZENoaWxkKCBfY2FudmFzICk7XG5cbiAgICAgICAgICAgIF9jdHguZmlsbFN0eWxlID0gJyM0NDQ0NDQnO1xuICAgICAgICAgICAgX2N0eC5maWxsUmVjdCggMCwgMCwgX2NhbnZhcy53aWR0aCwgX2NhbnZhcy5oZWlnaHQgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gX2RyYXcgKCB2LCBhbGFybSApIHtcbiAgICAgICAgICAgIF9jdXJyZW50ICs9ICggdiAtIF9jdXJyZW50ICkgKiAwLjE7XG4gICAgICAgICAgICBfbWF4ICo9IDAuOTk7XG4gICAgICAgICAgICBpZiAoIF9jdXJyZW50ID4gX21heCApIF9tYXggPSBfY3VycmVudDtcbiAgICAgICAgICAgIF9jdHguZHJhd0ltYWdlKCBfY2FudmFzLCAxLCAwLCBfY2FudmFzLndpZHRoIC0gMSwgX2NhbnZhcy5oZWlnaHQsIDAsIDAsIF9jYW52YXMud2lkdGggLSAxLCBfY2FudmFzLmhlaWdodCApO1xuICAgICAgICAgICAgaWYgKCBhbGFybSApIHtcbiAgICAgICAgICAgICAgICBfY3R4LmRyYXdJbWFnZSggX2FsYXJtQ2FudmFzLCBfY2FudmFzLndpZHRoIC0gMSwgX2NhbnZhcy5oZWlnaHQgLSBfY3VycmVudCAqIF9jYW52YXMuaGVpZ2h0IC8gX21heCAtIF9lbEhlaWdodCApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBfY3R4LmRyYXdJbWFnZSggX2RvdENhbnZhcywgX2NhbnZhcy53aWR0aCAtIDEsIF9jYW52YXMuaGVpZ2h0IC0gX2N1cnJlbnQgKiBfY2FudmFzLmhlaWdodCAvIF9tYXggLSBfZWxIZWlnaHQgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIF9pbml0KCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRyYXc6IF9kcmF3XG4gICAgICAgIH07XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBTdGFja0dyYXBoICggX2RvbSwgX251bSApIHtcblxuICAgICAgICB2YXIgX2NhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdjYW52YXMnICksXG4gICAgICAgICAgICBfY3R4ID0gX2NhbnZhcy5nZXRDb250ZXh0KCAnMmQnICk7XG5cbiAgICAgICAgZnVuY3Rpb24gX2luaXQgKCkge1xuXG4gICAgICAgICAgICBfY2FudmFzLndpZHRoID0gX2VsV2lkdGg7XG4gICAgICAgICAgICBfY2FudmFzLmhlaWdodCA9IF9lbEhlaWdodCAqIF9udW07XG4gICAgICAgICAgICBfY2FudmFzLnN0eWxlLndpZHRoID0gX2NhbnZhcy53aWR0aCArICdweCc7XG4gICAgICAgICAgICBfY2FudmFzLnN0eWxlLmhlaWdodCA9IF9jYW52YXMuaGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgICAgIF9jYW52YXMuY2xhc3NOYW1lID0gJ3JzLWNhbnZhcyc7XG4gICAgICAgICAgICBfZG9tLmFwcGVuZENoaWxkKCBfY2FudmFzICk7XG5cbiAgICAgICAgICAgIF9jdHguZmlsbFN0eWxlID0gJyM0NDQ0NDQnO1xuICAgICAgICAgICAgX2N0eC5maWxsUmVjdCggMCwgMCwgX2NhbnZhcy53aWR0aCwgX2NhbnZhcy5oZWlnaHQgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gX2RyYXcgKCB2ICkge1xuICAgICAgICAgICAgX2N0eC5kcmF3SW1hZ2UoIF9jYW52YXMsIDEsIDAsIF9jYW52YXMud2lkdGggLSAxLCBfY2FudmFzLmhlaWdodCwgMCwgMCwgX2NhbnZhcy53aWR0aCAtIDEsIF9jYW52YXMuaGVpZ2h0ICk7XG4gICAgICAgICAgICB2YXIgdGggPSAwO1xuICAgICAgICAgICAgaXRlcmF0ZUtleXMoIHYsIGZ1bmN0aW9uICggaiApIHtcbiAgICAgICAgICAgICAgICB2YXIgaCA9IHZbIGogXSAqIF9jYW52YXMuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIF9jdHguZmlsbFN0eWxlID0gX2NvbG91cnNbIGogXTtcbiAgICAgICAgICAgICAgICBfY3R4LmZpbGxSZWN0KCBfY2FudmFzLndpZHRoIC0gMSwgdGgsIDEsIGggKTtcbiAgICAgICAgICAgICAgICB0aCArPSBoO1xuICAgICAgICAgICAgfSApO1xuICAgICAgICB9XG5cbiAgICAgICAgX2luaXQoKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZHJhdzogX2RyYXdcbiAgICAgICAgfTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIFBlcmZDb3VudGVyICggaWQsIGdyb3VwICkge1xuXG4gICAgICAgIHZhciBfaWQgPSBpZCxcbiAgICAgICAgICAgIF90aW1lLFxuICAgICAgICAgICAgX3ZhbHVlID0gMCxcbiAgICAgICAgICAgIF90b3RhbCA9IDAsXG4gICAgICAgICAgICBfYXZlcmFnZVZhbHVlID0gMCxcbiAgICAgICAgICAgIF9hY2N1bVZhbHVlID0gMCxcbiAgICAgICAgICAgIF9hY2N1bVN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCksXG4gICAgICAgICAgICBfYWNjdW1TYW1wbGVzID0gMCxcbiAgICAgICAgICAgIF9kb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnZGl2JyApLFxuICAgICAgICAgICAgX3NwYW5JZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdzcGFuJyApLFxuICAgICAgICAgICAgX3NwYW5WYWx1ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdkaXYnICksXG4gICAgICAgICAgICBfc3BhblZhbHVlVGV4dCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCAnJyApLFxuICAgICAgICAgICAgX2RlZiA9IF9zZXR0aW5ncyA/IF9zZXR0aW5ncy52YWx1ZXNbIF9pZC50b0xvd2VyQ2FzZSgpIF0gOiBudWxsLFxuICAgICAgICAgICAgX2dyYXBoID0gbmV3IEdyYXBoKCBfZG9tLCBfaWQsIF9kZWYgKSxcbiAgICAgICAgICAgIF9zdGFydGVkID0gZmFsc2U7XG5cbiAgICAgICAgX2RvbS5jbGFzc05hbWUgPSAncnMtY291bnRlci1iYXNlJztcblxuICAgICAgICBfc3BhbklkLmNsYXNzTmFtZSA9ICdycy1jb3VudGVyLWlkJztcbiAgICAgICAgX3NwYW5JZC50ZXh0Q29udGVudCA9ICggX2RlZiAmJiBfZGVmLmNhcHRpb24gKSA/IF9kZWYuY2FwdGlvbiA6IF9pZDtcblxuICAgICAgICBfc3BhblZhbHVlLmNsYXNzTmFtZSA9ICdycy1jb3VudGVyLXZhbHVlJztcbiAgICAgICAgX3NwYW5WYWx1ZS5hcHBlbmRDaGlsZCggX3NwYW5WYWx1ZVRleHQgKTtcblxuICAgICAgICBfZG9tLmFwcGVuZENoaWxkKCBfc3BhbklkICk7XG4gICAgICAgIF9kb20uYXBwZW5kQ2hpbGQoIF9zcGFuVmFsdWUgKTtcbiAgICAgICAgaWYgKCBncm91cCApIGdyb3VwLmRpdi5hcHBlbmRDaGlsZCggX2RvbSApO1xuICAgICAgICBlbHNlIF9kaXYuYXBwZW5kQ2hpbGQoIF9kb20gKTtcblxuICAgICAgICBfdGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXG4gICAgICAgIGZ1bmN0aW9uIF9hdmVyYWdlICggdiApIHtcbiAgICAgICAgICAgIGlmICggX2RlZiAmJiBfZGVmLmF2ZXJhZ2UgKSB7XG4gICAgICAgICAgICAgICAgX2FjY3VtVmFsdWUgKz0gdjtcbiAgICAgICAgICAgICAgICBfYWNjdW1TYW1wbGVzKys7XG4gICAgICAgICAgICAgICAgdmFyIHQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICAgICAgICBpZiAoIHQgLSBfYWNjdW1TdGFydCA+PSAoIF9kZWYuYXZnTXMgfHwgMTAwMCApICkge1xuICAgICAgICAgICAgICAgICAgICBfYXZlcmFnZVZhbHVlID0gX2FjY3VtVmFsdWUgLyBfYWNjdW1TYW1wbGVzO1xuICAgICAgICAgICAgICAgICAgICBfYWNjdW1WYWx1ZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIF9hY2N1bVN0YXJ0ID0gdDtcbiAgICAgICAgICAgICAgICAgICAgX2FjY3VtU2FtcGxlcyA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gX3N0YXJ0ICgpIHtcbiAgICAgICAgICAgIF90aW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICAgICBpZiggX3NldHRpbmdzLnVzZXJUaW1pbmdBUEkgKSBwZXJmb3JtYW5jZS5tYXJrKCBfaWQgKyAnLXN0YXJ0JyApO1xuICAgICAgICAgICAgX3N0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gX2VuZCAoKSB7XG4gICAgICAgICAgICBfdmFsdWUgPSBwZXJmb3JtYW5jZS5ub3coKSAtIF90aW1lO1xuICAgICAgICAgICAgaWYoIF9zZXR0aW5ncy51c2VyVGltaW5nQVBJICkge1xuICAgICAgICAgICAgICAgIHBlcmZvcm1hbmNlLm1hcmsoIF9pZCArICctZW5kJyApO1xuICAgICAgICAgICAgICAgIGlmKCBfc3RhcnRlZCApIHtcbiAgICAgICAgICAgICAgICAgICAgcGVyZm9ybWFuY2UubWVhc3VyZSggX2lkLCBfaWQgKyAnLXN0YXJ0JywgX2lkICsgJy1lbmQnICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX2F2ZXJhZ2UoIF92YWx1ZSApO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gX3RpY2sgKCkge1xuICAgICAgICAgICAgX2VuZCgpO1xuICAgICAgICAgICAgX3N0YXJ0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBfZHJhdyAoKSB7XG4gICAgICAgICAgICB2YXIgdiA9ICggX2RlZiAmJiBfZGVmLmF2ZXJhZ2UgKSA/IF9hdmVyYWdlVmFsdWUgOiBfdmFsdWU7XG4gICAgICAgICAgICBfc3BhblZhbHVlVGV4dC5ub2RlVmFsdWUgPSBNYXRoLnJvdW5kKCB2ICogMTAwICkgLyAxMDA7XG4gICAgICAgICAgICB2YXIgYSA9ICggX2RlZiAmJiAoICggX2RlZi5iZWxvdyAmJiBfdmFsdWUgPCBfZGVmLmJlbG93ICkgfHwgKCBfZGVmLm92ZXIgJiYgX3ZhbHVlID4gX2RlZi5vdmVyICkgKSApO1xuICAgICAgICAgICAgX2dyYXBoLmRyYXcoIF92YWx1ZSwgYSApO1xuICAgICAgICAgICAgX2RvbS5zdHlsZS5jb2xvciA9IGEgPyAnI2I3MDAwMCcgOiAnI2ZmZmZmZic7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBfZnJhbWUgKCkge1xuICAgICAgICAgICAgdmFyIHQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICAgIHZhciBlID0gdCAtIF90aW1lO1xuICAgICAgICAgICAgX3RvdGFsKys7XG4gICAgICAgICAgICBpZiAoIGUgPiAxMDAwICkge1xuICAgICAgICAgICAgICAgIGlmICggX2RlZiAmJiBfZGVmLmludGVycG9sYXRlID09PSBmYWxzZSApIHtcbiAgICAgICAgICAgICAgICAgICAgX3ZhbHVlID0gX3RvdGFsO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF92YWx1ZSA9IF90b3RhbCAqIDEwMDAgLyBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdG90YWwgPSAwO1xuICAgICAgICAgICAgICAgIF90aW1lID0gdDtcbiAgICAgICAgICAgICAgICBfYXZlcmFnZSggX3ZhbHVlICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBfc2V0ICggdiApIHtcbiAgICAgICAgICAgIF92YWx1ZSA9IHY7XG4gICAgICAgICAgICBfYXZlcmFnZSggX3ZhbHVlICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2V0OiBfc2V0LFxuICAgICAgICAgICAgc3RhcnQ6IF9zdGFydCxcbiAgICAgICAgICAgIHRpY2s6IF90aWNrLFxuICAgICAgICAgICAgZW5kOiBfZW5kLFxuICAgICAgICAgICAgZnJhbWU6IF9mcmFtZSxcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF92YWx1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkcmF3OiBfZHJhd1xuICAgICAgICB9O1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2FtcGxlICgpIHtcblxuICAgICAgICB2YXIgX3ZhbHVlID0gMDtcblxuICAgICAgICBmdW5jdGlvbiBfc2V0ICggdiApIHtcbiAgICAgICAgICAgIF92YWx1ZSA9IHY7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2V0OiBfc2V0LFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3ZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX3BlcmYgKCBpZEFyZyApIHtcblxuICAgICAgICB2YXIgaWQgPSBpZEFyZy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoIGlkID09PSB1bmRlZmluZWQgKSBpZCA9ICdkZWZhdWx0JztcbiAgICAgICAgaWYgKCBfcGVyZkNvdW50ZXJzWyBpZCBdICkgcmV0dXJuIF9wZXJmQ291bnRlcnNbIGlkIF07XG5cbiAgICAgICAgdmFyIGdyb3VwID0gbnVsbDtcbiAgICAgICAgaWYgKCBfc2V0dGluZ3MgJiYgX3NldHRpbmdzLmdyb3VwcyApIHtcbiAgICAgICAgICAgIGl0ZXJhdGVLZXlzKCBfc2V0dGluZ3MuZ3JvdXBzLCBmdW5jdGlvbiAoIGogKSB7XG4gICAgICAgICAgICAgICAgdmFyIGcgPSBfc2V0dGluZ3MuZ3JvdXBzWyBwYXJzZUludCggaiwgMTAgKSBdO1xuICAgICAgICAgICAgICAgIGlmICggIWdyb3VwICYmIGcudmFsdWVzLmluZGV4T2YoIGlkLnRvTG93ZXJDYXNlKCkgKSAhPT0gLTEgKSB7XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwID0gZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9ICk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcCA9IG5ldyBQZXJmQ291bnRlciggaWQsIGdyb3VwICk7XG4gICAgICAgIF9wZXJmQ291bnRlcnNbIGlkIF0gPSBwO1xuICAgICAgICByZXR1cm4gcDtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9pbml0ICgpIHtcblxuICAgICAgICBpZiAoIF9zZXR0aW5ncy5wbHVnaW5zICkge1xuICAgICAgICAgICAgaWYgKCAhX3NldHRpbmdzLnZhbHVlcyApIF9zZXR0aW5ncy52YWx1ZXMgPSB7fTtcbiAgICAgICAgICAgIGlmICggIV9zZXR0aW5ncy5ncm91cHMgKSBfc2V0dGluZ3MuZ3JvdXBzID0gW107XG4gICAgICAgICAgICBpZiAoICFfc2V0dGluZ3MuZnJhY3Rpb25zICkgX3NldHRpbmdzLmZyYWN0aW9ucyA9IFtdO1xuICAgICAgICAgICAgZm9yICggdmFyIGogPSAwOyBqIDwgX3NldHRpbmdzLnBsdWdpbnMubGVuZ3RoOyBqKysgKSB7XG4gICAgICAgICAgICAgICAgX3NldHRpbmdzLnBsdWdpbnNbIGogXS5hdHRhY2goIF9wZXJmICk7XG4gICAgICAgICAgICAgICAgaXRlcmF0ZUtleXMoIF9zZXR0aW5ncy5wbHVnaW5zWyBqIF0udmFsdWVzLCBmdW5jdGlvbiAoIGsgKSB7XG4gICAgICAgICAgICAgICAgICAgIF9zZXR0aW5ncy52YWx1ZXNbIGsgXSA9IF9zZXR0aW5ncy5wbHVnaW5zWyBqIF0udmFsdWVzWyBrIF07XG4gICAgICAgICAgICAgICAgfSApO1xuICAgICAgICAgICAgICAgIF9zZXR0aW5ncy5ncm91cHMgPSBfc2V0dGluZ3MuZ3JvdXBzLmNvbmNhdCggX3NldHRpbmdzLnBsdWdpbnNbIGogXS5ncm91cHMgKTtcbiAgICAgICAgICAgICAgICBfc2V0dGluZ3MuZnJhY3Rpb25zID0gX3NldHRpbmdzLmZyYWN0aW9ucy5jb25jYXQoIF9zZXR0aW5ncy5wbHVnaW5zWyBqIF0uZnJhY3Rpb25zICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfc2V0dGluZ3MucGx1Z2lucyA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgX2Jhc2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnZGl2JyApO1xuICAgICAgICBfYmFzZS5jbGFzc05hbWUgPSAncnMtYmFzZSc7XG4gICAgICAgIF9kaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnZGl2JyApO1xuICAgICAgICBfZGl2LmNsYXNzTmFtZSA9ICdycy1jb250YWluZXInO1xuICAgICAgICBfZGl2LnN0eWxlLmhlaWdodCA9ICdhdXRvJztcbiAgICAgICAgX2Jhc2UuYXBwZW5kQ2hpbGQoIF9kaXYgKTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCggX2Jhc2UgKTtcblxuICAgICAgICBpZiAoICFfc2V0dGluZ3MgKSByZXR1cm47XG5cbiAgICAgICAgaWYgKCBfc2V0dGluZ3MuZ3JvdXBzICkge1xuICAgICAgICAgICAgaXRlcmF0ZUtleXMoIF9zZXR0aW5ncy5ncm91cHMsIGZ1bmN0aW9uICggaiApIHtcbiAgICAgICAgICAgICAgICB2YXIgZyA9IF9zZXR0aW5ncy5ncm91cHNbIHBhcnNlSW50KCBqLCAxMCApIF07XG4gICAgICAgICAgICAgICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdkaXYnICk7XG4gICAgICAgICAgICAgICAgZGl2LmNsYXNzTmFtZSA9ICdycy1ncm91cCc7XG4gICAgICAgICAgICAgICAgZy5kaXYgPSBkaXY7XG4gICAgICAgICAgICAgICAgdmFyIGgxID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2gxJyApO1xuICAgICAgICAgICAgICAgIGgxLnRleHRDb250ZW50ID0gZy5jYXB0aW9uO1xuICAgICAgICAgICAgICAgIGgxLmFkZEV2ZW50TGlzdGVuZXIoICdjbGljaycsIGZ1bmN0aW9uICggZSApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QudG9nZ2xlKCAnaGlkZGVuJyApO1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfS5iaW5kKCBkaXYgKSApO1xuICAgICAgICAgICAgICAgIF9kaXYuYXBwZW5kQ2hpbGQoIGgxICk7XG4gICAgICAgICAgICAgICAgX2Rpdi5hcHBlbmRDaGlsZCggZGl2ICk7XG4gICAgICAgICAgICB9ICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIF9zZXR0aW5ncy5mcmFjdGlvbnMgKSB7XG4gICAgICAgICAgICBpdGVyYXRlS2V5cyggX3NldHRpbmdzLmZyYWN0aW9ucywgZnVuY3Rpb24gKCBqICkge1xuICAgICAgICAgICAgICAgIHZhciBmID0gX3NldHRpbmdzLmZyYWN0aW9uc1sgcGFyc2VJbnQoIGosIDEwICkgXTtcbiAgICAgICAgICAgICAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2RpdicgKTtcbiAgICAgICAgICAgICAgICBkaXYuY2xhc3NOYW1lID0gJ3JzLWZyYWN0aW9uJztcbiAgICAgICAgICAgICAgICB2YXIgbGVnZW5kID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2RpdicgKTtcbiAgICAgICAgICAgICAgICBsZWdlbmQuY2xhc3NOYW1lID0gJ3JzLWxlZ2VuZCc7XG5cbiAgICAgICAgICAgICAgICB2YXIgaCA9IDA7XG4gICAgICAgICAgICAgICAgaXRlcmF0ZUtleXMoIF9zZXR0aW5ncy5mcmFjdGlvbnNbIGogXS5zdGVwcywgZnVuY3Rpb24gKCBrICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdwJyApO1xuICAgICAgICAgICAgICAgICAgICBwLnRleHRDb250ZW50ID0gX3NldHRpbmdzLmZyYWN0aW9uc1sgaiBdLnN0ZXBzWyBrIF07XG4gICAgICAgICAgICAgICAgICAgIHAuc3R5bGUuY29sb3IgPSBfY29sb3Vyc1sgaCBdO1xuICAgICAgICAgICAgICAgICAgICBsZWdlbmQuYXBwZW5kQ2hpbGQoIHAgKTtcbiAgICAgICAgICAgICAgICAgICAgaCsrO1xuICAgICAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICAgICAgICBkaXYuYXBwZW5kQ2hpbGQoIGxlZ2VuZCApO1xuICAgICAgICAgICAgICAgIGRpdi5zdHlsZS5oZWlnaHQgPSBoICogX2VsSGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgICAgICAgICBmLmRpdiA9IGRpdjtcbiAgICAgICAgICAgICAgICB2YXIgZ3JhcGggPSBuZXcgU3RhY2tHcmFwaCggZGl2LCBoICk7XG4gICAgICAgICAgICAgICAgZi5ncmFwaCA9IGdyYXBoO1xuICAgICAgICAgICAgICAgIF9kaXYuYXBwZW5kQ2hpbGQoIGRpdiApO1xuICAgICAgICAgICAgfSApO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfdXBkYXRlICgpIHtcblxuICAgICAgICBpdGVyYXRlS2V5cyggX3NldHRpbmdzLnBsdWdpbnMsIGZ1bmN0aW9uICggaiApIHtcbiAgICAgICAgICAgIF9zZXR0aW5ncy5wbHVnaW5zWyBqIF0udXBkYXRlKCk7XG4gICAgICAgIH0gKTtcblxuICAgICAgICBpdGVyYXRlS2V5cyggX3BlcmZDb3VudGVycywgZnVuY3Rpb24gKCBqICkge1xuICAgICAgICAgICAgX3BlcmZDb3VudGVyc1sgaiBdLmRyYXcoKTtcbiAgICAgICAgfSApO1xuXG4gICAgICAgIGlmICggX3NldHRpbmdzICYmIF9zZXR0aW5ncy5mcmFjdGlvbnMgKSB7XG4gICAgICAgICAgICBpdGVyYXRlS2V5cyggX3NldHRpbmdzLmZyYWN0aW9ucywgZnVuY3Rpb24gKCBqICkge1xuICAgICAgICAgICAgICAgIHZhciBmID0gX3NldHRpbmdzLmZyYWN0aW9uc1sgcGFyc2VJbnQoIGosIDEwICkgXTtcbiAgICAgICAgICAgICAgICB2YXIgdiA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBiYXNlID0gX3BlcmZDb3VudGVyc1sgZi5iYXNlLnRvTG93ZXJDYXNlKCkgXTtcbiAgICAgICAgICAgICAgICBpZiAoIGJhc2UgKSB7XG4gICAgICAgICAgICAgICAgICAgIGJhc2UgPSBiYXNlLnZhbHVlKCk7XG4gICAgICAgICAgICAgICAgICAgIGl0ZXJhdGVLZXlzKCBfc2V0dGluZ3MuZnJhY3Rpb25zWyBqIF0uc3RlcHMsIGZ1bmN0aW9uICggayApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzID0gX3NldHRpbmdzLmZyYWN0aW9uc1sgaiBdLnN0ZXBzWyBwYXJzZUludCggaywgMTAgKSBdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0gX3BlcmZDb3VudGVyc1sgcyBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB2YWwgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdi5wdXNoKCB2YWwudmFsdWUoKSAvIGJhc2UgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmLmdyYXBoLmRyYXcoIHYgKTtcbiAgICAgICAgICAgIH0gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qaWYoIF9oZWlnaHQgIT0gX2Rpdi5jbGllbnRIZWlnaHQgKSB7XG4gICAgICAgICAgICBfaGVpZ2h0ID0gX2Rpdi5jbGllbnRIZWlnaHQ7XG4gICAgICAgICAgICBfYmFzZS5zdHlsZS5oZWlnaHQgPSBfaGVpZ2h0ICsgMiAqIF9lbEhlaWdodCArICdweCc7XG4gICAgICAgIGNvbnNvbGUubG9nKCBfYmFzZS5jbGllbnRIZWlnaHQgKTtcbiAgICAgICAgfSovXG5cbiAgICB9XG5cbiAgICBfaW5pdCgpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICggaWQgKSB7XG4gICAgICAgIGlmICggaWQgKSByZXR1cm4gX3BlcmYoIGlkICk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlbGVtZW50OiBfYmFzZSxcbiAgICAgICAgICAgIHVwZGF0ZTogX3VwZGF0ZVxuICAgICAgICB9O1xuICAgIH07XG5cbn1cblxuaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gd2luZG93LnJTdGF0cztcbn1cblxufSx7fV0sMTA4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxNSBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbnZhciBVdGlsID0ge307XG5cblV0aWwuYmFzZTY0ID0gZnVuY3Rpb24obWltZVR5cGUsIGJhc2U2NCkge1xuICByZXR1cm4gJ2RhdGE6JyArIG1pbWVUeXBlICsgJztiYXNlNjQsJyArIGJhc2U2NDtcbn07XG5cblV0aWwuaXNNb2JpbGUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGNoZWNrID0gZmFsc2U7XG4gIChmdW5jdGlvbihhKXtpZigvKGFuZHJvaWR8YmJcXGQrfG1lZWdvKS4rbW9iaWxlfGF2YW50Z298YmFkYVxcL3xibGFja2JlcnJ5fGJsYXplcnxjb21wYWx8ZWxhaW5lfGZlbm5lY3xoaXB0b3B8aWVtb2JpbGV8aXAoaG9uZXxvZCl8aXJpc3xraW5kbGV8bGdlIHxtYWVtb3xtaWRwfG1tcHxtb2JpbGUuK2ZpcmVmb3h8bmV0ZnJvbnR8b3BlcmEgbShvYnxpbilpfHBhbG0oIG9zKT98cGhvbmV8cChpeGl8cmUpXFwvfHBsdWNrZXJ8cG9ja2V0fHBzcHxzZXJpZXMoNHw2KTB8c3ltYmlhbnx0cmVvfHVwXFwuKGJyb3dzZXJ8bGluayl8dm9kYWZvbmV8d2FwfHdpbmRvd3MgY2V8eGRhfHhpaW5vL2kudGVzdChhKXx8LzEyMDd8NjMxMHw2NTkwfDNnc298NHRocHw1MFsxLTZdaXw3NzBzfDgwMnN8YSB3YXxhYmFjfGFjKGVyfG9vfHNcXC0pfGFpKGtvfHJuKXxhbChhdnxjYXxjbyl8YW1vaXxhbihleHxueXx5dyl8YXB0dXxhcihjaHxnbyl8YXModGV8dXMpfGF0dHd8YXUoZGl8XFwtbXxyIHxzICl8YXZhbnxiZShja3xsbHxucSl8YmkobGJ8cmQpfGJsKGFjfGF6KXxicihlfHYpd3xidW1ifGJ3XFwtKG58dSl8YzU1XFwvfGNhcGl8Y2N3YXxjZG1cXC18Y2VsbHxjaHRtfGNsZGN8Y21kXFwtfGNvKG1wfG5kKXxjcmF3fGRhKGl0fGxsfG5nKXxkYnRlfGRjXFwtc3xkZXZpfGRpY2F8ZG1vYnxkbyhjfHApb3xkcygxMnxcXC1kKXxlbCg0OXxhaSl8ZW0obDJ8dWwpfGVyKGljfGswKXxlc2w4fGV6KFs0LTddMHxvc3x3YXx6ZSl8ZmV0Y3xmbHkoXFwtfF8pfGcxIHV8ZzU2MHxnZW5lfGdmXFwtNXxnXFwtbW98Z28oXFwud3xvZCl8Z3IoYWR8dW4pfGhhaWV8aGNpdHxoZFxcLShtfHB8dCl8aGVpXFwtfGhpKHB0fHRhKXxocCggaXxpcCl8aHNcXC1jfGh0KGMoXFwtfCB8X3xhfGd8cHxzfHQpfHRwKXxodShhd3x0Yyl8aVxcLSgyMHxnb3xtYSl8aTIzMHxpYWMoIHxcXC18XFwvKXxpYnJvfGlkZWF8aWcwMXxpa29tfGltMWt8aW5ub3xpcGFxfGlyaXN8amEodHx2KWF8amJyb3xqZW11fGppZ3N8a2RkaXxrZWppfGtndCggfFxcLyl8a2xvbnxrcHQgfGt3Y1xcLXxreW8oY3xrKXxsZShub3x4aSl8bGcoIGd8XFwvKGt8bHx1KXw1MHw1NHxcXC1bYS13XSl8bGlid3xseW54fG0xXFwtd3xtM2dhfG01MFxcL3xtYSh0ZXx1aXx4byl8bWMoMDF8MjF8Y2EpfG1cXC1jcnxtZShyY3xyaSl8bWkobzh8b2F8dHMpfG1tZWZ8bW8oMDF8MDJ8Yml8ZGV8ZG98dChcXC18IHxvfHYpfHp6KXxtdCg1MHxwMXx2ICl8bXdicHxteXdhfG4xMFswLTJdfG4yMFsyLTNdfG4zMCgwfDIpfG41MCgwfDJ8NSl8bjcoMCgwfDEpfDEwKXxuZSgoY3xtKVxcLXxvbnx0Znx3Znx3Z3x3dCl8bm9rKDZ8aSl8bnpwaHxvMmltfG9wKHRpfHd2KXxvcmFufG93ZzF8cDgwMHxwYW4oYXxkfHQpfHBkeGd8cGcoMTN8XFwtKFsxLThdfGMpKXxwaGlsfHBpcmV8cGwoYXl8dWMpfHBuXFwtMnxwbyhja3xydHxzZSl8cHJveHxwc2lvfHB0XFwtZ3xxYVxcLWF8cWMoMDd8MTJ8MjF8MzJ8NjB8XFwtWzItN118aVxcLSl8cXRla3xyMzgwfHI2MDB8cmFrc3xyaW05fHJvKHZlfHpvKXxzNTVcXC98c2EoZ2V8bWF8bW18bXN8bnl8dmEpfHNjKDAxfGhcXC18b298cFxcLSl8c2RrXFwvfHNlKGMoXFwtfDB8MSl8NDd8bWN8bmR8cmkpfHNnaFxcLXxzaGFyfHNpZShcXC18bSl8c2tcXC0wfHNsKDQ1fGlkKXxzbShhbHxhcnxiM3xpdHx0NSl8c28oZnR8bnkpfHNwKDAxfGhcXC18dlxcLXx2ICl8c3koMDF8bWIpfHQyKDE4fDUwKXx0NigwMHwxMHwxOCl8dGEoZ3R8bGspfHRjbFxcLXx0ZGdcXC18dGVsKGl8bSl8dGltXFwtfHRcXC1tb3x0byhwbHxzaCl8dHMoNzB8bVxcLXxtM3xtNSl8dHhcXC05fHVwKFxcLmJ8ZzF8c2kpfHV0c3R8djQwMHx2NzUwfHZlcml8dmkocmd8dGUpfHZrKDQwfDVbMC0zXXxcXC12KXx2bTQwfHZvZGF8dnVsY3x2eCg1Mnw1M3w2MHw2MXw3MHw4MHw4MXw4M3w4NXw5OCl8dzNjKFxcLXwgKXx3ZWJjfHdoaXR8d2koZyB8bmN8bncpfHdtbGJ8d29udXx4NzAwfHlhc1xcLXx5b3VyfHpldG98enRlXFwtL2kudGVzdChhLnN1YnN0cigwLDQpKSljaGVjayA9IHRydWV9KShuYXZpZ2F0b3IudXNlckFnZW50fHxuYXZpZ2F0b3IudmVuZG9yfHx3aW5kb3cub3BlcmEpO1xuICByZXR1cm4gY2hlY2s7XG59O1xuXG5VdGlsLmlzSU9TID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAvKGlQYWR8aVBob25lfGlQb2QpL2cudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbn07XG5cblV0aWwuaXNJRnJhbWUgPSBmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gd2luZG93LnNlbGYgIT09IHdpbmRvdy50b3A7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuVXRpbC5hcHBlbmRRdWVyeVBhcmFtZXRlciA9IGZ1bmN0aW9uKHVybCwga2V5LCB2YWx1ZSkge1xuICAvLyBEZXRlcm1pbmUgZGVsaW1pdGVyIGJhc2VkIG9uIGlmIHRoZSBVUkwgYWxyZWFkeSBHRVQgcGFyYW1ldGVycyBpbiBpdC5cbiAgdmFyIGRlbGltaXRlciA9ICh1cmwuaW5kZXhPZignPycpIDwgMCA/ICc/JyA6ICcmJyk7XG4gIHVybCArPSBkZWxpbWl0ZXIgKyBrZXkgKyAnPScgKyB2YWx1ZTtcbiAgcmV0dXJuIHVybDtcbn07XG5cbi8vIEZyb20gaHR0cDovL2dvby5nbC80V1gzdGdcblV0aWwuZ2V0UXVlcnlQYXJhbWV0ZXIgPSBmdW5jdGlvbihuYW1lKSB7XG4gIG5hbWUgPSBuYW1lLnJlcGxhY2UoL1tcXFtdLywgXCJcXFxcW1wiKS5yZXBsYWNlKC9bXFxdXS8sIFwiXFxcXF1cIik7XG4gIHZhciByZWdleCA9IG5ldyBSZWdFeHAoXCJbXFxcXD8mXVwiICsgbmFtZSArIFwiPShbXiYjXSopXCIpLFxuICAgICAgcmVzdWx0cyA9IHJlZ2V4LmV4ZWMobG9jYXRpb24uc2VhcmNoKTtcbiAgcmV0dXJuIHJlc3VsdHMgPT09IG51bGwgPyBcIlwiIDogZGVjb2RlVVJJQ29tcG9uZW50KHJlc3VsdHNbMV0ucmVwbGFjZSgvXFwrL2csIFwiIFwiKSk7XG59O1xuXG5VdGlsLmlzTGFuZHNjYXBlTW9kZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKHdpbmRvdy5vcmllbnRhdGlvbiA9PSA5MCB8fCB3aW5kb3cub3JpZW50YXRpb24gPT0gLTkwKTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBVdGlsO1xuXG59LHt9XSwxMDk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLypcbiAqIENvcHlyaWdodCAyMDE1IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxudmFyIFV0aWwgPSBfZGVyZXFfKCcuL3V0aWwuanMnKTtcblxuLyoqXG4gKiBBbmRyb2lkIGFuZCBpT1MgY29tcGF0aWJsZSB3YWtlbG9jayBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBSZWZhY3RvcmVkIHRoYW5rcyB0byBka292YWxldkAuXG4gKi9cbmZ1bmN0aW9uIEFuZHJvaWRXYWtlTG9jaygpIHtcbiAgdmFyIHZpZGVvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKTtcblxuICB2aWRlby5hZGRFdmVudExpc3RlbmVyKCdlbmRlZCcsIGZ1bmN0aW9uKCkge1xuICAgIHZpZGVvLnBsYXkoKTtcbiAgfSk7XG5cbiAgdGhpcy5yZXF1ZXN0ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHZpZGVvLnBhdXNlZCkge1xuICAgICAgLy8gQmFzZTY0IHZlcnNpb24gb2YgdmlkZW9zX3NyYy9uby1zbGVlcC02MHMud2VibS5cbiAgICAgIHZpZGVvLnNyYyA9IFV0aWwuYmFzZTY0KCd2aWRlby93ZWJtJywgJ0drWGZvd0VBQUFBQUFBQWZRb2FCQVVMM2dRRkM4b0VFUXZPQkNFS0NoSGRsWW0xQ2g0RUNRb1dCQWhoVGdHY0JBQUFBQUFBSDR4Rk5tM1JBTEUyN2kxT3JoQlZKcVdaVHJJSGZUYnVNVTZ1RUZsU3VhMU9zZ2dFd1RidU1VNnVFSEZPN2ExT3NnZ2ZHN0FFQUFBQUFBQUNrQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBVlNhbG1BUUFBQUFBQUFFVXExN0dERDBKQVRZQ05UR0YyWmpVMkxqUXdMakV3TVZkQmpVeGhkbVkxTmk0ME1DNHhNREZ6cEpBR1NKVE1ic0xwRHQveVNraXBnWDFmUkltSVFPMU1BQUFBQUFBV1ZLNXJBUUFBQUFBQUFEdXVBUUFBQUFBQUFETFhnUUZ6eFlFQm5JRUFJcldjZzNWdVpJYUZWbDlXVURtRGdRRWo0NE9FTzVyS0FPQUJBQUFBQUFBQUJyQ0JzTHFCa0I5RHRuVUJBQUFBQUFBQW8rZUJBS09tZ1FBQWdLSkpnMElBQVY0QkhzQUhCSU9EQ29BQUNtSDJNQUFBWnhnejRkUFNURmk1SkFDamxvRUQ2QUNtQUVDU25BQk1RQUFEWUFBQVdpMHF1b0NqbG9FSDBBQ21BRUNTbkFCTndBQURZQUFBV2kwcXVvQ2psb0VMdUFDbUFFQ1NuQUJOZ0FBRFlBQUFXaTBxdW9DamxvRVBvQUNtQUVDU25BQk5ZQUFEWUFBQVdpMHF1b0NqbG9FVGlBQ21BRUNTbkFCTklBQURZQUFBV2kwcXVvQWZRN1oxQVFBQUFBQUFBSlRuZ2hkd281YUJBQUFBcGdCQWtwd0FUT0FBQTJBQUFGb3RLcnFBbzVhQkErZ0FwZ0JBa3B3QVRNQUFBMkFBQUZvdEtycUFvNWFCQjlBQXBnQkFrcHdBVElBQUEyQUFBRm90S3JxQW81YUJDN2dBcGdCQWtwd0FURUFBQTJBQUFGb3RLcnFBbzVhQkQ2QUFwZ0RBa3B3QVEyQUFBMkFBQUZvdEtycUFvNWFCRTRnQXBnQkFrcHdBVENBQUEyQUFBRm90S3JxQUgwTzJkUUVBQUFBQUFBQ1U1NEl1NEtPV2dRQUFBS1lBUUpLY0FFdkFBQU5nQUFCYUxTcTZnS09XZ1FQb0FLWUFRSktjQUV0Z0FBTmdBQUJhTFNxNmdLT1dnUWZRQUtZQVFKS2NBRXNBQUFOZ0FBQmFMU3E2Z0tPV2dRdTRBS1lBUUpLY0FFcUFBQU5nQUFCYUxTcTZnS09XZ1ErZ0FLWUFRSktjQUVvZ0FBTmdBQUJhTFNxNmdLT1dnUk9JQUtZQVFKS2NBRW5BQUFOZ0FBQmFMU3E2Z0I5RHRuVUJBQUFBQUFBQWxPZUNSbENqbG9FQUFBQ21BRUNTbkFCSmdBQURZQUFBV2kwcXVvQ2psb0VENkFDbUFFQ1NuQUJKSUFBRFlBQUFXaTBxdW9DamxvRUgwQUNtQU1DU25BQkRZQUFEWUFBQVdpMHF1b0NqbG9FTHVBQ21BRUNTbkFCSTRBQURZQUFBV2kwcXVvQ2psb0VQb0FDbUFFQ1NuQUJJb0FBRFlBQUFXaTBxdW9DamxvRVRpQUNtQUVDU25BQklZQUFEWUFBQVdpMHF1b0FmUTdaMUFRQUFBQUFBQUpUbmdsM0FvNWFCQUFBQXBnQkFrcHdBU0NBQUEyQUFBRm90S3JxQW81YUJBK2dBcGdCQWtwd0FTQUFBQTJBQUFGb3RLcnFBbzVhQkI5QUFwZ0JBa3B3QVI4QUFBMkFBQUZvdEtycUFvNWFCQzdnQXBnQkFrcHdBUjRBQUEyQUFBRm90S3JxQW81YUJENkFBcGdCQWtwd0FSMkFBQTJBQUFGb3RLcnFBbzVhQkU0Z0FwZ0JBa3B3QVJ5QUFBMkFBQUZvdEtycUFIME8yZFFFQUFBQUFBQUNVNTRKMU1LT1dnUUFBQUtZQXdKS2NBRU5nQUFOZ0FBQmFMU3E2Z0tPV2dRUG9BS1lBUUpLY0FFYmdBQU5nQUFCYUxTcTZnS09XZ1FmUUFLWUFRSktjQUVhZ0FBTmdBQUJhTFNxNmdLT1dnUXU0QUtZQVFKS2NBRWFBQUFOZ0FBQmFMU3E2Z0tPV2dRK2dBS1lBUUpLY0FFWkFBQU5nQUFCYUxTcTZnS09XZ1JPSUFLWUFRSktjQUVZQUFBTmdBQUJhTFNxNmdCOUR0blVCQUFBQUFBQUFsT2VDaktDamxvRUFBQUNtQUVDU25BQkY0QUFEWUFBQVdpMHF1b0NqbG9FRDZBQ21BRUNTbkFCRndBQURZQUFBV2kwcXVvQ2psb0VIMEFDbUFFQ1NuQUJGb0FBRFlBQUFXaTBxdW9DamxvRUx1QUNtQUVDU25BQkZnQUFEWUFBQVdpMHF1b0NqbG9FUG9BQ21BTUNTbkFCRFlBQURZQUFBV2kwcXVvQ2psb0VUaUFDbUFFQ1NuQUJGWUFBRFlBQUFXaTBxdW9BZlE3WjFBUUFBQUFBQUFKVG5ncVFRbzVhQkFBQUFwZ0JBa3B3QVJVQUFBMkFBQUZvdEtycUFvNWFCQStnQXBnQkFrcHdBUlNBQUEyQUFBRm90S3JxQW81YUJCOUFBcGdCQWtwd0FSUUFBQTJBQUFGb3RLcnFBbzVhQkM3Z0FwZ0JBa3B3QVJRQUFBMkFBQUZvdEtycUFvNWFCRDZBQXBnQkFrcHdBUk9BQUEyQUFBRm90S3JxQW81YUJFNGdBcGdCQWtwd0FSTUFBQTJBQUFGb3RLcnFBSDBPMmRRRUFBQUFBQUFDVTU0SzdnS09XZ1FBQUFLWUFRSktjQUVTZ0FBTmdBQUJhTFNxNmdLT1dnUVBvQUtZQVFKS2NBRVNBQUFOZ0FBQmFMU3E2Z0tPV2dRZlFBS1lBd0pLY0FFTmdBQU5nQUFCYUxTcTZnS09XZ1F1NEFLWUFRSktjQUVSZ0FBTmdBQUJhTFNxNmdLT1dnUStnQUtZQVFKS2NBRVJBQUFOZ0FBQmFMU3E2Z0tPV2dST0lBS1lBUUpLY0FFUWdBQU5nQUFCYUxTcTZnQjlEdG5VQkFBQUFBQUFBbE9lQzB2Q2psb0VBQUFDbUFFQ1NuQUJFSUFBRFlBQUFXaTBxdW9DamxvRUQ2QUNtQUVDU25BQkVBQUFEWUFBQVdpMHF1b0NqbG9FSDBBQ21BRUNTbkFCRDRBQURZQUFBV2kwcXVvQ2psb0VMdUFDbUFFQ1NuQUJEd0FBRFlBQUFXaTBxdW9DamxvRVBvQUNtQUVDU25BQkRvQUFEWUFBQVdpMHF1b0NqbG9FVGlBQ21BRUNTbkFCRGdBQURZQUFBV2kwcXVvQWNVN3RyQVFBQUFBQUFBQkc3ajdPQkFMZUs5NEVCOFlJQmQvQ0JBdz09Jyk7XG4gICAgICB2aWRlby5wbGF5KCk7XG4gICAgfVxuICB9O1xuXG4gIHRoaXMucmVsZWFzZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZpZGVvLnBhdXNlKCk7XG4gICAgdmlkZW8uc3JjID0gJyc7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGlPU1dha2VMb2NrKCkge1xuICB2YXIgdGltZXIgPSBudWxsO1xuXG4gIHRoaXMucmVxdWVzdCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGltZXIpIHtcbiAgICAgIHRpbWVyID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbiA9IHdpbmRvdy5sb2NhdGlvbjtcbiAgICAgICAgc2V0VGltZW91dCh3aW5kb3cuc3RvcCwgMCk7XG4gICAgICB9LCAzMDAwMCk7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5yZWxlYXNlID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRpbWVyKSB7XG4gICAgICBjbGVhckludGVydmFsKHRpbWVyKTtcbiAgICAgIHRpbWVyID0gbnVsbDtcbiAgICB9XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBnZXRXYWtlTG9jaygpIHtcbiAgdmFyIHVzZXJBZ2VudCA9IG5hdmlnYXRvci51c2VyQWdlbnQgfHwgbmF2aWdhdG9yLnZlbmRvciB8fCB3aW5kb3cub3BlcmE7XG4gIGlmICh1c2VyQWdlbnQubWF0Y2goL2lQaG9uZS9pKSB8fCB1c2VyQWdlbnQubWF0Y2goL2lQb2QvaSkpIHtcbiAgICByZXR1cm4gaU9TV2FrZUxvY2s7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIEFuZHJvaWRXYWtlTG9jaztcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFdha2VMb2NrKCk7XG5cbn0se1wiLi91dGlsLmpzXCI6MTA4fV19LHt9LFs4OF0pKDg4KVxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZnJhbWUuanMubWFwXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9hZnJhbWUvZGlzdC9hZnJhbWUuanNcbiAqKiBtb2R1bGUgaWQgPSAyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgbmV4dFRpY2sgPSByZXF1aXJlKCdwcm9jZXNzL2Jyb3dzZXIuanMnKS5uZXh0VGljaztcbnZhciBhcHBseSA9IEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseTtcbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciBpbW1lZGlhdGVJZHMgPSB7fTtcbnZhciBuZXh0SW1tZWRpYXRlSWQgPSAwO1xuXG4vLyBET00gQVBJcywgZm9yIGNvbXBsZXRlbmVzc1xuXG5leHBvcnRzLnNldFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0VGltZW91dCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhclRpbWVvdXQpO1xufTtcbmV4cG9ydHMuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0SW50ZXJ2YWwsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJJbnRlcnZhbCk7XG59O1xuZXhwb3J0cy5jbGVhclRpbWVvdXQgPVxuZXhwb3J0cy5jbGVhckludGVydmFsID0gZnVuY3Rpb24odGltZW91dCkgeyB0aW1lb3V0LmNsb3NlKCk7IH07XG5cbmZ1bmN0aW9uIFRpbWVvdXQoaWQsIGNsZWFyRm4pIHtcbiAgdGhpcy5faWQgPSBpZDtcbiAgdGhpcy5fY2xlYXJGbiA9IGNsZWFyRm47XG59XG5UaW1lb3V0LnByb3RvdHlwZS51bnJlZiA9IFRpbWVvdXQucHJvdG90eXBlLnJlZiA9IGZ1bmN0aW9uKCkge307XG5UaW1lb3V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9jbGVhckZuLmNhbGwod2luZG93LCB0aGlzLl9pZCk7XG59O1xuXG4vLyBEb2VzIG5vdCBzdGFydCB0aGUgdGltZSwganVzdCBzZXRzIHVwIHRoZSBtZW1iZXJzIG5lZWRlZC5cbmV4cG9ydHMuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSwgbXNlY3MpIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IG1zZWNzO1xufTtcblxuZXhwb3J0cy51bmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IC0xO1xufTtcblxuZXhwb3J0cy5fdW5yZWZBY3RpdmUgPSBleHBvcnRzLmFjdGl2ZSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuXG4gIHZhciBtc2VjcyA9IGl0ZW0uX2lkbGVUaW1lb3V0O1xuICBpZiAobXNlY3MgPj0gMCkge1xuICAgIGl0ZW0uX2lkbGVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uIG9uVGltZW91dCgpIHtcbiAgICAgIGlmIChpdGVtLl9vblRpbWVvdXQpXG4gICAgICAgIGl0ZW0uX29uVGltZW91dCgpO1xuICAgIH0sIG1zZWNzKTtcbiAgfVxufTtcblxuLy8gVGhhdCdzIG5vdCBob3cgbm9kZS5qcyBpbXBsZW1lbnRzIGl0IGJ1dCB0aGUgZXhwb3NlZCBhcGkgaXMgdGhlIHNhbWUuXG5leHBvcnRzLnNldEltbWVkaWF0ZSA9IHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHNldEltbWVkaWF0ZSA6IGZ1bmN0aW9uKGZuKSB7XG4gIHZhciBpZCA9IG5leHRJbW1lZGlhdGVJZCsrO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPCAyID8gZmFsc2UgOiBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgaW1tZWRpYXRlSWRzW2lkXSA9IHRydWU7XG5cbiAgbmV4dFRpY2soZnVuY3Rpb24gb25OZXh0VGljaygpIHtcbiAgICBpZiAoaW1tZWRpYXRlSWRzW2lkXSkge1xuICAgICAgLy8gZm4uY2FsbCgpIGlzIGZhc3RlciBzbyB3ZSBvcHRpbWl6ZSBmb3IgdGhlIGNvbW1vbiB1c2UtY2FzZVxuICAgICAgLy8gQHNlZSBodHRwOi8vanNwZXJmLmNvbS9jYWxsLWFwcGx5LXNlZ3VcbiAgICAgIGlmIChhcmdzKSB7XG4gICAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm4uY2FsbChudWxsKTtcbiAgICAgIH1cbiAgICAgIC8vIFByZXZlbnQgaWRzIGZyb20gbGVha2luZ1xuICAgICAgZXhwb3J0cy5jbGVhckltbWVkaWF0ZShpZCk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gaWQ7XG59O1xuXG5leHBvcnRzLmNsZWFySW1tZWRpYXRlID0gdHlwZW9mIGNsZWFySW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIgPyBjbGVhckltbWVkaWF0ZSA6IGZ1bmN0aW9uKGlkKSB7XG4gIGRlbGV0ZSBpbW1lZGlhdGVJZHNbaWRdO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqICh3ZWJwYWNrKS9+L25vZGUtbGlicy1icm93c2VyL34vdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qc1xuICoqIG1vZHVsZSBpZCA9IDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBzZXRUaW1lb3V0KGRyYWluUXVldWUsIDApO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAod2VicGFjaykvfi9ub2RlLWxpYnMtYnJvd3Nlci9+L3Byb2Nlc3MvYnJvd3Nlci5qc1xuICoqIG1vZHVsZSBpZCA9IDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2luZGV4LmpzISEuL21haW4uc2Nzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCB7fSk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvaW5kZXguanMhIS4vbWFpbi5zY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2luZGV4LmpzISEuL21haW4uc2Nzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3N0eWxlcy9tYWluLnNjc3NcbiAqKiBtb2R1bGUgaWQgPSA1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcImh0bWwsIGJvZHkge1xcbiAgbWFyZ2luOiAwO1xcbiAgcGFkZGluZzogMDsgfVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2Nzcy1sb2FkZXIhLi9+L3Nhc3MtbG9hZGVyIS4vc3R5bGVzL21haW4uc2Nzc1xuICoqIG1vZHVsZSBpZCA9IDZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIGxpc3QgPSBbXTtcclxuXHJcblx0Ly8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xyXG5cdGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcclxuXHRcdHZhciByZXN1bHQgPSBbXTtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBpdGVtID0gdGhpc1tpXTtcclxuXHRcdFx0aWYoaXRlbVsyXSkge1xyXG5cdFx0XHRcdHJlc3VsdC5wdXNoKFwiQG1lZGlhIFwiICsgaXRlbVsyXSArIFwie1wiICsgaXRlbVsxXSArIFwifVwiKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRyZXN1bHQucHVzaChpdGVtWzFdKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHJlc3VsdC5qb2luKFwiXCIpO1xyXG5cdH07XHJcblxyXG5cdC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XHJcblx0bGlzdC5pID0gZnVuY3Rpb24obW9kdWxlcywgbWVkaWFRdWVyeSkge1xyXG5cdFx0aWYodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpXHJcblx0XHRcdG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsIFwiXCJdXTtcclxuXHRcdHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgaWQgPSB0aGlzW2ldWzBdO1xyXG5cdFx0XHRpZih0eXBlb2YgaWQgPT09IFwibnVtYmVyXCIpXHJcblx0XHRcdFx0YWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xyXG5cdFx0fVxyXG5cdFx0Zm9yKGkgPSAwOyBpIDwgbW9kdWxlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgaXRlbSA9IG1vZHVsZXNbaV07XHJcblx0XHRcdC8vIHNraXAgYWxyZWFkeSBpbXBvcnRlZCBtb2R1bGVcclxuXHRcdFx0Ly8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBub3QgMTAwJSBwZXJmZWN0IGZvciB3ZWlyZCBtZWRpYSBxdWVyeSBjb21iaW5hdGlvbnNcclxuXHRcdFx0Ly8gIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cclxuXHRcdFx0Ly8gIEkgaG9wZSB0aGlzIHdpbGwgbmV2ZXIgb2NjdXIgKEhleSB0aGlzIHdheSB3ZSBoYXZlIHNtYWxsZXIgYnVuZGxlcylcclxuXHRcdFx0aWYodHlwZW9mIGl0ZW1bMF0gIT09IFwibnVtYmVyXCIgfHwgIWFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcclxuXHRcdFx0XHRpZihtZWRpYVF1ZXJ5ICYmICFpdGVtWzJdKSB7XHJcblx0XHRcdFx0XHRpdGVtWzJdID0gbWVkaWFRdWVyeTtcclxuXHRcdFx0XHR9IGVsc2UgaWYobWVkaWFRdWVyeSkge1xyXG5cdFx0XHRcdFx0aXRlbVsyXSA9IFwiKFwiICsgaXRlbVsyXSArIFwiKSBhbmQgKFwiICsgbWVkaWFRdWVyeSArIFwiKVwiO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRsaXN0LnB1c2goaXRlbSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9O1xyXG5cdHJldHVybiBsaXN0O1xyXG59O1xyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1xuICoqIG1vZHVsZSBpZCA9IDdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbnZhciBzdHlsZXNJbkRvbSA9IHt9LFxyXG5cdG1lbW9pemUgPSBmdW5jdGlvbihmbikge1xyXG5cdFx0dmFyIG1lbW87XHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRpZiAodHlwZW9mIG1lbW8gPT09IFwidW5kZWZpbmVkXCIpIG1lbW8gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG5cdFx0XHRyZXR1cm4gbWVtbztcclxuXHRcdH07XHJcblx0fSxcclxuXHRpc09sZElFID0gbWVtb2l6ZShmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiAvbXNpZSBbNi05XVxcYi8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpKTtcclxuXHR9KSxcclxuXHRnZXRIZWFkRWxlbWVudCA9IG1lbW9pemUoZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdO1xyXG5cdH0pLFxyXG5cdHNpbmdsZXRvbkVsZW1lbnQgPSBudWxsLFxyXG5cdHNpbmdsZXRvbkNvdW50ZXIgPSAwLFxyXG5cdHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wID0gW107XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxpc3QsIG9wdGlvbnMpIHtcclxuXHRpZih0eXBlb2YgREVCVUcgIT09IFwidW5kZWZpbmVkXCIgJiYgREVCVUcpIHtcclxuXHRcdGlmKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJvYmplY3RcIikgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHN0eWxlLWxvYWRlciBjYW5ub3QgYmUgdXNlZCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50XCIpO1xyXG5cdH1cclxuXHJcblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblx0Ly8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XHJcblx0Ly8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxyXG5cdGlmICh0eXBlb2Ygb3B0aW9ucy5zaW5nbGV0b24gPT09IFwidW5kZWZpbmVkXCIpIG9wdGlvbnMuc2luZ2xldG9uID0gaXNPbGRJRSgpO1xyXG5cclxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSBib3R0b20gb2YgPGhlYWQ+LlxyXG5cdGlmICh0eXBlb2Ygb3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJ1bmRlZmluZWRcIikgb3B0aW9ucy5pbnNlcnRBdCA9IFwiYm90dG9tXCI7XHJcblxyXG5cdHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMobGlzdCk7XHJcblx0YWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZShuZXdMaXN0KSB7XHJcblx0XHR2YXIgbWF5UmVtb3ZlID0gW107XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xyXG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcclxuXHRcdFx0ZG9tU3R5bGUucmVmcy0tO1xyXG5cdFx0XHRtYXlSZW1vdmUucHVzaChkb21TdHlsZSk7XHJcblx0XHR9XHJcblx0XHRpZihuZXdMaXN0KSB7XHJcblx0XHRcdHZhciBuZXdTdHlsZXMgPSBsaXN0VG9TdHlsZXMobmV3TGlzdCk7XHJcblx0XHRcdGFkZFN0eWxlc1RvRG9tKG5ld1N0eWxlcywgb3B0aW9ucyk7XHJcblx0XHR9XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbWF5UmVtb3ZlLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBkb21TdHlsZSA9IG1heVJlbW92ZVtpXTtcclxuXHRcdFx0aWYoZG9tU3R5bGUucmVmcyA9PT0gMCkge1xyXG5cdFx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKylcclxuXHRcdFx0XHRcdGRvbVN0eWxlLnBhcnRzW2pdKCk7XHJcblx0XHRcdFx0ZGVsZXRlIHN0eWxlc0luRG9tW2RvbVN0eWxlLmlkXTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucykge1xyXG5cdGZvcih2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xyXG5cdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XHJcblx0XHRpZihkb21TdHlsZSkge1xyXG5cdFx0XHRkb21TdHlsZS5yZWZzKys7XHJcblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xyXG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzW2pdKGl0ZW0ucGFydHNbal0pO1xyXG5cdFx0XHR9XHJcblx0XHRcdGZvcig7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XHJcblx0XHRcdFx0ZG9tU3R5bGUucGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHZhciBwYXJ0cyA9IFtdO1xyXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xyXG5cdFx0XHRcdHBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHN0eWxlc0luRG9tW2l0ZW0uaWRdID0ge2lkOiBpdGVtLmlkLCByZWZzOiAxLCBwYXJ0czogcGFydHN9O1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gbGlzdFRvU3R5bGVzKGxpc3QpIHtcclxuXHR2YXIgc3R5bGVzID0gW107XHJcblx0dmFyIG5ld1N0eWxlcyA9IHt9O1xyXG5cdGZvcih2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XHJcblx0XHR2YXIgaXRlbSA9IGxpc3RbaV07XHJcblx0XHR2YXIgaWQgPSBpdGVtWzBdO1xyXG5cdFx0dmFyIGNzcyA9IGl0ZW1bMV07XHJcblx0XHR2YXIgbWVkaWEgPSBpdGVtWzJdO1xyXG5cdFx0dmFyIHNvdXJjZU1hcCA9IGl0ZW1bM107XHJcblx0XHR2YXIgcGFydCA9IHtjc3M6IGNzcywgbWVkaWE6IG1lZGlhLCBzb3VyY2VNYXA6IHNvdXJjZU1hcH07XHJcblx0XHRpZighbmV3U3R5bGVzW2lkXSlcclxuXHRcdFx0c3R5bGVzLnB1c2gobmV3U3R5bGVzW2lkXSA9IHtpZDogaWQsIHBhcnRzOiBbcGFydF19KTtcclxuXHRcdGVsc2VcclxuXHRcdFx0bmV3U3R5bGVzW2lkXS5wYXJ0cy5wdXNoKHBhcnQpO1xyXG5cdH1cclxuXHRyZXR1cm4gc3R5bGVzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgc3R5bGVFbGVtZW50KSB7XHJcblx0dmFyIGhlYWQgPSBnZXRIZWFkRWxlbWVudCgpO1xyXG5cdHZhciBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCA9IHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wW3N0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLmxlbmd0aCAtIDFdO1xyXG5cdGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcInRvcFwiKSB7XHJcblx0XHRpZighbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3ApIHtcclxuXHRcdFx0aGVhZC5pbnNlcnRCZWZvcmUoc3R5bGVFbGVtZW50LCBoZWFkLmZpcnN0Q2hpbGQpO1xyXG5cdFx0fSBlbHNlIGlmKGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKSB7XHJcblx0XHRcdGhlYWQuaW5zZXJ0QmVmb3JlKHN0eWxlRWxlbWVudCwgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0aGVhZC5hcHBlbmRDaGlsZChzdHlsZUVsZW1lbnQpO1xyXG5cdFx0fVxyXG5cdFx0c3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AucHVzaChzdHlsZUVsZW1lbnQpO1xyXG5cdH0gZWxzZSBpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJib3R0b21cIikge1xyXG5cdFx0aGVhZC5hcHBlbmRDaGlsZChzdHlsZUVsZW1lbnQpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgJ2luc2VydEF0Jy4gTXVzdCBiZSAndG9wJyBvciAnYm90dG9tJy5cIik7XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KSB7XHJcblx0c3R5bGVFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50KTtcclxuXHR2YXIgaWR4ID0gc3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AuaW5kZXhPZihzdHlsZUVsZW1lbnQpO1xyXG5cdGlmKGlkeCA+PSAwKSB7XHJcblx0XHRzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5zcGxpY2UoaWR4LCAxKTtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKSB7XHJcblx0dmFyIHN0eWxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcclxuXHRzdHlsZUVsZW1lbnQudHlwZSA9IFwidGV4dC9jc3NcIjtcclxuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgc3R5bGVFbGVtZW50KTtcclxuXHRyZXR1cm4gc3R5bGVFbGVtZW50O1xyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVMaW5rRWxlbWVudChvcHRpb25zKSB7XHJcblx0dmFyIGxpbmtFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIik7XHJcblx0bGlua0VsZW1lbnQucmVsID0gXCJzdHlsZXNoZWV0XCI7XHJcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIGxpbmtFbGVtZW50KTtcclxuXHRyZXR1cm4gbGlua0VsZW1lbnQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZFN0eWxlKG9iaiwgb3B0aW9ucykge1xyXG5cdHZhciBzdHlsZUVsZW1lbnQsIHVwZGF0ZSwgcmVtb3ZlO1xyXG5cclxuXHRpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcclxuXHRcdHZhciBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrO1xyXG5cdFx0c3R5bGVFbGVtZW50ID0gc2luZ2xldG9uRWxlbWVudCB8fCAoc2luZ2xldG9uRWxlbWVudCA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKSk7XHJcblx0XHR1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50LCBzdHlsZUluZGV4LCBmYWxzZSk7XHJcblx0XHRyZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50LCBzdHlsZUluZGV4LCB0cnVlKTtcclxuXHR9IGVsc2UgaWYob2JqLnNvdXJjZU1hcCAmJlxyXG5cdFx0dHlwZW9mIFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXHJcblx0XHR0eXBlb2YgVVJMLmNyZWF0ZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXHJcblx0XHR0eXBlb2YgVVJMLnJldm9rZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXHJcblx0XHR0eXBlb2YgQmxvYiA9PT0gXCJmdW5jdGlvblwiICYmXHJcblx0XHR0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcblx0XHRzdHlsZUVsZW1lbnQgPSBjcmVhdGVMaW5rRWxlbWVudChvcHRpb25zKTtcclxuXHRcdHVwZGF0ZSA9IHVwZGF0ZUxpbmsuYmluZChudWxsLCBzdHlsZUVsZW1lbnQpO1xyXG5cdFx0cmVtb3ZlID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpO1xyXG5cdFx0XHRpZihzdHlsZUVsZW1lbnQuaHJlZilcclxuXHRcdFx0XHRVUkwucmV2b2tlT2JqZWN0VVJMKHN0eWxlRWxlbWVudC5ocmVmKTtcclxuXHRcdH07XHJcblx0fSBlbHNlIHtcclxuXHRcdHN0eWxlRWxlbWVudCA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKTtcclxuXHRcdHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQpO1xyXG5cdFx0cmVtb3ZlID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpO1xyXG5cdFx0fTtcclxuXHR9XHJcblxyXG5cdHVwZGF0ZShvYmopO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUobmV3T2JqKSB7XHJcblx0XHRpZihuZXdPYmopIHtcclxuXHRcdFx0aWYobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJiBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJiBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwKVxyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0dXBkYXRlKG9iaiA9IG5ld09iaik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZW1vdmUoKTtcclxuXHRcdH1cclxuXHR9O1xyXG59XHJcblxyXG52YXIgcmVwbGFjZVRleHQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdHZhciB0ZXh0U3RvcmUgPSBbXTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZW1lbnQpIHtcclxuXHRcdHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudDtcclxuXHRcdHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpO1xyXG5cdH07XHJcbn0pKCk7XHJcblxyXG5mdW5jdGlvbiBhcHBseVRvU2luZ2xldG9uVGFnKHN0eWxlRWxlbWVudCwgaW5kZXgsIHJlbW92ZSwgb2JqKSB7XHJcblx0dmFyIGNzcyA9IHJlbW92ZSA/IFwiXCIgOiBvYmouY3NzO1xyXG5cclxuXHRpZiAoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcclxuXHRcdHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0dmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xyXG5cdFx0dmFyIGNoaWxkTm9kZXMgPSBzdHlsZUVsZW1lbnQuY2hpbGROb2RlcztcclxuXHRcdGlmIChjaGlsZE5vZGVzW2luZGV4XSkgc3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKTtcclxuXHRcdGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xyXG5cdFx0XHRzdHlsZUVsZW1lbnQuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChjc3NOb2RlKTtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFwcGx5VG9UYWcoc3R5bGVFbGVtZW50LCBvYmopIHtcclxuXHR2YXIgY3NzID0gb2JqLmNzcztcclxuXHR2YXIgbWVkaWEgPSBvYmoubWVkaWE7XHJcblxyXG5cdGlmKG1lZGlhKSB7XHJcblx0XHRzdHlsZUVsZW1lbnQuc2V0QXR0cmlidXRlKFwibWVkaWFcIiwgbWVkaWEpXHJcblx0fVxyXG5cclxuXHRpZihzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xyXG5cdFx0c3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcclxuXHR9IGVsc2Uge1xyXG5cdFx0d2hpbGUoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpIHtcclxuXHRcdFx0c3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKTtcclxuXHRcdH1cclxuXHRcdHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHVwZGF0ZUxpbmsobGlua0VsZW1lbnQsIG9iaikge1xyXG5cdHZhciBjc3MgPSBvYmouY3NzO1xyXG5cdHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwO1xyXG5cclxuXHRpZihzb3VyY2VNYXApIHtcclxuXHRcdC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI2NjAzODc1XHJcblx0XHRjc3MgKz0gXCJcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiICsgYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSArIFwiICovXCI7XHJcblx0fVxyXG5cclxuXHR2YXIgYmxvYiA9IG5ldyBCbG9iKFtjc3NdLCB7IHR5cGU6IFwidGV4dC9jc3NcIiB9KTtcclxuXHJcblx0dmFyIG9sZFNyYyA9IGxpbmtFbGVtZW50LmhyZWY7XHJcblxyXG5cdGxpbmtFbGVtZW50LmhyZWYgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xyXG5cclxuXHRpZihvbGRTcmMpXHJcblx0XHRVUkwucmV2b2tlT2JqZWN0VVJMKG9sZFNyYyk7XHJcbn1cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1xuICoqIG1vZHVsZSBpZCA9IDhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=